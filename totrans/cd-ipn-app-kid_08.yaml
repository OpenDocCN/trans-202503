- en: '**7**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FUNCTIONS ARE A PARTY, AND YOU’RE INVITED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: FUNCTIONS ARE A PARTY, AND YOU’RE INVITED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: One of the most useful tools found in every programming language is the function.
    A *function* is a block of code that you can use again and again to perform a
    specific task. You can write your own custom functions, but Swift comes with lots
    of built-in functions. You’ve already used a few, like the print(_:) function,
    which displays a string in the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**IN WITH THE INPUT, OUT WITH THE OUTPUT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Functions can take *input* and return *output* , although they don’t always
    have to. Input is information that you give to the function to perform its task,
    and output is something the function returns when it’s finished performing that
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: The type of input that a function can take is defined in its *input parameters*
    . The values you pass in for those parameters are called *arguments* . For example,
    the string that you put between the parentheses of the print(_:) function is an
    argument. Sometimes an argument will have an *argument label* that describes it.
    The print(_:) function doesn’t have an argument label, but we’ll learn more about
    labels later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, when we refer to a function with one unlabeled input parameter,
    we put a (_:) after the function name. You’ll see where that colon (: ) comes
    into play soon!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in the playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the debug area (press ⌘ -SHIFT -Y), you’ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: The print(_:) function takes an input value but does not have a return value.
    In this case, the input value is the string "Swift is awesome!" . The print(_:)
    function displays the string it’s given in the debug console and then ends without
    returning anything. A function with no return value is sometimes called a *void
    function* . We’ll see an example of a function with both input parameters and
    a return value in “[Return Values](text00017.html#ch07lev1sec5) ” on [page 91](text00017.html#page_91)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: By writing functions that work with input and return output, you can create
    all kinds of applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITING A CUSTOM FUNCTION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a simple function that prints a *haiku* , which is a traditional
    Japanese poem composed of three lines, where the first and last lines have five
    syllables and the middle line has seven syllables. Enter this into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: First, you write the func keyword ➊ , followed by your function’s name. When
    you create a function, you must give it a name so you can call it when you want
    it to perform its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for naming functions are the same as for naming variables: you start
    with a lowercase letter and capitalize each new word in the name using camel case.
    You should also give your function a name that describes what it does. Wouldn’t
    you agree that printAHaiku() is a great name for a function that prints a simple
    Swift haiku?'
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: After the function name, there’s a pair of parentheses ➋ . If your function
    has input parameters, you would include them inside these parentheses. In this
    example, you don’t have any input parameters, so you just leave the parentheses
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: The *body* of the function is enclosed in braces. This is where you’ll write
    the function’s code. You put the opening brace ({ ) on the same line as the function
    name and the closing brace (} ) on its own line at the end of the function. In
    this example, the body of the function contains all the print statements that
    print the haiku.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00152.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: To use a function, you simply write its name followed by the parentheses with
    any arguments inside them. This is a *function call* . In this case, because printAHaiku()
    has no input parameters, you don’t need to pass in any arguments—just leave the
    parentheses empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'To call printAHaiku() , add the following line to your playground after the
    closing brace of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'The console output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve defined this function, you can call it any time you want, and
    the code inside the function will run. Make sure you have the debug area open
    (⌘ -SHIFT -Y), as in [Figure 7-1](text00017.html#ch07fig1) , so you can see the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00153.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-1: The function’s output is displayed in the debug console.*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Try calling the printAHaiku() function a bunch of times!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**FUNCTIONS DO EVEN MORE WITH INPUT PARAMETERS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: In our first example, you saw how functions can save you time and effort. When
    you write a function, you can call it wherever you want instead of having to repeat
    blocks of code in many places. This is certainly cool, but the real power of functions
    comes when you pass in one or more input values to produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING PARTY INVITATIONS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a function called invite(guest:) that takes a person’s name as
    input and creates a personalized invitation to a birthday party. Enter the following
    into your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function has an input parameter, you include it in the parentheses after
    the function’s name ➊ . You format an input parameter with its name first (in
    this example, guest ), then a colon (: ), and finally its data type (String in
    this case).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: By default, the parameter name also acts as the argument label, so guest will
    be the argument label when you call this function. (You’ll learn how to define
    separate parameter names and argument labels in “[Argument Labels](text00017.html#ch07lev1sec4)
    ” on [page 89](text00017.html#page_89) .)
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: You write the data type of an input parameter after the colon, just like when
    declaring a variable. However, unlike with variable declarations, when defining
    function parameters, you must *always* declare the data type the function should
    expect; there’s no type inference here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: To use the input parameter inside the function, you simply use its parameter
    name, just as you would any other constant ➋ .
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, defining a function isn’t enough. Now that the function is defined,
    let’s call it in the playground to see what happens. You can call a function that
    has input parameters by entering the function name followed by, in parentheses,
    the argument label, a colon, and the argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: When you call a function by writing its name, Xcode’s autocomplete gives you
    a hint about what you’re supposed to pass in to the function. In this case, when
    you start writing invite , you’ll see a drop-down menu like in [Figure 7-2](text00017.html#ch07fig2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00155.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-2: Xcode’s autocomplete will show you a function’s input parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to autocomplete the function. Your cursor will move into the parentheses
    of the function (see [Figure 7-3](text00017.html#ch07fig3) ), where Xcode has
    automatically added some placeholder text telling you what type of input the function
    is expecting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00156.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-3: Xcode is waiting for you to fill in the guest parameter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you pass something that isn’t a string to invite(guest:) , such as invite(guest:
    45) , you’ll get an error because the function is expecting a string.*'
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Simply type in "Cathy" or the name of another friend in place of String , and
    then press TAB to finish filling out the function call. It should look like [Figure
    7-4](text00017.html#ch07fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-4: An invite(guest:) function call*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to fill out the function call, call invite(guest:) three
    times, using your own friends’ names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1289]'
  prefs: []
  type: TYPE_PRE
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1290]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1291]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1292]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1293]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1294]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1295]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1296]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1297]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1298]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1299]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1300]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1301]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1302]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1303]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1304]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1305]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1306]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1307]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: With your invite(guest:) function, you’re able to quickly print three party
    invitations, each addressed to a different friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1308]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1309]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1310]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1311]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1312]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1313]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1314]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1315]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1316]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1317]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1318]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1319]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1320]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1321]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1322]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1323]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1324]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1325]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**INVITING ALL YOUR FRIENDS AT ONCE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1326]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1327]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1328]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1329]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1330]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1331]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1332]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1333]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1334]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1335]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1336]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1337]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1338]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1339]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1340]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1341]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1342]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1343]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: You can also write a function that invites all of your friends at once by passing
    in an array of strings as arguments instead of a single string. In the same playground
    where you wrote invite(guest:) , write the following invite(allGuests:) function
    to test this. Notice that the parameter name is now plural because we’ll be inviting
    multiple guests at once.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1344]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1345]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1346]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1347]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1348]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1349]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1350]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1351]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1352]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1353]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1354]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1355]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1356]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1357]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1358]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1359]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1360]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1361]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00158.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1362]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1363]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1364]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1365]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1366]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1367]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1368]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1369]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1370]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1371]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1372]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1373]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1374]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1375]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1376]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1377]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1378]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1379]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1380]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1381]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1382]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1383]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1384]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1385]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1386]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1387]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1388]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1389]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1390]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1391]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1392]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1393]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1394]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1395]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1396]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1397]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: In this example, when you declare the parameter of the function, you’ll notice
    that [String] is in square brackets ➊ . The square brackets declare the data type
    as an array and String indicates the data type of the values in the array. By
    using [String] , we declare this function’s input as an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1398]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1399]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1400]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1401]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1402]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1403]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1404]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1405]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1406]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1407]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1408]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1409]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1410]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1411]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1412]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1413]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1414]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the invite(allGuests:) function, we will want to use a for-in loop to
    go through our guests array and print an invitation for each guest. Remember how
    we just created a function that prints invitations? Let’s use that here! Add the
    following to your invite(allGuests:) function (the gray text shows the existing
    lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1415]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1416]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1417]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1418]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1419]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1420]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1421]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1422]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1423]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1424]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1425]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1426]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1427]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1428]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1429]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1430]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1431]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1432]'
  prefs: []
  type: TYPE_PRE
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1433]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1434]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1435]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1436]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1437]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1438]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1439]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1440]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1441]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1442]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1443]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1444]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1445]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1446]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1447]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1448]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: In our for-in loop, we call the singular invite(guest:) function on each guest
    in the String array allGuests to invite each person to the birthday party. You
    might be wondering if invite(guest:) and invite(allGuests:) are the same function.
    After all, they’re both called invite . Despite sharing a name, however, they’re
    two different functions because they take different input parameters. This is
    a pattern that you’ll see often in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1449]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1450]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1451]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1452]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1453]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1454]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1455]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1456]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1457]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1458]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1459]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1460]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1461]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1462]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1463]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1464]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: To use the invite(allGuests:) function, we first create an array called friends
    , which we will then use in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1465]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1466]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1467]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1468]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1469]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1470]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1471]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1472]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1473]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1474]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1475]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1476]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1477]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1478]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1479]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1480]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1481]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1482]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1483]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1484]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1485]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1486]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1487]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1488]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1489]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1490]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1491]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1492]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1493]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1494]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1495]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1496]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create an array of six friends ➊ . Then we call the function with
    our new array as the function’s input ➋ . This is the output you’ll see in the
    debug console (the -- snip -- shows where we’ve omitted lines for space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1497]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1498]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1499]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1500]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1501]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1502]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1503]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1504]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1505]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1506]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1507]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1508]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1509]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1510]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1511]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1512]'
  prefs: []
  type: TYPE_PRE
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1513]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1514]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1515]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1516]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1517]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1518]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1519]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1520]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1521]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1522]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1523]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1524]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1525]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1526]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: If you had to write out the invitation for each of these friends, it would take
    a lot of work. But with the power of functions, you’ve accomplished it with very
    few lines of code. Try creating your own array of friends; make it as long as
    you want! Then call the invite(allGuests:) function with your new array as input.
    What a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1527]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1528]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1529]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1530]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1531]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1532]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1533]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1534]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1535]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1536]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1537]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1538]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1539]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1540]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**MESSAGING YOUR GUESTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1541]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1542]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1543]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1544]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1545]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1546]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1547]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1548]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1549]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1550]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1551]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1552]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1553]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1554]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the date of your party is fast approaching, and some of your guests
    haven’t RSVPed yet. You want to get a final headcount and let the guests know
    to bring a bathing suit because it’s going to be a slip-and-slide party. You can
    write a function that sends a custom message to each guest based on their RSVP
    status.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1555]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1556]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1557]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1558]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1559]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1560]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1561]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1562]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1563]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1564]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1565]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1566]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1567]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1568]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1569]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1570]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1571]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1572]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1573]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1574]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1575]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1576]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1577]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1578]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1579]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1580]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1581]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1582]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Your new function will take two input parameters: a String parameter for the
    guest’s name and a Bool parameter for the RSVP status, which is either true or
    false . Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1583]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1584]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1585]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1586]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1587]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1588]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1589]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1590]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1591]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1592]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1593]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1594]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1595]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1596]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1597]'
  prefs: []
  type: TYPE_PRE
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1598]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1599]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1600]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1601]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1602]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1603]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1604]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1605]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1606]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1607]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1608]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1609]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1610]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: When a function takes more than one input parameter, you add a comma between
    each one ➊ . Each parameter needs to have a parameter name, followed by a colon
    and the data type of the parameter. You can create a function that takes as many
    input parameters as you want, and they don’t have to be the same type. In the
    sendMessage(guest:rsvped:) function, we’re passing in a String for guest and a
    Bool for rsvped .
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1611]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1612]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1613]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1614]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1615]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1616]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1617]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1618]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1619]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1620]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1621]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1622]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1623]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we check the rsvped value to see if it’s true ➋ and then
    print the corresponding message using an if-else statement. Notice, too, that
    the final print statements in the function definition will run whether the rsvped
    value is true or false because they’re outside the braces of the if-else statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1624]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1625]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1626]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1627]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1628]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1629]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1630]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1631]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1632]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1633]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1634]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1635]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1636]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'If your guest has RSVPed, they’ll get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1637]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1638]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1639]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1640]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1641]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1642]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1643]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1644]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1645]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1646]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1647]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1648]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1649]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1650]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1651]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1652]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1653]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1654]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1655]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1656]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1657]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1658]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1659]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1660]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1661]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1662]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, they’ll get a polite note asking them to respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1663]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1664]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1665]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1666]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1667]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1668]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1669]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1670]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1671]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1672]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1673]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1674]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1675]'
  prefs: []
  type: TYPE_PRE
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1676]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1677]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1678]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1679]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1680]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1681]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1682]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1683]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1684]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1685]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1686]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s call the function to see how it works. Try setting one guest’s rsvped
    value to true and another guest’s to false so you can see both messages in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1687]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1688]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1689]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1690]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1691]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1692]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1693]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1694]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1695]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1696]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1697]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1698]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1699]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1700]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1701]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1702]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1703]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1704]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1705]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1706]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1707]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1708]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, calling a function with more than one input parameter is similar
    to calling a function that has just one input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1709]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1710]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1711]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1712]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1713]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1714]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1715]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1716]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1717]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1718]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will help you fill out the input values by providing the
    argument labels for you. All you have to do is pass in the value you want to use.
    After filling out the guest name, press TAB , and Xcode will put the cursor right
    where you need it to fill out the next input value. (See [Figure 7-5](text00017.html#ch07fig5)
    .)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1719]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1720]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1721]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1722]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1723]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1724]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1725]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1726]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1727]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1728]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1729]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1730]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1731]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1732]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1733]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1734]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1735]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1736]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1737]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1738]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-5: Pressing TAB after typing the guest’s name will move your cursor
    over to the next input field.*'
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1739]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1740]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1741]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1742]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1743]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1744]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1745]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1746]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1747]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1748]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Xcode also tells you the data type of rsvped . Replace the placeholder text
    Bool with either true or false . If you try to pass in anything else, like a name
    or number, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1749]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1750]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1751]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1752]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1753]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1754]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1755]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1756]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1757]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1758]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**ARGUMENT LABELS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1759]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1760]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1761]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1762]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1763]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1764]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1765]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1766]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1767]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1768]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you notice that when you call print(_:) , you don’t put an argument label
    in front of the input value? You write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1769]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1770]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1771]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1772]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1773]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1774]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1775]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1776]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1777]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1778]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1779]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1780]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1781]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1782]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1783]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1784]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1785]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1786]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1787]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1788]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you try to include a label, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1789]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1790]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1791]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1792]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1793]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1794]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1795]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1796]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1797]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1798]'
  prefs: []
  type: TYPE_PRE
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1799]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1800]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1801]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1802]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1803]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1804]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1805]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1806]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Some parameters have argument labels in function calls, and some don’t. By default,
    when you write a function, every parameter will have an argument label, and it
    will be the same as the parameter name. However, if you write a function and don’t
    feel like the argument label is necessary to make the code clear, then you can
    explicitly omit it in the function definition. In the print(_:) function, for
    example, it’s obvious that the input you pass in is a string that will be printed.
    Having to include an argument label like inputString every time you call print(_:)
    would be annoying.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1807]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1808]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1809]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1810]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1811]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1812]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1813]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1814]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an argument label for each parameter that is different from
    the parameter name. You do this by entering the argument label, the parameter
    name, a colon, and finally the parameter’s data type. You do all of this when
    you first declare the parameters inside the function parentheses after the func
    keyword. This is often done in Swift functions to make the function call look
    more like a sentence. [Figure 7-6](text00017.html#ch07fig6) illustrates the difference
    between an argument label and a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1815]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1816]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1817]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1818]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1819]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1820]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1821]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1822]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00161.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1823]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1824]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1825]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1826]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1827]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1828]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1829]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1830]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-6: The sayHello() function has a custom argument label.*'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1831]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1832]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1833]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1834]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1835]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1836]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1837]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1838]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: The input parameter of the sayHello(to:) function is friend , the argument label
    is to , and the passed-in argument in the function call is "Colin" . If you didn’t
    have a separate argument label, when you called the function it would look like
    sayHello(friend:) , which sounds less like a full sentence.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1839]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1840]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1841]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1842]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1843]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1844]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1845]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1846]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at writing functions with custom argument
    labels. We’ll also show you how to write a function in which you omit the argument
    labels altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1847]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1848]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1849]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1850]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1851]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1852]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1853]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1854]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING A CUSTOM ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1855]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1856]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1857]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1858]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1859]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1860]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1861]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1862]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how adding custom argument labels can make your
    code more readable. After your birthday party, you’ll want to send thank you notes
    to all of your guests. Write the following function in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1863]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1864]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1865]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1866]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1867]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1868]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1869]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1870]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1871]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1872]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1873]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1874]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1875]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1876]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1877]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1878]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we add a custom argument label, to , to the guest parameter that is passed
    in to the function. Similarly, at ➋ , we add an argument label, for , to the gift
    parameter. The parameter names, guest ➌ and gift ➍ , are used to refer to the
    parameters inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1879]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1880]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1881]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1882]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1883]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1884]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1885]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument labels, to and for , are used to label the arguments when the
    function is called, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1886]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1887]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1888]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1889]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1890]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1891]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1892]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1893]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1894]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1895]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1896]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1897]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1898]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1899]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can see that to: is written in the function call before the first
    input value, and for: is written before the second input value. If a parameter
    has a custom argument label, you have to use it in your function call. Trying
    to use the parameter names instead will give you an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1900]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1901]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1902]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1903]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1904]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1905]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1906]'
  prefs: []
  type: TYPE_PRE
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1907]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1908]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1909]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1910]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1911]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Xcode’s autocomplete will always fill in the argument labels for you, so you
    don’t have to worry about calling a function incorrectly (see [Figure 7-7](text00017.html#ch07fig7)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1912]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1913]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1914]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1915]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1916]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1917]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1918]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1919]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1920]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1921]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7-7: Xcode autocompletes a function with the correct argument labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1922]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1923]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1924]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1925]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1926]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common for programmers to use prepositions like *to* , *from* , or *with*
    as argument labels. In this example, the function is used to send a thank you
    note *to* a guest *for* a gift. The code sendThankYou(to: "Meghan", for: "puzzle
    books") reads more like a sentence than sendThankYou(guest: "Meghan", gift: "puzzle
    books") .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1927]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1928]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1929]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1930]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1931]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1932]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1933]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1934]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1935]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1936]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**REMOVING AN ARGUMENT LABEL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1937]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1938]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1939]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1940]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1941]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to use any argument labels in your function call, you can
    remove them by adding an underscore followed by a space in front of the parameter
    name. In the following example, we write a function for calculating volume that
    takes the three sides of a box as input. Because the function name makes it clear
    that you need to pass in three sides, you don’t really need argument labels to
    make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1942]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1943]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1944]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1945]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1946]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1947]'
  prefs: []
  type: TYPE_PRE
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1948]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1949]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1950]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1951]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: We remove the argument labels for the sides by placing an underscore in front
    of side1 at ➊ , side2 at ➋ , and side3 at ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1952]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1953]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1954]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1955]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Now when you call the function, you just enter the parameter values without
    any labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1956]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1957]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1958]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1959]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1960]'
  prefs: []
  type: TYPE_PRE
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1961]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1962]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1963]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: This function will output "The volume of this box is 72." . Wouldn’t it be useful
    if, instead of simply printing the volume of the box, you could store the result
    to use later in a variable or constant? Let’s find out how to do that with return
    values!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1964]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1965]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1966]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**RETURN VALUES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1967]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1968]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1969]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try rewriting the volumeOfBoxWithSides(_:_:_:) function to return the
    volume instead of printing it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1970]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1971]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1972]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHICH IS THE BIGGER BOX?**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1973]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1974]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1975]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have two differently shaped boxes and want to know which one will fit
    more stuff. First, write a volumeOfBox(_:_:_:) function that returns an Int for
    the box volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1976]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1977]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1978]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1979]'
  prefs: []
  type: TYPE_PRE
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1980]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1981]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: To give a function a return value, use a dash and a greater-than sign to form
    an arrow (-> ) just after the input parameters of the function ➊ and then enter
    the data type of the return value. Note that you don’t provide a name for the
    return value, just a data type. Inside the function body, you return the value
    by using the return keyword followed by the value that you want to return ➋ .
    If you write a function that returns a value, then you *must* return that value
    inside the function, or you’ll get an error. The function ends after you return
    the value. If you write any code inside the function after the return statement,
    it will be ignored, because return exits the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1982]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1983]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1984]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1985]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the function on two different boxes to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1986]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1987]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1988]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1989]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊ , the volumeOfBox(_:_:_:) function calculates the volume of a box with
    side lengths of 6 , 5 , and 3 , and the return value of 90 is stored in a constant
    called volumeOfBox1 . At ➋ , volumeOfBox2 with side lengths of 8 , 4 , and 2 is
    given the value of 64 . Now let’s print a message about which box is bigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1990]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1991]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1992]'
  prefs: []
  type: TYPE_PRE
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1993]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: You should see the string "Box 1 is the bigger box." output in your debug console.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1994]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**CONDITIONAL RETURNS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1995]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to return a different value depending on a condition. Let’s write
    a function that takes an array of test scores and returns the average score. To
    get the average, you add the scores together and then divide by the total number
    of scores. Enter the following code in your playground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1996]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1997]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll need to find the sum of all the values. At ➊ , we define an Int
    variable called sum and sets it to an initial value of 0 . The for-in loop at
    ➋ goes through each value in the scores array and adds it to the sum variable.
    When the loop is complete, the variable sum holds the sum of all of the scores.
    After we calculate the sum, all that’s left is to divide it by the total number
    of scores, which is simply scores.count .
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: But what if the array is empty? You can’t divide something by zero—in math class
    or in Swift. In Swift, trying to divide by zero will give you a division-by-zero
    error and crash your program. Therefore, when doing division, always make sure
    the number you’re going to divide by is not zero, which is what we did by checking
    if scores.count > 0 at ➌ . At ➍ , we return the average by dividing the sum of
    the scores by the number of scores in the array using return sum / scores.count
    . That’s right! You can return any expression that evaluates to the correct data
    type, meaning we can skip the step of assigning the calculated average to a new
    variable and just return sum / scores.count because it evaluates to an Int .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we also need to return something when scores.count isn’t
    greater than zero, or we’ll get an error that the function is missing a return.
    We handle this by adding an else to our if statement that returns 0 ➎ . You can
    test the code by calling the function on an array of scores and an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: When you pass a full array of test scores into the averageOf() function, as
    we do at ➊ , the average value of the scores is returned and shown in the results
    pane. If you pass in an empty array, as we do at ➋ , the return value is 0 .
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this case, the else statement around return 0 isn’t really necessary. This
    is because if scores.count > 0 , then the function will have ended already with
    return sum / scores.count . So if the computer has gotten past that if statement,
    then we know that scores.count > 0 must not have been true , and we could just
    have a return 0 without enclosing it in an else . However, the code is clearer
    and easier to understand if we leave the else statement in. Sometimes it’s better
    to write a little extra code to make something clearer to others than it is to
    use a tricky shortcut.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: You just added an important tool to your Swift tool belt—creating and calling
    your own functions! Functions are used extensively in programming to do all sorts
    of amazing things!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00018.html#ch08) , we’ll show you how to create custom objects
    by writing a class definition. This will let you make constants and variables
    with types other than the ones already included in Swift, which will come in handy
    when you create apps!
  prefs: []
  type: TYPE_NORMAL
