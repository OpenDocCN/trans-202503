- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8**'
- en: STATIC ANALYSIS OF A BOOTKIT USING IDA PRO**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 IDA PRO 进行 BOOTKIT 静态分析**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter introduces the basic concepts of bootkit static analysis with IDA
    Pro. There are several ways to approach reversing bootkits, and covering all the
    existing approaches would require a book of its own. We focus on the IDA Pro disassembler,
    because it provides unique features that enable the static analysis of bootkits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用 IDA Pro 进行 bootkit 静态分析的基本概念。反向工程 bootkit 有几种方法，涵盖所有现有方法需要一本专门的书。本章重点介绍
    IDA Pro 反汇编器，因为它提供了独特的功能，能够支持 bootkit 的静态分析。
- en: Statically analyzing bootkits is radically different from reverse engineering
    in most conventional application environments, because crucial parts of a bootkit
    execute in a preboot environment. For example, a typical Windows application relies
    on standard Windows libraries and is expected to call standard library functions
    known to reverse-engineering tools like Hex-Rays IDA Pro. We can deduce a lot
    about an application by the functions it calls; the same is true about Linux applications
    versus POSIX system calls. But the preboot environment lacks these hints, so the
    tools for preboot analysis need additional features to compensate for this missing
    information. Fortunately, these features are available in IDA Pro, and this chapter
    explains how to use them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析 bootkit 与大多数常规应用环境中的逆向工程截然不同，因为 bootkit 的关键部分在预启动环境中执行。例如，典型的 Windows 应用程序依赖于标准的
    Windows 库，并且预期调用已知的标准库函数，这些函数是像 Hex-Rays IDA Pro 这样的逆向工程工具所熟悉的。通过应用程序调用的函数，我们可以推断出很多信息；Linux
    应用程序与 POSIX 系统调用也是如此。但预启动环境缺乏这些提示，因此预启动分析工具需要额外的功能来弥补这些缺失的信息。幸运的是，这些功能在 IDA Pro
    中可用，本章将解释如何使用它们。
- en: 'As discussed in [Chapter 7](ch07.xhtml#ch07), a bootkit consists of several
    closely connected modules: the Master Boot Record (MBR) or Volume Boot Record
    (VBR) infector, a malicious boot loader, and kernel-mode drivers, among others.
    We’ll restrict the discussion in this chapter to the analysis of a bootkit MBR
    and a legitimate operating system VBR, which you can use as a model for reversing
    any code that executes in the preboot environment. You can download the MBR and
    VBR you’ll use here from the book’s downloadable resources. At the end of the
    chapter, we discuss how to deal with other bootkit components, such as the malicious
    boot loader and kernel-mode drivers. If you haven’t already worked through [Chapter
    7](ch07.xhtml#ch07), you should do so now.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第七章](ch07.xhtml#ch07)中讨论的那样，bootkit 由几个紧密关联的模块组成：主引导记录（MBR）或卷引导记录（VBR）感染者、恶意引导加载程序、内核模式驱动程序等。本章将讨论
    bootkit MBR 和合法操作系统 VBR 的分析，您可以将其作为反向工程任何在预启动环境中执行的代码的模型。您可以从本书的下载资源中获取您将要使用的
    MBR 和 VBR。在本章结束时，我们将讨论如何处理其他 bootkit 组件，如恶意引导加载程序和内核模式驱动程序。如果您还没有学习[第七章](ch07.xhtml#ch07)，现在应该去学习。
- en: First, we’ll show you how to get started with bootkit analysis; you’ll learn
    which options to use in IDA Pro in order to load the code into the disassembler,
    the API used in the preboot environment, how control is transferred between different
    modules, and which IDA features may simplify their reversal. Then you’ll learn
    how to develop a custom loader for IDA Pro in order to automate your reversing
    tasks. Finally, we provide a set of exercises designed to help you further explore
    bootkit static analysis. You can download the materials for this chapter from
    *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将展示如何开始进行 bootkit 分析；您将了解在 IDA Pro 中使用哪些选项将代码加载到反汇编器中、预启动环境中使用的 API、不同模块之间如何传递控制以及哪些
    IDA 功能可能简化它们的反向工程。然后，您将学习如何为 IDA Pro 开发自定义加载器，以自动化反向工程任务。最后，我们提供了一组练习，帮助您进一步探索
    bootkit 静态分析。您可以从 *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*
    下载本章的材料。
- en: '**Analyzing the Bootkit MBR**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分析 Bootkit MBR**'
- en: First, we’ll analyze a bootkit MBR in the IDA Pro disassembler. The MBR we use
    in this chapter is similar to the one the TDL4 bootkit creates (see [Chapter 7](ch07.xhtml#ch07)).
    The TDL4 MBR is a good example because it implements traditional bootkit functionality,
    but its code is easy to disassemble and understand. We based the VBR example in
    this chapter on legitimate code from an actual Microsoft Windows volume.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在IDA Pro反汇编器中分析一个引导木马MBR。本章使用的MBR类似于TDL4引导木马创建的MBR（参见[第7章](ch07.xhtml#ch07)）。TDL4的MBR是一个很好的例子，因为它实现了传统的引导木马功能，但其代码易于反汇编和理解。本章中的VBR例子基于一个来自实际Microsoft
    Windows卷的合法代码。
- en: '***Loading and Decrypting the MBR***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载并解密MBR***'
- en: In the following sections, you’ll load the MBR into IDA Pro and analyze the
    MBR code at its entry point. Then, you’ll decrypt the code and examine how the
    MBR manages memory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将把MBR加载到IDA Pro中，并分析MBR代码的入口点。然后，你将解密代码，并检查MBR如何管理内存。
- en: '**Loading the MBR into IDA Pro**'
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将MBR加载到IDA Pro中**'
- en: The first step in the static analysis of the bootkit MBR is to load the MBR
    code into IDA. Because the MBR isn’t a conventional executable and has no dedicated
    loader, you need to load it as a binary module. IDA Pro will simply load the MBR
    into its memory as a single contiguous segment just as the BIOS does, without
    performing any extra processing. You only need to provide the starting memory
    address for this segment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 引导木马MBR的静态分析的第一步是将MBR代码加载到IDA中。因为MBR不是一个传统的可执行文件，并且没有专用的加载器，你需要将它作为一个二进制模块加载。IDA
    Pro会像BIOS一样，将MBR加载到内存中作为一个连续的单一段落，而不会进行任何额外处理。你只需要提供该段的起始内存地址。
- en: Load the binary file by opening it via IDA Pro. When IDA Pro first loads the
    MBR, it displays a message offering various options, as shown in [Figure 8-1](ch08.xhtml#ch08fig01).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IDA Pro打开二进制文件加载MBR。当IDA Pro第一次加载MBR时，它会显示一条消息，提供各种选项，如[图8-1](ch08.xhtml#ch08fig01)所示。
- en: '![image](../images/08fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig01.jpg)'
- en: '*Figure 8-1: The IDA Pro dialog displayed when loading the MBR*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：加载MBR时显示的IDA Pro对话框*'
- en: You can accept the defaults for most of the parameters, but you need to enter
    a value into the Loading offset field ➊, which specifies where in memory to load
    the module. This value should always be 0x7C00—the fixed address where the MBR
    is loaded by the BIOS boot code. Once you’ve entered this offset, click **OK**.
    IDA Pro loads the module, then gives you the option to disassemble the module
    either in 16-bit or 32-bit mode, as shown in [Figure 8-2](ch08.xhtml#ch08fig02).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以接受大多数参数的默认值，但需要在加载偏移字段➊中输入一个值，该字段指定将模块加载到内存中的位置。这个值应该始终是0x7C00——这是BIOS启动代码将MBR加载到的固定地址。输入完这个偏移量后，点击**确定**。IDA
    Pro加载模块后，会提供选项让你选择以16位或32位模式反汇编模块，如[图8-2](ch08.xhtml#ch08fig02)所示。
- en: '![image](../images/08fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig02.jpg)'
- en: '*Figure 8-2: IDA Pro dialog asking you which disassembly mode to choose*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-2：IDA Pro对话框询问你选择哪个反汇编模式*'
- en: For this example, choose **No**. This directs IDA to disassemble the MBR as
    16-bit real-mode code, which is the way the actual CPU decodes it at the very
    beginning of the boot process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，选择**否**。这会指示IDA将MBR反汇编为16位实模式代码，这正是实际CPU在启动过程中最初阶段解码MBR的方式。
- en: Because IDA Pro stores the results of disassembly in a database file with the
    extension *idb*, we’ll refer to the results of its disassembly as a database from
    now on. IDA uses this database to collect all of the code annotations you provide
    through your GUI actions and IDA scripts. You can think of the database as the
    implicit argument to all IDA script functions, which represents the current state
    of your hard-won reverse-engineering knowledge about the binary on which IDA can
    act.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IDA Pro将反汇编的结果存储在扩展名为*idb*的数据库文件中，从现在开始，我们将其反汇编结果称为数据库。IDA使用这个数据库来收集你通过GUI操作和IDA脚本提供的所有代码注释。你可以将这个数据库视为所有IDA脚本函数的隐式参数，它代表了你对IDA能作用的二进制文件所获得的逆向工程知识的当前状态。
- en: 'If you don’t have any experience with databases, don’t worry: IDA’s interfaces
    are designed so that you don’t need to know the database internals. Understanding
    how IDA represents what it learns about code, however, does help a lot.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有任何数据库经验，别担心：IDA的接口设计使得你无需了解数据库内部结构。然而，理解IDA如何表示它所学到的代码知识确实非常有帮助。
- en: '**Analyzing the MBR’s Entry Point**'
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**分析MBR的入口点**'
- en: When loaded by the BIOS at boot, the MBR—now modified by the infecting bootkit—is
    executed from its first byte. We specified its loading address to IDA’s disassembler
    as 0:7C00h, which is where the BIOS loads it. [Listing 8-1](ch08.xhtml#ch08list01)
    shows the first few bytes of the loaded MBR image.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BIOS 在启动时加载时，经过感染的引导工具修改后的 MBR 从其第一个字节开始执行。我们将其加载地址指定给 IDA 的反汇编器为 0:7C00h，这是
    BIOS 加载它的地方。[列表 8-1](ch08.xhtml#ch08list01) 显示了加载的 MBR 映像的前几个字节。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 8-1: Entry point of the MBR*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-1：MBR 的入口点*'
- en: Early on we see the initialization stub ➊ that sets up the stack segment selector
    `ss`, stack pointer `sp`, and segment selector registers `es` and `ds` in order
    to access memory and execute subroutines. Following the initialization stub is
    a decryption routine ➋, which deciphers the rest of the MBR ➌ by rotating the
    bits—byte by byte—with an `ror` instruction, then passes control to the decrypted
    code. The size of the encrypted blob is given in the `cx` register, and the `bp`
    register points to the blob. This ad hoc encryption is intended to hamper static
    analysis and avoid detection by security software. It also presents us with our
    first obstacle, because we now need to extract the actual code to proceed with
    the analysis.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期看到初始化存根 ➊，它设置了堆栈段选择符 `ss`、堆栈指针 `sp` 和段选择符寄存器 `es` 和 `ds`，以便访问内存并执行子程序。初始化存根之后是一个解密例程
    ➋，它通过逐字节旋转位（使用 `ror` 指令）来解密剩余的 MBR ➌，然后将控制权传递给解密后的代码。加密数据的大小由 `cx` 寄存器给出，而 `bp`
    寄存器指向该数据块。这种临时加密旨在阻碍静态分析并避免被安全软件检测到。它还给我们带来了第一个障碍，因为我们现在需要提取实际代码以继续分析。
- en: '**Decrypting the MBR Code**'
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解密 MBR 代码**'
- en: To continue our analysis of an encrypted MBR, we need to decrypt the code. Thanks
    to the IDA scripting engine, you can easily accomplish this task with the Python
    script in [Listing 8-2](ch08.xhtml#ch08list02).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续分析加密的 MBR，我们需要解密代码。由于有了 IDA 脚本引擎，你可以轻松地使用[列表 8-2](ch08.xhtml#ch08list02)中的
    Python 脚本完成这个任务。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 8-2: Python script to decrypt the MBR code*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-2：解密 MBR 代码的 Python 脚本*'
- en: First, we import the `idaapi` package ➊, which contains the IDA API library.
    Then we loop through and decrypt the encrypted bytes ➋. To fetch a byte from the
    disassembly segment, we use the `get_byte` API ➌, which takes the address of the
    byte to read as its only parameter. Once it’s decrypted, we write the byte back
    to the disassembly region ➍ using the `patch_byte` API, which takes the address
    of the byte to modify and the value to write there. You can execute the script
    by choosing **File**▸**Script** from the IDA menu or by pressing ALT-F7.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `idaapi` 包 ➊，它包含了 IDA API 库。然后我们循环遍历并解密加密的字节 ➋。为了从反汇编段中获取字节，我们使用 `get_byte`
    API ➌，它只接受一个参数：要读取的字节的地址。一旦字节解密完成，我们使用 `patch_byte` API 将字节写回反汇编区域 ➍，该 API 接受要修改的字节的地址和要写入的值。你可以通过选择
    **文件**▸**脚本** 从 IDA 菜单中执行此脚本，或按 ALT-F7。
- en: '**NOTE**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This script doesn’t modify the actual image of the MBR but rather its representation
    in IDA—that is, IDA’s idea of what the loaded code will look when it’s ready to
    run. Before making any modifications to the disassembled code, you should create
    a backup of the current version of the IDA database. That way, if the script modifying
    the MBR code contains bugs and distorts the code, you’ll be able to easily recover
    its most recent version.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*此脚本并不会修改 MBR 的实际映像，而是修改其在 IDA 中的表示——即 IDA 对加载代码执行时的预期样子。在对反汇编代码进行任何修改之前，你应该先创建
    IDA 数据库当前版本的备份。这样，如果修改 MBR 代码的脚本有 bug 并扭曲了代码，你就可以轻松恢复最近的版本。*'
- en: '**Analyzing Memory Management in Real Mode**'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实模式下的内存管理分析**'
- en: Having decrypted the code, let’s proceed with analyzing it. If you look through
    the decrypted code, you’ll find the instructions shown in [Listing 8-3](ch08.xhtml#ch08list03).
    These instructions initialize the malicious code by storing the MBR input parameters
    and memory allocation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解密了代码后，让我们继续分析它。如果你查看解密后的代码，你会发现[列表 8-3](ch08.xhtml#ch08list03)中显示的指令。这些指令通过存储
    MBR 输入参数和内存分配来初始化恶意代码。
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 8-3: Memory allocation in the preboot environment*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-3：预启动环境中的内存分配*'
- en: The assembly instruction that stores the contents of the `dl` register into
    memory is at an offset from the `ds` segment ➊. From our experience analyzing
    this kind of code, we can guess that the `dl` register contains the number of
    the hard drive from which the MBR is being executed; annotate this offset as a
    variable called `drive_no`. IDA Pro records this annotation in the database and
    shows it in the listing. When performing I/O operations, you can use this integer
    index to distinguish between different disks available to the system. You’ll use
    this variable in the BIOS disk service in the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dl` 寄存器的内容存储到内存中的汇编指令位于 `ds` 段的一个偏移量 ➊ 处。从我们分析这种代码的经验来看，我们可以猜测 `dl` 寄存器包含执行
    MBR 的硬盘编号；我们将这个偏移量注释为名为 `drive_no` 的变量。IDA Pro 会在数据库中记录这一注释并在清单中显示。当执行 I/O 操作时，您可以使用这个整数索引来区分系统中不同的磁盘。您将在下一节的
    BIOS 磁盘服务中使用这个变量。
- en: Similarly, [Listing 8-3](ch08.xhtml#ch08list03) shows the annotation `buffer_segm`
    ➌ for the offset where the code allocates a buffer. IDA Pro helpfully propagates
    these annotations to other code that uses the same variables.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，[清单 8-3](ch08.xhtml#ch08list03)显示了注释`buffer_segm` ➌，这是代码分配缓冲区的偏移量。IDA Pro
    会将这些注释传播到使用相同变量的其他代码中。
- en: At ➋, we see a memory allocation. In the preboot environment, there is no memory
    manager in the sense of modern operating systems, such as the OS logic backing
    `malloc()` calls. Instead, the BIOS maintains the number of kilobytes of available
    memory in a *word*—a 16-bit value in x86 architecture—located at the address 0:413h.
    In order to allocate *X* KB of memory, we subtract *X* from the total size of
    available memory, a value stored in the word at 0:413h, as shown in [Figure 8-3](ch08.xhtml#ch08fig03).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在➋处，我们看到内存分配。在预启动环境中，并没有现代操作系统那种内存管理器的概念，比如支持`malloc()`调用的操作系统逻辑。相反，BIOS 通过一个*字*（在
    x86 架构中为 16 位值）维护可用内存的千字节数，该字存储在地址 0:413h 处。为了分配 *X* KB 的内存，我们从可用内存的总大小中减去 *X*，这个总大小存储在
    0:413h 处的字中，如[图 8-3](ch08.xhtml#ch08fig03)所示。
- en: '![image](../images/08fig03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/08fig03.jpg)'
- en: '*Figure 8-3: Memory management in a preboot environment*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：预启动环境中的内存管理*'
- en: In [Listing 8-3](ch08.xhtml#ch08list03), the code allocates a buffer of 10Kb
    by subtracting 10h from the total amount available. The actual address is stored
    in the variable `buffer_segm` ➌. The MBR then uses the allocated buffer to store
    read data from the hard drive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 8-3](ch08.xhtml#ch08list03)中，代码通过从总可用内存中减去 10h 来分配一个 10KB 的缓冲区。实际的地址存储在变量`buffer_segm`
    ➌中。MBR 然后使用分配的缓冲区来存储从硬盘读取的数据。
- en: '***Analyzing the BIOS Disk Service***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析 BIOS 磁盘服务***'
- en: Another unique aspect of the preboot environment is the BIOS disk service, an
    API used to communicate with a hard drive. This API is particularly interesting
    in the context of bootkit analysis for two reasons. First, bootkits use it to
    read data from the hard drive, so it’s important to be familiar with the API’s
    most frequently used commands in order to understand bootkit code. Also, this
    API is itself a frequent target of bootkits. In the most common scenario, a bootkit
    hooks the API to patch legitimate modules that are read from the hard drive by
    other code during the boot process.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 预启动环境的另一个独特方面是 BIOS 磁盘服务，它是用于与硬盘通信的 API。在引导包分析中，这个 API 特别值得关注，原因有二。首先，引导包使用它从硬盘读取数据，因此熟悉该
    API 最常用的命令对于理解引导包代码至关重要。其次，BIOS 磁盘服务本身也是引导包的常见目标。在最常见的情况下，引导包会挂钩该 API，从而修补通过其他代码在引导过程中从硬盘读取的合法模块。
- en: 'The BIOS disk service is accessible via an INT 13h instruction. In order to
    perform I/O operations, software passes I/O parameters through the processor registers
    and executes the INT 13h instruction, which transfers control to the appropriate
    handler. The I/O operation code, or *identifier*, is passed in the `ah` register—the
    higher-order part of the `ax` register. The register `dl` is used to pass the
    index of the disk in question. The processor’s carry flag (`CF`) is used to indicate
    whether an error has occurred during execution of the service: if `CF` is set
    to `1`, an error has occurred and the detailed error code is returned in the `ah`
    register. This BIOS convention for passing arguments to a function predates the
    modern OS system call conventions; if it seems convoluted to you, remember that
    this is where the idea of uniform system call interfaces originated.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS磁盘服务可以通过INT 13h指令访问。为了执行I/O操作，软件通过处理器寄存器传递I/O参数，并执行INT 13h指令，这会将控制权转交给适当的处理程序。I/O操作码或*标识符*被传递到`ah`寄存器——`ax`寄存器的高位部分。`dl`寄存器用于传递目标磁盘的索引。处理器的进位标志（`CF`）用于指示在执行服务时是否发生错误：如果`CF`被设置为`1`，则表示发生了错误，详细的错误代码将返回在`ah`寄存器中。这种通过函数传递参数的BIOS约定早于现代操作系统的系统调用约定；如果它看起来有些复杂，请记住，这就是统一系统调用接口概念的起源地。
- en: This INT 13h interrupt is an entry point to the BIOS disk service, and it allows
    software in the preboot environment to perform basic I/O operations on disk devices,
    like hard drives, floppy drives, and CD-ROMs, as shown in [Table 8-1](ch08.xhtml#ch08tab01).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个INT 13h中断是进入BIOS磁盘服务的入口点，它允许在预引导环境中的软件对磁盘设备执行基本的I/O操作，如硬盘、软盘和光盘驱动器，具体如[表 8-1](ch08.xhtml#ch08tab01)所示。
- en: '**Table 8-1:** The INT 13h Commands'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 8-1：** INT 13h 命令'
- en: '| **Operation code** | **Operation description** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **操作码** | **操作描述** |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 2h | Read sectors into memory |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2h | 读取扇区到内存 |'
- en: '| 3h | Write disk sectors |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 3h | 写入磁盘扇区 |'
- en: '| 8h | Get drive parameters |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 8h | 获取驱动器参数 |'
- en: '| 41h | Extensions installation check |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 41h | 扩展安装检查 |'
- en: '| 42h | Extended read |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 42h | 扩展读取 |'
- en: '| 43h | Extended write |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 43h | 扩展写入 |'
- en: '| 48h | Extended get drive parameters |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 48h | 扩展获取驱动器参数 |'
- en: 'The operations in [Table 8-1](ch08.xhtml#ch08tab01) are split into two groups:
    the first group (with codes 41h, 42h, 43h, and 48h) comprises the *extended operations*,
    and the second group (with codes 2h, 3h, and 8h) consists of the *legacy operations*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-1](ch08.xhtml#ch08tab01)中的操作分为两组：第一组（包含代码41h、42h、43h和48h）为*扩展操作*，第二组（包含代码2h、3h和8h）为*传统操作*。'
- en: The only difference between the groups is that the extended operations can use
    an addressing scheme based on *logical block addressing (LBA)*, whereas the legacy
    operations rely solely on a legacy *Cylinder Head Sector (CHS)*–based addressing
    scheme. In the case of the LBA-based scheme, sectors are enumerated linearly on
    the disk, beginning with index `0`, whereas in the CHS-based scheme, each sector
    is addressed using the tuple `(c,h,s)`, where `c` is the cylinder number, `h`
    is the head number, and `s` is the number of the sector. Although bootkits may
    use either group, almost all modern hardware supports the LBA-based addressing
    scheme.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 两组操作之间唯一的区别是，扩展操作可以使用基于*逻辑块寻址（LBA）*的寻址方案，而传统操作则仅依赖基于*柱面-磁头-扇区（CHS）*的寻址方案。在LBA寻址方案中，磁盘上的扇区按顺序从索引`0`开始枚举，而在CHS寻址方案中，每个扇区都使用元组`(c,h,s)`进行寻址，其中`c`是柱面号，`h`是磁头号，`s`是扇区号。尽管引导工具可能使用任一组操作，但几乎所有现代硬件都支持基于LBA的寻址方案。
- en: '**Obtaining Drive Parameters to Locate Hidden Storage**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取驱动器参数以定位隐藏存储**'
- en: As you continue looking at the MBR code that follows the 10KB memory allocation,
    you should see the execution of an INT 13h instruction, as shown in [Listing 8-4](ch08.xhtml#ch08list04).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续查看跟随在10KB内存分配后的MBR代码时，你应该会看到执行INT 13h指令，如[示例 8-4](ch08.xhtml#ch08list04)所示。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 8-4: Obtaining drive parameters via the BIOS disk service*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8-4：通过BIOS磁盘服务获取驱动器参数*'
- en: The small size of the MBR (512 bytes) restricts the functionality of the code
    that can be implemented within it. For this reason, the bootkit loads additional
    code to execute, called a *malicious boot loader*, which is placed in hidden storage
    at the end of the hard drive. To obtain the coordinates of the hidden storage
    on the disk, the MBR code uses the extended “get drive parameters” operation (operation
    code 48h in [Table 8-1](ch08.xhtml#ch08tab01)), which returns information about
    the hard drive’s size and geometry. This information allows the bootkit to compute
    the offset at which the additional code is located on the hard drive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MBR的大小（512字节）限制了其可以实现的代码功能，因此启动工具会加载额外的代码进行执行，这段代码称为*恶意引导加载程序*，它被放置在硬盘末尾的隐藏存储中。为了获取硬盘上隐藏存储的坐标，MBR代码使用扩展的“获取驱动器参数”操作（操作码48h，在[表8-1](ch08.xhtml#ch08tab01)中），该操作返回硬盘的大小和几何信息。通过这些信息，启动工具可以计算出额外代码在硬盘上的偏移位置。
- en: In [Listing 8-4](ch08.xhtml#ch08list04), you can see an automatically generated
    comment from IDA Pro for the instruction INT 13h ➌. During code analysis, IDA
    Pro identifies parameters passed to the BIOS disk service handler call and generates
    a comment with the name of the requested disk I/O operation and the register names
    used to pass parameters to the BIOS handler. This MBR code executes INT 13h with
    parameter `48h` ➊. Upon execution, this routine fills a special structure called
    `EXTENDED_GET_PARAMS` that provides the drive parameters. The address of this
    structure is stored in the `si` register ➋.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 8-4](ch08.xhtml#ch08list04)中，你可以看到IDA Pro为指令INT 13h ➌自动生成的注释。在代码分析过程中，IDA
    Pro识别传递给BIOS磁盘服务处理程序的参数，并生成带有请求的磁盘I/O操作名称和用于传递参数给BIOS处理程序的寄存器名称的注释。这段MBR代码执行INT
    13h操作，并使用参数`48h` ➊。执行后，这个例程会填充一个名为`EXTENDED_GET_PARAMS`的特殊结构，该结构提供驱动器参数。该结构的地址存储在`si`寄存器中
    ➋。
- en: '**Examining EXTENDED_GET_PARAMS**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**检查EXTENDED_GET_PARAMS**'
- en: The `EXTENDED_GET_PARAMS` routing is provided in [Listing 8-5](ch08.xhtml#ch08list05).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTENDED_GET_PARAMS`路由在[清单 8-5](ch08.xhtml#ch08list05)中提供。'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 8-5: The `EXTENDED_GET_PARAMS` structure layout*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-5：`EXTENDED_GET_PARAMS`结构布局*'
- en: The only fields the bootkit actually looks at in the returned structure are
    the number of sectors on the hard drive ➊ and the size of the disk sector in bytes
    ➋. The bootkit computes the total size of the hard drive in bytes by multiplying
    these two values, then uses the result to locate the hidden storage at the end
    of the drive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 启动工具实际上只关心返回结构中的两个字段：硬盘上的扇区数量 ➊ 和磁盘扇区的大小（以字节为单位） ➋。启动工具通过将这两个值相乘来计算硬盘的总大小（以字节为单位），然后利用结果来定位硬盘末尾的隐藏存储。
- en: '**Reading Malicious Boot Loader Sectors**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**读取恶意引导加载程序扇区**'
- en: Once the bootkit has obtained the hard drive parameters and calculated the offset
    of the hidden storage, the bootkit MBR code reads this hidden data from the disk
    with the extended read operation of the BIOS disk service. This data is the next-stage
    malicious boot loader intended to bypass OS security checks and load a malicious
    kernel-mode driver. [Listing 8-6](ch08.xhtml#ch08list06) shows the code that reads
    it into RAM.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动工具获取了硬盘参数并计算出隐藏存储的偏移量，启动工具的MBR代码就会通过BIOS磁盘服务的扩展读取操作从磁盘中读取这些隐藏数据。这些数据是下一阶段的恶意引导加载程序，旨在绕过操作系统安全检查并加载恶意的内核模式驱动程序。[清单
    8-6](ch08.xhtml#ch08list06)展示了将其读取到RAM中的代码。
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 8-6: Code for loading an additional malicious boot loader from the
    disk*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-6：从磁盘加载额外恶意引导加载程序的代码*'
- en: In the `read_loop`, this code repeatedly reads sectors from the hard drive using
    the routine `read_sector` ➊ and stores them in the previously allocated memory
    buffer. Then the code transfers control to this malicious boot loader by executing
    a `jmp far` instruction ➋.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`read_loop`中，这段代码通过调用`read_sector` ➊反复从硬盘读取扇区，并将它们存储在之前分配的内存缓冲区中。然后，代码通过执行`jmp
    far`指令 ➋将控制转移到这个恶意引导加载程序。
- en: Looking at the code of the `read_sector` routine, in [Listing 8-7](ch08.xhtml#ch08list07)
    you can see the usage of INT 13h with the parameter `42h`, which corresponds to
    the extended read operation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`read_sector`例程的代码，在[清单 8-7](ch08.xhtml#ch08list07)中，你可以看到使用了INT 13h，参数为`42h`，这对应于扩展读取操作。
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 8-7: Reading sectors from the disk*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-7：从磁盘读取扇区*'
- en: Before executing INT 13h ➐, the bootkit code initializes the `DISK_ADDRESS_PACKET`
    structure with the proper parameters, including the size of the structure ➊, the
    number of sectors to transfer ➋, the address of the buffer to store the result
    ➌, and the addresses of the sectors to read ➍ ➎. This structure’s address is provided
    to the INT 13h handler via the `ds` and `si` registers ➏. Note the manual annotation
    of the structure’s offsets; IDA picks them up and propagates them. The BIOS disk
    service uses `DISK_ADDRESS_PACKET` to uniquely identify which sectors to read
    from the hard drive. The complete layout of the structure of `DISK_ADDRESS_PACKET`,
    with comments, is provided in [Listing 8-8](ch08.xhtml#ch08list08).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行INT 13h ➐之前，bootkit代码初始化`DISK_ADDRESS_PACKET`结构，设置适当的参数，包括结构的大小➊、要传输的扇区数量➋、存储结果的缓冲区地址➌，以及要读取的扇区地址➍
    ➎。该结构的地址通过`ds`和`si`寄存器提供给INT 13h处理程序➏。注意结构偏移量的手动注释；IDA会获取并传播它们。BIOS磁盘服务使用`DISK_ADDRESS_PACKET`来唯一标识从硬盘读取哪些扇区。`DISK_ADDRESS_PACKET`结构的完整布局及其注释在[列表
    8-8](ch08.xhtml#ch08list08)中提供。
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 8-8: The `DISK_ADDRESS_PACKET` structure layout*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 8-8：`DISK_ADDRESS_PACKET` 结构布局*'
- en: Once the boot loader is read into the memory buffer, the bootkit executes it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引导加载程序被读取到内存缓冲区，bootkit就会执行它。
- en: 'At this point, we have finished our the analysis of the MBR code and we’ll
    proceed to dissecting another essential part of the MBR: the partition table.
    You can download the complete version of the disassembled and commented malicious
    MBR at *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了对MBR代码的分析，接下来将分析MBR的另一个重要部分：分区表。你可以在*[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*下载完整版本的反汇编并注释过的恶意MBR。
- en: '***Analyzing the Infected MBR’s Partition Table***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析受感染的MBR分区表***'
- en: The MBR partition table is a common target of bootkits because the data it contains—although
    limited—plays a crucial part in the boot process’s logic. Introduced in [Chapter
    5](ch05.xhtml#ch05), the partition table is located at the offset 0x1BE in the
    MBR and consists of four entries, each 0x10 bytes in size. It lists the partitions
    available on the hard drive, describes their type and location, and specifies
    where the MBR code should transfer control when it’s done. Usually, the sole purpose
    of legitimate MBR code is to scan this table for the *active* partition—that is,
    the partition marked with the appropriate bit flag and containing the VBR—and
    load it. You might be able to intercept this execution flow at the very early
    boot stage by simply manipulating the information contained in the table, without
    modifying the MBR code itself; the Olmasco bootkit, which we’ll discuss in [Chapter
    10](ch10.xhtml#ch10), implements this method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MBR分区表是bootkit的常见攻击目标，因为它包含的数据——虽然有限——在启动过程的逻辑中扮演着关键角色。在[第5章](ch05.xhtml#ch05)中介绍过，分区表位于MBR中的偏移量0x1BE处，由四个条目组成，每个条目的大小为0x10字节。它列出了硬盘上可用的分区，描述了它们的类型和位置，并指定了MBR代码完成后应该将控制权转交到哪里。通常，合法MBR代码的唯一目的是扫描此表格以查找*活动*分区——即标记了相应位标志并包含VBR的分区——并将其加载。你可能能够通过简单地操作表格中包含的信息来在启动的早期阶段拦截这一执行流程，而无需修改MBR代码本身；我们将在[第10章](ch10.xhtml#ch10)中讨论的Olmasco
    bootkit实现了这种方法。
- en: 'This illustrates an important principle of bootkit and rootkit design: if you
    can manipulate some data surreptitiously enough to bend the control flow, then
    that approach is preferred to patching the code. This saves the malware programmer
    the effort of testing new, altered code—a good example of code reuse promoting
    reliability!'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了bootkit和rootkit设计中的一个重要原则：如果你能够巧妙地操控某些数据以弯曲控制流，那么这种方法比修补代码更受青睐。这节省了恶意软件程序员测试新修改代码的努力——这是代码重用促进可靠性的一个好例子！
- en: Complex data structures like an MBR or VBR notoriously afford attackers many
    opportunities to treat them as a kind of bytecode and to treat the native code
    that consumes the data as a virtual machine programmed through the input data.
    The *language-theoretic security* (LangSec, *[http://langsec.org/](http://langsec.org/)*)
    approach explains why this is the case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像MBR或VBR这样的复杂数据结构通常会为攻击者提供许多机会，将它们视为一种字节码，并将消耗这些数据的本机代码视为通过输入数据编程的虚拟机。*语言理论安全*（LangSec，*[http://langsec.org/](http://langsec.org/)*）方法解释了为什么会出现这种情况。
- en: Being able to read and understand the MBR’s partition table is essential for
    spotting this kind of early bootkit interception. Take a look at the partition
    table in [Figure 8-4](ch08.xhtml#ch08fig04), where each 16/10h-byte line is a
    partition table entry.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-4: Partition table of the MBR*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the table has two entries—the top two lines—which implies there
    are only two partitions on the disk. The first partition entry starts at the address
    0x7DBE; its very first byte ➊ shows that this partition is active, so the MBR
    code should load and execute its VBR, which is the first sector of that partition.
    The byte at offset 0x7DC2 ➋ describes the type of the partition—that is, the particular
    filesystem type that should be expected there by the OS, by the bootloader itself,
    or by other low-level disk access code. In this case, 0x07 corresponds to Microsoft’s
    NTFS. (For more information on partition types, see “[The Windows Boot Process](ch05.xhtml#ch05lev1sec3)”
    on [page 60](ch05.xhtml#page_60).)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Next, the DWORD at 0x7DC5 ➌ in the partition table entry indicates that the
    partition starts at offset 0x800 from the beginning of the hard drive; this offset
    is counted in sectors. The last DWORD ➍ of the entry specifies the partition’s
    size in sectors (0x32000). [Table 8-2](ch08.xhtml#ch08tab02) details the particular
    example in [Figure 8-4](ch08.xhtml#ch08fig04). In the Beginning offset and Partition
    size columns, the actual values are provided in sectors, with bytes in parentheses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2:** MBR Partition Table Contents'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '| **Partition index** | **Is active** | **Type** | **Beginning offset, sectors
    (bytes)** | **Partition size, sectors (bytes)** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| 0 | True | NTFS (0x07) | 0x800 (0x100000) | 0x32000 (0x6400000) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| 1 | False | NTFS (0x07) | 0x32800 (0x6500000) | 0x4FCD000 (0x9F9A00000) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| 2 | N/A | N/A | N/A | N/A |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| 3 | N/A | N/A | N/A | N/A |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: The reconstructed partition table indicates where you should look next in your
    analysis of the boot sequence. Namely, it tells you where the VBR is. The coordinates
    of the VBR are stored in the Beginning offset column of the primary partition
    entry. In this case, the VBR is located at an offset 0x100000 bytes from the beginning
    of the hard drive, which is the place to look in order to continue your analysis.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**VBR Analysis Techniques**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll consider VBR static analysis approaches using IDA and
    focus on an essential VBR concept called *BIOS parameter block (BPB)*, which plays
    an important role in the boot process and bootkit infection. The VBR is also a
    common target of bootkits, as we explained briefly in [Chapter 7](ch07.xhtml#ch07).
    In [Chapter 12](ch12.xhtml#ch12), we’ll discuss the Gapz bootkit, which infects
    the VBR in order to persist on the infected system, in more detail. The Rovnix
    bookit, discussed in [Chapter 11](ch11.xhtml#ch11), also makes use of the VBR
    to infect a system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: You should load the VBR into the disassembler in essentially the same way you
    loaded the MBR, since it’s also executed in real mode. Load the VBR file, *vbr_sample_ch8.bin*,
    from the samples directory for [Chapter 8](ch08.xhtml#ch08) as a binary module
    at 0:7C00h and in 16-bit disassembly mode.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该以与加载 MBR 基本相同的方式加载 VBR 到反汇编器中，因为它也在实模式下执行。加载来自样本目录中 [第 8 章](ch08.xhtml#ch08)
    的 VBR 文件 *vbr_sample_ch8.bin*，作为 0:7C00h 处的二进制模块，并以 16 位反汇编模式加载。
- en: '***Analyzing the IPL***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析 IPL***'
- en: The main purpose of the VBR is to locate the Initial Program Loader (IPL) and
    to read it into RAM. The location of the IPL on the hard drive is specified in
    the `BIOS_PARAMETER_BLOCK_NTFS` structure, which we discussed in [Chapter 5](ch05.xhtml#ch05).
    Stored directly in the VBR, `BIOS_PARAMETER_BLOCK_NTFS` contains a number of fields
    that define the geometry of the NTFS volume, such as the number of bytes per sector,
    the number of sectors per cluster, and the location of the master file table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 的主要目的是定位初始程序加载器（IPL），并将其加载到内存中。IPL 在硬盘上的位置在 `BIOS_PARAMETER_BLOCK_NTFS`
    结构中指定，前文在[第 5 章](ch05.xhtml#ch05)中已讨论过。直接存储在 VBR 中的 `BIOS_PARAMETER_BLOCK_NTFS`
    包含多个字段，用于定义 NTFS 卷的几何结构，如每扇区的字节数、每簇的扇区数以及主文件表的位置。
- en: The `HiddenSectors` field, which stores the number of sectors from the beginning
    of the hard drive to the beginning of the NTFS volume, defines the actual location
    of the IPL. The VBR assumes that the NTFS volume begins with the VBR, immediately
    followed by the IPL. So the VBR code loads the IPL by fetching the contents of
    the `HiddenSectors` field, incrementing the fetched value by 1, and then reading
    0x2000 bytes—which corresponds to 16 sectors—from the calculated offset. Once
    the IPL is loaded from disk, the VBR code transfers control to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`HiddenSectors` 字段存储了从硬盘开始到 NTFS 卷开始的扇区数，定义了 IPL 的实际位置。VBR 假定 NTFS 卷以 VBR 开头，紧随其后的是
    IPL。因此，VBR 代码通过获取 `HiddenSectors` 字段的内容，递增该值 1，然后从计算出的偏移量读取 0x2000 字节（即 16 个扇区）来加载
    IPL。一旦 IPL 从磁盘加载完毕，VBR 代码会将控制权转交给它。'
- en: '[Listing 8-9](ch08.xhtml#ch08list09) shows a part of the BIOS parameter block
    structure in our example.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 8-9](ch08.xhtml#ch08list09) 展示了我们示例中 BIOS 参数块结构的一部分。'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 8-9: The BIOS parameter block of the VBR*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 8-9：VBR 的 BIOS 参数块*'
- en: 'The value of `HiddenSectors` ➊ is 0x800, which corresponds to the beginning
    offset of the active partition on the disk in [Table 8-2](ch08.xhtml#ch08tab02).
    This shows that the IPL is located at offset 0x801 from the beginning of the disk.
    Bootkits use this information to intercept control during the boot process. The
    Gapz bootkit, for example, modifies the contents of the `HiddenSectors` field
    so that, instead of a legitimate IPL, the VBR code reads and executes the malicious
    IPL. Rovnix, on the other hand, uses another strategy: it modifies the legitimate
    IPL’s code. Both manipulations intercept control at the early boot of the system.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`HiddenSectors` ➊ 的值为 0x800，对应磁盘上活动分区的起始偏移量，见[表 8-2](ch08.xhtml#ch08tab02)。这表明
    IPL 位于磁盘起始位置的 0x801 偏移处。Bootkit 利用这些信息在启动过程中拦截控制。比如，Gapz bootkit 修改了 `HiddenSectors`
    字段的内容，使得 VBR 代码读取并执行恶意的 IPL，而不是合法的 IPL。另一方面，Rovnix 使用了另一种策略：它修改了合法 IPL 的代码。这两种操作都在系统启动初期拦截了控制权。'
- en: '***Evaluating Other Bootkit Components***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***评估其他 Bootkit 组件***'
- en: Once the IPL receives control, it loads *bootmgr*, which is stored in the filesystem
    of the volume. After this, other bootkit components, such as malicious boot loaders
    and kernel-mode drivers, may kick in. A full analysis of these modules is beyond
    the scope of this chapter, but we’ll briefly outline some approaches.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 IPL 获得控制，它会加载存储在卷文件系统中的 *bootmgr*。此后，其他 bootkit 组件，如恶意引导加载程序和内核模式驱动程序，可能会启动。对这些模块的完整分析超出了本章的范围，但我们会简要概述一些方法。
- en: '**Malicious Boot Loaders**'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**恶意引导加载程序**'
- en: Malicious boot loaders constitute an important part of bootkits. Their main
    purposes are to survive through the CPU’s execution mode switching, bypass OS
    security checks (such as driver signature enforcement), and load malicious kernel-mode
    drivers. They implement functionality that cannot fit in the MBR and the VBR due
    to their size limitations, and they’re stored separately on the hard drive. Bootkits
    store their boot loaders in hidden storage areas located either at the end of
    the hard drive, where there is usually some unused disk space, or in free disk
    space between partitions, if there is any.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'A malicious boot loader may contain different code to be executed in different
    processor execution modes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**16-bit real mode** Interrupt 13h hooking functionality'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**32-bit protected mode** Bypass OS security checks for 32-bit OS version'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**64-bit protected mode (long mode)** Bypass OS security checks for 64-bit
    OS version'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: But the IDA Pro disassembler can’t keep code disassembled in different modes
    in a single IDA database, so you’ll need to maintain different versions of the
    IDA Pro database for different execution modes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel-Mode Drivers**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In most cases, the kernel-mode drivers that bootkits load are valid PE images.
    They implement rootkit functionality that allows malware to avoid detection by
    security software and provides covert communication channels, among other things.
    Modern bootkits usually contain two versions of the kernel-mode driver, compiled
    for the x86 and x64 platforms. You may analyze these modules using conventional
    approaches for static analysis of executable images. IDA Pro does a decent job
    of loading such executables, and it provides a lot of supplemental tools and information
    for their analysis. However, we’ll discuss how to instead use IDA Pro’s features
    to automate the analysis of bootkits by preprocessing them as IDA loads them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced IDA Pro Usage: Writing a Custom MBR Loader**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most striking features of the IDA Pro disassembler is the breadth
    of its support for various file formats and processor architectures. To achieve
    this, the functionality for loading particular types of executables is implemented
    in special modules called *loaders*. By default, IDA Pro contains a number of
    loaders, covering the most frequent types of executables, such as PE (Windows),
    ELF (Linux), Mach-O (macOS), and firmware image formats. You can obtain the list
    of available loaders by inspecting the contents of your *$IDADIR\loaders* directory,
    where *$IDADIR* is the installation directory of the disassembler. The files within
    this directory are the loaders, and their names correspond to platforms and their
    binary formats. The file extensions have the following meanings:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '***ldw*** Binary implementation of a loader for the 32-bit version of IDA Pro'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '***l64*** Binary implementation of a loader for the 64-bit version of IDA Pro'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '***py*** Python implementation of a loader for both versions of IDA Pro'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: By default, no loader is available for MBR or VBR at the time of writing this
    chapter, which is why you have to instruct IDA to load the MBR or VBR as a binary
    module. This section shows you how to write a custom Python-based MBR loader for
    IDA Pro that loads MBR in the 16-bit disassembler mode at the address 0x7C00 and
    parses the partition table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding loader.hpp***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The place to start is the *loader.hpp* file, which is provided with the IDA
    Pro SDK and contains a lot of useful information related to loading executables
    in the disassembler. It defines structures and types to use, lists prototypes
    of the callback routines, and describes the parameters they take. Here is the
    list of the callbacks that should be implemented in a loader, according to *loader.hpp*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: accept_file This routine checks whether the file being loaded is of a supported
    format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: load_file This routine does the actual work of loading the file into the disassembler—that
    is, parsing the file format and mapping the file’s content into the newly created
    database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: save_file This is an optional routine that, if implemented, produces an executable
    from the disassembly upon executing the File▸Produce File▸Create EXE File command
    in the menu.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: move_segm This is an optional routine that, if implemented, is executed when
    a user moves a segment within the database. It is mostly used when there is relocation
    information in the image that the user should take into account when moving a
    segment. Due to the MBR’s lack of relocations, we can skip this routine here,
    but we couldn’t if we were to write a loader for PE or ELF binaries.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: init_loader_options This is an optional routine that, if implemented, asks a
    user for additional parameters for loading a particular file type, once the user
    chooses a loader. We can skip this routine as well, because we have no special
    options to add.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the actual implementation of these routines in our
    custom MBR loader.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing accept_file***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the `accept_file` routine, shown in [Listing 8-10](ch08.xhtml#ch08list10),
    we check whether the file in question is a Master Boot Record.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8-10: The `accept_file` implementation*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The MBR format is rather simple, so the following are the only indicators we
    need to perform this check:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**File size** The file should be at least 512 bytes, which corresponds to the
    minimum size of a hard drive sector.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**MBR signature** A valid MBR should end with the bytes 0xAA55.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: If the conditions are met and the file is recognized as an MBR, the code returns
    a string with the name of the loader ➌; if the file is not an MBR, the code returns
    `0` ➊ ➋.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing load_file***'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once `accept_file` returns a nonzero value, IDA Pro attempts to load the file
    by executing the `load_file` routine, which is implemented in your loader. This
    routine needs to perform the following steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Read the whole file into a buffer.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and initialize a new memory segment, into which the script will load
    the MBR contents.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the very beginning of the MBR as an entry point for the disassembly.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the partition table contained in the MBR.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `load_file` implementation is shown in [Listing 8-11](ch08.xhtml#ch08list11).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 8-11: The `load_file` implementation*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'First, set the CPU type to `metapc` ➊, which corresponds to the generic PC
    family, instructing IDA to disassemble the binary as IBM PC opcodes. Then read
    the MBR into a buffer ➋ and create a memory segment by calling the `segment_t`
    API ➌. This call allocates an empty structure, `seg`, describing the segment to
    create. Then, populate it with the actual byte values. Set the starting address
    of the segment to 0x7C00, as you did in “[Loading the MBR into IDA Pro](ch08.xhtml#ch08lev3sec1)”
    on [page 96](ch08.xhtml#page_96), and set its size to the corresponding size of
    the MBR. Also tell IDA that the new segment will be a 16-bit segment by setting
    the `bitness` flag of the structure to `0`; note that `1` corresponds to 32-bit
    segments and `2` corresponds to 64-bit segments. Then, by calling the `add_segm_ex`
    API ➍, add a new segment to the disassembly database. The `add_segm_ex` API takes
    these parameters: a structure describing the segment to create; the segment name
    (`seg0`); the segment class `CODE`; and `flags`, which is left at `0`. Following
    this call ➎, copy the MBR contents into the newly created segment and add an entry
    point indicator.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add automatic parsing of the partition table present in the MBR by calling
    the `doStruct` API ➐ with these parameters: the address of the beginning of the
    partition table, the table size in bytes, and the identifier of the structure
    you want the table to be cast to. The `add_struct_def` routine ➏ implemented in
    our loader creates this structure. It imports the structures defining the partition
    table, `PARTITION_TABLE_ENTRY`, into the database.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating the Partition Table Structure***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 8-12](ch08.xhtml#ch08list12) defines the `add_struct_def` routine,
    which creates the `PARTITION_TABLE_ENTRY` structure.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 8-12: Importing data structures into the disassembly database*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Once your loader module is finished, copy it into the *$IDADIR\loaders* directory
    as an *mbr.py* file. When a user attempts to load an MBR into the disassembler,
    the dialog in [Figure 8-5](ch08.xhtml#ch08fig05) appears, confirming that your
    loader has successfully recognized the MBR image. Clicking **OK** executes the
    `load_file` routine implemented in your loader in order to apply the previously
    described customizations to the loaded file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*When you’re developing custom loaders for IDA Pro, bugs in the script implementation
    may cause IDA Pro to crash. If this happens, simply remove the loader script from
    the* loaders *directory and restart the disassembler.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ve seen a small sample of the disassembler’s extension
    development capabilities. For a more complete reference on IDA Pro extension development,
    refer to *The IDA Pro Book* (No Starch Press, 2011) by Chris Eagle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/08fig05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-5: Choosing the custom MBR loader*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we described a few simple steps for static analysis of the
    MBR and the VBR. You can easily extend the examples in this chapter to any code
    running in the preboot environment. You also saw that the IDA Pro disassembler
    provides a number of unique features that make it a handy tool for performing
    static analysis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, static analysis has its limitations—mainly related to the
    inability to see the code at work and observe how it manipulates the data. In
    many cases, static analysis can’t provide answers to all the questions a reverse
    engineer may have. In such situations, it’s important to examine the actual execution
    of the code to better understand its functionality or to obtain some information
    that may have been missing in the static context, such as encryption keys. This
    brings us to dynamic analysis, the methods and tools for which we’ll discuss in
    the next chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises to get a better grasp of the material in this
    chapter. You’ll need to download a disk image from *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
    The required tools for this exercise are the IDA Pro disassembler and a Python
    interpreter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Extract the MBR from the image by reading its first 512 bytes and saving them
    in a file named *mbr.mbr*. Load the extracted MBR into the IDA Pro disassembler.
    Examine and describe the code at the entry point.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify code that decrypts the MBR. What kind of encryption is being used?
    Find the key used to decrypt the MBR.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a Python script to decrypt the rest of the MBR code and execute it. Use
    the code in [Listing 8-2](ch08.xhtml#ch08list02) as a reference.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be able to load additional code from disk, the MBR code allocates a memory
    buffer. Where is the code allocating that buffer located? How many bytes of memory
    does the code allocate? Where is the pointer to the allocated buffer stored?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the memory buffer is allocated, the MBR code attempts to load additional
    code from disk. At which offset in which sectors does the MBR code start reading
    these sectors? How many sectors does it read?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It appears that the data loaded from the disk is encrypted. Identify the MBR
    code that decrypts the read sectors. What is the address at which this MBR code
    will be loaded?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the encrypted sectors from the disk image by reading the number of bytes
    identified in exercise 4 from the found offset in the file *stage2.mbr*.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a Python script for decrypting the extracted sectors and execute it.
    Load the decrypted data into the disassembler (in the same way as the MBR) and
    examine its output.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the partition table in the MBR. How many partitions are there? Which
    one is active? Where on the image are these partitions located?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the VBR of the active partition from the image by reading its first
    512 bytes and saving it in a *vbr.vbr* file. Load the extracted VBR into IDA Pro.
    Examine and describe the code at the entry point.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the value stored in the `HiddenSectors` field of the BIOS parameter
    block in the VBR? At which offset is the IPL code located? Examine the VBR code
    and determine the size of the IPL (that is, how many bytes of the IPL are read).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the IPL code from the disk image by reading and saving it into an *ipl.vbr*
    file. Load the extracted IPL into IDA Pro. Find the location of the entry point
    in the IPL. Examine and describe the code at the entry point.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop a custom VBR loader for IDA Pro that automatically parses the BIOS parameter
    block. Use the structure `BIOS_PARAMETER_BLOCK_NTFS` defined in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
