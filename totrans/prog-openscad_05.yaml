- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to turn complex designs into more manageable
    components called modules. *Modules* are separate sections of code that organize
    a collection of stand-alone statements, and they’re particularly useful for two
    reasons. If your code is long and complicated, using modules can break your code
    into smaller subsections, which helps make your code more readable. And if your
    design has duplicate or similar shapes, you can use a single module to define
    the shape, reducing the amount of code you need to write to create complex designs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also describes how to use variables and parameters to customize
    your modules. Finally, we’ll explain how to group similar modules into a separate
    file (often called a *library*) to make it easier to organize designs, share designs,
    and use designs others have created.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Code with Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how using modules might simplify your code, let’s take another
    look at the code for drawing the cross-shaped cookie cutter ([Figure 5-1](#figure5-1))you
    built in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/279547c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: The cross-shaped cookie cutter'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve reproduced the code in [Listing 5-1](#listing5-1). Do you see any repeated
    code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: The original cross-shaped cookie cutter program'
  prefs: []
  type: TYPE_NORMAL
- en: The cookie cutter is made by taking the difference of two crosses, so the `square`
    commands to create the cross shape are repeated twice. Duplicate code almost always
    causes problems, because any change you make to a shape’s dimensions must be made
    twice (or however many times the code is duplicated). If you forget to change
    every instance, you’ll need to spend time fixing it later, or worse, end up with
    lasting mistakes in your design.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve this design, you can use a module to create a cross shape, and then
    use that module to create each of the two crosses. The following pseudocode shows
    the syntax of a module definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use the `module` keyword to start defining a new module. Then give the module
    a name that describes the new shape you are creating. Module names have the same
    restrictions as variable names, meaning you can only use lowercase and uppercase
    letters, underscores, or the digits 0 to 9\. A good name should help readers understand
    what the module does without making them read the actual code that defines the
    module. Following the `ModuleName`, add an empty pair of parentheses followed
    by the code enclosed in curly brackets. The code you write inside the curly brackets
    is no different from any other OpenSCAD code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module definition will stand alone as a separate section of your design.
    So, defining a module won’t actually draw the new shape. It’s simply a recipe
    that describes how to create a shape. To see the shape, you must create it by
    inserting the module name into your design, just as you would to create any other
    shape. Here’s the syntax for using a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A module is an example of a programmer-defined shape. In fact, all the OpenSCAD
    commands you have used so far, including `sphere`, `cylinder`, and `linear_extrude`,
    are actually modules that are built into the language. An implied `union` operation
    occurs when shapes are combined within a module, so you can transform and combine
    the shape(s) generated by a module with any operation you’ve seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Write some new code for your cookie cutter by creating a `cross` module, as
    shown in [Listing 5-2](#listing5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: The new cross-shaped cookie cutter program, improved with a module'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `module` keyword to start the definition of the new shape. Give it the
    name `cross` 1 to describe the shape you’re creating. In curly brackets following
    the name, enter the code for the shapes that define the cross 2. Finally, tell
    OpenSCAD to draw the cross by using the module name followed by a set of parentheses
    3 4. Notice that you use the `cross` module twice, so you can subtract one cross
    shape from the other with the `difference` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting Your Design into Multiple Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes when creating a new design, you’ll want to reuse a component from
    a previous project. A good way to organize this is to make the component into
    a module. Putting this module definition into a separate file will allow you to
    easily use it in both designs. Saving modules separately helps you find and reuse
    your new shapes in as many projects as you like, as well as easily share them
    with others. Also, if you make improvements to a module defined in a file that
    is used by several designs, those improvements will be applied the next time you
    open each design. Organizing module definitions into separate files is often called
    creating a *library*, especially when a new file has multiple related modules
    defined within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to save your module in a separate file, let’s split the cross-shaped
    cookie-cutter design into two files. We’ll use one file to define a cross shape,
    and then use that module in the second file to create a cookie cutter. First,
    create two empty OpenSCAD files: *cross-module.scad* and *cookie-cutter.scad*.
    Make sure you save the two files in the same folder so OpenSCAD can find the two
    files. Also, note that these filenames were chosen to clearly indicate the purpose
    of each file. Carefully choosing your filenames will help you organize your projects
    in the future, especially as you build more and more OpenSCAD projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *cross-module.scad*, copy the module definition from [Listing 5-2](#listing5-2),
    including the curly brackets, and then paste it into the file you just created.
    Be sure to save *cross-module.scad* after you’ve pasted the code so that OpenSCAD
    can use the newest version when you connect the files. The new *cross-module.scad*
    file should contain only the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in *cookie-cutter.scad*, remove the module definition and add the following
    line at the top of your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Instead of typing the module definition in *cookie-cutter.scad*, the first line
    tells OpenSCAD to use code from *cross-module.scad*. This is what provides the
    definition for the cross shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `use` keyword tells OpenSCAD to load the modules from a different file.
    The syntax for the `use` keyword is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After the `use` keyword, add *angle brackets* (`< >`), and inside the angle
    brackets, specify the name of the *.scad* file you want to use. If the file you
    want to use is not in the same folder as your main design file, specify either
    the absolute or relative path to the file. A `use` statement allows you to use
    the module definitions from the file, but it will not immediately result in any
    shape being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating a preview of *cookie-cutter.scad* will now produce the same shape
    as in [Figure 5-1](#figure5-1). However, generating a preview of *cross-module.scad*
    will not produce any shape. That is because *cross-module.scad* currently only
    contains a definition of the cross module. In order to see what the cross shape
    looks like by generating a preview of *cross-module.scad*, you need to add a statement
    to draw the cross:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding Parameters to Your Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because shapes come in different sizes, you’ll likely want your modules to allow
    for some variation. You already know that built-in OpenSCAD modules, like `sphere`,
    can take a parameter,such as `sphere(r=30);`, where the parameter specifies the
    sphere’s radius. You can add such parameters to your own modules as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pseudocode shows the full syntax for specifying a module, including
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Instead of leaving the parentheses after the module definition empty, add a
    `parameterName`, which is a placeholder for a value that you’ll provide whenever
    you use the module. You can also give each parameter a `defaultValue`, so if the
    user of a module doesn’t specify a value for a parameter, the module will use
    the default value instead. Providing a default value allows people to use the
    module without having to specify all parameters, which can be beneficial when
    experimenting with a module, or it can hide distracting details when the default
    value is a common choice. To create multiple parameters, specify multiple parameter
    names, separated by commas, and be sure to give each parameter a different name.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that parameters look a lot like variables. In fact, inside
    a module, parameters behave as if they were variables. It’s good practice to give
    parameters names that describe their purpose. As with variables and module names,
    parameter names can only include letters, underscores, or numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-3](#listing5-3) shows how to add parameters to the `cross` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: Defining the `cross` module with parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the parentheses, you add the `width` and `length` parameters, which define
    the width and length of each arm of the cross.
  prefs: []
  type: TYPE_NORMAL
- en: To create a cross shape with the `cross` module, provide specific values for
    each parameter each time you use the module, as shown in [Listing 5-4](#listing5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: Specifying values for the `cross` module'
  prefs: []
  type: TYPE_NORMAL
- en: The order of the numbers indicates which should be interpreted as the width
    of the cross and which should be interpreted as the length of the cross. Since
    the `width` parameter comes first in the definition of the module, the first number
    in the parentheses is assigned to the `width` parameter, and the second number
    is assigned to the `length` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSCAD also allows you to name your parameters explicitly when you use a
    module, which can be helpful when you create a shape with a large number of parameters
    (and keeping track of the order becomes unwieldy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use a module and name your parameters, the order of the parameters
    is not important. Switching the order of the length and width parameters does
    not affect the appearance of the shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now the module is truly dynamic; you can use it to create cookie cutters of
    any size ([Figure 5-2](#figure5-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/279547c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: A variety of cookie cutters, each created with different parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Building a LEGO Brick
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll walk through a complex modeling project that uses parameters,
    modules, and `for` loops in a single design. You’ll design a LEGO brick shape
    that has two studs in one direction and any number of studs in the other direction.
    *Studs* are the small bumps on the top of a LEGO brick that fit into other LEGO
    bricks to hold them together. [Figure 5-3](#figure5-3) shows a LEGO brick with
    two rows and four studs per row.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/279547c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: A LEGO brick with a 2×4 grid of studs'
  prefs: []
  type: TYPE_NORMAL
- en: Before coding a complicated design like this, sketching a few hand-drawn versions
    of your shape can help you gain a firm understanding of the dimensions and patterns
    that exist within the shape ([Figure 5-4](#figure5-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/279547c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: A hand-drawn exploration of the dimensions of LEGO bricks of various
    sizes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dimensions of LEGO bricks are readily available online. We’ve taken our
    dimensions from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: The height of a brick is 9.6 mm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The height of a stud is 1.7 mm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diameter of a stud is 4.8 mm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each new stud adds 8 mm to the width of the brick to accommodate not only the
    diameter of a stud, but also the empty space surrounding a stud. The length of
    a brick is also dependent on the number of studs. You’ll generate only bricks
    with two rows of studs, which implies a fixed brick length of 16 mm for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a variety of hand-drawn LEGO shapes makes it easier to identify the
    OpenSCAD statements necessary for defining a LEGO brick module.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-5](#listing5-5) defines a LEGO brick module.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: Drawing a LEGO brick with modules'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a module named `LEGObrick` with a `studs_per_row` parameter.
    This parameter represents the number of studs along the top of the LEGO brick,
    which determines the overall width along the x-axis of the brick. LEGO bricks
    come in different sizes, so this parameter will be useful as a way to reuse the
    same module to draw a variety of brick sizes. We chose to set a default value
    of 4 studs per row, but this is an arbitrary choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable called `width` is created to keep track of the overall width of
    the brick, which is based on `studs_per_row`. Each additional stud increases the
    width of the brick by 8 mm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Other dimensions of the LEGO brick remain fixed, unrelated to the number of
    studs per row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A `for` loop is used to draw each repeated stud in its proper position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `for` loop, the variable `x_position` keeps track of the x position
    of each stud. The first stud is centered at x = 4 mm 1, and each additional stud
    is positioned 8 mm 2 away from the previous stud. Similarly, the last stud in
    each row is centered 4 mm from the overall width of the brick 3. Two rows of studs
    are drawn with the exact same values on the x-axis. Since we’re restricting ourselves
    to just two studs on the y-axis, it’s easier to position the rows explicitly at
    y = 4 mm and y = 12 mm instead of using a second loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `LEGObrick` module is now complete, which means you can use it to create
    LEGO bricks of various sizes, like the ones in [Figure 5-5](#figure5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05005](image_fi/279547c05/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: A variety of LEGO bricks created with the same `LEGObrick` module'
  prefs: []
  type: TYPE_NORMAL
- en: This module is only a simplified design of a LEGO brick, however; it won’t function
    as a real brick would, because the current design doesn’t include an interior
    mechanism on the bottom of the brick for snapping bricks together. We leave that
    as a challenge for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing and Collaborating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you save your modules in separate files, you can reuse your new shapes in
    multiple designs, as you saw earlier in this chapter. Keeping your modules separate
    also allows you to share common design components with other people or use other
    people’s components instead of building everything yourself. Splitting a design
    into multiple modules allows you to collaborate more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through a possible collaboration. Say you and a friend want to work
    together to make a 3D animation of a LEGO castle. To save time, you decide to
    split the design into two tasks that can be completed in parallel using two different
    computers. Your friend decides to design a module that will draw a LEGO brick
    shape, while you will be in charge of designing a castle that is made from LEGO
    brick shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You and your friend first decide what the `LEGO` module should look like. You
    agree on a name for the module (`LEGObrick`), any necessary parameters and their
    defaults (`studs_per_row`), with a default of three studs, and the basic shape
    and size of each brick (24 × 16 × 9.6 mm for a 3×2 brick). Your friend then goes
    off and builds a simple version of the `LEGObrick` module in a file called *LEGObrick-module.scad*,
    shown in [Figure 5-6](#figure5-6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![f05006](image_fi/279547c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: A simple version of the `LEGObrick` module'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the `LEGObrick` module isn’t complete (this simple version of the
    module doesn’t have studs yet), you can still use it as a building block to start
    creating the castle design in a file called *castle-wall.scad*, as shown in [Figure
    5-7](#figure5-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/279547c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: A wall of the LEGO castle that uses a basic version of the `LEGObrick`
    module'
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, your friend keeps working on the `LEGObrick` module, and every time
    it improves, your friend shares their new version of *LEGObrick-module.scad* with
    you. Because OpenSCAD designs are plaintext files (with a *.scad* extension),
    you can share them by emailing the files as attachments, copying and pasting OpenSCAD
    code directly from email or other documents, or by using more advanced services
    like GitHub to make designs public. 3D design-sharing websites also exist. One
    of the more popular ones, which supports OpenSCAD directly, is Thingiverse ([https://thingiverse.com/](https://thingiverse.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Every time your friend shares an updated version of *LEGObrick-module.scad*,
    you replace your old version of the file with the new version. Your castle design
    in *castle-wall.scad* will update to use the newest definition of `LEGObrick`
    each time you Preview or Render your castle code. Over time, your design may look
    more like the one shown in [Figure 5-8](#figure5-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05008](image_fi/279547c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Building the castle by using the updated `LEGObrick` module'
  prefs: []
  type: TYPE_NORMAL
- en: This collaboration strategy saves you time, because you and your friend can
    work on the `LEGObrick` module and castle design simultaneously. You don’t have
    to wait for your friend to finish a part before you can make progress on your
    own part, while your friend can see how small changes in their module design effect
    the overall castle design.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to organize your design into smaller logical
    components by using modules, which can make your OpenSCAD code more readable,
    facilitate collaboration, and help you customize your design.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using modules, remember these key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Module definitions have three parts: a name, a parameter list, and a body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the module contains a collection of OpenSCAD statements that define
    the unique shape of the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use a module, create the shape by using the name of the module in your design.
    If your module isn’t showing up, check that you’re actually using the name of
    the module in your code statements; it’s possible you’ve only defined the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When designing a module, choose module names and parameters that obviously describe
    their purpose, so someone using your module won’t need to read your module definition
    to know what it does. This can also help you later if you have forgotten the module’s
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are useful for specifying a module’s characteristics. Identifying
    which variables should be included as parameters is an important part of designing
    a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying default values for parameters is a useful way to make some parameters
    optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating your module definition into other files helps you use the module
    in other OpenSCAD designs. You can also group related modules into a library.
    As with modules and variables, choose filenames that adequately describe their
    purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting your design to a module with the `use` keyword won’t immediately
    add new shapes to your design. You have to explicitly use the module in your code
    to see the new shape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s common practice to draw the shape defined by a module at the top of a module
    definition file. This is helpful for testing purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try searching online for examples of OpenSCAD modules to see more examples of
    user-defined shapes. You can learn a lot by inspecting and tinkering with other
    people’s solutions, especially when it comes to figuring out which parameters
    to include.
  prefs: []
  type: TYPE_NORMAL
