<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_165"/><span class="big"><strong>9</strong></span><br/><strong>CALLING FUNCTIONS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">Before you start writing your own functions in R, it’s useful to understand how functions are called and interpreted in an R session. First, you’ll look at how variable names are compartmentalized in R. You’ll see R’s rules for naming arguments and objects, and how R searches for arguments and other variables when a function is called. Then you’ll look at some alternative ways to specify arguments when calling a function.</p>&#13;
<h3 class="h3" id="ch09lev1sec31"><strong>9.1 Scoping</strong></h3>&#13;
<p class="noindent">To begin with, it’s important to understand R’s <em>scoping rules</em>, which determine how the language compartmentalizes objects and retrieves them in a given session. This framework also defines the situations in which duplicate object names can exist at once. For example, you’ve used the argument <code>data</code> when calling <code>matrix</code> (<a href="ch03.xhtml#ch03lev1sec12">Section 3.1</a>), but <code>data</code> is also the name of a ready-to-use function that loads data sets from contributed packages (<a href="ch08.xhtml#ch08lev2sec72">Section 8.1.2</a>). In this section, you’ll gain an introductory understanding of <span epub:type="pagebreak" id="page_166"/>how R behaves internally in these circumstances, which will help you later on when it comes to programming and executing your own functions and those of other packages.</p>&#13;
<h4 class="h4" id="ch09lev2sec79"><strong><em>9.1.1 Environments</em></strong></h4>&#13;
<p class="noindent">R enforces scoping rules with virtual <em>environments</em>. You can think of environments as separate compartments where data structures and functions are stored. They allow R to distinguish between identical names that are associated with different scopes and therefore stored in different environments. Environments are dynamic entities—new environments can be created, and existing environments can be manipulated or removed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Technically speaking, environments don’t actually contain items. Rather, they have</em> pointers <em>to the location of those items in the computer’s memory. But using the “compartment” metaphor and thinking of objects “belonging to” these compartments is useful when you’re first getting a general sense of how environments work.</em></p>&#13;
</div>&#13;
<p class="indent">There are three important kinds of environments: global environments, package environments and namespaces, and local or lexical environments.</p>&#13;
<h5 class="h5" id="ch09lev3sec19"><strong>Global Environment</strong></h5>&#13;
<p class="noindent">The <em>global environment</em> is the compartment set aside for user-defined objects. Every object you’ve created or overwritten so far has resided in the global environment of your current R session. In <a href="ch01.xhtml#ch01lev2sec12">Section 1.3.1</a>, I mentioned that a call to <code>ls()</code> lists all the objects, variables, and user-defined functions in the active workspace—more precisely, <code>ls()</code> prints the names of everything in the current global environment.</p>&#13;
<p class="indent">Starting with a new R workspace, the following code creates two objects and confirms their existence in the global environment:</p>&#13;
<pre>R&gt; foo &lt;- 4+5<br/>R&gt; bar &lt;- "stringtastic"<br/>R&gt; ls()<br/>[1] "bar" "foo"</pre>&#13;
<p class="indent">But what about all the ready-to-use objects and functions? Why aren’t those printed alongside <code>foo</code> and <code>bar</code> as members of this environment? In fact, those objects and functions belong to package-specific environments, described next.</p>&#13;
<h5 class="h5" id="ch09lev3sec20"><strong>Package Environments and Namespaces</strong></h5>&#13;
<p class="noindent">For simplicity, I’ll use the term <em>package environment</em> rather loosely to refer to the items made available by each package in R. In fact, the structure of R packages in terms of scoping is a bit more complicated. Each package environment actually represents several environments that control different aspects of a search for a given object. A package <em>namespace</em>, for example, essentially defines the visibility of its functions. (A package can <span epub:type="pagebreak" id="page_167"/>have visible functions that a user is able to use and invisible functions that provide internal support to the visible functions.) Another part of the package environment handles <em>imports</em> designations, dealing with any functions or objects from other libraries that the package needs to import for its own functionality.</p>&#13;
<p class="indent">To clarify this, you can think of all the ready-to-use functions and objects you’re working with in this book as belonging to specific package environments. The same is true for the functions and objects of any contributed packages you’ve explicitly loaded with a call to <code>library</code>. You can use <code>ls</code> to list the items in a package environment as follows:</p>&#13;
<pre>R&gt; ls("package:graphics")<br/> [1] "abline"          "arrows"          "assocplot"       "axis"<br/> [5] "Axis"            "axis.Date"       "axis.POSIXct"    "axTicks"<br/> [9] "barplot"         "barplot.default" "box"             "boxplot"<br/>[13] "boxplot.default" "boxplot.matrix"  "bxp"             "cdplot"<br/>[17] "clip"            "close.screen"    "co.intervals"    "contour"<br/>[21] "contour.default" "coplot"          "curve"           "dotchart"<br/>[25] "erase.screen"    "filled.contour"  "fourfoldplot"    "frame"<br/>[29] "grconvertX"      "grconvertY"      "grid"            "hist"<br/>[33] "hist.default"    "identify"        "image"           "image.default"<br/>[37] "layout"          "layout.show"     "lcm"             "legend"<br/>[41] "lines"           "lines.default"   "locator"         "matlines"<br/>[45] "matplot"         "matpoints"       "mosaicplot"      "mtext"<br/>[49] "pairs"           "pairs.default"   "panel.smooth"    "par"<br/>[53] "persp"           "pie"             "plot"            "plot.default"<br/>[57] "plot.design"     "plot.function"   "plot.new"        "plot.window"<br/>[61] "plot.xy"         "points"          "points.default"  "polygon"<br/>[65] "polypath"        "rasterImage"     "rect"            "rug"<br/>[69] "screen"          "segments"        "smoothScatter"   "spineplot"<br/>[73] "split.screen"    "stars"           "stem"            "strheight"<br/>[77] "stripchart"      "strwidth"        "sunflowerplot"   "symbols"<br/>[81] "text"            "text.default"    "title"           "xinch"<br/>[85] "xspline"         "xyinch"          "yinch"</pre>&#13;
<p class="indent">The <code>ls</code> command lists all of the visible objects contained in the <code>graphics</code> package environment. Note that this list includes some of the functions you used in <a href="ch07.xhtml#ch07">Chapter 7</a>, such as <code>arrows</code>, <code>plot</code>, and <code>segments</code>.</p>&#13;
<h5 class="h5" id="ch09lev3sec21"><strong>Local Environments</strong></h5>&#13;
<p class="noindent">Each time a function is called in R, a new environment is created called the <em>local environment</em>, sometimes referred to as the <em>lexical environment</em>. This local environment contains all the objects and variables created in and visible to the function, including any arguments you’ve supplied to the function upon execution. It’s this feature that allows the presence of argument names that are identical to other object names accessible in a given workspace.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>For example, say you call <code>matrix</code> and pass in the argument <code>data</code>, as follows:</p>&#13;
<pre>R&gt; youthspeak &lt;- matrix(data=c("OMG","LOL","WTF","YOLO"),nrow=2,ncol=2)<br/>R&gt; youthspeak<br/>     [,1]  [,2]<br/>[1,] "OMG" "WTF"<br/>[2,] "LOL" "YOLO"</pre>&#13;
<p class="indent">Calling this function creates a local environment containing the <code>data</code> vector. When you execute the function, it begins by looking for <code>data</code> in this local environment. That means R isn’t confused by other objects or functions named <code>data</code> in other environments (such as the <code>data</code> function automatically loaded from the <code>utils</code> package environment). If a required item isn’t found in the local environment, only then does R begin to widen its search for that item (I’ll discuss this feature a little more in <a href="ch09.xhtml#ch09lev2sec80">Section 9.1.2</a>). Once the function has completed, this local environment is automatically removed. The same comments apply to the <code>nrow</code> and <code>ncol</code> arguments.</p>&#13;
<h4 class="h4" id="ch09lev2sec80"><strong><em>9.1.2 Search Path</em></strong></h4>&#13;
<p class="noindent">To access data structures and functions from environments other than the immediate global environment, R follows a <em>search path</em>. The search path lays out all the environments that a given R session has available to it.</p>&#13;
<p class="indent">The search path is basically a list of the environments that R will search when an object is requested. If the object isn’t found in one environment, R proceeds to the next one. You can view R’s search path at any time using <code>search()</code>.</p>&#13;
<pre>R&gt; search()<br/> [1] ".GlobalEnv"        "tools:RGUI"         "package:stats"<br/> [4] "package:graphics"  "package:grDevices"  "package:utils"<br/> [7] "package:datasets"  "package:methods"    "Autoloads"<br/>[10] "package:base"</pre>&#13;
<p class="indent">From the command prompt, this path will always begin at the global user environment (<code>.GlobalEnv</code>) and end after the <code>base</code> package environment (<code>package:base</code>). You can think of these as belonging to a hierarchy, with an arrow pointing from left to right between each pair of environments. For my current session, if I request a certain object at the R prompt, the program will inspect <code>.GlobalEnv</code> → <code>tools:RGUI</code> → <code>package:stats</code> → ... → <code>package:base</code> in turn, stopping the search when the desired object is found and retrieved. Note that, depending on your operating system and whether you’re using the built-in GUI, <code>tools:RGUI</code> might not be included in your search path.</p>&#13;
<p class="indent">If R doesn’t find what it’s looking for by following the environments in the search path, the <em>empty environment</em> is reached. The empty environment is not explicitly listed in the output from <code>search()</code>, but it’s always the final <span epub:type="pagebreak" id="page_169"/>destination after <code>package:base</code>. This environment is special because it marks the end of the search path.</p>&#13;
<p class="indent">For example, if you call the following, a number of things happen internally:</p>&#13;
<pre>R&gt; baz &lt;- seq(from=0,to=3,length.out=5)<br/>R&gt; baz<br/>[1] 0.00 0.75 1.50 2.25 3.00</pre>&#13;
<p class="indent">R first searches the global environment for a function called <code>seq</code>, and when this isn’t found, it goes on to search in the enclosing environment, which is the next level up in the search path (according to the left-to-right arrows mentioned earlier). It doesn’t find it there, so R keeps going through the path to the next environment, searching the packages that have been loaded (automatically or otherwise) until it finds what it’s looking for. In this example, R locates <code>seq</code> in the built-in <code>base</code> package environment. Then it executes the <code>seq</code> function (creating a temporary local environment) and assigns the results to a new object, <code>baz</code>, which resides in the global environment. In the subsequent call to print <code>baz</code>, R begins by searching the global environment and immediately finds the requested object.</p>&#13;
<p class="indent">You can look up the enclosing environment of any function using <code>environment</code>, as follows:</p>&#13;
<pre>R&gt; environment(seq)<br/>&lt;environment: namespace:base&gt;<br/>R&gt; environment(arrows)<br/>&lt;environment: namespace:graphics&gt;</pre>&#13;
<p class="indent">Here, I’ve identified the package namespace of <code>base</code> as the owner of the <code>seq</code> function and the <code>graphics</code> package as the owner of the <code>arrows</code> function.</p>&#13;
<p class="indent">Each environment has a <em>parent</em>, to direct the order of the search path. Examining the earlier output from the call <code>search()</code>, you can see that the parent of <code>package:stats</code>, for example, is <code>package:graphics</code>. The specific parent-child structure is dynamic in the sense that the search path changes when additional libraries are loaded or data frames are <code>attach</code>ed. When you load a contributed package with a call to <code>library</code>, this essentially just inserts the desired package in the search path. For example, in <a href="ch08.xhtml#ch8exc1">Exercise 8.1</a> on <a href="ch08.xhtml#page_161">page 161</a>, you installed the contributed package <code>car</code>. After loading this package, your search path will include its contents.</p>&#13;
<pre>R&gt; library("car")<br/>R&gt; search()<br/> [1] ".GlobalEnv"         "package:car"        "tools:RGUI"<br/> [4] "package:stats"      "package:graphics"   "package:grDevices"<br/> [7] "package:utils"      "package:datasets"   "package:methods"<br/>[10] "Autoloads"          "package:base"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>Note the position of the <code>car</code> package environment in the path—inserted directly after the global environment. This is where each subsequently loaded package will be placed (followed by any additional packages it depends upon for its own functionality).</p>&#13;
<p class="indent">As noted earlier, R will stop searching once it has exhausted the entire search path and reached the empty environment. If you request a function or object that you haven’t defined, that doesn’t exist, or that is perhaps in a contributed package that you’ve forgotten to load (this is quite a common little mistake), then an error is thrown. These “cannot find” errors are recognizable for both functions and other objects.</p>&#13;
<pre>R&gt; neither.here()<br/>Error: could not find function "neither.here"<br/>R&gt; nor.there<br/>Error: object 'nor.there' not found</pre>&#13;
<p class="indent">Environments help compartmentalize the huge amount of functionality in R. This becomes particularly important when there are functions with the same name in different packages in the search path. At that point, <em>masking</em>, discussed in <a href="ch12.xhtml#ch12lev1sec41">Section 12.3</a>, comes into play.</p>&#13;
<p class="indent">As you get more comfortable with R and want more precise control over how it operates, it’s worth investigating in full how R handles environments. For more technical details on this, Gupta (<a href="ref.xhtml#ref27">2012</a>) provides a particularly well-written online article.</p>&#13;
<h4 class="h4" id="ch09lev2sec81"><strong><em>9.1.3 Reserved and Protected Names</em></strong></h4>&#13;
<p class="noindent">A few key terms are strictly forbidden from being used as object names in R. These <em>reserved</em> names are necessary in order to protect fundamental operations and data types frequently used in the language.</p>&#13;
<p class="indentb">The following identifiers are reserved:</p>&#13;
<p class="bull">• <code>if</code> and <code>else</code></p>&#13;
<p class="bull">• <code>for</code>, <code>while</code>, and <code>in</code></p>&#13;
<p class="bull">• <code>function</code></p>&#13;
<p class="bull">• <code>repeat</code>, <code>break</code>, and <code>next</code></p>&#13;
<p class="bull">• <code>TRUE</code> and <code>FALSE</code></p>&#13;
<p class="bull">• <code>Inf</code> and <code>-Inf</code></p>&#13;
<p class="bull">• <code>NA</code>, <code>NaN</code>, and <code>NULL</code></p>&#13;
<p class="indentt">I haven’t yet covered some of the terms on this list. These items represent the core tools for programming in the R language, and you’ll begin to explore them in the following chapter. The last three bullet points include the familiar logical values (<a href="ch04.xhtml#ch04lev1sec16">Section 4.1</a>) and special terms used to represent things like infinity and missing entries (<a href="ch06.xhtml#ch06lev1sec21">Section 6.1</a>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>If you try to assign a new value to any of these reserved terms, an error occurs.</p>&#13;
<pre>R&gt; NaN &lt;- 5<br/>Error in NaN &lt;- 5 : invalid (do_set) left-hand side to assignment</pre>&#13;
<p class="indent">Because R is case sensitive, it’s possible to assign values to any case-variant of the reserved names, but this can be confusing and is generally not advisable.</p>&#13;
<pre>R&gt; False &lt;- "confusing"<br/>R&gt; nan &lt;- "this is"<br/>R&gt; cat(nan,False)<br/>this is confusing</pre>&#13;
<p class="indent">Also be wary of assigning values to <code>T</code> and <code>F</code>, the abbreviations of <code>TRUE</code> and <code>FALSE</code>. The full identifiers <code>TRUE</code> and <code>FALSE</code> are reserved, but the abbreviated versions are not.</p>&#13;
<pre>R&gt; T &lt;- 42<br/>R&gt; F &lt;- TRUE<br/>R&gt; F&amp;&amp;TRUE<br/>[1] TRUE</pre>&#13;
<p class="indent">Assigning values to <code>T</code> and <code>F</code> this way will affect any subsequent code that intends to use <code>T</code> and <code>F</code> to refer to <code>TRUE</code> and <code>FALSE</code>. The second assignment (<code>F &lt;- TRUE</code>) is perfectly legal in R’s eyes, but it’s extremely confusing given the normal usage of <code>F</code> as an abbreviation: the line <code>F&amp;&amp;TRUE</code> now represents a <code>TRUE&amp;&amp;TRUE</code> comparison! It’s best to simply avoid these types of assignments.</p>&#13;
<p class="indent">If you’ve been following along with the examples in your R console, it’s prudent at this point to clear the global environment (thereby deleting the objects <code>False</code>, <code>nan</code>, <code>T</code>, and <code>F</code> from your workspace). To do this, use the <code>rm</code> function as shown next. Using <code>ls()</code>, supply a character vector of all objects in the global environment as the argument <code>list</code>.</p>&#13;
<pre>R&gt; ls()<br/>[1] "bar"        "baz"        "F"       "False"     "foo"        "nan"<br/>[7] "T"          "youthspeak"<br/>R&gt; rm(list=ls())<br/>R&gt; ls()<br/>character(0)</pre>&#13;
<p class="indent">Now the global environment is empty, and calling <code>ls()</code> returns an empty character vector (<code>character(0)</code>).</p>&#13;
<div class="ex">&#13;
<p class="ext"><span epub:type="pagebreak" id="page_172"/><a id="ch9exc1"/><strong>Exercise 9.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Identify the first 20 items contained in the built-in and automatically loaded <code>methods</code> package. How many items are there in total?</p></li>&#13;
<li><p class="noindents">Determine the environment that owns each of the following functions:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents"><code>read.table</code></p></li>&#13;
<li><p class="noindents"><code>data</code></p></li>&#13;
<li><p class="noindents"><code>matrix</code></p></li>&#13;
<li><p class="noindents"><code>jpeg</code></p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Use <code>ls</code> and a test for character string equality to confirm the function <code>smoothScatter</code> is part of the <code>graphics</code> package.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch09lev1sec32"><strong>9.2 Argument Matching</strong></h3>&#13;
<p class="noindent">Another set of rules that determine how R interprets function calls has to do with <em>argument matching</em>. Argument matching conditions allow you to provide arguments to functions either with abbreviated names or without names at all.</p>&#13;
<h4 class="h4" id="ch09lev2sec82"><strong><em>9.2.1 Exact</em></strong></h4>&#13;
<p class="noindent">So far, you’ve mostly been using <em>exact</em> matching of arguments, where each argument tag is written out in full. This is the most exhaustive way to call a function. It’s helpful to write out full argument names this way when first getting to know R or a new function.</p>&#13;
<p class="indentb">Other benefits of exact matching include the following:</p>&#13;
<p class="bull">• Exact matching is less prone to mis-specification of arguments than other matching styles.</p>&#13;
<p class="bull">• The order in which arguments are supplied doesn’t matter.</p>&#13;
<p class="bull">• Exact matching is useful when a function has many possible arguments but you want to specify only a few.</p>&#13;
<p class="indenttb">The main drawbacks of exact matching are clear:</p>&#13;
<p class="bull">• It can be cumbersome for relatively simple operations.</p>&#13;
<p class="bull">• Exact matching requires the user to remember or look up the full, case-sensitive tags.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/>As an example, in <a href="ch06.xhtml#ch06lev2sec59">Section 6.2.1</a>, you used exact matching to execute the following:</p>&#13;
<pre>R&gt; bar &lt;- matrix(data=1:9,nrow=3,ncol=3,dimnames=list(c("A","B","C"),<br/>                                                      c("D","E","F")))<br/>R&gt; bar<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indent">This creates a 3 × 3 matrix object <code>bar</code> with a <code>dimnames</code> attribute for the rows and columns. Since the argument tags are fully specified, the order of the arguments doesn’t matter. You could switch around the arguments, and the function still has all the information it requires.</p>&#13;
<pre>R&gt; bar &lt;- matrix(nrow=3,dimnames=list(c("A","B","C"),c("D","E","F")),ncol=3,<br/>                 data=1:9)<br/>R&gt; bar<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indent">This behaves the same way as the previous function call. For the sake of consistency, you usually won’t switch around arguments each time you call a function, but this example shows a benefit of exact matching: you don’t have to worry about the order of any optional arguments or about skipping them.</p>&#13;
<h4 class="h4" id="ch09lev2sec83"><strong><em>9.2.2 Partial</em></strong></h4>&#13;
<p class="noindent"><em>Partial</em> matching lets you identify arguments with an abbreviated tag. This can shorten your code, and it still lets you provide arguments in any order.</p>&#13;
<p class="indent">Here is another way to call <code>matrix</code> that takes advantage of partial matching:</p>&#13;
<pre>R&gt; bar &lt;- matrix(nr=3,di=list(c("A","B","C"),c("D","E","F")),nc=3,dat=1:9)<br/>R&gt; bar<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_174"/>Notice I’ve shortened the <code>nrow</code>, <code>dimnames</code>, and <code>ncol</code> argument tags to the first two letters and shortened the <code>data</code> argument to the first three. For partial matching, there’s no set number of letters you have to provide, as long as each argument is still uniquely identifiable for the function being called. Partial matching has the following benefits:</p>&#13;
<p class="bull">• It requires less code than exact matching.</p>&#13;
<p class="bull">• Argument tags are still visible (which limits the possibility of mis-specification).</p>&#13;
<p class="bull">• The order of supplied arguments still doesn’t matter.</p>&#13;
<p class="indentt">But partial matching also has some limitations. For one, it gets trickier if there are multiple arguments whose tags start with the same letters. Here’s an example:</p>&#13;
<pre>R&gt; bar &lt;- matrix(nr=3,di=list(c("A","B","C"),c("D","E","F")),nc=3,d=1:9)<br/>Error in matrix(nr = 3, di = list(c("A", "B", "C"), c("D", "E", "F")), :<br/>  argument 4 matches multiple formal arguments</pre>&#13;
<p class="indent">An error has occurred. The fourth argument tag is designated simply as <code>d</code>, which is meant to stand for <code>data</code>. This is illegal because another argument, namely <code>dimnames</code>, also starts with <code>d</code>. Even though <code>dimnames</code> is specified separately as <code>di</code> earlier in the same line, the call isn’t valid.</p>&#13;
<p class="indentb">Drawbacks of partial matching include the following:</p>&#13;
<p class="bull">• The user must be aware of other potential arguments that can be matched by the shortened tag (even if they aren’t specified in the call or have a default value assigned).</p>&#13;
<p class="bull">• Each tag must have a unique identification, which can be difficult to remember.</p>&#13;
<h4 class="h4" id="ch09lev2sec84"><strong><em>9.2.3 Positional</em></strong></h4>&#13;
<p class="noindent">The most compact mode of function calling in R is <em>positional matching</em>. This is when you supply arguments without tags, and R interprets them based solely on their order.</p>&#13;
<p class="indent">Positional matching is usually used for relatively simple functions with only a few arguments, or functions that are very familiar to the user. For this type of matching, you <em>must</em> be aware of the precise positions of each argument. You can find that information in the “Usage” section of the function’s help file, or it can be printed to the console with the <code>args</code> function. Here’s an example:</p>&#13;
<pre>R&gt; args(matrix)<br/>function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)<br/>NULL</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_175"/>This shows the defined order of arguments of the <code>matrix</code> function, as well as the default value for each argument. To construct the matrix <code>bar</code> with positional matching, execute the following:</p>&#13;
<pre>R&gt; bar &lt;- matrix(1:9,3,3,F,list(c("A","B","C"),c("D","E","F")))<br/>R&gt; bar<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indentb">The benefits of positional matching are as follows:</p>&#13;
<p class="bull">• Shorter, cleaner code, particularly for routine tasks</p>&#13;
<p class="bull">• No need to remember specific argument tags</p>&#13;
<p class="indentt">Notice that when using exact and partial matching, you didn’t need to supply anything for the <code>byrow</code> argument, which, by default, is set to <code>FALSE</code>. With positional matching, you must provide a value (given here as <code>F</code>) for <code>byrow</code> as the fourth argument because R relies on position alone to interpret the function call. If you leave out the argument, you get an error, as follows:</p>&#13;
<pre>R&gt; bar &lt;- matrix(1:9,3,3,list(c("A","B","C"),c("D","E","F")))<br/>Error in matrix(1:9, 3, 3, list(c("A", "B", "C"), c("D", "E", "F"))) :<br/>  invalid 'byrow' argument</pre>&#13;
<p class="indentb">Here R has tried to assign the fourth argument (the list you intended for <code>dimnames</code>) as the value for the logical <code>byrow</code> argument. This brings us to the drawbacks of positional matching:</p>&#13;
<p class="bull">• You must look up and exactly match the defined order of arguments.</p>&#13;
<p class="bull">• Reading code written by someone else can be more difficult, especially when it includes unfamiliar functions.</p>&#13;
<h4 class="h4" id="ch09lev2sec85"><strong><em>9.2.4 Mixed</em></strong></h4>&#13;
<p class="noindent">Since each matching style has pros and cons, it’s quite common, and perfectly legal, to mix these three styles in a single function call.</p>&#13;
<p class="indent">For instance, you can avoid the type of error shown in the previous example like so:</p>&#13;
<pre>R&gt; bar &lt;- matrix(1:9,3,3,dim=list(c("A","B","C"),c("D","E","F")))<br/>R&gt; bar<br/>  D E F<br/>A 1 4 7<br/>B 2 5 8<br/>C 3 6 9</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>Here I’ve used positional matching for the first three arguments, which are by now familiar to you. At the same time, I’ve used partial matching to explicitly tell R that the list is meant as a <code>dimnames</code> value, not for <code>byrow</code>.</p>&#13;
<h4 class="h4" id="ch09lev2sec86"><strong><em>9.2.5 Dot-Dot-Dot: Use of Ellipses</em></strong></h4>&#13;
<p class="noindent">Many functions exhibit <em>variadic</em> behavior. That is, they can accept any number of arguments, and it’s up to the user to decide how many arguments to provide. The functions <code>c</code>, <code>data.frame</code>, and <code>list</code> are all like this. When you call a function like <code>data.frame</code>, you can specify any number of members as arguments.</p>&#13;
<p class="indent">This flexibility is achieved in R through the special <em>dot-dot-dot</em> designation (<code>...</code>), also called the <em>ellipsis</em>. This construct allows the user to supply any number of data vectors (these become the columns in the final data frame). You can see whether an ellipsis is used in a function on the function’s help page or with <code>args</code>. Looking at <code>data.frame</code>, notice the first argument slot is an ellipsis:</p>&#13;
<pre>R&gt; args(data.frame)<br/>function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE,<br/>    stringsAsFactors = default.stringsAsFactors())<br/>NULL</pre>&#13;
<p class="indent">When you call a function and supply an argument that can’t be matched with one of the function’s defined argument tags, normally this would produce an error. But if the function is defined with an ellipsis, any arguments that aren’t matched to other argument tags are matched to the ellipsis.</p>&#13;
<p class="indent">Functions that employ ellipses generally fall into two groups. The first group includes functions such as <code>c</code>, <code>data.frame</code>, and <code>list</code>, where the ellipsis always represents the “main ingredients” in the function call. That is, the objective of the function is to use contents of the ellipsis in the resulting object or output. The second group consists of functions where the ellipsis is meant as a <em>supplementary</em> or <em>potential</em> repository of optional arguments. This is common when the function of interest calls other <em>subfunctions</em> that themselves require additional arguments depending upon the originally supplied items. Rather than explicitly copy all the arguments desired by the subfunction into the argument list of the “parent” function, the parent function can instead be defined including an ellipsis that is subsequently provided to the subfunction.</p>&#13;
<p class="indent">Here’s an example of the ellipsis used for supplementary arguments with the generic <code>plot</code> function:</p>&#13;
<pre>R&gt; args(plot)<br/>function (x, y, ...)<br/>NULL</pre>&#13;
<p class="indent">From examining the arguments, it’s clear that optional arguments such as point size (argument tag <code>cex</code>) or line type (argument tag <code>lty</code>), if supplied, <span epub:type="pagebreak" id="page_177"/>are matched to the ellipsis. These optional arguments are then passed in to the function to be used by various methods that tweak graphical parameters.</p>&#13;
<p class="indent">Ellipses are a convenient programming tool for writing variadic functions or functions where an unknown number of arguments may be supplied. This will become clearer when you start writing your own functions in <a href="ch11.xhtml#ch11">Chapter 11</a>. However, when writing functions like this, it’s important to properly document the intended use of <code>...</code> so the potential users of the function know exactly which arguments can be passed to it and what those arguments are subsequently used for in execution.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch9exc2"/><strong>Exercise 9.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Use positional matching with <code>seq</code> to create a sequence of values between −4 and 4 that progresses in steps of 0.2.</p></li>&#13;
<li><p class="noindents">In each of the following lines of code, identify which style of argument matching is being used: exact, partial, positional, or mixed. If mixed, identify which arguments are specified in each style.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents"><code>array(8:1,dim=c(2,2,2))</code></p></li>&#13;
<li><p class="noindents"><code>rep(1:2,3)</code></p></li>&#13;
<li><p class="noindents"><code>seq(from=10,to=8,length=5)</code></p></li>&#13;
<li><p class="noindents"><code>sort(decreasing=T,x=c(2,1,1,2,0.3,3,1.3))</code></p></li>&#13;
<li><p class="noindents"><code>which(matrix(c(T,F,T,T),2,2))</code></p></li>&#13;
<li><p class="noindents"><code>which(matrix(c(T,F,T,T),2,2),a=T)</code></p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Suppose you explicitly ran the plotting function <code>plot.default</code> and supplied values to arguments tagged <code>type</code>, <code>pch</code>, <code>xlab</code>, <code>ylab</code>, <code>lwd</code>, <code>lty</code>, and <code>col</code>. Use the function documentation to determine which of these arguments fall under the umbrella of the ellipsis.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch09lev3sec22"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>ls</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Inspect environment objects</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch09.xhtml#ch09lev2sec79">Section 9.1.1</a>, <a href="ch09.xhtml#page_167">p. 167</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>search</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Current search path</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch09.xhtml#ch09lev2sec80">Section 9.1.2</a>, <a href="ch09.xhtml#page_168">p. 168</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>environment</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Function environment properties</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch09.xhtml#ch09lev2sec80">Section 9.1.2</a>, <a href="ch09.xhtml#page_169">p. 169</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rm</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Delete objects in workspace</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch09.xhtml#ch09lev2sec81">Section 9.1.3</a>, <a href="ch09.xhtml#page_171">p. 171</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>args</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Show function arguments</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch09.xhtml#ch09lev2sec84">Section 9.2.3</a>, <a href="ch09.xhtml#page_174">p. 174</a><span epub:type="pagebreak" id="page_178"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>