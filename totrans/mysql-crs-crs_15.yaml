- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Triggers
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll create triggers, database objects that automatically
    *fire*, or execute, before or after a row is inserted, updated, or deleted from
    a table, and perform the functionality you’ve defined. Every trigger is associated
    with one table.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers are most often used to track changes made to a table or to enhance
    the data’s quality before it’s saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Like functions and procedures, triggers are saved in the database in which you
    create them.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers That Audit Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll first use triggers to track changes to a database table by creating a
    second *audit table* that logs which user changed which piece of data and saves
    the date and time of the change.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following `payable` table in a company’s `accounting` database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an audit table that tracks any changes made to the `payable` table,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll create triggers so that when changes are made to the `payable` table,
    a record of the changes is saved to the `payable_audit` table. You’ll save the
    date and time of the change to the `audit_datetime` column; the user who made
    the change to the `audit_user` column; and a text description of what changed
    to the `audit_change` column.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers can be set to fire either before or after rows are changed. The first
    set of triggers you’ll create are *after* triggers. You’ll set three triggers
    to fire after changes are made to data in the `payable` table.
  prefs: []
  type: TYPE_NORMAL
- en: After Insert Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *after insert* trigger (indicated in the code by the suffix `_ai`) fires
    after a row is inserted. [Listing 12-1](#listing12-1) shows how to create an after
    insert trigger for the `payable` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Creating an after insert trigger'
  prefs: []
  type: TYPE_NORMAL
- en: First you create your trigger and call it `tr_payable_ai` ❶. Next, you specify
    the `after` keyword to indicate when the trigger should fire ❷. In this example,
    a row will be inserted into the `payable` table and *then* the trigger will fire,
    writing the audit row to the `payable_audit` table.
  prefs: []
  type: TYPE_NORMAL
- en: In the trigger, for each row ❸ that gets inserted into the `payable` table,
    MySQL will run the code between the `begin` and `end` statements. All triggers
    will include the `for each row` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You insert a row into the `payable_audit` table with an `insert` statement
    that calls three functions: `now()` to get the current date and time; `user()`
    to get the username of the user who inserted the row; and `concat()` to build
    a string describing the data that was inserted into the `payable` table ❹.'
  prefs: []
  type: TYPE_NORMAL
- en: When writing triggers, you use the `new` keyword to access the new values being
    inserted into the table ❺. For example, you got the new `payable_id` value by
    referencing `new.payable_id`, and the new `company` value by referencing `new.company`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have the trigger in place, try inserting a row into the `payable`
    table to see if the new row automatically gets tracked in the `payable_audit`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show that your trigger worked. Inserting a new row into the `payable`
    table caused your `tr_payable_ai` trigger to fire, which inserted a row into your
    `payable_audit` audit table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `audit_datetime` column shows the date and time that the row was inserted.
    The `audit_user` column shows the username and the host of the user who inserted
    the row (the *host* is the server where the MySQL database resides). The `audit_change`
    column contains a description of the added row you built with the `concat()` function.
  prefs: []
  type: TYPE_NORMAL
- en: After Delete Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll write an *after delete* trigger (specified in code with the suffix
    `_ad`) that will log any rows that are deleted from the `payable` table to the
    `payable_audit` table ([Listing 12-2](#listing12-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Creating an after delete trigger'
  prefs: []
  type: TYPE_NORMAL
- en: The `delete` trigger looks similar to the `insert` trigger except for a few
    differences; namely, you used the `old` keyword ❶ instead of `new`. Since this
    trigger fires when a row is deleted, there are only `old` values for the columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your after delete trigger in place, delete a row from the `payable` table
    and see if the deletion gets logged in the `payable_audit` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The trigger worked! The `payable_audit` table still contains the row you inserted
    into the `payable` table, but you also have a row that tracked the deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether rows get inserted or deleted, you’re logging the changes
    to the same `payable_audit` table. You included the text `New row` or `Deleted
    row` as part of your `audit_change` column value to clarify the action taken.
  prefs: []
  type: TYPE_NORMAL
- en: After Update Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write an *after* *update* trigger (`_au`) that will log any rows that are
    updated in the `payable` table to the `payable_audit` table, enter the code in
    [Listing 12-3](#listing12-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Creating an after update trigger'
  prefs: []
  type: TYPE_NORMAL
- en: You declare this trigger to fire after an update to the `payable` table. When
    you update a row in a table, you can update one or more of its columns. You design
    your after update trigger to show only the column values that changed in the `payable`
    table. For example, if you didn’t change the `service` column, you won’t include
    any text about the `service` column in the `payable_audit` table.
  prefs: []
  type: TYPE_NORMAL
- en: You create a user variable called `@change_msg` ❶ (for *change message*) that
    you use to build a string that contains a list of every updated column. You check
    whether each column in the `payable` table has changed. If the old `company` column
    value is different from the new `company` column value, you add the text `Company
    changed from` `old value` `to` `new value` to the `@change_msg` variable ❷. You
    then do the same thing with the `amount` and `service` columns, adjusting the
    message text accordingly. When you’re done, the value of `@change_msg` is inserted
    into the `audit_change` column of the `payable_audit` table ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'With your after update trigger in place, see what happens when a user updates
    a row in the `payable` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two rows in the `payable_audit` table are still in the results, along
    with a new row that tracked the `update` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It seems that a user named `larry@localhost` updated a row, changed the `amount`
    to $100,000, and changed the `company` that will be paid to `House of Larry`.
    Hmmm . . .
  prefs: []
  type: TYPE_NORMAL
- en: Triggers That Affect Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also write triggers that fire *before* rows are changed in a table,
    to change the data that gets written to tables or prevent rows from being inserted
    or deleted. This can help improve the quality of your data before you save it
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `credit` table in the `bank` database that will store customers and
    their credit scores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with after triggers, there are three before triggers that will fire before
    a row is inserted, deleted, or updated.
  prefs: []
  type: TYPE_NORMAL
- en: Before Insert Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *before insert* trigger (`_bi`) fires before a new row is inserted. [Listing
    12-4](#listing12-4) shows how to write a before insert trigger to make sure no
    scores outside of the 300–850 range (the lowest possible credit score and the
    highest) get inserted into the `credit` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: Creating a before insert trigger'
  prefs: []
  type: TYPE_NORMAL
- en: First, you name the trigger `tr_credit_bi` ❶ and define it as a `before insert`
    trigger ❷ so that it will fire before rows are inserted into the `credit` table.
    Because this is an insert trigger, you can take advantage of the `new` keyword
    by checking if `new.credit_score`—the value about to be inserted into the `credit`
    table—is less than 300\. If so, you set it to exactly `300` ❸. You do a similar
    check for credit scores over 850, changing their value to exactly `850` ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert some data into the `credit` table and see what effect your trigger has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now take a look at the data in the `credit` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Your trigger worked. It changed the credit score for Milton Megabucks from `987`
    to `850` and the credit score for Patti Po from `145` to `300` just before those
    values were inserted into the `credit` table.
  prefs: []
  type: TYPE_NORMAL
- en: Before Update Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *before update* trigger (`_bu`) fires before a table is updated. You already
    wrote a trigger that prevents an `insert` statement from setting a credit score
    outside of the 300–850 range, but it’s possible that an `update` statement could
    update a credit score value outside of that range too. [Listing 12-5](#listing12-5)
    shows how to create a `before` `update` trigger to solve this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: Creating a before update trigger'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update a row to test your trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now take a look at the data in the `credit` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It worked. The trigger would not let you update the credit score for `Vinny
    Middle-Class` to `1111`. Instead, it set the value to `850` before updating the
    row in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Before Delete Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lastly, a *before delete* trigger (`_bd`) will fire before a row is deleted
    from a table. You can use a before delete trigger as a check before you allow
    the row to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Say your bank manager asked you to write a trigger that prevents users from
    deleting any customers from the `credit` table that have a credit score over 750\.
    You can achieve this by writing a before delete trigger as shown in [Listing 12-6](#listing12-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-6: Creating a before delete trigger'
  prefs: []
  type: TYPE_NORMAL
- en: If the credit score of the row you’re about to delete is over 750, the trigger
    returns an error ❶. You use a `signal` statement, which handles returning an error,
    followed by the `sqlstate` keyword and code. A *sqlstate code* is a five-character
    code that identifies a particular error or a warning. Since you’re creating your
    own error, you use `45000`, which represents a user-defined error. Then, you define
    the `message_text` to display your error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your trigger by deleting some rows from the `credit` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since customer `1` has a credit score of 850, the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Your trigger worked. It prevented the deletion of the row because the credit
    score was over 750.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now delete the row for customer `2`, who has a credit score of 300:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You get a message back informing you that the row was deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Your trigger is working as you intended. It allowed you to delete the row for
    customer `2` because their credit score was not more than 750, but prevented you
    from deleting customer `1` because their credit score was over 750.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you created triggers that automatically fire and perform tasks
    you define. You learned the differences between before and after triggers, and
    the three types of each. You used triggers to track changes to tables, prevent
    particular rows from being deleted, and control ranges of allowed values.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to use MySQL events to schedule tasks.
  prefs: []
  type: TYPE_NORMAL
