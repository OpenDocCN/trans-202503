["```\n$ **ssh-keygen -t rsa -f ~/.ssh/dftd -C dftd**\nGenerating public/private rsa key pair.\nEnter passphrase (empty for no passphrase): `<passphrase>`\nEnter same passphrase again: `<passphrase>`\nYour identification has been saved in /Users/bradleyd/.ssh/dftd.\nYour public key has been saved in /Users/bradleyd/.ssh/dftd.pub.\n```", "```\n- name: Set authorized key file from local user\n  authorized_key:\n    user: bender\n    state: present\n    key: \"{{ lookup('file', lookup('env','HOME') + '/.ssh/dftd.pub') }}\"\n```", "````## Adding Two-Factor Authentication    Security is built in layers. The more layers you have, the harder it is for an intruder to gain access. The next layer of security to add is *two-factor authentication (2FA**)*, which validates a user’s identity by using credentials and something that the user has, like a phone or device. The main goal of 2FA is to make it harder for someone to spoof your identity if your password or key is compromised.    Two-factor authentication relies on your providing two out of these three things: *something you know*, *something you have*, and *something you are*. Here are some examples of each:    1.  Something you know: password or pin 2.  Something you have: phone or hardware authentication device, such as a YubiKey 3.  Something you are: fingerprint or voice    For this example, you’ll use a *time-based one-time password (TOTP)* to satisfy the “something you have” portion, along with your public key for access. You’ll use the `Google Authenticator` package to configure your VM to use TOTP tokens for logging in. These TOTP tokens are usually generated from an application like `oathtool` ([https://www.nongnu.org/oath-toolkit/](https://www.nongnu.org/oath-toolkit/)) and are valid for only a short period of time. I have taken the liberty of creating 10 TOTP tokens that Ansible will use for you, but I will also show you how to use `oathtool` (more on this later).    To enforce 2FA on your VM, you’ll use some provided Ansible tasks to install another PAM module, configure the SSH server, and enable 2FA. To review the provided tasks, first open the *two_factor.yml* file in your editor. (All the Ansible files for this chapter are located in the *ansible/chapter3/* directory.) This file has seven tasks, and each task has a specific job to enable 2FA. The tasks are named as follows:    1.  Install the `libpam-google-authenticator` package. 2.  Copy over preconfigured `GoogleAuthenticator` config. 3.  Disable password authentication for SSH. 4.  Configure PAM to use `GoogleAuthenticator` for SSH logins. 5.  Set `ChallengeResponseAuthentication` to `Yes`. 6.  Set Authentication Methods for *bender*, *vagrant*, and *ubuntu*. 7.  Insert an additional line here that reads: Restart SSH Server.    We’ll look at each of these tasks in the following sections.    ### Installing Google Authenticator    `Google Authenticator` is a PAM module that allows you to enforce 2FA over SSH. This module is located in the Ubuntu software repository under the name `libpam-google-authenticator`. The package contains all the necessary files to enable `Google Authenticator`. With the *two_factor.yml* file still open, find the first task at the top. It should look like this:    ``` - name: Install the libpam-google-authenticator package   apt:     name: \"libpam-google-authenticator\"     update_cache: yes     state: present ```    The `name` on the first line identifies the task’s intent (installing a package). You’ll use Ansible’s `apt` module to install the OS package. The `apt` module also requires the following `name` parameter to be set, and in this example, it is set to the package name `libpam-google-authenticator`.    Finally, as before, set the `state` to `present` since you want to install the package and not remove it. Most Ansible modules have the `state` set to `present` as a default, but you are most likely not the only person using these tasks. Letting the other engineers know your intent leaves little room for doubt or error, so even though you could omit this step, it’s always better to be explicit.    ### Configuring Google Authenticator    To configure `Google Authenticator` for a user, you typically would run the `google-authenticator` command that was installed from the `libpam-google-authenticator` package. This application creates a configuration file named *.google_authenticator* in the user’s *home/* directory by default. The configuration file consists of a Base32 key (secret); configuration options, such as token reuse and time to live; and 10 emergency recovery tokens. To keep the focus on provisioning, I’ve created the *google_authenticator* configuration file for you in the *chapter3/* directory.    Since the goal is to automate, you’ll use an Ansible task to copy this configuration file over to the VM. If you’re tempted to think, “It would be easier just to run the command by hand,” remember that in most cases you’ll be managing many hosts. Doing that by hand would be tedious and make you error prone.    With the *two_factor.yml* file still open, locate the task on line 7 of the file that looks like this:    ``` - name: Copy over preconfigured GoogleAuthenticator config   copy:     src: ../ansible/chapter3/google_authenticator     dest: /home/bender/.google_authenticator     owner: bender     group: bender     mode: 0600 ```    As always, the `name` of the task describes its intent (copy a file). The Ansible `copy` module copies the configuration file from your local host to the VM. Use the `copy` module when you need to copy a file from a source to a destination. (The source can be either local or remote.) The `copy` module requires you to set the `src` and `dest` parameters. In this case, the `src` field is set to the local *google_authenticator* file in the cloned repository ([https://github.com/bradleyd/devops_for_the_desperate/](https://github.com/bradleyd/devops_for_the_desperate/)). Notice the two dots (`..`) in the beginning of the source (*src*) file. These dots indicate that the file is located one directory up from the current *vagrant/* directory, where the `ansible` command is run. Without these dots, the `ansible-playbook` command would not be able to find the *ansible/* directory where the file is located. The `dest` parameter is set to the file named */home/bender/.google_authenticator* on the VM. The file permission, or `mode`, is set to read and write (`0600`), so only the owner of the file, *bender*, can read and write to it.    To learn more about `Google Authenticator`, visit [https://github.com/google/google-authenticator/wiki/](https://github.com/google/google-authenticator/wiki/)*.*    ### Configuring PAM for Google Authenticator    As mentioned in Chapter 2, PAM controls a lot of authorization and authentication methods in Linux. To be able to use `Google Authenticator` over SSH, you need to modify the SSH PAM configuration file, which is very similar to what you did in Chapter 2. To add `Google Authenticator` to PAM, you’ll need to make changes to the module file located at */etc/pam.d/sshd*. This file controls how PAM interacts with the SSH server (more on that later).    You’ll use two provided Ansible tasks that disable password prompts over SSH and tell PAM where it can find the `Google Authenticator` file (*pam_google_authenticator.so*). Remember, you want to force users to use public key authentication in lieu of passwords. This change will also make it harder for attackers to brute-force SSH with a password since you will not allow it.    With the *two_factor.yml* file still open, locate the first of the two tasks that configure PAM (on line 15). It should look like this:    ``` - name: Disable password authentication for SSH   lineinfile:     dest: \"/etc/pam.d/sshd\"     regex: \"@include common-auth\"     line: \"#@include common-auth\" ```    This task disables `password` prompts for SSH via the PAM module. To edit the PAM *sshd* file, this task uses the familiar Ansible `lineinfile` module, which locates the `common-auth` line with a regular expression (`regex`) and comments it out with a *#* sign. In this case, the regular expression searches for the full `common-auth` line. By commenting out that line, SSH `password` prompts for users are disabled when logging in over SSH.    The second task that will configure PAM, located on line 21, should look like this:    ``` - name: Configure PAM to use GoogleAuthenticator for SSH logins   lineinfile:     dest: \"/etc/pam.d/sshd\"     line: \"auth required pam_google_authenticator.so nullok\" ```    This task tells PAM about the `Google Authenticator` module. It uses the Ansible `lineinfile` module again to edit the PAM *sshd* file. This time, you just want to add the `auth` line to the bottom of the PAM file, which lets PAM know it should use `Google Authenticator` as an authentication mechanism. The `nullok` option at the end of the line tells PAM that this authentication method is optional, which allows you to avoid locking out users until they have successfully configured 2FA. In a production environment, you should remove the `nullok` option once all users have enabled 2FA.    ### Configuring the SSH Server    The SSH server manages all the SSH connections from the clients and enforces specific rules governing those connections. The SSH server will require some changes to expect a 2FA response, since that’s not a default configuration.    First, you’ll want to use Ansible to enable a keyboard response prompt when authenticating over SSH. The option to set is called `ChallengeResponseAuthentication`, and it’s needed so users can enter the two-factor verification code when logging in.    The second change Ansible will make is to set the SSH users’ `AuthenticationMethods`, which enable the SSH server to enforce specific ways for users to authenticate themselves. For this example, you’ll set the `AuthenticationMethods` for *bender* to be `publickey` and `keyboard-interactive`. This will force *bender* to need a public key and a TOTP token to log in. You’ll also set the *vagrant* and *ubuntu* users’ `AuthenticationMethods` only to `publickey` to log in, so you’ll still have users that can access the VM if anything goes wrong with 2FA.    With the *two_factor.yml* file still open, let’s review the two tasks that modify the VM’s SSH server. The first of these tasks, on line 26, should look like this:    ``` - name: Set ChallengeResponseAuthentication to Yes   lineinfile:     dest: \"/etc/ssh/sshd_config\"     regexp: \"^ChallengeResponseAuthentication (yes|no)\"     line: \"ChallengeResponseAuthentication yes\"     state: present ```    The task sets the `ChallengeResponseAuthentication` to `yes`. It uses the `lineinfile` module again to change a line in the VM’s SSH server config file. It locates the line using a regular expression that searches for the `ChallengeResponseAuthentication` option at the beginning of a line that is set to `yes` or `no`. Once it finds the line, it sets the line to `ChallengeResponseAuthentication` `yes` to enable keyboard interactivity for 2FA.    The last task in the file that configures the SSH server should look like this:    ``` - name: Set Authentication Methods for bender, vagrant, and ubuntu   blockinfile:     path: \"/etc/ssh/sshd_config\"     block: |       Match User \"ubuntu,vagrant\"           AuthenticationMethods publickey       Match User \"bender,!vagrant,!ubuntu\"           AuthenticationMethods publickey,keyboard-interactive     state: present   notify: \"Restart SSH Server\" ```    This task sets the authentication methods for users using the `blockinfile` module. Similar to `lineinfile`, `blockinfile` can manipulate a block of text. This is useful when you need to change multiple lines at once and preserve indentation inside a file. The `blockinfile` module requires that the `path` parameter be set. In this case, the `path` of the file to edit is */etc/ssh/sshd_config*. The pipe character (`|`) is YAML notation for introducing a multiline string: the block of text, where the task uses an SSH server configuration option called `Match` that allows you to apply certain criteria to specific users. In this example, you want to allow the *ubuntu* and *vagrant* users to use `publickey` authentication only when logging in over SSH. Then you want to set the authentication methods for *bender* to be `publickey` and `keyboard-interactive`, to enforce 2FA. Finally, this example sets a `notify` action to `\"Restart SSH Server\"` on this task. (I’ll discuss the `notify` option next.)    ### Restarting the SSH Server with a Handler    Editing the configuration file is not enough; the SSH server requires a restart for all the changes to take effect. To make that happen, you’ll use the `notify` Ansible option that triggers a `handler` to perform a single task. A `handler` is just like any other task, but it’s executed only once and has a globally unique name across the whole playbook.    The last Ansible task in *two_factor.yml* activates a `handler` that restarts the SSH server for you. Open the *handlers/restart_ssh.yml* file found in the *ansible/* directory. It should look like this:    ``` - name: Restart SSH Server   service:     name: sshd     state: restarted ```    This `handler`’s `name` is set to `Restart SSH Server`. This `name` matches the `notify` value from the previous task (`Set Authentication Methods for bender`, `vagrant, and ubuntu`). This is not an accident. The values must match exactly to be triggered. The `service` module restarts the SSH server. This module requires the `name` parameter, which is `sshd` in this case, to be set. Finally, this task sets the `state` to `restarted`. If, for some reason, the SSH server does not restart, the task will fail.    You’re now finished with the Ansible tasks, so it’s safe to close all the open files.    ## Provisioning the VM    To provision the VM with all the tasks described thus far, you’ll need to uncomment them in the playbook. You’ll follow essentially the same process that you followed in Chapter 2, but this time around, you’ll need to uncomment two tasks and a `handler`. Open the *site.yml* file in your editor and locate the task for authorized keys, which should look like this:    ``` **#-** **import_tasks****: chapter3/****authorized_keys.yml** ```    Remove the `#` symbol to uncomment it.    Next, find the task for 2FA:    ``` **#-** **import_tasks****: chapter3/****two_factor.yml** ```    Remove the `#` symbol to uncomment that line as well.    Next, find the `handler` section that’s located below all the tasks. The `handler` to restart the SSH server should look like this:    ``` **#-** **import_tasks****: handlers/****restart_ssh.yml** ```    Remove the `#` symbol at the beginning of the line to uncomment it.    The playbook should now look like this:    ``` - name: Provision VM   hosts: all   become: yes   become_method: sudo   remote_user: ubuntu   tasks:     - import_tasks: chapter2/pam_pwquality.yml  - import_tasks: chapter2/user_and_group.yml     **- import_tasks: chapter3/authorized_keys.yml**  **- import_tasks: chapter3/two_factor.yml**   `--snip--`   handlers:  **- import_tasks: handlers/restart_ssh.yml** ```    Here, the changes to the playbook for Chapter 3 are added on to the changes from Chapter 2. As mentioned previously, the playbook is a collection of tasks that will perform specific actions on a host or group of hosts to enforce a specified state.    Now, you’ll automate the configuration of the VM using Vagrant. Navigate to the *vagrant/* directory, and once there, enter the following command:    ``` $ **vagrant** **provision** `--snip--` PLAY RECAP ********************************************************************* default    : ok=16   changed=9   unreachable=0   failed=0   skipped=0   rescued=0   ignored=0 ```    Notice that the total task count has increased to `16` since the last provision. You have also changed a total of `9` things on the VM. Here’s a summary of the things that changed:    *   Seven new tasks from Chapter 3 *   One task that updates the empty file from the previous chapter *   One `handler`    Once again, make sure no actions failed before you continue. The values from the provision output will vary, depending on how many times you run the `provision` command in this chapter. This is because Ansible is working hard to make sure your environment is consistent, and it doesn’t do extra work that is not needed. As mentioned earlier, Ansible is idempotent, meaning it can be executed several times and each execution completes with the same end state you would expect from the initial execution.    ## Testing SSH Access    With the VM successfully provisioned, you should test *bender*’s access over SSH. To test public key and 2FA over SSH, you’ll need the private key you created earlier and one of the emergency tokens from the *google_authenticator* file in the repository. The private key should be located in your local SSH directory. On my Mac, it’s in */Users/bradleyd/.ssh/dftd*. The emergency tokens are the 10 eight-digit numbers located at the bottom of the *ansible/chapter3/google_authenticator*file. Choose the first one.    To `ssh` in to the VM as *bender*, open a terminal on your local host and enter the following command:    ``` $ **ssh** 1**-i ~/.ssh/dftd** **-p 2222** 2**bender@localhost** Enter passphrase for key /Users/bradleyd/.ssh/dftd: `<passphrase>` Verification code: `<76338876>` `--snip--` bender@dftd:~$ ```    In the `ssh` command, you set the identity file to your private key 1 for authentication and set the remote SSH port to `2222`. The default SSH port is 22, but Vagrant listens on a different SSH port to avoid conflicts on your local host. You also set the login user to *bender* and the SSH host to `localhost` 2.    The output indicates you should have been prompted twice during this login session: once to enter the passphrase to unlock your private key, and a second time to enter a 2FA verification code. After satisfying both prompts, you should be successfully logged in to the VM as *bender*.    If, for some reason, you weren’t prompted for a TOTP token or for the private key passphrase, stop and check for errors. You can log in to the VM as the *vagrant* user and inspect the logs. A good place to start looking for errors is in either */var/log/auth.log* or */var/log/syslog*on the VM. Common errors include the SSH server not restarting cleanly and one of the configuration files having a syntax issue.    Each of the 10 tokens provided is for one-time use. Every time you successfully use one, it’s removed from the */home/bender/.google_authenticator* file. If, for some reason, you burn through all the tokens, run the `vagrant provision` command again to replace the file and replenish the tokens. Another option is to use a TOTP application like `oathtool` and generate a time-based one-time token by using the Base32 secret at the top of the */home/bender/.google_authenticator* file. You can install `oathtool` with Ubuntu’s package manager by using the `apt install oathtool` command. Every time you need a token, you can use the following command:    ``` $ **oathtool --totp --base32 \"QLIUWM4UVD7E5SI6PPVZ2EGRFU\"** 097903 ```    Here, you pass `oathtool` your Base32 secret in the double quotes and set the flags `--totp` and `--base32` to generate the token. In this result, the token `097903` is generated and can be used when prompted for a verification code. Feel free to use this method or the provided tokens when logging in.    ## Summary    In this chapter, you secured the VM by disabling password logins, requiring public key authentication, and enforcing 2FA for *bender*. Automating these simple steps improves your host’s security, whether it’s local or on someone else’s computer in the cloud. As with the previous chapters, these automation tasks are a part of a foundational base that you can employ with all your hosts. In the next chapter, you’ll use more Ansible tasks to control user access by enabling security policies.````"]