- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: CONFIGURING YOUR PROJECT WITH AUTOCONF
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AUTOCONF 配置你的项目
- en: '*Come my friends, ’Tis not too late to seek a newer world.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*来吧，我的朋友们，‘寻找一个新的世界’还不算太晚。  '
- en: —Alfred, Lord Tennyson, “Ulysses”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ——阿尔弗雷德·丁尼生，《尤利西斯》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The Autoconf project has had a long history, starting in 1992 when David McKenzie,
    while volunteering for the Free Software Foundation, was looking for a way to
    simplify the process of creating the complex configuration scripts necessary to
    support the target platforms that were being added daily at that time to the GNU
    project. At the same time, he was working on his bachelor’s degree in computer
    science at the University of Maryland, College Park.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 项目有着悠久的历史，始于1992年，当时 David McKenzie 在自愿为自由软件基金会工作时，正在寻找一种简化创建复杂配置脚本的方式，以支持当时每天添加到
    GNU 项目的目标平台。与此同时，他还在马里兰大学帕克分校攻读计算机科学学士学位。
- en: After McKenzie’s initial work on Autoconf, he continued to be a strong contributor
    to the project through 1996, at which point Ben Elliston took over project maintenance.
    Since then, maintainers and primary contributors have included Akim Demaille,
    Jim Meyering, Alexandre Oliva, Tom Tromey, Lars J. Aas (inventor of the name *autom4te*,
    among others), Mo DeJong, Steven G. Johnson, Matthew D. Langston, Paval Roskin,
    and Paul Eggert (the list of contributors is much longer—see the Autoconf *AUTHORS*
    file for more history).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 McKenzie 最初的 Autoconf 工作之后，他一直是该项目的重要贡献者，直到1996年，Ben Elliston 接手了项目的维护。从那时起，维护者和主要贡献者包括
    Akim Demaille、Jim Meyering、Alexandre Oliva、Tom Tromey、Lars J. Aas（*autom4te* 这个名字的发明者之一）等人，Mo
    DeJong、Steven G. Johnson、Matthew D. Langston、Paval Roskin 和 Paul Eggert（贡献者名单更长，详情见
    Autoconf 的 *AUTHORS* 文件）。
- en: Today’s maintainer, Eric Blake, began making strong contributions to Autoconf
    in 2012\. He’s been maintainer of the project ever since while working for Red
    Hat. Because Automake and Libtool are essentially add-on components to the original
    Autoconf framework, it’s useful to spend some time focusing on using Autoconf
    without Automake and Libtool. This will provide a fair amount of insight into
    how Autoconf operates by exposing aspects of the tool that are often hidden by
    Automake.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的维护者，Eric Blake，自2012年起开始为 Autoconf 做出重要贡献。从那时起，他一直担任该项目的维护者，并为 Red Hat 工作。由于
    Automake 和 Libtool 本质上是 Autoconf 框架的附加组件，因此花一些时间专注于在没有 Automake 和 Libtool 的情况下使用
    Autoconf 是有益的。这将提供一些洞察，帮助理解 Autoconf 的操作方式，因为许多由 Automake 隐藏的工具细节将得以显现。
- en: Before Automake came along, Autoconf was used alone. In fact, many legacy open
    source projects never made the transition from Autoconf to the full GNU Autotools
    suite. As a result, it’s not unusual to find a file called *configure.in* (the
    original Autoconf naming convention), as well as handwritten *Makefile.in* templates,
    in older open source projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Automake 出现之前，Autoconf 是单独使用的。事实上，许多遗留的开源项目从未从 Autoconf 过渡到完整的 GNU Autotools
    套件。因此，在较旧的开源项目中，找到一个名为 *configure.in* 的文件（这是原始的 Autoconf 命名约定），以及手写的 *Makefile.in*
    模板，并不罕见。
- en: In this chapter, I’ll show you how to add an Autoconf build system to an existing
    project. I’ll spend most of this chapter talking about the more basic features
    of Autoconf, and in [Chapter 5](ch05.xhtml) I’ll go into much more detail about
    how some of the more complex Autoconf macros work and how to properly use them.
    Throughout this process, we’ll continue using the Jupiter project as our example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你展示如何为现有项目添加 Autoconf 构建系统。我将在本章的大部分时间里讲解 Autoconf 的基础功能，在 [第5章](ch05.xhtml)中，我将详细介绍一些更复杂的
    Autoconf 宏是如何工作的以及如何正确使用它们。在整个过程中，我们将继续使用 Jupiter 项目作为示例。
- en: Autoconf Configuration Scripts
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autoconf 配置脚本
- en: The input to the `autoconf` program is Bourne shell script sprinkled with macro
    calls. The input data stream must also include the definitions of all referenced
    macros—both those that Autoconf provides and those that you write yourself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoconf` 程序的输入是带有宏调用的 Bourne shell 脚本。输入数据流还必须包括所有引用宏的定义——包括 Autoconf 提供的宏和你自己编写的宏。'
- en: The macro language used in Autoconf is called *M4*. (The name means *M, plus
    4 more letters*, or the word *Macro*.^([1](footnote.xhtml#ch04fn1))) The `m4`
    utility is a general-purpose macro language processor originally written by Brian
    Kernighan and Dennis Ritchie in 1977.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Autoconf 中使用的宏语言叫做 *M4*。（这个名字的含义是 *M，外加4个字母*，或者是 *宏* 这个词。^([1](footnote.xhtml#ch04fn1)))
    `m4` 工具是一个通用的宏语言处理器，最初由 Brian Kernighan 和 Dennis Ritchie 于1977年编写。
- en: While you may not be familiar with it, you can find some form of M4 on every
    Unix and Linux variant (as well as other systems) in use today. The ubiquitous
    nature of this tool is the main reason it’s used by Autoconf, as the original
    design goals of Autoconf stated that it should be able to run on all systems without
    the addition of complex tool chains and utility sets.^([2](footnote.xhtml#ch04fn2))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不熟悉它，但你可以在今天使用的每个Unix和Linux变体（以及其他系统）中找到某种形式的M4。这个工具的普及性是Autoconf使用它的主要原因，因为Autoconf的原始设计目标就是能够在所有系统上运行，而不需要添加复杂的工具链和实用程序集。^([2](footnote.xhtml#ch04fn2))
- en: 'Autoconf depends on the existence of relatively few tools: a Bourne shell,
    M4, and a Perl interpreter. The configuration scripts and makefiles it generates
    rely on the existence of a different set of tools, including a Bourne shell, `grep`,
    `ls`, and `sed` or `awk`.^([3](footnote.xhtml#ch04fn3))'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf依赖于相对较少的工具：Bourne shell、M4和Perl解释器。它生成的配置脚本和Makefile依赖于一组不同的工具，包括Bourne
    shell、`grep`、`ls`以及`sed`或`awk`。^([3](footnote.xhtml#ch04fn3))
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not confuse the requirements of the Autotools with the requirements of
    the scripts and makefiles they generate. The Autotools are maintainer tools, whereas
    the resulting scripts and makefiles are end user tools. We can reasonably expect
    a higher level of installed functionality on development systems than we can on
    end user systems.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将Autotools的要求与它们生成的脚本和Makefile的要求混淆。Autotools是维护工具，而生成的脚本和Makefile是最终用户工具。我们可以合理地预期开发系统中安装的功能比最终用户系统中更多。*'
- en: The configuration script ensures that the end user’s build environment is configured
    to properly build your project. This script checks for installed tools, utilities,
    libraries, and header files, as well as for specific functionality within these
    resources. What distinguishes Autoconf from other project configuration frameworks
    is that Autoconf tests also ensure that these resources can be properly consumed
    by your project. You see, it’s important not only that your users have *libxyz.so*
    and its public header files properly installed on their systems but also that
    they have compatible versions of these files. Autoconf is pathological about such
    tests. It ensures that the end user’s environment is in compliance with the project
    requirements by compiling and linking a small test program for each feature—a
    quintessential example, if you will, that does what your project source code does
    on a larger scale.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 配置脚本确保最终用户的构建环境已正确配置，以构建你的项目。该脚本检查已安装的工具、实用程序、库和头文件，以及这些资源中的特定功能。Autoconf与其他项目配置框架的不同之处在于，Autoconf的测试还确保这些资源能够被你的项目正确使用。你看，不仅仅是你的用户在他们的系统上正确安装了*libxyz.so*及其公共头文件，更重要的是，他们的文件版本是否兼容。Autoconf在这类测试上非常严格。它通过为每个功能编译和链接一个小的测试程序，确保最终用户的环境符合项目要求——如果你愿意，它就像是一个示范例子，做的事情与项目源代码在更大范围内所做的相同。
- en: '*Can’t I just ensure that* libxyz.2.1.0.so *is installed by searching library
    paths for the filename?* The answer to this question is debatable. There are legitimate
    situations where libraries and tools get updated quietly. Sometimes, the specific
    functionality upon which your project relies is added in the form of a security
    bug fix or enhancement to a library, in which case vendors aren’t even required
    to bump up the version number. But it’s often difficult to tell whether you’ve
    got version 2.1.0.r1 or version 2.1.0.r2 unless you look at the file size or call
    a library function to make sure it works as expected.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*难道我不能仅仅通过在库路径中搜索文件名来确保* libxyz.2.1.0.so *已安装吗？* 这个问题的答案是有争议的。在一些合法的情况下，库和工具会悄无声息地更新。有时，项目所依赖的特定功能是以安全错误修复或库功能增强的形式添加的，在这种情况下，供应商甚至不需要更新版本号。但通常很难判断你拥有的是版本2.1.0.r1还是版本2.1.0.r2，除非你查看文件大小或调用库函数来确保它按预期工作。'
- en: Additionally, vendors often backport bug fixes and features from newer products
    onto older platforms without bumping the version number. Hence, you can’t tell
    even by looking at the version number whether the library supports a feature that
    was added *after* that version of the library was published.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，供应商经常会将新产品中的错误修复和功能回移到旧平台，而不更新版本号。因此，仅通过查看版本号，你无法判断库是否支持在该版本库发布后*新增*的功能。
- en: However, the most significant reason for not relying on library version numbers
    is that they do not represent specific marketing releases of a library. As we
    will discuss in [Chapter 8](ch08.xhtml), library version numbers indicate binary
    interface characteristics on a particular platform. This means that library version
    numbers for the same feature set can be different from platform to platform. As
    a result, you may not be able to tell—short of compiling and linking against the
    library—whether or not a particular library has the functionality your project
    needs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不依赖库版本号的最重要原因是，它们并不代表库的特定营销版本。如我们在[第8章](ch08.xhtml)中将讨论的，库版本号表示的是特定平台上的二进制接口特性。这意味着，同一功能集的库版本号可能在不同平台之间有所不同。因此，除非进行编译和链接到该库，否则你可能无法判断某个库是否具备你的项目所需的功能。
- en: Finally, there are several important cases where the same functionality is provided
    by entirely different libraries on different systems. For example, you may find
    cursor manipulation functionality in *libtermcap* on one system, *libncurses*
    on another, and *libcurses* on yet another system. But it’s not critical that
    you know about all of these side cases, because your users will tell you when
    your project won’t build on their system because of such a discrepancy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有几个重要情况是，在不同的系统上，完全不同的库提供相同的功能。例如，你可能在一个系统中找到 *libtermcap* 提供光标操作功能，在另一个系统中找到
    *libncurses*，而在另一个系统中找到 *libcurses*。但你不需要知道所有这些边缘情况，因为当你的项目在用户的系统上由于这些差异而无法构建时，用户会告诉你。
- en: What can you do when such a bug is reported? You can use the Autoconf `AC_SEARCH_LIBS`
    macro to test multiple libraries for the same functionality. Simply add a library
    to the search list, and you’re done. Since this fix is so easy, it’s likely the
    user who noticed the problem will simply send a patch to your *configure.ac* file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当报告此类 bug 时，你该怎么办？你可以使用 Autoconf 的 `AC_SEARCH_LIBS` 宏来测试多个库是否具备相同的功能。只需将一个库添加到搜索列表中，完成即可。由于这个修复非常简单，发现问题的用户很可能会直接发送一个补丁到你的
    *configure.ac* 文件。
- en: Because Autoconf tests are written in shell script, you have a lot of flexibility
    as to how the tests operate. You can write a test that merely checks for the existence
    of a library or utility in the usual locations on your user’s system, but this
    bypasses some of the most significant features of Autoconf. Fortunately, Autoconf
    provides dozens of macros that conform to Autoconf’s feature-testing philosophy.
    You should carefully study and use the list of available macros, rather than write
    your own, because they’re specifically designed to ensure that the desired functionality
    is available on the widest variety of systems and platforms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Autoconf 测试是用 shell 脚本编写的，你在测试操作的方式上有很大的灵活性。你可以编写一个仅检查用户系统中常见位置是否存在某个库或工具的测试，但这绕过了
    Autoconf 的一些重要特性。幸运的是，Autoconf 提供了数十个符合其特性测试哲学的宏。你应当仔细研究并使用可用宏的列表，而不是编写自己的宏，因为它们专门设计来确保所需功能在尽可能多的系统和平台上可用。
- en: The Shortest configure.ac File
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最简洁的 `configure.ac` 文件
- en: The input file for `autoconf` is called *configure.ac*. The simplest possible
    *configure.ac* file has just two lines, as shown in [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoconf` 的输入文件叫做 *configure.ac*。最简单的 *configure.ac* 文件只有两行，如[清单 4-1](ch04.xhtml#ch04ex01)所示。'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: The simplest configure.ac file*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：最简单的 configure.ac 文件*'
- en: To those new to Autoconf, these two lines appear to be a couple of function
    calls, perhaps in the syntax of some obscure programming language. Don’t let their
    appearance throw you—these are M4 macro invocations. The macros are defined in
    files distributed with the autoconf package. You can find the definition of `AC_INIT`,
    for example, in *general.m4* in Autoconf’s installation directory (usually */usr/(local/)share/autoconf/autoconf*).
    `AC_OUTPUT` is defined in *status.m4* in the same directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新接触 Autoconf 的人来说，这两行看起来像是几个函数调用，可能是某种晦涩的编程语言的语法。不要让它们的外观把你吓到——这些是 M4 宏调用。这些宏定义在与
    autoconf 软件包一起分发的文件中。例如，你可以在 Autoconf 的安装目录中的 *general.m4* 文件中找到 `AC_INIT` 的定义（通常是
    */usr/(local/)share/autoconf/autoconf*）。`AC_OUTPUT` 的定义在同一目录下的 *status.m4* 中。
- en: Comparing M4 to the C Preprocessor
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 M4 与 C 预处理器进行比较
- en: 'M4 macros are similar in many ways to the C-preprocessor (CPP) macros defined
    in C-language source files. The C preprocessor is also a text replacement tool,
    which isn’t surprising: both M4 and the C preprocessor were designed and written
    by Kernighan and Ritchie around the same time.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: M4宏在许多方面类似于在C语言源文件中定义的C预处理器（CPP）宏。C预处理器也是一种文本替换工具，这并不奇怪：M4和C预处理器是由Kernighan和Ritchie在差不多同一时期设计和编写的。
- en: Autoconf uses square brackets around macro parameters as a quoting mechanism.
    Quotes are necessary only for cases in which the context of the macro call could
    cause an ambiguity that the macro processor may resolve incorrectly (usually without
    telling you). We’ll discuss M4 quoting in much more detail in [Chapter 16](ch16.xhtml).
    For now, just use square brackets around every argument to ensure that the expected
    macro expansions are generated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf使用方括号将宏参数括起来作为引用机制。引用仅在宏调用的上下文可能导致歧义，而宏处理器可能错误地解决这种歧义时才需要。我们将在[第16章](ch16.xhtml)中详细讨论M4的引用。现在，只需在每个参数周围使用方括号，以确保生成预期的宏展开。
- en: 'As with CPP macros, you can define M4 macros to accept a comma-delimited list
    of arguments enclosed in parentheses. With CPP, macros are defined using a *preprocessor
    directive*: `#define` *`name`*`(`*`args`*`)` *`expansion`*, while in M4, macros
    are defined with a built-in macro: `define(`*`name`*`,` *`expansion`*`)`. Another
    significant difference is that in CPP, the arguments specified in the macro definition
    are required,^([4](footnote.xhtml#ch04fn4)) while in M4, the arguments to parameterized
    macros are optional and the caller may simply omit them. If no arguments are passed,
    you can also omit the parentheses. Extra arguments passed to M4 macros are simply
    ignored. Finally, M4 does not allow intervening whitespace between a macro name
    and the opening parenthesis in a macro invocation.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与CPP宏一样，你可以定义M4宏来接受以逗号分隔并括在括号中的参数列表。与CPP中通过*预处理器指令*定义宏：`#define` *`name`*`(`*`args`*`)`
    *`expansion`*不同，在M4中，宏是通过内建宏定义的：`define(`*`name`*`,` *`expansion`*`)`。另一个显著的区别是，在CPP中，宏定义中指定的参数是必需的^([4](footnote.xhtml#ch04fn4))，而在M4中，参数化宏的参数是可选的，调用者可以简单地省略它们。如果没有传递参数，你也可以省略括号。传递给M4宏的额外参数会被忽略。最后，M4不允许宏调用中的宏名和开括号之间有空格。
- en: The Nature of M4 Macros
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: M4宏的性质
- en: If you’ve been programming in C for many years, you’ve no doubt run across a
    few C-preprocessor macros from the dark regions of the lower realm. I’m talking
    about those truly evil macros that expand into one or two pages of C code. They
    should have been written as C functions, but their authors were either overly
    worried about performance or just got carried away, and now it’s your turn to
    debug and maintain them. But, as any veteran C programmer will tell you, the slight
    performance gains you get by using a macro where you should have used a function
    do not justify the trouble you cause maintainers trying to debug your fancy macros.
    Debugging such macros can be a nightmare because the source code generated by
    macros is usually inaccessible from within a symbolic debugger.^([5](footnote.xhtml#ch04fn5))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在C语言中编程多年，你无疑遇到过一些来自低层次黑暗区域的C预处理器宏。我说的就是那些真正邪恶的宏，它们展开后会生成一到两页的C代码。它们本应被写成C函数，但它们的作者要么过于担心性能，要么只是过于兴奋，结果现在轮到你来调试和维护它们了。但是，正如任何资深C程序员会告诉你的，使用宏而不是函数所带来的轻微性能提升，并不足以弥补你给维护者带来的调试麻烦。调试这样的宏可能是一场噩梦，因为宏生成的源代码通常无法通过符号调试器访问^([5](footnote.xhtml#ch04fn5))。
- en: 'Writing such complex macros is viewed by M4 programmers as a sort of macro
    nirvana—the more complex and functional they are, the “cooler” they are. The two
    Autoconf macros in [Listing 4-1](ch04.xhtml#ch04ex01) expand into a file containing
    almost 2,400 lines of Bourne-shell script that total more than 70KB! But you wouldn’t
    guess this by looking at their definitions. They’re both fairly short—only a few
    dozen lines each. The reason for this apparent disparity is simple: they’re written
    in a modular fashion, with each macro expanding several others, which in turn
    expand several others, and so on.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这种复杂的宏被M4程序员视为一种宏的极乐世界——它们越复杂、越功能强大，就越“酷”。在[清单4-1](ch04.xhtml#ch04ex01)中的两个Autoconf宏展开后会生成一个包含近2400行Bourne-shell脚本的文件，总大小超过70KB！但你通过查看它们的定义是猜不到这一点的。它们都相当简短——每个只有几十行。这个明显差异的原因很简单：它们是以模块化的方式编写的，每个宏都扩展其他几个宏，后者又扩展其他几个宏，依此类推。
- en: For the same reasons that programmers are taught not to abuse the C preprocessor,
    the extensive use of M4 causes a fair amount of frustration for those trying to
    understand Autoconf. That’s not to say Autoconf shouldn’t use M4 this way; quite
    the contrary—this is the domain of M4\. But there is a school of thought that
    says M4 was a poor choice for Autoconf because of the problems with macros mentioned
    earlier. Fortunately, being able to use Autoconf effectively usually doesn’t require
    a deep understanding of the inner workings of the macros that ship with it.^([6](footnote.xhtml#ch04fn6))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与编程人员被教导不滥用C预处理器的原因相同，广泛使用M4会给那些试图理解Autoconf的人带来相当大的困惑。这并不是说Autoconf不应该这样使用M4；恰恰相反——这正是M4的领域。但也有一种观点认为，M4对于Autoconf来说是一个不太好的选择，因为前面提到的宏问题。幸运的是，通常有效地使用Autoconf并不需要深入理解它附带的宏的内部工作原理。^([6](footnote.xhtml#ch04fn6))
- en: Executing autoconf
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 autoconf
- en: 'Running Autoconf is simple: just execute `autoconf` in the same directory as
    your *configure.ac* file. While I could do this for each example in this chapter,
    I’m going to use the `autoreconf` program instead of the `autoconf` program, because
    running `autoreconf` has exactly the same effect as running `autoconf`, except
    that `autoreconf` will also do the right thing when you start adding Automake
    and Libtool functionality to your build system. That is, it will execute all of
    the Autotools in the right order based on the contents of your *configure.ac*
    file.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Autoconf非常简单：只需在与*configure.ac*文件相同的目录中执行`autoconf`。虽然我可以为本章中的每个示例都执行这个操作，但我将使用`autoreconf`程序，而不是`autoconf`程序，因为运行`autoreconf`的效果与运行`autoconf`完全相同，只不过`autoreconf`在你开始向构建系统中添加Automake和Libtool功能时，也会正确地执行所有Autotools。也就是说，它会根据*configure.ac*文件的内容按正确的顺序执行所有Autotools。
- en: The `autoreconf` program is smart enough to execute only the tools you need,
    in the order you need them, with the options you want (with one caveat that I’ll
    mention shortly). Therefore, running `autoreconf` is the recommended method for
    executing the Autotools tool chain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoreconf`程序足够智能，只会按正确的顺序执行你需要的工具，并使用你想要的选项（有一个小小的限制，我会在稍后提到）。因此，运行`autoreconf`是执行Autotools工具链的推荐方法。'
- en: 'Let’s start by adding the simple *configure.ac* file from [Listing 4-1](ch04.xhtml#ch04ex01)
    to our project directory. The top-level directory currently contains only a *Makefile*
    and a *src* directory that contains its own *Makefile* and a *main.c* file. Once
    you’ve added *configure.ac* to the top-level directory, run `autoreconf`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将来自[清单 4-1](ch04.xhtml#ch04ex01)的简单*configure.ac*文件添加到我们的项目目录中。当前的顶层目录仅包含一个*Makefile*和一个*src*目录，后者包含其自己的*Makefile*和一个*main.c*文件。一旦你将*configure.ac*添加到顶层目录中，运行`autoreconf`：
- en: Git tag 4.0
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 4.0
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, notice that `autoreconf` operates silently by default. If you want to
    see something happening, use the `-v` or `--verbose` option. If you want `autoreconf`
    to execute the Autotools in verbose mode as well, then add `-vv` to the command
    line.^([7](footnote.xhtml#ch04fn7))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到`autoreconf`默认是静默运行的。如果你想看到一些执行过程，可以使用`-v`或`--verbose`选项。如果你希望`autoreconf`以详细模式执行Autotools，也可以在命令行中添加`-vv`。^([7](footnote.xhtml#ch04fn7))
- en: Next, notice that `autoconf` creates a directory called *autom4te.cache*. This
    is the `autom4te` cache directory. This cache speeds up access to *configure.ac*
    during successive executions of utilities in the Autotools tool chain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意到`autoconf`会创建一个名为*autom4te.cache*的目录。这是`autom4te`缓存目录。该缓存加速了在连续执行Autotools工具链中的实用工具时对*configure.ac*的访问。
- en: The result of passing *configure.ac* through `autoconf` is essentially the same
    file (now called `configure`), but with all of the macros fully expanded. You’re
    welcome to take a look at `configure`, but don’t be too surprised if you don’t
    immediately understand what you see. The *configure.ac* file has been transformed,
    through M4 macro expansions, into a text file containing thousands of lines of
    complex Bourne shell script.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将*configure.ac*通过`autoconf`处理的结果基本上是相同的文件（现在叫做`configure`），但是所有的宏都已经完全展开。你可以查看`configure`文件，但如果你立即无法理解其中的内容，也不必太惊讶。*configure.ac*文件已经通过M4宏展开转换成一个包含数千行复杂Bourne
    shell脚本的文本文件。
- en: Executing configure
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 configure
- en: 'As discussed in “Configuring Your Package” on [page 77](ch03.xhtml#page_77),
    the *GNU Coding Standards* indicate that a handwritten `configure` script should
    generate another script called `config.status`, whose job it is to generate files
    from templates. Unsurprisingly, this is exactly the sort of functionality you’ll
    find in an Autoconf-generated configuration script. This script has two primary
    tasks:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在“配置你的软件包”一节中讨论的，在 [第77页](ch03.xhtml#page_77)，*GNU 编程标准* 指出手写的 `configure`
    脚本应该生成另一个名为 `config.status` 的脚本，它的任务是从模板生成文件。毫不意外，这正是你在 Autoconf 生成的配置脚本中会找到的功能。这个脚本有两个主要任务：
- en: Perform requested checks
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行请求的检查
- en: Generate and then call `config.status`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成并调用 `config.status`
- en: 'The results of the checks performed by `configure` are written into `config``.status`
    in a manner that allows them to be used as replacement text for Autoconf substitution
    variables in template files (*Makefile.in*, *config.h.in*, and so on). When you
    execute `./configure`, it tells you that it’s creating `config.status`. It also
    creates a log file called *config.log* that has several important attributes.
    Let’s run `./configure` and then see what’s new in our project directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 执行的检查结果会写入 `config.status`，以便作为 Autoconf 替换变量的替换文本，用于模板文件中（*Makefile.in*、*config.h.in*
    等）。当你执行 `./configure` 时，它会告诉你它正在创建 `config.status`。它还会创建一个名为 *config.log* 的日志文件，包含一些重要的属性。我们来运行
    `./configure`，然后看看我们的项目目录中新增加了什么：'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We see that `configure` has indeed generated both `config.status` and *config.log**.
    The *config.log* file contains the following information:*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`configure` 确实生成了 `config.status` 和 *config.log* 文件。*config.log* 文件包含以下信息：*
- en: '**   The command line that was used to invoke `configure` (very handy!)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '** 用来调用 `configure` 的命令行（非常有用！）'
- en: Information about the platform on which `configure` was executed
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 执行时的平台信息'
- en: Information about the core tests `configure` executed
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 执行的核心测试信息'
- en: The line number in `configure` at which `config.status` is generated and then
    called
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 中生成并调用 `config.status` 的行号'
- en: 'At this point in the log file, `config.status` takes over generating log information
    and adds the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志文件的这一部分，`config.status` 接管生成日志信息，并添加以下内容：
- en: The command line used to invoke `config.status`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于调用 `config.status` 的命令行
- en: 'After `config.status` generates all the files from their templates, it exits,
    returning control to `configure`, which then appends the following information
    to the log:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `config.status` 从模板中生成所有文件后，它退出并将控制权返回给 `configure`，然后 `configure` 将以下信息附加到日志中：
- en: The cache variables that `config.status` used to perform its tasks
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.status` 用来执行任务的缓存变量'
- en: The list of output variables that may be replaced in templates
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会在模板中替换的输出变量列表
- en: The exit code `configure` returned to the shell
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 返回给 shell 的退出代码'
- en: This information is invaluable when you’re debugging a `configure` script and
    its associated *configure.ac* file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调试 `configure` 脚本及其相关的 *configure.ac* 文件时，这些信息非常宝贵。
- en: Why doesn’t `configure` just execute the code it writes into `config.status`
    instead of going to all the trouble of generating a second script, only to immediately
    call it? There are a few good reasons. First, the operations of performing checks
    and generating files are conceptually different, and the `make` utility works
    best when conceptually different operations are associated with separate targets.
    A second reason is that you can execute `config.status` separately to regenerate
    output files from their corresponding template files, saving the time required
    to perform those lengthy checks. Finally, `config.status` is written to remember
    the parameters originally used on the `configure` command line. Thus, when `make`
    detects that it needs to update the build system, it can call `config.status`
    to re-execute `configure`, using the command line options that were originally
    specified.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `configure` 不直接执行它写入 `config.status` 中的代码，而要经历生成第二个脚本并立即调用它的麻烦呢？有几个很好的理由。首先，执行检查和生成文件是概念上不同的操作，`make`
    工具在将概念上不同的操作与独立的目标关联时效果最佳。第二个原因是，你可以单独执行 `config.status`，从而重新生成输出文件，而不需要再次执行那些繁琐的检查，这样可以节省时间。最后，`config.status`
    会记住最初在 `configure` 命令行上使用的参数。因此，当 `make` 检测到需要更新构建系统时，它可以调用 `config.status` 重新执行
    `configure`，使用最初指定的命令行选项。
- en: Executing config.status
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 config.status
- en: Now that you know how `configure` works, you might be tempted to execute `config.status`
    yourself. This was exactly the intent of the Autoconf designers and the authors
    of the *GCS*, who originally conceived these design goals. However, a more important
    reason for separating checks from template processing is that `make` rules can
    use `config.status` to regenerate makefiles from their templates when `make` determines
    that a template is newer than its corresponding makefile.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`configure`是如何工作的，你可能会想自己执行`config.status`。这正是Autoconf设计者和*GCS*的作者们的初衷，他们最初构思了这些设计目标。然而，将检查与模板处理分开更为重要的原因是，`make`规则可以使用`config.status`来重新生成makefile，当`make`判断模板比对应的makefile更新时。
- en: Rather than call `configure` to perform needless checks (your environment hasn’t
    changed—just your template files), makefile rules should be written to indicate
    that output files depend on their templates. The commands for these rules run
    `config.status`, passing the rule’s target as a parameter. If, for example, you
    modify one of your *Makefile.in* templates, `make` calls `config.status` to regenerate
    the corresponding *Makefile*, after which `make` re-executes its own original
    command line—basically restarting itself.^([8](footnote.xhtml#ch04fn8))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要调用`configure`进行不必要的检查（因为你的环境没有改变——只是模板文件改变了），应该编写makefile规则来指示输出文件依赖于其模板。这些规则的命令会运行`config.status`，并将规则的目标作为参数传递。例如，如果你修改了其中一个*Makefile.in*模板，`make`会调用`config.status`来重新生成相应的*Makefile*，然后`make`会重新执行它最初的命令行——基本上是重新启动自己。^([8](footnote.xhtml#ch04fn8))
- en: '[Listing 4-2](ch04.xhtml#ch04ex02) shows the relevant portion of such a *Makefile.in*
    template, containing the rules needed to regenerate the corresponding *Makefile*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-2](ch04.xhtml#ch04ex02)显示了该*Makefile.in*模板的相关部分，包含了重新生成相应*Makefile*所需的规则。'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-2: A rule that causes `make` to regenerate* Makefile *if its template
    has changed*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：一个规则，如果其模板发生变化，将导致`make`重新生成* Makefile*'
- en: A rule with a target named `Makefile` is the trigger here. This rule allows
    `make` to regenerate the source makefile from its template if the template changes.
    It does this *before* executing either the user’s specified targets or the default
    target, if no specific target was given. This functionality is built into `make`—if
    there’s a rule whose target is `Makefile`, `make` always evaluates that rule first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里触发规则的目标是`Makefile`。这个规则允许`make`在模板发生变化时从其模板重新生成源makefile。它会在执行用户指定的目标或默认目标之前执行，如果没有指定特定目标的话。这个功能是`make`内建的——如果有一个目标为`Makefile`的规则，`make`总是会首先评估这个规则。
- en: The rule in [Listing 4-2](ch04.xhtml#ch04ex02) indicates that *Makefile* is
    dependent on `config``.status` as well as *Makefile.in*, because if `configure`
    updates `config.status`, it may generate *Makefile* differently. Perhaps different
    command line options were provided so that `configure` can now find libraries
    and header files it couldn’t find previously. In this case, Autoconf substitution
    variables may have different values. Thus, *Makefile* should be regenerated if
    either *Makefile.in* or `config .status` is updated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-2](ch04.xhtml#ch04ex02)中的规则表明，*Makefile*依赖于`config.status`和*Makefile.in*，因为如果`configure`更新了`config.status`，它可能会不同地生成*Makefile*。也许提供了不同的命令行选项，以便`configure`现在能够找到之前找不到的库和头文件。在这种情况下，Autoconf替代变量可能会有不同的值。因此，如果*Makefile.in*或`config.status`中的任何一个被更新，*Makefile*应该重新生成。'
- en: Since `config.status` is itself a generated file, it stands to reason that you
    could write such a rule to regenerate this file when needed. Expanding on the
    previous example, [Listing 4-3](ch04.xhtml#ch04ex03) adds the required code to
    rebuild `config.status` if `configure` changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`config.status`本身是一个生成的文件，因此可以推理出，你可以编写这样的规则，在需要时重新生成这个文件。在前面的例子基础上，[列表 4-3](ch04.xhtml#ch04ex03)添加了所需的代码，以便在`configure`改变时重建`config.status`。
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-3: A rule to rebuild `config.status` when `configure` changes*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：当`configure`改变时，重建`config.status`的规则*'
- en: Since `config.status` is a dependency of the `Makefile` target, `make` will
    look for a rule whose target is `config.status` and run its commands if needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`config.status`是`Makefile`目标的依赖项，`make`会寻找一个目标为`config.status`的规则，并在需要时执行其命令。
- en: Adding Some Real Functionality
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一些实际功能
- en: I’ve suggested before that you should call `config.status` in your makefiles
    to generate those makefiles from templates. [Listing 4-4](ch04.xhtml#ch04ex04)
    shows the code in *configure.ac* that actually makes this happen. It’s just a
    single additional macro call between the two original lines of [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经建议过，您应该在 makefiles 中调用 `config.status` 来从模板生成这些 makefiles。[清单 4-4](ch04.xhtml#ch04ex04)
    显示了实际执行此操作的 *configure.ac* 中的代码。这只是 [清单 4-1](ch04.xhtml#ch04ex01) 中两个原始行之间的一个额外宏调用。
- en: Git tag 4.1
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.1
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 4-4:* configure.ac: *Using the `AC_CONFIG_FILES` macro*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4:* configure.ac: *使用 `AC_CONFIG_FILES` 宏*'
- en: 'This code assumes that templates exist for *Makefile* and *src/Makefile*, called
    *Makefile.in* and *src/Makefile.in*, respectively. These template files look exactly
    like their *Makefile* counterparts, with one exception: any text I want Autoconf
    to replace is marked as an Autoconf substitution variable, using the `@`*`VARIABLE`*`@`
    syntax.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码假设存在 *Makefile* 和 *src/Makefile* 的模板，分别称为 *Makefile.in* 和 *src/Makefile.in*。这些模板文件看起来与其
    *Makefile* 对应文件完全相同，唯一的例外是：任何我希望 Autoconf 替换的文本，都标记为 Autoconf 替代变量，使用 `@`*`VARIABLE`*`@`
    语法。
- en: 'To create these files, simply rename the existing *Makefile* files to *Makefile.in*
    in both the top-level and *src* directories. This is a common practice when *autoconfiscating*
    a project:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些文件，只需将现有的 *Makefile* 文件在顶层和 *src* 目录中重命名为 *Makefile.in*。这是将项目 *autoconfiscate*
    的常见做法：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these changes in place, we are now effectively using our new *configure.ac*
    file in Jupiter to generate makefiles. To make it useful, let’s add a few Autoconf
    substitution variables to replace the original default values. At the top of these
    files, I’ve also added the Autoconf substitution variable, `@configure_input@`,
    after a comment hash mark. [Listing 4-5](ch04.xhtml#ch04ex05) shows the comment
    text that is generated in *Makefile*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改后，我们现在已经有效地在 Jupiter 中使用新的 *configure.ac* 文件来生成 makefiles。为了让它更有用，我们可以添加一些
    Autoconf 替代变量来替换原始的默认值。在这些文件的顶部，我还添加了 Autoconf 替代变量 `@configure_input@`，并在注释符号后面添加。
    [清单 4-5](ch04.xhtml#ch04ex05) 显示了在 *Makefile* 中生成的注释文本。
- en: Git tag 4.2
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.2
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4-5:* Makefile: *The text generated from the Autoconf `@configure_input@`
    variable*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5:* Makefile: *从 Autoconf `@configure_input@` 变量生成的文本*'
- en: I’ve also added the makefile regeneration rules from the previous examples to
    each of these templates, with slight path differences in each file to account
    for their different positions relative to `config.status` and `configure` in the
    build directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将之前示例中的 makefile 重新生成规则添加到了每个模板中，每个文件中略有不同的路径差异，以考虑到它们相对于构建目录中的 `config.status`
    和 `configure` 的不同位置。
- en: '[Listings 4-6](ch04.xhtml#ch04ex06) and [4-7](ch04.xhtml#ch04ex07) highlight
    the required changes to the final recursive versions of *Makefile* and *src/Makefile*
    from near the end of [Chapter 3](ch03.xhtml). We’ll consider writing nonrecursive
    versions of these files later as we cover Automake—the process when using Autoconf
    with handwritten *Makefile.in* templates is nearly identical to what we did in
    [Chapter 3](ch03.xhtml) with makefiles.^([9](footnote.xhtml#ch04fn9))'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6](ch04.xhtml#ch04ex06) 和 [4-7](ch04.xhtml#ch04ex07) 突出了从 [第 3 章](ch03.xhtml)
    末尾部分到最终递归版本的 *Makefile* 和 *src/Makefile* 所需的更改。稍后我们将在讲解 Automake 时考虑编写这些文件的非递归版本——使用
    Autoconf 和手写的 *Makefile.in* 模板的过程几乎与我们在 [第 3 章](ch03.xhtml) 中使用 makefiles 所做的完全相同。^([9](footnote.xhtml#ch04fn9))'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-6:* Makefile.in: *Required modifications to Makefile from [Chapter
    3](ch03.xhtml)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6:* Makefile.in: *来自 [第 3 章](ch03.xhtml) 的 Makefile 所需修改*'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-7:* src/Makefile.in: *Required modifications to src/Makefile from
    [Chapter 3](ch03.xhtml)*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-7:* src/Makefile.in: *来自 [第 3 章](ch03.xhtml) 的 src/Makefile 所需修改*'
- en: I’ve removed the `export` statements from the top-level *Makefile.in* and added
    a copy of all the `make` variables (originally only in the top-level *Makefile*)
    into *src/Makefile.in*. Since `config.status` generates both of these files, I
    can reap excellent benefits by substituting values for these variables directly
    into both files. The primary advantage of doing this is that I can now run `make`
    in any subdirectory without worrying about uninitialized variables that would
    originally have been passed down by a higher-level makefile.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从顶层的 *Makefile.in* 中移除了 `export` 语句，并将所有的 `make` 变量（最初只在顶层 *Makefile* 中）复制到了
    *src/Makefile.in* 中。由于 `config.status` 会生成这两个文件，因此我可以通过直接将这些变量的值替换到这两个文件中，从中获得显著的好处。这样做的主要优势是，我现在可以在任何子目录中运行
    `make`，而无需担心那些原本由更高级别的 makefile 传递的未初始化变量。
- en: Since Autoconf generates entire values for these `make` variables, you may be
    tempted to clean things up a bit by removing the variables and just substituting
    `@prefix@` where we currently use `$(prefix)` throughout the files. There are
    a few good reasons for keeping the `make` variables. First and foremost, we’ll
    retain the original benefits of the `make` variables; our end users can continue
    to substitute their own values on the `make` command line. (Even though Autoconf
    places default values in these variables, users may wish to override them.) Second,
    for variables such as `$(distdir)`, whose values are composed of multiple variable
    references, it’s simply cleaner to build the name in one place and use it everywhere
    else through a single variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Autoconf为这些`make`变量生成完整的值，你可能会想通过删除这些变量，只在文件中使用`@prefix@`来替代当前使用的`$(prefix)`，从而简化内容。保留`make`变量是有几个充分理由的。首先，我们将保留`make`变量的原始优点；最终用户可以继续在`make`命令行中替换他们自己的值。（即使Autoconf为这些变量设置了默认值，用户可能希望覆盖它们。）其次，对于像`$(distdir)`这样的变量，其值由多个变量引用组成，在一个地方构建这个名称并通过单个变量在其他地方使用，这样会显得更简洁。
- en: I’ve also changed the commands in the distribution targets a bit. Rather than
    distribute the makefiles, I now need to distribute the *Makefile.in* templates,
    as well as the new `configure` script and the *configure.ac* file.^([10](footnote.xhtml#ch04fn10))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我还稍微改变了一些分发目标中的命令。我不再分发makefile，而是需要分发*Makefile.in*模板、新的`configure`脚本和*configure.ac*文件。^([10](footnote.xhtml#ch04fn10))
- en: Finally, I modified the `distcheck` target’s commands to run the `configure`
    script before running `make`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我修改了`distcheck`目标的命令，使其在运行`make`之前先运行`configure`脚本。
- en: Generating Files from Templates
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模板生成文件
- en: Note that you can use `AC_CONFIG_FILES` to generate *any* text file from a file
    of the same name with a *.in* extension, found in the same directory. The *.in*
    extension is the default template-naming pattern for `AC_CONFIG_FILES`, but you
    can override this default behavior. I’ll get into the details shortly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以使用`AC_CONFIG_FILES`从同一目录中找到具有*.in*扩展名的同名文件生成*任何*文本文件。*.in*扩展名是`AC_CONFIG_FILES`的默认模板命名模式，但你可以覆盖这个默认行为。我稍后会详细讲解。
- en: Autoconf generates `sed` or `awk` expressions into the resulting `configure`
    script, which then copies them into `config.status`. The `config.status` script
    uses these expressions to perform string replacement in the input template files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf将`sed`或`awk`表达式生成到结果`configure`脚本中，然后将它们复制到`config.status`中。`config.status`脚本使用这些表达式在输入模板文件中执行字符串替换。
- en: Both `sed` and `awk` are text-processing tools that operate on file streams.
    The advantage of a stream editor (the name *sed* is a contraction of the phrase
    *stream editor*) is that it replaces text patterns in a byte stream. Thus, both
    `sed` and `awk` can operate on huge files because they don’t need to load the
    entire input file into memory in order to process it. Autoconf builds the expression
    list that `config.status` passes to `sed` or `awk` from a list of variables defined
    by various macros, many of which I’ll cover in greater detail later in this chapter.
    It’s important to understand that Autoconf substitution variables are the *only*
    items replaced in a template file while generating output files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`和`awk`都是处理文件流的文本处理工具。流编辑器的优点（*sed*这个名字是*stream editor*的缩写）是它能在字节流中替换文本模式。因此，`sed`和`awk`可以处理非常大的文件，因为它们不需要将整个输入文件加载到内存中进行处理。Autoconf根据各种宏定义的变量列表构建`config.status`传递给`sed`或`awk`的表达式列表，其中许多宏我将在本章稍后更详细地讲解。重要的是要理解，Autoconf替换变量是模板文件中生成输出文件时唯一会被替换的内容。'
- en: At this point, with very little effort, I’ve created a basic *configure.ac*
    file. I can now execute `autoreconf`, followed by `./configure` and then `make`,
    in order to build the Jupiter project. This simple, three-line *configure.ac*
    file generates a `configure` script that is fully functional, according to the
    definition of a proper configuration script as specified by the *GCS*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我几乎没有花费多少精力，就创建了一个基本的*configure.ac*文件。我现在可以执行`autoreconf`，然后执行`./configure`，接着是`make`，以便构建Jupiter项目。这个简单的三行*configure.ac*文件生成了一个完全可用的`configure`脚本，符合*GCS*所规定的正确配置脚本定义。
- en: The resulting configuration script runs various system checks and generates
    a `config.status` script that can replace a fair number of substitution variables
    in a set of specified template files in this build system. That’s a lot of functionality
    in just three lines of code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的配置脚本会运行各种系统检查，并生成一个 `config.status` 脚本，该脚本可以替换在此构建系统中指定的模板文件集中的许多替换变量。这仅仅是三行代码就实现了这么多功能。
- en: Adding VPATH Build Functionality
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 VPATH 构建功能
- en: 'At the end of [Chapter 3](ch03.xhtml), I mentioned that I hadn’t yet covered
    an important concept—that of vpath builds. A *vpath build* is a way of using a
    `make` construct (`VPATH`) to `configure` and build a project in a directory other
    than the source directory. This is important if you need to perform any of the
    following tasks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.xhtml) 结束时，我提到过，我还没有讲解一个重要的概念——即 vpath 构建。*vpath 构建* 是一种使用 `make`
    构造（`VPATH`）来在不同于源目录的目录中 `configure` 和构建项目的方法。如果你需要执行以下任何任务，这个概念很重要：
- en: Maintain a separate debug configuration
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一个单独的调试配置
- en: Test different configurations side by side
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 侧边比较不同的配置
- en: Keep a clean source directory for patch diffs after local modifications
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地修改后，为补丁差异保留一个干净的源目录
- en: Build from a read-only source directory
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从只读源目录进行构建
- en: The `VPATH` keyword is short for *virtual search path*. A `VPATH` statement
    contains a colon-separated list of places to look for relative-path dependencies
    when they can’t be found relative to the current directory. In other words, when
    `make` can’t find a prerequisite file relative to the current directory, it searches
    for that file successively in each of the paths in the `VPATH` statement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`VPATH` 关键字是 *虚拟搜索路径* 的缩写。一个 `VPATH` 语句包含一个由冒号分隔的路径列表，用于查找相对路径的依赖项，当它们在当前目录中无法找到时。换句话说，当
    `make` 无法在当前目录中找到一个前置文件时，它会依次在 `VPATH` 语句中的每个路径中查找该文件。'
- en: Adding remote build functionality to an existing makefile using `VPATH` is very
    simple. [Listing 4-8](ch04.xhtml#ch04ex08) shows an example of using a `VPATH`
    statement in a makefile.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `VPATH` 向现有的 makefile 添加远程构建功能非常简单。[清单 4-8](ch04.xhtml#ch04ex08) 展示了在 makefile
    中使用 `VPATH` 语句的一个示例。
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-8: An example of using `VPATH` in a makefile*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-8：在 makefile 中使用 `VPATH` 的示例*'
- en: In this (contrived) example, if `make` can’t find *src/main.c* in the current
    directory while processing the rule, it will look for *some/path/src/main.c*,
    and then for *some/other/path/src/main.c*, and finally for *yet/another/path/src/main.c*
    before giving up with an error message about not knowing how to make *src/main.c*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个（假设的）示例中，如果 `make` 在处理规则时无法在当前目录中找到 *src/main.c*，它将依次查找 *some/path/src/main.c*、*some/other/path/src/main.c*，最后查找
    *yet/another/path/src/main.c*，然后因无法找到 *src/main.c* 而报错。
- en: With just a few simple modifications, we can completely support remote builds
    in Jupiter. [Listings 4-9](ch04.xhtml#ch04ex09) and [4-10](ch04.xhtml#ch04ex10)
    illustrate the necessary changes to the project’s two makefiles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 只需做几处简单的修改，我们就能完全支持 Jupiter 中的远程构建。[清单 4-9](ch04.xhtml#ch04ex09) 和 [4-10](ch04.xhtml#ch04ex10)
    说明了对项目的两个 makefile 进行必要更改的方式。
- en: Git tag 4.3
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.3
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-9:* Makefile.in: *Adding VPATH build capabilities to the top-level
    makefile*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9:* Makefile.in: *向顶层 makefile 添加 VPATH 构建功能*'
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-10:* src/Makefile.in: *Adding `VPATH` build capabilities to the
    lower-level makefile*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10:* src/Makefile.in: *向低级 makefile 添加 `VPATH` 构建功能*'
- en: That’s it. Really. When `config.status` generates a file, it replaces an Autoconf
    substitution variable called `@srcdir@` with the relative path to the template’s
    source directory. The value substituted for `@srcdir@` in a given *Makefile* within
    the build directory structure is the relative path to the directory containing
    the corresponding *Makefile.in* template in the source directory structure. The
    concept here is that for each *Makefile* in the remote build directory, `VPATH`
    provides a relative path to the directory containing the source code for that
    build directory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，真的。当 `config.status` 生成一个文件时，它会将一个叫做 `@srcdir@` 的 Autoconf 替换变量替换为模板源目录的相对路径。在构建目录结构中的给定
    *Makefile* 中，替换 `@srcdir@` 的值是源目录结构中包含相应 *Makefile.in* 模板的目录的相对路径。这里的概念是，对于远程构建目录中的每个
    *Makefile*，`VPATH` 提供了一个相对路径，指向该构建目录的源代码所在的目录。
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not expect *`VPATH`* to work in commands. *`VPATH`* only allows *`make`*
    to find dependencies; therefore, you can only expect *`VPATH`* to take effect
    in target and dependency lists within rules. You may use *`$(srcdir)/`* as a prefix
    for file system objects in commands, as I’ve done in [Listing 4-10](ch04.xhtml#ch04ex10)
    in the command for the *`jupiter`* target rule.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要期望*`VPATH`* 在命令中有效。*`VPATH`* 只允许*`make`* 查找依赖项；因此，你只能期望*`VPATH`* 在规则中的目标和依赖列表中生效。你可以像我在
    [Listing 4-10](ch04.xhtml#ch04ex10) 中所做的那样，在命令中使用*`$(srcdir)/`*作为文件系统对象的前缀，针对*`jupiter`*
    目标规则。*'
- en: 'The changes required for supporting remote builds in your build system are
    summarized as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 支持远程构建所需的更改在你的构建系统中总结如下：
- en: Set a `make` variable, `srcdir`, to the `@srcdir@` substitution variable.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `make` 变量 `srcdir` 设置为 `@srcdir@` 替代变量。
- en: Set the `VPATH` variable to `@srcdir@`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `VPATH` 变量设置为 `@srcdir@`。
- en: Prefix all file dependencies used *in commands* with `$(srcdir)/`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*命令中*，所有文件依赖项前缀都需要加上 `$(srcdir)/`。
- en: '**NOTE**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t use *`$(srcdir)`* in the *`VPATH`* statement itself, because some older
    versions of *`make`* won’t substitute variable references within the *`VPATH`*
    statement.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在*`VPATH`* 语句中使用*`$(srcdir)`*，因为一些旧版本的*`make`* 在*`VPATH`* 语句中不会替换变量引用。*'
- en: If the source directory is the same as the build directory, the `@srcdir@` substitution
    variable degenerates to a dot (*.*). That means all of these `$(srcdir)`*/* prefixes
    simply degenerate to *./*, which is harmless.^([11](footnote.xhtml#ch04fn11))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源目录与构建目录相同，`@srcdir@` 替代变量会退化为一个点（*.*）。这意味着所有这些 `$(srcdir)`*/* 前缀都会简单地退化为
    *./*，这无害。^([11](footnote.xhtml#ch04fn11))
- en: 'A quick example is the easiest way to show you how this works. Now that Jupiter
    is fully functional with respect to remote builds, let’s give it a try. Start
    in the Jupiter project directory, create a subdirectory called *build*, and then
    change into that directory. Execute the `configure` script using a relative path
    and then list the current directory contents:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是展示这个功能如何工作的最简单方法。现在，Jupiter 在远程构建方面已经完全功能化，让我们试试看。在 Jupiter 项目目录中开始，创建一个名为*build*的子目录，然后进入该目录。使用相对路径执行
    `configure` 脚本，然后列出当前目录的内容：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The entire build system has been constructed by `configure` and `config.status`
    within the *build* subdirectory. Enter `make` to build the project from within
    the *build* directory:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 整个构建系统已由 `configure` 和 `config.status` 在*build* 子目录中构建完成。从*build* 目录内进入 `make`
    以构建项目：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: No matter where you are, if you can access the project directory using either
    a relative or an absolute path, you can do a remote build from that location.
    This is just one more thing that Autoconf does for you in Autoconf-generated configuration
    scripts. Imagine managing proper relative paths to source directories in your
    own hand-coded configuration scripts!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你身处何地，只要可以通过相对路径或绝对路径访问项目目录，你就可以从该位置进行远程构建。这仅仅是 Autoconf 在 Autoconf 生成的配置脚本中为你做的一件事。想象一下，在你自己编写的配置脚本中管理源目录的适当相对路径！
- en: Let’s Take a Breather
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稍作休息
- en: So far, I’ve shown you a nearly complete build system that includes almost all
    of the features outlined in the *GCS*. The features of Jupiter’s build system
    are all fairly self-contained and reasonably simple to understand. The most difficult
    feature to implement by hand is the configuration script. In fact, writing a configuration
    script by hand is so labor intensive, compared to the simplicity of using Autoconf,
    that I just skipped the hand-coded version entirely in [Chapter 3](ch03.xhtml).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经展示了一个几乎完整的构建系统，包含了*GCS*中概述的几乎所有功能。Jupiter 的构建系统的特性都相对独立，并且容易理解。手动实现的最困难的功能是配置脚本。实际上，与使用
    Autoconf 的简单性相比，手写配置脚本是如此繁琐，以至于我在 [第 3 章](ch03.xhtml) 中完全跳过了手写版本。
- en: Although using Autoconf as I’ve used it here is quite easy, most people don’t
    create their build systems in the manner I’ve shown you. Instead, they try to
    copy the build system of another project and tweak it to make it work in their
    own project. Later, when they start a new project, they do the same thing again.
    This can cause trouble because the code they’re copying was never meant to be
    used the way they’re now trying to use it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像我这里展示的那样使用 Autoconf 是非常简单的，但大多数人并不会像我展示的那样创建他们的构建系统。相反，他们会尝试复制另一个项目的构建系统，并对其进行调整，以使其在自己的项目中工作。后来，当他们开始一个新项目时，他们又会做同样的事情。这可能会导致问题，因为他们复制的代码从来没有打算以他们现在尝试的方式使用。
- en: I’ve seen projects in which the *configure.ac* file contained junk that had
    nothing to do with the project to which it belonged. These leftover bits came
    from some legacy project, but the maintainer didn’t know enough about Autoconf
    to properly remove all the extraneous text. With the Autotools, it’s generally
    better to start small and add what you need than to start with a copy of *configure.ac*
    from another full-featured build system and then try to pare it down to size or
    otherwise modify it to work with a new project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾见过一些项目，其中的 *configure.ac* 文件包含与所属项目无关的垃圾。这些残留的内容来自某个遗留项目，但维护者并不了解 Autoconf，因此无法正确地删除所有多余的文本。使用
    Autotools 时，通常最好从小开始，根据需要添加内容，而不是从另一个功能齐全的构建系统中复制一个 *configure.ac* 文件，然后试图将其缩减到适合的大小或修改它以适应新项目。
- en: I’m sure you’re feeling like there’s a lot more to learn about Autoconf, and
    you’re right. We’ll spend the remainder of this chapter examining the most important
    Autoconf macros and how they’re used in the context of the Jupiter project. But
    first, let’s go back and see if we might be able to simplify the Autoconf startup
    process even more by using another utility that comes with the Autoconf package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你一定觉得 Autoconf 还有很多东西需要学习，你说得对。我们将在本章剩余的部分研究最重要的 Autoconf 宏以及它们在 Jupiter
    项目中的使用方式。但首先，让我们回过头来看看，是否可以通过使用 Autoconf 包中另一个工具，进一步简化 Autoconf 启动过程。
- en: An Even Quicker Start with autoscan
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 autoscan 更快速的开始
- en: The easiest way to create a (mostly) complete *configure.ac* file is to run
    the `autoscan` utility, which is part of the Autoconf package. This utility examines
    the contents of a project directory and generates the basis for a *configure.ac*
    file (which `autoscan` names *configure.scan*) using existing makefiles and source
    files.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个（基本）完整的 *configure.ac* 文件的最简单方法是运行 `autoscan` 工具，它是 Autoconf 包的一部分。该工具会检查项目目录的内容，并使用现有的
    makefile 和源文件生成一个 *configure.ac* 文件的基础（`autoscan` 将其命名为 *configure.scan*）。
- en: Let’s see how well `autoscan` does on the Jupiter project. First, I’ll clean
    up the droppings from my earlier experiments, and then I’ll run `autoscan` in
    the *jupiter* directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `autoscan` 在 Jupiter 项目中表现如何。首先，我将清理掉我之前实验中留下的痕迹，然后我将在 *jupiter* 目录中运行
    `autoscan`。
- en: '**NOTE**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using the git repository that accompanies this book, you can simply
    run *`git clean -df`* to remove all files and directories not currently under
    source control by git. Don’t forget to switch back into the parent directory if
    you’re still sitting in the build directory.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你正在使用本书附带的 git 仓库，你可以简单地运行 *`git clean -df`* 来删除所有未被 git 源控制管理的文件和目录。别忘了，如果你仍然在构建目录中，切换回父目录。*'
- en: 'Note that I’m *not* deleting my original *configure.ac* file—I’ll just let
    `autoscan` tell me how to improve it. In less than a second, I have a few new
    files in the top-level directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我*并没有*删除我的原始 *configure.ac* 文件——我只是让 `autoscan` 告诉我如何改进它。在不到一秒钟的时间里，我在顶层目录下得到了一些新的文件：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `autoscan` utility examines the project directory hierarchy and creates
    two files called *configure.scan* and *autoscan.log*. The project may or may not
    already be instrumented for the Autotools—it doesn’t really matter, because `autoscan`
    is decidedly nondestructive. It will never alter any existing files in a project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoscan` 工具会检查项目目录结构，并创建两个文件：*configure.scan* 和 *autoscan.log*。该项目可能已经为 Autotools
    做了准备，也可能没有——这并不重要，因为 `autoscan` 是完全无破坏性的。它绝不会修改项目中任何现有的文件。'
- en: The `autoscan` utility generates a warning message for each problem it discovers
    in an existing *configure.ac* file. In this example, `autoscan` noticed that *configure.ac*
    should be using the Autoconf-provided `AC_CHECK_HEADERS`, `AC_PREREQ`, `AC_PROG_CC`,
    and `AC_PROG_INSTALL` macros. It made these assumptions based on information gleaned
    from the existing *Makefile.in* templates and from the C-language source files,
    as you can see by the comments after the warning statements beginning at ➊. You
    can always see these messages (in even greater detail) by examining the *autoscan.log*
    file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoscan` 工具会为它在现有的 *configure.ac* 文件中发现的每个问题生成一条警告消息。在这个例子中，`autoscan` 注意到
    *configure.ac* 应该使用 Autoconf 提供的 `AC_CHECK_HEADERS`、`AC_PREREQ`、`AC_PROG_CC` 和
    `AC_PROG_INSTALL` 宏。它是根据从现有的 *Makefile.in* 模板和 C 语言源文件中获取的信息做出这些假设的，正如你在警告语句后的评论中看到的那样，警告语句从
    ➊ 开始。你可以通过检查 *autoscan.log* 文件来查看这些消息（更详细的信息）。'
- en: '**NOTE**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The notices you receive from *`autoscan`* and the contents of your configure.ac
    file may differ slightly from mine, depending on the version of Autoconf you have
    installed. I have version 2.69 of GNU Autoconf installed on my system (the latest,
    as of this writing). If your version of *`autoscan`* is older (or newer), you
    may see some minor differences.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*你从*`autoscan`* 接收到的通知和你的 configure.ac 文件的内容可能会根据你安装的 Autoconf 版本与我的略有不同。我系统中安装的是
    GNU Autoconf 的 2.69 版本（截至本文写作时为最新版本）。如果你的 *`autoscan`* 版本较旧（或较新），你可能会看到一些小的差异。*'
- en: 'Looking at the generated *configure.scan* file, I note that `autoscan` has
    added more text to this file than was in my original *configure.ac* file. After
    looking it over to ensure that I understand everything, I see that it’s probably
    easiest for me to overwrite *configure.ac* with *configure.scan* and then change
    the few bits of information that are specific to Jupiter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的 *configure.scan* 文件，我注意到 `autoscan` 向该文件添加的文本比我原始的 *configure.ac* 文件中的内容更多。查看后我确保理解所有内容后，我发现最简单的方法是用
    *configure.scan* 文件覆盖 *configure.ac* 文件，然后更改一些特定于 Jupiter 的信息：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: My first modification involves changing the `AC_INIT` macro parameters for Jupiter,
    as illustrated in [Listing 4-11](ch04.xhtml#ch04ex11).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一次修改涉及更改 Jupiter 的 `AC_INIT` 宏参数，如 [示例 4-11](ch04.xhtml#ch04ex11) 所示。
- en: Git tag 4.4
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.4
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 4-11:* configure.ac: *Tweaking the `AC_INIT` macro generated by `autoscan`*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-11：* configure.ac: *调整 `autoscan` 生成的 `AC_INIT` 宏*'
- en: The `autoscan` utility does a lot of the work for you. The *GNU Autoconf Manual*^([12](footnote.xhtml#ch04fn12))
    states that you should modify this file to meet the needs of your project before
    you use it, but there are only a few key issues to worry about (besides those
    related to `AC_INIT`). I’ll cover each of these issues in turn, but first, let’s
    take care of a few administrative details.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoscan` 工具为你做了大量的工作。*GNU Autoconf 手册*^([12](footnote.xhtml#ch04fn12)) 中指出，在使用此文件之前，你应根据项目的需求修改该文件，但除了与
    `AC_INIT` 相关的问题外，只有一些关键问题需要关注。我将依次讲解这些问题，但首先，我们需要处理一些行政细节。'
- en: I’d be remiss if I didn’t mention `autoupdate` while discussing `autoscan`.
    If you’ve already got a working *configure.ac* file, and you update to a newer
    version of Autoconf, you can run `autoupdate` to update your existing *configure.ac*
    file with constructs that have changed or been added since the older version of
    Autoconf.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 `autoscan` 时，我必须提到 `autoupdate`。如果你已经有了一个工作正常的 *configure.ac* 文件，并且你更新到更新版本的
    Autoconf，你可以运行 `autoupdate` 来更新你现有的 *configure.ac* 文件，使其包含自旧版本 Autoconf 以来更改或新增的构造。
- en: '*The Proverbial bootstrap.sh Script*'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*所谓的 bootstrap.sh 脚本*'
- en: Before `autoreconf` came along, maintainers passed around a short shell script,
    often named `autogen.sh` or `bootstrap.sh`, which would run all of the Autotools
    required for their projects in the proper order. The recommended name for this
    script is `bootstrap.sh` because Autogen is the name of another GNU project. The
    `bootstrap.sh` script can be fairly sophisticated, but to solve the problem of
    the missing `install-sh` script (see “Missing Required Files in Autoconf,” next),
    I’ll just add a simple temporary `bootstrap.sh` script to the project root directory,
    as shown in [Listing 4-12](ch04.xhtml#ch04ex12).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `autoreconf` 出现之前，维护者们会传递一个简短的 shell 脚本，通常命名为 `autogen.sh` 或 `bootstrap.sh`，该脚本会按照正确的顺序运行所需的所有
    Autotools。这个脚本的推荐名称是 `bootstrap.sh`，因为 Autogen 是另一个 GNU 项目的名称。`bootstrap.sh` 脚本可以相当复杂，但为了处理缺失的
    `install-sh` 脚本问题（请参见“Autoconf 中缺失的必需文件”），我将只添加一个简单的临时 `bootstrap.sh` 脚本到项目的根目录，如
    [示例 4-12](ch04.xhtml#ch04ex12) 所示。
- en: Git tag 4.5
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.5
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 4-12:* bootstrap.sh: *A temporary bootstrap script that executes the
    required Autotools*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-12：* bootstrap.sh: *一个临时的 bootstrap 脚本，用于执行所需的 Autotools*'
- en: The Automake `--add-missing` option copies the required missing utility scripts
    into the project, and the `--copy` option indicates that true copies should be
    made (otherwise, symbolic links are created that refer to the files where they’re
    installed with the Automake package).^([13](footnote.xhtml#ch04fn13))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Automake `--add-missing` 选项将所需的缺失工具脚本复制到项目中，`--copy` 选项表示应该创建真正的副本（否则，会创建指向安装目录中文件的符号链接，链接文件是与
    Automake 包一起安装的）。^([13](footnote.xhtml#ch04fn13))
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We don’t need to see the warnings from executing *`automake`*, so I’ve redirected
    the *`stderr`* and *`stdout`* streams to /dev/null on the *`automake`* command
    line at ➊ in this script. In [Chapter 6](ch06.xhtml), we’ll remove *`bootstrap.sh`*
    and simply run *`autoreconf --install`*, but for now, this solves our missing
    file problems.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们不需要看到执行 *`automake`* 时的警告，因此我在这个脚本的 ➊ 处将 *`stderr`* 和 *`stdout`* 流重定向到 /dev/null。在[第6章](ch06.xhtml)中，我们将移除
    *`bootstrap.sh`* 并简单地运行 *`autoreconf --install`*，但目前为止，这解决了我们缺失文件的问题。*'
- en: MISSING REQUIRED FILES IN AUTOCONF
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 中缺少的必需文件
- en: 'When I first tried to execute `autoreconf` on the *configure.ac* file in [Listing
    4-11](ch04.xhtml#ch04ex11), I discovered a minor problem related to using Autoconf
    *without* Automake. When I ran the `configure` script, it failed with an error:
    `configure: error: cannot find install-sh, install.sh, or shtool in "." "./.."
    "./../.."`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '当我第一次尝试在 [清单 4-11](ch04.xhtml#ch04ex11) 中的 *configure.ac* 文件上执行 `autoreconf`
    时，我发现了一个小问题，关于在没有 Automake 的情况下使用 Autoconf。当我运行 `configure` 脚本时，它因错误而失败：`configure:
    error: cannot find install-sh, install.sh, or shtool in "." "./.." "./../.."`。'
- en: 'Autoconf is all about portability and, unfortunately, the Unix `install` utility
    is not as portable as it could be. From one platform to another, critical bits
    of installation functionality are just different enough to cause problems, so
    the Autotools provide a shell script called `install-sh` (deprecated name: `install.sh`).
    This script acts as a wrapper around the system’s own `install` utility, masking
    important differences between various versions of `install`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 旨在实现可移植性，但不幸的是，Unix 的 `install` 工具并不像它本可以那样可移植。从一个平台到另一个平台，安装功能的关键部分差异足够大，以至于会引发问题，因此
    Autotools 提供了一个名为 `install-sh`（已弃用名称：`install.sh`）的 shell 脚本。该脚本作为系统自带的 `install`
    工具的包装器，屏蔽了不同版本的 `install` 之间的重要差异。
- en: '`autoscan` noticed that I’d used the `install` program in my *src/Makefile.in*
    template, so it generated an expansion of the `AC_PROG_INSTALL` macro. The problem
    is that `configure` couldn’t find the `install-sh` wrapper script anywhere in
    my project.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoscan` 注意到我在 *src/Makefile.in* 模板中使用了 `install` 程序，因此它生成了 `AC_PROG_INSTALL`
    宏的扩展。问题是 `configure` 无法在我的项目中找到 `install-sh` 包装脚本。'
- en: I reasoned that the missing file was part of the Autoconf package and it just
    needed to be installed. I also knew that `autoreconf` accepts a command line option
    to install such missing files into a project directory. The `--install` (`-i`)
    option supported by `autoreconf` is designed to pass tool-specific options down
    to each of the tools that it calls in order to install missing files. However,
    when I tried that, I found that the file was still missing, because `autoconf`
    doesn’t support an option to install missing files.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我推测缺失的文件是 Autoconf 包的一部分，只需要安装它即可。我还知道 `autoreconf` 接受一个命令行选项来将这些缺失的文件安装到项目目录中。`--install`（`-i`）选项由
    `autoreconf` 支持，用于将特定于工具的选项传递给它调用的每个工具，以便安装缺失的文件。然而，当我尝试这个方法时，我发现文件依然丢失，因为 `autoconf`
    不支持安装缺失文件的选项。
- en: I could have manually copied `install-sh` from the Automake installation directory
    (usually */usr/(local/)share/automake-**), but looking for a more automated solution,
    I tried manually executing `automake --add-missing --copy`. This command generated
    a slew of warnings indicating that the project was not configured for Automake.
    However, I could now see that `install-sh` had been copied into my project root
    directory, and that’s all I was after. Executing `autoreconf --install` didn’t
    run `automake` because *configure.ac* was not set up for Automake.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以手动从 Automake 安装目录（通常是 */usr/(local/)share/automake-**）复制 `install-sh`，但为了寻找更自动化的解决方案，我尝试手动执行
    `automake --add-missing --copy`。这个命令生成了大量警告，表明项目没有为 Automake 配置。然而，我现在可以看到 `install-sh`
    已经被复制到了我的项目根目录，这正是我需要的。执行 `autoreconf --install` 并没有运行 `automake`，因为 *configure.ac*
    没有为 Automake 设置。
- en: Autoconf should ship with `install-sh`, since it provides a macro that requires
    it, but then `autoconf` would have to provide an `--add-missing` command line
    option. Nevertheless, there is actually a quite obvious solution to this problem.
    The `install-sh` script is not really required by any code Autoconf generates.
    How could it be? Autoconf doesn’t generate any makefile constructs—it only substitutes
    variables into your *Makefile.in* templates. Thus, there’s really no reason for
    Autoconf to complain about a missing `install-sh` script.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 应该随 `install-sh` 一起提供，因为它提供了一个需要该脚本的宏，但那样的话 `autoconf` 还需要提供一个 `--add-missing`
    命令行选项。不过，实际上有一个相当明显的解决方案。`install-sh` 脚本并不是 Autoconf 生成的任何代码所必需的。怎么会呢？Autoconf
    并不生成任何 makefile 构造——它只是将变量替换到你的 *Makefile.in* 模板中。因此，Autoconf 没有理由抱怨缺少 `install-sh`
    脚本。
- en: '*Updating Makefile.in*'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*更新 Makefile.in*'
- en: 'Let’s make `bootstrap.sh` executable and then execute it and see what we end
    up with:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使 `bootstrap.sh` 可执行，然后执行它，看看最终会得到什么：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We know from the file list at ➊ that *config.h.in* has been created, so we know
    that `autoreconf` has executed `autoheader`. We also see the new `install-sh`
    script at ➋ that was created when we executed `automake` in `bootstrap.sh`. Anything
    provided or generated by the Autotools should be copied into the archive directory
    so that it can be shipped with release tarballs. Therefore, we’ll add `cp` commands
    for these two files to the `$(distdir)` target in the top-level *Makefile.in*
    template. Note that we don’t need to copy the `bootstrap.sh` script because it’s
    purely a maintainer tool—users should never need to execute it from a tarball
    distribution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ➊ 处的文件列表中，我们知道已经创建了 *config.h.in*，因此我们知道 `autoreconf` 已执行了 `autoheader`。我们还看到新创建的
    `install-sh` 脚本在 ➋ 处，它是在我们执行 `bootstrap.sh` 中的 `automake` 时创建的。任何 Autotools 提供或生成的文件都应该复制到归档目录中，以便可以随发行的
    tarball 一起打包。因此，我们将为这两个文件添加 `cp` 命令到顶层 *Makefile.in* 模板中的 `$(distdir)` 目标。请注意，我们不需要复制
    `bootstrap.sh` 脚本，因为它完全是一个维护工具—用户不应该需要从 tarball 分发版中执行它。
- en: '[Listing 4-13](ch04.xhtml#ch04ex13) illustrates the required changes to the
    `$(distdir)` target in the top-level *Makefile.in* template.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-13](ch04.xhtml#ch04ex13) 展示了对顶层 *Makefile.in* 模板中的 `$(distdir)` 目标所需的更改。'
- en: Git tag 4.6
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.6
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-13:* Makefile.in: *Additional files needed in the distribution archive
    image directory*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-13:* Makefile.in：*在分发归档镜像目录中需要的附加文件*'
- en: If you’re beginning to think that this could become a maintenance problem, then
    you’re right. I mentioned earlier that the `$(distdir)` target was painful to
    maintain. Luckily, the `distcheck` target still exists and still works as designed.
    It would have caught this problem, because attempts to build from the tarball
    will fail without these additional files—and the `distcheck` target certainly
    won’t succeed if the build fails. When we discuss Automake in [Chapter 6](ch06.xhtml),
    we will clear up much of this maintenance mess.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始觉得这可能会变成一个维护问题，那么你是对的。我之前提到过 `$(distdir)` 目标维护起来很痛苦。幸运的是，`distcheck` 目标仍然存在并按预期工作。它会捕捉到这个问题，因为没有这些附加文件，从
    tarball 构建的尝试将失败—如果构建失败，`distcheck` 目标肯定不会成功。当我们在 [第六章](ch06.xhtml) 中讨论 Automake
    时，我们会清理掉很多维护上的麻烦。
- en: Initialization and Package Information
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化和包信息
- en: Now let’s turn our attention back to the contents of the *configure.ac* file
    in [Listing 4-11](ch04.xhtml#ch04ex11) (and the console example immediately preceding
    that listing). The first section contains Autoconf initialization macros. These
    are required for all projects. Let’s consider each of these macros individually,
    because they’re all important.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 [列表 4-11](ch04.xhtml#ch04ex11) 中的 *configure.ac* 文件内容（以及该列表之前的控制台示例）。第一部分包含
    Autoconf 初始化宏。这些是所有项目所必需的。让我们单独考虑每个宏，因为它们都很重要。
- en: '*AC_PREREQ*'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AC_PREREQ*'
- en: 'The `AC_PREREQ` macro simply defines the earliest version of Autoconf that
    may be used to successfully process this *configure.ac* file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_PREREQ` 宏仅仅定义了可以成功处理此 *configure.ac* 文件的最早版本的 Autoconf：'
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *GNU Autoconf Manual* indicates that `AC_PREREQ` is the only macro that
    may be used before `AC_INIT`. This is because it’s good to ensure you’re using
    a new enough version of Autoconf before you begin processing any other macros,
    which may be version dependent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU Autoconf 手册* 表示，`AC_PREREQ` 是唯一可以在 `AC_INIT` 之前使用的宏。这是因为，在处理任何其他可能依赖版本的宏之前，确保使用新版本的
    Autoconf 是一个好做法。'
- en: '*AC_INIT*'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AC_INIT*'
- en: The `AC_INIT` macro, as its name implies, initializes the Autoconf system. Here’s
    its prototype, as defined in the *GNU Autoconf Manual*:^([14](footnote.xhtml#ch04fn14))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_INIT`宏，顾名思义，用于初始化Autoconf系统。以下是它的原型，定义在*GNU Autoconf手册*中：^([14](footnote.xhtml#ch04fn14))'
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It accepts up to five arguments (`autoscan` only generates an invocation with
    the first three): *`package`*, *`version`*, and, optionally, *`bug-report`*, *`tarname`*,
    and *`url`*. The *`package`* argument is intended to be the name of the package.
    It will end up (in a canonical form) as the first part of the name of an Automake-generated
    release distribution tarball when you execute `make dist`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它最多接受五个参数（`autoscan`仅生成带有前三个参数的调用）：*`package`*、*`version`*，以及可选的*`bug-report`*、*`tarname`*和*`url`*。*`package`*参数是包的名称。在你执行`make
    dist`时，它会以标准形式作为Automake生成的发布版本tarball名称的一部分。
- en: '**NOTE**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Autoconf uses a normalized form of the package name in the tarball name, so
    you can use uppercase letters in the package name, if you wish. Automake-generated
    tarballs are named *`tarname`*-*`version`*.tar.gz by default, but *`tarname`*
    is set to a normalized form of the *`package`* name (lowercase, with all punctuation
    converted to underscores). Bear this in mind when you choose your package name
    and version string.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*Autoconf在tarball名称中使用了包名称的标准化形式，因此，如果你愿意，可以在包名中使用大写字母。Automake生成的tarballs默认命名为*`tarname`*-*`version`*.tar.gz，但*`tarname`*被设置为包名称（小写，所有标点符号转换为下划线）的标准化形式。选择包名称和版本字符串时请记住这一点。*'
- en: The optional *`bug-report`* argument is usually set to an email address, but
    any text string is valid—the URL of a web page that accepts bug reports for the
    project is a common alternative. An Autoconf substitution variable called `@PACKAGE_BUGREPORT@`
    is created for it, and that variable is also added to the *config.h.in* template
    as a C-preprocessor definition. The intent here is that you use the variable in
    your code to present an email address or URL for bug reports at appropriate places—possibly
    when the user requests help or version information from your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的*`bug-report`*参数通常设置为一个电子邮件地址，但任何文本字符串都是有效的——一个接受项目bug报告的网页URL是常见的替代方式。一个名为`@PACKAGE_BUGREPORT@`的Autoconf替换变量会为它创建，并且该变量也会添加到*config.h.in*模板中，作为C预处理器定义。这样做的目的是让你在代码中使用这个变量，在适当的位置显示电子邮件地址或用于报告bug的URL——可能是在用户请求帮助或版本信息时。
- en: While the *`version`* argument can be anything you like, there are a few commonly
    used OSS conventions that will make things a little easier for you. The most widely
    used convention is to pass in *major.minor* (for example, 1.2). However, there’s
    nothing that says you can’t use *major.minor.revision*, and there’s nothing wrong
    with this approach. None of the resulting `VERSION` variables (Autoconf, shell,
    or `make`) are parsed or analyzed anywhere—they’re only used as placeholders for
    substituted text in various locations.^([15](footnote.xhtml#ch04fn15)) So if you
    wish, you may even add nonnumerical text into this macro, such as *0.15.alpha1*,
    which is occasionally useful.^([16](footnote.xhtml#ch04fn16))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*`version`*参数可以是你喜欢的任何内容，但有一些常用的开源软件规范可以让你更轻松地处理这个问题。最广泛使用的规范是传入*major.minor*（例如，1.2）。然而，并没有规定你不能使用*major.minor.revision*，这种方式也没有问题。生成的`VERSION`变量（Autoconf、shell或`make`）在任何地方都不会被解析或分析——它们只是作为占位符，用于在不同位置替换文本。^([15](footnote.xhtml#ch04fn15))
    所以如果你愿意，你甚至可以在这个宏中添加非数字文本，例如*0.15.alpha1*，这种做法有时也很有用。^([16](footnote.xhtml#ch04fn16))
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The RPM package manager, on the other hand, does care what you put in the
    version string. For the sake of RPM, you may wish to limit the version string
    text to only alphanumeric characters and periods—no dashes or underscores.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*另一方面，RPM包管理器对版本字符串中的内容比较严格。为了兼容RPM，你可能希望将版本字符串文本限制为仅包含字母数字字符和句点——不允许使用连字符或下划线。*'
- en: The optional *`url`* argument should be the URL for your project website. It’s
    shown in the help text displayed by `configure --help`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的*`url`*参数应该是你项目网站的URL。它会显示在`configure --help`命令的帮助文本中。
- en: Autoconf generates the substitution variables `@PACKAGE_NAME@`, `@PACKAGE_VERSION@`,
    `@PACKAGE_TARNAME@`, `@PACKAGE_STRING@` (a stylized concatenation of the package
    name and version information), `@PACKAGE_BUGREPORT@`, and `@PACKAGE_URL@` from
    the arguments to `AC_INIT`. You can use any or all of these in your *Makefile.in*
    template files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf根据`AC_INIT`的参数生成替换变量`@PACKAGE_NAME@`、`@PACKAGE_VERSION@`、`@PACKAGE_TARNAME@`、`@PACKAGE_STRING@`（包名称和版本信息的样式化连接）、`@PACKAGE_BUGREPORT@`和`@PACKAGE_URL@`。你可以在*Makefile.in*模板文件中使用这些变量中的任何一个或所有。
- en: '*AC_CONFIG_SRCDIR*'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*AC_CONFIG_SRCDIR*'
- en: The `AC_CONFIG_SRCDIR` macro is a sanity check. Its purpose is to ensure that
    the generated `configure` script knows that the directory on which it is being
    executed is actually the project directory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`AC_CONFIG_SRCDIR`宏是一个合理性检查。它的目的是确保生成的`configure`脚本知道它正在执行的目录实际上是项目目录。'
- en: More specifically, `configure` needs to be able to locate itself, because it
    generates code that executes itself, possibly from a remote directory. There are
    myriad ways to inadvertently fool `configure` into finding some other `configure`
    script. For example, the user could accidentally provide an incorrect `--srcdir`
    argument to `configure`. The `$0` shell script parameter is unreliable, at best—it
    may contain the name of the shell, rather than that of the script, or it may be
    that `configure` was found in the system search path, so no path information was
    specified on the command line.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体来说，`configure`需要能够找到它自己，因为它生成的代码需要执行自己，可能是从一个远程目录中执行。有许多方式可以不小心让`configure`找到其他的`configure`脚本。例如，用户可能会不小心为`configure`提供一个错误的`--srcdir`参数。`$0`这个Shell脚本参数最多也只是可靠，它可能包含的是Shell的名称，而不是脚本的名称，或者可能是`configure`在系统搜索路径中找到的，因此在命令行上没有指定路径信息。
- en: 'The `configure` script could try looking in the current or parent directories,
    but it still needs a way to verify that the `configure` script it locates is actually
    itself. Thus, `AC_CONFIG_SRCDIR` gives `configure` a significant hint that it’s
    looking in the right place. Here’s the prototype for `AC_CONFIG_SRCDIR`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`脚本可以尝试在当前或父目录中查找，但它仍然需要一种方法来验证它找到的`configure`脚本是否确实是它自己。因此，`AC_CONFIG_SRCDIR`为`configure`提供了一个重要的提示，告诉它正在正确的位置查找。以下是`AC_CONFIG_SRCDIR`的原型：'
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The argument can be a path (relative to the project’s `configure` script) to
    any source file you like. You should choose one that is unique to your project
    so as to minimize the possibility that `configure` is fooled into thinking some
    other project’s configuration file is itself. I normally try to choose a file
    that sort of represents the project, such as a source file named for a feature
    that defines the project. That way, in case I ever decide to reorganize the source
    code, I’m not likely to lose it in a file rename. In this case, however, we have
    only one source file, *main.c*, making it a little difficult to follow this convention.
    Regardless, both `autoconf` and `configure` will tell you and your users if it
    can’t find the file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是任何源文件的路径（相对于项目的`configure`脚本）。你应该选择一个在你的项目中唯一的文件，以尽量减少`configure`被误导为其他项目的配置文件的可能性。我通常选择一个代表项目的文件，例如一个定义了项目特性的源文件。这样，即使我以后决定重新组织源代码，也不太可能因为文件重命名而丢失它。然而，在这种情况下，我们只有一个源文件，*main.c*，这使得遵循这个约定有点困难。无论如何，`autoconf`和`configure`都会告诉你和你的用户如果它找不到这个文件。
- en: The Instantiating Macros
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例化宏
- en: 'Before we dive into the details of `AC_CONFIG_HEADERS`, I’d like to spend a
    little time on the file generation framework Autoconf provides. From a high-level
    perspective, there are four major things happening in *configure.ac*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论`AC_CONFIG_HEADERS`的细节之前，我想花点时间介绍一下Autoconf提供的文件生成框架。从一个高层次的角度来看，*configure.ac*中有四个主要的内容：
- en: Initialization
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化
- en: Check request processing
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查请求处理
- en: File instantiation request processing
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件实例化请求处理
- en: Generation of the `configure` script
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成`configure`脚本
- en: We’ve covered initialization—there’s not much to it, although there are a few
    more macros you should be aware of. Check out the *GNU Autoconf Manual* for more
    information—look up `AC_COPYRIGHT`, for an example. Now let’s move on to file
    instantiation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了初始化——它并不复杂，尽管有一些宏你应该了解。更多信息可以查看*GNU Autoconf手册*，查找`AC_COPYRIGHT`作为一个示例。现在让我们继续讨论文件实例化。
- en: 'There are actually four so-called *instantiating macros*: `AC_CONFIG_FILES`,
    `AC_CONFIG_HEADERS`, `AC_CONFIG_COMMANDS`, and `AC_CONFIG_LINKS`. An instantiating
    macro accepts a list of tags or files; `configure` will generate these files from
    templates containing Autoconf substitution variables.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有四个所谓的*实例化宏*：`AC_CONFIG_FILES`、`AC_CONFIG_HEADERS`、`AC_CONFIG_COMMANDS`和`AC_CONFIG_LINKS`。实例化宏接受标签或文件列表；`configure`将根据包含
    Autoconf 替代变量的模板生成这些文件。
- en: '**NOTE**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might need to change the name of *`AC_CONFIG_HEADER`* (singular) to *`AC_CONFIG_HEADERS`*
    (plural) in your version of* configure.scan. *The singular version is the older
    name for this macro, and the older macro is less functional than the newer one.^([17](footnote.xhtml#ch04fn17))*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能需要在你的版本的configure.scan中将*`AC_CONFIG_HEADER`*（单数）更改为*`AC_CONFIG_HEADERS`*（复数）。单数版本是该宏的旧名称，旧宏比新宏功能少。^([17](footnote.xhtml#ch04fn17))*'
- en: 'The four instantiating macros have an interesting common signature. The following
    prototype can be used to represent each of them, with appropriate text replacing
    the *`XXX`* portion of the macro name:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个实例化宏具有一个有趣的共同签名。以下原型可用于表示它们中的每一个，适当的文本将替换宏名称中的*`XXX`*部分：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For each of these four macros, the tag argument has the form *`OUT`*`[:`*`INLIST`*`]`,
    where *`INLIST`* has the form *`IN0`*`[:`*`IN1`*`:...:`*`INn`*`]`. Often, you’ll
    see a call to one of these macros with only a single argument, as in the three
    examples that follow (note that these examples represent macro *invocations*,
    not *prototypes*, so the square brackets are actually Autoconf quotes, not indications
    of optional parameters):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这四个宏中的每一个，标签参数的形式是*`OUT`*`[:`*`INLIST`*`]`，其中*`INLIST`*的形式是*`IN0`*`[:`*`IN1`*`:...:`*`INn`*`]`。通常，你会看到这些宏的调用只有一个参数，如下三个示例所示（请注意，这些示例表示宏*调用*，而不是*原型*，所以方括号实际上是
    Autoconf 引号，而不是可选参数的指示）：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, *config.h* is the *`OUT`* portion of the preceding specification.
    The default value for *`INLIST`* is the *`OUT`* portion with *.in* appended to
    it. So, in other words, the preceding call is exactly equivalent to the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，*config.h*是前述规范中的*`OUT`*部分。*`INLIST`*的默认值是*`OUT`*部分并附加了*.in*。换句话说，前面的调用与以下内容完全等效：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'What this means is that `config.status` contains shell code that will generate
    *config.h* from *config.h.in*, substituting all Autoconf variables in the process.
    You may also provide a list of input files in the *`INLIST`* portion. In this
    case, the files in *`INLIST`* will be concatenated to form the resulting *`OUT`*
    file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`config.status`包含的 shell 代码将从*config.h.in*生成*config.h*，并在此过程中替换所有 Autoconf
    变量。你还可以在*`INLIST`*部分提供一个输入文件列表。在这种情况下，*`INLIST`*中的文件将被连接起来形成结果*`OUT`*文件：
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `config.status` will generate *config.h* by concatenating *cfg0*, *cfg1*,
    and *cfg2* (in that order), after substituting all Autoconf variables. The *GNU
    Autoconf Manual* refers to this entire *`OUT`*`[:`*`INLIST`*`]` construct as a
    *tag*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`config.status`将通过连接*cfg0*、*cfg1*和*cfg2*（按此顺序），在替换所有 Autoconf 变量后生成*config.h*。*GNU
    Autoconf 手册*将这个完整的*`OUT`*`[:`*`INLIST`*`]`构造称为一个*标签*。
- en: Why not just call it a *file*? Well, this parameter’s primary purpose is to
    provide a sort of command line target name—much like makefile targets. It can
    also be used as a filesystem name if the associated macro generates files, as
    is the case with `AC_CONFIG_HEADERS`, `AC_CONFIG_FILES`, and `AC_CONFIG_LINKS`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接称它为*文件*呢？嗯，这个参数的主要用途是提供一种类似 makefile 目标名称的命令行目标名称。它还可以用作文件系统名称，如果相关宏生成文件的话，就像`AC_CONFIG_HEADERS`、`AC_CONFIG_FILES`和`AC_CONFIG_LINKS`那样。
- en: 'But `AC_CONFIG_COMMANDS` is unique in that it doesn’t generate any files. Instead,
    it runs arbitrary shell code, as specified by the user in the macro’s arguments.
    Thus, rather than name this first parameter after a secondary function (the generation
    of files), the *GNU Autoconf Manual* refers to it more generally, according to
    its primary purpose—as a command line *tag* that may be specified on the `./config.status`
    command line, in this manner:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`AC_CONFIG_COMMANDS`的独特之处在于它不会生成任何文件。相反，它运行用户在宏参数中指定的任意 shell 代码。因此，与其根据次要功能（文件生成）为这个第一个参数命名，*GNU
    Autoconf 手册*根据其主要用途，更一般地将其称为一个命令行*标签*，可以在`./config.status`命令行中指定，方式如下：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command will regenerate the *config.h* file based on the macro call to
    `AC_CONFIG_HEADERS` in *configure.ac*. It will *only* regenerate *config.h*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将根据*configure.ac*中对`AC_CONFIG_HEADERS`宏的调用重新生成*config.h*文件。它*只会*重新生成*config.h*。
- en: 'Enter `./config.status --help` to see the other command line options you can
    use when executing `./config.status`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `./config.status --help` 查看执行 `./config.status` 时可以使用的其他命令行选项：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that `config.status` provides custom help about a project’s `config .status`
    file. It lists configuration files ➍ and configuration headers ➎ that we can use
    as tags on the command line where the usage specifies `[TAG]...` at ➊. In this
    case, `config.status` will only instantiate the specified objects. In the case
    of commands, it will execute the command set specified by the tag passed in the
    associated expansion of the `AC_CONFIG_COMMANDS` macro.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`config.status` 提供了有关项目的 `config.status` 文件的自定义帮助。它列出了我们可以在命令行中使用的配置文件 ➍
    和配置头文件 ➎，这些文件在用法中指定 `[TAG]...` 的位置 ➊。在这种情况下，`config.status` 只会实例化指定的对象。在命令的情况下，它将执行通过关联的
    `AC_CONFIG_COMMANDS` 宏展开中传递的标签指定的命令集。
- en: 'Each of these macros may be used multiple times in a *configure.ac* file. The
    results are cumulative, and we can use `AC_CONFIG_FILES` as many times as we need
    to in *configure.ac*. It is also important to note that `config.status` supports
    the `--file=` option (at ➌). When you call `config.status` with tags on the command
    line, the only tags you can use are those the help text lists as available configuration
    files, headers, links, and commands. When you execute `config.status` with the
    `--file=` option, you’re telling `config.status` to generate a new file that’s
    not already associated with any of the calls to the instantiating macros found
    in *configure.ac*. This new file is generated from an associated template using
    configuration options and check results determined by the last execution of `configure`.
    For example, I could execute `config.status` in this manner (using a fictional
    template called *extra.in*):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏可以在 *configure.ac* 文件中多次使用。结果是累积的，我们可以在 *configure.ac* 中根据需要多次使用 `AC_CONFIG_FILES`。还需要注意的是，`config.status`
    支持 `--file=` 选项（在 ➌ 位置）。当你在命令行中调用 `config.status` 时，唯一可以使用的标签是帮助文本中列出的可用配置文件、头文件、链接和命令。当你使用
    `--file=` 选项执行 `config.status` 时，你是在告诉 `config.status` 生成一个新文件，该文件尚未与任何在 *configure.ac*
    中找到的实例化宏调用关联。这个新文件是从一个关联的模板生成的，使用的是通过上次执行 `configure` 确定的配置选项和检查结果。例如，我可以通过以下方式执行
    `config.status`（使用一个虚构的模板 *extra.in*）：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**NOTE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The default template name is the filename with a .in suffix, so this call
    could have been made without using the *`:extra.in`* portion of the option. I
    added it here for clarity.*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*默认的模板名称是文件名加上 .in 后缀，因此这个调用可以在不使用 *`:extra.in`* 选项部分的情况下完成。我在这里添加它是为了更清晰地说明。*'
- en: 'Finally, I’d like to point out a newer feature of `config.status`—the `--config`
    option at ➋, added with version 2.65 of Autoconf. Using this option displays the
    explicit configuration options passed to `configure` on the command line. For
    instance, assume that we had invoked `./configure` in this manner:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想指出 `config.status` 的一个新特性——版本2.65的 Autoconf 添加了 `--config` 选项，在 ➋ 位置显示。使用此选项会显示传递给
    `configure` 的显式配置选项。例如，假设我们以这种方式调用了 `./configure`：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you use the new `--config` option, `./config.status` displays the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用新的 `--config` 选项时，`./config.status` 会显示以下内容：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**NOTE**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Older versions of Autoconf generated a *`config.status`* script that displayed
    this information when using the *`--version`* option, but it was part of a larger
    wall of text. The newer *`--config`* option makes it easier to find and reuse
    configuration options originally passed to the *`configure`* script.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*较旧版本的 Autoconf 会生成一个 *`config.status`* 脚本，当使用 *`--version`* 选项时，它会显示这些信息，但它是更大一块文本的一部分。较新的
    *`--config`* 选项使得查找和重用最初传递给 *`configure`* 脚本的配置选项变得更加容易。*'
- en: Let’s return now to the instantiating macro signature at the bottom of [page
    102](ch04.xhtml#page_102). I’ve shown you that the *`tag...`* argument has a complex
    format, but the ellipsis indicates that it also represents multiple tags, separated
    by whitespace. The format you’ll see in nearly all *configure.ac* files is shown
    in [Listing 4-14](ch04.xhtml#ch04ex14).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到[第102页](ch04.xhtml#page_102)底部的实例化宏签名。我已经向你展示了 *`tag...`* 参数具有复杂的格式，但省略号表示它也代表多个标签，用空格分隔。你将在几乎所有
    *configure.ac* 文件中看到的格式，如[清单4-14](ch04.xhtml#ch04ex14)所示。
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 4-14: Specifying multiple tags (files) in `AC_CONFIG_FILES`*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-14：在 `AC_CONFIG_FILES` 中指定多个标签（文件）*'
- en: Each entry here is one tag specification, which, if fully specified, would look
    like the call in [Listing 4-15](ch04.xhtml#ch04ex15).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的每一项都是一个标签规范，如果完全指定，应该类似于[清单4-15](ch04.xhtml#ch04ex15)中的调用。
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 4-15: Fully specifying multiple tags in `AC_CONFIG_FILES`*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-15：在 `AC_CONFIG_FILES` 中完全指定多个标签*'
- en: 'Returning to the instantiating macro prototype, there are two optional arguments
    that you’ll rarely see used in these macros: *`commands`* and *`init-cmds`*. The
    *`commands`* argument may be used to specify some arbitrary shell code that should
    be executed by `config.status` just before the files associated with the tags
    are generated. It is unusual for this feature to be used within the file-generating
    instantiating macros. You will almost always see the *`commands`* argument used
    with `AC_CONFIG_COMMANDS`, which generates no files by default, because a call
    to this macro is basically useless without commands to execute!^([18](footnote.xhtml#ch04fn18))
    In this case, the *`tag`* argument becomes a way of telling `config .status` to
    execute a specific set of shell commands.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实例化宏原型，有两个在这些宏中很少使用的可选参数：*`commands`* 和 *`init-cmds`*。*`commands`* 参数可用于指定一些任意的
    shell 代码，这些代码将在 `config.status` 生成与标签相关的文件之前执行。通常不在文件生成实例化宏中使用此功能。你几乎总是会看到 *`commands`*
    参数与 `AC_CONFIG_COMMANDS` 一起使用，因为默认情况下该宏不会生成任何文件，因为如果没有要执行的命令，调用此宏基本上是没有用的！^([18](footnote.xhtml#ch04fn18))
    在这种情况下，*`tag`* 参数成为告诉 `config.status` 执行一组特定的 shell 命令的方法。
- en: The *`init-cmds`* argument initializes shell variables at the top of `config
    .status` with values available in *configure.ac* and `configure`. It’s important
    to remember that all calls to instantiating macros share a common namespace along
    with `config.status`. Therefore, you should try to choose your shell variable
    names carefully so they are less likely to conflict with each other and with Autoconf-generated
    variables.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*`init-cmds`* 参数用于在 `config.status` 文件顶部初始化 shell 变量，变量值来自 *configure.ac* 和
    `configure`。重要的是要记住，所有实例化宏的调用与 `config.status` 共享一个公共命名空间。因此，你应该尽量谨慎选择 shell 变量名，以减少它们与彼此之间以及与
    Autoconf 生成的变量发生冲突的可能性。'
- en: The old adage about the value of a picture versus an explanation holds true
    here, so let’s try a little experiment. Create a test version of your *configure.ac*
    file that contains only the contents of [Listing 4-16](ch04.xhtml#ch04ex16). You
    should do this in a separate directory, as we’re not relying on any of the other
    files in the Jupiter project directory structure with this experiment.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 旧有的谚语“画面胜于千言万语”在这里同样适用，因此让我们做一个小实验。创建一个包含 [清单 4-16](ch04.xhtml#ch04ex16) 内容的
    *configure.ac* 文件的测试版本。你应该在一个单独的目录中执行此操作，因为在此实验中我们不依赖于 Jupiter 项目目录结构中的其他文件。
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 4-16: Experiment #1—a simple* configure.ac *file using `AC_CONFIG_COMMANDS`*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-16：实验 #1——使用 `AC_CONFIG_COMMANDS` 的简单* configure.ac *文件*'
- en: 'Now execute `autoreconf`, `./configure`, and `./config.status` in various ways
    to see what happens:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以不同的方式执行 `autoreconf`、`./configure` 和 `./config.status`，观察会发生什么：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see at ➊, executing `./configure` caused `config.status` to be executed
    with no command line options. There are no checks specified in *configure.ac*,
    so manually executing `./config.status`, as we did at ➋, has nearly the same effect.
    Querying `config.status` for help (as we did at ➌) indicates that `abc` is a valid
    tag; executing `./config.status` with that tag (as we did at ➍) on the command
    line simply runs the associated commands.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 ➊ 处看到的，执行 `./configure` 会导致 `config.status` 被执行且没有命令行选项。由于在 *configure.ac*
    中没有指定检查，所以像我们在 ➋ 处做的那样手动执行 `./config.status`，几乎会产生相同的效果。查询 `config.status` 获取帮助（如我们在
    ➌ 处所做的）表明 `abc` 是一个有效的标签；在命令行中执行带有该标签的 `./config.status`（如我们在 ➍ 处所做的）只是简单地运行关联的命令。
- en: 'In summary, the important points regarding the instantiating macros are as
    follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，关于实例化宏的关键点如下：
- en: The `config.status` script generates all files from templates.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.status` 脚本从模板生成所有文件。'
- en: The `configure` script performs all checks and then executes `./config.status`.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure` 脚本执行所有检查，然后执行 `./config.status`。'
- en: When you execute `./config.status` with no command line options, it generates
    files based on the last set of check results.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不带命令行选项执行 `./config.status` 时，它会根据最后一组检查结果生成文件。
- en: You can call `./config.status` to execute file generation or command sets specified
    by any of the tags given in any of the instantiating macro calls.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以调用 `./config.status` 来执行任何实例化宏调用中指定的文件生成或命令集。
- en: The `config.status` script may generate files not associated with any tags specified
    in *configure.ac*, in which case it will substitute variables based on the last
    set of checks performed.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.status` 脚本可能会生成与 *configure.ac* 中任何标签未关联的文件，在这种情况下，它将基于最后一组检查结果替换变量。'
- en: '*Generating Header Files from Templates*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从模板生成头文件*'
- en: As you’ve no doubt concluded by now, the `AC_CONFIG_HEADERS` macro allows you
    to specify one or more header files that `config.status` should generate from
    template files. The format of a configuration header template is very specific.
    A short example is given in [Listing 4-17](ch04.xhtml#ch04ex17).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在无疑已经得出结论，`AC_CONFIG_HEADERS` 宏允许你指定一个或多个头文件，让 `config.status` 从模板文件生成这些文件。配置头文件模板的格式非常具体。一个简短的示例见
    [列表 4-17](ch04.xhtml#ch04ex17)。
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 4-17: A short example of a header file template*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-17：一个简短的头文件模板示例*'
- en: You can place multiple statements like this in your header template, one per
    line. The comments are optional, of course. Let’s try another experiment. Create
    a new *configure.ac* file like that shown in [Listing 4-18](ch04.xhtml#ch04ex18).
    Again, you should do this in an isolated directory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在头文件模板中放置多条类似的语句，每行一条。当然，注释是可选的。让我们尝试另一个实验。创建一个新的 *configure.ac* 文件，如 [列表
    4-18](ch04.xhtml#ch04ex18) 中所示。同样，你应该在一个隔离的目录中执行此操作。
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 4-18: Experiment #2—a simple* configure.ac *file*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-18：实验 #2——一个简单的* configure.ac *文件*'
- en: Create a template header file called *config.h.in* that contains the two lines
    in [Listing 4-19](ch04.xhtml#ch04ex19).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *config.h.in* 的模板头文件，包含 [列表 4-19](ch04.xhtml#ch04ex19) 中的两行。
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 4-19: Experiment #2 continued—a simple* config.h.in *file*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-19：实验 #2 继续——一个简单的* config.h.in *文件*'
- en: 'Now execute the following commands:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下命令：
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see at ➌ that `config.status` generated a *config.h* file from the simple
    *config.h.in* template we wrote. The contents of this header file are based on
    the checks executed by `configure`. Since the shell code generated by `AC_CHECK_HEADERS([unistd.h
    foobar.h])` was able to locate a *unistd.h* header file (➊) in the system include
    directory, the corresponding `#undef` statement was converted into a `#define`
    statement. Of course, no *foobar.h* header was found in the system include directory,
    as you can also see by the output of `./configure` at ➋; therefore, its definition
    was left commented out in the template, as shown at ➍.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 ➌ 看到，`config.status` 从我们编写的简单 *config.h.in* 模板生成了一个 *config.h* 文件。这个头文件的内容基于
    `configure` 执行的检查。由于由 `AC_CHECK_HEADERS([unistd.h foobar.h])` 生成的 shell 代码能够在系统包含目录中找到
    *unistd.h* 头文件（➊），因此相应的 `#undef` 语句被转换成了 `#define` 语句。当然，如你所见，系统包含目录中没有找到 *foobar.h*
    头文件，正如在 ➋ 的 `./configure` 输出中所示；因此，它的定义被保留为注释，正如 ➍ 所示。
- en: Hence, you may add the sort of code shown in [Listing 4-20](ch04.xhtml#ch04ex20)
    to appropriate C-language source files in your project.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将 [列表 4-20](ch04.xhtml#ch04ex20) 中所示的代码添加到项目中适当的 C 语言源文件中。
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 4-20: Using generated CPP definitions in a C-language source file*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-20：在 C 语言源文件中使用生成的 CPP 定义*'
- en: '**NOTE**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The unistd.h header file is so standard these days that it’s not really necessary
    to check for it in *`AC_CONFIG_HEADERS`*, but it served here as a file that I
    was sure existed on my system for this example.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*如今，`unistd.h` 头文件已经如此标准，以至于在 *`AC_CONFIG_HEADERS`* 中检查它其实不是必需的，但在这个示例中，它作为我确信在我的系统上存在的文件出现。*'
- en: '*Using autoheader to Generate an Include File Template*'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用 autoheader 生成包含文件模板*'
- en: Manually maintaining a *config.h.in* template is more trouble than necessary.
    The format of *config.h.in* is very strict—for example, you can’t have any leading
    or trailing whitespace on the `#undef` lines, and the `#undef` lines you add must
    use `#undef` rather than `#define`, mainly because `config.status` only knows
    how to either replace `#undef` with `#define` or comment out lines containing
    `#undef`.^([19](footnote.xhtml#ch04fn19))
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 手动维护 *config.h.in* 模板比实际需要的麻烦。*config.h.in* 的格式非常严格——例如，`#undef` 行前后不能有空格，且你添加的
    `#undef` 行必须使用 `#undef` 而不是 `#define`，主要是因为 `config.status` 只知道如何将 `#undef` 替换为
    `#define`，或者注释掉包含 `#undef` 的行。^([19](footnote.xhtml#ch04fn19))
- en: 'Most of the information you need from *config.h.in* is available in *configure.ac*.
    Fortunately, `autoheader` will generate a properly formatted header file template
    for you based on the contents of *configure.ac*, so you don’t often need to write
    *config.h.in* templates. Let’s return to the command prompt for a final experiment.
    This one is easy—just delete your *config.h.in* template from experiment #2 and
    then run `autoheader` followed by `autoconf`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '你从 *config.h.in* 中需要的大部分信息在 *configure.ac* 中都可以找到。幸运的是，`autoheader` 会根据 *configure.ac*
    的内容为你生成一个格式正确的头文件模板，因此你通常不需要编写 *config.h.in* 模板。让我们回到命令提示符，进行一个最终实验。这个很简单——只需删除实验
    #2 中的 *config.h.in* 模板，然后运行 `autoheader`，接着是 `autoconf`：'
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**NOTE**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Again, I encourage you to use *`autoreconf`*, which will automatically run
    *`autoheader`* if it notices an expansion of *`AC_CONFIG_HEADERS`** in configure.ac.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*再次，我鼓励你使用 *`autoreconf`*，如果它注意到 *`AC_CONFIG_HEADERS`* 在 configure.ac 中扩展，它将自动运行
    *`autoheader`*。'
- en: As you can see by the output of the `cat` command at ➊, an entire set of preprocessor
    definitions was derived from *configure.ac* by `autoheader`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，➊ 处 `cat` 命令的输出显示，`autoheader` 从 *configure.ac* 中派生出了一整套预处理器定义。
- en: '[Listing 4-21](ch04.xhtml#ch04ex21) shows a much more realistic example of
    using a generated *config.h* file to increase the portability of your project
    source code. In this example, the `AC_CONFIG_HEADERS` macro invocation indicates
    that *config.h* should be generated, and the invocation of `AC_CHECK_HEADERS`
    will cause `autoheader` to insert a definition into *config.h*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-21](ch04.xhtml#ch04ex21) 展示了一个更实际的示例，说明如何使用生成的 *config.h* 文件来提高项目源代码的可移植性。在这个示例中，`AC_CONFIG_HEADERS`
    宏的调用表示应该生成 *config.h*，而 `AC_CHECK_HEADERS` 的调用会使 `autoheader` 在 *config.h* 中插入一个定义。'
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 4-21: A more realistic example of using `AC_CONFIG_HEADERS`*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-21：使用 `AC_CONFIG_HEADERS` 的一个更实际的示例*'
- en: The *config.h* file is intended to be included in your source code in locations
    where you might wish to test a configured option in the code itself using the
    C preprocessor. This file should be included first in source files so it can influence
    the inclusion of system header files later in the source.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*config.h* 文件的目的是在你希望使用 C 预处理器在代码中测试已配置的选项时包含它。这个文件应当首先包含在源文件中，以便它可以影响后续系统头文件的包含。'
- en: '**NOTE**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The config.h.in template that *`autoheader`* generates doesn’t contain an
    include-guard construct, so you need to be careful that it’s not included more
    than once in a source file. A good rule of thumb is to always include* config.h
    *as the very first header in every .c source file and never include it anywhere
    else. Following this rule will guarantee that it never needs an include guard.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*`autoheader`* 生成的 *config.h.in* 模板不包含包含保护结构，因此你需要小心确保它不会在源文件中被包含多次。一个好的经验法则是始终将
    *config.h* 作为每个 .c 源文件中第一个包含的头文件，并且不要在其他地方包含它。遵循这一规则将确保它永远不需要包含保护。'
- en: It’s often the case that every *.c* file in a project needs to include *config.h*.
    In this case, an interesting approach is to use the `gcc` `-include` option to
    include it at the top of every compiled source file from the compiler command
    line. This can be done within *configure.ac* by appending `-include config.h`
    to the `DEFS` variable (which is currently only used to define `HAVE_CONFIG_H`—if
    you’re more of a purist, you can use `CFLAGS` instead). Once done, you may assume
    *config.h* is part of every translation unit.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，通常每个 *.c* 文件都需要包含 *config.h*。在这种情况下，一个有趣的方法是使用 `gcc` 的 `-include` 选项，在编译器命令行中将其包含在每个编译的源文件顶部。这可以在
    *configure.ac* 中通过将 `-include config.h` 添加到 `DEFS` 变量中来实现（当前该变量仅用于定义 `HAVE_CONFIG_H`——如果你更喜欢简洁的方法，可以改用
    `CFLAGS`）。完成后，你可以假设 *config.h* 是每个翻译单元的一部分。
- en: 'Don’t make the mistake of including *config.h* in a public header file if your
    project installs libraries and header files as part of your product set. For more
    detailed information on this topic, refer to “Item 1: Keeping Private Details
    out of Public Interfaces” on [page 499](ch18.xhtml#page_499).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目将库和头文件作为产品的一部分进行安装，千万不要犯将 *config.h* 包含在公共头文件中的错误。有关此主题的更详细信息，请参见 [第 499
    页](ch18.xhtml#page_499) 的“项 1：将私有细节排除在公共接口之外”。
- en: Using the *configure.ac* file from [Listing 4-21](ch04.xhtml#ch04ex21), the
    generated `configure` script will create a *config.h* header file with appropriate
    definitions for determining, at compile time, whether or not the current system
    provides the `dlfcn` interface. To complete the portability check, you can add
    the code from [Listing 4-22](ch04.xhtml#ch04ex22) to a source file in your project
    that uses dynamic loader functionality.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例 4-21](ch04.xhtml#ch04ex21)中的*configure.ac*文件，生成的`configure`脚本将创建一个*config.h*头文件，并根据编译时的判断来确定当前系统是否提供`dlfcn`接口。为了完成可移植性检查，你可以将[示例
    4-22](ch04.xhtml#ch04ex22)中的代码添加到你的项目源文件中，来使用动态加载器功能。
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 4-22: A sample source file that checks for dynamic loader functionality*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-22：检查动态加载器功能的示例源文件*'
- en: If you already had code that included *dlfcn.h*, `autoscan` would have generated
    a line in *configure.ac* to call `AC_CHECK_HEADERS` with an argument list containing
    *dlfcn.h* as one of the header files to be checked. Your job as maintainer is
    to add the conditional statements at ➊ and ➋ to your source code around the existing
    inclusions of the *dlfcn.h* header file and around calls to the *dlfcn* interface
    functions. This is the crux of Autoconf portability support.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了包含*dlfcn.h*的代码，`autoscan`将会在*configure.ac*中生成一行，调用`AC_CHECK_HEADERS`，并在其参数列表中包含*dlfcn.h*，作为要检查的头文件之一。作为维护者，你的任务是在现有的*dlfcn.h*头文件的包含部分以及调用*dlfcn*接口函数的部分周围添加条件语句，标记为➊和➋。这是Autoconf可移植性支持的关键。
- en: '**NOTE**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You don’t technically need the preprocessor conditionals around the code if
    you choose to “error out” if the inclusion check fails, but doing so makes it
    obvious to the reader which portions of the source code are affected by the conditional
    inclusion.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你选择在包含检查失败时“报错”，技术上你不需要预处理器条件语句围绕代码，但这样做会使读者明显看到哪些部分的源代码受到了条件包含的影响。*'
- en: Your project might prefer dynamic loader functionality, but could get along
    without it if necessary. It’s also possible that your project requires a dynamic
    loader, in which case your build should terminate with an error (as this code
    does) if the key functionality is missing. Often, this is an acceptable stopgap
    until someone comes along and adds support to the source code for a more system-specific
    dynamic loader service.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目可能更倾向于使用动态加载器功能，但在必要时也能没有它。也有可能你的项目确实需要一个动态加载器，在这种情况下，如果缺少关键功能，构建应该终止并报错（如此代码所示）。通常，这是一个可接受的临时解决方案，直到有人来为源代码添加更系统特定的动态加载器服务支持。
- en: '**NOTE**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have to bail out with an error, it’s best to do so at configuration
    time rather than at compile time. The general rule of thumb is to bail out as
    early as possible.*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你必须在配置时就报错，最好在配置时而不是编译时处理。一般的做法是尽早退出。*'
- en: As mentioned earlier, `HAVE_CONFIG_H` is part of a string of definitions passed
    on the compiler command line in the Autoconf substitution variable `@DEFS@`. Before
    `autoheader` and `AC_CONFIG_HEADERS` functionality existed, Automake added all
    of the compiler configuration macros to the `@DEFS@` variable. You can still use
    this method if you don’t use `AC_CONFIG_HEADERS` in *configure.ac,* but it’s not
    recommended—mainly because a large number of definitions make for very long compiler
    command lines.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`HAVE_CONFIG_H`是一个由Autoconf替换变量`@DEFS@`传递给编译器命令行的一系列定义的一部分。在`autoheader`和`AC_CONFIG_HEADERS`功能出现之前，Automake将所有的编译器配置宏添加到`@DEFS@`变量中。如果你没有在*configure.ac*中使用`AC_CONFIG_HEADERS`，你仍然可以使用这种方法，但不推荐这样做——主要是因为大量的定义会导致编译器命令行非常长。
- en: Back to Remote Builds for a Moment
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到远程构建的话题
- en: As we wrap up this chapter, you’ll notice that we’ve come full circle. We started
    out covering some preliminary information before we discussed how to add remote
    builds to Jupiter. Now we’ll return to this topic for a moment, because I haven’t
    yet covered how to get the C preprocessor to properly locate a generated *config.h*
    file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这一章时，你会注意到我们已经走了一圈。我们一开始介绍了一些初步的信息，然后讨论了如何将远程构建添加到Jupiter中。现在我们将暂时回到这个话题，因为我还没有讲解如何让C预处理器正确地找到生成的*config.h*文件。
- en: Since this file is generated from a template, it will be at the same relative
    position in the build directory structure as its counterpart template file, *config.h.in*,
    is in the source directory structure. The template is located in the top-level
    *source* directory (unless you chose to put it elsewhere), so the generated file
    will be in the top-level *build* directory. Well, that’s easy enough—it’s always
    one level up from the generated *src/Makefile*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此文件是从模板生成的，因此它在构建目录结构中的相对位置将与其对应模板文件*config.h.in*在源代码目录结构中的位置相同。模板位于顶层*source*目录（除非你选择将其放在其他地方），因此生成的文件将位于顶层*build*目录。嗯，这很简单——它总是比生成的*src/Makefile*高一级。
- en: Before we draw any conclusions then about header file locations, let’s consider
    where header files might appear in a project. We might generate them in the current
    build directory, as part of the build process. We might also add internal header
    files to the current source directory. We know we have a *config.h* file in the
    top-level build directory. Finally, we might also create a top-level *include*
    directory for library interface header files our package provides. What is the
    order of priority for these various *include* directories?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对头文件位置做出任何结论之前，先考虑一下头文件可能出现在项目中的位置。我们可能会在当前的构建目录中生成它们，作为构建过程的一部分。我们也可能将内部头文件添加到当前的源代码目录中。我们知道在顶层构建目录中有一个*config.h*文件。最后，我们还可能为我们的包提供的库接口头文件创建一个顶层*include*目录。这些不同的*include*目录的优先级顺序是什么？
- en: The order in which we place *include directives* (`-I`*`path`* options) on the
    compiler command line is the order in which they will be searched, so the order
    should be based on which files are most relevant to the source file currently
    being compiled. Therefore, the compiler command line should include `-I`*`path`*
    directives for the current build directory (`.`) first, followed by the source
    directory [`$(srcdir)`], then the top-level build directory (`..`), and, finally,
    our project’s *include* directory, if it has one. We impose this ordering by adding
    `-I`*`path`* options to the compiler command line, as shown in [Listing 4-23](ch04.xhtml#ch04ex23).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编译器命令行中放置*include指令*（`-I`*`path`*选项）的顺序，就是它们被搜索的顺序，因此顺序应该基于与当前正在编译的源文件最相关的文件。因此，编译器命令行应首先包含当前构建目录（`.`）的`-I`*`path`*指令，然后是源代码目录[`$(srcdir)`]，接着是顶层构建目录（`..`），最后是我们的项目的*include*目录（如果有的话）。我们通过在编译器命令行中添加`-I`*`path`*选项来强制执行此顺序，如[清单4-23](ch04.xhtml#ch04ex23)所示。
- en: Git tag 4.7
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签4.7
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 4-23:* src/Makefile.in: *Adding proper compiler include directives*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单4-23：* src/Makefile.in: *添加正确的编译器包含指令*'
- en: 'Now that we know this, we need to add another rule of thumb for remote builds
    to the list we created on [page 92](ch04.xhtml#page_92):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这一点，我们需要向我们在[第92页](ch04.xhtml#page_92)上创建的列表中添加另一个远程构建的经验法则：
- en: Add preprocessor commands for the current build directory, the associated source
    directory, and the top-level build directory (or other build directory if *config.h.in*
    is located elsewhere), in that order.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照顺序添加当前构建目录、相关源代码目录和顶层构建目录（或者如果*config.h.in*位于其他地方，则是其他构建目录）的预处理器命令。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered just about all the major features of a fully functional
    GNU project build system, including writing a *configure.ac* file, from which
    Autoconf generates a fully functional `configure` script. We’ve also covered adding
    remote build functionality to makefiles with `VPATH` statements.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一个完全功能的GNU项目构建系统几乎所有主要特性，包括编写*configure.ac*文件，Autoconf从中生成一个完全功能的`configure`脚本。我们还涵盖了如何通过`VPATH`语句向makefile添加远程构建功能。
- en: So what else is there? Plenty! In the next chapter, I’ll continue to show you
    how you can use Autoconf to test system features and functionality before your
    users run `make`. We’ll also continue enhancing the configuration script so that
    when we’re done, users will have more options and understand exactly how our package
    will be built on their systems.*
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 那还有什么呢？当然有！在下一章，我将继续向你展示如何使用Autoconf在用户运行`make`之前测试系统特性和功能。我们还将继续增强配置脚本，以便当我们完成时，用户将有更多选项，并且完全理解我们的包将如何在他们的系统上构建。
