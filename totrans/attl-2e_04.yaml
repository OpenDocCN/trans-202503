- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONFIGURING YOUR PROJECT WITH AUTOCONF
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*Come my friends, ’Tis not too late to seek a newer world.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: —Alfred, Lord Tennyson, “Ulysses”*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: The Autoconf project has had a long history, starting in 1992 when David McKenzie,
    while volunteering for the Free Software Foundation, was looking for a way to
    simplify the process of creating the complex configuration scripts necessary to
    support the target platforms that were being added daily at that time to the GNU
    project. At the same time, he was working on his bachelor’s degree in computer
    science at the University of Maryland, College Park.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: After McKenzie’s initial work on Autoconf, he continued to be a strong contributor
    to the project through 1996, at which point Ben Elliston took over project maintenance.
    Since then, maintainers and primary contributors have included Akim Demaille,
    Jim Meyering, Alexandre Oliva, Tom Tromey, Lars J. Aas (inventor of the name *autom4te*,
    among others), Mo DeJong, Steven G. Johnson, Matthew D. Langston, Paval Roskin,
    and Paul Eggert (the list of contributors is much longer—see the Autoconf *AUTHORS*
    file for more history).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Today’s maintainer, Eric Blake, began making strong contributions to Autoconf
    in 2012\. He’s been maintainer of the project ever since while working for Red
    Hat. Because Automake and Libtool are essentially add-on components to the original
    Autoconf framework, it’s useful to spend some time focusing on using Autoconf
    without Automake and Libtool. This will provide a fair amount of insight into
    how Autoconf operates by exposing aspects of the tool that are often hidden by
    Automake.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Before Automake came along, Autoconf was used alone. In fact, many legacy open
    source projects never made the transition from Autoconf to the full GNU Autotools
    suite. As a result, it’s not unusual to find a file called *configure.in* (the
    original Autoconf naming convention), as well as handwritten *Makefile.in* templates,
    in older open source projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll show you how to add an Autoconf build system to an existing
    project. I’ll spend most of this chapter talking about the more basic features
    of Autoconf, and in [Chapter 5](ch05.xhtml) I’ll go into much more detail about
    how some of the more complex Autoconf macros work and how to properly use them.
    Throughout this process, we’ll continue using the Jupiter project as our example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf Configuration Scripts
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The input to the `autoconf` program is Bourne shell script sprinkled with macro
    calls. The input data stream must also include the definitions of all referenced
    macros—both those that Autoconf provides and those that you write yourself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The macro language used in Autoconf is called *M4*. (The name means *M, plus
    4 more letters*, or the word *Macro*.^([1](footnote.xhtml#ch04fn1))) The `m4`
    utility is a general-purpose macro language processor originally written by Brian
    Kernighan and Dennis Ritchie in 1977.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: While you may not be familiar with it, you can find some form of M4 on every
    Unix and Linux variant (as well as other systems) in use today. The ubiquitous
    nature of this tool is the main reason it’s used by Autoconf, as the original
    design goals of Autoconf stated that it should be able to run on all systems without
    the addition of complex tool chains and utility sets.^([2](footnote.xhtml#ch04fn2))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不熟悉它，但你可以在今天使用的每个Unix和Linux变体（以及其他系统）中找到某种形式的M4。这个工具的普及性是Autoconf使用它的主要原因，因为Autoconf的原始设计目标就是能够在所有系统上运行，而不需要添加复杂的工具链和实用程序集。^([2](footnote.xhtml#ch04fn2))
- en: 'Autoconf depends on the existence of relatively few tools: a Bourne shell,
    M4, and a Perl interpreter. The configuration scripts and makefiles it generates
    rely on the existence of a different set of tools, including a Bourne shell, `grep`,
    `ls`, and `sed` or `awk`.^([3](footnote.xhtml#ch04fn3))'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf依赖于相对较少的工具：Bourne shell、M4和Perl解释器。它生成的配置脚本和Makefile依赖于一组不同的工具，包括Bourne
    shell、`grep`、`ls`以及`sed`或`awk`。^([3](footnote.xhtml#ch04fn3))
- en: '**NOTE**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do not confuse the requirements of the Autotools with the requirements of
    the scripts and makefiles they generate. The Autotools are maintainer tools, whereas
    the resulting scripts and makefiles are end user tools. We can reasonably expect
    a higher level of installed functionality on development systems than we can on
    end user systems.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将Autotools的要求与它们生成的脚本和Makefile的要求混淆。Autotools是维护工具，而生成的脚本和Makefile是最终用户工具。我们可以合理地预期开发系统中安装的功能比最终用户系统中更多。*'
- en: The configuration script ensures that the end user’s build environment is configured
    to properly build your project. This script checks for installed tools, utilities,
    libraries, and header files, as well as for specific functionality within these
    resources. What distinguishes Autoconf from other project configuration frameworks
    is that Autoconf tests also ensure that these resources can be properly consumed
    by your project. You see, it’s important not only that your users have *libxyz.so*
    and its public header files properly installed on their systems but also that
    they have compatible versions of these files. Autoconf is pathological about such
    tests. It ensures that the end user’s environment is in compliance with the project
    requirements by compiling and linking a small test program for each feature—a
    quintessential example, if you will, that does what your project source code does
    on a larger scale.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 配置脚本确保最终用户的构建环境已正确配置，以构建你的项目。该脚本检查已安装的工具、实用程序、库和头文件，以及这些资源中的特定功能。Autoconf与其他项目配置框架的不同之处在于，Autoconf的测试还确保这些资源能够被你的项目正确使用。你看，不仅仅是你的用户在他们的系统上正确安装了*libxyz.so*及其公共头文件，更重要的是，他们的文件版本是否兼容。Autoconf在这类测试上非常严格。它通过为每个功能编译和链接一个小的测试程序，确保最终用户的环境符合项目要求——如果你愿意，它就像是一个示范例子，做的事情与项目源代码在更大范围内所做的相同。
- en: '*Can’t I just ensure that* libxyz.2.1.0.so *is installed by searching library
    paths for the filename?* The answer to this question is debatable. There are legitimate
    situations where libraries and tools get updated quietly. Sometimes, the specific
    functionality upon which your project relies is added in the form of a security
    bug fix or enhancement to a library, in which case vendors aren’t even required
    to bump up the version number. But it’s often difficult to tell whether you’ve
    got version 2.1.0.r1 or version 2.1.0.r2 unless you look at the file size or call
    a library function to make sure it works as expected.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*难道我不能仅仅通过在库路径中搜索文件名来确保* libxyz.2.1.0.so *已安装吗？* 这个问题的答案是有争议的。在一些合法的情况下，库和工具会悄无声息地更新。有时，项目所依赖的特定功能是以安全错误修复或库功能增强的形式添加的，在这种情况下，供应商甚至不需要更新版本号。但通常很难判断你拥有的是版本2.1.0.r1还是版本2.1.0.r2，除非你查看文件大小或调用库函数来确保它按预期工作。'
- en: Additionally, vendors often backport bug fixes and features from newer products
    onto older platforms without bumping the version number. Hence, you can’t tell
    even by looking at the version number whether the library supports a feature that
    was added *after* that version of the library was published.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，供应商经常会将新产品中的错误修复和功能回移到旧平台，而不更新版本号。因此，仅通过查看版本号，你无法判断库是否支持在该版本库发布后*新增*的功能。
- en: However, the most significant reason for not relying on library version numbers
    is that they do not represent specific marketing releases of a library. As we
    will discuss in [Chapter 8](ch08.xhtml), library version numbers indicate binary
    interface characteristics on a particular platform. This means that library version
    numbers for the same feature set can be different from platform to platform. As
    a result, you may not be able to tell—short of compiling and linking against the
    library—whether or not a particular library has the functionality your project
    needs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不依赖库版本号的最重要原因是，它们并不代表库的特定营销版本。如我们在[第8章](ch08.xhtml)中将讨论的，库版本号表示的是特定平台上的二进制接口特性。这意味着，同一功能集的库版本号可能在不同平台之间有所不同。因此，除非进行编译和链接到该库，否则你可能无法判断某个库是否具备你的项目所需的功能。
- en: Finally, there are several important cases where the same functionality is provided
    by entirely different libraries on different systems. For example, you may find
    cursor manipulation functionality in *libtermcap* on one system, *libncurses*
    on another, and *libcurses* on yet another system. But it’s not critical that
    you know about all of these side cases, because your users will tell you when
    your project won’t build on their system because of such a discrepancy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有几个重要情况是，在不同的系统上，完全不同的库提供相同的功能。例如，你可能在一个系统中找到 *libtermcap* 提供光标操作功能，在另一个系统中找到
    *libncurses*，而在另一个系统中找到 *libcurses*。但你不需要知道所有这些边缘情况，因为当你的项目在用户的系统上由于这些差异而无法构建时，用户会告诉你。
- en: What can you do when such a bug is reported? You can use the Autoconf `AC_SEARCH_LIBS`
    macro to test multiple libraries for the same functionality. Simply add a library
    to the search list, and you’re done. Since this fix is so easy, it’s likely the
    user who noticed the problem will simply send a patch to your *configure.ac* file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当报告此类 bug 时，你该怎么办？你可以使用 Autoconf 的 `AC_SEARCH_LIBS` 宏来测试多个库是否具备相同的功能。只需将一个库添加到搜索列表中，完成即可。由于这个修复非常简单，发现问题的用户很可能会直接发送一个补丁到你的
    *configure.ac* 文件。
- en: Because Autoconf tests are written in shell script, you have a lot of flexibility
    as to how the tests operate. You can write a test that merely checks for the existence
    of a library or utility in the usual locations on your user’s system, but this
    bypasses some of the most significant features of Autoconf. Fortunately, Autoconf
    provides dozens of macros that conform to Autoconf’s feature-testing philosophy.
    You should carefully study and use the list of available macros, rather than write
    your own, because they’re specifically designed to ensure that the desired functionality
    is available on the widest variety of systems and platforms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Autoconf 测试是用 shell 脚本编写的，你在测试操作的方式上有很大的灵活性。你可以编写一个仅检查用户系统中常见位置是否存在某个库或工具的测试，但这绕过了
    Autoconf 的一些重要特性。幸运的是，Autoconf 提供了数十个符合其特性测试哲学的宏。你应当仔细研究并使用可用宏的列表，而不是编写自己的宏，因为它们专门设计来确保所需功能在尽可能多的系统和平台上可用。
- en: The Shortest configure.ac File
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最简洁的 `configure.ac` 文件
- en: The input file for `autoconf` is called *configure.ac*. The simplest possible
    *configure.ac* file has just two lines, as shown in [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoconf` 的输入文件叫做 *configure.ac*。最简单的 *configure.ac* 文件只有两行，如[清单 4-1](ch04.xhtml#ch04ex01)所示。'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 4-1: The simplest configure.ac file*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-1：最简单的 configure.ac 文件*'
- en: To those new to Autoconf, these two lines appear to be a couple of function
    calls, perhaps in the syntax of some obscure programming language. Don’t let their
    appearance throw you—these are M4 macro invocations. The macros are defined in
    files distributed with the autoconf package. You can find the definition of `AC_INIT`,
    for example, in *general.m4* in Autoconf’s installation directory (usually */usr/(local/)share/autoconf/autoconf*).
    `AC_OUTPUT` is defined in *status.m4* in the same directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新接触 Autoconf 的人来说，这两行看起来像是几个函数调用，可能是某种晦涩的编程语言的语法。不要让它们的外观把你吓到——这些是 M4 宏调用。这些宏定义在与
    autoconf 软件包一起分发的文件中。例如，你可以在 Autoconf 的安装目录中的 *general.m4* 文件中找到 `AC_INIT` 的定义（通常是
    */usr/(local/)share/autoconf/autoconf*）。`AC_OUTPUT` 的定义在同一目录下的 *status.m4* 中。
- en: Comparing M4 to the C Preprocessor
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 M4 与 C 预处理器进行比较
- en: 'M4 macros are similar in many ways to the C-preprocessor (CPP) macros defined
    in C-language source files. The C preprocessor is also a text replacement tool,
    which isn’t surprising: both M4 and the C preprocessor were designed and written
    by Kernighan and Ritchie around the same time.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf uses square brackets around macro parameters as a quoting mechanism.
    Quotes are necessary only for cases in which the context of the macro call could
    cause an ambiguity that the macro processor may resolve incorrectly (usually without
    telling you). We’ll discuss M4 quoting in much more detail in [Chapter 16](ch16.xhtml).
    For now, just use square brackets around every argument to ensure that the expected
    macro expansions are generated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'As with CPP macros, you can define M4 macros to accept a comma-delimited list
    of arguments enclosed in parentheses. With CPP, macros are defined using a *preprocessor
    directive*: `#define` *`name`*`(`*`args`*`)` *`expansion`*, while in M4, macros
    are defined with a built-in macro: `define(`*`name`*`,` *`expansion`*`)`. Another
    significant difference is that in CPP, the arguments specified in the macro definition
    are required,^([4](footnote.xhtml#ch04fn4)) while in M4, the arguments to parameterized
    macros are optional and the caller may simply omit them. If no arguments are passed,
    you can also omit the parentheses. Extra arguments passed to M4 macros are simply
    ignored. Finally, M4 does not allow intervening whitespace between a macro name
    and the opening parenthesis in a macro invocation.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The Nature of M4 Macros
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve been programming in C for many years, you’ve no doubt run across a
    few C-preprocessor macros from the dark regions of the lower realm. I’m talking
    about those truly evil macros that expand into one or two pages of C code. They
    should have been written as C functions, but their authors were either overly
    worried about performance or just got carried away, and now it’s your turn to
    debug and maintain them. But, as any veteran C programmer will tell you, the slight
    performance gains you get by using a macro where you should have used a function
    do not justify the trouble you cause maintainers trying to debug your fancy macros.
    Debugging such macros can be a nightmare because the source code generated by
    macros is usually inaccessible from within a symbolic debugger.^([5](footnote.xhtml#ch04fn5))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing such complex macros is viewed by M4 programmers as a sort of macro
    nirvana—the more complex and functional they are, the “cooler” they are. The two
    Autoconf macros in [Listing 4-1](ch04.xhtml#ch04ex01) expand into a file containing
    almost 2,400 lines of Bourne-shell script that total more than 70KB! But you wouldn’t
    guess this by looking at their definitions. They’re both fairly short—only a few
    dozen lines each. The reason for this apparent disparity is simple: they’re written
    in a modular fashion, with each macro expanding several others, which in turn
    expand several others, and so on.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: For the same reasons that programmers are taught not to abuse the C preprocessor,
    the extensive use of M4 causes a fair amount of frustration for those trying to
    understand Autoconf. That’s not to say Autoconf shouldn’t use M4 this way; quite
    the contrary—this is the domain of M4\. But there is a school of thought that
    says M4 was a poor choice for Autoconf because of the problems with macros mentioned
    earlier. Fortunately, being able to use Autoconf effectively usually doesn’t require
    a deep understanding of the inner workings of the macros that ship with it.^([6](footnote.xhtml#ch04fn6))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Executing autoconf
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running Autoconf is simple: just execute `autoconf` in the same directory as
    your *configure.ac* file. While I could do this for each example in this chapter,
    I’m going to use the `autoreconf` program instead of the `autoconf` program, because
    running `autoreconf` has exactly the same effect as running `autoconf`, except
    that `autoreconf` will also do the right thing when you start adding Automake
    and Libtool functionality to your build system. That is, it will execute all of
    the Autotools in the right order based on the contents of your *configure.ac*
    file.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `autoreconf` program is smart enough to execute only the tools you need,
    in the order you need them, with the options you want (with one caveat that I’ll
    mention shortly). Therefore, running `autoreconf` is the recommended method for
    executing the Autotools tool chain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the simple *configure.ac* file from [Listing 4-1](ch04.xhtml#ch04ex01)
    to our project directory. The top-level directory currently contains only a *Makefile*
    and a *src* directory that contains its own *Makefile* and a *main.c* file. Once
    you’ve added *configure.ac* to the top-level directory, run `autoreconf`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 4.0
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, notice that `autoreconf` operates silently by default. If you want to
    see something happening, use the `-v` or `--verbose` option. If you want `autoreconf`
    to execute the Autotools in verbose mode as well, then add `-vv` to the command
    line.^([7](footnote.xhtml#ch04fn7))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Next, notice that `autoconf` creates a directory called *autom4te.cache*. This
    is the `autom4te` cache directory. This cache speeds up access to *configure.ac*
    during successive executions of utilities in the Autotools tool chain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The result of passing *configure.ac* through `autoconf` is essentially the same
    file (now called `configure`), but with all of the macros fully expanded. You’re
    welcome to take a look at `configure`, but don’t be too surprised if you don’t
    immediately understand what you see. The *configure.ac* file has been transformed,
    through M4 macro expansions, into a text file containing thousands of lines of
    complex Bourne shell script.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Executing configure
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As discussed in “Configuring Your Package” on [page 77](ch03.xhtml#page_77),
    the *GNU Coding Standards* indicate that a handwritten `configure` script should
    generate another script called `config.status`, whose job it is to generate files
    from templates. Unsurprisingly, this is exactly the sort of functionality you’ll
    find in an Autoconf-generated configuration script. This script has two primary
    tasks:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Perform requested checks
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate and then call `config.status`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The results of the checks performed by `configure` are written into `config``.status`
    in a manner that allows them to be used as replacement text for Autoconf substitution
    variables in template files (*Makefile.in*, *config.h.in*, and so on). When you
    execute `./configure`, it tells you that it’s creating `config.status`. It also
    creates a log file called *config.log* that has several important attributes.
    Let’s run `./configure` and then see what’s new in our project directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We see that `configure` has indeed generated both `config.status` and *config.log**.
    The *config.log* file contains the following information:*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**   The command line that was used to invoke `configure` (very handy!)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Information about the platform on which `configure` was executed
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information about the core tests `configure` executed
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line number in `configure` at which `config.status` is generated and then
    called
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point in the log file, `config.status` takes over generating log information
    and adds the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The command line used to invoke `config.status`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After `config.status` generates all the files from their templates, it exits,
    returning control to `configure`, which then appends the following information
    to the log:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The cache variables that `config.status` used to perform its tasks
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of output variables that may be replaced in templates
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exit code `configure` returned to the shell
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information is invaluable when you’re debugging a `configure` script and
    its associated *configure.ac* file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Why doesn’t `configure` just execute the code it writes into `config.status`
    instead of going to all the trouble of generating a second script, only to immediately
    call it? There are a few good reasons. First, the operations of performing checks
    and generating files are conceptually different, and the `make` utility works
    best when conceptually different operations are associated with separate targets.
    A second reason is that you can execute `config.status` separately to regenerate
    output files from their corresponding template files, saving the time required
    to perform those lengthy checks. Finally, `config.status` is written to remember
    the parameters originally used on the `configure` command line. Thus, when `make`
    detects that it needs to update the build system, it can call `config.status`
    to re-execute `configure`, using the command line options that were originally
    specified.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Executing config.status
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how `configure` works, you might be tempted to execute `config.status`
    yourself. This was exactly the intent of the Autoconf designers and the authors
    of the *GCS*, who originally conceived these design goals. However, a more important
    reason for separating checks from template processing is that `make` rules can
    use `config.status` to regenerate makefiles from their templates when `make` determines
    that a template is newer than its corresponding makefile.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Rather than call `configure` to perform needless checks (your environment hasn’t
    changed—just your template files), makefile rules should be written to indicate
    that output files depend on their templates. The commands for these rules run
    `config.status`, passing the rule’s target as a parameter. If, for example, you
    modify one of your *Makefile.in* templates, `make` calls `config.status` to regenerate
    the corresponding *Makefile*, after which `make` re-executes its own original
    command line—basically restarting itself.^([8](footnote.xhtml#ch04fn8))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-2](ch04.xhtml#ch04ex02) shows the relevant portion of such a *Makefile.in*
    template, containing the rules needed to regenerate the corresponding *Makefile*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 4-2: A rule that causes `make` to regenerate* Makefile *if its template
    has changed*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: A rule with a target named `Makefile` is the trigger here. This rule allows
    `make` to regenerate the source makefile from its template if the template changes.
    It does this *before* executing either the user’s specified targets or the default
    target, if no specific target was given. This functionality is built into `make`—if
    there’s a rule whose target is `Makefile`, `make` always evaluates that rule first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The rule in [Listing 4-2](ch04.xhtml#ch04ex02) indicates that *Makefile* is
    dependent on `config``.status` as well as *Makefile.in*, because if `configure`
    updates `config.status`, it may generate *Makefile* differently. Perhaps different
    command line options were provided so that `configure` can now find libraries
    and header files it couldn’t find previously. In this case, Autoconf substitution
    variables may have different values. Thus, *Makefile* should be regenerated if
    either *Makefile.in* or `config .status` is updated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Since `config.status` is itself a generated file, it stands to reason that you
    could write such a rule to regenerate this file when needed. Expanding on the
    previous example, [Listing 4-3](ch04.xhtml#ch04ex03) adds the required code to
    rebuild `config.status` if `configure` changes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4-3: A rule to rebuild `config.status` when `configure` changes*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Since `config.status` is a dependency of the `Makefile` target, `make` will
    look for a rule whose target is `config.status` and run its commands if needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Adding Some Real Functionality
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve suggested before that you should call `config.status` in your makefiles
    to generate those makefiles from templates. [Listing 4-4](ch04.xhtml#ch04ex04)
    shows the code in *configure.ac* that actually makes this happen. It’s just a
    single additional macro call between the two original lines of [Listing 4-1](ch04.xhtml#ch04ex01).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经建议过，您应该在 makefiles 中调用 `config.status` 来从模板生成这些 makefiles。[清单 4-4](ch04.xhtml#ch04ex04)
    显示了实际执行此操作的 *configure.ac* 中的代码。这只是 [清单 4-1](ch04.xhtml#ch04ex01) 中两个原始行之间的一个额外宏调用。
- en: Git tag 4.1
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.1
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 4-4:* configure.ac: *Using the `AC_CONFIG_FILES` macro*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-4:* configure.ac: *使用 `AC_CONFIG_FILES` 宏*'
- en: 'This code assumes that templates exist for *Makefile* and *src/Makefile*, called
    *Makefile.in* and *src/Makefile.in*, respectively. These template files look exactly
    like their *Makefile* counterparts, with one exception: any text I want Autoconf
    to replace is marked as an Autoconf substitution variable, using the `@`*`VARIABLE`*`@`
    syntax.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码假设存在 *Makefile* 和 *src/Makefile* 的模板，分别称为 *Makefile.in* 和 *src/Makefile.in*。这些模板文件看起来与其
    *Makefile* 对应文件完全相同，唯一的例外是：任何我希望 Autoconf 替换的文本，都标记为 Autoconf 替代变量，使用 `@`*`VARIABLE`*`@`
    语法。
- en: 'To create these files, simply rename the existing *Makefile* files to *Makefile.in*
    in both the top-level and *src* directories. This is a common practice when *autoconfiscating*
    a project:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这些文件，只需将现有的 *Makefile* 文件在顶层和 *src* 目录中重命名为 *Makefile.in*。这是将项目 *autoconfiscate*
    的常见做法：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these changes in place, we are now effectively using our new *configure.ac*
    file in Jupiter to generate makefiles. To make it useful, let’s add a few Autoconf
    substitution variables to replace the original default values. At the top of these
    files, I’ve also added the Autoconf substitution variable, `@configure_input@`,
    after a comment hash mark. [Listing 4-5](ch04.xhtml#ch04ex05) shows the comment
    text that is generated in *Makefile*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改后，我们现在已经有效地在 Jupiter 中使用新的 *configure.ac* 文件来生成 makefiles。为了让它更有用，我们可以添加一些
    Autoconf 替代变量来替换原始的默认值。在这些文件的顶部，我还添加了 Autoconf 替代变量 `@configure_input@`，并在注释符号后面添加。
    [清单 4-5](ch04.xhtml#ch04ex05) 显示了在 *Makefile* 中生成的注释文本。
- en: Git tag 4.2
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 4.2
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4-5:* Makefile: *The text generated from the Autoconf `@configure_input@`
    variable*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5:* Makefile: *从 Autoconf `@configure_input@` 变量生成的文本*'
- en: I’ve also added the makefile regeneration rules from the previous examples to
    each of these templates, with slight path differences in each file to account
    for their different positions relative to `config.status` and `configure` in the
    build directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我还将之前示例中的 makefile 重新生成规则添加到了每个模板中，每个文件中略有不同的路径差异，以考虑到它们相对于构建目录中的 `config.status`
    和 `configure` 的不同位置。
- en: '[Listings 4-6](ch04.xhtml#ch04ex06) and [4-7](ch04.xhtml#ch04ex07) highlight
    the required changes to the final recursive versions of *Makefile* and *src/Makefile*
    from near the end of [Chapter 3](ch03.xhtml). We’ll consider writing nonrecursive
    versions of these files later as we cover Automake—the process when using Autoconf
    with handwritten *Makefile.in* templates is nearly identical to what we did in
    [Chapter 3](ch03.xhtml) with makefiles.^([9](footnote.xhtml#ch04fn9))'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6](ch04.xhtml#ch04ex06) 和 [4-7](ch04.xhtml#ch04ex07) 突出了从 [第 3 章](ch03.xhtml)
    末尾部分到最终递归版本的 *Makefile* 和 *src/Makefile* 所需的更改。稍后我们将在讲解 Automake 时考虑编写这些文件的非递归版本——使用
    Autoconf 和手写的 *Makefile.in* 模板的过程几乎与我们在 [第 3 章](ch03.xhtml) 中使用 makefiles 所做的完全相同。^([9](footnote.xhtml#ch04fn9))'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 4-6:* Makefile.in: *Required modifications to Makefile from [Chapter
    3](ch03.xhtml)*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-6:* Makefile.in: *来自 [第 3 章](ch03.xhtml) 的 Makefile 所需修改*'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-7:* src/Makefile.in: *Required modifications to src/Makefile from
    [Chapter 3](ch03.xhtml)*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-7:* src/Makefile.in: *来自 [第 3 章](ch03.xhtml) 的 src/Makefile 所需修改*'
- en: I’ve removed the `export` statements from the top-level *Makefile.in* and added
    a copy of all the `make` variables (originally only in the top-level *Makefile*)
    into *src/Makefile.in*. Since `config.status` generates both of these files, I
    can reap excellent benefits by substituting values for these variables directly
    into both files. The primary advantage of doing this is that I can now run `make`
    in any subdirectory without worrying about uninitialized variables that would
    originally have been passed down by a higher-level makefile.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经从顶层的 *Makefile.in* 中移除了 `export` 语句，并将所有的 `make` 变量（最初只在顶层 *Makefile* 中）复制到了
    *src/Makefile.in* 中。由于 `config.status` 会生成这两个文件，因此我可以通过直接将这些变量的值替换到这两个文件中，从中获得显著的好处。这样做的主要优势是，我现在可以在任何子目录中运行
    `make`，而无需担心那些原本由更高级别的 makefile 传递的未初始化变量。
- en: Since Autoconf generates entire values for these `make` variables, you may be
    tempted to clean things up a bit by removing the variables and just substituting
    `@prefix@` where we currently use `$(prefix)` throughout the files. There are
    a few good reasons for keeping the `make` variables. First and foremost, we’ll
    retain the original benefits of the `make` variables; our end users can continue
    to substitute their own values on the `make` command line. (Even though Autoconf
    places default values in these variables, users may wish to override them.) Second,
    for variables such as `$(distdir)`, whose values are composed of multiple variable
    references, it’s simply cleaner to build the name in one place and use it everywhere
    else through a single variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: I’ve also changed the commands in the distribution targets a bit. Rather than
    distribute the makefiles, I now need to distribute the *Makefile.in* templates,
    as well as the new `configure` script and the *configure.ac* file.^([10](footnote.xhtml#ch04fn10))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I modified the `distcheck` target’s commands to run the `configure`
    script before running `make`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Generating Files from Templates
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you can use `AC_CONFIG_FILES` to generate *any* text file from a file
    of the same name with a *.in* extension, found in the same directory. The *.in*
    extension is the default template-naming pattern for `AC_CONFIG_FILES`, but you
    can override this default behavior. I’ll get into the details shortly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf generates `sed` or `awk` expressions into the resulting `configure`
    script, which then copies them into `config.status`. The `config.status` script
    uses these expressions to perform string replacement in the input template files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Both `sed` and `awk` are text-processing tools that operate on file streams.
    The advantage of a stream editor (the name *sed* is a contraction of the phrase
    *stream editor*) is that it replaces text patterns in a byte stream. Thus, both
    `sed` and `awk` can operate on huge files because they don’t need to load the
    entire input file into memory in order to process it. Autoconf builds the expression
    list that `config.status` passes to `sed` or `awk` from a list of variables defined
    by various macros, many of which I’ll cover in greater detail later in this chapter.
    It’s important to understand that Autoconf substitution variables are the *only*
    items replaced in a template file while generating output files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: At this point, with very little effort, I’ve created a basic *configure.ac*
    file. I can now execute `autoreconf`, followed by `./configure` and then `make`,
    in order to build the Jupiter project. This simple, three-line *configure.ac*
    file generates a `configure` script that is fully functional, according to the
    definition of a proper configuration script as specified by the *GCS*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The resulting configuration script runs various system checks and generates
    a `config.status` script that can replace a fair number of substitution variables
    in a set of specified template files in this build system. That’s a lot of functionality
    in just three lines of code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Adding VPATH Build Functionality
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the end of [Chapter 3](ch03.xhtml), I mentioned that I hadn’t yet covered
    an important concept—that of vpath builds. A *vpath build* is a way of using a
    `make` construct (`VPATH`) to `configure` and build a project in a directory other
    than the source directory. This is important if you need to perform any of the
    following tasks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Maintain a separate debug configuration
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test different configurations side by side
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a clean source directory for patch diffs after local modifications
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build from a read-only source directory
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VPATH` keyword is short for *virtual search path*. A `VPATH` statement
    contains a colon-separated list of places to look for relative-path dependencies
    when they can’t be found relative to the current directory. In other words, when
    `make` can’t find a prerequisite file relative to the current directory, it searches
    for that file successively in each of the paths in the `VPATH` statement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Adding remote build functionality to an existing makefile using `VPATH` is very
    simple. [Listing 4-8](ch04.xhtml#ch04ex08) shows an example of using a `VPATH`
    statement in a makefile.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-8: An example of using `VPATH` in a makefile*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: In this (contrived) example, if `make` can’t find *src/main.c* in the current
    directory while processing the rule, it will look for *some/path/src/main.c*,
    and then for *some/other/path/src/main.c*, and finally for *yet/another/path/src/main.c*
    before giving up with an error message about not knowing how to make *src/main.c*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: With just a few simple modifications, we can completely support remote builds
    in Jupiter. [Listings 4-9](ch04.xhtml#ch04ex09) and [4-10](ch04.xhtml#ch04ex10)
    illustrate the necessary changes to the project’s two makefiles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 4.3
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-9:* Makefile.in: *Adding VPATH build capabilities to the top-level
    makefile*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-10:* src/Makefile.in: *Adding `VPATH` build capabilities to the
    lower-level makefile*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. Really. When `config.status` generates a file, it replaces an Autoconf
    substitution variable called `@srcdir@` with the relative path to the template’s
    source directory. The value substituted for `@srcdir@` in a given *Makefile* within
    the build directory structure is the relative path to the directory containing
    the corresponding *Makefile.in* template in the source directory structure. The
    concept here is that for each *Makefile* in the remote build directory, `VPATH`
    provides a relative path to the directory containing the source code for that
    build directory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not expect *`VPATH`* to work in commands. *`VPATH`* only allows *`make`*
    to find dependencies; therefore, you can only expect *`VPATH`* to take effect
    in target and dependency lists within rules. You may use *`$(srcdir)/`* as a prefix
    for file system objects in commands, as I’ve done in [Listing 4-10](ch04.xhtml#ch04ex10)
    in the command for the *`jupiter`* target rule.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes required for supporting remote builds in your build system are
    summarized as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Set a `make` variable, `srcdir`, to the `@srcdir@` substitution variable.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the `VPATH` variable to `@srcdir@`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefix all file dependencies used *in commands* with `$(srcdir)/`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t use *`$(srcdir)`* in the *`VPATH`* statement itself, because some older
    versions of *`make`* won’t substitute variable references within the *`VPATH`*
    statement.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If the source directory is the same as the build directory, the `@srcdir@` substitution
    variable degenerates to a dot (*.*). That means all of these `$(srcdir)`*/* prefixes
    simply degenerate to *./*, which is harmless.^([11](footnote.xhtml#ch04fn11))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick example is the easiest way to show you how this works. Now that Jupiter
    is fully functional with respect to remote builds, let’s give it a try. Start
    in the Jupiter project directory, create a subdirectory called *build*, and then
    change into that directory. Execute the `configure` script using a relative path
    and then list the current directory contents:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The entire build system has been constructed by `configure` and `config.status`
    within the *build* subdirectory. Enter `make` to build the project from within
    the *build* directory:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: No matter where you are, if you can access the project directory using either
    a relative or an absolute path, you can do a remote build from that location.
    This is just one more thing that Autoconf does for you in Autoconf-generated configuration
    scripts. Imagine managing proper relative paths to source directories in your
    own hand-coded configuration scripts!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Let’s Take a Breather
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, I’ve shown you a nearly complete build system that includes almost all
    of the features outlined in the *GCS*. The features of Jupiter’s build system
    are all fairly self-contained and reasonably simple to understand. The most difficult
    feature to implement by hand is the configuration script. In fact, writing a configuration
    script by hand is so labor intensive, compared to the simplicity of using Autoconf,
    that I just skipped the hand-coded version entirely in [Chapter 3](ch03.xhtml).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Although using Autoconf as I’ve used it here is quite easy, most people don’t
    create their build systems in the manner I’ve shown you. Instead, they try to
    copy the build system of another project and tweak it to make it work in their
    own project. Later, when they start a new project, they do the same thing again.
    This can cause trouble because the code they’re copying was never meant to be
    used the way they’re now trying to use it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: I’ve seen projects in which the *configure.ac* file contained junk that had
    nothing to do with the project to which it belonged. These leftover bits came
    from some legacy project, but the maintainer didn’t know enough about Autoconf
    to properly remove all the extraneous text. With the Autotools, it’s generally
    better to start small and add what you need than to start with a copy of *configure.ac*
    from another full-featured build system and then try to pare it down to size or
    otherwise modify it to work with a new project.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure you’re feeling like there’s a lot more to learn about Autoconf, and
    you’re right. We’ll spend the remainder of this chapter examining the most important
    Autoconf macros and how they’re used in the context of the Jupiter project. But
    first, let’s go back and see if we might be able to simplify the Autoconf startup
    process even more by using another utility that comes with the Autoconf package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: An Even Quicker Start with autoscan
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to create a (mostly) complete *configure.ac* file is to run
    the `autoscan` utility, which is part of the Autoconf package. This utility examines
    the contents of a project directory and generates the basis for a *configure.ac*
    file (which `autoscan` names *configure.scan*) using existing makefiles and source
    files.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how well `autoscan` does on the Jupiter project. First, I’ll clean
    up the droppings from my earlier experiments, and then I’ll run `autoscan` in
    the *jupiter* directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re using the git repository that accompanies this book, you can simply
    run *`git clean -df`* to remove all files and directories not currently under
    source control by git. Don’t forget to switch back into the parent directory if
    you’re still sitting in the build directory.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that I’m *not* deleting my original *configure.ac* file—I’ll just let
    `autoscan` tell me how to improve it. In less than a second, I have a few new
    files in the top-level directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `autoscan` utility examines the project directory hierarchy and creates
    two files called *configure.scan* and *autoscan.log*. The project may or may not
    already be instrumented for the Autotools—it doesn’t really matter, because `autoscan`
    is decidedly nondestructive. It will never alter any existing files in a project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The `autoscan` utility generates a warning message for each problem it discovers
    in an existing *configure.ac* file. In this example, `autoscan` noticed that *configure.ac*
    should be using the Autoconf-provided `AC_CHECK_HEADERS`, `AC_PREREQ`, `AC_PROG_CC`,
    and `AC_PROG_INSTALL` macros. It made these assumptions based on information gleaned
    from the existing *Makefile.in* templates and from the C-language source files,
    as you can see by the comments after the warning statements beginning at ➊. You
    can always see these messages (in even greater detail) by examining the *autoscan.log*
    file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '*The notices you receive from *`autoscan`* and the contents of your configure.ac
    file may differ slightly from mine, depending on the version of Autoconf you have
    installed. I have version 2.69 of GNU Autoconf installed on my system (the latest,
    as of this writing). If your version of *`autoscan`* is older (or newer), you
    may see some minor differences.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the generated *configure.scan* file, I note that `autoscan` has
    added more text to this file than was in my original *configure.ac* file. After
    looking it over to ensure that I understand everything, I see that it’s probably
    easiest for me to overwrite *configure.ac* with *configure.scan* and then change
    the few bits of information that are specific to Jupiter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: My first modification involves changing the `AC_INIT` macro parameters for Jupiter,
    as illustrated in [Listing 4-11](ch04.xhtml#ch04ex11).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 4.4
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 4-11:* configure.ac: *Tweaking the `AC_INIT` macro generated by `autoscan`*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The `autoscan` utility does a lot of the work for you. The *GNU Autoconf Manual*^([12](footnote.xhtml#ch04fn12))
    states that you should modify this file to meet the needs of your project before
    you use it, but there are only a few key issues to worry about (besides those
    related to `AC_INIT`). I’ll cover each of these issues in turn, but first, let’s
    take care of a few administrative details.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: I’d be remiss if I didn’t mention `autoupdate` while discussing `autoscan`.
    If you’ve already got a working *configure.ac* file, and you update to a newer
    version of Autoconf, you can run `autoupdate` to update your existing *configure.ac*
    file with constructs that have changed or been added since the older version of
    Autoconf.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*The Proverbial bootstrap.sh Script*'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before `autoreconf` came along, maintainers passed around a short shell script,
    often named `autogen.sh` or `bootstrap.sh`, which would run all of the Autotools
    required for their projects in the proper order. The recommended name for this
    script is `bootstrap.sh` because Autogen is the name of another GNU project. The
    `bootstrap.sh` script can be fairly sophisticated, but to solve the problem of
    the missing `install-sh` script (see “Missing Required Files in Autoconf,” next),
    I’ll just add a simple temporary `bootstrap.sh` script to the project root directory,
    as shown in [Listing 4-12](ch04.xhtml#ch04ex12).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 4.5
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 4-12:* bootstrap.sh: *A temporary bootstrap script that executes the
    required Autotools*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The Automake `--add-missing` option copies the required missing utility scripts
    into the project, and the `--copy` option indicates that true copies should be
    made (otherwise, symbolic links are created that refer to the files where they’re
    installed with the Automake package).^([13](footnote.xhtml#ch04fn13))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '*We don’t need to see the warnings from executing *`automake`*, so I’ve redirected
    the *`stderr`* and *`stdout`* streams to /dev/null on the *`automake`* command
    line at ➊ in this script. In [Chapter 6](ch06.xhtml), we’ll remove *`bootstrap.sh`*
    and simply run *`autoreconf --install`*, but for now, this solves our missing
    file problems.*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: MISSING REQUIRED FILES IN AUTOCONF
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'When I first tried to execute `autoreconf` on the *configure.ac* file in [Listing
    4-11](ch04.xhtml#ch04ex11), I discovered a minor problem related to using Autoconf
    *without* Automake. When I ran the `configure` script, it failed with an error:
    `configure: error: cannot find install-sh, install.sh, or shtool in "." "./.."
    "./../.."`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Autoconf is all about portability and, unfortunately, the Unix `install` utility
    is not as portable as it could be. From one platform to another, critical bits
    of installation functionality are just different enough to cause problems, so
    the Autotools provide a shell script called `install-sh` (deprecated name: `install.sh`).
    This script acts as a wrapper around the system’s own `install` utility, masking
    important differences between various versions of `install`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '`autoscan` noticed that I’d used the `install` program in my *src/Makefile.in*
    template, so it generated an expansion of the `AC_PROG_INSTALL` macro. The problem
    is that `configure` couldn’t find the `install-sh` wrapper script anywhere in
    my project.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: I reasoned that the missing file was part of the Autoconf package and it just
    needed to be installed. I also knew that `autoreconf` accepts a command line option
    to install such missing files into a project directory. The `--install` (`-i`)
    option supported by `autoreconf` is designed to pass tool-specific options down
    to each of the tools that it calls in order to install missing files. However,
    when I tried that, I found that the file was still missing, because `autoconf`
    doesn’t support an option to install missing files.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: I could have manually copied `install-sh` from the Automake installation directory
    (usually */usr/(local/)share/automake-**), but looking for a more automated solution,
    I tried manually executing `automake --add-missing --copy`. This command generated
    a slew of warnings indicating that the project was not configured for Automake.
    However, I could now see that `install-sh` had been copied into my project root
    directory, and that’s all I was after. Executing `autoreconf --install` didn’t
    run `automake` because *configure.ac* was not set up for Automake.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf should ship with `install-sh`, since it provides a macro that requires
    it, but then `autoconf` would have to provide an `--add-missing` command line
    option. Nevertheless, there is actually a quite obvious solution to this problem.
    The `install-sh` script is not really required by any code Autoconf generates.
    How could it be? Autoconf doesn’t generate any makefile constructs—it only substitutes
    variables into your *Makefile.in* templates. Thus, there’s really no reason for
    Autoconf to complain about a missing `install-sh` script.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '*Updating Makefile.in*'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s make `bootstrap.sh` executable and then execute it and see what we end
    up with:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We know from the file list at ➊ that *config.h.in* has been created, so we know
    that `autoreconf` has executed `autoheader`. We also see the new `install-sh`
    script at ➋ that was created when we executed `automake` in `bootstrap.sh`. Anything
    provided or generated by the Autotools should be copied into the archive directory
    so that it can be shipped with release tarballs. Therefore, we’ll add `cp` commands
    for these two files to the `$(distdir)` target in the top-level *Makefile.in*
    template. Note that we don’t need to copy the `bootstrap.sh` script because it’s
    purely a maintainer tool—users should never need to execute it from a tarball
    distribution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-13](ch04.xhtml#ch04ex13) illustrates the required changes to the
    `$(distdir)` target in the top-level *Makefile.in* template.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 4.6
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-13:* Makefile.in: *Additional files needed in the distribution archive
    image directory*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: If you’re beginning to think that this could become a maintenance problem, then
    you’re right. I mentioned earlier that the `$(distdir)` target was painful to
    maintain. Luckily, the `distcheck` target still exists and still works as designed.
    It would have caught this problem, because attempts to build from the tarball
    will fail without these additional files—and the `distcheck` target certainly
    won’t succeed if the build fails. When we discuss Automake in [Chapter 6](ch06.xhtml),
    we will clear up much of this maintenance mess.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Initialization and Package Information
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s turn our attention back to the contents of the *configure.ac* file
    in [Listing 4-11](ch04.xhtml#ch04ex11) (and the console example immediately preceding
    that listing). The first section contains Autoconf initialization macros. These
    are required for all projects. Let’s consider each of these macros individually,
    because they’re all important.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*AC_PREREQ*'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `AC_PREREQ` macro simply defines the earliest version of Autoconf that
    may be used to successfully process this *configure.ac* file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The *GNU Autoconf Manual* indicates that `AC_PREREQ` is the only macro that
    may be used before `AC_INIT`. This is because it’s good to ensure you’re using
    a new enough version of Autoconf before you begin processing any other macros,
    which may be version dependent.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '*AC_INIT*'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `AC_INIT` macro, as its name implies, initializes the Autoconf system. Here’s
    its prototype, as defined in the *GNU Autoconf Manual*:^([14](footnote.xhtml#ch04fn14))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It accepts up to five arguments (`autoscan` only generates an invocation with
    the first three): *`package`*, *`version`*, and, optionally, *`bug-report`*, *`tarname`*,
    and *`url`*. The *`package`* argument is intended to be the name of the package.
    It will end up (in a canonical form) as the first part of the name of an Automake-generated
    release distribution tarball when you execute `make dist`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*Autoconf uses a normalized form of the package name in the tarball name, so
    you can use uppercase letters in the package name, if you wish. Automake-generated
    tarballs are named *`tarname`*-*`version`*.tar.gz by default, but *`tarname`*
    is set to a normalized form of the *`package`* name (lowercase, with all punctuation
    converted to underscores). Bear this in mind when you choose your package name
    and version string.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The optional *`bug-report`* argument is usually set to an email address, but
    any text string is valid—the URL of a web page that accepts bug reports for the
    project is a common alternative. An Autoconf substitution variable called `@PACKAGE_BUGREPORT@`
    is created for it, and that variable is also added to the *config.h.in* template
    as a C-preprocessor definition. The intent here is that you use the variable in
    your code to present an email address or URL for bug reports at appropriate places—possibly
    when the user requests help or version information from your application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: While the *`version`* argument can be anything you like, there are a few commonly
    used OSS conventions that will make things a little easier for you. The most widely
    used convention is to pass in *major.minor* (for example, 1.2). However, there’s
    nothing that says you can’t use *major.minor.revision*, and there’s nothing wrong
    with this approach. None of the resulting `VERSION` variables (Autoconf, shell,
    or `make`) are parsed or analyzed anywhere—they’re only used as placeholders for
    substituted text in various locations.^([15](footnote.xhtml#ch04fn15)) So if you
    wish, you may even add nonnumerical text into this macro, such as *0.15.alpha1*,
    which is occasionally useful.^([16](footnote.xhtml#ch04fn16))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*The RPM package manager, on the other hand, does care what you put in the
    version string. For the sake of RPM, you may wish to limit the version string
    text to only alphanumeric characters and periods—no dashes or underscores.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The optional *`url`* argument should be the URL for your project website. It’s
    shown in the help text displayed by `configure --help`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf generates the substitution variables `@PACKAGE_NAME@`, `@PACKAGE_VERSION@`,
    `@PACKAGE_TARNAME@`, `@PACKAGE_STRING@` (a stylized concatenation of the package
    name and version information), `@PACKAGE_BUGREPORT@`, and `@PACKAGE_URL@` from
    the arguments to `AC_INIT`. You can use any or all of these in your *Makefile.in*
    template files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*AC_CONFIG_SRCDIR*'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `AC_CONFIG_SRCDIR` macro is a sanity check. Its purpose is to ensure that
    the generated `configure` script knows that the directory on which it is being
    executed is actually the project directory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, `configure` needs to be able to locate itself, because it
    generates code that executes itself, possibly from a remote directory. There are
    myriad ways to inadvertently fool `configure` into finding some other `configure`
    script. For example, the user could accidentally provide an incorrect `--srcdir`
    argument to `configure`. The `$0` shell script parameter is unreliable, at best—it
    may contain the name of the shell, rather than that of the script, or it may be
    that `configure` was found in the system search path, so no path information was
    specified on the command line.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The `configure` script could try looking in the current or parent directories,
    but it still needs a way to verify that the `configure` script it locates is actually
    itself. Thus, `AC_CONFIG_SRCDIR` gives `configure` a significant hint that it’s
    looking in the right place. Here’s the prototype for `AC_CONFIG_SRCDIR`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The argument can be a path (relative to the project’s `configure` script) to
    any source file you like. You should choose one that is unique to your project
    so as to minimize the possibility that `configure` is fooled into thinking some
    other project’s configuration file is itself. I normally try to choose a file
    that sort of represents the project, such as a source file named for a feature
    that defines the project. That way, in case I ever decide to reorganize the source
    code, I’m not likely to lose it in a file rename. In this case, however, we have
    only one source file, *main.c*, making it a little difficult to follow this convention.
    Regardless, both `autoconf` and `configure` will tell you and your users if it
    can’t find the file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The Instantiating Macros
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we dive into the details of `AC_CONFIG_HEADERS`, I’d like to spend a
    little time on the file generation framework Autoconf provides. From a high-level
    perspective, there are four major things happening in *configure.ac*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check request processing
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File instantiation request processing
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation of the `configure` script
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve covered initialization—there’s not much to it, although there are a few
    more macros you should be aware of. Check out the *GNU Autoconf Manual* for more
    information—look up `AC_COPYRIGHT`, for an example. Now let’s move on to file
    instantiation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually four so-called *instantiating macros*: `AC_CONFIG_FILES`,
    `AC_CONFIG_HEADERS`, `AC_CONFIG_COMMANDS`, and `AC_CONFIG_LINKS`. An instantiating
    macro accepts a list of tags or files; `configure` will generate these files from
    templates containing Autoconf substitution variables.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*You might need to change the name of *`AC_CONFIG_HEADER`* (singular) to *`AC_CONFIG_HEADERS`*
    (plural) in your version of* configure.scan. *The singular version is the older
    name for this macro, and the older macro is less functional than the newer one.^([17](footnote.xhtml#ch04fn17))*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The four instantiating macros have an interesting common signature. The following
    prototype can be used to represent each of them, with appropriate text replacing
    the *`XXX`* portion of the macro name:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For each of these four macros, the tag argument has the form *`OUT`*`[:`*`INLIST`*`]`,
    where *`INLIST`* has the form *`IN0`*`[:`*`IN1`*`:...:`*`INn`*`]`. Often, you’ll
    see a call to one of these macros with only a single argument, as in the three
    examples that follow (note that these examples represent macro *invocations*,
    not *prototypes*, so the square brackets are actually Autoconf quotes, not indications
    of optional parameters):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, *config.h* is the *`OUT`* portion of the preceding specification.
    The default value for *`INLIST`* is the *`OUT`* portion with *.in* appended to
    it. So, in other words, the preceding call is exactly equivalent to the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'What this means is that `config.status` contains shell code that will generate
    *config.h* from *config.h.in*, substituting all Autoconf variables in the process.
    You may also provide a list of input files in the *`INLIST`* portion. In this
    case, the files in *`INLIST`* will be concatenated to form the resulting *`OUT`*
    file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `config.status` will generate *config.h* by concatenating *cfg0*, *cfg1*,
    and *cfg2* (in that order), after substituting all Autoconf variables. The *GNU
    Autoconf Manual* refers to this entire *`OUT`*`[:`*`INLIST`*`]` construct as a
    *tag*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Why not just call it a *file*? Well, this parameter’s primary purpose is to
    provide a sort of command line target name—much like makefile targets. It can
    also be used as a filesystem name if the associated macro generates files, as
    is the case with `AC_CONFIG_HEADERS`, `AC_CONFIG_FILES`, and `AC_CONFIG_LINKS`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'But `AC_CONFIG_COMMANDS` is unique in that it doesn’t generate any files. Instead,
    it runs arbitrary shell code, as specified by the user in the macro’s arguments.
    Thus, rather than name this first parameter after a secondary function (the generation
    of files), the *GNU Autoconf Manual* refers to it more generally, according to
    its primary purpose—as a command line *tag* that may be specified on the `./config.status`
    command line, in this manner:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command will regenerate the *config.h* file based on the macro call to
    `AC_CONFIG_HEADERS` in *configure.ac*. It will *only* regenerate *config.h*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `./config.status --help` to see the other command line options you can
    use when executing `./config.status`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that `config.status` provides custom help about a project’s `config .status`
    file. It lists configuration files ➍ and configuration headers ➎ that we can use
    as tags on the command line where the usage specifies `[TAG]...` at ➊. In this
    case, `config.status` will only instantiate the specified objects. In the case
    of commands, it will execute the command set specified by the tag passed in the
    associated expansion of the `AC_CONFIG_COMMANDS` macro.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these macros may be used multiple times in a *configure.ac* file. The
    results are cumulative, and we can use `AC_CONFIG_FILES` as many times as we need
    to in *configure.ac*. It is also important to note that `config.status` supports
    the `--file=` option (at ➌). When you call `config.status` with tags on the command
    line, the only tags you can use are those the help text lists as available configuration
    files, headers, links, and commands. When you execute `config.status` with the
    `--file=` option, you’re telling `config.status` to generate a new file that’s
    not already associated with any of the calls to the instantiating macros found
    in *configure.ac*. This new file is generated from an associated template using
    configuration options and check results determined by the last execution of `configure`.
    For example, I could execute `config.status` in this manner (using a fictional
    template called *extra.in*):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**NOTE**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*The default template name is the filename with a .in suffix, so this call
    could have been made without using the *`:extra.in`* portion of the option. I
    added it here for clarity.*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I’d like to point out a newer feature of `config.status`—the `--config`
    option at ➋, added with version 2.65 of Autoconf. Using this option displays the
    explicit configuration options passed to `configure` on the command line. For
    instance, assume that we had invoked `./configure` in this manner:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you use the new `--config` option, `./config.status` displays the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**NOTE**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '*Older versions of Autoconf generated a *`config.status`* script that displayed
    this information when using the *`--version`* option, but it was part of a larger
    wall of text. The newer *`--config`* option makes it easier to find and reuse
    configuration options originally passed to the *`configure`* script.*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return now to the instantiating macro signature at the bottom of [page
    102](ch04.xhtml#page_102). I’ve shown you that the *`tag...`* argument has a complex
    format, but the ellipsis indicates that it also represents multiple tags, separated
    by whitespace. The format you’ll see in nearly all *configure.ac* files is shown
    in [Listing 4-14](ch04.xhtml#ch04ex14).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 4-14: Specifying multiple tags (files) in `AC_CONFIG_FILES`*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Each entry here is one tag specification, which, if fully specified, would look
    like the call in [Listing 4-15](ch04.xhtml#ch04ex15).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 4-15: Fully specifying multiple tags in `AC_CONFIG_FILES`*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the instantiating macro prototype, there are two optional arguments
    that you’ll rarely see used in these macros: *`commands`* and *`init-cmds`*. The
    *`commands`* argument may be used to specify some arbitrary shell code that should
    be executed by `config.status` just before the files associated with the tags
    are generated. It is unusual for this feature to be used within the file-generating
    instantiating macros. You will almost always see the *`commands`* argument used
    with `AC_CONFIG_COMMANDS`, which generates no files by default, because a call
    to this macro is basically useless without commands to execute!^([18](footnote.xhtml#ch04fn18))
    In this case, the *`tag`* argument becomes a way of telling `config .status` to
    execute a specific set of shell commands.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The *`init-cmds`* argument initializes shell variables at the top of `config
    .status` with values available in *configure.ac* and `configure`. It’s important
    to remember that all calls to instantiating macros share a common namespace along
    with `config.status`. Therefore, you should try to choose your shell variable
    names carefully so they are less likely to conflict with each other and with Autoconf-generated
    variables.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The old adage about the value of a picture versus an explanation holds true
    here, so let’s try a little experiment. Create a test version of your *configure.ac*
    file that contains only the contents of [Listing 4-16](ch04.xhtml#ch04ex16). You
    should do this in a separate directory, as we’re not relying on any of the other
    files in the Jupiter project directory structure with this experiment.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 4-16: Experiment #1—a simple* configure.ac *file using `AC_CONFIG_COMMANDS`*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute `autoreconf`, `./configure`, and `./config.status` in various ways
    to see what happens:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see at ➊, executing `./configure` caused `config.status` to be executed
    with no command line options. There are no checks specified in *configure.ac*,
    so manually executing `./config.status`, as we did at ➋, has nearly the same effect.
    Querying `config.status` for help (as we did at ➌) indicates that `abc` is a valid
    tag; executing `./config.status` with that tag (as we did at ➍) on the command
    line simply runs the associated commands.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the important points regarding the instantiating macros are as
    follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The `config.status` script generates all files from templates.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `configure` script performs all checks and then executes `./config.status`.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you execute `./config.status` with no command line options, it generates
    files based on the last set of check results.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can call `./config.status` to execute file generation or command sets specified
    by any of the tags given in any of the instantiating macro calls.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `config.status` script may generate files not associated with any tags specified
    in *configure.ac*, in which case it will substitute variables based on the last
    set of checks performed.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generating Header Files from Templates*'
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve no doubt concluded by now, the `AC_CONFIG_HEADERS` macro allows you
    to specify one or more header files that `config.status` should generate from
    template files. The format of a configuration header template is very specific.
    A short example is given in [Listing 4-17](ch04.xhtml#ch04ex17).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 4-17: A short example of a header file template*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: You can place multiple statements like this in your header template, one per
    line. The comments are optional, of course. Let’s try another experiment. Create
    a new *configure.ac* file like that shown in [Listing 4-18](ch04.xhtml#ch04ex18).
    Again, you should do this in an isolated directory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 4-18: Experiment #2—a simple* configure.ac *file*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Create a template header file called *config.h.in* that contains the two lines
    in [Listing 4-19](ch04.xhtml#ch04ex19).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 4-19: Experiment #2 continued—a simple* config.h.in *file*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Now execute the following commands:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see at ➌ that `config.status` generated a *config.h* file from the simple
    *config.h.in* template we wrote. The contents of this header file are based on
    the checks executed by `configure`. Since the shell code generated by `AC_CHECK_HEADERS([unistd.h
    foobar.h])` was able to locate a *unistd.h* header file (➊) in the system include
    directory, the corresponding `#undef` statement was converted into a `#define`
    statement. Of course, no *foobar.h* header was found in the system include directory,
    as you can also see by the output of `./configure` at ➋; therefore, its definition
    was left commented out in the template, as shown at ➍.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Hence, you may add the sort of code shown in [Listing 4-20](ch04.xhtml#ch04ex20)
    to appropriate C-language source files in your project.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 4-20: Using generated CPP definitions in a C-language source file*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '*The unistd.h header file is so standard these days that it’s not really necessary
    to check for it in *`AC_CONFIG_HEADERS`*, but it served here as a file that I
    was sure existed on my system for this example.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '*Using autoheader to Generate an Include File Template*'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Manually maintaining a *config.h.in* template is more trouble than necessary.
    The format of *config.h.in* is very strict—for example, you can’t have any leading
    or trailing whitespace on the `#undef` lines, and the `#undef` lines you add must
    use `#undef` rather than `#define`, mainly because `config.status` only knows
    how to either replace `#undef` with `#define` or comment out lines containing
    `#undef`.^([19](footnote.xhtml#ch04fn19))
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the information you need from *config.h.in* is available in *configure.ac*.
    Fortunately, `autoheader` will generate a properly formatted header file template
    for you based on the contents of *configure.ac*, so you don’t often need to write
    *config.h.in* templates. Let’s return to the command prompt for a final experiment.
    This one is easy—just delete your *config.h.in* template from experiment #2 and
    then run `autoheader` followed by `autoconf`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**NOTE**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '*Again, I encourage you to use *`autoreconf`*, which will automatically run
    *`autoheader`* if it notices an expansion of *`AC_CONFIG_HEADERS`** in configure.ac.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: As you can see by the output of the `cat` command at ➊, an entire set of preprocessor
    definitions was derived from *configure.ac* by `autoheader`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-21](ch04.xhtml#ch04ex21) shows a much more realistic example of
    using a generated *config.h* file to increase the portability of your project
    source code. In this example, the `AC_CONFIG_HEADERS` macro invocation indicates
    that *config.h* should be generated, and the invocation of `AC_CHECK_HEADERS`
    will cause `autoheader` to insert a definition into *config.h*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 4-21: A more realistic example of using `AC_CONFIG_HEADERS`*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The *config.h* file is intended to be included in your source code in locations
    where you might wish to test a configured option in the code itself using the
    C preprocessor. This file should be included first in source files so it can influence
    the inclusion of system header files later in the source.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '*The config.h.in template that *`autoheader`* generates doesn’t contain an
    include-guard construct, so you need to be careful that it’s not included more
    than once in a source file. A good rule of thumb is to always include* config.h
    *as the very first header in every .c source file and never include it anywhere
    else. Following this rule will guarantee that it never needs an include guard.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: It’s often the case that every *.c* file in a project needs to include *config.h*.
    In this case, an interesting approach is to use the `gcc` `-include` option to
    include it at the top of every compiled source file from the compiler command
    line. This can be done within *configure.ac* by appending `-include config.h`
    to the `DEFS` variable (which is currently only used to define `HAVE_CONFIG_H`—if
    you’re more of a purist, you can use `CFLAGS` instead). Once done, you may assume
    *config.h* is part of every translation unit.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t make the mistake of including *config.h* in a public header file if your
    project installs libraries and header files as part of your product set. For more
    detailed information on this topic, refer to “Item 1: Keeping Private Details
    out of Public Interfaces” on [page 499](ch18.xhtml#page_499).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Using the *configure.ac* file from [Listing 4-21](ch04.xhtml#ch04ex21), the
    generated `configure` script will create a *config.h* header file with appropriate
    definitions for determining, at compile time, whether or not the current system
    provides the `dlfcn` interface. To complete the portability check, you can add
    the code from [Listing 4-22](ch04.xhtml#ch04ex22) to a source file in your project
    that uses dynamic loader functionality.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 4-22: A sample source file that checks for dynamic loader functionality*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: If you already had code that included *dlfcn.h*, `autoscan` would have generated
    a line in *configure.ac* to call `AC_CHECK_HEADERS` with an argument list containing
    *dlfcn.h* as one of the header files to be checked. Your job as maintainer is
    to add the conditional statements at ➊ and ➋ to your source code around the existing
    inclusions of the *dlfcn.h* header file and around calls to the *dlfcn* interface
    functions. This is the crux of Autoconf portability support.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '*You don’t technically need the preprocessor conditionals around the code if
    you choose to “error out” if the inclusion check fails, but doing so makes it
    obvious to the reader which portions of the source code are affected by the conditional
    inclusion.*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Your project might prefer dynamic loader functionality, but could get along
    without it if necessary. It’s also possible that your project requires a dynamic
    loader, in which case your build should terminate with an error (as this code
    does) if the key functionality is missing. Often, this is an acceptable stopgap
    until someone comes along and adds support to the source code for a more system-specific
    dynamic loader service.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have to bail out with an error, it’s best to do so at configuration
    time rather than at compile time. The general rule of thumb is to bail out as
    early as possible.*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, `HAVE_CONFIG_H` is part of a string of definitions passed
    on the compiler command line in the Autoconf substitution variable `@DEFS@`. Before
    `autoheader` and `AC_CONFIG_HEADERS` functionality existed, Automake added all
    of the compiler configuration macros to the `@DEFS@` variable. You can still use
    this method if you don’t use `AC_CONFIG_HEADERS` in *configure.ac,* but it’s not
    recommended—mainly because a large number of definitions make for very long compiler
    command lines.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Back to Remote Builds for a Moment
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we wrap up this chapter, you’ll notice that we’ve come full circle. We started
    out covering some preliminary information before we discussed how to add remote
    builds to Jupiter. Now we’ll return to this topic for a moment, because I haven’t
    yet covered how to get the C preprocessor to properly locate a generated *config.h*
    file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Since this file is generated from a template, it will be at the same relative
    position in the build directory structure as its counterpart template file, *config.h.in*,
    is in the source directory structure. The template is located in the top-level
    *source* directory (unless you chose to put it elsewhere), so the generated file
    will be in the top-level *build* directory. Well, that’s easy enough—it’s always
    one level up from the generated *src/Makefile*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Before we draw any conclusions then about header file locations, let’s consider
    where header files might appear in a project. We might generate them in the current
    build directory, as part of the build process. We might also add internal header
    files to the current source directory. We know we have a *config.h* file in the
    top-level build directory. Finally, we might also create a top-level *include*
    directory for library interface header files our package provides. What is the
    order of priority for these various *include* directories?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The order in which we place *include directives* (`-I`*`path`* options) on the
    compiler command line is the order in which they will be searched, so the order
    should be based on which files are most relevant to the source file currently
    being compiled. Therefore, the compiler command line should include `-I`*`path`*
    directives for the current build directory (`.`) first, followed by the source
    directory [`$(srcdir)`], then the top-level build directory (`..`), and, finally,
    our project’s *include* directory, if it has one. We impose this ordering by adding
    `-I`*`path`* options to the compiler command line, as shown in [Listing 4-23](ch04.xhtml#ch04ex23).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 4.7
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 4-23:* src/Makefile.in: *Adding proper compiler include directives*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know this, we need to add another rule of thumb for remote builds
    to the list we created on [page 92](ch04.xhtml#page_92):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Add preprocessor commands for the current build directory, the associated source
    directory, and the top-level build directory (or other build directory if *config.h.in*
    is located elsewhere), in that order.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we covered just about all the major features of a fully functional
    GNU project build system, including writing a *configure.ac* file, from which
    Autoconf generates a fully functional `configure` script. We’ve also covered adding
    remote build functionality to makefiles with `VPATH` statements.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: So what else is there? Plenty! In the next chapter, I’ll continue to show you
    how you can use Autoconf to test system features and functionality before your
    users run `make`. We’ll also continue enhancing the configuration script so that
    when we’re done, users will have more options and understand exactly how our package
    will be built on their systems.*
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
