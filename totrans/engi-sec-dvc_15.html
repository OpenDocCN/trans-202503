<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_223"/><strong><span class="big">12</span><br/>SYSTEM MONITORING</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">Monitoring often comes with a negative connotation because it suggests that data is collected for surveillance by something or somebody. However, many digital business models like predictive maintenance wouldn’t work without monitoring and subsequent data analytics. In the same way, the continuous protection of devices requires data logging and analysis to detect and trace back malicious activities.</p>
<p class="indent">The creation of extensive logfiles in IT systems has been common for decades. However, when it comes to embedded systems, logs might not receive the attention they deserve. In the past, low storage capacities and missing internet connections were legitimate reasons for putting system monitoring in second place, but luckily, these days, those limitations have continued to decrease.</p>
<p class="indent">In this chapter, I explain the benefits of monitoring devices for security reasons. In addition, I discuss resource limitations on embedded systems and multiple aspects of logging processes and their management. To wrap everything up, the book’s final case study looks at available log data on an STM32MP157F device and how to analyze it.</p>
<h3 class="h3" id="ch00lev1_96"><span epub:type="pagebreak" id="page_224"/><strong>Monitoring for the Right Reasons</strong></h3>
<p class="noindent">Many companies have been accused of being “data krakens” because they collect all the data they can lay their hands on, whether from web services, IT infrastructures, or end-user devices. For them, this collection leads to profitable business models, but this development obviously contradicts privacy efforts to protect humans from tracking, surveillance, and spying.</p>
<p class="indent">On the legal side, the European GDPR is an example of counteracting excessive data collection, but other legal requirements—such as UN Regulation 155 in the automotive sector, IEC 62443-4-2 for the industrial automation industry, and the Critical Infrastructure Protection (CIP) standard CIP-007-6 of the North American Electric Reliability Corporation (NERC)—explicitly require security monitoring of connected products, either by manufacturers or operators. In a nutshell, be aware that the two sides of the data collection and monitoring coin always have to be balanced carefully.</p>
<p class="indent">In some areas, monitoring has been common practice for a long time; for example, surveillance cameras and security staff keep an eye on the physical security threats of buildings and corporate sites. The banking sector has a long tradition of monitoring transactions and reacting to unusual activities. Last but not least, network traffic monitoring by firewalls and intrusion detection systems is part of every sane IT infrastructure. Collecting data and monitoring systems in the name of security is clearly often acceptable, but it always must stay within reasonable bounds.</p>
<p class="indent">System monitoring has various advantages for device security. Log data can be especially useful in two cases. First, every attack on your device runs through multiple phases including reconnaissance, delivery, exploitation, installation, command and control, and actions on objectives. Each phase might leave traces in the device’s logfiles that enable you to detect the attack early, react accordingly, and thereby avert further damage. Second, log data can be an immensely valuable source during forensic processes after an incident happened. Imagine that your devices were attacked in the field, but you don’t have any data to reconstruct and understand what happened. Being blind in such a situation not only leaves you clueless but also can be a significant risk for your business.</p>
<p class="indent">In general, device monitoring raises transparency throughout your device population in the field and gives you an overview of when, where, and how your products are used. In critical infrastructures, such monitoring might even be necessary to fulfill legal or certification requirements. Also, as mentioned in <a href="ch09.xhtml#ch09">Chapter 9</a>, knowing the state of firmware versions deployed on your devices in the field can be helpful in understanding the threat landscape of your customers.</p>
<p class="indent">Besides the pure security use cases, monitoring can even be a supporting tool for handling and analyzing customer complaints. Log data might, for example, prove that an end user performed manual configuration changes that led to unauthorized operation modes, which overstressed mechanical components and caused a machine to break.</p>
<h3 class="h3" id="ch00lev1_97"><span epub:type="pagebreak" id="page_225"/><strong>Monitoring the Right Things</strong></h3>
<p class="noindent">Embedded systems running Linux, communicating with a variety of services, and interacting with sensors and actuators have reached a complexity that doesn’t allow for recording the whole device state at any given point in time. The only option is <em>selective monitoring</em> of system properties and events.</p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Logging system data is a double-edged sword. It might be of great use to your service engineers during troubleshooting, but if your log contains usernames, passwords, and other sensitive data, attackers might very much appreciate the information free of charge.</em></p>
</div>
<h4 class="h4" id="ch00lev2_150"><strong><em>User Interactions and Access Control</em></strong></h4>
<p class="noindent">A good starting point is to monitor events that are related to user interaction and access control.</p>
<h5 class="h5" id="ch00lev3_32"><strong>User Sessions</strong></h5>
<p class="noindent">If humans log in to a device, they don’t do it without intention, whether authorized or malicious. Knowing the user login history and being able to match it with real-world activities of a certain human might reveal that an account was misused. For example, the person corresponding to a virtual user could have been on vacation and therefore clearly not acting.</p>
<p class="indent">In addition, a high number of failed login attempts can indicate that a brute-force attack has been performed. Finally, the time and date information of user sessions might help in reconstructing an attack’s timeline.</p>
<h5 class="h5" id="ch00lev3_33"><strong>Access-Control Violations</strong></h5>
<p class="noindent">As described in <a href="ch11.xhtml#ch11">Chapter 11</a>, users and processes should be restricted to the minimum permissions necessary to fulfill their tasks. Besides the positive effect of access restrictions at runtime, those measures can also yield valuable information about which user or process <em>tried</em> to access a forbidden resource, which might help detect attacks in an early phase.</p>
<h5 class="h5" id="ch00lev3_34"><strong>Filesystem Activities</strong></h5>
<p class="noindent">Temporary files that appear suddenly and permanent changes to configuration or system files can indicate malicious activities. They could be initiated by processes running on the device, possibly because they’ve been compromised by exploitation of an unknown vulnerability. But a human user also could be the origin of manipulation, which could hint at an insider attack. Monitoring at least a subset of critical files and their events can be valuable in such cases.</p>
<h5 class="h5" id="ch00lev3_35"><strong>Removable Media</strong></h5>
<p class="noindent">Sometimes just plugging a USB thumb drive or a memory card into a device can trigger an attack. If your product offers such features, it absolutely makes sense to log information about when such media was plugged in or removed and maybe even which identifiers it had.</p>
<h4 class="h4" id="ch00lev2_151"><span epub:type="pagebreak" id="page_226"/><strong><em>Communication</em></strong></h4>
<p class="noindent">Although monitoring all data running on all communication channels of a device is usually not possible because of the vast amount of data transmitted, certain metadata or specific sent or received information can provide valuable insights.</p>
<h5 class="h5" id="ch00lev3_36"><strong>Network Communication</strong></h5>
<p class="noindent">Communication data received from external sources as well as data your device sends can yield hints of malicious activities. For example, a high amount of traffic from certain IP addresses might represent targeted DoS attacks. Nonstandard packets of communication protocols can represent adversaries testing your device’s reactions upon manipulated requests.</p>
<p class="indent">New connections from your device to unknown locations and IP addresses or an unexpected, increased amount of outbound network traffic also might indicate that the device is already compromised.</p>
<h5 class="h5" id="ch00lev3_37"><strong>Low-Level Communication</strong></h5>
<p class="noindent">In contrast to classic IT systems, an embedded system often has a variety of low-level interfaces like an I<sup>2</sup>C bus, serial connections, or general-purpose input/output (GPIO) pins. Their communication usually carries sensor or control data, which might again be a source for detecting unexpected behavior like forcing actuators into a dangerous operation mode.</p>
<p class="indent">Logging the state and communication data of these interfaces might not be a standard feature, but depending on their criticality, implementing it might be worth considering.</p>
<h4 class="h4" id="ch00lev2_152"><strong><em>Application Behavior</em></strong></h4>
<p class="noindent">In contrast to looking at security monitoring from a user or communication interface perspective, considering an application-centric approach might make sense.</p>
<h5 class="h5" id="ch00lev3_38"><strong>Service Activities</strong></h5>
<p class="noindent">Some services provide interesting information about your device’s state, especially those with remote connections. For example, an SSH daemon that allows remote sessions may provide a history of login attempts with corresponding IP addresses and usernames.</p>
<p class="indent">A web server also is able to log the HTTP requests it receives, which can reveal adversarial activities on application layer communication.</p>
<h5 class="h5" id="ch00lev3_39"><strong>Custom Applications</strong></h5>
<p class="noindent">Proprietary software components that are, for example, relevant for your business model might provide deep insight into the use of your device. Therefore, it should be quite natural to integrate monitoring facilities into important applications you develop on your own.</p>
<h5 class="h5" id="ch00lev3_40"><span epub:type="pagebreak" id="page_227"/><strong>Third-Party Applications</strong></h5>
<p class="noindent">Whenever you allow users to install applications developed by third parties on your device, you face common threats originating from untrustworthy software components. Besides strict access management for those programs, continuous monitoring of their behavior is a reasonable measure.</p>
<h4 class="h4" id="ch00lev2_153"><strong><em>System Behavior</em></strong></h4>
<p class="noindent">Last but not least, the overall “health status” of your device may reveal attacks or at least unexpected behavior you can analyze further.</p>
<h5 class="h5" id="ch00lev3_41"><strong>System Utilization</strong></h5>
<p class="noindent">Typical system utilization values, such as CPU load and memory consumption, are usually known by developers and maintenance staff. A device that shows unexpectedly high values can indicate additional software running on the device—for example, a crypto miner or backdoor service installed by attackers. But it might also just be a side effect of an attack targeting low-level or network interfaces.</p>
<h5 class="h5" id="ch00lev3_42"><strong>Process and System Crashes</strong></h5>
<p class="noindent">Do your device’s processes crash from time to time? I hope not, but maybe they do only in rare cases that you didn’t cover during testing. If single processes or even the whole system crashes multiple times, it might be due to an attacker probing your device for potential vulnerabilities. If it’s detected and analyzed early enough, you might be able to take action and prevent further damage.</p>
<h5 class="h5" id="ch00lev3_43"><strong>Errors and Warnings</strong></h5>
<p class="noindent">Although error messages and warnings can be part of perfectly normal device behavior, they can also be evidence that an adversary is tampering with a device’s services or configuration options during a reconnaissance phase.</p>
<h4 class="h4" id="ch00lev2_154"><strong><em>Risk-Based Monitoring</em></strong></h4>
<p class="noindent">Which monitoring measures are reasonable for your product should be decided on the basis of your device’s threat and risk analysis, as described in <a href="ch01.xhtml#ch01">Chapter 1</a>. For example, if you discovered that high network loads are a risk for your device’s real-time operations, monitoring network communication and system utilization is a good idea. If your device allows for running third-party Docker containers, monitoring the activities of those potentially dangerous software bundles should be on your list. And if your device has a web interface for configuration purposes, logging web server events becomes a necessity.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Many more sources of valuable information might exist for security monitoring that are specific to your device. Find them and use them to secure your device.</em></p>
</div>
<h3 class="h3" id="ch00lev1_98"><span epub:type="pagebreak" id="page_228"/><strong>Designing a Monitoring Scheme</strong></h3>
<p class="noindent">While system monitoring is not new for IT systems, implementing it efficiently is always a challenge—especially when it comes to logging events and processes on embedded systems. Depending on the capabilities of a specific product and the requirements for its use, a trade-off between on-device and server-based processing must be found.</p>
<p class="indent"><a href="ch12.xhtml#ch12fig01">Figure 12-1</a> shows a generic data-flow architecture of log data, starting with its collection, local storage, and eventual on-device analysis. While constrained devices will keep this part rather lean, stronger devices might aggregate more data and already perform on-device analysis to maximize potential insights.</p>
<div class="image"><img alt="Image" height="250" id="ch12fig01" src="../images/12fig01.jpg" width="871"/></div>
<p class="figcap"><em>Figure 12-1: A generic logging architecture</em></p>
<p class="indent">Usually, networked devices transmit at least part of the collected information to a remote server, whether on the local network or on the internet. This not only allows for storing larger amounts of log data but also enables performance-intensive data analytics for single devices and across whole device populations. The latter especially leads to significantly increased quality of security monitoring.</p>
<h4 class="h4" id="ch00lev2_155"><strong><em>Challenges for Embedded Systems</em></strong></h4>
<p class="noindent">When it comes to (I)IoT scenarios with rather constrained devices and possibly pretty large populations, the specific design of the monitoring process faces several challenges.</p>
<h5 class="h5" id="ch00lev3_44"><strong>Limited Resources</strong></h5>
<p class="noindent">Embedded systems can be limited in several dimensions, which leaves developers with the difficulty of determining the amount of resources to use for monitoring. Some devices are battery powered, and collection (let alone transmission) of log data would be a further burden on battery life. For products based on small microcontrollers, log data collection isn’t possible from a performance perspective because there’s simply no time left for such tasks. Some systems have limited storage space and store only small amounts of log data, while others don’t have the high-bandwidth network connection necessary for transferring monitoring data to central servers. Some devices have all these limitations.</p>
<p class="indent">For existing products, which are optimized to their single, dedicated task, it’s often difficult or nearly impossible to integrate security monitoring <span epub:type="pagebreak" id="page_229"/>as an add-on. But that shouldn’t be an excuse to discard all monitoring features. If you identify the need for security monitoring early in the development life cycle, you have a chance to reserve resources for this absolutely relevant purpose.</p>
<h5 class="h5" id="ch00lev3_45"><strong>Synchronized Time Sources</strong></h5>
<p class="noindent">Correct timestamps are essential for correlating events within a device and with those of other devices and system components. For this purpose, time sources have to be synchronized, which can’t be taken for granted on embedded systems.</p>
<p class="indent">Support for synchronization protocols, like NTP, likely has to be enabled on purpose, and integrators who use your product as well as operators of these systems have to provide a suitable infrastructure, like master clocks and time servers within their networks.</p>
<h5 class="h5" id="ch00lev3_46"><strong>Secure Communication</strong></h5>
<p class="noindent">Secure transmission of monitoring data from a device to a central collection server comes with several prerequisites. The device has to be able to authenticate the central server; otherwise, it could be tricked into sending valuable data to unauthorized parties.</p>
<p class="indent">The server also has to be able to verify the identity of the device providing data, because fake devices could significantly disturb the monitoring process by sending manipulated data. In addition, the data transmission itself should be protected in all aspects of secure communication, as described in <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>
<h5 class="h5" id="ch00lev3_47"><strong>Integrity-Protected Local Storage</strong></h5>
<p class="noindent">If you decide to partly or even completely rely on device-side logging without external transmissions, you have to prepare for the question, “How do you actually guarantee that the log data wasn’t altered at some point?” This question might even be posed by legal entities or in a court of law, for example, if your device is part of a nation’s critical infrastructure.</p>
<p class="indent">System-integrity protection as described in <a href="ch08.xhtml#ch08">Chapter 8</a> is a fundamental requirement for solid solutions regarding this challenge.</p>
<h5 class="h5" id="ch00lev3_48"><strong>Confidentiality-Protected Local Storage</strong></h5>
<p class="noindent">As mentioned in the previous section, log data might be useful not only for debugging your device but also for attackers during their reconnaissance phase. Therefore, you can definitely regard logfiles as assets that need confidentiality protection.</p>
<p class="indent">Measures like encrypted filesystems, as explained in <a href="ch05.xhtml#ch05">Chapter 5</a>, can be a solution. Another option is the implementation of a hybrid encryption scheme using the public key of a central log server to encrypt a random local symmetric key, which is, in turn, used to encrypt the locally generated log data. In that case, only the remote server in possession of the corresponding private key would be able to decrypt and analyze the log information.</p>
<h4 class="h4" id="ch00lev2_156"><span epub:type="pagebreak" id="page_230"/><strong><em>Monitoring of the On-Device Logging Process</em></strong></h4>
<p class="noindent">Continuous security monitoring can play a central role in the detection of attacks, timely reactions to incidents, and comprehensive forensic analysis after a compromise, which means the involved on-device logging processes are expected to function properly. However, it would be naive to assume that monitoring processes are robust by nature and immune to all sorts of influences. It’s important to install measures that check whether the involved logging procedures are working correctly.</p>
<p class="indent">No matter whether the local log storage is only a few megabytes or some gigabytes, it is always finite. In some cases, it might be tempting to say that a certain memory can hold “more log events than a specific device could ever generate,” but keep in mind that logging behavior can change with future firmware versions, devices in industrial scenarios might operate for decades, and new features and content could significantly reduce storage capacities. Monitoring the log storage capacity is, therefore, a mandatory task. Also, you have to make a decision about how to react if storage space is exhausted, or even before that happens. For example, if possible, logs can be compressed and archived to a remote location, or the oldest events can be overwritten by new ones coming in.</p>
<p class="indent">In addition to local storage-capacity issues, remote connections used to transmit log data also could be affected. You can easily imagine how the bandwidth of such communication could decrease abruptly or completely disconnect. In such cases, it’s the device’s responsibility to decide whether collected data is temporarily stored at a local destination until the connection is reestablished and the remote location is able to catch up again, or if monitoring data should be discarded at least partially or even completely.</p>
<p class="indent">Further, your logging applications could unpleasantly run into unknown bugs, or adversaries might attack your monitoring system on purpose. Both scenarios could result in crashes of critical system parts and leave you blind in terms of monitoring data. Even though your device can’t recover from all possible situations, automatically restarting monitoring services after crashes and locally logging events regarding the eventual loss of monitoring capabilities can be worthwhile.</p>
<h4 class="h4" id="ch00lev2_157"><strong><em>Central Log Analysis and Management</em></strong></h4>
<p class="noindent">In many use cases, having a central storage location for monitoring data as well as the analysis and correlation of information from the whole device population is of great value. Among other advantages, this approach allows you to react to security-related events in the field within a short time frame. If an attacker is messing with critical configuration or system files, you might want to know that as soon as possible. This approach also enables you to include a long history of device log data into current analyses, and once the data has been transmitted, on-device manipulation or destruction of log information would become obvious.</p>
<p class="indent">However, implementing the second row of the logging architecture shown in <a href="ch12.xhtml#ch12fig01">Figure 12-1</a> is all but simple. One challenge in (I)IoT scenarios can <span epub:type="pagebreak" id="page_231"/>be the scalability of the central monitoring system and the availability of corresponding analysis capacities. Of course, this depends on the size of your device populations. While a few thousand products might be manageable, scalability gains center stage when monitoring a six-digit number of devices or even more. This requires not only a vast amount of central storage capacities but also people and algorithms that sift through all the data to identify unexpected device behavior, emerging malicious activities, or indicators of compromise (IoCs).</p>
<p class="indent">Systems used for this purpose are often known as <em>security information and event management (SIEM)</em> because they collect event data relevant for security monitoring and provide a means to find the proverbial needle in the haystack. Examples of such analysis platforms, open source or commercial, include the Elastic Stack, Graylog, and Splunk, just to name a few. While big data analytics and artificial intelligence can provide strong support for this task, in many cases, judgment and eventual manual investigation by a human expert is necessary.</p>
<p class="indent">As explained in <a href="ch01.xhtml#ch01">Chapter 1</a>, every secure product life cycle has to establish some kind of incident- and vulnerability-response processes. Make sure that the teams operating the SIEM system have a strong connection to the product development and management teams, which will enable you to gain efficiency in your incident and vulnerability handling.</p>
<p class="indent">With all the advantages of central monitoring systems and processes, don’t forget to critically assess which data you <em>really</em> need for your chosen monitoring approach. Piling up stacks of unnecessary data only makes your solution inefficient and could lead to conflicts with the European GDPR or similar laws, especially if your database contains personally identifiable information (PII).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you’re not familiar with the legal restrictions of PII collection, thoroughly acquaint yourself with that topic. Even rather “technical” data like IP and MAC addresses might be traced back to natural persons and, therefore, require special treatment or should not be collected at all.</em></p>
</div>
<h3 class="h3" id="ch00lev1_99"><strong>Case Study: Logging Events on an STM32MP157F Device</strong></h3>
<p class="noindent">This case study presents typical tools and configurations to extract monitoring data from a Linux-based embedded system like an STM32MP157F-DK2 board.</p>
<h4 class="h4" id="ch00lev2_158"><strong><em>User-Session Monitoring with journald</em></strong></h4>
<p class="noindent">Linux systems that run <span class="literal">systemd</span>, like my STM32MP157F-DK2 firmware does, come with the <span class="literal">journald</span> tool, which collects valuable information about basic system processes.</p>
<p class="indent">For example, <a href="ch12.xhtml#ch12list01">Listing 12-1</a> shows a series of log entries extracted from <span class="literal">journalctl</span> by using <span class="literal">grep logind</span>.</p>
<pre class="pre"><span epub:type="pagebreak" id="page_232"/># <span class="codestrong1">journalctl | grep logind</span>&#13;
...&#13;
Apr 28 21:07:31 stm32mp1 systemd-logind[650]: New session c1 of user root.&#13;
Apr 28 21:13:51 stm32mp1 systemd-logind[650]: Session c1 logged out. ...&#13;
Apr 28 21:13:51 stm32mp1 systemd-logind[650]: Removed session c1.&#13;
Apr 28 22:54:57 stm32mp1 systemd-logind[650]: New session c2 of user root.&#13;
Apr 28 22:55:10 stm32mp1 systemd-logind[650]: Session c2 logged out. ...&#13;
Apr 28 22:55:10 stm32mp1 systemd-logind[650]: Removed session c2.&#13;
May 14 13:26:18 stm32mp1 systemd-logind[650]: New session c3 of user lservice.&#13;
May 14 13:39:24 stm32mp1 systemd-logind[650]: Removed session c3.&#13;
May 27 11:58:58 stm32mp1 systemd-logind[650]: New session c4 of user root.</pre>
<p class="list-title" id="ch12list01"><em>Listing 12-1: Typical</em> <span class="codeitalic1">journald</span> <em>entries for user sessions</em></p>
<p class="indent">The logs clearly show that the root user had two sessions on April 28 and that the local service user <span class="literal">lservice</span> was logged in for around 13 minutes on May 14. If this doesn’t correlate with an official inspection by a technician from your company, it might be an indication of unauthorized access.</p>
<p class="indent">The <span class="literal">journald</span> daemon can run in several modes, two of which are <em>volatile</em> and <em>persistent</em>. While the first option stores journal data only until the system is rebooted, the second one makes <span class="literal">journald</span> store its log data under <em>/var/log/ journal</em> in a persistent way, which can be helpful for forensics. You can set the corresponding <span class="literal">Storage=persistent</span> option in its configuration file <em>/etc/ systemd/journald.conf</em>.</p>
<p class="indent">Further configuration parameters like <span class="literal">SystemMaxUse=</span> and <span class="literal">RuntimeMaxUse=</span> as well as <span class="literal">SystemKeepFree=</span> and <span class="literal">RuntimeKeepFree=</span> determine the limits of journal file sizes for on-disk and in-memory storage, respectively, so critical situations caused by too much memory consumption of logfiles can be avoided.</p>
<h4 class="h4" id="ch00lev2_159"><strong><em>Kernel Event Monitoring with auditd</em></strong></h4>
<p class="noindent">The Linux kernel provides an audit framework that collects information about potentially security-relevant events happening within the kernel. It’s the same framework that’s used by MAC systems like SELinux or AppArmor to watch and restrict access to system resources, as described in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>
<p class="indent">The <span class="literal">auditd</span> user-space tool builds upon this framework and enables the persistent storage of security events in a device’s nonvolatile memory.</p>
<h5 class="h5" id="ch00lev3_49"><strong>Installation</strong></h5>
<p class="noindent">If you successfully installed AppArmor or another popular MAC system on your device, the audit framework is probably already up and running. Otherwise, you can set <span class="literal">CONFIG_AUDIT=y</span> within your Linux kernel’s configuration to enable it.</p>
<p class="indent">The <span class="literal">meta-oe</span> layer for Yocto contains the recipe to install the <span class="literal">auditd</span> tool from <em>meta-oe/recipes-security/audit</em>. It can be simply added to your image by setting <span class="literal">IMAGE_INSTALL += "auditd"</span>. After booting your system with the newly <span epub:type="pagebreak" id="page_233"/>installed software, you should see that your system now contains the <em>/var/ log/audit/audit.log</em> file, which is the default place to persistently store kernel audit data.</p>
<h5 class="h5" id="ch00lev3_50"><strong>Customization</strong></h5>
<p class="noindent">The audit framework is a powerful tool with deep access to system processes, so it’s important to explicitly specify the kind of events you want to monitor. You can use <span class="literal">auditctl</span> to add watch rules to a running <span class="literal">auditd</span> service, as shown in <a href="ch12.xhtml#ch12list02">Listing 12-2</a>.</p>
<pre class="pre"># <span class="codestrong1">auditctl -D</span>&#13;
No rules&#13;
# <span class="codestrong1">auditctl -w /etc/passwd -p rwa -k users_credentials</span>&#13;
# <span class="codestrong1">auditctl -l</span>&#13;
-w /etc/passwd -p rwa -k users_credentials</pre>
<p class="list-title" id="ch12list02"><em>Listing 12-2: Adding audit rules with</em> <span class="codeitalic1">auditctl</span></p>
<p class="indent">The <span class="literal">-D</span> parameter removes all currently active rules. The second command in <a href="ch12.xhtml#ch12list02">Listing 12-2</a> installs a rule that monitors the <em>/etc/passwd</em> file (<span class="literal">-w /etc/ passwd</span>) for read (<span class="literal">r</span>) and write (<span class="literal">w</span>) access as well as file attribute changes (<span class="literal">a</span>). The <span class="literal">-k</span> option allows for adding an arbitrary key string that gives the rule a certain meaning and accelerates log searching at a later time.</p>
<p class="indent">However, the rules set by <span class="literal">auditctl</span> are available only until the system performs a reboot. To install watch rules persistently, you have to add them to the <em>/etc/audit/audit.rules</em> file. As shown in <a href="ch12.xhtml#ch12list03">Listing 12-3</a>, the rules in this file are actually equal to the command line calls to <span class="literal">auditctl</span>, just without the tool name at the beginning.</p>
<pre class="pre">## SSH daemon configuration&#13;
-w /etc/default/dropbear -p wa -k ssh_config&#13;
-w /etc/dropbear -p rwa -k ssh_config&#13;
&#13;
## Users and credentials&#13;
-w /etc/passwd -p rwa -k users_credentials&#13;
-w /etc/shadow -p rwa -k users_credentials&#13;
&#13;
## auditd configuration&#13;
-w /etc/audit/ -p wa -k auditd_config&#13;
&#13;
## Audit management tools&#13;
-w /sbin/auditctl -p x -k audit_tools&#13;
-w /sbin/auditd -p x -k audit_tools</pre>
<p class="list-title" id="ch12list03"><em>Listing 12-3: An example of persistent audit rules</em></p>
<p class="indent">File-access monitoring can be useful in a variety of scenarios. For example, if you enable SSH access to your device based on the popular <span class="literal">dropbear</span> <span epub:type="pagebreak" id="page_234"/>daemon, it might be reasonable to watch for changes of the corresponding configuration file, which—if manipulated—could potentially open a backdoor to your device. Further, access to <em>/etc/passwd</em> and <em>/etc/shadow</em> are common indicators for malicious activities. Advanced attackers might also target the audit system itself, which makes the files containing audit rules and the audit tools valid targets to watch.</p>
<p class="indent">After enabling the rules, you can use the <span class="literal">ausearch</span> tool to filter audit data, as demonstrated in <a href="ch12.xhtml#ch12list04">Listing 12-4</a> for the installed SSH configuration watch rules.</p>
<pre class="pre"># <span class="codestrong1">ausearch -k ssh_config</span>&#13;
time-&gt;Thu Apr 28 23:12:57 ...&#13;
type=PROCTITLE msg=audit(1651187577.140:366): proctitle=...&#13;
type=SYSCALL msg=audit(1651187577.140:366): arch=40000028 syscall=290 ...&#13;
... uid=0 gid=0 ... comm="auditctl" exe="/sbin/auditctl" ...&#13;
type=CONFIG_CHANGE ... op=add_rule key="ssh_config" ...&#13;
# <span class="codestrong1">touch /etc/default/dropbear</span>&#13;
# <span class="codestrong1">ausearch -k ssh_config</span>&#13;
...&#13;
time-&gt;Thu Apr 28 23:24:47 ...&#13;
type=PROCTITLE msg=audit(1651188287.600:379): proctitle=...&#13;
type=PATH msg=audit(1651188287.600:379): ... name="/etc/default/dropbear" ...&#13;
type=PATH msg=audit(1651188287.600:379): ... name="/etc/default/" ...&#13;
type=CWD msg=audit(1651188287.600:379): cwd="/home/root"&#13;
type=SYSCALL msg=audit(1651188287.600:379): arch=40000028 syscall=322 ...&#13;
... uid=0 gid=0 ... comm="touch" exe="/bin/touch.coreutils" ...</pre>
<p class="list-title" id="ch12list04"><em>Listing 12-4: Using</em> <span class="codeitalic1">ausearch</span> <em>to find suspicious activities</em></p>
<p class="indent">The first call to <span class="literal">ausearch</span> with the <span class="literal">ssh_config</span> key reports that a new rule with this key was added by the <span class="literal">auditctl</span> tool. Afterward, I just touched (didn’t even manipulate) the configuration file located at <em>/etc/default/dropbear</em>. The second call to <span class="literal">ausearch</span> clearly states that the root user (<span class="literal">uid=0 gid=0</span>) used the <span class="literal">touch</span> tool to access the file <em>/etc/default/dropbear</em> while being in the <em>/home/ root</em> directory only 12 minutes after the new rule was loaded. This example shows the beneficial strengths of having monitoring data available for critical system files.</p>
<p class="indent">Besides watching file access, <span class="literal">auditd</span> is also able to intercept syscalls. However, since such rules directly affect performance, you should use them only if you consider them absolutely necessary.</p>
<h4 class="h4" id="ch00lev2_160"><strong><em>Service and Application Event Logging</em></strong></h4>
<p class="noindent">While <span class="literal">auditd</span> provides powerful services to monitor kernel behavior and to log accesses to system resources, it doesn’t capture an important part of your device: specific events generated by services and applications.</p>
<h5 class="h5" id="ch00lev3_51"><span epub:type="pagebreak" id="page_235"/><strong>Logging Application Events with syslog</strong></h5>
<p class="noindent">Within my STM32MP157F firmware, BusyBox implements a minimal version of <span class="literal">syslogd</span> that some applications use to store log information in the <em>/var/log/messages</em> file. One example for such an application is the lightweight <span class="literal">dropbear</span> SSH daemon.</p>
<p class="indent"><a href="ch12.xhtml#ch12list05">Listing 12-5</a> shows corresponding log messages after several SSH login attempts.</p>
<pre class="pre"># <span class="codestrong1">grep /var/log/messages -e dropbear</span>&#13;
Apr 29 09:06:38 stm32mp1 authpriv.info dropbear[819]:&#13;
  Child connection from ::ffff:192.168.13.17:37214&#13;
Apr 29 09:06:40 stm32mp1 authpriv.notice dropbear[819]:&#13;
  pam_unix(dropbear:auth): ... rhost=::ffff:192.168.13.17  user=rservice&#13;
Apr 29 09:06:42 stm32mp1 authpriv.warn dropbear[819]:&#13;
  pam_authenticate() failed, rc=7, Authentication failure&#13;
Apr 29 09:06:42 stm32mp1 authpriv.warn dropbear[819]:&#13;
<span class="ent">➊</span> Bad PAM password attempt for 'rservice' from ::ffff:192.168.13.17:37214&#13;
Apr 29 09:06:51 stm32mp1 authpriv.notice dropbear[819]:&#13;
<span class="ent">➋</span> PAM password auth succeeded for 'rservice' from ::ffff:192.168.13.17:37214&#13;
Apr 29 09:07:01 stm32mp1 authpriv.info dropbear[819]:&#13;
<span class="ent">➌</span> Exit (rservice) from &lt;::ffff:192.168.13.17:37214&gt;: Disconnect received&#13;
Apr 29 09:07:11 stm32mp1 authpriv.info dropbear[825]:&#13;
  Child connection from ::ffff:192.168.13.17:48656&#13;
...&#13;
Apr 29 09:07:16 stm32mp1 authpriv.warn dropbear[825]:&#13;
  Bad PAM password attempt for 'root' from ::ffff:192.168.13.17:48656&#13;
...&#13;
Apr 29 09:07:20 stm32mp1 authpriv.warn dropbear[825]:&#13;
  Bad PAM password attempt for 'root' from ::ffff:192.168.13.17:48656&#13;
...&#13;
Apr 29 09:07:23 stm32mp1 authpriv.warn dropbear[825]:&#13;
  Bad PAM password attempt for 'root' from ::ffff:192.168.13.17:48656&#13;
Apr 29 09:07:23 stm32mp1 authpriv.info dropbear[825]:&#13;
<span class="ent">➍</span> Exit before auth from ...: (user 'root', 3 fails): Exited normally</pre>
<p class="list-title" id="ch12list05"><em>Listing 12-5: SSH login attempts logged by</em> <span class="codeitalic1">syslogd</span></p>
<p class="indent">The log data first shows a <span class="literal">Bad PAM password attempt</span> <span class="ent">➊</span> for the user <span class="literal">rservice</span>, shortly followed by a successful <span class="literal">PAM password auth</span> <span class="ent">➋</span> for the same user. The established session is closed only 10 seconds later <span class="ent">➌</span>. Further, three failed login attempts for the root user can be seen that finally make the SSH daemon quit the login process <span class="ent">➍</span>. Such log data can be extremely useful for detecting brute-force attacks on SSH accounts or login attempts for unusual users and from unexpected IP addresses.</p>
<h5 class="h5" id="ch00lev3_52"><span epub:type="pagebreak" id="page_236"/><strong>Using Application-Specific Logfiles</strong></h5>
<p class="noindent">Some applications do not rely on <span class="literal">syslogd</span>’s services by default, but rather create and manage their own logfiles. One example is the <span class="literal">apache2</span> web server running on my STM32MP157F-DK2 board. Its logfiles <em>access_log</em> and <em>error_log</em> can be found under <em>/var/log/apache2/</em>. <a href="ch12.xhtml#ch12list06">Listing 12-6</a> shows sample HTTP requests from the IP address 192.168.13.17.</p>
<pre class="pre"># <span class="codestrong1">cat /var/log/apache2/access_log</span>&#13;
...&#13;
192.168.13.17 - - [29/Apr/...09:35:46 +0000] "GET / HTTP/1.1" 200 45&#13;
192.168.13.17 - - [29/Apr/...09:35:58 +0000] "GET /admin/ HTTP/1.1" 404 196&#13;
192.168.13.17 - - [29/Apr/...09:36:27 +0000] "GET /config/ HTTP/1.1" 404 196&#13;
192.168.13.17 - - [29/Apr/...09:37:29 +0000] "GET /cgi-bin/ HTTP/1.1" 404 196&#13;
192.168.13.17 - - [29/Apr/...09:38:33 +0000] "GET / HTTP/1.1" 200 45&#13;
...</pre>
<p class="list-title" id="ch12list06"><em>Listing 12-6: Sample access log entries from</em> <span class="codeitalic1">apache2</span></p>
<p class="indent">This information provides not only the history of successfully delivered web pages by the web server but also requests that might reveal adversarial activities typical for the reconnaissance phase. Here, an attacker checked the availability of the <em>/admin/</em>, <em>/config/</em>, and <em>/cgi-bin/</em> subdirectories. Again, early detection can prevent later attacks and damages.</p>
<h4 class="h4" id="ch00lev2_161"><strong><em>Logging to a Remote Server</em></strong></h4>
<p class="noindent">All the previously mentioned tools operate locally on a device, which might be sufficient for device-specific forensic purposes whenever you have physical or remote access to it. However, as suggested earlier in this chapter, the central collection of log data can be beneficial in many ways. Although the setup of a central monitoring infrastructure goes beyond the device-centered focus of this book, I would like to point out that all the data collected by these tools can be transmitted to remote locations.</p>
<p class="indent">For example, the <span class="literal">journald</span> daemon can be extended by a service called <span class="literal">systemd-journal-remote</span> for logging data to a remote server. The <span class="literal">audisp</span> tool and its <span class="literal">audisp-remote</span> plug-in can enable central log aggregation for data collected by the Linux audit framework and <span class="literal">auditd</span>. Alternatively, specific tools like <span class="literal">auditbeat</span> can be used to send audit data to an Elastic Stack, for example. Further, <span class="literal">rsyslog</span> and <span class="literal">syslog-ng</span> are modern <span class="literal">syslog</span> implementations that allow for logging to remote locations. Finally, some of these tools are even interoperable, which means that <span class="literal">journald</span>, for example, can be configured to forward log data to a <span class="literal">syslog</span> daemon, which in turn can take care of remote transmission.</p>
<h3 class="h3" id="ch00lev1_100"><span epub:type="pagebreak" id="page_237"/><strong>Summary</strong></h3>
<p class="noindent">It’s simple to request that a device should aggregate and transmit system data and event information to a central server. However, when you start implementing such measures, you’ll encounter several obstacles to overcome, from legal issues to device constraints to the human resources necessary for continuously operating security-monitoring services.</p>
<p class="indent">In this chapter, I discussed typical information that can be useful for security monitoring of embedded systems, from user sessions and their interactions to network traffic metadata to system crashes and error messages. Clearly, the more you want to monitor, the more on-device and server resources you need. A risk-based approach is absolutely reasonable to find a compromise between full device transparency and minimal resource usage for your specific product.</p>
<p class="indent">System monitoring is an essential layer within your defense-in-depth strategy because even if all the protection measures you implement fail, monitoring might enable you to detect ongoing attacks and anomalies. Monitoring can make the difference between getting away with a black eye and ruining your product’s and your company’s reputation.<span epub:type="pagebreak" id="page_238"/></p>
</div></body></html>