<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>9 USEFUL FPGA PRIMITIVES</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:d7b1a4c0-49cb-46f7-b6a4-8fcfa081f00a" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch9" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch9">
<span class="CN"><span aria-label=" Page 185. " epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">USEFUL FPGA PRIMITIVES</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="COS">So far, you’ve learned about the two most fundamental FPGA components: the LUT and the flip-flop. These general-purpose components are the main workhorses in your FPGA, but there are also other dedicated components that are commonly used in FPGA designs for more specialized tasks. These components are usually called <i>primitives</i>, but they’re also sometimes referred to as <i>hard IP</i> or <i>cores</i>.</p>
<p class="TX">Working with primitives helps you get the most out of your FPGA. In fact, a lot of modern FPGA development revolves around linking together these pre-existing primitives, with custom code added as needed for application-specific logic. In this chapter, we’ll explore three important primitives: the block RAM (BRAM), the digital signal processor (DSP) block, and the phase-locked loop (PLL). You’ll learn what role each one plays within an FPGA and see how to create them through your Verilog or VHDL code, or with assistance from your build tools.</p>
<p class="TX"><span aria-label=" Page 186. " epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/>The primitives we’ll discuss are especially important on higher-end FPGAs, more advanced than the iCE40 FPGAs we’ve focused on so far. With these feature-rich FPGAs, the companion GUI software has become a critical piece of the build process. These GUIs are more complicated than the iCEcube2 tool we’ve been working with, and a large part of the complexity stems from the creation and wiring up of these primitives. Once you have an understanding of how the primitives work, however, you’ll be better equipped to start working with these more advanced tools and to take full advantage of the common built-in features of professional-grade FPGAs.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h-114"/><samp class="SANS_Futura_Std_Bold_B_11">How to Create Primitives</samp></h2>
<p class="TNI1">There are a few different ways to create an FPGA primitive. Up to this point, we’ve been writing Verilog or VHDL and letting the synthesis tools decide for us how to translate that code into primitives. We trust the tools to understand when we want to create a flip-flop or a LUT. This is called <i>inference</i>, since we’re letting the tools infer (or make an educated guess about) what we want based on our code.</p>
<p class="TX">In general, the tools are able to understand our intentions quite well. However, there are some primitives that the synthesis tools won’t be able to infer. To create those, you need to use another method: you can either explicitly instantiate the primitive in your code or use the GUI built into most synthesis tools to automate the creation process.</p>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H2" id="sec2"><span id="h-115"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instantiation</samp></h3>
<p class="TNI1"><i>Instantiation</i> is the creation of a primitive from a code template written by the FPGA manufacturer. When you instantiate a primitive component, it looks like you’re instantiating a Verilog or VHDL module—but in this case, the module you’re instantiating isn’t one you’ve created. Rather, it’s built into the tools for your specific FPGA. The actual module code behind these primitives is often unavailable to view; it’s part of the secret sauce that the FPGA vendors like to keep to themselves.</p>
<p class="TX">Let’s look at an example of how to instantiate a block RAM (we’ll talk more about these primitives later in the chapter):</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>RAMB18E1 #(
  // Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE"
  .RDADDR_COLLISION_HWCONFIG("DELAYED_WRITE"),
  // Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
  .SIM_COLLISION_CHECK("ALL"),
  // DOA_REG, DOB_REG: Optional output register (0 or 1)
  .DOA_REG(0),
  .DOB_REG(0),
  // INITP_00 to INITP_07: Initial contents of parity memory array
.INITP_00(256'h0000000000000000000000000000000000000000000000000000000000000000),
<var>--snip--</var><span aria-label=" Page 187. " epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/>
.INIT_3F(256'h0000000000000000000000000000000000000000000000000000000000000000),
  // INIT_A, INIT_B: Initial values on output ports
  .INIT_A(18'h00000),
   .INIT_B(18'h00000),
  // Initialization File: RAM initialization file
  .INIT_FILE("NONE"),
  // RAM Mode: "SDP" or "TDP"
  .RAM_MODE("TDP"),
  // READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
  .READ_WIDTH_A(0),                    // 0-72
  .READ_WIDTH_B(0),                    // 0-18
  .WRITE_WIDTH_A(0),                   // 0-18
  .WRITE_WIDTH_B(0),                   // 0-72
  // RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
  .RSTREG_PRIORITY_A("RSTREG"),
  .RSTREG_PRIORITY_B("RSTREG"),
  // SRVAL_A, SRVAL_B: Set/reset value for output
  .SRVAL_A(18'h00000),
  .SRVAL_B(18'h00000),
  // Simulation Device: Must be set to "7SERIES" for simulation behavior
  .SIM_DEVICE("7SERIES"),
  // WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
  .WRITE_MODE_A("WRITE_FIRST"),
  .WRITE_MODE_B("WRITE_FIRST")
)
RAMB18E1_inst (
  // Port A Data: 16-bit (each) output: Port A data
  .DOADO(DOADO), <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>             // 16-bit output: A port data/LSB data
  .DOPADOP(DOPADOP),            // 2-bit output: A port parity/LSB parity
  // Port B Data: 16-bit (each) output: Port B data
  .DOBDO(DOBDO),                // 16-bit output: B port data/MSB data
  .DOPBDOP(DOPBDOP),            // 2-bit output: B port parity/MSB parity
  // Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals
  // (read port when RAM_MODE="SDP")
  .ADDRARDADDR(ADDRARDADDR),    // 14-bit input: A port address/Read address
  .CLKARDCLK(CLKARDCLK),        // 1-bit input: A port clock/Read clock
<var>--snip--</var></code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>RAMB18E1_inst : RAMB18E1
generic map (
  -- Address Collision Mode: "PERFORMANCE" or "DELAYED_WRITE"
  RDADDR_COLLISION_HWCONFIG =&gt; "DELAYED_WRITE",
  -- Collision check: Values ("ALL", "WARNING_ONLY", "GENERATE_X_ONLY" or "NONE")
  SIM_COLLISION_CHECK =&gt; "ALL",
  -- DOA_REG, DOB_REG: Optional output register (0 or 1)
  DOA_REG =&gt; 0,
  DOB_REG =&gt; 0,
  -- INITP_00 to INITP_07: Initial contents of parity memory array
  INITP_00 =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",
<var>--snip--</var>
  INIT_3F =&gt; X"0000000000000000000000000000000000000000000000000000000000000000",<span aria-label=" Page 188. " epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>
  -- INIT_A, INIT_B: Initial values on output ports
  INIT_A =&gt; X"00000",
  INIT_B =&gt; X"00000",
  -- Initialization File: RAM initialization file
  INIT_FILE =&gt; "NONE",
  -- RAM Mode: "SDP" or "TDP"
  RAM_MODE =&gt; "TDP",
  -- READ_WIDTH_A/B, WRITE_WIDTH_A/B: Read/write width per port
  READ_WIDTH_A =&gt; 0,             -- 0-72
  READ_WIDTH_B =&gt; 0,             -- 0-18
  WRITE_WIDTH_A =&gt; 0,            -- 0-18
  WRITE_WIDTH_B =&gt; 0,            -- 0-72
  -- RSTREG_PRIORITY_A, RSTREG_PRIORITY_B: Reset or enable priority ("RSTREG" or "REGCE")
  RSTREG_PRIORITY_A =&gt; "RSTREG",
  RSTREG_PRIORITY_B =&gt; "RSTREG",
  -- SRVAL_A, SRVAL_B: Set/reset value for output
  SRVAL_A =&gt; X"00000",
  SRVAL_B =&gt; X"00000",
  -- Simulation Device: Must be set to "7SERIES" for simulation behavior
  SIM_DEVICE =&gt; "7SERIES",
  -- WriteMode: Value on output upon a write ("WRITE_FIRST", "READ_FIRST", or "NO_CHANGE")
  WRITE_MODE_A =&gt; "WRITE_FIRST",
  WRITE_MODE_B =&gt; "WRITE_FIRST"
)
port map (
  -- Port A Data: 16-bit (each) output: Port A data
  DOADO =&gt; DOADO, <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>             -- 16-bit output: A port data/LSB data
  DOPADOP =&gt; DOPADOP,            -- 2-bit output: A port parity/LSB parity
  -- Port B Data: 16-bit (each) output: Port B data
  DOBDO =&gt; DOBDO,                -- 16-bit output: B port data/MSB data
  DOPBDOP =&gt; DOPBDOP,            -- 2-bit output: B port parity/MSB parity
  -- Port A Address/Control Signals: 14-bit (each) input: Port A address and control signals
  -- (read port when RAM_MODE="SDP")
  ADDRARDADDR =&gt; ADDRARDADDR,    -- 14-bit input: A port address/Read address
  CLKARDCLK =&gt; CLKARDCLK,        -- 1-bit input: A port clock/Read clock
<var>--snip--</var></code></pre>
<p class="TX">This code is an example of instantiation of a RAMB18E1 component (a type of block RAM) from an AMD FPGA. The code makes the block RAM available for use by wiring its internal signals to signals external to the block RAM: for example, it wires the block RAM’s internal <samp class="SANS_TheSansMonoCd_W5Regular_11">DOADO</samp> signal, a 16-bit output, to an external signal of the same name <span aria-label="annotation1" class="CodeAnnotation">❶</span>. I’ve omitted many more lines of code that make similar connections. It’s not important that you understand the details of this code; it’s just to demonstrate what instantiation looks like. Clearly a block RAM is a complicated component, with many bells and whistles available to you. Instantiation specifies every single input and output of the primitive and allows you to set them exactly as you want. However, it also requires that you have a deep knowledge of the primitive being instantiated. If you connect it improperly, it won’t work as intended.</p>
<p class="TX">If you wanted to, it would be possible to instantiate, rather than infer, even a simple component like a flip-flop. Here’s what AMD’s Verilog <span aria-label=" Page 189. " epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/>template looks like for instantiating a single flip-flop (which AMD calls an FDSE):</p>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp></p>
<pre><code>FDSE #(
  .INIT(1'b0) // Initial value of register (1'b0 or 1'b1)
) FDSE_inst (
  .Q(Q),      // 1-bit data output
  .C(C),      // 1-bit clock input
  .CE(CE),    // 1-bit clock enable input
  .S(S),      // 1-bit synchronous set input
  .D(D)       // 1-bit data input
);</code></pre>
<p class="Label"><samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp></p>
<pre><code>FDSE_inst : FDSE
generic map (
  INIT =&gt; '0') -- Initial value of register ('0' or '1')
port map (
  Q =&gt; Q,      -- Data output
  C =&gt; C,      -- Clock input
  CE =&gt; CE,    -- Clock enable input
  S =&gt; S,      -- Synchronous set input
  D =&gt; D       -- Data input
);</code></pre>
<p class="TX">Notice that this primitive has the normal connections we’d expect from a flip-flop, including the data output (<samp class="SANS_TheSansMonoCd_W5Regular_11">Q</samp>), the clock input (<samp class="SANS_TheSansMonoCd_W5Regular_11">C</samp>), the clock enable (<samp class="SANS_TheSansMonoCd_W5Regular_11">CE</samp>), and the data input (<samp class="SANS_TheSansMonoCd_W5Regular_11">D</samp>). After instantiating this flip-flop, you could then make use of these connections in your code. If you had to instantiate every single flip-flop in your entire FPGA, however, it would take quite a lot of code!</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>I found the templates for the RAM18E1 block RAM and the FDSE flip-flop in AMD’s online Libraries Guide, which contains the templates for all primitives throughout AMD FPGAs. Every FPGA manufacturer has a similar resource where you’ll find the instantiation templates for its primitives.</i></p>
<p class="TX">The benefit of instantiating a primitive is that it gives you exactly what you want. You don’t need to trust the synthesis tools to guess at what you’re trying to do. However, there are clearly some downsides. As you’ve just seen, instantiation takes more code than inference. It also requires you to wire up every connection correctly, or the design won’t function as intended. This means you need to understand the primitive at a deep level. Finally, each primitive needs to be instantiated using a dedicated template specific to your FPGA vendor, or sometimes specific to just a subset of devices within a family of FPGAs. For example, the RAMB18E1 block RAM component we instantiated earlier only exists on AMD FPGAs; Intel and Lattice FPGAs have their own block RAMs. Therefore, instantiation makes your code less portable than writing more generic Verilog or VHDL where the tools can <span aria-label=" Page 190. " epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>just infer the primitive based on which FPGA you’re targeting. Next, we’ll look at the alternative: using the GUI.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H2" id="sec3"><span id="h-116"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The GUI Approach</samp></h3>
<p class="TNI1">Every FPGA vendor has its own GUI or IDE for FPGA development, and that GUI will have a section allowing you to view the library of available primitives for your FPGA. You can select a primitive that you want to add to your project, and the tool will walk you through the process. Additionally, the GUI explains how the primitive works and what each setting controls. <a href="#fig9-1">Figure 9-1</a> shows an example of creating a block RAM using the Lattice Diamond GUI. As mentioned in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, this is Lattice’s IDE for working with higher-end FPGAs with features like the primitives discussed in this chapter. (The iCEcube2 IDE doesn’t have a GUI for creating primitives, since it’s designed to work primarily with simpler FPGAs.)</p>
<figure class="IMG"><img alt="" class="img80" id="fig9-1" src="../images/Figure9-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: Instantiating a block RAM with a GUI</samp></p></figcaption>
</figure>
<p class="TX">The block diagram on the left side of the window visually demonstrates the block RAM’s inputs and outputs. In the configuration section on the right, it’s clear which selections for the primitive are mutually exclusive. These are represented with radio buttons, like Initialize to All 0’s or Initialize to All 1’s. We can also tell which options can be enabled or <span aria-label=" Page 191. " epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>disabled. These are represented by checkboxes, like Enable Output Register or Enable Output ClockEn. In addition, there’s a convenient Help button in the bottom-right corner that can guide you through some of these decisions if you’re unsure what to pick.</p>
<p class="TX">Once you’ve configured a primitive with a GUI, you’ll get an instantiation template that you can drop into your Verilog or VHDL code, much like the one we looked at in the previous section. The template will be customized to the exact settings that you picked in the GUI so you can wire up your primitive without having to make any guesses about how to configure it.</p>
<p class="TX">Compared to direct instantiation, the GUI method is more approachable for beginners. You’re much less likely to make a mistake using the GUI, since you have the menus to guide you, but you can still control exactly what you get, just like with instantiation. There is an important downside to this approach, however. If you need to change a setting in your primitive, then you need to open the GUI and run through the whole process again. This might not sound like a big deal, but if your design features many primitives created using a GUI, making adjustments can become quite tedious and time-consuming.</p>
</section>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h-117"/><samp class="SANS_Futura_Std_Bold_B_11">The Block RAM</samp></h2>
<p class="TNI1">A <i>block RAM (BRAM)</i> is a dedicated memory storage component built into your FPGA. Next to LUTs and flip-flops, block RAMs are the third most common FPGA primitive. We touched briefly on block RAMs in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, when we discussed common memory modules like RAMs and FIFOs. As I mentioned in that chapter, when you need a memory over a certain size, it will be created using a block RAM instead of flip-flops.</p>
<p class="TX">Creating memory for storing data is an incredibly common task in FPGAs. You might use a block RAM for storing read-only data, like calibration values, or you might regularly write data to a block RAM from an off-chip device like an analog-to-digital converter (ADC) and then read from it later. Block RAMs are also commonly used to buffer data between a producer and a consumer, including when sending data between clock domains. In this case, the block RAM can be configured as a FIFO, with features specially designed to handle the metastability issues that arise when crossing between domains (we discussed how you can transmit data across cross clock domains back in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>).</p>
<p class="TX">The number of block RAMs available, and the specific features of each block RAM, will vary from FPGA to FPGA and vendor to vendor. You should always consult your FPGA’s datasheet and memory guide for details particular to your model. As an example, <a href="#fig9-2">Figure 9-2</a> shows a datasheet highlighting the block RAMs on Intel’s Cyclone V line of FPGAs.</p><span aria-label=" Page 192. " epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img100" id="fig9-2" src="../images/Figure9-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Block RAMs on the Cyclone V product line</samp></p></figcaption>
</figure>
<p class="TX">Intel refers to block RAMs as <i>memory blocks</i>. The first of the highlighted lines in the datasheet is telling us how many of these memory blocks are available on each of three FPGA models: 176 on the 5CEA2 FPGA, 308 on the 5CEA4, and 446 on the 5CEA5 part. The next line on the datasheet shows the total number of kilobits (Kb) of block RAM storage available. Each memory block holds 10Kb (hence the <i>M10K</i> in the name), so there are 1,760Kb of BRAM storage on the 5CEA2 FPGA, 3,080Kb on the 5CEA4, and 4,460Kb on the 5CEA5.</p>
<p class="TX">You might be surprised by how little storage that really is. Even the largest amount, 4,460Kb, is less than a megabyte! Consider the fact that you can get a 32-gigabyte MicroSD card, which has thousands of times more storage space, for around $10, and you’ll start to appreciate that FPGAs aren’t designed for storing data in any significant quantity. Rather, block RAMs are there to buffer data on the FPGA for temporary usage. If you need to store large amounts of data, you’ll have to use an external chip to do that. MicroSD cards, DDR memory, SRAM, and flash memory are common examples of chips that an FPGA might interface to in order to expand its memory storage and retrieval capabilities.</p>
<p class="TX">You should also notice in <a href="#fig9-2">Figure 9-2</a> that block RAMs are the fourth item in the Cyclone V datasheet’s list of FPGA resources, after LEs, ALMs, and registers. Those are the terms that Intel uses to describe LUTs and flip-flops (LE stands for logic element and ALM for Adaptive Logic Module). While you may not always need many block RAMs for your application, this prime position in the datasheet highlights that block RAMs are often one of the most significant primitive components to take into consideration when choosing an FPGA.</p>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h-118"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Features and Limitations</samp></h3>
<p class="TNI1">There are some common features and some limitations that are helpful to keep in mind when working with block RAMs. First, block RAMs usually come in only one size on an FPGA; 16Kb per block RAM is common. This one-size-fits-all approach means that if you only need to use 4Kb out of the <span aria-label=" Page 193. " epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/>16Kb, you’ll still use up an entire block RAM primitive. There’s no way to divide a single block RAM component into multiple memories, and in that way, block RAMs can be limiting.</p>
<p class="TX">In other ways, however, block RAMs can be quite flexible. You can store data in whatever width you like: for example, with a 16Kb block RAM you can store data that’s 1 bit wide and 16,384 bits (2<sup>14</sup>) deep, or 8 bits wide and 2,048 deep, or 32 bits wide and 512 deep, among other possibilities. It’s also possible to create memories that are larger than a single block RAM. For example, if you needed to store 16 kilobytes (KB) of data, that would use up eight individual block RAMs (16Kb <span class="symbol">×</span> 8 = 16KB). The tools are smart enough to cascade the block RAMs and make them look like one large memory, rather than eight individual components that you need to index into individually.</p>
<p class="TX">Other common features include error detection and correction, where the block RAM has some extra bits reserved to detect and correct any errors that might occur within the memory itself (that is, when a 1 changes to a 0, or vice versa). If that happens in your memory, a value could be completely corrupted and produce very strange behavior when the FPGA tries to analyze it.</p>
<p class="TX">Error detection and correction are two separate but related processes: the FPGA can <i>detect</i> some number of bit errors and notify you about their presence, and, separately, it can automatically <i>correct</i> some number of bit errors. The number of bit errors that can be corrected is usually less than the number of bit errors that can be detected. The important thing here is that error detection and correction within a block RAM are performed automatically, without you having to do anything.</p>
<p class="TX">Many block RAMs can also be initialized to default values. This can be a useful feature if you need to store a large number of initial values or if you want to create read-only memory (ROM). Pushing those values to a block RAM rather than taking up flip-flops for data storage can be a valuable way to save resources. We touched on this idea back in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, when we were looking at parts of Verilog and VHDL that are synthesizable and not synthesizable. Even though reading from a file is normally not synthesizable—remember that there’s no filesystem on an FPGA unless you create it yourself—we can read data from files as part of the synthesis process to preload a block RAM with default values. Again, I recommend consulting the memory guide for your particular FPGA to find out which features it supports.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H2" id="sec6"><span id="h-119"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation</samp></h3>
<p class="TNI1">When using a block RAM in your design, I generally recommend inferring it. As you saw in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, when we create a two-dimensional memory element, the tools will easily recognize it. Whether or not this memory gets pushed to a block RAM depends on its size. Again, the synthesis tool is smart about this: it knows how many bits of memory you’re creating, and if it’s above some threshold, then it will be pushed to a block RAM. <span aria-label=" Page 194. " epub:type="pagebreak" id="pg_194" role="doc-pagebreak"/>Otherwise, the tool will just use flip-flops. For example, if you’re creating a memory that holds 16 bytes, it will likely be pushed to flip-flops. You only need 16 <span class="symbol">×</span> 8 = 128 bits of memory, so it doesn’t make much sense to use an entire 16Kb block RAM for this small quantity of data.</p>
<p class="TX">At which point the tools will start pushing memory to block RAMs instead of using flip-flops is highly dependent on the situation. To find out what your tool decided for a particular design, consult your utilization report after synthesis. Here’s an example:</p>
<pre><code><var>--snip--</var>
Number of registers:   1204 out of 84255 (1%)
<var>--snip--</var>
Number of LUT4s:       1925 out of 83640 (2%)
<var>--snip--</var>
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> Number of block RAMs:  3 out of 208 (1%)</code></pre>
<p class="TX">The utilization report lists the number of block RAMs required <span aria-label="annotation1" class="CodeAnnotation">❶</span>, just as it lists the number of flip-flops (registers) and LUTs (LUT4s, or four-input LUTs in this case). If you see that no block RAMs are being used, then your memory was inferred as flip-flops instead. As a reminder, I always recommend double-checking your utilization report to make sure the tools are inferring what you expect.</p>
<p class="TX">If you’re wary of trying to infer large memory elements, or you’re confused about which features you may or may not want to take advantage of in your block RAM, then creating it with a GUI is your best option. The GUI will guide you through the process, so for beginners it’s very helpful. Using the GUI is also the best way to ensure that you’re using a FIFO correctly when crossing clock domains, as it can help you handle the complexities involved.</p>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h2 class="H1" id="sec7"><span id="h-120"/><samp class="SANS_Futura_Std_Bold_B_11">The Digital Signal Processing Block</samp></h2>
<p class="TNI1"><i>Digital signal processing (DSP)</i> is a catch-all term for performing math-based operations on signals within a digital system. Often these math operations need to happen very fast and in parallel, which makes FPGAs an excellent tool for the job. Since DSP is such a common FPGA application, another kind of FPGA primitive, the <i>DSP block</i>, exists for this purpose. DSP blocks (also known as <i>DSP tiles</i>) specialize in performing mathematical operations, in particular <i>multiply–accumulate (MAC)</i>, which is an operation where a multiplication is followed by an addition. Before we look more closely at these primitives, however, it’s worth taking a step back to discuss the difference between analog and digital signals.</p>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Analog vs. Digital Signals</samp></h3>
<p class="TNI1">An <i>analog signal</i> is a continuous signal representing some physical measurement. A common example is the audio signal stored on a vinyl record <span aria-label=" Page 195. " epub:type="pagebreak" id="pg_195" role="doc-pagebreak"/>(a big black shiny thing that has music on it, sometimes seen in old movies or new hipster bars). The record is etched with a continuous groove that mirrors the continuous waveform of the audio. Then a record player reads that waveform with a needle and amplifies the resulting signal to play back the sound. The information is always analog; no conversion is needed.</p>
<p class="TX"><i>Digital signals</i>, on the other hand, aren’t continuous. Rather, they consist of discrete measurements at individual points in time, with gaps in between. A common example is the audio signal stored on a CD, where the sound is represented as a series of 1s and 0s. If you have enough discrete measurements, you can fill in the gaps to create a reasonably accurate approximation of an analog signal from those digital values. A CD player reads those digital values and rebuilds an analog waveform from them. The result is always an approximation of the original analog signal, however, which is why some audiophiles prefer the true analog signal of a record to digital media like CDs and MP3s.</p>
<p class="TX">Within your common FPGA fabric, like LUTs and flip-flops, data is represented digitally. So what do you do if you have some analog signal that you need to bring into your FPGA? This is the purpose of an ADC: it converts an analog signal into a digital one by <i>sampling</i> it, or recording its value, at discrete points in time. <a href="#fig9-3">Figure 9-3</a> shows how this works.</p>
<figure class="IMG"><img alt="" class="img80" id="fig9-3" src="../images/Figure9-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: Digital sampling of an analog signal</samp></p></figcaption>
</figure>
<p class="TX">The undulating line moving from left to right in the figure represents a continuous analog signal, and the dark points along that line represent the individual samples taken of that signal to convert it into a digital form. Notice that the samples are taken at regular time intervals. The frequency at which the analog signal is sampled is called the <i>sampling frequency</i> or <i>sampling rate</i>. The higher the sampling rate, the more accurately we can represent an analog signal, because it’s easier to connect the discrete dots into something that looks like the original waveform. However, a higher <span aria-label=" Page 196. " epub:type="pagebreak" id="pg_196" role="doc-pagebreak"/>sampling rate also means that we have more data that we have to process: each dot represents some number of bits of digital data, so the more dots you have, the more bits you’re working with.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H2" id="sec9"><span id="h-122"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Common DSP Tasks</samp></h3>
<p class="TNI1">FPGAs commonly take an analog signal as input, digitize it, and then do some math to process that digital data. As an example, let’s say we have an audio signal that we’ve sampled within our FPGA. Let’s furthermore assume that the recorded data was too quiet, so when it’s played back it’s hard to hear. How can we manipulate the digital signal such that the output volume is louder? One simple thing we can do is multiply every digital value by some constant, say 1.6. This is called applying <i>gain</i> to a signal. How would we accomplish this within an FPGA? It’s quite simple:</p>
<pre><code>gain_adjusted &lt;= input_signal * 1.6;</code></pre>
<p class="TX">We take the <samp class="SANS_TheSansMonoCd_W5Regular_11">input_signal</samp>, multiply every discrete digital value in that signal by <samp class="SANS_TheSansMonoCd_W5Regular_11">1.6</samp>, and store the result in the <samp class="SANS_TheSansMonoCd_W5Regular_11">gain_adjusted</samp> output. Here is where the DSP primitive comes into play. When we write code like this, the synthesis tools will see that we’re performing a multiplication operation and infer a DSP block for us automatically.</p>
<p class="TX">Applying gain to an input signal doesn’t require parallel processing. There’s only one multiplication operation per data sample, and the data samples can be processed one after the other. Often, however, you’ll need to perform many mathematical operations in parallel by running several DSP blocks simultaneously. A common example is creating a <i>filter</i>, a system that performs mathematical operations on a signal to reduce or enhance certain features of the input signal. A <i>low-pass filter (LPF)</i>, for instance, keeps the frequency components of a signal that are below some cutoff while reducing the frequencies that are above that cutoff, which can be useful for removing high-frequency noise from an input signal. Lowering the treble slider on your audio system is a real-world example of applying a low-pass filter, since it will reduce high frequencies within the audio. The details of implementing a digital LPF are beyond the scope of this book, but since it requires many multiplication and addition operations all occurring at the same time, FPGAs are well suited for the task.</p>
<p class="TX">Another example of parallel math that might be performed in an FPGA is processing video data to create a blur effect. Blurring video involves replacing individual pixel values with the average value of a group of neighboring pixels. This requires performing math on the many pixels in an image at the same time, and this must happen quickly since the video data consists of many images per second. An FPGA is very capable of performing these parallel mathematical operations using DSP blocks.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H2" id="sec10"><span id="h-123"/><span aria-label=" Page 197. " epub:type="pagebreak" id="pg_197" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Features</samp></h3>
<p class="TNI1">DSP blocks are versatile primitives, providing many features that facilitate different math operations. You won’t always need every feature for your application—most often, you’ll just be performing a multiplication or addition operation—but for more complicated scenarios, the DSP block can be set up to solve a wide range of problems. <a href="#fig9-4">Figure 9-4</a> provides a detailed look at a DSP block in an FPGA from AMD. Each manufacturer’s DSP primitive is a bit different, but this example is representative of the typical features available.</p>
<figure class="IMG"><img alt="" class="img100" id="fig9-4" src="../images/Figure9-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: Block diagram of a DSP primitive</samp></p></figcaption>
</figure>
<p class="TX">This diagram actually shows a simplified version of the DSP block. It’s not critical to understand the complete anatomy of the primitive, but it’s worth pointing out a few things. First, notice that this DSP block can take up to four inputs and has two outputs. This allows for more applications than simply multiplying two numbers together: for example, MAC, where the result of a multiplication is fed back into the input at the next clock cycle for an addition operation.</p>
<p class="TX">Toward the left-hand side of the block diagram, you can see a <i>pre-adder</i> block. This can be enabled if an addition operation is requested prior to another mathematical operation. To the right of this, near the middle of the diagram, is a circle with an X in it. This is the <i>multiplier</i>, which is the heart of the DSP block. It performs multiplication operations at very high speeds. To its right is a circle labeled ALU, short for <i>arithmetic logic unit</i>, which can perform more operations, like addition and subtraction. Finally, there are built-in output registers that can be enabled to sample the outputs and help meet timing at fast data rates.</p>
<p class="TX">Like the number of block RAMs, the number of DSP blocks available to you will vary from FPGA to FPGA. Some higher-end FPGAs have thousands of DSP blocks inside them; again, you should consult your FPGA’s datasheet for details specific to your model. As an example, <a href="#fig9-5">Figure 9-5</a> highlights the information on DSP blocks in the datasheet for Intel’s Cyclone V product line.</p><span aria-label=" Page 198. " epub:type="pagebreak" id="pg_198" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img100" id="fig9-5" src="../images/Figure9-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: DSP blocks on Cyclone V FPGAs</samp></p></figcaption>
</figure>
<p class="TX">Notice that the DSP block information comes just below the block RAM information, again pointing to the importance of these primitives in FPGA development. The 5CEA2 FPGA has 25 DSP blocks, but that increases to 66 for the 5CEA4 and 150 for the 5CEA5. Each DSP block has two multipliers, so on the second highlighted line we can see that there are twice as many 18 <span class="symbol">×</span> 18 multipliers (where 18 is the width of the inputs) as there are DSP blocks.</p>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>If there aren’t any DSP blocks available on your FPGA, that doesn’t mean you can’t perform these types of operations. Multiplication and addition operations will just be implemented with LUTs, rather than with dedicated DSP blocks. We’ll discuss this further in <a href="chapter10.xhtml">Chapter 10</a>.</i></p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="H2"><span id="sec11"/><span id="h-124"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation</samp></h3>
<p class="TNI1">As with block RAMs, I generally recommend using inference to create DSP blocks. Most of the multiplication operations you’ll need to do will require two inputs and one output, as you saw earlier when we applied gain to a signal. It’s simple enough to write the relevant code in Verilog or VHDL and let the tools handle the rest. Remember to check your synthesis report to ensure that you’re getting what you expect, but I’ve had good luck with the synthesis tools understanding my intent with addition and multiplication and pushing those operations to DSPs where relevant. The user guides for your particular FPGA will also provide you with suggestions on how to write your Verilog or VHDL code to help ensure the tools understand your intentions.</p>
<p class="TX">If you have more complicated needs for your DSP blocks, or if you want to explore all of the features and capabilities internal to them, then you should probably create them using a GUI to ensure you get what you want. <a href="#fig9-6">Figure 9-6</a> shows an example of creating a multiplier within the Lattice Diamond GUI.</p><span aria-label=" Page 199. " epub:type="pagebreak" id="pg_199" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img80" id="fig9-6" src="../images/Figure9-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: Creating a DSP block with a GUI</samp></p></figcaption>
</figure>
<p class="TX">One thing to highlight here is the Block Implementation drop-down menu. You can change this from DSP to LUT to use look-up tables rather than a DSP block to perform this multiplication operation. As mentioned previously, LUTs and DSPs are both capable of performing math operations, including multiplication. With the DSP block, however, you’ll save LUT resources, and you’ll be able to run the math operation at much faster clock rates, since you’ll be using a dedicated primitive highly optimized for math.</p>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h2 class="H1" id="sec12"><span id="h-125"/><samp class="SANS_Futura_Std_Bold_B_11">The Phase-Locked Loop</samp></h2>
<p class="TNI1">The <i>phase-locked loop (PLL)</i> is a primitive commonly used as the main clock generator for your entire FPGA. Very often, you’ll have an external clock chip that runs at some frequency. On some FPGAs, you can simply use that input clock to feed all of your synchronous logic directly, as we’ve done in this book’s projects. In this case, your logic frequency will be fixed at the frequency of whatever external clock you picked. But what happens if you need to change that frequency? Without a PLL, you would need to physically remove the external clock chip and replace it with a different component that generates the clock frequency you want to switch to. With a PLL, however, you can generate a different clock frequency inside your FPGA by changing a few lines of code, without requiring a new external component.</p>
<p class="TX">PLLs also make it easy to have multiple clock domains in your FPGA design. Say you have some external memory that runs at 100 MHz, but you want your main logic to run at 25 MHz. You <i>could</i> purchase a second external clock and feed that into your FPGA, but a better solution is to <span aria-label=" Page 200. " epub:type="pagebreak" id="pg_200" role="doc-pagebreak"/>use a PLL, since this primitive can generate multiple clock frequencies simultaneously.</p>
<p class="TX">Not all FPGAs have a PLL, but many have at least one, and some have several. The datasheet will tell you what’s available. As an example, <a href="#fig9-7">Figure 9-7</a> highlights the PLLs available on Intel’s Cyclone V product line.</p>
<figure class="IMG"><img alt="" class="img100" id="fig9-7" src="../images/Figure9-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: PLLs on the Cyclone V product line</samp></p></figcaption>
</figure>
<p class="TX">The 5CEA2 and 5CEA4 FPGAs both have four PLLs, while the 5CEA5 has six. Given that each PLL can generate multiple clocks, that should be more than enough for all your clocking needs.</p>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H2" id="sec13"><span id="h-126"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How It Works</samp></h3>
<p class="TNI1">A PLL serves as the source of your clock distribution throughout your FPGA by taking a single clock input, often called the <i>reference clock</i>, and generating one or more clock outputs from it. The input clock comes from a dedicated external component, and the outputs can run at completely different frequencies from the input clock and from one another. The block diagram in <a href="#fig9-8">Figure 9-8</a> shows the most common signals on a PLL.</p>
<figure class="IMG"><img alt="" class="img60" id="fig9-8" src="../images/Figure9-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-8: Common PLL signals</samp></p></figcaption>
</figure>
<p class="TX">The PLL typically takes two inputs: a clock signal and a reset. The reset input will stop the PLL from running when it’s asserted.</p>
<p class="TX"><span aria-label=" Page 201. " epub:type="pagebreak" id="pg_201" role="doc-pagebreak"/>On the output side, the PLL has some number of output clocks in the range 1 to <i>N</i>, with the maximum number depending on the FPGA. The output clocks can be of different frequencies, depending on what you need for your design. These frequencies are achieved by taking the input reference clock and multiplying and/or dividing it to get the desired value. For example, say you have a 10 MHz input reference clock, and you want a 15 MHz output clock. The PLL would multiply the reference clock by 3 (giving you 30 MHz), then divide it by 2 to get down to 15 MHz. The multiplication and division terms must be integers, so it’s important to realize that you can’t get any arbitrary frequency out of the PLL. It isn’t possible to get a <span class="greek"><span lang="el" xml:lang="el">π</span></span> MHz clock output from a 10 MHz clock input, for example, since <span class="greek"><span lang="el" xml:lang="el">π</span></span> is an irrational number that can’t be expressed as the ratio of two integers.</p>
<p class="TX">Besides varying the frequency of the output clock(s), a PLL can also vary their phase. A signal’s <i>phase</i> is its current position along the repeating waveform of the signal, measured as an angle from 0 to 360 degrees. It’s easiest to picture what this means by comparing two signals that share a frequency but aren’t aligned in time. <a href="#fig9-9">Figure 9-9</a> demonstrates some common phase shifts of a clock signal.</p>
<figure class="IMG"><img alt="" class="img40" id="fig9-9" src="../images/Figure9-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-9: Common phase shifts</samp></p></figcaption>
</figure>
<p class="TX">As this figure shows, shifting the phase of a clock signal results in moving the location of its rising edges. Compare the first rising edge of <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp> (which has no phase shift) with the first rising edge of <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">90°</samp> (which is phase-shifted by 90 degrees). The rising edge of <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">90°</samp> is delayed by one-quarter of a clock period relative to <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp>. Each increment of 90 degrees shifts the signal by another quarter period. Continuing the example in the figure, we have <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">180°</samp>, which is delayed by 90 degrees from <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">90°</samp> and 180 degrees from <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp>. Notice that <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">180°</samp> is actually the same waveform that you would get if you took the <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp> signal and inverted it by swapping the highs and lows. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">270°</samp> is delayed by three-quarters of a clock period relative to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">Clk</samp> signal. If you went a full 360 degrees, you’d be back to your original signal. This example has demonstrated positive phase shifts, but phase can also be negative, meaning the signal is shifted backward in time compared to the other. Of course, you can shift the phase by any arbitrary angle, not just in 90-degree steps.</p>
<p class="NOTE"><span aria-label=" Page 202. " epub:type="pagebreak" id="pg_202" role="doc-pagebreak"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>Creating clocks with phase shifts isn’t very common in simple designs, but it can be useful in some applications. For example, it might be important for interfacing to external components, like some off-FPGA memory.</i></p>
<p class="TX">Returning to the block diagram in <a href="#fig9-8">Figure 9-8</a>, a PLL also typically has a <i>locked</i> output signal, which tells any module downstream that the PLL is operating and you can “trust” the clocks. It’s a common design practice to use this locked signal as a reset to other modules relying on the PLL’s clocks. When the PLL isn’t locked, the modules downstream of the PLL are held in a reset state until the PLL is locked and ready, meaning the output clocks can be used by other modules in your FPGA design. When the PLL’s reset input is driven high its locked output will go low, putting the downstream modules back into a reset condition.</p>
<p class="TX">If you’re going to use a PLL in your design, it’s a good idea to use <i>only</i> the PLL’s outputs for all your clocking needs. Even if part of your design runs at the same clock frequency as the external reference clock, you shouldn’t use the external clock directly to drive that part of the design. Instead, have the PLL output a clock signal at the same frequency as the external reference. By only using the PLL’s outputs, you can tightly control the relationships between the output clocks. Additionally, you can confidently use the locked output of the PLL for your reset circuitry, knowing it reflects the state that <i>all</i> clocks in your design are operational.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h3 class="H2"><span id="sec14"/><span id="h-127"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creation</samp></h3>
<p class="TNI1">The PLL is one primitive that I recommend using a GUI to create, since the synthesis tools won’t be able to infer a PLL. Instantiation is also possible, but it’s prone to errors. You need to choose PLL settings that are compatible with one another for the PLL to work successfully, and during instantiation it’s easy to pick settings that won’t work. If you had a 10 MHz reference clock and you wanted to generate one 15 MHz output and a separate 89 MHz output, for example, that simply might not be possible, but you might miss that fact during instantiation.</p>
<p class="TX">When you create a PLL using the GUI, you tell it your input reference clock and desired output clock frequencies, and the tool will tell you if it can find a solution that works. Continuing the 10/15/89 MHz example, the GUI might tell you that the closest value to 89 MHz that it can give you is 90 MHz (since 90 MHz is a multiple of both 10 MHz and 15 MHz, this is likely to work). Then it’s up to you to decide whether 90 MHz will work for your design or if you really need 89 MHz, in which case you might need to use a separate PLL or change your reference clock. <a href="#fig9-10">Figure 9-10</a> shows an example of the PLL GUI within Lattice Diamond.</p><span aria-label=" Page 203. " epub:type="pagebreak" id="pg_203" role="doc-pagebreak"/>
<figure class="IMG"><img alt="" class="img80" id="fig9-10" src="../images/Figure9-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-10: Creating a PLL with a GUI</samp></p></figcaption>
</figure>
<p class="TX">As you can see, the GUI helps guide us through the PLL creation process. In this case, we have a 30 MHz reference on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKI</samp>, and we’re setting the desired output frequencies to 30 MHz on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOP</samp>, 60 MHz on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS</samp>, 15 MHz on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS2</samp>, and 89 MHz on <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>. Notice that for each clock except <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>, the actual frequency on the far right matches the desired frequency. For <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>, when I first tried to create an 89 MHz clock with 0.0 percent tolerance, I got the error message shown in <a href="#fig9-11">Figure 9-11</a>.</p>
<figure class="IMG"><img alt="" class="img40" id="fig9-11" src="../images/Figure9-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-11: Actionable feedback from invalid PLL settings</samp></p></figcaption>
</figure>
<p class="TX">Not until I changed the tolerance to 2.0 percent did the error message go away; the tool had selected an actual frequency of 90 MHz, which is within 2.0 percent of the requested frequency. This type of guidance isn’t provided if you try to instantiate your PLL directly.</p>
<p class="TX">Another helpful feature of the GUI is the PLL block diagram, shown in the left half of <a href="#fig9-10">Figure 9-10</a>. This diagram will be updated if you modify the inputs or outputs. For example, if we disabled <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKOS3</samp>, that output would <span aria-label=" Page 204. " epub:type="pagebreak" id="pg_204" role="doc-pagebreak"/>disappear from the block diagram to reflect that we only want to output three clock signals. This is useful to ensure you’re creating what you expect. Notice that there’s also a separate Phase tab near the top of the window, which allows us to specify phase shifts on our output clocks.</p>
<p class="TX">After designing a PLL in the GUI, you can run your design through the normal synthesis process. The utilization report will confirm you’re getting a PLL, as it’s one of the main primitives highlighted in the report. Here’s an example:</p>
<pre><code><var>--snip--</var>
Number of PLLs:   1 out of 4 (25%)</code></pre>
<p class="TX">This indicates one PLL is being used out of four available on this particular FPGA.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h2 class="H1" id="sec15"><span id="h-128"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI1">The majority of your Verilog and VHDL code will be dedicated to creating LUTs and flip-flops, which are the two most fundamental FPGA components. However, as you’ve seen in this chapter, FPGAs also contain other primitive components, such as block RAMs, DSP blocks, and PLLs, that add specialized functionality. Block RAMs add dedicated memory, DSP blocks enable high-speed parallel math operations, and PLLs allow you to generate different internal clock frequencies. With a combination of these FPGA building blocks, you’ll be able to solve a wide range of problems efficiently.</p>
</section>
</section>
</body>
</html>