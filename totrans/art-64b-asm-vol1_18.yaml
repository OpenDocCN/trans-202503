- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Stand-Alone Assembly Language Programs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 独立汇编语言程序
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Until now, this book has relied upon a C/C++ main program to call the example
    code written in assembly language. Although this is probably the biggest use of
    assembly language in the real world, it is also possible to write stand-alone
    code (no C/C++ main program) in assembly language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书依赖于 C/C++ 主程序来调用用汇编语言编写的示例代码。尽管这可能是汇编语言在现实世界中的最大应用，但也可以在汇编语言中编写独立的代码（没有
    C/C++ 主程序）。
- en: In the context of this chapter, *stand-alone assembly language programs* means
    that you’re writing an executable program in assembly that does not directly link
    into a C/C++ program for execution. Without a C/C++ main program calling your
    assembly code, you’re not dragging along the C/C++ library code and runtime system,
    so your programs can be smaller and you won’t have external naming conflicts with
    C/C++ public names. However, you’ll have to do much of the work yourself that
    C/C++ libraries do by writing comparable assembly code or calling the Win32 API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的上下文中，*独立汇编语言程序*指的是你编写的一个可执行的汇编程序，它不会直接链接到 C/C++ 程序中执行。没有 C/C++ 主程序调用你的汇编代码，你就不会拖带
    C/C++ 库代码和运行时系统，因此你的程序会更小，也不会与 C/C++ 公共名称发生外部命名冲突。然而，你必须自己完成很多 C/C++ 库所做的工作，或者编写相应的汇编代码，或调用
    Win32 API。
- en: The *Win32 API* is a bare-metal interface to the Windows operating system that
    provides thousands of functions you can call from a stand-alone assembly language
    program—far too many to consider in this chapter. This chapter provides a basic
    introduction to Win32 applications (especially console-based applications). This
    information will get you started writing stand-alone assembly language programs
    under Windows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Win32 API* 是一个裸金属接口，提供给 Windows 操作系统，提供了成千上万的函数，你可以从独立的汇编语言程序中调用——本章无法考虑所有这些函数。
    本章为你提供了 Win32 应用程序的基本介绍（尤其是基于控制台的应用程序）。这些信息将帮助你开始在 Windows 下编写独立的汇编语言程序。'
- en: To use the Win32 API from your assembly programs, you’ll need to download the
    MASM32 library package from [https://www.masm32.com/](https://www.masm32.com/).^([1](#c16-footnote-1))
    Most of the examples in this chapter assume the MASM32 64-bit include files are
    available on your system in the *C:\masm32* subdirectory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的汇编程序中使用 Win32 API，你需要从 [https://www.masm32.com/](https://www.masm32.com/)
    下载 MASM32 库包。^([1](#c16-footnote-1)) 本章中的大多数示例假设 MASM32 64 位包含文件已经在你的系统的 *C:\masm32*
    子目录中。
- en: 16.1 Hello World, by Itself
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 独立的 Hello World
- en: 'Before showing you some of the wonders of Windows stand-alone assembly language
    programming, perhaps the best place to start is at the beginning: with a stand-alone
    “Hello, world!” program ([Listing 16-1](#listing16-1)).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在向你展示一些 Windows 独立汇编语言编程的奇迹之前，也许最好的起点是从头开始：一个独立的“Hello, world!”程序（[清单 16-1](#listing16-1)）。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 16-1: Stand-alone “Hello, world!” program'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-1：独立的“Hello, world!”程序
- en: 'The `__imp_``GetStdHandle` and `__imp_``WriteFile` procedures are functions
    inside Windows (they are part of the so-called Win32 API, even though this is
    64-bit code that is executing). The `__imp_GetStdHandle` procedure, when passed
    the (admittedly magic) number –11 as an argument, returns a handle to the standard
    output device. With this handle, calls to `__imp_WriteFile` will send the output
    to the standard output device (the console). To build and run this program, use
    the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`__imp_``GetStdHandle` 和 `__imp_``WriteFile` 过程是 Windows 内的函数（它们是所谓的 Win32
    API 的一部分，尽管这是执行的 64 位代码）。`__imp_GetStdHandle` 过程，在传入（虽然是魔法般的）数字 -11 作为参数时，返回标准输出设备的句柄。使用这个句柄，调用
    `__imp_WriteFile` 将把输出发送到标准输出设备（控制台）。要构建并运行此程序，使用以下命令：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The MASM `/link` command line option tells it that the following commands (to
    the end of the line) are to be passed on to the linker. The `/subsystem:console`
    (linker) command line option tells the linker that this program is a console application
    (that is, it will run in a command line window). The `/entry:main` linker option
    passes along the name of the main program to the linker. The linker stores this
    address in a special location in the executable file so Windows can determine
    the starting address of the main program after it loads the executable file into
    memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MASM的`/link`命令行选项告诉它，接下来的命令（直到行末）将被传递给链接器。`/subsystem:console`（链接器）命令行选项告诉链接器这个程序是一个控制台应用程序（也就是说，它将在命令行窗口中运行）。`/entry:main`链接器选项将主程序的名称传递给链接器。链接器将这个地址存储在可执行文件中的一个特殊位置，以便Windows在将可执行文件加载到内存后确定主程序的起始地址。
- en: 16.2 Header Files and the Windows Interface
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 头文件与Windows接口
- en: 'Near the beginning of the “Hello, world!” example in [Listing 16-1](#listing16-1),
    you’ll notice the following lines:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 16-1](#listing16-1)的“Hello, world!”示例的开始部分，你会注意到以下几行：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *kernel32.lib* library file contains the object module definitions for many
    of the Win32 API functions, including the `__imp_GetStdHandle` and `__imp_WriteFile`
    procedures. Inserting `extrn` directives for all the Win32 API functions into
    your assembly language programs is an incredible amount of work. The proper way
    to deal with these function definitions is to include them in a header (include)
    file and then include that file in every application you write that uses the Win32
    API functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*kernel32.lib*库文件包含了许多Win32 API函数的对象模块定义，包括`__imp_GetStdHandle`和`__imp_WriteFile`过程。为所有Win32
    API函数在你的汇编语言程序中插入`extrn`指令是一个巨大的工作量。处理这些函数定义的正确方式是将它们包含在一个头文件（包含文件）中，然后在你编写的每个使用Win32
    API函数的应用程序中都包含这个文件。'
- en: 'The bad news is that creating an appropriate set of header files is a gargantuan
    task. The good news is that somebody else has already done all that work for you:
    the MASM32 headers. [Listing 16-2](#listing16-2) is a rework of [Listing 16-1](#listing16-1)
    that uses the MASM32 64-bit include files to obtain the Win32 external declarations.
    Note that we incorporate MASM32 via an include file, *listing16-2.inc*, rather
    than use it directly. This will be explained in a moment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是，创建一个合适的头文件集合是一个庞大的任务。好消息是，已经有人为你做了所有这些工作：MASM32头文件。[Listing 16-2](#listing16-2)是[Listing
    16-1](#listing16-1)的重做版，使用MASM32 64位包含文件来获取Win32外部声明。请注意，我们通过包含文件*listing16-2.inc*来引入MASM32，而不是直接使用它。稍后会详细解释。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the *listing16-2.inc* include file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*listing16-2.inc*包含文件：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 16-2: Using the MASM32 64-bit include files'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 16-2: 使用MASM32 64位包含文件'
- en: 'Here’s the build command and sample output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和示例输出：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The MASM32 include file
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MASM32包含文件
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: includes all the other hundreds of include files that are part of the MASM32
    64-bit system. Sticking this include directive into your programs provides your
    application with access to a huge number of Win32 API functions, data declarations,
    and other goodies (such as MASM32 macros).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了MASM32 64位系统中的其他数百个包含文件。将这个包含指令加入到你的程序中，能够为你的应用程序提供对大量Win32 API函数、数据声明和其他资源（如MASM32宏）的访问。
- en: However, your computer will pause for a bit when you assemble your source file.
    That’s because that single include directive winds up including many tens of thousands
    of lines of code into your program during assembly. If you know which header file(s)
    contain the actual declarations you want to use, you can speed up your compilations
    by including just the files you need (as was done in *listing16-2.asm* using the
    MASM32 64-bit include files).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你组装源文件时，计算机会暂停一会儿。这是因为那个单一的包含指令在组装过程中将成千上万行代码包含到程序中。如果你知道哪个头文件包含你需要使用的实际声明，你可以通过只包含必要的文件来加速编译过程（就像在*listing16-2.asm*中使用MASM32
    64位包含文件那样）。
- en: 'Including *masm64rt.inc* into your programs has one other problem: *namespace
    pollution*. The MASM32 include file introduces thousands and thousands of symbols
    into your program, and there is a chance a symbol you want to use has already
    been defined in the MASM32 include files (for a different purpose than the one
    you have in mind). If you have a *file grep* utility, a program that searches
    through files in a directory and recursively in subdirectories for a particular
    string, you can easily locate all occurrences of a particular symbol you want
    to use in your file and copy that symbol’s definition into your own source file
    (or, better yet, into a header file you create specifically for this purpose).
    This is the approach this chapter uses for many of the example programs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 The Win32 API and the Windows ABI
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Win32 API functions all adhere to the Windows ABI calling convention. This
    means that calls to these functions can modify all the volatile registers (RAX,
    RCX, RDX, R8, R9, R10, R11, and XMM0 to XMM5) but must preserve the nonvolatile
    registers (the others not listed here). Also, API calls pass parameters in RDX,
    RCX, R8, R9 (and XMM0 to XMM3), and then on the stack; the stack must be 16-byte-aligned
    prior to the API call. See the discussion of the Windows ABI throughout this book
    for more details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Building a Stand-Alone Console Application
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at the (simplified) build command from the preceding section:^([2](#c16-footnote-2))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `/subsystem:console` option tells the linker that in addition to possible
    GUI windows the application might create, the system must also create a special
    window for the application to display console information. If you run the program
    from a Windows command line, it uses the already-open console window of the *cmd.exe*
    program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Building a Stand-Alone GUI Application
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a pure Windows GUI application that does not also open up a console
    window, you can specify `/subsystem:windows` rather than `/subsystem:console`.
    The simple dialog box application in [Listing 16-3](#listing16-3) is an example
    of an especially simple Windows application. It displays a simple dialog box and
    then quits when the user clicks the OK button in the dialog box.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 16-3: A simple dialog box application'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the *listing16-3.inc* include file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the build command for the program in [Listing 16-3](#listing16-3):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 16-1](#figure16-1) shows the runtime output from [Listing 16-3](#listing16-3).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: file:///Users/DisPater/Desktop/Hyde501089/Production/IndesignFiles/image_fi/501089c16/f16001.tiff
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16-1: Sample dialog box output'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 A Brief Look at the MessageBox Windows API Function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although creating GUI applications in assembly language is well beyond the scope
    of this book, the `MessageBox` function is sufficiently useful (even in console
    applications) to be worth a special mention.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageBox` function has four parameters:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: RCX Window handle. This is usually NULL (0), implying that the message box is
    a stand-alone dialog box that is not associated with any particular window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX Message pointer. RDX contains a pointer to a zero-terminated string that
    will be displayed in the body of the message box.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Window title. R8 contains a pointer to a zero-terminated string that is displayed
    in the title bar of the message box window.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'R9D Message box type. This is an integer value that specifies the type of buttons
    and other icons appearing in the message box. Typical values are the following:
    `MB_OK`, `MB_OKCANCEL`, `MB_ABORTRETRYIGNORE`, `MB_YESNOCANCEL`, `MB_YESNO`, and
    `MB_RETRYCANCEL`.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `MessageBox` function returns an integer value in RAX corresponding to the
    button that was pressed (if `MB_OK` was specified, that’s the value that the message
    box returns when the user clicks the OK button).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 16.7 Windows File I/O
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing missing from most of the example code in this book has been a discussion
    of file I/O. Although you can easily make C Standard Library calls to open, read,
    write, and close files, it seemed appropriate to use file I/O as an example in
    this chapter to cover this missing detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The Win32 API provides many useful functions for *file I/O*: reading and writing
    file data. This section describes a small number of these functions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateFileA` A function (despite its name) that you use to open existing files
    or create new files'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WriteFile` A function that writes data to a file'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReadFile` A function that reads data from a file'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CloseHandle` A function that closes a file and flushes any cached data to
    the storage device'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetStdHandle` A function, which you’ve already seen, that returns the handle
    of one of the standard input or output devices (standard input, standard output,
    or standard error)'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetLastError` A function you can use to retrieve a Windows error code if an
    error occurs in the execution of any of these functions'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 16-4](#listing16-4) demonstrates the use of these functions as well
    as the creation of some useful procedures that call these functions. Note that
    this code is rather long, so I’ve taken the liberty of breaking it into smaller
    chunks, with individual explanations in front of each section.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'The Win32 file I/O functions are all part of the *kernel32.lib* library module.
    Therefore, [Listing 16-4](#listing16-4) uses the `includelib kernel32.lib` statement
    to automatically link in this library during the build phase. To speed up assembly
    and reduce namespace pollution, this program does not automatically include all
    of the MASM32 equate files (via an `include \masm32\include64\masm64rt.inc` statement).
    Instead, I’ve collected all the necessary equates and other definitions from the
    MASM32 header files and placed them in the *listing16-4.inc* header file (which
    appears a little later in this chapter). Finally, the program also includes the
    *aoalib.inc* header file, just to use a few of the constants defined in that file
    (such as `cr` and `nl`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code constructs *wrapper code* around each of the file I/O functions
    to preserve the volatile register values. These functions use the following macro
    definitions to save and restore the register values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first function appearing in [Listing 16-4](#listing16-4) is `getStdOutHandle`.
    This is a wrapper function around `__imp_GetStdHandle` that preserves the volatile
    registers and explicitly requests the standard output device handle. This function
    returns the standard output device handle in the RAX register. Immediately following
    `getStdOutHandle` are comparable functions that retrieve the standard error handle
    and the standard input handle:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now consider the wrapper code for the `write` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `write` function writes data from a memory buffer to the output file specified
    by a file handle (which could also be the standard output or standard error handle,
    if you want to write data to the console). The `write` function expects the following
    parameter data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: RAX File handle specifying the write destination. This is typically a handle
    obtained by the `open` or `openNew` functions (a little later in the program)
    or the `getStdOutHandle` and `getStdErrHandle` functions.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RSI Address of the buffer containing the data to write to the file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Number of bytes of data to write to the file (from the buffer).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function does not follow the Windows ABI calling convention. Although there
    isn’t an official *assembly language calling convention*, many assembly language
    programmers tend to use the same registers that the x86-64 string instructions
    use. For example, the source data (buffer) is passed in RSI (the source index
    register), and the count (buffer size) parameter appears in the RCX register.
    The `write` procedure moves the data to appropriate locations for the call to
    `__imp_WriteFile` (as well as sets up additional parameters).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__imp_WriteFile` function is the actual Win32 API write function (technically,
    `__imp_WriteFile` is a pointer to the function; the call instruction is an indirect
    call through this pointer). The `__imp_WriteFile` has the following arguments:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: RCX File handle.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX Buffer address.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Buffer size (really, 32 bits in R8D).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 Address of a dword variable to receive the number of bytes written to the
    file; this will equal the buffer size if the write operation is successful.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 32] `lpOverlapped` value; just set this to NULL (0). As per the Windows
    ABI, callers pass all parameters beyond the fourth parameter on the stack, leaving
    room (shadow parameters) for the first four.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On return from `__imp_WriteFile`, RAX contains a nonzero value (true) if the
    write was successful, and zero (false) if there was an error. If there was an
    error, you can call the Win32 `GetLastError` function to retrieve the error code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `write` function returns the number of bytes written to the file
    in the RAX register. If there was an error, `write` returns `-1` in the RAX register.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up are the `puts` and `newLn` functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `puts` and `newLn` procedures write strings to the standard output device.
    The `puts` function writes a zero-terminated string whose address you pass in
    the RSI register. The `newLn` function writes a newline sequence (carriage return
    and line feed) to the standard output device.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions have a tiny optimization: they call `getStdOutHandle` only
    once to obtain the standard output device handle. On the first call to either
    of these functions, they call `getStdOutHandle` and cache the result (in the `stdOutHnd`
    variable) and set flag (`hasSOHndl`) that indicates that the cached value is valid.
    Thereafter, these functions use the cached value rather than continually calling
    `getStdOutHandle` to retrieve the standard output device handle.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The `write` function requires a buffer length; it does not work on zero-terminated
    strings. Therefore, the `puts` function must explicitly determine the length of
    the zero-terminated string before calling `write`. The `newLn` function doesn’t
    have to do this because it knows the length of the carriage return and line feed
    sequence (two characters).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function in [Listing 16-4](#listing16-4) is the wrapper for the `read`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `read` function is the input analog to the `write` function. The parameters
    are similar (note, however, that `read` uses RDI as the *destination address*
    for the buffer parameter):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: RAX File handle.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDI Destination buffer to store data read from file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Number of bytes to read from the file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `read` function, a wrapper around the Win32 API `__imp_ReadFile` function,
    has the following arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: RCX File handle.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX File buffer address.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Number of bytes to read.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 Address of dword variable to receive the number of bytes actually read.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 32] Overlapped operation; should be NULL (0). As per the Windows ABI,
    callers pass all parameters beyond the fourth parameter on the stack, leaving
    room (shadow parameters) for the first four.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `read` function returns `-1` in RAX if there was an error during the read
    operation. Otherwise, it returns the actual number of bytes read from the file.
    This value can be less than the requested read amount if the read operation reaches
    the end of the file (EOF). A `0` return value generally indicates EOF has been
    reached.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `open` function opens an existing file for reading, writing, or both. It
    is a wrapper function for the Windows `CreateFileA` API call:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `open` procedure has two parameters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: RSI A pointer to a zero-terminated string containing the filename of the file
    to open.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RAX A set of file access flags. These are typically the constants `GENERIC_READ`
    (to open a file for reading), `GENERIC_WRITE` (to open a file for writing), or
    `GENERIC_READ + GENERIC_WRITE` (to open a file for reading and writing).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `open` function calls the Windows `CreateFileA` function after setting up
    the appropriate parameters for the latter. The `A` suffix on `CreateFileA` stands
    for *ASCII*. This particular function expects the caller to pass an ASCII filename.
    Another function, `CreateFileW`, expects Unicode filenames, encoded as UTF-16\.
    Internally, Windows uses Unicode filenames; when you call `CreateFileA`, it converts
    the ASCII filename to Unicode and then calls `CreateFileW`. The `open` function
    sticks with ASCII characters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateFileA` function has the following parameters:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: RCX Pointer to zero-terminated (ASCII) string holding the name of the file to
    open.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX Read and write access flags (`GENERIC_READ` and `GENERIC_WRITE`).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Sharing mode flag (`0` means exclusive access). Controls whether another
    process can access the file while the current process has it open. Possible flag
    values are `FILE_SHARE_READ`, `FILE_SHARE_WRITE`, and `FILE_SHARE_DELETE` (or
    a combination of these).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 Pointer to a security descriptor. The `open` function doesn’t specify any
    special security; it simply passes NULL (0) as this argument.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 32] This parameter holds the creation disposition flag. The `open` function
    opens an existing file, so it passes `OPEN_EXISTING` here. Other possible values
    are `CREATE_ALWAYS`, `CREATE_NEW`, `OPEN_ALWAYS`, `OPEN_EXISTING`, or `TRUNCATE_EXISTING`.
    The `OPEN_EXISTING` value requires that the file exists, or it will return an
    open error. Being the fifth parameter, this is passed on the stack (in the fifth
    64-bit slot).'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 40] This parameter contains the file attributes. This function simply
    uses the `FILE_ATTRIBUTE_NORMAL` attribute (for example, not read-only).'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 48] This parameter is a pointer to a file template handle. The `open`
    function doesn’t use a file template, so it passes NULL (0) in this argument.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `open` function returns a file handle in the RAX register. If there was
    an error, this function returns `INVALID_HANDLE_VALUE` in RAX.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The `openNew` function is also a wrapper around the `CreateFileA` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`openNew` creates a new (empty) file on the disk. If the file previously existed,
    `openNew` will delete it before opening the new file. This function is almost
    identical to the preceding `open` function, with the following two differences:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The caller does not pass the file access flags in the RAX register. The file
    access is always assumed to be `GENERIC_WRITE`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function passes the `CREATE_ALWAYS` creation disposition flag to `CreateFileA`
    rather than `OPEN_EXISTING`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `closeHandle` function is a simple wrapper around the Windows `CloseHandle`
    function. You pass the file handle of the file to close in the RAX register. This
    function returns `0` in RAX if there was an error, or a nonzero file if the file
    close operation was successful. The only purpose of this wrapper is to preserve
    all the volatile registers across the call to the Windows `CloseHandle` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this program doesn’t explicitly use `getLastError`, it does provide
    a wrapper around the `getLastError` function (just to show how it would be written).
    Whenever one of the Windows functions in this program returns an error indication,
    you have to call `getLastError` to retrieve the actual error code. This function
    has no input parameters. It returns the last Windows error code generated in RAX.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to call `getLastError` immediately after a function returns
    an error indication. If you call any other Windows functions between the error
    and retrieval of the error code, those intervening calls will reset the last error
    code value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'As was the case for the `closeHandle` function, the `getLastError` procedure
    is a very simple wrapper around the Windows `GetLastError` function that preserves
    volatile register values across the call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `stdin_read` is a simple wrapper function around the `read` function that
    reads its data from the standard input device (rather than from a file on another
    device):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`stdin_read` is similar to the `puts` (and `newLn`) procedure insofar as it
    caches the standard input handle on its first call and uses that cached value
    on subsequent calls. Note that `stdin_read` does not (directly) preserve the volatile
    registers. This function does not directly call any Windows functions, so it doesn’t
    have to preserve the volatile registers (`stdin_read` calls the `read` function,
    which preserves the volatile registers). The `stdin_read` function has the following
    parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: RDI Pointer to destination buffer that will receive the characters read from
    the standard input device.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Buffer size (maximum number of bytes to read).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function returns the actual number of bytes read in the RAX register. This
    value may be less than the value passed in RCX. If the user presses enter, this
    function immediately returns. This function does not zero-terminate the string
    read from the standard input device. Use the value in the RAX register to determine
    the string’s length. If this function returns because the user pressed enter on
    the standard input device, that carriage return will appear in the buffer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stdin_getc` function reads a single character from the standard input
    device and returns that character in the AL register:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `readLn` function reads a string of characters from the standard input
    device and places them in a caller-specified buffer. The arguments are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: RDI Address of the buffer.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Maximum buffer size. (`readLn` allows the user to enter a maximum of RCX
    – 1 characters.)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function will put a zero-terminating byte at the end of the string input
    by the user. Furthermore, it will strip out the carriage return (or newline or
    line feed) character at the end of the line. It returns the character count in
    RAX (not counting the enter key):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the main program for [Listing 16-4](#listing16-4), which reads a filename
    from the user, opens that file, reads the file data, and displays the data on
    the standard output device:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 16-4: File I/O demonstration program'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for [Listing 16-4](#listing16-4):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the *listing16-4.inc* include file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the *listing16-4.mak* makefile:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 16.8 Windows Applications
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has provided just a glimpse of what is possible when writing pure
    assembly language applications that run under Windows. The *kernel32.lib* library
    provides hundreds of functions you can call, covering such diverse topic areas
    as manipulating filesystems (for example, deleting files, looking up filenames
    in a directory, and changing directories), creating threads and synchronizing
    them, processing environment strings, allocating and deallocating memory, manipulating
    the Windows registry, sleeping for a certain time period, waiting for events to
    occur, and much, much more.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The *kernel32.lib* library is but one of the libraries in the Win32 API. The
    *gdi32.lib* library contains most of the functions needed to create GUI applications
    running under Windows. Creating such applications is well beyond the scope of
    this book, but if you want to create stand-alone Windows GUI applications, you
    need to become intimately familiar with this library. The following “For More
    Information” section provides links to internet resources if you’re interested
    in creating stand-alone Windows GUI applications in assembly language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 16.9 For More Information
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to write stand-alone 64-bit assembly language programs that run
    under Windows, your first stop should be [https://www.masm32.com/](https://www.masm32.com/).
    Although this website is primarily dedicated to creating 32-bit assembly language
    programs that run under Windows, it has a large amount of information for 64-bit
    programmers as well. More importantly, this site contains the header files you
    will need to access the Win32 API from your 64-bit assembly language programs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If you’re serious about writing Win32 API–based Windows applications in assembly
    language, Charles Petzold’s *Programming Windows*, Fifth Edition (Microsoft, 1998)
    is an absolutely essential purchase. This book is old (do not get the newer edition
    for C# and XAML), and you likely will have to purchase a used copy. It was written
    for C programmers (not assembly), but if you know the Windows ABI (which you should
    by now), translating all the C calls into assembly language isn’t that difficult.
    Though much of this information about the Win32 API is available online (such
    as at the MASM32 site), having all the information available in a single (very
    large!) book is essential.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Another good source on the web for Win32 API calls is software analyst Geoff
    Chappell’s Win32 Programming page ([https://www.geoffchappell.com/studies/windows/win32/](https://www.geoffchappell.com/studies/windows/win32/)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The Iczelion tutorials were the original standard for writing Windows programs
    in x86 assembly language. Although they were originally written for 32-bit x86
    assembly language, there have been several translations of this code to 64-bit
    assembly language, for example: [http://masm32.com/board/index.php?topic=4190.0/](http://masm32.com/board/index.php?topic=4190.0/).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library and examples (which can be found at [https://www.randallhyde.com/](https://www.randallhyde.com/))
    contain a ton of Windows code and API function calls. Though this code is all
    32-bit, translating it to 64-bit MASM code is easy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 16.10 Test Yourself
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the linker command line option needed to tell MASM that you’re building
    a console application?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What website should you visit to get Win32 programming information?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the major drawback to including *\masm32\include64\masm64rt.inc* in
    all your assembly language source files?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What linker command line option lets you specify the name of your assembly language
    main program?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the Win32 API function that lets you bring up a dialog box?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrapper code?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Win32 API function you would use to open an existing file?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Win32 API function do you use to retrieve the last Windows error code?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
