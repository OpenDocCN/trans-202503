- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Stand-Alone Assembly Language Programs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 独立汇编语言程序
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Until now, this book has relied upon a C/C++ main program to call the example
    code written in assembly language. Although this is probably the biggest use of
    assembly language in the real world, it is also possible to write stand-alone
    code (no C/C++ main program) in assembly language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书依赖于 C/C++ 主程序来调用用汇编语言编写的示例代码。尽管这可能是汇编语言在现实世界中的最大应用，但也可以在汇编语言中编写独立的代码（没有
    C/C++ 主程序）。
- en: In the context of this chapter, *stand-alone assembly language programs* means
    that you’re writing an executable program in assembly that does not directly link
    into a C/C++ program for execution. Without a C/C++ main program calling your
    assembly code, you’re not dragging along the C/C++ library code and runtime system,
    so your programs can be smaller and you won’t have external naming conflicts with
    C/C++ public names. However, you’ll have to do much of the work yourself that
    C/C++ libraries do by writing comparable assembly code or calling the Win32 API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的上下文中，*独立汇编语言程序*指的是你编写的一个可执行的汇编程序，它不会直接链接到 C/C++ 程序中执行。没有 C/C++ 主程序调用你的汇编代码，你就不会拖带
    C/C++ 库代码和运行时系统，因此你的程序会更小，也不会与 C/C++ 公共名称发生外部命名冲突。然而，你必须自己完成很多 C/C++ 库所做的工作，或者编写相应的汇编代码，或调用
    Win32 API。
- en: The *Win32 API* is a bare-metal interface to the Windows operating system that
    provides thousands of functions you can call from a stand-alone assembly language
    program—far too many to consider in this chapter. This chapter provides a basic
    introduction to Win32 applications (especially console-based applications). This
    information will get you started writing stand-alone assembly language programs
    under Windows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Win32 API* 是一个裸金属接口，提供给 Windows 操作系统，提供了成千上万的函数，你可以从独立的汇编语言程序中调用——本章无法考虑所有这些函数。
    本章为你提供了 Win32 应用程序的基本介绍（尤其是基于控制台的应用程序）。这些信息将帮助你开始在 Windows 下编写独立的汇编语言程序。'
- en: To use the Win32 API from your assembly programs, you’ll need to download the
    MASM32 library package from [https://www.masm32.com/](https://www.masm32.com/).^([1](#c16-footnote-1))
    Most of the examples in this chapter assume the MASM32 64-bit include files are
    available on your system in the *C:\masm32* subdirectory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的汇编程序中使用 Win32 API，你需要从 [https://www.masm32.com/](https://www.masm32.com/)
    下载 MASM32 库包。^([1](#c16-footnote-1)) 本章中的大多数示例假设 MASM32 64 位包含文件已经在你的系统的 *C:\masm32*
    子目录中。
- en: 16.1 Hello World, by Itself
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 独立的 Hello World
- en: 'Before showing you some of the wonders of Windows stand-alone assembly language
    programming, perhaps the best place to start is at the beginning: with a stand-alone
    “Hello, world!” program ([Listing 16-1](#listing16-1)).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在向你展示一些 Windows 独立汇编语言编程的奇迹之前，也许最好的起点是从头开始：一个独立的“Hello, world!”程序（[清单 16-1](#listing16-1)）。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 16-1: Stand-alone “Hello, world!” program'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-1：独立的“Hello, world!”程序
- en: 'The `__imp_``GetStdHandle` and `__imp_``WriteFile` procedures are functions
    inside Windows (they are part of the so-called Win32 API, even though this is
    64-bit code that is executing). The `__imp_GetStdHandle` procedure, when passed
    the (admittedly magic) number –11 as an argument, returns a handle to the standard
    output device. With this handle, calls to `__imp_WriteFile` will send the output
    to the standard output device (the console). To build and run this program, use
    the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`__imp_``GetStdHandle` 和 `__imp_``WriteFile` 过程是 Windows 内的函数（它们是所谓的 Win32
    API 的一部分，尽管这是执行的 64 位代码）。`__imp_GetStdHandle` 过程，在传入（虽然是魔法般的）数字 -11 作为参数时，返回标准输出设备的句柄。使用这个句柄，调用
    `__imp_WriteFile` 将把输出发送到标准输出设备（控制台）。要构建并运行此程序，使用以下命令：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The MASM `/link` command line option tells it that the following commands (to
    the end of the line) are to be passed on to the linker. The `/subsystem:console`
    (linker) command line option tells the linker that this program is a console application
    (that is, it will run in a command line window). The `/entry:main` linker option
    passes along the name of the main program to the linker. The linker stores this
    address in a special location in the executable file so Windows can determine
    the starting address of the main program after it loads the executable file into
    memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MASM的`/link`命令行选项告诉它，接下来的命令（直到行末）将被传递给链接器。`/subsystem:console`（链接器）命令行选项告诉链接器这个程序是一个控制台应用程序（也就是说，它将在命令行窗口中运行）。`/entry:main`链接器选项将主程序的名称传递给链接器。链接器将这个地址存储在可执行文件中的一个特殊位置，以便Windows在将可执行文件加载到内存后确定主程序的起始地址。
- en: 16.2 Header Files and the Windows Interface
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 头文件与Windows接口
- en: 'Near the beginning of the “Hello, world!” example in [Listing 16-1](#listing16-1),
    you’ll notice the following lines:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 16-1](#listing16-1)的“Hello, world!”示例的开始部分，你会注意到以下几行：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *kernel32.lib* library file contains the object module definitions for many
    of the Win32 API functions, including the `__imp_GetStdHandle` and `__imp_WriteFile`
    procedures. Inserting `extrn` directives for all the Win32 API functions into
    your assembly language programs is an incredible amount of work. The proper way
    to deal with these function definitions is to include them in a header (include)
    file and then include that file in every application you write that uses the Win32
    API functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*kernel32.lib*库文件包含了许多Win32 API函数的对象模块定义，包括`__imp_GetStdHandle`和`__imp_WriteFile`过程。为所有Win32
    API函数在你的汇编语言程序中插入`extrn`指令是一个巨大的工作量。处理这些函数定义的正确方式是将它们包含在一个头文件（包含文件）中，然后在你编写的每个使用Win32
    API函数的应用程序中都包含这个文件。'
- en: 'The bad news is that creating an appropriate set of header files is a gargantuan
    task. The good news is that somebody else has already done all that work for you:
    the MASM32 headers. [Listing 16-2](#listing16-2) is a rework of [Listing 16-1](#listing16-1)
    that uses the MASM32 64-bit include files to obtain the Win32 external declarations.
    Note that we incorporate MASM32 via an include file, *listing16-2.inc*, rather
    than use it directly. This will be explained in a moment.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是，创建一个合适的头文件集合是一个庞大的任务。好消息是，已经有人为你做了所有这些工作：MASM32头文件。[Listing 16-2](#listing16-2)是[Listing
    16-1](#listing16-1)的重做版，使用MASM32 64位包含文件来获取Win32外部声明。请注意，我们通过包含文件*listing16-2.inc*来引入MASM32，而不是直接使用它。稍后会详细解释。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the *listing16-2.inc* include file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*listing16-2.inc*包含文件：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 16-2: Using the MASM32 64-bit include files'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 16-2: 使用MASM32 64位包含文件'
- en: 'Here’s the build command and sample output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和示例输出：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The MASM32 include file
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MASM32包含文件
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: includes all the other hundreds of include files that are part of the MASM32
    64-bit system. Sticking this include directive into your programs provides your
    application with access to a huge number of Win32 API functions, data declarations,
    and other goodies (such as MASM32 macros).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了MASM32 64位系统中的其他数百个包含文件。将这个包含指令加入到你的程序中，能够为你的应用程序提供对大量Win32 API函数、数据声明和其他资源（如MASM32宏）的访问。
- en: However, your computer will pause for a bit when you assemble your source file.
    That’s because that single include directive winds up including many tens of thousands
    of lines of code into your program during assembly. If you know which header file(s)
    contain the actual declarations you want to use, you can speed up your compilations
    by including just the files you need (as was done in *listing16-2.asm* using the
    MASM32 64-bit include files).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你组装源文件时，计算机会暂停一会儿。这是因为那个单一的包含指令在组装过程中将成千上万行代码包含到程序中。如果你知道哪个头文件包含你需要使用的实际声明，你可以通过只包含必要的文件来加速编译过程（就像在*listing16-2.asm*中使用MASM32
    64位包含文件那样）。
- en: 'Including *masm64rt.inc* into your programs has one other problem: *namespace
    pollution*. The MASM32 include file introduces thousands and thousands of symbols
    into your program, and there is a chance a symbol you want to use has already
    been defined in the MASM32 include files (for a different purpose than the one
    you have in mind). If you have a *file grep* utility, a program that searches
    through files in a directory and recursively in subdirectories for a particular
    string, you can easily locate all occurrences of a particular symbol you want
    to use in your file and copy that symbol’s definition into your own source file
    (or, better yet, into a header file you create specifically for this purpose).
    This is the approach this chapter uses for many of the example programs.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *masm64rt.inc* 引入到你的程序中还存在一个问题：*命名空间污染*。MASM32 包含文件会将成千上万的符号引入到你的程序中，因此有可能你想使用的符号已经在
    MASM32 包含文件中被定义了（并且可能是用于与你想要的用途不同的目的）。如果你有一个 *file grep* 工具，这是一个搜索目录中文件并递归查找子目录中特定字符串的程序，你可以轻松找到你想在文件中使用的符号的所有出现位置，并将该符号的定义复制到你自己的源文件中（或者更好的是，复制到你专门为此目的创建的头文件中）。本章使用这种方法来处理许多示例程序。
- en: 16.3 The Win32 API and the Windows ABI
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 Win32 API 和 Windows ABI
- en: The Win32 API functions all adhere to the Windows ABI calling convention. This
    means that calls to these functions can modify all the volatile registers (RAX,
    RCX, RDX, R8, R9, R10, R11, and XMM0 to XMM5) but must preserve the nonvolatile
    registers (the others not listed here). Also, API calls pass parameters in RDX,
    RCX, R8, R9 (and XMM0 to XMM3), and then on the stack; the stack must be 16-byte-aligned
    prior to the API call. See the discussion of the Windows ABI throughout this book
    for more details.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API 函数都遵循 Windows ABI 调用约定。这意味着对这些函数的调用可以修改所有易失寄存器（RAX、RCX、RDX、R8、R9、R10、R11
    和 XMM0 到 XMM5），但必须保留非易失寄存器（这里没有列出的其他寄存器）。此外，API 调用通过 RDX、RCX、R8、R9（以及 XMM0 到 XMM3）传递参数，然后是栈；在进行
    API 调用之前，栈必须进行 16 字节对齐。有关更多详细信息，请参见本书中关于 Windows ABI 的讨论。
- en: 16.4 Building a Stand-Alone Console Application
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 构建独立的控制台应用程序
- en: Take a look at the (simplified) build command from the preceding section:^([2](#c16-footnote-2))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面章节中的（简化版）构建命令：^([2](#c16-footnote-2))
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `/subsystem:console` option tells the linker that in addition to possible
    GUI windows the application might create, the system must also create a special
    window for the application to display console information. If you run the program
    from a Windows command line, it uses the already-open console window of the *cmd.exe*
    program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`/subsystem:console` 选项告诉链接器，除了可能创建的 GUI 窗口外，系统还必须为应用程序创建一个特殊窗口以显示控制台信息。如果你从
    Windows 命令行运行该程序，它将使用已经打开的 *cmd.exe* 程序的控制台窗口。'
- en: 16.5 Building a Stand-Alone GUI Application
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 构建独立的 GUI 应用程序
- en: To create a pure Windows GUI application that does not also open up a console
    window, you can specify `/subsystem:windows` rather than `/subsystem:console`.
    The simple dialog box application in [Listing 16-3](#listing16-3) is an example
    of an especially simple Windows application. It displays a simple dialog box and
    then quits when the user clicks the OK button in the dialog box.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个纯 Windows GUI 应用程序而不打开控制台窗口，可以指定 `/subsystem:windows` 而不是 `/subsystem:console`。[Listing
    16-3](#listing16-3) 中的简单对话框应用程序是一个特别简单的 Windows 应用程序示例。它显示一个简单的对话框，然后在用户点击对话框中的确定按钮时退出。
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 16-3: A simple dialog box application'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 16-3：一个简单的对话框应用程序
- en: 'Here’s the *listing16-3.inc* include file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *listing16-3.inc* 包含文件：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the build command for the program in [Listing 16-3](#listing16-3):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 [Listing 16-3](#listing16-3) 中程序的构建命令：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Figure 16-1](#figure16-1) shows the runtime output from [Listing 16-3](#listing16-3).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 16-1](#figure16-1) 显示了 [Listing 16-3](#listing16-3) 的运行时输出。'
- en: file:///Users/DisPater/Desktop/Hyde501089/Production/IndesignFiles/image_fi/501089c16/f16001.tiff
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: file:///Users/DisPater/Desktop/Hyde501089/Production/IndesignFiles/image_fi/501089c16/f16001.tiff
- en: 'Figure 16-1: Sample dialog box output'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-1：示例对话框输出
- en: 16.6 A Brief Look at the MessageBox Windows API Function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 简要了解 MessageBox Windows API 函数
- en: Although creating GUI applications in assembly language is well beyond the scope
    of this book, the `MessageBox` function is sufficiently useful (even in console
    applications) to be worth a special mention.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在汇编语言中创建 GUI 应用程序超出了本书的范围，但 `MessageBox` 函数足够实用（即使在控制台应用程序中）值得特别提及。
- en: 'The `MessageBox` function has four parameters:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox` 函数有四个参数：'
- en: RCX Window handle. This is usually NULL (0), implying that the message box is
    a stand-alone dialog box that is not associated with any particular window.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 窗口句柄。通常是NULL（0），表示消息框是一个独立的对话框，未与任何特定窗口关联。
- en: RDX Message pointer. RDX contains a pointer to a zero-terminated string that
    will be displayed in the body of the message box.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDX 消息指针。RDX 包含一个指向零终止字符串的指针，该字符串将在消息框的正文中显示。
- en: R8 Window title. R8 contains a pointer to a zero-terminated string that is displayed
    in the title bar of the message box window.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R8 窗口标题。R8 包含一个指向零终止字符串的指针，该字符串显示在消息框窗口的标题栏中。
- en: 'R9D Message box type. This is an integer value that specifies the type of buttons
    and other icons appearing in the message box. Typical values are the following:
    `MB_OK`, `MB_OKCANCEL`, `MB_ABORTRETRYIGNORE`, `MB_YESNOCANCEL`, `MB_YESNO`, and
    `MB_RETRYCANCEL`.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R9D 消息框类型。这是一个整数值，指定消息框中出现的按钮类型和其他图标。典型的值有：`MB_OK`、`MB_OKCANCEL`、`MB_ABORTRETRYIGNORE`、`MB_YESNOCANCEL`、`MB_YESNO`
    和 `MB_RETRYCANCEL`。
- en: The `MessageBox` function returns an integer value in RAX corresponding to the
    button that was pressed (if `MB_OK` was specified, that’s the value that the message
    box returns when the user clicks the OK button).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBox` 函数返回一个整数值到 RAX，表示用户按下的按钮（如果指定了 `MB_OK`，那么当用户点击“确定”按钮时，消息框返回的就是这个值）。'
- en: 16.7 Windows File I/O
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.7 Windows 文件 I/O
- en: One thing missing from most of the example code in this book has been a discussion
    of file I/O. Although you can easily make C Standard Library calls to open, read,
    write, and close files, it seemed appropriate to use file I/O as an example in
    this chapter to cover this missing detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中大多数示例代码缺少一个关于文件 I/O 的讨论。尽管你可以轻松地使用 C 标准库函数来打开、读取、写入和关闭文件，但在本章中，使用文件 I/O 作为示例，涵盖这个缺失的细节似乎是合适的。
- en: 'The Win32 API provides many useful functions for *file I/O*: reading and writing
    file data. This section describes a small number of these functions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API 提供了许多有用的*文件 I/O*函数：读取和写入文件数据。本节描述了这些函数中的一小部分：
- en: '`CreateFileA` A function (despite its name) that you use to open existing files
    or create new files'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateFileA` 一个函数（尽管它的名字是这样），你用它来打开现有文件或创建新文件。'
- en: '`WriteFile` A function that writes data to a file'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriteFile` 一个函数，用来将数据写入文件。'
- en: '`ReadFile` A function that reads data from a file'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReadFile` 一个函数，用来从文件中读取数据。'
- en: '`CloseHandle` A function that closes a file and flushes any cached data to
    the storage device'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CloseHandle` 一个函数，关闭文件并将任何缓存数据刷新到存储设备。'
- en: '`GetStdHandle` A function, which you’ve already seen, that returns the handle
    of one of the standard input or output devices (standard input, standard output,
    or standard error)'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetStdHandle` 一个你已经见过的函数，它返回标准输入或输出设备（标准输入、标准输出或标准错误）的句柄。'
- en: '`GetLastError` A function you can use to retrieve a Windows error code if an
    error occurs in the execution of any of these functions'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GetLastError` 一个函数，你可以用它来检索 Windows 错误代码，如果在执行这些函数中的任何一个时发生错误。'
- en: '[Listing 16-4](#listing16-4) demonstrates the use of these functions as well
    as the creation of some useful procedures that call these functions. Note that
    this code is rather long, so I’ve taken the liberty of breaking it into smaller
    chunks, with individual explanations in front of each section.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-4](#listing16-4) 演示了这些函数的使用，并创建了一些有用的过程来调用这些函数。请注意，这段代码相当长，因此我已将其拆分成更小的块，并在每个部分前面加上了个别的解释。'
- en: 'The Win32 file I/O functions are all part of the *kernel32.lib* library module.
    Therefore, [Listing 16-4](#listing16-4) uses the `includelib kernel32.lib` statement
    to automatically link in this library during the build phase. To speed up assembly
    and reduce namespace pollution, this program does not automatically include all
    of the MASM32 equate files (via an `include \masm32\include64\masm64rt.inc` statement).
    Instead, I’ve collected all the necessary equates and other definitions from the
    MASM32 header files and placed them in the *listing16-4.inc* header file (which
    appears a little later in this chapter). Finally, the program also includes the
    *aoalib.inc* header file, just to use a few of the constants defined in that file
    (such as `cr` and `nl`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 文件 I/O 函数都属于 *kernel32.lib* 库模块。因此，[清单 16-4](#listing16-4) 使用 `includelib
    kernel32.lib` 语句，在构建阶段自动链接此库。为了加快汇编速度并减少命名空间污染，本程序并没有自动包含所有的 MASM32 等式文件（通过 `include
    \masm32\include64\masm64rt.inc` 语句）。相反，我从 MASM32 头文件中收集了所有必要的等式和其他定义，并将它们放在 *listing16-4.inc*
    头文件中（稍后在本章中会看到）。最后，程序还包含了 *aoalib.inc* 头文件，只是为了使用该文件中定义的一些常量（如 `cr` 和 `nl`）：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code constructs *wrapper code* around each of the file I/O functions
    to preserve the volatile register values. These functions use the following macro
    definitions to save and restore the register values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码围绕每个文件 I/O 函数构建了 *包装代码*，以保留易失性寄存器值。这些函数使用以下宏定义来保存和恢复寄存器值：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first function appearing in [Listing 16-4](#listing16-4) is `getStdOutHandle`.
    This is a wrapper function around `__imp_GetStdHandle` that preserves the volatile
    registers and explicitly requests the standard output device handle. This function
    returns the standard output device handle in the RAX register. Immediately following
    `getStdOutHandle` are comparable functions that retrieve the standard error handle
    and the standard input handle:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 16-4](#listing16-4) 中出现的第一个函数是 `getStdOutHandle`。这是一个包装函数，封装了 `__imp_GetStdHandle`，用于保留易失性寄存器并显式请求标准输出设备句柄。该函数返回标准输出设备句柄，保存在
    RAX 寄存器中。在 `getStdOutHandle` 后面是类似的函数，用于获取标准错误句柄和标准输入句柄：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now consider the wrapper code for the `write` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 `write` 函数的包装代码：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `write` function writes data from a memory buffer to the output file specified
    by a file handle (which could also be the standard output or standard error handle,
    if you want to write data to the console). The `write` function expects the following
    parameter data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 函数将数据从内存缓冲区写入由文件句柄指定的输出文件（如果你希望将数据写入控制台，它也可以是标准输出或标准错误句柄）。`write` 函数期望以下参数数据：'
- en: RAX File handle specifying the write destination. This is typically a handle
    obtained by the `open` or `openNew` functions (a little later in the program)
    or the `getStdOutHandle` and `getStdErrHandle` functions.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAX 文件句柄，指定写入目标。这通常是通过 `open` 或 `openNew` 函数（在程序稍后的部分）或 `getStdOutHandle` 和
    `getStdErrHandle` 函数获得的句柄。
- en: RSI Address of the buffer containing the data to write to the file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RSI 包含要写入文件的数据的缓冲区地址。
- en: RCX Number of bytes of data to write to the file (from the buffer).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 写入文件的数据字节数（来自缓冲区）。
- en: This function does not follow the Windows ABI calling convention. Although there
    isn’t an official *assembly language calling convention*, many assembly language
    programmers tend to use the same registers that the x86-64 string instructions
    use. For example, the source data (buffer) is passed in RSI (the source index
    register), and the count (buffer size) parameter appears in the RCX register.
    The `write` procedure moves the data to appropriate locations for the call to
    `__imp_WriteFile` (as well as sets up additional parameters).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不遵循 Windows ABI 调用约定。虽然没有官方的 *汇编语言调用约定*，但许多汇编语言程序员倾向于使用 x86-64 字符串指令使用的相同寄存器。例如，源数据（缓冲区）通过
    RSI（源索引寄存器）传递，计数（缓冲区大小）参数出现在 RCX 寄存器中。`write` 过程将数据移动到适当位置，以供调用 `__imp_WriteFile`（并设置额外的参数）。
- en: 'The `__imp_WriteFile` function is the actual Win32 API write function (technically,
    `__imp_WriteFile` is a pointer to the function; the call instruction is an indirect
    call through this pointer). The `__imp_WriteFile` has the following arguments:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`__imp_WriteFile` 函数是实际的 Win32 API 写入函数（技术上，`__imp_WriteFile` 是指向该函数的指针；调用指令是通过此指针的间接调用）。`__imp_WriteFile`
    具有以下参数：'
- en: RCX File handle.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 文件句柄。
- en: RDX Buffer address.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDX 缓冲区地址。
- en: R8 Buffer size (really, 32 bits in R8D).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R8 缓冲区大小（实际上是 R8D 中的 32 位）。
- en: R9 Address of a dword variable to receive the number of bytes written to the
    file; this will equal the buffer size if the write operation is successful.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R9 地址，指向一个DWORD变量，用于接收写入文件的字节数；如果写操作成功，该值将等于缓冲区大小。
- en: '[rsp + 32] `lpOverlapped` value; just set this to NULL (0). As per the Windows
    ABI, callers pass all parameters beyond the fourth parameter on the stack, leaving
    room (shadow parameters) for the first four.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[rsp + 32] `lpOverlapped`值；将其设置为NULL（0）。根据Windows ABI，调用者通过栈传递第四个参数之后的所有参数，为前四个参数留出空间（影子参数）。'
- en: On return from `__imp_WriteFile`, RAX contains a nonzero value (true) if the
    write was successful, and zero (false) if there was an error. If there was an
    error, you can call the Win32 `GetLastError` function to retrieve the error code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从`__imp_WriteFile`返回时，如果写入成功，RAX包含非零值（true）；如果出现错误，RAX包含零（false）。如果发生错误，可以调用Win32的`GetLastError`函数来获取错误代码。
- en: Note that the `write` function returns the number of bytes written to the file
    in the RAX register. If there was an error, `write` returns `-1` in the RAX register.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`write`函数将写入文件的字节数返回在RAX寄存器中。如果发生错误，`write`在RAX寄存器中返回`-1`。
- en: 'Next up are the `puts` and `newLn` functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`puts`和`newLn`函数：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `puts` and `newLn` procedures write strings to the standard output device.
    The `puts` function writes a zero-terminated string whose address you pass in
    the RSI register. The `newLn` function writes a newline sequence (carriage return
    and line feed) to the standard output device.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`puts`和`newLn`过程将字符串写入标准输出设备。`puts`函数写入一个以零终止的字符串，其地址通过RSI寄存器传递。`newLn`函数写入一个换行序列（回车和换行符）到标准输出设备。'
- en: 'These two functions have a tiny optimization: they call `getStdOutHandle` only
    once to obtain the standard output device handle. On the first call to either
    of these functions, they call `getStdOutHandle` and cache the result (in the `stdOutHnd`
    variable) and set flag (`hasSOHndl`) that indicates that the cached value is valid.
    Thereafter, these functions use the cached value rather than continually calling
    `getStdOutHandle` to retrieve the standard output device handle.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数有一个小优化：它们只调用`getStdOutHandle`一次来获取标准输出设备句柄。在第一次调用这两个函数中的任何一个时，它们调用`getStdOutHandle`并缓存结果（在`stdOutHnd`变量中），并设置标志（`hasSOHndl`），指示缓存的值有效。之后，这些函数使用缓存值，而不是不断调用`getStdOutHandle`来检索标准输出设备句柄。
- en: The `write` function requires a buffer length; it does not work on zero-terminated
    strings. Therefore, the `puts` function must explicitly determine the length of
    the zero-terminated string before calling `write`. The `newLn` function doesn’t
    have to do this because it knows the length of the carriage return and line feed
    sequence (two characters).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`函数需要一个缓冲区长度；它不适用于以零终止的字符串。因此，`puts`函数在调用`write`之前必须显式确定零终止字符串的长度。`newLn`函数不需要这样做，因为它知道回车换行序列的长度（两个字符）。'
- en: 'The next function in [Listing 16-4](#listing16-4) is the wrapper for the `read`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单16-4](#listing16-4)中的下一个函数是`read`函数的包装器：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `read` function is the input analog to the `write` function. The parameters
    are similar (note, however, that `read` uses RDI as the *destination address*
    for the buffer parameter):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`函数是`write`函数的输入对应函数。参数相似（但请注意，`read`使用RDI作为*目标地址*来传递缓冲区参数）：'
- en: RAX File handle.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAX 文件句柄。
- en: RDI Destination buffer to store data read from file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDI 目标缓冲区，用于存储从文件读取的数据。
- en: RCX Number of bytes to read from the file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 从文件中读取的字节数。
- en: 'The `read` function, a wrapper around the Win32 API `__imp_ReadFile` function,
    has the following arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`函数是对Win32 API `__imp_ReadFile`函数的包装，具有以下参数：'
- en: RCX File handle.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 文件句柄。
- en: RDX File buffer address.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDX 文件缓冲区地址。
- en: R8 Number of bytes to read.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R8 要读取的字节数。
- en: R9 Address of dword variable to receive the number of bytes actually read.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R9 地址，指向一个DWORD变量，用于接收实际读取的字节数。
- en: '[rsp + 32] Overlapped operation; should be NULL (0). As per the Windows ABI,
    callers pass all parameters beyond the fourth parameter on the stack, leaving
    room (shadow parameters) for the first four.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[rsp + 32] 重叠操作；应为NULL（0）。根据Windows ABI，调用者通过栈传递第四个参数之后的所有参数，为前四个参数留出空间（影子参数）。'
- en: The `read` function returns `-1` in RAX if there was an error during the read
    operation. Otherwise, it returns the actual number of bytes read from the file.
    This value can be less than the requested read amount if the read operation reaches
    the end of the file (EOF). A `0` return value generally indicates EOF has been
    reached.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 函数如果在读取操作期间发生错误，会在 RAX 中返回 `-1`。否则，它返回实际从文件中读取的字节数。如果读取操作到达文件结尾（EOF），此值可能会小于请求的读取量。返回值为
    `0` 通常表示已到达文件末尾（EOF）。'
- en: 'The `open` function opens an existing file for reading, writing, or both. It
    is a wrapper function for the Windows `CreateFileA` API call:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数用于打开一个现有的文件进行读取、写入或两者兼有。它是 Windows `CreateFileA` API 调用的封装函数：'
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `open` procedure has two parameters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 过程有两个参数：'
- en: RSI A pointer to a zero-terminated string containing the filename of the file
    to open.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RSI 是指向包含要打开文件的文件名的零终止字符串的指针。
- en: RAX A set of file access flags. These are typically the constants `GENERIC_READ`
    (to open a file for reading), `GENERIC_WRITE` (to open a file for writing), or
    `GENERIC_READ + GENERIC_WRITE` (to open a file for reading and writing).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAX 是一组文件访问标志。通常是常量 `GENERIC_READ`（用于打开文件以进行读取）、`GENERIC_WRITE`（用于打开文件以进行写入）或
    `GENERIC_READ + GENERIC_WRITE`（用于同时打开文件进行读取和写入）。
- en: The `open` function calls the Windows `CreateFileA` function after setting up
    the appropriate parameters for the latter. The `A` suffix on `CreateFileA` stands
    for *ASCII*. This particular function expects the caller to pass an ASCII filename.
    Another function, `CreateFileW`, expects Unicode filenames, encoded as UTF-16\.
    Internally, Windows uses Unicode filenames; when you call `CreateFileA`, it converts
    the ASCII filename to Unicode and then calls `CreateFileW`. The `open` function
    sticks with ASCII characters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数在设置好适当的参数后调用 Windows `CreateFileA` 函数。`CreateFileA` 中的 `A` 后缀代表 *ASCII*。这个函数期望调用者传递一个
    ASCII 文件名。另一个函数 `CreateFileW` 则期望传递 Unicode 文件名，且编码为 UTF-16。Windows 内部使用 Unicode
    文件名；当调用 `CreateFileA` 时，它会将 ASCII 文件名转换为 Unicode，然后调用 `CreateFileW`。`open` 函数坚持使用
    ASCII 字符。'
- en: 'The `CreateFileA` function has the following parameters:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateFileA` 函数具有以下参数：'
- en: RCX Pointer to zero-terminated (ASCII) string holding the name of the file to
    open.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 是指向零终止的（ASCII）字符串，包含要打开文件的文件名。
- en: RDX Read and write access flags (`GENERIC_READ` and `GENERIC_WRITE`).
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDX 读取和写入访问标志（`GENERIC_READ` 和 `GENERIC_WRITE`）。
- en: R8 Sharing mode flag (`0` means exclusive access). Controls whether another
    process can access the file while the current process has it open. Possible flag
    values are `FILE_SHARE_READ`, `FILE_SHARE_WRITE`, and `FILE_SHARE_DELETE` (or
    a combination of these).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R8 共享模式标志（`0` 表示独占访问）。控制当前进程打开文件时，是否允许其他进程访问该文件。可能的标志值有 `FILE_SHARE_READ`、`FILE_SHARE_WRITE`
    和 `FILE_SHARE_DELETE`（或它们的组合）。
- en: R9 Pointer to a security descriptor. The `open` function doesn’t specify any
    special security; it simply passes NULL (0) as this argument.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R9 是指向安全描述符的指针。`open` 函数没有指定任何特殊的安全性，它只是将 NULL (0) 作为该参数传递。
- en: '[rsp + 32] This parameter holds the creation disposition flag. The `open` function
    opens an existing file, so it passes `OPEN_EXISTING` here. Other possible values
    are `CREATE_ALWAYS`, `CREATE_NEW`, `OPEN_ALWAYS`, `OPEN_EXISTING`, or `TRUNCATE_EXISTING`.
    The `OPEN_EXISTING` value requires that the file exists, or it will return an
    open error. Being the fifth parameter, this is passed on the stack (in the fifth
    64-bit slot).'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[rsp + 32] 该参数包含创建处置标志。`open` 函数打开一个现有的文件，因此它传递 `OPEN_EXISTING`。其他可能的值有 `CREATE_ALWAYS`、`CREATE_NEW`、`OPEN_ALWAYS`、`OPEN_EXISTING`
    或 `TRUNCATE_EXISTING`。`OPEN_EXISTING` 要求文件必须存在，否则会返回打开错误。作为第五个参数，该值通过堆栈传递（在第五个
    64 位位置）。'
- en: '[rsp + 40] This parameter contains the file attributes. This function simply
    uses the `FILE_ATTRIBUTE_NORMAL` attribute (for example, not read-only).'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[rsp + 40] 该参数包含文件属性。此函数仅使用 `FILE_ATTRIBUTE_NORMAL` 属性（例如，不是只读的）。'
- en: '[rsp + 48] This parameter is a pointer to a file template handle. The `open`
    function doesn’t use a file template, so it passes NULL (0) in this argument.'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[rsp + 48] 该参数是指向文件模板句柄的指针。`open` 函数不使用文件模板，因此它在该参数中传递 NULL (0)。'
- en: The `open` function returns a file handle in the RAX register. If there was
    an error, this function returns `INVALID_HANDLE_VALUE` in RAX.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 函数返回一个文件句柄，该句柄存储在 RAX 寄存器中。如果发生错误，函数会在 RAX 中返回 `INVALID_HANDLE_VALUE`。'
- en: 'The `openNew` function is also a wrapper around the `CreateFileA` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`openNew` 函数也是对 `CreateFileA` 函数的封装：'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`openNew` creates a new (empty) file on the disk. If the file previously existed,
    `openNew` will delete it before opening the new file. This function is almost
    identical to the preceding `open` function, with the following two differences:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`openNew`在磁盘上创建一个新的（空的）文件。如果文件之前已存在，`openNew`会在打开新文件之前删除它。这个函数与前面的`open`函数几乎相同，只有以下两个区别：'
- en: The caller does not pass the file access flags in the RAX register. The file
    access is always assumed to be `GENERIC_WRITE`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者不通过RAX寄存器传递文件访问标志。文件访问始终假定为`GENERIC_WRITE`。
- en: This function passes the `CREATE_ALWAYS` creation disposition flag to `CreateFileA`
    rather than `OPEN_EXISTING`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数传递`CREATE_ALWAYS`创建方式标志给`CreateFileA`，而不是`OPEN_EXISTING`。
- en: 'The `closeHandle` function is a simple wrapper around the Windows `CloseHandle`
    function. You pass the file handle of the file to close in the RAX register. This
    function returns `0` in RAX if there was an error, or a nonzero file if the file
    close operation was successful. The only purpose of this wrapper is to preserve
    all the volatile registers across the call to the Windows `CloseHandle` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`closeHandle`函数是对Windows `CloseHandle`函数的一个简单封装。你将要关闭的文件句柄传递给RAX寄存器。该函数如果发生错误，则返回RAX中的`0`，如果文件关闭操作成功，则返回一个非零文件句柄。这个封装函数的唯一目的是在调用Windows
    `CloseHandle`函数时保留所有易失性寄存器：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this program doesn’t explicitly use `getLastError`, it does provide
    a wrapper around the `getLastError` function (just to show how it would be written).
    Whenever one of the Windows functions in this program returns an error indication,
    you have to call `getLastError` to retrieve the actual error code. This function
    has no input parameters. It returns the last Windows error code generated in RAX.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该程序没有显式地使用`getLastError`，但它确实提供了一个封装`getLastError`函数的函数（只是为了展示它是如何写的）。每当此程序中的Windows函数返回错误指示时，你必须调用`getLastError`来获取实际的错误代码。该函数没有输入参数。它返回在RAX寄存器中生成的最后一个Windows错误代码。
- en: It is very important to call `getLastError` immediately after a function returns
    an error indication. If you call any other Windows functions between the error
    and retrieval of the error code, those intervening calls will reset the last error
    code value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数返回错误指示后，立即调用`getLastError`非常重要。如果在错误和错误代码检索之间调用了其他Windows函数，这些中介调用将重置最后的错误代码值。
- en: 'As was the case for the `closeHandle` function, the `getLastError` procedure
    is a very simple wrapper around the Windows `GetLastError` function that preserves
    volatile register values across the call:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 和`closeHandle`函数一样，`getLastError`过程是对Windows `GetLastError`函数的一个非常简单的封装，它在调用过程中保留了易失性寄存器的值：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `stdin_read` is a simple wrapper function around the `read` function that
    reads its data from the standard input device (rather than from a file on another
    device):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin_read`是对`read`函数的一个简单封装函数，它从标准输入设备读取数据（而不是从另一个设备上的文件读取数据）：'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`stdin_read` is similar to the `puts` (and `newLn`) procedure insofar as it
    caches the standard input handle on its first call and uses that cached value
    on subsequent calls. Note that `stdin_read` does not (directly) preserve the volatile
    registers. This function does not directly call any Windows functions, so it doesn’t
    have to preserve the volatile registers (`stdin_read` calls the `read` function,
    which preserves the volatile registers). The `stdin_read` function has the following
    parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin_read`类似于`puts`（和`newLn`）过程，因为它在第一次调用时缓存了标准输入句柄，并在随后的调用中使用该缓存值。需要注意的是，`stdin_read`不会（直接）保留易失性寄存器。该函数没有直接调用任何Windows函数，因此不需要保留易失性寄存器（`stdin_read`调用了`read`函数，后者会保留易失性寄存器）。`stdin_read`函数有以下参数：'
- en: RDI Pointer to destination buffer that will receive the characters read from
    the standard input device.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDI 指向目标缓冲区，该缓冲区将接收从标准输入设备读取的字符。
- en: RCX Buffer size (maximum number of bytes to read).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 缓冲区大小（最大读取字节数）。
- en: This function returns the actual number of bytes read in the RAX register. This
    value may be less than the value passed in RCX. If the user presses enter, this
    function immediately returns. This function does not zero-terminate the string
    read from the standard input device. Use the value in the RAX register to determine
    the string’s length. If this function returns because the user pressed enter on
    the standard input device, that carriage return will appear in the buffer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回实际读取的字节数，存储在 RAX 寄存器中。这个值可能小于 RCX 中传递的值。如果用户按下回车键，该函数会立即返回。此函数不会为从标准输入设备读取的字符串添加零终止符。请使用
    RAX 寄存器中的值来确定字符串的长度。如果该函数因为用户在标准输入设备上按下回车键而返回，那么该回车符将出现在缓冲区中。
- en: 'The `stdin_getc` function reads a single character from the standard input
    device and returns that character in the AL register:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdin_getc` 函数从标准输入设备读取一个字符，并将该字符返回到 AL 寄存器：'
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `readLn` function reads a string of characters from the standard input
    device and places them in a caller-specified buffer. The arguments are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`readLn` 函数从标准输入设备读取一串字符，并将其放入调用者指定的缓冲区。参数如下：'
- en: RDI Address of the buffer.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RDI 缓冲区的地址。
- en: RCX Maximum buffer size. (`readLn` allows the user to enter a maximum of RCX
    – 1 characters.)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RCX 最大缓冲区大小。（`readLn` 允许用户输入最多 RCX - 1 个字符。）
- en: 'This function will put a zero-terminating byte at the end of the string input
    by the user. Furthermore, it will strip out the carriage return (or newline or
    line feed) character at the end of the line. It returns the character count in
    RAX (not counting the enter key):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将在用户输入的字符串末尾添加一个零终止字节。此外，它会去除行末的回车符（或换行符或换行符）。它将字符数返回在 RAX 寄存器中（不包括回车键）：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here’s the main program for [Listing 16-4](#listing16-4), which reads a filename
    from the user, opens that file, reads the file data, and displays the data on
    the standard output device:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [列表 16-4](#listing16-4) 的主程序，它从用户处读取文件名，打开该文件，读取文件数据，并将数据显示到标准输出设备：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 16-4: File I/O demonstration program'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-4：文件 I/O 演示程序
- en: 'Here’s the build command and sample output for [Listing 16-4](#listing16-4):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [列表 16-4](#listing16-4) 的构建命令和示例输出：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the *listing16-4.inc* include file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *listing16-4.inc* 包含文件：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the *listing16-4.mak* makefile:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *listing16-4.mak* makefile 文件：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 16.8 Windows Applications
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.8 Windows 应用程序
- en: This chapter has provided just a glimpse of what is possible when writing pure
    assembly language applications that run under Windows. The *kernel32.lib* library
    provides hundreds of functions you can call, covering such diverse topic areas
    as manipulating filesystems (for example, deleting files, looking up filenames
    in a directory, and changing directories), creating threads and synchronizing
    them, processing environment strings, allocating and deallocating memory, manipulating
    the Windows registry, sleeping for a certain time period, waiting for events to
    occur, and much, much more.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅展示了在 Windows 下编写纯汇编语言应用程序时可能实现的一些功能。*kernel32.lib* 库提供了数百个可供调用的函数，涵盖了多个不同的主题领域，如操作文件系统（例如，删除文件、查找目录中的文件名、切换目录）、创建线程并进行同步、处理环境字符串、分配和释放内存、操作
    Windows 注册表、使程序暂停一定时间、等待事件发生等等。
- en: The *kernel32.lib* library is but one of the libraries in the Win32 API. The
    *gdi32.lib* library contains most of the functions needed to create GUI applications
    running under Windows. Creating such applications is well beyond the scope of
    this book, but if you want to create stand-alone Windows GUI applications, you
    need to become intimately familiar with this library. The following “For More
    Information” section provides links to internet resources if you’re interested
    in creating stand-alone Windows GUI applications in assembly language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*kernel32.lib* 库只是 Win32 API 中的一个库。*gdi32.lib* 库包含了创建在 Windows 下运行的 GUI 应用程序所需的大部分函数。创建此类应用程序远超本书的范围，但如果你想创建独立的
    Windows GUI 应用程序，你需要深入了解这个库。以下的“获取更多信息”部分提供了互联网资源链接，如果你有兴趣用汇编语言创建独立的 Windows GUI
    应用程序，可以参考。'
- en: 16.9 For More Information
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.9 获取更多信息
- en: If you want to write stand-alone 64-bit assembly language programs that run
    under Windows, your first stop should be [https://www.masm32.com/](https://www.masm32.com/).
    Although this website is primarily dedicated to creating 32-bit assembly language
    programs that run under Windows, it has a large amount of information for 64-bit
    programmers as well. More importantly, this site contains the header files you
    will need to access the Win32 API from your 64-bit assembly language programs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想编写在 Windows 上运行的独立 64 位汇编语言程序，你的第一站应该是 [https://www.masm32.com/](https://www.masm32.com/)。虽然这个网站主要致力于创建在
    Windows 上运行的 32 位汇编语言程序，但它也为 64 位程序员提供了大量的信息。更重要的是，这个网站包含了你需要从 64 位汇编语言程序访问 Win32
    API 的头文件。
- en: If you’re serious about writing Win32 API–based Windows applications in assembly
    language, Charles Petzold’s *Programming Windows*, Fifth Edition (Microsoft, 1998)
    is an absolutely essential purchase. This book is old (do not get the newer edition
    for C# and XAML), and you likely will have to purchase a used copy. It was written
    for C programmers (not assembly), but if you know the Windows ABI (which you should
    by now), translating all the C calls into assembly language isn’t that difficult.
    Though much of this information about the Win32 API is available online (such
    as at the MASM32 site), having all the information available in a single (very
    large!) book is essential.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算认真编写基于 Win32 API 的 Windows 汇编语言应用程序，Charles Petzold 的 *Programming Windows*（第五版，Microsoft，1998年）是一本绝对必要购买的书。这本书已经很老了（不要购买新版的
    C# 和 XAML 版本），你可能需要购买二手书。它是为 C 程序员（而非汇编程序员）编写的，但如果你了解 Windows ABI（你现在应该已经知道了），将所有的
    C 调用翻译成汇编语言并不难。尽管关于 Win32 API 的很多信息可以在网上找到（例如在 MASM32 网站上），但将所有信息集成在一本（非常大的！）书中是必不可少的。
- en: Another good source on the web for Win32 API calls is software analyst Geoff
    Chappell’s Win32 Programming page ([https://www.geoffchappell.com/studies/windows/win32/](https://www.geoffchappell.com/studies/windows/win32/)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上另一个关于 Win32 API 调用的好资源是软件分析师 Geoff Chappell 的 Win32 编程页面（[https://www.geoffchappell.com/studies/windows/win32/](https://www.geoffchappell.com/studies/windows/win32/)）。
- en: 'The Iczelion tutorials were the original standard for writing Windows programs
    in x86 assembly language. Although they were originally written for 32-bit x86
    assembly language, there have been several translations of this code to 64-bit
    assembly language, for example: [http://masm32.com/board/index.php?topic=4190.0/](http://masm32.com/board/index.php?topic=4190.0/).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Iczelion 教程是编写 x86 汇编语言 Windows 程序的最初标准。尽管它们最初是为 32 位 x86 汇编语言编写的，但已经有多个将该代码翻译成
    64 位汇编语言的版本，例如：[http://masm32.com/board/index.php?topic=4190.0/](http://masm32.com/board/index.php?topic=4190.0/)。
- en: The HLA Standard Library and examples (which can be found at [https://www.randallhyde.com/](https://www.randallhyde.com/))
    contain a ton of Windows code and API function calls. Though this code is all
    32-bit, translating it to 64-bit MASM code is easy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 标准库和示例（可以在 [https://www.randallhyde.com/](https://www.randallhyde.com/)
    找到）包含了大量的 Windows 代码和 API 函数调用。尽管这些代码都是 32 位的，但将它们转换为 64 位的 MASM 代码非常容易。
- en: 16.10 Test Yourself
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.10 自我测试
- en: What is the linker command line option needed to tell MASM that you’re building
    a console application?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉 MASM 你正在构建控制台应用程序的链接器命令行选项是什么？
- en: What website should you visit to get Win32 programming information?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该访问哪个网站来获取 Win32 编程信息？
- en: What is the major drawback to including *\masm32\include64\masm64rt.inc* in
    all your assembly language source files?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *\masm32\include64\masm64rt.inc* 包含在所有汇编语言源文件中的主要缺点是什么？
- en: What linker command line option lets you specify the name of your assembly language
    main program?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个链接器命令行选项允许你指定汇编语言主程序的名称？
- en: What is the name of the Win32 API function that lets you bring up a dialog box?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许你弹出对话框的 Win32 API 函数的名称是什么？
- en: What is wrapper code?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是包装代码？
- en: What is the Win32 API function you would use to open an existing file?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用哪个 Win32 API 函数来打开一个现有文件？
- en: What Win32 API function do you use to retrieve the last Windows error code?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用哪个 Win32 API 函数来检索最后的 Windows 错误代码？
