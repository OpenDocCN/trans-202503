- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stand-Alone Assembly Language Programs
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Until now, this book has relied upon a C/C++ main program to call the example
    code written in assembly language. Although this is probably the biggest use of
    assembly language in the real world, it is also possible to write stand-alone
    code (no C/C++ main program) in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this chapter, *stand-alone assembly language programs* means
    that you’re writing an executable program in assembly that does not directly link
    into a C/C++ program for execution. Without a C/C++ main program calling your
    assembly code, you’re not dragging along the C/C++ library code and runtime system,
    so your programs can be smaller and you won’t have external naming conflicts with
    C/C++ public names. However, you’ll have to do much of the work yourself that
    C/C++ libraries do by writing comparable assembly code or calling the Win32 API.
  prefs: []
  type: TYPE_NORMAL
- en: The *Win32 API* is a bare-metal interface to the Windows operating system that
    provides thousands of functions you can call from a stand-alone assembly language
    program—far too many to consider in this chapter. This chapter provides a basic
    introduction to Win32 applications (especially console-based applications). This
    information will get you started writing stand-alone assembly language programs
    under Windows.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Win32 API from your assembly programs, you’ll need to download the
    MASM32 library package from [https://www.masm32.com/](https://www.masm32.com/).^([1](#c16-footnote-1))
    Most of the examples in this chapter assume the MASM32 64-bit include files are
    available on your system in the *C:\masm32* subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Hello World, by Itself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before showing you some of the wonders of Windows stand-alone assembly language
    programming, perhaps the best place to start is at the beginning: with a stand-alone
    “Hello, world!” program ([Listing 16-1](#listing16-1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-1: Stand-alone “Hello, world!” program'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__imp_``GetStdHandle` and `__imp_``WriteFile` procedures are functions
    inside Windows (they are part of the so-called Win32 API, even though this is
    64-bit code that is executing). The `__imp_GetStdHandle` procedure, when passed
    the (admittedly magic) number –11 as an argument, returns a handle to the standard
    output device. With this handle, calls to `__imp_WriteFile` will send the output
    to the standard output device (the console). To build and run this program, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The MASM `/link` command line option tells it that the following commands (to
    the end of the line) are to be passed on to the linker. The `/subsystem:console`
    (linker) command line option tells the linker that this program is a console application
    (that is, it will run in a command line window). The `/entry:main` linker option
    passes along the name of the main program to the linker. The linker stores this
    address in a special location in the executable file so Windows can determine
    the starting address of the main program after it loads the executable file into
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Header Files and the Windows Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Near the beginning of the “Hello, world!” example in [Listing 16-1](#listing16-1),
    you’ll notice the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The *kernel32.lib* library file contains the object module definitions for many
    of the Win32 API functions, including the `__imp_GetStdHandle` and `__imp_WriteFile`
    procedures. Inserting `extrn` directives for all the Win32 API functions into
    your assembly language programs is an incredible amount of work. The proper way
    to deal with these function definitions is to include them in a header (include)
    file and then include that file in every application you write that uses the Win32
    API functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bad news is that creating an appropriate set of header files is a gargantuan
    task. The good news is that somebody else has already done all that work for you:
    the MASM32 headers. [Listing 16-2](#listing16-2) is a rework of [Listing 16-1](#listing16-1)
    that uses the MASM32 64-bit include files to obtain the Win32 external declarations.
    Note that we incorporate MASM32 via an include file, *listing16-2.inc*, rather
    than use it directly. This will be explained in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the *listing16-2.inc* include file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-2: Using the MASM32 64-bit include files'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The MASM32 include file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: includes all the other hundreds of include files that are part of the MASM32
    64-bit system. Sticking this include directive into your programs provides your
    application with access to a huge number of Win32 API functions, data declarations,
    and other goodies (such as MASM32 macros).
  prefs: []
  type: TYPE_NORMAL
- en: However, your computer will pause for a bit when you assemble your source file.
    That’s because that single include directive winds up including many tens of thousands
    of lines of code into your program during assembly. If you know which header file(s)
    contain the actual declarations you want to use, you can speed up your compilations
    by including just the files you need (as was done in *listing16-2.asm* using the
    MASM32 64-bit include files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Including *masm64rt.inc* into your programs has one other problem: *namespace
    pollution*. The MASM32 include file introduces thousands and thousands of symbols
    into your program, and there is a chance a symbol you want to use has already
    been defined in the MASM32 include files (for a different purpose than the one
    you have in mind). If you have a *file grep* utility, a program that searches
    through files in a directory and recursively in subdirectories for a particular
    string, you can easily locate all occurrences of a particular symbol you want
    to use in your file and copy that symbol’s definition into your own source file
    (or, better yet, into a header file you create specifically for this purpose).
    This is the approach this chapter uses for many of the example programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 The Win32 API and the Windows ABI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Win32 API functions all adhere to the Windows ABI calling convention. This
    means that calls to these functions can modify all the volatile registers (RAX,
    RCX, RDX, R8, R9, R10, R11, and XMM0 to XMM5) but must preserve the nonvolatile
    registers (the others not listed here). Also, API calls pass parameters in RDX,
    RCX, R8, R9 (and XMM0 to XMM3), and then on the stack; the stack must be 16-byte-aligned
    prior to the API call. See the discussion of the Windows ABI throughout this book
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4 Building a Stand-Alone Console Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at the (simplified) build command from the preceding section:^([2](#c16-footnote-2))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `/subsystem:console` option tells the linker that in addition to possible
    GUI windows the application might create, the system must also create a special
    window for the application to display console information. If you run the program
    from a Windows command line, it uses the already-open console window of the *cmd.exe*
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Building a Stand-Alone GUI Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a pure Windows GUI application that does not also open up a console
    window, you can specify `/subsystem:windows` rather than `/subsystem:console`.
    The simple dialog box application in [Listing 16-3](#listing16-3) is an example
    of an especially simple Windows application. It displays a simple dialog box and
    then quits when the user clicks the OK button in the dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-3: A simple dialog box application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the *listing16-3.inc* include file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the build command for the program in [Listing 16-3](#listing16-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 16-1](#figure16-1) shows the runtime output from [Listing 16-3](#listing16-3).'
  prefs: []
  type: TYPE_NORMAL
- en: file:///Users/DisPater/Desktop/Hyde501089/Production/IndesignFiles/image_fi/501089c16/f16001.tiff
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16-1: Sample dialog box output'
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 A Brief Look at the MessageBox Windows API Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although creating GUI applications in assembly language is well beyond the scope
    of this book, the `MessageBox` function is sufficiently useful (even in console
    applications) to be worth a special mention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageBox` function has four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: RCX Window handle. This is usually NULL (0), implying that the message box is
    a stand-alone dialog box that is not associated with any particular window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX Message pointer. RDX contains a pointer to a zero-terminated string that
    will be displayed in the body of the message box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Window title. R8 contains a pointer to a zero-terminated string that is displayed
    in the title bar of the message box window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'R9D Message box type. This is an integer value that specifies the type of buttons
    and other icons appearing in the message box. Typical values are the following:
    `MB_OK`, `MB_OKCANCEL`, `MB_ABORTRETRYIGNORE`, `MB_YESNOCANCEL`, `MB_YESNO`, and
    `MB_RETRYCANCEL`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `MessageBox` function returns an integer value in RAX corresponding to the
    button that was pressed (if `MB_OK` was specified, that’s the value that the message
    box returns when the user clicks the OK button).
  prefs: []
  type: TYPE_NORMAL
- en: 16.7 Windows File I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing missing from most of the example code in this book has been a discussion
    of file I/O. Although you can easily make C Standard Library calls to open, read,
    write, and close files, it seemed appropriate to use file I/O as an example in
    this chapter to cover this missing detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Win32 API provides many useful functions for *file I/O*: reading and writing
    file data. This section describes a small number of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateFileA` A function (despite its name) that you use to open existing files
    or create new files'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WriteFile` A function that writes data to a file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReadFile` A function that reads data from a file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CloseHandle` A function that closes a file and flushes any cached data to
    the storage device'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetStdHandle` A function, which you’ve already seen, that returns the handle
    of one of the standard input or output devices (standard input, standard output,
    or standard error)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetLastError` A function you can use to retrieve a Windows error code if an
    error occurs in the execution of any of these functions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 16-4](#listing16-4) demonstrates the use of these functions as well
    as the creation of some useful procedures that call these functions. Note that
    this code is rather long, so I’ve taken the liberty of breaking it into smaller
    chunks, with individual explanations in front of each section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Win32 file I/O functions are all part of the *kernel32.lib* library module.
    Therefore, [Listing 16-4](#listing16-4) uses the `includelib kernel32.lib` statement
    to automatically link in this library during the build phase. To speed up assembly
    and reduce namespace pollution, this program does not automatically include all
    of the MASM32 equate files (via an `include \masm32\include64\masm64rt.inc` statement).
    Instead, I’ve collected all the necessary equates and other definitions from the
    MASM32 header files and placed them in the *listing16-4.inc* header file (which
    appears a little later in this chapter). Finally, the program also includes the
    *aoalib.inc* header file, just to use a few of the constants defined in that file
    (such as `cr` and `nl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code constructs *wrapper code* around each of the file I/O functions
    to preserve the volatile register values. These functions use the following macro
    definitions to save and restore the register values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function appearing in [Listing 16-4](#listing16-4) is `getStdOutHandle`.
    This is a wrapper function around `__imp_GetStdHandle` that preserves the volatile
    registers and explicitly requests the standard output device handle. This function
    returns the standard output device handle in the RAX register. Immediately following
    `getStdOutHandle` are comparable functions that retrieve the standard error handle
    and the standard input handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the wrapper code for the `write` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` function writes data from a memory buffer to the output file specified
    by a file handle (which could also be the standard output or standard error handle,
    if you want to write data to the console). The `write` function expects the following
    parameter data:'
  prefs: []
  type: TYPE_NORMAL
- en: RAX File handle specifying the write destination. This is typically a handle
    obtained by the `open` or `openNew` functions (a little later in the program)
    or the `getStdOutHandle` and `getStdErrHandle` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RSI Address of the buffer containing the data to write to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Number of bytes of data to write to the file (from the buffer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function does not follow the Windows ABI calling convention. Although there
    isn’t an official *assembly language calling convention*, many assembly language
    programmers tend to use the same registers that the x86-64 string instructions
    use. For example, the source data (buffer) is passed in RSI (the source index
    register), and the count (buffer size) parameter appears in the RCX register.
    The `write` procedure moves the data to appropriate locations for the call to
    `__imp_WriteFile` (as well as sets up additional parameters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__imp_WriteFile` function is the actual Win32 API write function (technically,
    `__imp_WriteFile` is a pointer to the function; the call instruction is an indirect
    call through this pointer). The `__imp_WriteFile` has the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: RCX File handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX Buffer address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Buffer size (really, 32 bits in R8D).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 Address of a dword variable to receive the number of bytes written to the
    file; this will equal the buffer size if the write operation is successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 32] `lpOverlapped` value; just set this to NULL (0). As per the Windows
    ABI, callers pass all parameters beyond the fourth parameter on the stack, leaving
    room (shadow parameters) for the first four.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On return from `__imp_WriteFile`, RAX contains a nonzero value (true) if the
    write was successful, and zero (false) if there was an error. If there was an
    error, you can call the Win32 `GetLastError` function to retrieve the error code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `write` function returns the number of bytes written to the file
    in the RAX register. If there was an error, `write` returns `-1` in the RAX register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up are the `puts` and `newLn` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `puts` and `newLn` procedures write strings to the standard output device.
    The `puts` function writes a zero-terminated string whose address you pass in
    the RSI register. The `newLn` function writes a newline sequence (carriage return
    and line feed) to the standard output device.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions have a tiny optimization: they call `getStdOutHandle` only
    once to obtain the standard output device handle. On the first call to either
    of these functions, they call `getStdOutHandle` and cache the result (in the `stdOutHnd`
    variable) and set flag (`hasSOHndl`) that indicates that the cached value is valid.
    Thereafter, these functions use the cached value rather than continually calling
    `getStdOutHandle` to retrieve the standard output device handle.'
  prefs: []
  type: TYPE_NORMAL
- en: The `write` function requires a buffer length; it does not work on zero-terminated
    strings. Therefore, the `puts` function must explicitly determine the length of
    the zero-terminated string before calling `write`. The `newLn` function doesn’t
    have to do this because it knows the length of the carriage return and line feed
    sequence (two characters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function in [Listing 16-4](#listing16-4) is the wrapper for the `read`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read` function is the input analog to the `write` function. The parameters
    are similar (note, however, that `read` uses RDI as the *destination address*
    for the buffer parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: RAX File handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDI Destination buffer to store data read from file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Number of bytes to read from the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `read` function, a wrapper around the Win32 API `__imp_ReadFile` function,
    has the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: RCX File handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX File buffer address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Number of bytes to read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 Address of dword variable to receive the number of bytes actually read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 32] Overlapped operation; should be NULL (0). As per the Windows ABI,
    callers pass all parameters beyond the fourth parameter on the stack, leaving
    room (shadow parameters) for the first four.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `read` function returns `-1` in RAX if there was an error during the read
    operation. Otherwise, it returns the actual number of bytes read from the file.
    This value can be less than the requested read amount if the read operation reaches
    the end of the file (EOF). A `0` return value generally indicates EOF has been
    reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `open` function opens an existing file for reading, writing, or both. It
    is a wrapper function for the Windows `CreateFileA` API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `open` procedure has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: RSI A pointer to a zero-terminated string containing the filename of the file
    to open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RAX A set of file access flags. These are typically the constants `GENERIC_READ`
    (to open a file for reading), `GENERIC_WRITE` (to open a file for writing), or
    `GENERIC_READ + GENERIC_WRITE` (to open a file for reading and writing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `open` function calls the Windows `CreateFileA` function after setting up
    the appropriate parameters for the latter. The `A` suffix on `CreateFileA` stands
    for *ASCII*. This particular function expects the caller to pass an ASCII filename.
    Another function, `CreateFileW`, expects Unicode filenames, encoded as UTF-16\.
    Internally, Windows uses Unicode filenames; when you call `CreateFileA`, it converts
    the ASCII filename to Unicode and then calls `CreateFileW`. The `open` function
    sticks with ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateFileA` function has the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: RCX Pointer to zero-terminated (ASCII) string holding the name of the file to
    open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RDX Read and write access flags (`GENERIC_READ` and `GENERIC_WRITE`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R8 Sharing mode flag (`0` means exclusive access). Controls whether another
    process can access the file while the current process has it open. Possible flag
    values are `FILE_SHARE_READ`, `FILE_SHARE_WRITE`, and `FILE_SHARE_DELETE` (or
    a combination of these).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: R9 Pointer to a security descriptor. The `open` function doesn’t specify any
    special security; it simply passes NULL (0) as this argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 32] This parameter holds the creation disposition flag. The `open` function
    opens an existing file, so it passes `OPEN_EXISTING` here. Other possible values
    are `CREATE_ALWAYS`, `CREATE_NEW`, `OPEN_ALWAYS`, `OPEN_EXISTING`, or `TRUNCATE_EXISTING`.
    The `OPEN_EXISTING` value requires that the file exists, or it will return an
    open error. Being the fifth parameter, this is passed on the stack (in the fifth
    64-bit slot).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 40] This parameter contains the file attributes. This function simply
    uses the `FILE_ATTRIBUTE_NORMAL` attribute (for example, not read-only).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[rsp + 48] This parameter is a pointer to a file template handle. The `open`
    function doesn’t use a file template, so it passes NULL (0) in this argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `open` function returns a file handle in the RAX register. If there was
    an error, this function returns `INVALID_HANDLE_VALUE` in RAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `openNew` function is also a wrapper around the `CreateFileA` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`openNew` creates a new (empty) file on the disk. If the file previously existed,
    `openNew` will delete it before opening the new file. This function is almost
    identical to the preceding `open` function, with the following two differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller does not pass the file access flags in the RAX register. The file
    access is always assumed to be `GENERIC_WRITE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function passes the `CREATE_ALWAYS` creation disposition flag to `CreateFileA`
    rather than `OPEN_EXISTING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `closeHandle` function is a simple wrapper around the Windows `CloseHandle`
    function. You pass the file handle of the file to close in the RAX register. This
    function returns `0` in RAX if there was an error, or a nonzero file if the file
    close operation was successful. The only purpose of this wrapper is to preserve
    all the volatile registers across the call to the Windows `CloseHandle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although this program doesn’t explicitly use `getLastError`, it does provide
    a wrapper around the `getLastError` function (just to show how it would be written).
    Whenever one of the Windows functions in this program returns an error indication,
    you have to call `getLastError` to retrieve the actual error code. This function
    has no input parameters. It returns the last Windows error code generated in RAX.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to call `getLastError` immediately after a function returns
    an error indication. If you call any other Windows functions between the error
    and retrieval of the error code, those intervening calls will reset the last error
    code value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As was the case for the `closeHandle` function, the `getLastError` procedure
    is a very simple wrapper around the Windows `GetLastError` function that preserves
    volatile register values across the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `stdin_read` is a simple wrapper function around the `read` function that
    reads its data from the standard input device (rather than from a file on another
    device):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`stdin_read` is similar to the `puts` (and `newLn`) procedure insofar as it
    caches the standard input handle on its first call and uses that cached value
    on subsequent calls. Note that `stdin_read` does not (directly) preserve the volatile
    registers. This function does not directly call any Windows functions, so it doesn’t
    have to preserve the volatile registers (`stdin_read` calls the `read` function,
    which preserves the volatile registers). The `stdin_read` function has the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: RDI Pointer to destination buffer that will receive the characters read from
    the standard input device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Buffer size (maximum number of bytes to read).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function returns the actual number of bytes read in the RAX register. This
    value may be less than the value passed in RCX. If the user presses enter, this
    function immediately returns. This function does not zero-terminate the string
    read from the standard input device. Use the value in the RAX register to determine
    the string’s length. If this function returns because the user pressed enter on
    the standard input device, that carriage return will appear in the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stdin_getc` function reads a single character from the standard input
    device and returns that character in the AL register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readLn` function reads a string of characters from the standard input
    device and places them in a caller-specified buffer. The arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: RDI Address of the buffer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RCX Maximum buffer size. (`readLn` allows the user to enter a maximum of RCX
    – 1 characters.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function will put a zero-terminating byte at the end of the string input
    by the user. Furthermore, it will strip out the carriage return (or newline or
    line feed) character at the end of the line. It returns the character count in
    RAX (not counting the enter key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the main program for [Listing 16-4](#listing16-4), which reads a filename
    from the user, opens that file, reads the file data, and displays the data on
    the standard output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-4: File I/O demonstration program'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for [Listing 16-4](#listing16-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the *listing16-4.inc* include file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the *listing16-4.mak* makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 16.8 Windows Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has provided just a glimpse of what is possible when writing pure
    assembly language applications that run under Windows. The *kernel32.lib* library
    provides hundreds of functions you can call, covering such diverse topic areas
    as manipulating filesystems (for example, deleting files, looking up filenames
    in a directory, and changing directories), creating threads and synchronizing
    them, processing environment strings, allocating and deallocating memory, manipulating
    the Windows registry, sleeping for a certain time period, waiting for events to
    occur, and much, much more.
  prefs: []
  type: TYPE_NORMAL
- en: The *kernel32.lib* library is but one of the libraries in the Win32 API. The
    *gdi32.lib* library contains most of the functions needed to create GUI applications
    running under Windows. Creating such applications is well beyond the scope of
    this book, but if you want to create stand-alone Windows GUI applications, you
    need to become intimately familiar with this library. The following “For More
    Information” section provides links to internet resources if you’re interested
    in creating stand-alone Windows GUI applications in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9 For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to write stand-alone 64-bit assembly language programs that run
    under Windows, your first stop should be [https://www.masm32.com/](https://www.masm32.com/).
    Although this website is primarily dedicated to creating 32-bit assembly language
    programs that run under Windows, it has a large amount of information for 64-bit
    programmers as well. More importantly, this site contains the header files you
    will need to access the Win32 API from your 64-bit assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re serious about writing Win32 API–based Windows applications in assembly
    language, Charles Petzold’s *Programming Windows*, Fifth Edition (Microsoft, 1998)
    is an absolutely essential purchase. This book is old (do not get the newer edition
    for C# and XAML), and you likely will have to purchase a used copy. It was written
    for C programmers (not assembly), but if you know the Windows ABI (which you should
    by now), translating all the C calls into assembly language isn’t that difficult.
    Though much of this information about the Win32 API is available online (such
    as at the MASM32 site), having all the information available in a single (very
    large!) book is essential.
  prefs: []
  type: TYPE_NORMAL
- en: Another good source on the web for Win32 API calls is software analyst Geoff
    Chappell’s Win32 Programming page ([https://www.geoffchappell.com/studies/windows/win32/](https://www.geoffchappell.com/studies/windows/win32/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Iczelion tutorials were the original standard for writing Windows programs
    in x86 assembly language. Although they were originally written for 32-bit x86
    assembly language, there have been several translations of this code to 64-bit
    assembly language, for example: [http://masm32.com/board/index.php?topic=4190.0/](http://masm32.com/board/index.php?topic=4190.0/).'
  prefs: []
  type: TYPE_NORMAL
- en: The HLA Standard Library and examples (which can be found at [https://www.randallhyde.com/](https://www.randallhyde.com/))
    contain a ton of Windows code and API function calls. Though this code is all
    32-bit, translating it to 64-bit MASM code is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10 Test Yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the linker command line option needed to tell MASM that you’re building
    a console application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What website should you visit to get Win32 programming information?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the major drawback to including *\masm32\include64\masm64rt.inc* in
    all your assembly language source files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What linker command line option lets you specify the name of your assembly language
    main program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the Win32 API function that lets you bring up a dialog box?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrapper code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Win32 API function you would use to open an existing file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Win32 API function do you use to retrieve the last Windows error code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
