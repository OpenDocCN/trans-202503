- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">23</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BUILDING
    A MINI WEB SERVER</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: The term *web server* may bring to mind a room full of computer servers connected
    by dozens of cables. However, any device with an IP address can act as a web server,
    including your ESP32 board. Thanks to its onboard Wi-Fi connection and software
    libraries, the board can respond to HTTP requests from web browser clients to
    display your required data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll create your own mini web server to monitor, in real
    time, any information gathered or generated by the ESP32 board, allowing anyone
    with access to the server to review the data captured without any additional software
    or tools. You’ll set up a simple web page using HTML to test and demonstrate the
    framework in this chapter and then build a web server to display ESP32 analog
    and digital input status and then another to display date, time, and temperature
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #66: Creating a Basic Text
    Web Server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll create a basic text web server. You can use it as a
    framework to display text or other information built with HTML.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already, turn to [Chapter 19](chapter19.xhtml) and complete the
    instructions in “Configuring the Arduino IDE for the ESP32” through “Testing the
    ESP32” to get your ESP32 working. Be sure to follow the instructions to set up
    port forwarding, if necessary. You should also have completed “BMP180 Sensors”
    in [Chapter 10](chapter10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'For hardware, you’ll need only the ESP32 board and matching USB cable. Once
    you’ve connected your ESP32 to your computer, upload the Project #66 sketch, adding
    your Wi-Fi network and name in the appropriate fields as originally explained
    in Project #55 in [Chapter 19](chapter19.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Serial Monitor in the Arduino IDE. You should see the network name
    (SSID) that the ESP32 has connected to, along with its IP address on your local
    network. [Figure 23-1](chapter23.xhtml#fig23-1), shows a connection to IP address
    192.168.20.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF SERIAL MONITOR SHOWING THE CONNECTION DETAILS](../images/fig23-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-1: The Serial Monitor
    output for Project #66</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now open a web browser and enter the IP address for your project in the URL
    field, as shown in [Figure 23-2](chapter23.xhtml#fig23-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE BASIC WEB SERVER IN ACTION](../images/fig23-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-2: A basic web server
    in action</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes the Wi-Fi library and initializes an instance of a
    web server with port number 80\. The client computer will use this port number
    to contact the web server. That is, if you’re using a static IP address, you’ll
    enter the IP address followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">:80</samp>
    in the web browser’s URL field to reach the web server.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then declares the required variables, including <samp class="SANS_TheSansMonoCd_W5Regular_11">timeoutTime</samp>,
    the length of time in milliseconds that a client can stay connected to your web
    server. If you plan to allow many clients to use the web server, you may want
    to reduce this number, as the server can deal with only one client request at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the code
    starts the Serial Monitor and then connects to the Wi-Fi network as usual. Once
    connected, the IP address is displayed in the Serial Monitor and the web server
    starts. In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the
    ESP32 waits for an incoming request from an HTTP client (a web browser on a remote
    device) ❶. When it receives such a request, the sketch records the current value
    returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> to determine
    how long the client stays connected. As long as the amount of time the client
    is connected is less than the limit set earlier, your web server receives the
    client request and sends it to the Serial Monitor for debugging and observational
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the client request ends, the server sends the following HTTP response
    in HTML ❷:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To send your web page HTML code back to the client web browser, the sketch uses
    <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp> to send text
    to the web client and then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">.println()</samp>to
    send text followed by a newline character to the client, starting with the page
    initialization. You’ll need to begin with this page initialization line of HTML
    every time you form a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the sketch sends the contents of the web page in the form of the following
    HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The sketch replaces <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">millis</samp>
    in the HTML with the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>
    by building up a line of text after the header <samp class="SANS_TheSansMonoCd_W5Regular_11"><h1></samp>
    line ❸ into a string and then sending the string with the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.println(textLine)</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch sends the line to end your web page ❹. As with the page initialization
    code, you’ll always use this same line to end a web page in similar projects.
    Finally, the sketch closes the connection to the client ❺ and the ESP32 awaits
    a new request.
  prefs: []
  type: TYPE_NORMAL
- en: In the next project, you’ll build on the skills you just learned to display
    data relating to the ESP32’s I/O ports on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #67: Creating an ESP32 I/O
    Port Monitor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project displays the status of four digital input pins and four analog
    input pins on your ESP32 board. This gives you the framework for a web server
    that displays data from devices with analog outputs read by the ESP32’s analog
    inputs, such as light sensors or potentiometers, and data from devices with simple
    digital outputs, such as motion sensors or door-activated switches. In this case,
    you’ll stimulate these types of sensors with buttons and trimpots.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need:'
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 dev board and matching USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four tactile buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four 10 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four 10 kΩ breadboard-compatible trimpots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 23-3](chapter23.xhtml#fig23-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #67](../images/fig23-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-3: The schematic
    for Project #67</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Upload the sketch, adding your Wi-Fi network and name in the fields at the top
    of the sketch, then open the Serial Monitor in the Arduino IDE. The Serial Monitor
    should show the network name (SSID) of the Wi-Fi network to which the ESP32 has
    connected, along with the ESP32’s IP address on your local network.
  prefs: []
  type: TYPE_NORMAL
- en: Open this IP address in a web browser using a device on your local network.
    You should be presented with the status website served up by the ESP32\. Adjust
    the trimpots to random positions, hold down one or more buttons in the circuit,
    and then refresh the web browser. The next display should show the values measured
    by the ADC pins and the status of the four digital inputs, as shown in [Figure
    23-4](chapter23.xhtml#fig23-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE OUTPUT FOR PROJECT #67](../images/fig23-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-4: Example output
    from Project #67</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the Arduino Uno and compatible boards, whose ADC has a range of 0 through
    1,023 thanks to its 10-bit resolution, the ADC on the ESP32 boards has a range
    of 0 through 4,095, as it uses 12-bit resolution (2^(12) = 4,096). You can also
    see the calculated voltage for the ADC inputs in the last item of data for each
    analog pin’s status on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like the previous project, this sketch serves an HTML web page after receiving
    a client request. The only differences are the blocks of code required to deal
    with the I/O values and displaying the results in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch declares variables ❶ used to store the status of each of the eight
    inputs—integer variables for the digital inputs, and floating-point variables
    for the analog inputs. It then uses string variables to store the values from
    the ADC that it will later combine with HTML for the web page display. The main
    web page construction starts ❷ with a large header and some text for the user,
    followed by a horizontal line. The sketch stores the values of the digital inputs
    (1 for HIGH, 0 for LOW) ❸ and then the analog values of the four ADCs, converting
    the latter into voltages ❹.
  prefs: []
  type: TYPE_NORMAL
- en: To display the input data on the web page ❺, the sketch tests the status of
    each digital pin, adding the results as text to the string <samp class="SANS_TheSansMonoCd_W5Regular_11">textLine</samp>.
    It displays that text using <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp>
    and repeats the process for the other three digital input pins. Next, it displays
    the values of each analog input and the matching voltage ❻. It concatenates the
    required HTML text for each line into the string <samp class="SANS_TheSansMonoCd_W5Regular_11">textLin</samp>,
    followed by an HTML <samp class="SANS_TheSansMonoCd_W5Regular_11"></p></samp>
    command to end the paragraph. After the sketch sends the line to end the web page
    ❼, the ESP32 closes the connection and awaits a new client request.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the code, the sketch uses the function <samp class="SANS_TheSansMonoCd_W5Regular_11">String()</samp>
    to convert an integer or floating-point value to text to add that value to a larger
    string variable. This is the key to displaying data generated by the sketch within
    an HTML web page.
  prefs: []
  type: TYPE_NORMAL
- en: For more practice in displaying sensor data on a web page, you’ll display more
    types of data on the server web page in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #68: Building a Time and Weather
    Server</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project builds on your existing knowledge to create a web server that displays,
    on request, the current time, date, temperature, and air pressure at sea level.
    This is a good example of displaying data from multiple sources on one web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need:'
  prefs: []
  type: TYPE_NORMAL
- en: An ESP32 dev board and matching USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assorted jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 temperature and air pressure sensor board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 23-5](chapter23.xhtml#fig23-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #68](../images/fig23-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-5: The schematic
    for Project #68</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload the Project #68 sketch, adding your Wi-Fi network and name in the fields
    at the top of the code as usual, then open the Serial Monitor in the Arduino IDE.
    The Serial Monitor should display the network name (SSID) that the ESP32 has connected
    to, along with its IP address on your local network.'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in “Network Time Protocol” in [Chapter 21](chapter21.xhtml), you
    may want to change the network time server IP address and the time zone offset
    to suit your location.
  prefs: []
  type: TYPE_NORMAL
- en: Open the IP address in a web browser using a device on your local network. You
    should see the status website served up by the ESP32, as shown in [Figure 23-6](chapter23.xhtml#fig23-6).
    Refresh the browser to view the latest information at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE OUTPUT FROM PROJECT #68](../images/fig23-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 23-6: Example output
    from Project #68</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The requirements to serve a web page are the same as with the previous project;
    only the code required for the recorded data and display is different. The sketch
    includes the required libraries and starts instances of the Wi-Fi server and the
    Network Time Protocol client.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous projects, the sketch connects to the local-area network Wi-Fi
    and displays the connection details on the Serial Monitor. When a client request
    is received, the ESP32 board sends the web server HTML to the client with the
    first piece of data (the current time) requested from the network time server
    ❶ and then sends the time to the web page with the <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp>
    function. Next, the sketch retrieves the day of the week ❷, determines the name
    of the day with a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch…case</samp>
    function, and sends all this information to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch stores the full date in the string <samp class="SANS_TheSansMonoCd_W5Regular_11">dateString</samp>
    ❸. The date values (day of month, month, and year) are extracted into individual
    string variables so the sketch can use <samp class="SANS_TheSansMonoCd_W5Regular_11">client.print()</samp>
    to send them as part of the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The code adds a horizontal line for a neater display ❹ and then retrieves and
    displays the temperature ❺ and air pressure at sea level ❻. Finally, it completes
    the web page ❼, and the response to the client request is finished.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to create web pages that can display any data you
    can gather or calculate with devices used alongside an ESP32\. From simple weather
    reports to data from sensors in a laboratory, you can put any of this data on
    the web for you or others to use.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers a final IoT skill set, demonstrating how to use an ESP32-controlled
    digital camera for surveillance or fun.
  prefs: []
  type: TYPE_NORMAL
