- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Debugging WebAssembly
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 WebAssembly
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll learn several techniques to debug your WAT code. We’ll
    discuss logging to the console and using alerts, as well as how to log stack traces
    to the console. We’ll cover using the debugger in Firefox and Chrome, the differences
    between them, and the limitations of each debugger.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习几种调试 WAT 代码的技术。我们将讨论如何将日志输出到控制台和使用警报，以及如何将堆栈跟踪输出到控制台。我们还将介绍如何在 Firefox
    和 Chrome 中使用调试器，它们之间的差异，以及各自调试器的局限性。
- en: A *source map*maps code running in the browser to the original precompiled source
    code. It allows a developer writing in languages like TypeScript or frameworks,
    such as React, to step through their original code to debug it. WebAssembly toolchains,
    such as Emscripten, map the generated WebAssembly binary back to the original
    C++ source code. At the time of this writing, *wat2wasm* doesn’t generate source
    maps for WAT code converted to the WebAssembly binary format. This doesn’t render
    debugging WAT code useless, but it does mean that any names for local or global
    variables are lost when it is converted to binary. Therefore, the code you write
    in WAT doesn’t look exactly like what you see in your debugger. You have to manually
    map the specific names you give variables to the generic names assigned by your
    browser debugger. Later in this chapter, you’ll learn how to understand this mapping.
    Once you’ve learned to debug your WebAssembly code, you’ll have the tools to step
    through any WebAssembly code you find on the web, even when you don’t have the
    source code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*源映射*将浏览器中运行的代码映射到原始的预编译源代码。它允许开发者在使用 TypeScript 等语言或 React 等框架时，逐步调试他们的原始代码。WebAssembly
    工具链（如 Emscripten）将生成的 WebAssembly 二进制文件映射回原始的 C++ 源代码。在撰写本文时，*wat2wasm* 并不为转换为
    WebAssembly 二进制格式的 WAT 代码生成源映射。这并不意味着调试 WAT 代码变得毫无意义，但它确实意味着在转换为二进制后，本地或全局变量的任何名称都会丢失。因此，您在
    WAT 中编写的代码看起来与在调试器中看到的代码并不完全一样。您必须手动将变量的特定名称映射到浏览器调试器分配的通用名称。本章稍后您将学到如何理解这种映射。一旦学会了调试您的
    WebAssembly 代码，您将能够使用这些工具逐步调试在网上找到的任何 WebAssembly 代码，即使您没有源代码。'
- en: Debugging from the Console
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从控制台进行调试
- en: The simplest way to start debugging your WebAssembly code is by logging statements
    to the browser console. As you learned earlier, WebAssembly must rely on JavaScript
    to do this. In this chapter, we’ll use a JavaScript function to create debugging
    logs. Let’s create a simple WebAssembly function to calculate the distance between
    two points using the Pythagorean theorem. We’ll introduce an error in the code
    and use it as code to debug. Create a new file named *pythagoras.wat* and add
    the code in [Listing 10-1](#listing10-1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 WebAssembly 代码的最简单方法是通过将语句记录到浏览器控制台。如前所述，WebAssembly 必须依赖 JavaScript 来实现这一点。在本章中，我们将使用一个
    JavaScript 函数来创建调试日志。让我们创建一个简单的 WebAssembly 函数，使用毕达哥拉斯定理计算两点之间的距离。我们将在代码中引入一个错误，并将其用作调试代码。创建一个名为
    *pythagoras.wat* 的新文件，并在其中添加 [Listing 10-1](#listing10-1) 中的代码。
- en: '**pythagoras.wat**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.wat**'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 10-1: Using the Pythagorean theorem to find the distance between two
    points'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 10-1：使用毕达哥拉斯定理计算两点之间的距离
- en: To use the Pythagorean theorem, we make a right triangle on the x-axis and y-axis
    between the two points. The length on the x-axis is the distance between the two
    `x` values. We can find the distance on the y-axis the same way. We can find the
    distance between the two points by squaring these two values, adding them, and
    then taking the square root ([Figure 10-1](#figure10-1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用毕达哥拉斯定理，我们在 x 轴和 y 轴之间的两点之间画一个直角三角形。x 轴上的长度是两个 `x` 值之间的距离。我们也可以用同样的方法计算
    y 轴上的距离。我们可以通过对这两个值进行平方、相加，然后取平方根来得到两点之间的距离（[图 10-1](#figure10-1)）。
- en: '![f10001](Images/f10001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f10001](Images/f10001.png)'
- en: 'Figure 10-1: Calculating the distance between game objects using the Pythagorean
    theorem'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1：使用毕达哥拉斯定理计算游戏对象之间的距离
- en: The math in this example isn’t terribly important. The important detail is that
    we’ve introduced a bug into this code by adding the values of `$y1` and `$y2`
    instead of subtracting them 1 to get the distance between the two y-coordinates.
    Compile *pythagoras.wat* into *pythagoras.wasm* and create a new file named *pythagoras.html*.
    Then add the code in [Listing 10-2](#listing10-2) to *pythagoras.html*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的数学并不特别重要。重要的细节是，我们通过将 `$y1` 和 `$y2` 相加，而不是相减 1 来计算 y 坐标之间的距离，从而在代码中引入了一个
    bug。将 *pythagoras.wat* 编译成 *pythagoras.wasm*，并创建一个名为 *pythagoras.html* 的新文件。然后将
    [Listing 10-2](#listing10-2) 中的代码添加到 *pythagoras.html* 中。
- en: '**pythagoras.html**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.html**'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 10-2: A web application that calls the WebAssembly distance function'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-2：调用 WebAssembly 距离函数的 Web 应用程序
- en: Inside the `body` tag, we set up the user interface by adding number type input
    tags for `x1` 1, `y1` 2, `x2` 3, and `y2` 4 coordinates. We add a `span`tag that
    will hold the distance 5 between the two points after the WebAssembly function
    runs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `body` 标签内，我们通过添加数字类型的输入标签来设置用户界面，包括 `x1` 1, `y1` 2, `x2` 3 和 `y2` 4 坐标。我们还添加了一个
    `span` 标签，用于显示 WebAssembly 函数运行后两点之间的距离 5。
- en: 'Inside the `script` tag, the `importObject` contains a `log_f64` 6 function
    that takes as its parameters a message index and a value. This function logs these
    two values to the browser console. WebAssembly cannot directly pass strings back
    and forth to JavaScript (it must pass an index into linear memory), so it’s frequently
    easier to use a message code and define the strings you want to log from within
    JavaScript. This function uses the template string `` `message #${message_index}
    value=${value}` `` to log the `message_index` and value to the console. Alternatively,
    you could choose from other template strings based on the `message_index` variable.
    The function `set_distance` 7 executes when the user clicks the Find Distance
    button a. This function will get the element ids for the `dist_out` 8 `span` tag,
    as well as the `x1`, `x2`, `y1`, and `y2` input fields. It then executes the WebAssembly
    `distance` 9 function using the values in those input fields.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `script` 标签内，`importObject` 包含一个 `log_f64` 6 函数，它接受消息索引和一个值作为参数。该函数将这两个值记录到浏览器控制台。由于
    WebAssembly 无法直接传递字符串到 JavaScript（必须传递线性内存中的索引），因此通常更容易使用消息代码并在 JavaScript 中定义要记录的字符串。该函数使用模板字符串
    `` `message #${message_index} value=${value}` `` 将 `message_index` 和值记录到控制台。你也可以根据
    `message_index` 变量选择其他模板字符串。`set_distance` 7 函数在用户点击 Find Distance 按钮时执行。该函数会获取
    `dist_out` 8 `span` 标签的元素 ID，以及 `x1`、`x2`、`y1` 和 `y2` 输入字段的 ID。然后它会使用这些输入字段中的值执行
    WebAssembly 的 `distance` 9 函数。'
- en: Run a web server and load the *pythagoras.html* page into a browser; you should
    see something like [Figure 10-2](#figure10-2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个 Web 服务器，并将 *pythagoras.html* 页面加载到浏览器中；你应该会看到类似于[图 10-2](#figure10-2)的内容。
- en: '![f10002](Images/f10002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f10002](Images/f10002.png)'
- en: 'Figure 10-2: The *pythagoras.html* web page screenshot'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：*pythagoras.html* 网页截图
- en: The values you see in [Figure 10-2](#figure10-2) are the default values populated
    in the form. The distance is listed as “??” below where the user can enter the
    coordinates. When we click **Find Distance**, the distance should be 5\. We’re
    using a 3-4-5 triangle to test this distance calculator. As long as the distance
    on the x-axis is 3 and the distance on the y-axis is 4, the distance between the
    two points will be 5 because 3² + 4² = 5², as shown in [Figure 10-3](#figure10-3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-2](#figure10-2)中看到的值是表单中填充的默认值。距离字段下方显示为“??”，用户可以在此输入坐标。当我们点击 **Find
    Distance** 时，距离应该是 5。我们使用 3-4-5 三角形来测试这个距离计算器。只要 x 轴的距离为 3，y 轴的距离为 4，那么两点之间的距离就是
    5，因为 3² + 4² = 5²，正如[图 10-3](#figure10-3)所示。
- en: '![f10003](Images/f10003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f10003](Images/f10003.png)'
- en: 'Figure 10-3: Using a 3-4-5 triangle'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：使用 3-4-5 三角形
- en: When you click the **Find Distance** button on the app, you will see the DISTANCE
    field populated with the value 5 as in [Figure 10-4](#figure10-4).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击应用中的 **Find Distance** 按钮时，你将看到 DISTANCE 字段填充了值 5，如[图 10-4](#figure10-4)所示。
- en: '![f10004](Images/f10004.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f10004](Images/f10004.png)'
- en: 'Figure 10-4: Distance calculated for a 3-4-5 triangle'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：计算出的 3-4-5 三角形距离
- en: When we change both X and Y values by the same amount, the distance between
    the two points should remain the same. However, because of a bug we introduced
    intentionally, adding 1 to both Y1 and Y2 results in the wrong value displayed
    in the DISTANCE field ([Figure 10-5](#figure10-5)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 X 和 Y 值都改变相同的量时，两点之间的距离应该保持不变。然而，由于我们故意引入的一个 bug，将 1 加到 Y1 和 Y2 后，DISTANCE
    字段中显示的值是错误的（见[图 10-5](#figure10-5)）。
- en: '![f10005](Images/f10005.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![f10005](Images/f10005.png)'
- en: 'Figure 10-5: A bug in the calculated distance'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：计算距离中的错误
- en: We should still see 5 in the DISTANCE field, but it’s a different number entirely.
    We need to track down what went wrong; the first step is to add `log` statements
    at several points in our `distance` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该仍然在 DISTANCE 字段中看到 5，但实际上这是一个完全不同的数字。我们需要追踪出错的原因；第一步是在线程中添加 `log` 语句。
- en: As we know, dealing with strings directly in WAT isn’t a simple task. Therefore,
    to step through and debug this code, we use a message id along with a value passed
    to the JavaScript from the WebAssembly module. Using [Listing 10-3](#listing10-3),
    modify the *pythagoras.wat* file to call `$log_f64` from within the `$distance`
    function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，在 WAT 中直接处理字符串并不是一项简单的任务。因此，为了逐步调试代码，我们使用一个消息 ID 以及从 WebAssembly 模块传递给
    JavaScript 的值。使用[清单 10-3](#listing10-3)，修改*pythagoras.wat* 文件，在 `$distance` 函数中调用
    `$log_f64`。
- en: '**pythagoras.wat**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.wat**'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 10-3: The*pythagoras.wat*file updated with JavaScript function calls
    to log f64 variables'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-3：更新后的*pythagoras.wat*文件，添加了 JavaScript 函数调用以记录 f64 变量
- en: We’ve added calls to the `$log_f64` function in several places here (13468a).
    The first parameter in `$log_f64` is the message id, which will be an integer
    we’ll use as the unique id for this message. Later we use this id to output a
    specific message from the JavaScript.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的几个位置添加了对 `$log_f64` 函数的调用（13468a）。`$log_f64` 的第一个参数是消息 ID，这是一个整数，我们将使用它作为此消息的唯一标识符。稍后我们会使用这个
    ID 从 JavaScript 输出特定的消息。
- en: The second parameter is a 64-bit floating-point value, which can show us the
    value at several different stages of our distance calculation. In a number of
    these calls, we want to log the value on the top of the stack but *not* take it
    off, so we use `local.tee` (2579) to set the value of `$temp_f64`, which will
    set the value but not remove it from the stack. We then use the value in `$temp_f64`
    in the call to `$log_f64` (368a).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个 64 位浮点值，它可以在多个不同的阶段显示我们的距离计算值。在其中一些调用中，我们希望记录栈顶的值，但*不*将其移除，因此我们使用 `local.tee`（2579）来设置
    `$temp_f64` 的值，这会设置值但不从栈中移除它。然后我们使用 `$temp_f64` 中的值在调用 `$log_f64`（368a）时。
- en: Logging Messages to the Console
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将消息记录到控制台
- en: As mentioned earlier, WebAssembly modules cannot directly log messages to the
    browser’s console, and WAT has no native string manipulation libraries. The `log_f64`
    function we’ve used so far is imported from JavaScript by the WebAssembly module.
    So, in [Listing 10-4](#listing10-4), we’ll implement this function in the JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，WebAssembly 模块不能直接将消息记录到浏览器的控制台，并且 WAT 没有原生的字符串处理库。我们到目前为止使用的 `log_f64`
    函数是通过 WebAssembly 模块从 JavaScript 导入的。所以，在[清单 10-4](#listing10-4)中，我们将在 JavaScript
    中实现这个函数。
- en: '**pythagoras.html**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.html**'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 10-4: The JavaScript function called by *pythagoras.wat*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-4：*pythagoras.wat* 调用的 JavaScript 函数
- en: This is a pretty straightforward version that logs the message index and the
    value but doesn’t customize the message for any of the `message_index` values.
    To see the console in Chrome, we’ll open Developer tools. Go to the browser menu
    and click **More tools** ([Figure 10-6](#figure10-6)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的版本，它记录了消息索引和数值，但没有根据任何 `message_index` 值自定义消息。要在 Chrome 中查看控制台，我们将打开开发者工具。进入浏览器菜单并点击
    **更多工具**（[图 10-6](#figure10-6)）。
- en: '![f10006](Images/f10006.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f10006](Images/f10006.png)'
- en: 'Figure 10-6: Opening the Chrome Developer tools'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6：打开 Chrome 开发者工具
- en: Click **Developer tools**, and then click the **Console** tab to see the console,
    as shown in [Figure 10-7](#figure10-7).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **开发者工具**，然后点击 **控制台** 标签页以查看控制台，如[图 10-7](#figure10-7)所示。
- en: '![f10007](Images/f10007.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![f10007](Images/f10007.png)'
- en: 'Figure 10-7: Opening the Chrome console'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：打开 Chrome 控制台
- en: To open the console inside Firefox, click the **Web Developer** submenu from
    within the Firefox browser menu, as shown in [Figure 10-8](#figure10-8).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Firefox 中打开控制台，点击 Firefox 浏览器菜单中的 **Web 开发者** 子菜单，如[图 10-8](#figure10-8)所示。
- en: '![f10008](Images/f10008.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![f10008](Images/f10008.png)'
- en: 'Figure 10-8: Opening the Firefox Web Developer menu'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-8：打开 Firefox Web 开发者菜单
- en: Click **Web Console**, as shown in [Figure 10-9](#figure10-9).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Web 控制台**，如[图 10-9](#figure10-9)所示。
- en: '![f10009](Images/f10009.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![f10009](Images/f10009.png)'
- en: 'Figure 10-9: Opening the Firefox Web Console'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-9：打开 Firefox Web 控制台
- en: Your Firefox screen should look similar to [Figure 10-10](#figure10-10).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Firefox 屏幕应该类似于[图 10-10](#figure10-10)所示。
- en: '![f10010](Images/f10010.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![f10010](Images/f10010.png)'
- en: 'Figure 10-10: Displaying messages in the Web Console'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-10：在 Web 控制台中显示消息
- en: 'All messages begin with `message #` followed by the message id.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '所有消息都以 `message #` 开头，后面跟着消息 ID。'
- en: This sort of messaging is frequently all you need, but we’ll make a modification
    to the function to log more specific messages. For example, you might want the
    messages to be more specific to the issue if you’re having trouble keeping track
    of what each message means. You could do it this way, as in [Listing 10-5](#listing10-5),
    or you could have a series of different log functions for different circumstances.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种消息通常已足够，但我们将对函数进行修改，记录更具体的消息。例如，如果你在跟踪每条消息的意义时遇到困难，可能希望消息更具体。你可以像[清单 10-5](#listing10-5)那样操作，或者根据不同的情况，拥有一系列不同的日志函数。
- en: '**pythagoras.html**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.html**'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 10-5: Updated*pythagoras.html*to have a more detailed message'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-5：更新了*pythagoras.html*，以显示更详细的消息
- en: There are six messages, so we create a switch on the `message_index` parameter,
    which prints a different message to the console for each value of `message_index`.
    The switch has a default that displays the original message in case an unexpected
    value for `message_index` is logged. With these messages changed, the console
    output should look similar to [Figure 10-11](#figure10-11).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有六条消息，因此我们在`message_index`参数上创建了一个开关，根据`message_index`的不同值，将不同的消息打印到控制台。该开关有一个默认值，在`message_index`出现意外值时，显示原始消息。更改这些消息后，控制台输出应类似于[图
    10-11](#figure10-11)。
- en: '![f10011](Images/f10011.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![f10011](Images/f10011.png)'
- en: 'Figure 10-11: Descriptive messages logged to the console'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-11：描述性消息记录到控制台
- en: Using Alerts
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用警告
- en: Next, we’ll use JavaScript alerts to pause code execution to give you time to
    look at the logged messages. For this task, we’ll use the `alert` function, which
    opens a dialog with the error text. Know that overusing alerts can make checking
    the logs time-consuming, so it’s best to use them sparingly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用JavaScript警告来暂停代码执行，给你时间查看日志消息。在此任务中，我们将使用`alert`函数，它会打开一个带有错误文本的对话框。请注意，过度使用警告会使检查日志变得耗时，因此最好适度使用它们。
- en: In the earlier `log_f64` example, you might want to alert the user immediately
    if a certain case executes. An `alert` stops code execution and creates a pop-up
    window to notify the user. You only want to use a call to `alert` for unusual
    circumstances that require immediate attention when you’re debugging. In [Listing
    10-6](#listing10-6), we change the `case 1:` code to output an alert in a pop-up
    window instead of to the console. Change the beginning of the `log_f64` function
    to look like [Listing 10-6](#listing10-6).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的`log_f64`示例中，你可能希望在某个特定的情况执行时立即提醒用户。`alert`会停止代码执行并弹出窗口通知用户。你只应在调试时，在需要立即注意的特殊情况下使用`alert`。在[清单
    10-6](#listing10-6)中，我们将`case 1:`的代码更改为在弹出窗口中显示警告，而不是输出到控制台。将`log_f64`函数的开始部分更改为[清单
    10-6](#listing10-6)所示。
- en: '**pythagoras.html**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.html**'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 10-6: Update the *pythagoras.html* fileto call an alert from `log_f64`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-6：更新*pythagoras.html*文件，以调用来自`log_f64`的警告。
- en: We changed the `console.log` function call to `alert` 1 to display the alert
    box when the `message_index` is 1\. The result, shown in [Figure 10-12](#figure10-12),
    should display in the browser.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`console.log`函数调用更改为`alert` 1，当`message_index`为1时显示警告框。结果如[图 10-12](#figure10-12)所示，应在浏览器中显示。
- en: '![f10012](Images/f10012.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f10012](Images/f10012.png)'
- en: 'Figure 10-12: Displaying the alert box'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-12：显示警告框
- en: Stack Trace
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: A *stack trace*displays a list of the functions that have been called to get
    to the current point in the code. For example, if function A calls function B,
    which calls function C, which then executes a stack trace, the stack trace will
    show the functions C, B, and A as well as the lines that called those functions.
    WebAssembly doesn’t offer this feature directly, so as with logging to the console,
    we call the stack trace from JavaScript. The trail of the functions called should
    look similar to [Figure 10-13](#figure10-13).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈跟踪*显示了调用过的函数列表，直到当前代码的这一点。例如，如果函数A调用函数B，函数B又调用函数C，随后执行堆栈跟踪，那么堆栈跟踪将显示函数C、B和A，以及调用这些函数的行。WebAssembly并不直接提供这个功能，因此就像向控制台输出日志一样，我们从JavaScript调用堆栈跟踪。调用的函数链应类似于[图
    10-13](#figure10-13)。'
- en: We display the stack trace with a call to the JavaScript `console.trace` function.
    Firefox and Chrome currently offer stack traces that look quite different from
    each other. Using `console.trace` in Firefox currently gives you more useful information
    about the WAT file than you get using the Chrome browser. The Firefox browser
    converts the WebAssembly binary into a WAT file and provides you with a stack
    trace that references the line in that disassembled WAT file. Chrome, on the other
    hand, gives you a reference to a function index, which can appear quite cryptic
    if you’re not familiar with it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 JavaScript 的`console.trace`函数来显示堆栈跟踪。当前，Firefox 和 Chrome 提供的堆栈跟踪差异较大。使用
    Firefox 中的 `console.trace`，你可以获取比在 Chrome 浏览器中更多的有关 WAT 文件的信息。Firefox 浏览器将 WebAssembly
    二进制文件转换为 WAT 文件，并为你提供一个指向该反汇编 WAT 文件中行号的堆栈跟踪。另一方面，Chrome 给出的只是一个指向函数索引的引用，如果你不熟悉它，可能会显得相当晦涩。
- en: '![f10013](Images/f10013.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![f10013](Images/f10013.png)'
- en: 'Figure 10-13: Function 1 calls function 2, which calls function 3, which calls
    function 4 in stack trace'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-13：函数 1 调用函数 2，函数 2 调用函数 3，函数 3 调用函数 4，堆栈跟踪中的函数调用
- en: Create a file named *stack_trace.wat* and add the code in [Listing 10-7](#listing10-7)
    to it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *stack_trace.wat* 的文件，并将 [列表 10-7](#listing10-7) 中的代码添加到文件中。
- en: '**stack_trace.wat**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**stack_trace.wat**'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 10-7: WebAssembly module demonstrating calls to stack trace'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-7：演示堆栈跟踪调用的 WebAssembly 模块
- en: This WebAssembly module imports the `log_stack_trace` 1 function from JavaScript
    that will call `console.trace` from the embedding JavaScript. We define four more
    functions that demonstrate how each browser logs the WebAssembly call stack. The
    imported function `$log_stack_trace` is called by `$call_stack_trace` and `$call_level_1`
    2. The function `$call_level_1` is called by `$call_stack_trace` and `$call_level_2`
    3. The function `$call_level_2` is called by `$call_stack_trace` and `$call_level_3`
    4. Finally, `$call_level_3` is called by `$call_stack_trace`. We nest these function
    calls to demonstrate how stack traces look when called from different function
    levels.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 WebAssembly 模块从 JavaScript 导入 `log_stack_trace` 1 函数，该函数将调用嵌入的 JavaScript
    中的 `console.trace`。我们定义了四个额外的函数，演示每个浏览器如何记录 WebAssembly 调用栈。导入的函数 `$log_stack_trace`
    由 `$call_stack_trace` 和 `$call_level_1` 2 调用。函数 `$call_level_1` 由 `$call_stack_trace`
    和 `$call_level_2` 3 调用。函数 `$call_level_2` 由 `$call_stack_trace` 和 `$call_level_3`
    4 调用。最后，`$call_level_3` 由 `$call_stack_trace` 调用。我们通过嵌套这些函数调用，展示从不同函数级别调用时堆栈跟踪的样子。
- en: Notice that `$call_stack_trace` 5 calls each of the other functions. First,
    it calls `$log_stack_trace` directly, passing in a constant `0`. Next, it calls
    `$call_level_1`, which calls `$log_stack_trace`, passing it a constant value of
    `1`. When the stack trace is logged, it should show `$call_level_1`, `$log_stack_trace`
    6, and `$call_stack_trace` in the call stack. The `$call_level_2` and `$call_level_3`
    functions each add additional layers that will display in the stack trace.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`$call_stack_trace` 5 调用了其他每个函数。首先，它直接调用 `$log_stack_trace`，并传递一个常量 `0`。接下来，它调用
    `$call_level_1`，该函数调用 `$log_stack_trace`，并传递一个常量值 `1`。当堆栈跟踪被记录时，它应显示 `$call_level_1`、`$log_stack_trace`
    6 和 `$call_stack_trace` 在调用栈中。`$call_level_2` 和 `$call_level_3` 函数会分别添加更多层级，这些层级将在堆栈跟踪中显示。
- en: Now create a new file named *stack_trace.html* and add the code in [Listing
    10-8](#listing10-8).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 *stack_trace.html* 的新文件，并将 [列表 10-8](#listing10-8) 中的代码添加到文件中。
- en: '**stack_trace.html**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**stack_trace.html**'
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 10-8: HTML file with JavaScript calls to stack trace'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10-8：带有 JavaScript 调用堆栈跟踪的 HTML 文件
- en: This is a very basic HTML file, similar to *pythagoras.html*. The primary code
    is the `log_stack_trace` function 1 defined inside `importObject`, which calls
    the JavaScript function `console.trace`, passing in a string that prints to the
    console before the stack trace. Once you’ve saved this HTML file, open it in the
    Firefox browser; you should see similar console logs to [Figure 10-14](#figure10-14).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基础的 HTML 文件，类似于*pythagoras.html*。主要的代码是定义在 `importObject` 内的 `log_stack_trace`
    函数 1，它调用 JavaScript 函数 `console.trace`，并传递一个字符串，该字符串会在堆栈跟踪之前打印到控制台。保存此 HTML 文件后，在
    Firefox 浏览器中打开，你应该会看到类似 [图 10-14](#figure10-14) 的控制台日志。
- en: '![f10014](Images/f10014.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![f10014](Images/f10014.png)'
- en: 'Figure 10-14: Displaying stack traces in Firefox'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-14：在 Firefox 中显示堆栈跟踪
- en: As you can see, the first stack trace was logged with `level=0` because we had
    passed a value of `0` directly into the first call to `$log_stack_trace` in the
    WAT code. That was a direct call from the WebAssembly function `$call_stack_trace`
    to the imported JavaScript function. Because that first call was direct to `$log_stack_trace`,
    there is only one stack frame logged for the *stack_trace.wasm* file in this first
    stack trace. This log indicates that the stack trace was executed from line 98
    of *stack_trace.wasm*. This isn’t necessarily line 98 in your WAT file; you’ll
    need to look at the WAT inside the browser to see which line it’s referring to.
    Each trace adds an additional function call in the WebAssembly file because we
    added an additional function layer to each call to `$log_stack_trace` in the WAT.
    Notice that in each stack trace an additional line is inside *stack_trace.wasm*
    that appears in the trace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个堆栈跟踪是通过`level=0`记录的，因为我们直接将`0`作为值传递给WAT代码中对`$log_stack_trace`的首次调用。这是从WebAssembly函数`$call_stack_trace`到导入的JavaScript函数的直接调用。由于第一次调用是直接调用`$log_stack_trace`，因此在这个第一个堆栈跟踪中，*stack_trace.wasm*文件只有一个堆栈帧被记录。该日志表明堆栈跟踪是从*stack_trace.wasm*的第98行执行的。这不一定是你WAT文件中的第98行；你需要在浏览器中查看WAT，看看它指的是哪一行。每个堆栈跟踪都会在WebAssembly文件中添加一个额外的函数调用，因为我们为每次调用`$log_stack_trace`添加了额外的函数层。注意，在每个堆栈跟踪中，*stack_trace.wasm*内部都会出现额外的一行，该行出现在堆栈跟踪中。
- en: Click one of these lines; Firefox opens the *stack_trace.wasm* file to the location
    in the code where the function call occurred.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点击其中一行，Firefox会打开*stack_trace.wasm*文件，并定位到代码中发生函数调用的位置。
- en: If you haven’t yet opened *stack_trace.wasm* in the Firefox debugger, you might
    be prompted to refresh your browser page to view the contents as disassembled
    WAT. When *stack_trace.wasm* opens to byte 98, you should see something like [Figure
    10-15](#figure10-15) in your Firefox debugger console.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在Firefox调试器中打开*stack_trace.wasm*，你可能会被提示刷新浏览器页面以查看作为反汇编WAT显示的内容。当*stack_trace.wasm*打开到字节98时，你应该在Firefox调试器控制台中看到类似于[图10-15](#figure10-15)的内容。
- en: '![f10015](Images/f10015.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![f10015](Images/f10015.png)'
- en: 'Figure 10-15: Clicking a location in *stack_trace.wasm* displays the WAT code'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-15：点击*stack_trace.wasm*中的位置显示WAT代码
- en: The line that makes the call is temporarily highlighted in gray. Notice that
    the byte number on the left (62) is in hexadecimal, unlike the console log, where
    the byte is the decimal number 98\.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 发出调用的行会暂时以灰色高亮显示。注意左侧的字节数（62）是十六进制的，不像控制台日志中的字节是十进制数字98\。
- en: Chrome doesn’t display the byte number inside the WAT file for each stack trace;
    rather, it looks like [Figure 10-16](#figure10-16).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome不在WAT文件中显示每个堆栈跟踪的字节数；相反，它看起来像是[图10-16](#figure10-16)。
- en: '![f10016](Images/f10016.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![f10016](Images/f10016.png)'
- en: 'Figure 10-16: Displaying stack traces in Chrome'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-16：在Chrome中显示堆栈跟踪
- en: In the Chrome browser, the line number is always 1\. However, when you click
    the link in the console, Chrome opens a disassembled version of that specific
    function. All WebAssembly functions begin with the `wasm-` prefix and end with
    an index for the function followed by `:1`. [Figure 10-17](#figure10-17) shows
    what it should look like when you click the first WebAssembly function that appears
    in a stack trace.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome浏览器中，行号总是1\。但是，当你点击控制台中的链接时，Chrome会打开该特定函数的反汇编版本。所有WebAssembly函数都以`wasm-`为前缀，后跟函数的索引，再加上`:1`。点击堆栈跟踪中出现的第一个WebAssembly函数时，应该像[图10-17](#figure10-17)所示。
- en: '![f10017](Images/f10017.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![f10017](Images/f10017.png)'
- en: 'Figure 10-17: Clicking the stack trace in Chrome displays the WebAssembly function.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-17：点击Chrome中的堆栈跟踪显示WebAssembly函数。
- en: The disassembled function is different in Chrome than in Firefox. We’ll cover
    these differences in more detail beginning in the next section. For now, notice
    that Chrome uses variable and function indexes rather than labels for disassembly,
    which are more challenging to read.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中，反汇编后的函数与Firefox中的不同。我们将在下一节中更详细地讨论这些差异。现在，注意Chrome使用变量和函数索引而不是标签进行反汇编，这使得阅读起来更具挑战性。
- en: Stack traces can be beneficial when you’re trying to figure out how certain
    functions execute. When you’re unsure of how a function is called, stack traces
    can be a lifesaver. Now let’s look at the code in the debuggers for Firefox and
    Chrome.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪在你尝试弄清楚某些函数如何执行时非常有用。当你不确定一个函数是如何被调用时，堆栈跟踪可能会成为救命稻草。接下来，让我们看看Firefox和Chrome中的调试器代码。
- en: The Firefox Debugger
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firefox调试器
- en: In this section, we’ll write some code we can step through in our debugger.
    First, take a moment to review the *pythagoras.html* and *pythagoras.wat* files.
    We intentionally introduced a bug so we could track it in the debugger. We’ll
    modify *pythagoras.wat* by removing calls to log output to JavaScript so we can
    step through it using the debugger. Create a file named *debugger.wat* and add
    the code in [Listing 10-9](#listing10-9), or simply remove the log calls from
    *pythagoras.wat* and resave the file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将编写一些可以在调试器中逐步执行的代码。首先，花点时间查看 *pythagoras.html* 和 *pythagoras.wat* 文件。我们故意引入了一个
    bug，以便在调试器中追踪它。我们将修改 *pythagoras.wat* 文件，移除向 JavaScript 输出日志的调用，以便我们可以在调试器中逐步执行。创建一个名为
    *debugger.wat* 的文件，并添加 [清单 10-9](#listing10-9) 中的代码，或者简单地从 *pythagoras.wat* 中移除日志调用并重新保存文件。
- en: '**debugger.wat**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**debugger.wat**'
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 10-9: We modify *pythagoras.wat* by removing the log calls.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-9：我们通过移除日志调用来修改 *pythagoras.wat*。
- en: Earlier, we introduced a bug to sometimes give an incorrect result by adding
    `$y1` to `$y2` instead of subtracting them. Copy *pythagoras.html* to a new file
    named *debugger.html*, and change the JavaScript code inside the `<script``>`
    tags to instead fetch *debugger.wasm*. Then remove the `importObject` to make
    it look like the code in [Listing 10-10](#listing10-10).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们通过将 `$y1` 加到 `$y2` 上，而不是相减，故意引入了一个有时会给出不正确结果的 bug。将 *pythagoras.html* 复制到一个名为
    *debugger.html* 的新文件中，并将 `<script>` 标签内的 JavaScript 代码改为加载 *debugger.wasm*。然后删除
    `importObject`，使其看起来像 [清单 10-10](#listing10-10) 中的代码。
- en: '**pythagoras.html**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**pythagoras.html**'
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 10-10: HTML file to test *debugger.wasm*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-10：测试 *debugger.wasm* 的 HTML 文件
- en: Load *debugger.html* into Firefox and open the console; then click the **Debugger**
    tab to access the Firefox debugger. From the **Sources** tab on the left, select
    *debugger.wasm* to see the disassembled version of your WAT code, which should
    look like [Figure 10-18](#figure10-18).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *debugger.html* 加载到 Firefox 中并打开控制台；然后点击 **调试器** 标签，进入 Firefox 调试器。在左侧的 **Sources**
    标签下，选择 *debugger.wasm*，查看反汇编版本的 WAT 代码，应该类似于 [图 10-18](#figure10-18)。
- en: '![f10018](Images/f10018.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![f10018](Images/f10018.png)'
- en: 'Figure 10-18: WAT code in the Firefox debugger'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-18：Firefox 调试器中的 WAT 代码
- en: This code is a disassembly of the WebAssembly binary, so now the names of functions
    and variables are no longer available. This result is similar to what you’d see
    if you disassembled a binary you found on the web. Because source maps aren’t
    yet available in *wat2wasm,* we can’t step through the original source code in
    the debugger. Instead, you need to do a side-by-side comparison of the original
    code and the disassembled code. [Listing 10-11](#listing10-11) shows what that
    disassembled code looks like.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是 WebAssembly 二进制的反汇编，因此现在函数和变量的名称不再可用。这个结果类似于你反汇编一个从网上找到的二进制文件。由于在 *wat2wasm*
    中还没有源映射功能，我们无法在调试器中逐步执行原始源代码。相反，你需要将原始代码和反汇编代码进行并排比较。[清单 10-11](#listing10-11)
    显示了反汇编代码的样子。
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 10-11: WAT code generated by Firefox disassembly'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-11：Firefox 反汇编生成的 WAT 代码
- en: This code was disassembled from the WebAssembly binary file and has no awareness
    of the labels we’ve given variables or functions. It’s also unaware of any comments
    in the code. If you look back at the original WAT code ([Listing 10-9](#listing10-9)),
    you can see that the function `$distance` has become `$func0` 1. The parameter
    variables `$x1`, `$y1`, `$x2`, and `$y2` have become `$var0` 2, `$var1` 3, `$var2`
    4, and `$var3` 5, respectively. The local variables `$x_dist` and `$y_dist` have
    become `$var4` 6 and `$var5` 7. Once you know which of the original variables
    corresponds to which of the disassembly variables, you can step through the code
    knowing the variable used. To watch the values in these variables, you can enter
    them into the Watch expressions window on the right without the `$`. In the Watch
    window you can watch the `$var0` variable by entering `var0`. I use a simple trick
    to keep track of which variable is which. I add a JavaScript comment along with
    my watch expression, labeling the variable with its original name. For example,
    I might enter `$var0` into Watch expressions as `var0 // $x1`. [Figure 10-19](#figure10-19)
    shows what that looks like in Watch expressions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是从 WebAssembly 二进制文件反汇编而来的，并没有意识到我们为变量或函数所给的标签。它也无法识别代码中的任何注释。如果你回头查看原始的
    WAT 代码([清单 10-9](#listing10-9))，你可以看到函数`$distance`变成了`$func0` 1。参数变量`$x1`、`$y1`、`$x2`
    和 `$y2` 分别变成了`$var0` 2、`$var1` 3、`$var2` 4 和`$var3` 5。局部变量`$x_dist` 和 `$y_dist`
    变成了`$var4` 6 和`$var5` 7。了解原始变量与反汇编变量之间的对应关系后，你就可以逐步执行代码，知道每个变量的用途。要查看这些变量的值，你可以将它们输入到右侧的
    Watch 表达式窗口中，去掉 `$` 符号。在 Watch 窗口中，你可以通过输入 `var0` 来查看`$var0`变量。我使用一个简单的技巧来跟踪哪个变量对应哪个。我在我的
    Watch 表达式中添加 JavaScript 注释，标记该变量的原始名称。例如，我可能会在 Watch 表达式中输入 `$var0` 为 `var0 //
    $x1`。[图 10-19](#figure10-19) 展示了 Watch 表达式中的效果。
- en: '![f10019](Images/f10019.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![f10019](Images/f10019.png)'
- en: 'Figure 10-19: Watch expressions in Firefox using comments'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-19：在 Firefox 中使用注释的 Watch 表达式
- en: To step through the WAT code, make sure the WebAssembly file is selected. We
    need to create a breakpoint, which is the point at which the debugger stops executing
    the code to allow you to step through one line at a time. To set a breakpoint,
    click the byte number on the left side of the WAT code. You can watch how the
    variables change in your Watch expressions window on the right. With the breakpoint
    set, execute the WebAssembly code by clicking **Find Distance** ([Figure 10-20](#figure10-20)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行 WAT 代码，请确保已选择 WebAssembly 文件。我们需要创建一个断点，这是调试器停止执行代码的地方，以便你可以逐行查看代码。要设置断点，请点击
    WAT 代码左侧的字节编号。在右侧的 Watch 表达式窗口中，你可以看到变量的变化。设置好断点后，通过点击**查找距离**([图 10-20](#figure10-20))来执行
    WebAssembly 代码。
- en: '![f10020](Images/f10020.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![f10020](Images/f10020.png)'
- en: 'Figure 10-20: Setting a breakpoint in the Firefox debugger'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-20：在 Firefox 调试器中设置断点
- en: When execution reaches the breakpoint, click the **Step over** button ![i10001](Images/i10001.png)
    located above Watch expressions. That allows you to step through your code one
    line at a time. To step into a function instead of executing it, click the **Step
    into** button ![i10002](Images/i10002.png) located next to the Step over button.
    To the right of the Step into button, click the **Step out** button ![i10003](Images/i10003.png)
    if you want to step out of the current function you’re in. Click the **Resume**
    button ![i10004](Images/i10004.png), which looks like a play button, to tell the
    debugger to execute until it reaches another breakpoint.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到达断点时，点击位于 Watch 表达式上方的**逐步跳过**按钮 ![i10001](Images/i10001.png)。这将允许你逐行执行代码。要进入一个函数而不是执行它，请点击**逐步进入**按钮
    ![i10002](Images/i10002.png)，该按钮位于**逐步跳过**按钮旁边。如果你想跳出当前的函数，点击**逐步跳出**按钮 ![i10003](Images/i10003.png)。如果你希望调试器继续执行，直到达到另一个断点，点击**恢复**按钮
    ![i10004](Images/i10004.png)，它看起来像一个播放按钮。
- en: To locate the error in the code, click the **Step over** button until you reach
    line 3D. At this point, `var5` is set, and we can see the value inside the Watch
    expressions window, as shown in [Figure 10-21](#figure10-21).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位代码中的错误，请点击**逐步跳过**按钮，直到到达 3D 行。此时，`var5` 已设置，我们可以在 Watch 表达式窗口中看到其值，如[图 10-21](#figure10-21)所示。
- en: '![f10021](Images/f10021.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![f10021](Images/f10021.png)'
- en: 'Figure 10-21: Stepping through the code in the Firefox debugger'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-21：在 Firefox 调试器中逐步执行代码
- en: Notice that `$y_dist` is set to a value of `5` when `Y1` was set to `1` and
    `Y2` was set to `4`. That means that `$y_dist` should have been `3`. Earlier,
    we changed the line numbered 3A from `f64.sub` to `f64.add` to introduce this
    error. Stepping through our code a line at a time in the debugger helped us track
    down the problem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`Y1`被设置为`1`，`Y2`被设置为`4`时，`$y_dist`被设置为`5`。这意味着`$y_dist`本应是`3`。之前，我们将编号为3A的行从`f64.sub`改为`f64.add`，引入了这个错误。通过在调试器中逐行单步执行代码，我们找到了问题所在。
- en: The Chrome Debugger
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chrome调试器
- en: Debugging WebAssembly in Chrome is somewhat different from debugging the same
    code in Firefox. The WAT code isn’t broken down by the WebAssembly file; rather,
    Chrome groups the WAT code by functions. The number at the end of the WebAssembly
    function is an index number based on where you defined the function in your code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中调试WebAssembly与在Firefox中调试相同的代码有所不同。WAT代码不会按WebAssembly文件进行分解；相反，Chrome会按函数对WAT代码进行分组。WebAssembly函数末尾的数字是一个索引号，基于你在代码中定义函数的位置。
- en: To get to the debugger, open the Chrome **Developer tools** and click the **Sources**
    tab. Located in a section labeled Page, you should see a cloud icon labeled wasm.
    Expand this branch to see a page for each function defined in your WebAssembly
    module. Because we’ve only defined one function in this module, only one function
    exists. Click that function to bring up the function’s code in the window on the
    right. In that window, set a breakpoint on line 3 that contains the code `local.get`
    `0` ([Figure 10-22](#figure10-22)).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入调试器，打开Chrome的**开发者工具**并点击**Sources**标签。在名为Page的部分下，你应该看到一个标有`wasm`的云图标。展开此分支，可以看到每个在WebAssembly模块中定义的函数的页面。因为我们在这个模块中只定义了一个函数，所以只有一个函数存在。点击该函数，在右侧窗口中显示该函数的代码。在该窗口中，在包含代码`local.get`
    `0`的第3行设置断点（[图10-22](#figure10-22)）。
- en: '![f10022](Images/f10022.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![f10022](Images/f10022.png)'
- en: 'Figure 10-22: Setting a breakpoint in the Chrome debugger'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-22：在Chrome调试器中设置断点
- en: Notice that `local.get` is getting a number instead of a variable name. The
    reason is that following `local.get` with a number gets the local variable based
    on an index instead of a name. Using `local.get 0` is the equivalent to `local.get`
    `$var0` in the Firefox browser. As in Firefox, you can look at the code and match
    it with the code in your function. [Listing 10-12](#listing10-12) shows the code
    as it appears in the Chrome debugger.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`local.get`获取的是一个数字而不是变量名。原因是，在`local.get`后面跟着一个数字时，会根据索引而不是名称获取局部变量。使用`local.get
    0`等同于在Firefox浏览器中的`local.get` `$var0`。像在Firefox中一样，你可以查看代码，并将其与函数中的代码进行匹配。[清单
    10-12](#listing10-12)展示了在Chrome调试器中显示的代码。
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 10-12: Chrome WAT disassembly in the debugger'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 10-12：Chrome调试器中的WAT反汇编
- en: Notice that Chrome uses indexes for local variables, parameters, and functions.
    The function 1 doesn’t have a name associated with it, nor do any of its parameters
    or local variables 2. The same is true for globals and types. If we were using
    global variables, we would use `global.get` and `global.set`, passing in an index
    number that corresponds to the order in which the variables were defined.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Chrome使用索引来表示局部变量、参数和函数。函数1没有与之关联的名称，它的任何参数或局部变量2也没有名称。全局变量和类型也是如此。如果我们使用全局变量，我们将使用`global.get`和`global.set`，并传入一个与变量定义顺序相对应的索引号。
- en: One nice feature of the Chrome debugging functionality is that you have access
    to the stack in the Scope window. As you step through the code, you can watch
    values get pushed onto and popped off the stack. One of the downsides is that
    the Watch window is much less useful than it is in Firefox, because Chrome doesn’t
    make variables available as if they were JavaScript variables.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome调试功能的一个优点是你可以在作用域窗口中访问堆栈。在逐步执行代码时，你可以看到值被推送到堆栈中，并从堆栈中弹出。一个缺点是，Watch窗口的用处远不如在Firefox中，因为Chrome不会像在JavaScript变量那样使变量可用。
- en: As in Firefox, Chrome has a Resume button ![i10005](Images/i10005.png), a Step
    over button ![i10006](Images/i10006.png), a Step into button ![i10007](Images/i10007.png),
    and a Step out button ![i10008](Images/i10008.png), as highlighted in [Figure
    10-23](#figure10-23).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 和Firefox一样，Chrome有一个Resume按钮 ![i10005](Images/i10005.png)、一个Step over按钮 ![i10006](Images/i10006.png)、一个Step
    into按钮 ![i10007](Images/i10007.png)和一个Step out按钮 ![i10008](Images/i10008.png)，如[图10-23](#figure10-23)所示。
- en: '![f10023](Images/f10023.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![f10023](Images/f10023.png)'
- en: 'Figure 10-23: Viewing the stack in the Chrome debugger'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-23：在Chrome调试器中查看堆栈
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we debugged WAT code using a variety of different techniques
    in Chrome and in Firefox. We looked at logging to the console in more depth than
    we had in earlier chapters. We then used the JavaScript `alert` function to stop
    execution and wait for user instruction. We also explored using *console.trace*
    to log a stack trace and discussed the differences between the way the stack trace
    works in Chrome and Firefox. Finally, we used the built-in debuggers in Chrome
    and Firefox.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了多种不同的技术在 Chrome 和 Firefox 中调试 WAT 代码。我们对控制台日志记录进行了比之前章节更深入的探讨。接着，我们使用了
    JavaScript 的`alert`函数来暂停执行并等待用户指令。我们还探索了使用*console.trace*来记录堆栈跟踪，并讨论了 Chrome 和
    Firefox 中堆栈跟踪的工作方式差异。最后，我们使用了 Chrome 和 Firefox 内置的调试器。
- en: Many options are available for debugging WebAssembly. Some of the options, such
    as using the Chrome or Firefox debuggers, are still being developed. Which tools
    you decide to use will depend on the code and your goal when debugging. In the
    next chapter, we’ll use WebAssembly to build Node.js modules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 WebAssembly 有多种可用选项。其中一些选项，例如使用 Chrome 或 Firefox 调试器，仍在开发中。你选择使用的工具将取决于代码和调试时的目标。在下一章中，我们将使用
    WebAssembly 构建 Node.js 模块。
