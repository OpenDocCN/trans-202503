- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging WebAssembly
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn several techniques to debug your WAT code. We’ll
    discuss logging to the console and using alerts, as well as how to log stack traces
    to the console. We’ll cover using the debugger in Firefox and Chrome, the differences
    between them, and the limitations of each debugger.
  prefs: []
  type: TYPE_NORMAL
- en: A *source map*maps code running in the browser to the original precompiled source
    code. It allows a developer writing in languages like TypeScript or frameworks,
    such as React, to step through their original code to debug it. WebAssembly toolchains,
    such as Emscripten, map the generated WebAssembly binary back to the original
    C++ source code. At the time of this writing, *wat2wasm* doesn’t generate source
    maps for WAT code converted to the WebAssembly binary format. This doesn’t render
    debugging WAT code useless, but it does mean that any names for local or global
    variables are lost when it is converted to binary. Therefore, the code you write
    in WAT doesn’t look exactly like what you see in your debugger. You have to manually
    map the specific names you give variables to the generic names assigned by your
    browser debugger. Later in this chapter, you’ll learn how to understand this mapping.
    Once you’ve learned to debug your WebAssembly code, you’ll have the tools to step
    through any WebAssembly code you find on the web, even when you don’t have the
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging from the Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to start debugging your WebAssembly code is by logging statements
    to the browser console. As you learned earlier, WebAssembly must rely on JavaScript
    to do this. In this chapter, we’ll use a JavaScript function to create debugging
    logs. Let’s create a simple WebAssembly function to calculate the distance between
    two points using the Pythagorean theorem. We’ll introduce an error in the code
    and use it as code to debug. Create a new file named *pythagoras.wat* and add
    the code in [Listing 10-1](#listing10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Using the Pythagorean theorem to find the distance between two
    points'
  prefs: []
  type: TYPE_NORMAL
- en: To use the Pythagorean theorem, we make a right triangle on the x-axis and y-axis
    between the two points. The length on the x-axis is the distance between the two
    `x` values. We can find the distance on the y-axis the same way. We can find the
    distance between the two points by squaring these two values, adding them, and
    then taking the square root ([Figure 10-1](#figure10-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](Images/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: Calculating the distance between game objects using the Pythagorean
    theorem'
  prefs: []
  type: TYPE_NORMAL
- en: The math in this example isn’t terribly important. The important detail is that
    we’ve introduced a bug into this code by adding the values of `$y1` and `$y2`
    instead of subtracting them 1 to get the distance between the two y-coordinates.
    Compile *pythagoras.wat* into *pythagoras.wasm* and create a new file named *pythagoras.html*.
    Then add the code in [Listing 10-2](#listing10-2) to *pythagoras.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: A web application that calls the WebAssembly distance function'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `body` tag, we set up the user interface by adding number type input
    tags for `x1` 1, `y1` 2, `x2` 3, and `y2` 4 coordinates. We add a `span`tag that
    will hold the distance 5 between the two points after the WebAssembly function
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `script` tag, the `importObject` contains a `log_f64` 6 function
    that takes as its parameters a message index and a value. This function logs these
    two values to the browser console. WebAssembly cannot directly pass strings back
    and forth to JavaScript (it must pass an index into linear memory), so it’s frequently
    easier to use a message code and define the strings you want to log from within
    JavaScript. This function uses the template string `` `message #${message_index}
    value=${value}` `` to log the `message_index` and value to the console. Alternatively,
    you could choose from other template strings based on the `message_index` variable.
    The function `set_distance` 7 executes when the user clicks the Find Distance
    button a. This function will get the element ids for the `dist_out` 8 `span` tag,
    as well as the `x1`, `x2`, `y1`, and `y2` input fields. It then executes the WebAssembly
    `distance` 9 function using the values in those input fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Run a web server and load the *pythagoras.html* page into a browser; you should
    see something like [Figure 10-2](#figure10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10002](Images/f10002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: The *pythagoras.html* web page screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: The values you see in [Figure 10-2](#figure10-2) are the default values populated
    in the form. The distance is listed as “??” below where the user can enter the
    coordinates. When we click **Find Distance**, the distance should be 5\. We’re
    using a 3-4-5 triangle to test this distance calculator. As long as the distance
    on the x-axis is 3 and the distance on the y-axis is 4, the distance between the
    two points will be 5 because 3² + 4² = 5², as shown in [Figure 10-3](#figure10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10003](Images/f10003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: Using a 3-4-5 triangle'
  prefs: []
  type: TYPE_NORMAL
- en: When you click the **Find Distance** button on the app, you will see the DISTANCE
    field populated with the value 5 as in [Figure 10-4](#figure10-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10004](Images/f10004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: Distance calculated for a 3-4-5 triangle'
  prefs: []
  type: TYPE_NORMAL
- en: When we change both X and Y values by the same amount, the distance between
    the two points should remain the same. However, because of a bug we introduced
    intentionally, adding 1 to both Y1 and Y2 results in the wrong value displayed
    in the DISTANCE field ([Figure 10-5](#figure10-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10005](Images/f10005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: A bug in the calculated distance'
  prefs: []
  type: TYPE_NORMAL
- en: We should still see 5 in the DISTANCE field, but it’s a different number entirely.
    We need to track down what went wrong; the first step is to add `log` statements
    at several points in our `distance` function.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, dealing with strings directly in WAT isn’t a simple task. Therefore,
    to step through and debug this code, we use a message id along with a value passed
    to the JavaScript from the WebAssembly module. Using [Listing 10-3](#listing10-3),
    modify the *pythagoras.wat* file to call `$log_f64` from within the `$distance`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: The*pythagoras.wat*file updated with JavaScript function calls
    to log f64 variables'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added calls to the `$log_f64` function in several places here (13468a).
    The first parameter in `$log_f64` is the message id, which will be an integer
    we’ll use as the unique id for this message. Later we use this id to output a
    specific message from the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a 64-bit floating-point value, which can show us the
    value at several different stages of our distance calculation. In a number of
    these calls, we want to log the value on the top of the stack but *not* take it
    off, so we use `local.tee` (2579) to set the value of `$temp_f64`, which will
    set the value but not remove it from the stack. We then use the value in `$temp_f64`
    in the call to `$log_f64` (368a).
  prefs: []
  type: TYPE_NORMAL
- en: Logging Messages to the Console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, WebAssembly modules cannot directly log messages to the
    browser’s console, and WAT has no native string manipulation libraries. The `log_f64`
    function we’ve used so far is imported from JavaScript by the WebAssembly module.
    So, in [Listing 10-4](#listing10-4), we’ll implement this function in the JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: The JavaScript function called by *pythagoras.wat*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a pretty straightforward version that logs the message index and the
    value but doesn’t customize the message for any of the `message_index` values.
    To see the console in Chrome, we’ll open Developer tools. Go to the browser menu
    and click **More tools** ([Figure 10-6](#figure10-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10006](Images/f10006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: Opening the Chrome Developer tools'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Developer tools**, and then click the **Console** tab to see the console,
    as shown in [Figure 10-7](#figure10-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10007](Images/f10007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7: Opening the Chrome console'
  prefs: []
  type: TYPE_NORMAL
- en: To open the console inside Firefox, click the **Web Developer** submenu from
    within the Firefox browser menu, as shown in [Figure 10-8](#figure10-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10008](Images/f10008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-8: Opening the Firefox Web Developer menu'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Web Console**, as shown in [Figure 10-9](#figure10-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10009](Images/f10009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-9: Opening the Firefox Web Console'
  prefs: []
  type: TYPE_NORMAL
- en: Your Firefox screen should look similar to [Figure 10-10](#figure10-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10010](Images/f10010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-10: Displaying messages in the Web Console'
  prefs: []
  type: TYPE_NORMAL
- en: 'All messages begin with `message #` followed by the message id.'
  prefs: []
  type: TYPE_NORMAL
- en: This sort of messaging is frequently all you need, but we’ll make a modification
    to the function to log more specific messages. For example, you might want the
    messages to be more specific to the issue if you’re having trouble keeping track
    of what each message means. You could do it this way, as in [Listing 10-5](#listing10-5),
    or you could have a series of different log functions for different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Updated*pythagoras.html*to have a more detailed message'
  prefs: []
  type: TYPE_NORMAL
- en: There are six messages, so we create a switch on the `message_index` parameter,
    which prints a different message to the console for each value of `message_index`.
    The switch has a default that displays the original message in case an unexpected
    value for `message_index` is logged. With these messages changed, the console
    output should look similar to [Figure 10-11](#figure10-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10011](Images/f10011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-11: Descriptive messages logged to the console'
  prefs: []
  type: TYPE_NORMAL
- en: Using Alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll use JavaScript alerts to pause code execution to give you time to
    look at the logged messages. For this task, we’ll use the `alert` function, which
    opens a dialog with the error text. Know that overusing alerts can make checking
    the logs time-consuming, so it’s best to use them sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the earlier `log_f64` example, you might want to alert the user immediately
    if a certain case executes. An `alert` stops code execution and creates a pop-up
    window to notify the user. You only want to use a call to `alert` for unusual
    circumstances that require immediate attention when you’re debugging. In [Listing
    10-6](#listing10-6), we change the `case 1:` code to output an alert in a pop-up
    window instead of to the console. Change the beginning of the `log_f64` function
    to look like [Listing 10-6](#listing10-6).
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Update the *pythagoras.html* fileto call an alert from `log_f64`.'
  prefs: []
  type: TYPE_NORMAL
- en: We changed the `console.log` function call to `alert` 1 to display the alert
    box when the `message_index` is 1\. The result, shown in [Figure 10-12](#figure10-12),
    should display in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10012](Images/f10012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-12: Displaying the alert box'
  prefs: []
  type: TYPE_NORMAL
- en: Stack Trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *stack trace*displays a list of the functions that have been called to get
    to the current point in the code. For example, if function A calls function B,
    which calls function C, which then executes a stack trace, the stack trace will
    show the functions C, B, and A as well as the lines that called those functions.
    WebAssembly doesn’t offer this feature directly, so as with logging to the console,
    we call the stack trace from JavaScript. The trail of the functions called should
    look similar to [Figure 10-13](#figure10-13).
  prefs: []
  type: TYPE_NORMAL
- en: We display the stack trace with a call to the JavaScript `console.trace` function.
    Firefox and Chrome currently offer stack traces that look quite different from
    each other. Using `console.trace` in Firefox currently gives you more useful information
    about the WAT file than you get using the Chrome browser. The Firefox browser
    converts the WebAssembly binary into a WAT file and provides you with a stack
    trace that references the line in that disassembled WAT file. Chrome, on the other
    hand, gives you a reference to a function index, which can appear quite cryptic
    if you’re not familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10013](Images/f10013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-13: Function 1 calls function 2, which calls function 3, which calls
    function 4 in stack trace'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named *stack_trace.wat* and add the code in [Listing 10-7](#listing10-7)
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**stack_trace.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: WebAssembly module demonstrating calls to stack trace'
  prefs: []
  type: TYPE_NORMAL
- en: This WebAssembly module imports the `log_stack_trace` 1 function from JavaScript
    that will call `console.trace` from the embedding JavaScript. We define four more
    functions that demonstrate how each browser logs the WebAssembly call stack. The
    imported function `$log_stack_trace` is called by `$call_stack_trace` and `$call_level_1`
    2. The function `$call_level_1` is called by `$call_stack_trace` and `$call_level_2`
    3. The function `$call_level_2` is called by `$call_stack_trace` and `$call_level_3`
    4. Finally, `$call_level_3` is called by `$call_stack_trace`. We nest these function
    calls to demonstrate how stack traces look when called from different function
    levels.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `$call_stack_trace` 5 calls each of the other functions. First,
    it calls `$log_stack_trace` directly, passing in a constant `0`. Next, it calls
    `$call_level_1`, which calls `$log_stack_trace`, passing it a constant value of
    `1`. When the stack trace is logged, it should show `$call_level_1`, `$log_stack_trace`
    6, and `$call_stack_trace` in the call stack. The `$call_level_2` and `$call_level_3`
    functions each add additional layers that will display in the stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Now create a new file named *stack_trace.html* and add the code in [Listing
    10-8](#listing10-8).
  prefs: []
  type: TYPE_NORMAL
- en: '**stack_trace.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: HTML file with JavaScript calls to stack trace'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very basic HTML file, similar to *pythagoras.html*. The primary code
    is the `log_stack_trace` function 1 defined inside `importObject`, which calls
    the JavaScript function `console.trace`, passing in a string that prints to the
    console before the stack trace. Once you’ve saved this HTML file, open it in the
    Firefox browser; you should see similar console logs to [Figure 10-14](#figure10-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10014](Images/f10014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-14: Displaying stack traces in Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the first stack trace was logged with `level=0` because we had
    passed a value of `0` directly into the first call to `$log_stack_trace` in the
    WAT code. That was a direct call from the WebAssembly function `$call_stack_trace`
    to the imported JavaScript function. Because that first call was direct to `$log_stack_trace`,
    there is only one stack frame logged for the *stack_trace.wasm* file in this first
    stack trace. This log indicates that the stack trace was executed from line 98
    of *stack_trace.wasm*. This isn’t necessarily line 98 in your WAT file; you’ll
    need to look at the WAT inside the browser to see which line it’s referring to.
    Each trace adds an additional function call in the WebAssembly file because we
    added an additional function layer to each call to `$log_stack_trace` in the WAT.
    Notice that in each stack trace an additional line is inside *stack_trace.wasm*
    that appears in the trace.
  prefs: []
  type: TYPE_NORMAL
- en: Click one of these lines; Firefox opens the *stack_trace.wasm* file to the location
    in the code where the function call occurred.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t yet opened *stack_trace.wasm* in the Firefox debugger, you might
    be prompted to refresh your browser page to view the contents as disassembled
    WAT. When *stack_trace.wasm* opens to byte 98, you should see something like [Figure
    10-15](#figure10-15) in your Firefox debugger console.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10015](Images/f10015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-15: Clicking a location in *stack_trace.wasm* displays the WAT code'
  prefs: []
  type: TYPE_NORMAL
- en: The line that makes the call is temporarily highlighted in gray. Notice that
    the byte number on the left (62) is in hexadecimal, unlike the console log, where
    the byte is the decimal number 98\.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome doesn’t display the byte number inside the WAT file for each stack trace;
    rather, it looks like [Figure 10-16](#figure10-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10016](Images/f10016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-16: Displaying stack traces in Chrome'
  prefs: []
  type: TYPE_NORMAL
- en: In the Chrome browser, the line number is always 1\. However, when you click
    the link in the console, Chrome opens a disassembled version of that specific
    function. All WebAssembly functions begin with the `wasm-` prefix and end with
    an index for the function followed by `:1`. [Figure 10-17](#figure10-17) shows
    what it should look like when you click the first WebAssembly function that appears
    in a stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10017](Images/f10017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-17: Clicking the stack trace in Chrome displays the WebAssembly function.'
  prefs: []
  type: TYPE_NORMAL
- en: The disassembled function is different in Chrome than in Firefox. We’ll cover
    these differences in more detail beginning in the next section. For now, notice
    that Chrome uses variable and function indexes rather than labels for disassembly,
    which are more challenging to read.
  prefs: []
  type: TYPE_NORMAL
- en: Stack traces can be beneficial when you’re trying to figure out how certain
    functions execute. When you’re unsure of how a function is called, stack traces
    can be a lifesaver. Now let’s look at the code in the debuggers for Firefox and
    Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: The Firefox Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll write some code we can step through in our debugger.
    First, take a moment to review the *pythagoras.html* and *pythagoras.wat* files.
    We intentionally introduced a bug so we could track it in the debugger. We’ll
    modify *pythagoras.wat* by removing calls to log output to JavaScript so we can
    step through it using the debugger. Create a file named *debugger.wat* and add
    the code in [Listing 10-9](#listing10-9), or simply remove the log calls from
    *pythagoras.wat* and resave the file.
  prefs: []
  type: TYPE_NORMAL
- en: '**debugger.wat**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: We modify *pythagoras.wat* by removing the log calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we introduced a bug to sometimes give an incorrect result by adding
    `$y1` to `$y2` instead of subtracting them. Copy *pythagoras.html* to a new file
    named *debugger.html*, and change the JavaScript code inside the `<script``>`
    tags to instead fetch *debugger.wasm*. Then remove the `importObject` to make
    it look like the code in [Listing 10-10](#listing10-10).
  prefs: []
  type: TYPE_NORMAL
- en: '**pythagoras.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: HTML file to test *debugger.wasm*'
  prefs: []
  type: TYPE_NORMAL
- en: Load *debugger.html* into Firefox and open the console; then click the **Debugger**
    tab to access the Firefox debugger. From the **Sources** tab on the left, select
    *debugger.wasm* to see the disassembled version of your WAT code, which should
    look like [Figure 10-18](#figure10-18).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10018](Images/f10018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-18: WAT code in the Firefox debugger'
  prefs: []
  type: TYPE_NORMAL
- en: This code is a disassembly of the WebAssembly binary, so now the names of functions
    and variables are no longer available. This result is similar to what you’d see
    if you disassembled a binary you found on the web. Because source maps aren’t
    yet available in *wat2wasm,* we can’t step through the original source code in
    the debugger. Instead, you need to do a side-by-side comparison of the original
    code and the disassembled code. [Listing 10-11](#listing10-11) shows what that
    disassembled code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: WAT code generated by Firefox disassembly'
  prefs: []
  type: TYPE_NORMAL
- en: This code was disassembled from the WebAssembly binary file and has no awareness
    of the labels we’ve given variables or functions. It’s also unaware of any comments
    in the code. If you look back at the original WAT code ([Listing 10-9](#listing10-9)),
    you can see that the function `$distance` has become `$func0` 1. The parameter
    variables `$x1`, `$y1`, `$x2`, and `$y2` have become `$var0` 2, `$var1` 3, `$var2`
    4, and `$var3` 5, respectively. The local variables `$x_dist` and `$y_dist` have
    become `$var4` 6 and `$var5` 7. Once you know which of the original variables
    corresponds to which of the disassembly variables, you can step through the code
    knowing the variable used. To watch the values in these variables, you can enter
    them into the Watch expressions window on the right without the `$`. In the Watch
    window you can watch the `$var0` variable by entering `var0`. I use a simple trick
    to keep track of which variable is which. I add a JavaScript comment along with
    my watch expression, labeling the variable with its original name. For example,
    I might enter `$var0` into Watch expressions as `var0 // $x1`. [Figure 10-19](#figure10-19)
    shows what that looks like in Watch expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '![f10019](Images/f10019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-19: Watch expressions in Firefox using comments'
  prefs: []
  type: TYPE_NORMAL
- en: To step through the WAT code, make sure the WebAssembly file is selected. We
    need to create a breakpoint, which is the point at which the debugger stops executing
    the code to allow you to step through one line at a time. To set a breakpoint,
    click the byte number on the left side of the WAT code. You can watch how the
    variables change in your Watch expressions window on the right. With the breakpoint
    set, execute the WebAssembly code by clicking **Find Distance** ([Figure 10-20](#figure10-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10020](Images/f10020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-20: Setting a breakpoint in the Firefox debugger'
  prefs: []
  type: TYPE_NORMAL
- en: When execution reaches the breakpoint, click the **Step over** button ![i10001](Images/i10001.png)
    located above Watch expressions. That allows you to step through your code one
    line at a time. To step into a function instead of executing it, click the **Step
    into** button ![i10002](Images/i10002.png) located next to the Step over button.
    To the right of the Step into button, click the **Step out** button ![i10003](Images/i10003.png)
    if you want to step out of the current function you’re in. Click the **Resume**
    button ![i10004](Images/i10004.png), which looks like a play button, to tell the
    debugger to execute until it reaches another breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: To locate the error in the code, click the **Step over** button until you reach
    line 3D. At this point, `var5` is set, and we can see the value inside the Watch
    expressions window, as shown in [Figure 10-21](#figure10-21).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10021](Images/f10021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-21: Stepping through the code in the Firefox debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `$y_dist` is set to a value of `5` when `Y1` was set to `1` and
    `Y2` was set to `4`. That means that `$y_dist` should have been `3`. Earlier,
    we changed the line numbered 3A from `f64.sub` to `f64.add` to introduce this
    error. Stepping through our code a line at a time in the debugger helped us track
    down the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome Debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging WebAssembly in Chrome is somewhat different from debugging the same
    code in Firefox. The WAT code isn’t broken down by the WebAssembly file; rather,
    Chrome groups the WAT code by functions. The number at the end of the WebAssembly
    function is an index number based on where you defined the function in your code.
  prefs: []
  type: TYPE_NORMAL
- en: To get to the debugger, open the Chrome **Developer tools** and click the **Sources**
    tab. Located in a section labeled Page, you should see a cloud icon labeled wasm.
    Expand this branch to see a page for each function defined in your WebAssembly
    module. Because we’ve only defined one function in this module, only one function
    exists. Click that function to bring up the function’s code in the window on the
    right. In that window, set a breakpoint on line 3 that contains the code `local.get`
    `0` ([Figure 10-22](#figure10-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10022](Images/f10022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-22: Setting a breakpoint in the Chrome debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `local.get` is getting a number instead of a variable name. The
    reason is that following `local.get` with a number gets the local variable based
    on an index instead of a name. Using `local.get 0` is the equivalent to `local.get`
    `$var0` in the Firefox browser. As in Firefox, you can look at the code and match
    it with the code in your function. [Listing 10-12](#listing10-12) shows the code
    as it appears in the Chrome debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: Chrome WAT disassembly in the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Chrome uses indexes for local variables, parameters, and functions.
    The function 1 doesn’t have a name associated with it, nor do any of its parameters
    or local variables 2. The same is true for globals and types. If we were using
    global variables, we would use `global.get` and `global.set`, passing in an index
    number that corresponds to the order in which the variables were defined.
  prefs: []
  type: TYPE_NORMAL
- en: One nice feature of the Chrome debugging functionality is that you have access
    to the stack in the Scope window. As you step through the code, you can watch
    values get pushed onto and popped off the stack. One of the downsides is that
    the Watch window is much less useful than it is in Firefox, because Chrome doesn’t
    make variables available as if they were JavaScript variables.
  prefs: []
  type: TYPE_NORMAL
- en: As in Firefox, Chrome has a Resume button ![i10005](Images/i10005.png), a Step
    over button ![i10006](Images/i10006.png), a Step into button ![i10007](Images/i10007.png),
    and a Step out button ![i10008](Images/i10008.png), as highlighted in [Figure
    10-23](#figure10-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10023](Images/f10023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-23: Viewing the stack in the Chrome debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we debugged WAT code using a variety of different techniques
    in Chrome and in Firefox. We looked at logging to the console in more depth than
    we had in earlier chapters. We then used the JavaScript `alert` function to stop
    execution and wait for user instruction. We also explored using *console.trace*
    to log a stack trace and discussed the differences between the way the stack trace
    works in Chrome and Firefox. Finally, we used the built-in debuggers in Chrome
    and Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Many options are available for debugging WebAssembly. Some of the options, such
    as using the Chrome or Firefox debuggers, are still being developed. Which tools
    you decide to use will depend on the code and your goal when debugging. In the
    next chapter, we’ll use WebAssembly to build Node.js modules.
  prefs: []
  type: TYPE_NORMAL
