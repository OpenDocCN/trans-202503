<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch14">
  <div id="header1401" class="chapter">
   <h1 class="cn">
    <span class="page" id="p313">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch14">
     14
    </a>
   </h1>
   <h1 class="ctfm">
    Controlling Servos
   </h1>
  </div>
  <div class="figure" id="ct14">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   Various projects in
   <a class="url" href="nsp-boxall502581-0018.xhtml#ch08">
    Chapter 8
   </a>
   used DC motors, which are ideal for rotating devices such as wheels for robots. However, for more precise motor control options, you can use a
   <i class="calibre5">
    servo
   </i>
   , short for
   <i class="calibre5">
    servomechanism
   </i>
   . Servos contain electric motors that you can rotate to a specific angular position using PWM signals.
  </p>
  <p class="calibre8">
   Servos come in handy for a variety of applications. For example, you might use a servo to steer a remote-controlled car by connecting it to a
   <i class="calibre5">
    horn
   </i>
   , a small arm or bar that the servo rotates. You might also connect a physical pointer to a servo so it can indicate information such as temperature on a scale, or use a servo to raise or lower a rotary drill.
  </p>
  <p class="calibre8">
   In this chapter, you will:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Learn how to connect the ATmega328P-PU microcontroller to a servo and use PWM to control it.
   </li>
   <li class="bl">
    <span id="p314">
    </span>
    • Learn how to independently control two servos at once.
   </li>
   <li class="bl">
    • Build an analog thermometer and an analog clock.
   </li>
  </ul>
  <div class="chapter">
   <h2 class="ah" id="ah1601">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah1601">
     Setting Up Your Servo
    </a>
   </h2>
   <p class="paft">
    There are a large variety of servos on the market, from tiny units used in portable devices such as digital cameras to large units used in robotic manufacturing assembly devices. When you’re selecting a servo, consider several parameters:
   </p>
   <p class="pcust1">
    <span class="hemb">
     Speed
    </span>
    The time it takes for the servo to rotate, usually measured in seconds per angular degree.
   </p>
   <p class="pcust1">
    <span class="hemb">
     Rotational range
    </span>
    The angular range through which the servo can rotate—for example, 180 degrees (half of a full rotation) or 360 degrees (one complete rotation).
   </p>
   <p class="pcust1">
    <span class="hemb">
     Current
    </span>
    How much current the servo draws. When using a servo with an Arduino, you may need to use an external power supply for the servo.
   </p>
   <p class="pcust1">
    <span class="hemb">
     Torque
    </span>
    The amount of force the servo can exert when rotating. The greater the torque, the heavier the item the servo can control. The torque produced is generally proportional to the amount of current used.
   </p>
   <p class="calibre8">
    For the examples in this chapter, we’ll be using an inexpensive and compact servo like the one in
    <a class="url" href="nsp-boxall502581-0024.xhtml#f14001">
     Figure 14-1
    </a>
    , commonly known as an SG90-type servo. We’ll combine this servo with three types of horns, also shown in the figure.
   </p>
   <div class="figure" id="f14001">
    <p class="fig">
     <img alt="Photo of an SG90-type servo and three different kinds of horns" height="1011" src="images/nsp-boxall502581-f14001.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 14-1:
      </span>
      Servo and various horns
     </p>
    </div>
   </div>
   <p class="calibre8">
    <span id="p315">
    </span>
    This servo can rotate up to 180 degrees, as shown in
    <a class="url" href="nsp-boxall502581-0024.xhtml#f14002">
     Figure 14-2
    </a>
    .
   </p>
   <div class="figure" id="f14002">
    <p class="fig">
     <img alt="Diagram showing the rotation range of a servo, from 0 to 180 degrees" height="663" src="images/nsp-boxall502581-f14002.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 14-2:
      </span>
      Example of servo rotation range
     </p>
    </div>
   </div>
   <p class="calibre8">
    Inside the servo is a small DC motor connected to the horn spindle via
    <i class="calibre5">
     reduction gears
    </i>
    , which reduce the rotational speed of the DC motor to a much slower pace for the servo. The servo also contains a
    <i class="calibre5">
     feedback controller
    </i>
    , which measures the rotational position of the DC motor’s shaft in order to position it more exactly.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh1601">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1601">
      Connecting a Servo
     </a>
    </h3>
    <p class="paft">
     You need just three wires to connect a servo to your microcontroller. If you’re using the SG90, the darkest wire connects to GND, the center wire connects to 5 V, and the lightest wire (the
     <i class="calibre5">
      pulse
     </i>
     or
     <i class="calibre5">
      PWM
     </i>
     wire) connects to a digital pin with PWM capability. If you’re using a different servo, check its data sheet for the correct wiring. We’ll use the standard schematic symbol for servos shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14003">
      Figure 14-3
     </a>
     .
    </p>
    <div class="figure" id="f14003">
     <p class="fig">
      <img alt="Standard schematic symbol for a servo" height="375" src="images/nsp-boxall502581-f14003.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-3:
       </span>
       Schematic symbol for a servo
      </p>
     </div>
    </div>
    <p class="calibre8">
     All the servos you will come across in the hobbyist and experimenting range of products use this same schematic symbol.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1602">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1602">
      Controlling a Servo
     </a>
    </h3>
    <p class="paft">
     We set a servo’s rotational angle by changing the duty cycle of a PWM signal connected to the servo’s pulse wire. In general, servos require a PWM signal with a frequency of 50 Hz and a period of 20 ms. Setting the signal’s duty cycle to different values causes the servo’s internal controller to move the horn to an angle to which the duty cycle is inversely proportionate.
    </p>
    <p class="calibre8">
     Using our SG90 servo as an example, if we set the duty cycle to 12 percent (or 2.4 ms out of the total period of 20 ms), as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14004">
      Figure 14-4
     </a>
     , the horn will rotate to 0 degrees.
    </p>
    <div class="figure" id="f14004">
     <p class="fig">
      <span id="p316">
      </span>
      <img alt="DSO display showing a PWM signal with a 12 percent duty cycle" height="720" src="images/nsp-boxall502581-f14004.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-4:
       </span>
       PWM signal for 0 degrees
      </p>
     </div>
    </div>
    <p class="calibre8">
     If we set the duty cycle to 3 percent, as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14005">
      Figure 14-5
     </a>
     , the horn will rotate to 180 degrees.
    </p>
    <div class="figure" id="f14005">
     <p class="fig">
      <img alt="DSO display showing a PWM signal with a 3 percent duty cycle" height="720" src="images/nsp-boxall502581-f14005.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-5:
       </span>
       PWM signal for 180 degrees
      </p>
     </div>
    </div>
    <p class="calibre8">
     We’ll put the code required to enable the PWM output for our SG90 servo in a function called
     <code class="calibre23">
      initPWM()
     </code>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      void initPWM()
     </p>
     <p class="cl">
      {  // Activate PWM on PB1
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ TCCR1A |= (1 &lt;&lt; WGM11);
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12)|(1 &lt;&lt; WGM13)|(1 &lt;&lt; CS11);
     </p>
     <p class="clf">
      // Connect PWM to PB1
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ TCCR1A |= (1 &lt;&lt; COM1A1); // PWM to OCR1A - PB1
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ ICR1=39999;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     <span id="p317">
     </span>
     This function sets TIMER1 up for fast PWM. It sets the prescaler to 8 for a timer frequency of 2 MHz
     <!--<ccust1>1</ccust1>-->
     ❶, and sends the output to PB1
     <!--<ccust1>2</ccust1>-->
     ❷. (To refresh your memory of how to generate PWM signals, refer to
     <a class="url" href="nsp-boxall502581-0017.xhtml#ch07">
      Chapter 7
     </a>
     .) The timer will count from 0 to 39,999 then reset
     <!--<ccust1>3</ccust1>-->
     ❸, with each period being 0.0000005 seconds in length (
     <i class="calibre5">
      time
     </i>
     = 1/
     <i class="calibre5">
      frequency
     </i>
     ). This gives a full pulse period of 20 ms.
    </p>
    <p class="calibre8">
     We’ll then use OCR1A to set the duty cycle and thus position the servo. We know that a 12 percent duty cycle results in a rotation to 0 degrees, so we can calculate the required OCR1A value by multiplying 40,000 (remember that the counter starts at 0 and counts to 39,999) by 0.12, which gives us 4,799. For a full rotation to 180 degrees, we would set OCR1A to 1,199 (40,000 × 0.12).
    </p>
    <p class="calibre8">
     If you’re using a servo other than the SG90, determine the duty cycle values required for 0 and 180 degree rotation, then use the calculations described in the previous paragraph to determine your required OCR1A values. You should be able to get the duty cycle information from the servo supplier or retailer.
    </p>
    <p class="calibre8">
     Now, let’s put what you’ve just learned into practice by rotating a servo in various ways.
    </p>
    <p class="hd" id="pro56">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro56">
      <span class="ccust1">
       Project 56: Experimenting with Servos
      </span>
     </a>
    </p>
    <p class="paft">
     With this project you’ll learn the basic of servo control, including the required circuitry and commands for servo movement.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1603">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1603">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bl">
      • SG90 servo
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14006">
      Figure 14-6
     </a>
     .
    </p>
    <div class="figure" id="f14006">
     <p class="fig">
      <span id="p318">
      </span>
      <img alt="Schematic diagram for Project 56" height="1159" src="images/nsp-boxall502581-f14006.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-6:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0024.xhtml#pro56">
        Project 56
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Note the use of the large electrolytic capacitor over the 5 V and GND lines. When servos are operating, they can sometimes generate a varying voltage due to the motor turning on and off quickly, so we use the capacitor to smooth out the power to a more consistent 5 V.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1604">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1604">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 56
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 14
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. After a moment or two, the servo should quickly rotate across its full range from 0 to 180 degrees, then do so again at a slower speed, then return to 0 degrees at an even slower speed.
    </p>
    <p class="calibre8">
     Let’s take a look at the code to see how this works:
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 56 - Experimenting with Servos
     </p>
     <p class="cl">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void initPWM()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p319">
      </span>
      // Activate PWM on PB1
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; WGM11);
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12)|(1 &lt;&lt; WGM13)|(1 &lt;&lt; CS11);
     </p>
     <p class="cl">
      // Connect PWM to PB1
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; COM1A1); // PWM to OCR1A - PB1
     </p>
     <p class="cl">
      ICR1=39999;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ void servoRange()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1A=4799;              // 0 degrees
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      OCR1A=1199;              // 180 degrees
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void servoAngle(uint8_t angle)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Rotate servo to 'angle' position
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ OCR1A = ((angle-239.95)/-0.05);
     </p>
     <p class="cl">
      // Convert angle to OCR1A (duty cycle) value
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ DDRB|=(1&lt;&lt;PB1);
     </p>
     <p class="cl">
      initPWM();
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ servoRange();
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="clf">
      for (i=0; i&lt;=180; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ servoAngle(i);
     </p>
     <p class="cl">
      _delay_ms(25);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      for (i=180; i&gt;0; --i)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ servoAngle(i);
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     We start by defining three functions:
     <code class="calibre23">
      initPWM()
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶, which handles PWM initialization;
     <code class="calibre23">
      servoRange()
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷, which for demonstrative purposes simply rotates the servo arm between 0 and 180 degrees by setting OCR1A with the duty cycle values for 0 degrees, then 180 degrees; and the useful custom function
     <code class="calibre23">
      servoAngle(uint8_t angle)
     </code>
     <!--<ccust1>3</ccust1>-->
     ❸, which accepts a number (the rotational angle for our desired servo position) and converts this into the required duty cycle value to be stored in OCR1A
     <!--<ccust1>4</ccust1>-->
     ❹. This simplifies the task
     <span id="p320">
     </span>
     of commanding the servo, automatically converting the angle we want into the correct duty cycle between 4,799 and 1,199 with the formula
     <i class="calibre5">
      angle
     </i>
     = (
     <i class="calibre5">
      counter
     </i>
     – 239.95) / −0.05. These values are generally used by most common small servos, but check with your supplier if you’re unsure.
    </p>
    <p class="calibre8">
     In the main section of the code, we first set the pin connected to the servo’s pulse wire to an output
     <!--<ccust1>5</ccust1>-->
     ❺, then call the
     <code class="calibre23">
      initPWM()
     </code>
     function to enable PWM. We call
     <code class="calibre23">
      servoRange()
     </code>
     <!--<ccust1>6</ccust1>-->
     ❻ to rotate the servo arm quickly from 0 to 180 degrees and back again, then this is repeated in a slower fashion using the
     <code class="calibre23">
      for
     </code>
     loops at
     <!--<ccust1>7</ccust1>-->
     ❼ and
     <!--<ccust1>8</ccust1>-->
     ❽, respectively. Each introduces a delay between movement of the servo arm one degree in either direction.
    </p>
    <p class="pcust">
     <span class="ccust">
      Note
     </span>
     The formula for the
     <code class="calibre23">
      servoAngle()
     </code>
     function was created using linear algebra, based on two sets of points: (4799,0) and (1199,180). You can use an online tool such as GeoGebra (
     <a class="url-i1" href="https://www.geogebra.org/m/UyfrABcN">
      https://www.geogebra.org/m/UyfrABcN
     </a>
     ) to determine the equation for your own formula if your servo requires different duty cycle values.
    </p>
    <p class="calibre8">
     Now that you have the code framework to control a servo, let’s combine it with your prior knowledge about using the TMP36 temperature sensor to build an analog thermometer.
    </p>
    <p class="hd" id="pro57">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro57">
      <span class="ccust1">
       Project 57: Creating an Analog Thermometer
      </span>
     </a>
    </p>
    <p class="paft">
     You can use a servo to display a temperature reading by attaching an arrow to the servo horn and creating a backing sheet with the temperature range on it. This project will display temperatures between 0 and 30 degrees Celsius, but you can modify it to show different ranges.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1605">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1605">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor (C4)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bl">
      • SG90-compatible servo
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14007">
      Figure 14-7
     </a>
     . Don’t forget to connect the microcontroller’s AV
     <sub class="calibre28">
      CC
     </sub>
     pin to 5 V.
    </p>
    <div class="figure" id="f14007">
     <p class="fig">
      <span id="p321">
      </span>
      <img alt="Schematic diagram for Project 57" height="954" src="images/nsp-boxall502581-f14007.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-7:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0024.xhtml#pro57">
        Project 57
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14008">
      Figure 14-8
     </a>
     shows what the backing sheet representing the range of temperatures that the servo will display might look like, with a small arrow attached to the horn as a pointer.
    </p>
    <div class="figure" id="f14008">
     <p class="fig">
      <img alt="Example of a finished Project 57, with the arrow fixed to the servo horn pointing to a value on the temperature backing sheet" height="611" src="images/nsp-boxall502581-f14008.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-8:
       </span>
       The backing sheet indicating the temperature
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1606">
     <span class="page" id="p322">
     </span>
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1606">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 57
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 14
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. After a moment or two, the servo horn should swing to an angular position that represents the temperature in degrees Celsius.
    </p>
    <p class="calibre8">
     Let’s take a look at the code to see how this works:
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 57 - Creating an Analog Thermometer
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl">
      #include &lt;stdlib.h&gt;
     </p>
     <p class="cl">
      #include &lt;math.h&gt;
     </p>
     <p class="clf">
      void startADC()
     </p>
     <p class="cl">
      // Set up the ADC
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; REFS0);                 // Use AVcc pin with ADC
     </p>
     <p class="cl">
      ADMUX |= (1 &lt;&lt; MUX2) | (1 &lt;&lt; MUX0);    // Use ADC5 (pin 28)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADPS2) |(1 &lt;&lt; ADPS1) | (1 &lt;&lt; ADPS0);
     </p>
     <p class="cl">
      // Prescaler for 16MHz (/128)
     </p>
     <p class="cl">
      ADCSRA |= (1 &lt;&lt; ADEN);                 // Enable ADC
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initPWM()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Activate PWM on PB1
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; WGM11);
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12)|(1 &lt;&lt; WGM13)|(1 &lt;&lt; CS11);
     </p>
     <p class="clf">
      // Connect PWM to PB1
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; COM1A1);
     </p>
     <p class="cl">
      // PWM to OCR1A - PB1
     </p>
     <p class="cl">
      ICR1=39999;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void servoAngle(uint8_t angle)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Rotate servo to 'angle' position
     </p>
     <p class="cl">
      OCR1A = ((angle-239.95)/-0.05);
     </p>
     <p class="cl">
      // Convert angle to OCR1A (duty cycle) value
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ DDRB|=(1&lt;&lt;PB1);  // Set PORTB1 as output for servo control
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ DDRC|=(0&lt;&lt;PC5);  // Set PORTC5 as input for TMP36 measurement
     </p>
     <p class="clf">
      <!--<ccust1>3</ccust1>-->
      ❸ float temperature;
     </p>
     <p class="cl">
      float voltage;
     </p>
     <p class="cl">
      uint16_t ADCvalue;
     </p>
     <p class="cl">
      uint8_t finalAngle;
     </p>
     <p class="clf">
      <span id="p323">
      </span>
      <!--<ccust1>4</ccust1>-->
      ❹ startADC();
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ initPWM();
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ ADCSRA |= (1 &lt;&lt; ADSC);        // Start ADC measurement
     </p>
     <p class="cl">
      while (ADCSRA &amp; (1 &lt;&lt; ADSC)); // Wait for conversion
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ ADCvalue = ADC;
     </p>
     <p class="clf">
      // Convert reading to temperature value (Celsius)
     </p>
     <p class="cl">
      <!--<ccust1>8</ccust1>-->
      ❽ voltage = (ADCvalue * 5);
     </p>
     <p class="cl">
      voltage = voltage / 1024;
     </p>
     <p class="cl">
      temperature = ((voltage - 0.5) * 100);
     </p>
     <p class="clf">
      // Display temperature using servo
     </p>
     <p class="cl">
      <!--<ccust1>9</ccust1>-->
      ❾ finalAngle = 6 * temperature;
     </p>
     <p class="cl">
      servoAngle(finalAngle);
     </p>
     <p class="cl">
      _delay_ms(500);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     We start by performing the usual steps to set the required pins for the servo as an output
     <!--<ccust1>1</ccust1>-->
     ❶ and the TMP36 sensor as an input
     <!--<ccust1>2</ccust1>-->
     ❷, then declare the variables needed for storage and conversion of temperature data from the TMP36 sensor
     <!--<ccust1>3</ccust1>-->
     ❸. We then call the functions to start the ADC
     <!--<ccust1>4</ccust1>-->
     ❹ and initialize PWM
     <!--<ccust1>5</ccust1>-->
     ❺. Next, we determine the temperature in Celsius by first reading the ADC
     <!--<ccust1>6</ccust1>-->
     ❻ and storing its value into
     <code class="calibre23">
      ADCvalue
     </code>
     <!--<ccust1>7</ccust1>-->
     ❼, then doing the mathematical conversion to Celsius
     <!--<ccust1>8</ccust1>-->
     ❽. Finally, we convert the temperature to an angle for the servo by multiplying it by 6 (since the servo range is 0 to 180 degrees)
     <!--<ccust1>9</ccust1>-->
     ❾ and tell the servo to move to the appropriate angle.
    </p>
    <p class="calibre8">
     At this point, you can use what you’ve learned in this book so far to make a variety of controllable analog displays with your servo—for example, a low-voltage meter or a countdown timer. But if anything’s better than one servo, it’s using two servos at once; you’ll see how to do that next.
    </p>
    <p class="hd" id="pro58">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro58">
      <span class="ccust1">
       Project 58: Controlling Two Servos
      </span>
     </a>
    </p>
    <p class="paft">
     Since there are multiple PWM-capable output pins on the ATmega328P-PU microcontroller, we can control two servos at once for more involved projects. This project will show you how.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1607">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1607">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      <span id="p324">
      </span>
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor (C4)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bl">
      • Two SG90-compatible servos
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14009">
      Figure 14-9
     </a>
     .
    </p>
    <div class="figure" id="f14009">
     <p class="fig">
      <img alt="Schematic diagram for Project 58" height="822" src="images/nsp-boxall502581-f14009.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-9:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0024.xhtml#pro58">
        Project 58
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1608">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1608">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 58
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 14
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. After a moment or two both servos should imitate the motion demonstrated in
     <a class="url" href="nsp-boxall502581-0024.xhtml#pro56">
      Project 56
     </a>
     , quickly rotating across their full range from 0 to 180 degrees, then repeating this at a slower speed, and then returning to 0 degrees at an even slower speed.
    </p>
    <p class="calibre8">
     Let’s see how this works:
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 58 - Controlling Two Servos
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <span id="p325">
      </span>
      <!--<ccust1>1</ccust1>-->
      ❶ void initPWM()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Activate PWM
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; WGM11);
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12)|(1 &lt;&lt; WGM13)|(1 &lt;&lt; CS11);
     </p>
     <p class="clf">
      // Connect PWM to PB1 and PB2
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ TCCR1A |= (1 &lt;&lt; COM1A1)|(1 &lt;&lt; COM1B1);
     </p>
     <p class="cl">
      // PWM to OCR1A - PB1 and OCR1B - PB2
     </p>
     <p class="cl">
      ICR1=39999;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void servoAngleA(uint8_t angle)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Rotate servo on OCR1A to 'angle' position
     </p>
     <p class="cl">
      OCR1A = ((angle-239.95)/-0.05);
     </p>
     <p class="cl">
      // Convert angle to OCR1A (duty cycle) value
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>4</ccust1>-->
      ❹ void servoAngleB(uint8_t angle)
     </p>
     <p class="cl">
      // Rotate servo on OCR1B to 'angle' position
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1B = ((angle-239.95)/-0.05);
     </p>
     <p class="cl">
      // Convert angle to OCR1A (duty cycle) value
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>5</ccust1>-->
      ❺ void servoRange()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1A=4799;               // 0 degrees
     </p>
     <p class="cl">
      OCR1B=4799;
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      OCR1A=1199;               // 180 degrees
     </p>
     <p class="cl">
      OCR1B=1199;               // 180 degrees
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB|=(1&lt;&lt;PB1)|(1&lt;&lt;PB2);  // Set PB1 and PB2 to outputs
     </p>
     <p class="cl">
      initPWM();
     </p>
     <p class="cl">
      uint8_t i;
     </p>
     <p class="clf">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      servoRange();
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="clf">
      for (i=0; i&lt;=180; i++)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      servoAngleA(i);
     </p>
     <p class="cl">
      servoAngleB(i);
     </p>
     <p class="cl">
      _delay_ms(25);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      for (i=180; i&gt;0; --i)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <span id="p326">
      </span>
      servoAngleA(i);
     </p>
     <p class="cl">
      servoAngleB(i);
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     In the
     <code class="calibre23">
      initPWM()
     </code>
     function
     <!--<ccust1>1</ccust1>-->
     ❶, after activating PWM we turn on the COM1B1 bit in TCCR1A to enable PWM for the second servo connected to PB2
     <!--<ccust1>2</ccust1>-->
     ❷. Two
     <code class="calibre23">
      servoAngle()
     </code>
     -type functions, one for servo A
     <!--<ccust1>3</ccust1>-->
     ❸ and one for servo B
     <!--<ccust1>4</ccust1>-->
     ❹, allow for control by accepting the required rotational angle. I’ve modified the function
     <code class="calibre23">
      servoRange()
     </code>
     <!--<ccust1>5</ccust1>-->
     ❺ to control the first servo and the second servo by assigning the required values to OCR1A and OCR1B, respectively.
    </p>
    <p class="calibre8">
     You could also experiment with the direction of both servos by altering the delays after the
     <code class="calibre23">
      servoAngleA/B()
     </code>
     functions or reversing the counting to go from higher values to lower values. Now that you can use two servos with ease, it’s time to put them to work in the form of an analog clock.
    </p>
    <p class="hd" id="pro59">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro59">
      <span class="ccust1">
       Project 59: Building an Analog Clock with Servo Hands
      </span>
     </a>
    </p>
    <p class="paft">
     In this project you’ll use two servos to display the time in the form of a dual-display analog clock. One servo will display the hour, and the other will display minutes.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1609">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1609">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     To build your circuit, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • 5 V breadboard power supply
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • One TMP36 temperature sensor
     </li>
     <li class="bl">
      • Two 22 pF ceramic capacitors (C1–C2)
     </li>
     <li class="bl">
      • 470
      <span lang="el" xml:lang="el">
       μF
      </span>
      16 V electrolytic capacitor (C3)
     </li>
     <li class="bl">
      • 0.1
      <span lang="el" xml:lang="el">
       μF
      </span>
      ceramic capacitor (C4)
     </li>
     <li class="bl">
      • 16 MHz crystal oscillator
     </li>
     <li class="bl">
      • DS3231 real-time clock module with backup battery
     </li>
     <li class="bl">
      • Two SG90-compatible servos
     </li>
     <li class="bll">
      • Jumper wires
     </li>
    </ul>
    <p class="calibre8">
     Assemble your circuit as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14010">
      Figure 14-10
     </a>
     . Don’t forget to connect the DS3231 board to 5 V and GND as well.
    </p>
    <div class="figure" id="f14010">
     <p class="fig">
      <span id="p327">
      </span>
      <img alt="Schematic diagram for Project 59" height="822" src="images/nsp-boxall502581-f14010.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-10:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0024.xhtml#pro59">
        Project 59
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     Before uploading the code, don’t forget to set the time in the same manner as you did in previous projects that used the DS3231, such as
     <a class="url" href="nsp-boxall502581-0022.xhtml#pro51">
      Project 51
     </a>
     . You may also want to create a backing display like the one used in
     <a class="url" href="nsp-boxall502581-0024.xhtml#pro57">
      Project 57
     </a>
     , as shown in
     <a class="url" href="nsp-boxall502581-0024.xhtml#f14011">
      Figure 14-11
     </a>
     —feel free to get creative. Note that servo M1 in the schematic is for hours, and M2 is for minutes.
    </p>
    <div class="figure" id="f14011">
     <p class="fig">
      <img alt="example of a finished Project 59, with the arrows fixed to the servo horn on each servo pointing to an hours and minutes value on the time backing sheets" height="315" src="images/nsp-boxall502581-f14011.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 14-11:
       </span>
       Example clock faces for
       <a class="url" href="nsp-boxall502581-0024.xhtml#pro59">
        Project 59
       </a>
      </p>
     </div>
    </div>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh1610">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh1610">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 59
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 14
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     as usual. Once you’ve flashed the code, you should see the current time displayed by way of the position of the servo horns.
    </p>
    <p class="calibre8">
     Let’s see how this works:
    </p>
    <div class="codeline">
     <p class="clf">
      <span id="p328">
      </span>
      // Project 59 - Building an Analog Clock with Servo Hands
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      // Variables to store time and date
     </p>
     <p class="cl">
      uint8_t hours, minutes, seconds, dow, dom, mo, years;
     </p>
     <p class="clf">
      void I2Cenable()
     </p>
     <p class="cl">
      // Enable I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWBR = 72;           // 100 kHz I2C bus
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWEN); // Enable I2C on PORTC4 and 5
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwait()
     </p>
     <p class="cl">
      // Wait until I2C finishes an operation
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Wait until bit TWINT in TWCR is set to 1
     </p>
     <p class="cl">
      while (!(TWCR &amp; (1&lt;&lt;TWINT)));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2CstartWait(unsigned char address)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Start I2C bus
     </p>
     <p class="cl">
      uint8_t status;
     </p>
     <p class="cl">
      while (1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Send START condition
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWSTA) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status != 0b00001000) &amp;&amp; (status != 0b00010000)) continue;
     </p>
     <p class="clf">
      // Send device address
     </p>
     <p class="cl">
      TWDR = address;
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN);
     </p>
     <p class="clf">
      // Wait until transmission completes
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="clf">
      // Check value of TWSR, and mask out status bits
     </p>
     <p class="cl">
      status = TWSR &amp; 0b11111000;
     </p>
     <p class="cl">
      if ((status == 0b00100000 )||(status == 0b01011000))
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR = (1&lt;&lt;TWINT) | (1&lt;&lt;TWEN) | (1&lt;&lt;TWSTO);
     </p>
     <p class="cl">
      // Wait until stop condition is executed and I2C bus is released
     </p>
     <p class="cl">
      while(TWCR &amp; (1&lt;&lt;TWSTO));
     </p>
     <p class="cl">
      continue;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      <span id="p329">
      </span>
      break;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cstop()
     </p>
     <p class="cl">
      // Stop I2C bus and release GPIO pins
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Clear interrupt, enable I2C, generate stop condition
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWSTO);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void I2Cwrite(uint8_t data)
     </p>
     <p class="cl">
      // Send 'data' to I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWDR = data;
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t I2Cread()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t I2CreadACK()
     </p>
     <p class="cl">
      // Read incoming byte of data from I2C bus and ACK signal
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TWCR |= (1 &lt;&lt; TWINT)|(1 &lt;&lt; TWEN)|(1 &lt;&lt; TWEA);
     </p>
     <p class="cl">
      I2Cwait();
     </p>
     <p class="cl">
      // Incoming byte is placed in TWDR register
     </p>
     <p class="cl">
      return TWDR;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t decimalToBcd(uint8_t val)
     </p>
     <p class="cl">
      // Convert integer to BCD
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      return((val/10*16)+(val%10));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      uint8_t bcdToDec(uint8_t val)
     </p>
     <p class="cl">
      // Convert BCD to integer
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      return((val/16*10)+(val%16));
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void setTimeDS3231(uint8_t hh, uint8_t mm, uint8_t ss, uint8_t dw,
     </p>
     <p class="cl">
      uint8_t dd, uint8_t mo, uint8_t yy)
     </p>
     <p class="cl">
      // Set time on DS3231
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      I2CstartWait(0xD0);         // DS3231 write
     </p>
     <p class="cl">
      I2Cwrite(0x00);             // Start with hours register
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(ss)); // Seconds
     </p>
     <p class="cl">
      <span id="p330">
      </span>
      I2Cwrite(decimalToBcd(mm)); // Minutes
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(hh)); // Hours
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(dw)); // Day of week
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(dd)); // Date
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(mo)); // Month
     </p>
     <p class="cl">
      I2Cwrite(decimalToBcd(yy)); // Year
     </p>
     <p class="cl">
      I2Cstop();
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void readTimeDS3231()
     </p>
     <p class="cl">
      // Retrieve time and date from DS3231
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      I2CstartWait(0xD0);         // DS3231 write
     </p>
     <p class="cl">
      I2Cwrite(0x00);             // Seconds register
     </p>
     <p class="cl">
      I2CstartWait(0xD1);         // DS3231 read
     </p>
     <p class="cl">
      seconds = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      minutes = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      hours = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      dow = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      dom = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      mo = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      years = bcdToDec(I2CreadACK());
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initPWM()
     </p>
     <p class="cl">
      // Activate PWM
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; WGM11);
     </p>
     <p class="cl">
      TCCR1B |= (1 &lt;&lt; WGM12)|(1 &lt;&lt; WGM13)|(1 &lt;&lt; CS11);
     </p>
     <p class="clf">
      // Connect PWM to PB1 and PB2
     </p>
     <p class="cl">
      TCCR1A |= (1 &lt;&lt; COM1A1)|(1 &lt;&lt; COM1B1);
     </p>
     <p class="cl">
      ICR1=39999;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void servoAngleA(uint8_t angle)        // Hours servo
     </p>
     <p class="cl">
      // Rotate servo on OCR1A to 'angle' position
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1A = ((angle-239.95)/-0.05);
     </p>
     <p class="cl">
      // Convert angle to OCR1A (duty cycle) value
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void servoAngleB(uint8_t angle)        // Minutes servo
     </p>
     <p class="cl">
      // Rotate servo on OCR1B to 'angle' position
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1B = ((angle-239.95)/-0.05);
     </p>
     <p class="cl">
      // Convert angle to OCR1A (duty cycle) value
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ void displayServoTime()
     </p>
     <p class="cl">
      {  // Displays hours on servo A, minutes on servo B
     </p>
     <p class="cl">
      uint8_t _hours;
     </p>
     <p class="cl">
      uint8_t _minutes;
     </p>
     <p class="clf">
      <!--<ccust1>2</ccust1>-->
      ❷ _hours = hours * 15;
     </p>
     <p class="cl">
      <span id="p331">
      </span>
      <!--<ccust1>3</ccust1>-->
      ❸ servoAngleA(_hours);
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ _minutes = minutes * 3;
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ servoAngleB(_minutes);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111;                  // Set PORTB as outputs
     </p>
     <p class="cl">
      I2Cenable();
     </p>
     <p class="cl">
      initPWM();
     </p>
     <p class="clf">
      // Uncomment to set time &amp; date, then comment and reflash code
     </p>
     <p class="cl">
      // setTimeDS3231(9,13,0,5,29,4,21); // h,m,s,dow,dom,m,y
     </p>
     <p class="cl">
      while(1)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      readTimeDS3231();
     </p>
     <p class="cl">
      displayServoTime();
     </p>
     <p class="cl">
      _delay_ms(1000);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     After reviewing the code, you should recognize the parts dedicated to enabling the I
     <sup class="calibre6">
      2
     </sup>
     C bus (as described in
     <a class="url" href="nsp-boxall502581-0022.xhtml#ch12">
      Chapter 12
     </a>
     ), along with setting and retrieving the time from the DS3231 RTC module (as described in
     <a class="url" href="nsp-boxall502581-0023.xhtml#ch13">
      Chapter 13
     </a>
     ) and controlling the servos via PWM (as discussed earlier in this chapter).
    </p>
    <p class="calibre8">
     The new material in this project is in the
     <code class="calibre23">
      displayServoTime()
     </code>
     function
     <!--<ccust1>1</ccust1>-->
     ❶, which takes the values of the hours and minutes from the RTC and converts them into suitable angles to which the servos move. For the servo displaying hours, we divide the 180-degree servo range by 12 hours. That gives us 15, so we multiply the hours value by 15 to get the required servo angle
     <!--<ccust1>2</ccust1>-->
     ❷, then command the first servo to move to that position
     <!--<ccust1>3</ccust1>-->
     ❸. We use a similar process to convert minutes to angles: 180 divided by 60 is 3, so we multiply the minutes value by 3
     <!--<ccust1>4</ccust1>-->
     ❹, then command the second servo to move to that position
     <!--<ccust1>5</ccust1>-->
     ❺.
    </p>
    <p class="calibre8">
     For a final challenge, try altering the code so the hours display starts at 12 and finishes at 11 instead of going from 1 to 12, or making your own servo library. There are many ways you can expand on these clocks, and using servos in general: for example, you could try using two servos as the front arms of a crawling robot, or to control older mechanical light switches.
    </p>
    <p class="calibre8">
     So where do you go from here? This book is only the beginning of your AVR journey. Check out the following epilogue for some next steps.
    </p>
   </div>
  </div>
 </div>
</div></body></html>