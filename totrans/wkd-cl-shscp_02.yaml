- en: '**1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**THE MISSING CODE LIBRARY**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of Unix’s greatest strengths is that it lets you create new commands by
    combining old ones in novel ways. But even though Unix includes hundreds of commands
    and there are thousands of ways to combine them, you will still encounter situations
    where nothing does the job quite right. This chapter focuses on the stepping stones
    that allow you to create smarter and more sophisticated programs within the world
    of shell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also something we should address up front: the shell script programming
    environment isn’t as sophisticated as a real programming environment. Perl, Python,
    Ruby, and even C have structures and libraries that offer extended capabilities,
    but shell scripts are more of a “roll your own” world. The scripts in this chapter
    will help you make your way in that world. They’re the building blocks that will
    help you write the wicked cool shell scripts that come later in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Much of the challenge of script writing also arises from subtle variations among
    different flavors of Unix and among the many different GNU/Linux distributions.
    While the IEEE POSIX standards supposedly provide a common base of functionality
    across Unix implementations, it can still be confusing to use an OS X system after
    a year in a Red Hat GNU/Linux environment. The commands are different, they’re
    in different locations, and they often have subtly different command flags. These
    variations can make writing shell scripts tricky, but we’ll learn a few tricks
    to keep these variations at bay.
  prefs: []
  type: TYPE_NORMAL
- en: '**What Is POSIX?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The early days of Unix were the Wild West, with companies innovating and taking
    the operating system in different directions while simultaneously assuring customers
    that all these new versions were compatible with each other and just like every
    other Unix. The Institute for Electrical and Electronic Engineers (IEEE) stepped
    in and, with tremendous effort from all the major Unix vendors, created a standard
    definition for Unix called the Portable Operating System Interface, or *POSIX*
    for short, against which all commercial and open source Unix implementations are
    measured. You can’t buy a POSIX operating system per se, but the Unix or GNU/Linux
    you run is generally POSIX compliant (though there’s some debate about whether
    we even need a POSIX standard at all, when GNU/Linux has become a de facto standard
    of its own).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, even POSIX-compliant Unix implementations can vary. One example
    addressed later in this chapter involves the `echo` command. Some versions of
    this command support an `-n` flag, which disables the trailing newline that’s
    a standard part of the command execution. Other versions of `echo` support the
    `\c` escape sequence as a special “don’t include a newline” notation, while still
    others have no way to avoid the newline at the end of the output. To make things
    even more interesting, some Unix systems have a command shell with a built-in
    `echo` function that ignores the `-n` and `\c` flags, as well as a stand-alone
    binary `/bin/echo` that understands these flags. This makes it tough to prompt
    for input in a shell script, because scripts should work identically on as many
    Unix systems as possible. So for functional scripts, it’s critical to normalize
    the `echo` command to work the same way across systems. Later in this chapter,
    in [Script #8](ch01.xhtml#ch01lev1sec09) on [page 33](ch01.xhtml#page_33), we’ll
    see how to wrap `echo` inside a shell script to create just such a normalized
    version of the command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some of the scripts in this book take advantage of bash-style features that
    may not be supported by all POSIX-compatible shells.*'
  prefs: []
  type: TYPE_NORMAL
- en: But enough backstory—let’s start looking at scripts to include in our shell
    script library!
  prefs: []
  type: TYPE_NORMAL
- en: '**#1 Finding Programs in the PATH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Shell scripts that use environment variables (like `MAILER` and `PAGER`) have
    a hidden danger: some of their settings may point to nonexistent programs. In
    case you haven’t bumped into these environment variables before, `MAILER` should
    be set to the email program you prefer (like `/usr/bin/mailx`), and `PAGER` should
    be set to the program that you use to view long documents one screenful (page)
    at a time. For example, if you decide to be flexible by using the `PAGER` setting
    to display script output instead of using the system’s default paging program
    (common values would be the `more` or `less` programs), how do you ensure that
    the `PAGER` environment value is set to a valid program?'
  prefs: []
  type: TYPE_NORMAL
- en: This first script addresses how to test whether a given program can be found
    in the user’s `PATH`. It’s also a good demonstration of a number of different
    shell-scripting techniques, including script functions and variable slicing. [Listing
    1-1](ch01.xhtml#ch1ex1) shows how you can verify that paths are valid.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: The* `*inpath*` *shell script functions*'
  prefs: []
  type: TYPE_NORMAL
- en: As stated in [Chapter 0](ch00.xhtml#ch00), we recommend that you create a new
    directory called *scripts* in your home directory, and then add that fully qualified
    directory name to your `PATH` variable. Use `echo $PATH` to see your current `PATH`
    and edit the contents of your login script (*.login*, *.profile*, *.bashrc*, or
    *.bash_profile*, depending on the shell) to modify your `PATH` appropriately.
    See “[Configuring Your Login Script](ch00.xhtml#ch00lev1sec03)” on [page 4](ch00.xhtml#page_4)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you are listing files in the terminal with the* `*ls*` *command, some special
    files, like* .bashrc *or* .bash_profile*, may not show up at first. This is because
    files that start with a period, as* .bashrc *does, are considered “hidden” by
    the filesystem. (This turned out to be a bit of a bug-turned-feature very early
    on in Unix.) To list all the files in a directory, including the hidden ones,
    use the* `*-a*` *argument with* `*ls*`.'
  prefs: []
  type: TYPE_NORMAL
- en: Definitely worth mentioning again is the assumption that you’re running bash
    as your shell for all these scripts. Note that this script explicitly sets the
    first line (called the *shebang*) to call `/bin/bash`. Many systems also support
    a `/usr/bin/env bash` shebang setting as the runtime for the script.
  prefs: []
  type: TYPE_NORMAL
- en: '**A NOTE ON COMMENTS**'
  prefs: []
  type: TYPE_NORMAL
- en: We wrestled with whether to include a detailed explanation of how each script
    works. In some cases, we’ll provide an explanation of a tricky coding segment
    after the code, but in general we’ll use code comments to explain, in context,
    what’s happening. Look for lines that begin with the `#` symbol or, sometimes,
    anything that appears after the `#` on a line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ll doubtless find yourself reading other people’s scripts (other than
    ours, of course!), it’s useful to practice figuring out what the heck is going
    on in a script by reading the comments. Commenting is also an excellent habit
    to get into when writing scripts of your own, to help you define what you seek
    to accomplish in specific blocks of code.
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The key to getting `checkForCmdInPath` to work is for it to be able to differentiate
    between variables that contain just the program name (like `echo`) and variables
    that contain a full directory path plus the filename (like `/bin/echo`). It does
    this by examining the first character of the given value to see whether it’s a
    `/`; hence, we have the need to isolate the first character from the rest of the
    variable value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the variable-slicing syntax `${var:0:1}` at ➊ is a shorthand notation
    that lets you specify substrings in a string, starting from an offset and continuing
    up to the given length (returning the entire rest of the string if no length is
    provided). The expression `${var:10}`, for example, will return the remaining
    value of `$var` starting from the 10th character, while `${var:10:5}` constrains
    the substring to just the characters between positions 10 and 15, inclusive. You
    can see what we mean here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In [Listing 1-1](ch01.xhtml#ch1ex1), the syntax is just used to see whether
    the specified path has a leading slash. Once we have determined whether the path
    passed to the script starts with a leading slash, we check if we can actually
    find the path on the filesystem. If the path begins with a `/`, we assume the
    path given is an absolute path and check whether it exists using the `-x` bash
    operator ➋. Otherwise, we pass the value to our `inpath` function ➌ to see whether
    the value can be found in any of the directories set in our default `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script as a stand-alone program, we first need to append a short
    block of commands to the very end of the file. These commands will do the basic
    work of actually getting user input and passing it to the function we wrote, as
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve added the code, you can invoke the script directly, as shown next
    in “The Results.” Make sure to remove or comment out this additional code when
    you’re done with the script, however, so it can be included as a library function
    later without messing things up.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To test the script, let’s invoke `inpath` with the names of three programs:
    a program that exists, a program that exists but isn’t in the `PATH`, and a program
    that does not exist but that has a fully qualified filename and path. [Listing
    1-2](ch01.xhtml#ch1ex2) shows an example test of the script.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-2: Testing the* `*inpath*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: The last block of code we added translates the results of the `in_path` function
    into something more readable, so now we can easily see that each of the three
    cases get handled as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want to be a code ninja here on the very first script, switch the expression
    `${var:0:1}` to its more complicated cousin: `${var%${var#?}}`. This is the POSIX
    variable-slicing method. The apparent gobbledygook is really two nested string
    slices. The inner call of `${var#?}` extracts everything but the first character
    of `var`, where `#` is a call to delete the first instance of a given pattern
    and `?` is a regular expression that matches exactly one character.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the call `${var%*pattern*}` produces a substring with everything left
    over once the specified pattern is removed from `var`. In this case, the pattern
    being removed is the result of the inner call, so what’s left is the first character
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: If this POSIX notation is too funky for you, most shells (including bash, ksh,
    and zsh) support the other method of variable slicing, `${*varname*:*start*:*size*}`,
    which was used in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if you don’t like either of these techniques for extracting the
    first character, you can also use a system call: `$(echo $var | cut -c1)`. With
    bash programming, there will likely be multiple ways to solve a given problem,
    be it extracting, transforming, or loading data from the system in different ways.
    It’s important to realize and understand that this “many ways to skin a cat” approach
    doesn’t mean one way is better than another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you want to create a version of this, or any script, that can differentiate
    between when it’s running as a stand-alone and when it’s invoked from another
    script, consider adding a conditional test near the beginning, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We’ll leave it as an exercise for you, dear reader, to write the rest of the
    snippet after some experimentation!
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Script #47](ch06.xhtml#ch06lev1sec03) on [page 150](ch06.xhtml#page_150)
    is a useful script that’s closely related to this one. It validates both the directories
    in the* `*PATH*` *and the environment variables in the user’s login environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**#2 Validating Input: Alphanumeric Only**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users are constantly ignoring directions and entering data that is inconsistent,
    is incorrectly formatted, or uses incorrect syntax. As a shell script developer,
    you need to identify and flag these errors before they become problems.
  prefs: []
  type: TYPE_NORMAL
- en: A typical situation involves filenames or database keys. Your program prompts
    the user for a string that’s supposed to be *alphanumeric*, consisting exclusively
    of uppercase characters, lowercase characters, and digits—no punctuation, no special
    characters, no spaces. Did they enter a valid string? That’s what the script in
    [Listing 1-3](ch01.xhtml#ch1ex3) tests.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-3: The* `*validalnum*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The logic of this script is straightforward. First, create a new version of
    the entered information with a `sed`-based transform that removes all invalid
    characters ➊. Then, compare the new version with the original ➋. If the two are
    the same, all is well. If not, the transformation lost data that wasn’t part of
    the acceptable (alphabetic plus numeric) character set, and the input is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: This works because the `sed` substitution removes any characters not in the
    set `[:alnum:]`, which is the POSIX regular expression shorthand for all alphanumeric
    characters. If the value of this transformation doesn’t match the original input
    entered earlier, it reveals the presence of nonalphanumeric values in the input
    string, thus indicating the input is invalid. The function returns a nonzero result
    to indicate a problem. Keep in mind, we are expecting only ASCII text.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This script is self-contained. It prompts for input and then informs you whether
    the input is valid. A more typical use of this function, however, would be to
    copy and paste it at the top of another shell script or to reference it as part
    of a library as shown in [Script #12](ch01.xhtml#ch01lev1sec13) on [page 42](ch01.xhtml#page_42).'
  prefs: []
  type: TYPE_NORMAL
- en: '`validalnum` is also a good example of a general shell script programming technique.
    Write your functions and then test them before you integrate them into larger,
    more complex scripts. By doing so, you’ll spare yourself lots of headaches.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `validalnum` shell script is simple to use, asking the user to enter a string
    to validate. [Listing 1-4](ch01.xhtml#ch1ex4) shows how the script handles valid
    and invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-4: Testing the* `*validalnum*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This “remove the good characters and see what’s left” approach is nice because
    it’s flexible, particularly if you remember to wrap both your input variable and
    matching pattern (or no pattern at all) in double quotes to avoid empty input
    errors. Empty patterns are a constant problem with scripting because they turn
    a valid conditional test into a broken statement, producing an error message.
    It’s beneficial to always keep in mind that a zero-character quoted phrase is
    different from a blank phrase. Want to require uppercase letters but also allow
    spaces, commas, and periods? Simply change the substitution pattern at ➊ to the
    code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a simple test like the following for validating phone number
    input (allowing integer values, spaces, parentheses, and dashes but not leading
    spaces or multiple spaces in sequence):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you want to limit input to integer values only, you must beware of a
    pitfall. As an example, you might be tempted to try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works for positive numbers, but what if you want to permit entry
    of negative numbers? If you just add the minus sign to the valid character set,
    `-3-4` would be valid input, though it’s clearly not a legal integer. [Script
    #5](ch01.xhtml#ch01lev1sec06) on [page 23](ch01.xhtml#page_23) addresses how to
    handle negative numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**#3 Normalizing Date Formats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One issue with shell script development is the number of inconsistent data
    formats; normalizing them can range from a bit tricky to quite difficult. Date
    formats are some of the most challenging to work with because a date can be specified
    in so many different ways. Even if you prompt for a specific format, like month-day-year,
    you’ll likely be given inconsistent input: a month number instead of a month name,
    an abbreviation for a month name, or even a full name in all uppercase letters.
    For this reason, a function that normalizes dates, though rudimentary on its own,
    will prove a very helpful building block for subsequent script work, especially
    for [Script #7](ch01.xhtml#ch01lev1sec08) on [page 29](ch01.xhtml#page_29).'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The script in [Listing 1-5](ch01.xhtml#ch1ex5) normalizes date formats that
    meet a relatively simple set of criteria: the month must be given either as a
    name or as a value between 1 and 12, and the year must be given as a four-digit
    value. The normalized date consists of the month’s name (as a three-letter abbreviation),
    followed by the day, followed by the four-digit year.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-5: The* `*normdate*` *shell script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the third conditional in this script at ➊. It strips out all the digits
    from the first input field and then uses the `-z` test to see whether the result
    is blank. If the result is blank, that means the input is only digits, so we can
    map it directly to a month name with `monthNumToName`, which also validates whether
    the number represents a valid month. Otherwise, we assume the first input is a
    month string, and we normalize it with a complex sequence of `cut` and `tr` pipes
    using two subshell calls (that is, sequences surrounded by `$(` and `)`, where
    the enclosed commands get invoked and substituted with their output).
  prefs: []
  type: TYPE_NORMAL
- en: The first subshell sequence, at ➋, extracts just the first character of the
    input and makes it uppercase with `tr` (though the sequence `echo $1|cut -c1`
    could also be written as `${1%${1#?}}` in the POSIX manner, as seen earlier).
    The second sequence, at ➌, extracts the second and third characters and forces
    them to be lowercase, resulting in a capitalized three-letter abbreviation for
    `month`. Note that this string manipulation method doesn’t check whether the input
    is actually a valid month, unlike when a digit for the month is passed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To ensure maximum flexibility with future scripts that incorporate the `normdate`
    functionality, this script was designed to accept input as three fields entered
    on the command line, as [Listing 1-6](ch01.xhtml#ch1ex6) shows. If you expected
    to use this script only interactively, you’d prompt the user for the three fields,
    though that would make it more difficult to invoke `normdate` from other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-6: Testing the* `*normdate*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this script just normalizes month representations; day formats (such
    as those with leading zeros) and years remain untouched.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before you get too excited about the many extensions you can add to this script
    to make it more sophisticated, check out [Script #7](ch01.xhtml#ch01lev1sec08)
    on [page 29](ch01.xhtml#page_29), which uses `normdate` to validate input dates.'
  prefs: []
  type: TYPE_NORMAL
- en: One modification you could make, however, would be to allow the script to accept
    dates in the format MM/DD/YYYY or MM-DD-YYYY by adding the following code immediately
    before the first conditional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this modification, you can then enter and normalize the following common
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you read the code carefully, you’ll realize that it would be improved with
    a more sophisticated approach to validating the year in a specified date, not
    to mention taking into account various international date formats. We leave those
    to you as an exercise to explore!
  prefs: []
  type: TYPE_NORMAL
- en: '**#4 Presenting Large Numbers Attractively**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common mistake that programmers make is to present the results of calculations
    to the user without formatting them first. It’s difficult for users to ascertain
    whether `43245435` goes into the millions without counting from right to left
    and mentally inserting a comma every three digits. The script in [Listing 1-7](ch01.xhtml#ch1ex7)
    formats your numbers nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-7: The* `*nicenumber*` *script formats long numbers to make them
    more readable.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The heart of this script is the `while` loop within the `nicenumber()` function
    ➌, which iteratively keeps removing the three least significant digits from the
    numeric value stored in the variable `thousands` ➍ and attaches these digits to
    the pretty version of the number that it’s building up ➎. The loop then reduces
    the number stored in thousands ➏ and feeds it through the loop again if necessary.
    Once the `nicenumber()` function is done, the main script logic starts. First
    it parses any options passed to the script with `getopts` ➐ and then finally it
    calls the `nicenumber()` function ➑ with the last argument the user specified.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script, simply specify a very large numeric value. The script will
    add a decimal point and separators as needed, using either the default values
    or the characters specified through flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result can be incorporated within an output message, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `nicenumber` shell script is easy to use but can also take some advanced
    options. [Listing 1-8](ch01.xhtml#ch1ex8) demonstrates using the script to format
    a few numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-8: Testing the* `*nicenumber*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Different countries use different characters for the thousands and decimal delimiters,
    so we can add flexible calling flags to this script. For example, Germans and
    Italians would use `-d "."` and `-t ","`, the French use `-d ","` and `-t " "`,
    and the Swiss, who have four national languages, use `-d "."` and `-t "'"`. This
    is a great example of a situation in which flexible is better than hardcoded so
    the tool is useful to the largest possible user community.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we did hardcode the `"."` as the decimal separator for input
    values, so if you are anticipating fractional input values using a different delimiter,
    you can change the two calls to `cut` at ➊ and ➋ that currently specify a `"."`
    as the decimal delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows one solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works, unless the decimal separator character in the input is different
    from the separator specified for the output, in which case the script breaks silently.
    A more sophisticated solution would include a test just before these two lines
    to ensure that the input decimal separator is the same as the one requested by
    the user. We could implement this test by using the same trick shown in [Script
    #2](ch01.xhtml#ch01lev1sec03) on [page 15](ch01.xhtml#page_15): cut out all the
    digits and see what’s left, as in the following code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**#5 Validating Integer Input**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you saw in [Script #2](ch01.xhtml#ch01lev1sec03) on [page 15](ch01.xhtml#page_15),
    validating integer input seems like a breeze, until you want to ensure that negative
    values are acceptable too. The problem is that each numeric value can have only
    one negative sign, which must come at the very beginning of the value. The validation
    routine in [Listing 1-9](ch01.xhtml#ch1ex9) makes sure that negative numbers are
    correctly formatted, and, more generally useful, it can check whether values are
    within a range specified by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-9: The* `*validint*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Validating an integer is fairly straightforward because values are either just
    a series of digits (0 through 9) or, possibly, a leading minus sign that can only
    occur once. If the `validint()` function is invoked with a minimum or maximum
    value, or both, it also checks against those to ensure that the entered value
    is within bounds.
  prefs: []
  type: TYPE_NORMAL
- en: The function ensures at ➊ that the user hasn’t skipped entry entirely (here’s
    another place where it’s critical to anticipate the possibility of an empty string
    with the use of quotes to ensure that we don’t generate an error message). Then
    at ➋, it looks for the minus sign and, at ➌, creates a version of the entered
    value with all digits removed. If that value is not zero length, there’s a problem
    and the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is valid, the user-entered number is compared against the min and
    max values ➍. Finally, the function returns 1 upon error or 0 upon success.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This entire script is a function that can be copied into other shell scripts
    or included as a library file. To turn this into a command, simply append the
    code in [Listing 1-10](ch01.xhtml#ch1ex10) to the bottom of the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-10: Adding support to* `*validint*` *to run it as a command*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After placing [Listing 1-10](ch01.xhtml#ch1ex10) in your script, you should
    be able to use it as [Listing 1-11](ch01.xhtml#ch1ex11) shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-11: Testing the* `*validint*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Notice the test at ➋ checks whether the number’s first character is a negative
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the first character is a negative sign, `testvalue` is assigned the numeric
    portion of the integer value. This non-negative value is then stripped of digits
    and tested further.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be tempted to use a logical AND (`-a`) to connect expressions and
    shrink some of the nested `if` statements. For example, it seems as though this
    code should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, it doesn’t, because even if the first condition of an AND expression
    proves false, you can’t guarantee that the second condition won’t be tested as
    well (unlike in most other programming languages). That means you’re liable to
    experience all sorts of bugs from invalid or unexpected comparison values if you
    try this. It shouldn’t be the case, but that’s shell scripting for you.
  prefs: []
  type: TYPE_NORMAL
- en: '**#6 Validating Floating-Point Input**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Upon first glance, the process of validating a floating-point (or “real”) value
    within the confines and capabilities of a shell script might seem daunting, but
    consider that a floating-point number is only two integers separated by a decimal
    point. Couple that insight with the ability to reference a different script inline
    (`validint`), and you’ll see that a floating-point validation test can be surprisingly
    short. The script in [Listing 1-12](ch01.xhtml#ch1ex12) assumes it is being run
    from the same directory as the `validint` script.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-12: The* `*validfloat*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The script first checks whether the input value includes a decimal point ➊.
    If it doesn’t, it’s not a floating-point number. Next, the decimal ➋ and fractional
    ➌ portions of the value are chopped out for analysis. Then at ➍, the script checks
    whether the decimal portion (the number to the *left* of the decimal point) is
    a valid integer. The next sequence is more complicated, because we need to check
    at ➎ that there’s no extra negative sign (to avoid weirdness like 17\. –30) and
    then, again, ensure that the fractional part (the number to the *right* of the
    decimal point) is a valid integer.
  prefs: []
  type: TYPE_NORMAL
- en: The last check, at ➏, is whether the user specified just a minus sign and a
    decimal point (which would be pretty peculiar, you have to admit).
  prefs: []
  type: TYPE_NORMAL
- en: All good? Then the script returns 0, indicating that the user input a valid
    float.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If no error message is produced when the function is called, the return code
    is 0, and the number specified is a valid floating-point value. You can test this
    script by appending the following few lines to the end of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If `validint` is generating an error, make sure that you have it in your `PATH`
    as a separate function accessible to the script or just copy and paste it into
    the script file directly.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `validfloat` shell script simply takes an argument to attempt to validate.
    [Listing 1-13](ch01.xhtml#ch1ex13) uses the `validfloat` script to validate a
    few inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-13: Testing the* `*validfloat*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see additional output at this point, it might be because you added a
    few lines to test out `validint` earlier but forgot to remove them when you moved
    on to this script. Simply go back to [Script #5](ch01.xhtml#ch01lev1sec06) on
    [page 23](ch01.xhtml#page_23) and ensure that the last few lines that let you
    run the function as a stand-alone are commented out or deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A cool additional hack would be to extend this function to allow scientific
    notation, as demonstrated in the last example. It wouldn’t be too difficult. You’d
    test for the presence of `''e''` or `''E''` and then split the result into three
    segments: the decimal portion (always a single digit), the fractional portion,
    and the power of 10\. Then you’d just need to ensure that each is a `validint`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to require a leading zero before the decimal point, you could
    also modify the conditional test at ➏ in [Listing 1-12](ch01.xhtml#ch1ex12). Be
    careful with odd formats, however.
  prefs: []
  type: TYPE_NORMAL
- en: '**#7 Validating Date Formats**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most challenging validation tasks, but one that’s crucial for shell
    scripts that work with dates, is to ensure that a specific date is actually possible
    on the calendar. If we ignore leap years, this task isn’t too bad, because the
    calendar is consistent every year. All we need in that case is a table with the
    maximum number of days per month against which to compare a specified date. To
    take leap years into account, you have to add some additional logic to the script,
    and that’s where it gets a bit more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'One set of rules for testing whether a given year is a leap year is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: • Years not divisible by 4 are *not* leap years.
  prefs: []
  type: TYPE_NORMAL
- en: • Years divisible by 4 and by 400 *are* leap years.
  prefs: []
  type: TYPE_NORMAL
- en: • Years divisible by 4, not divisible by 400, but divisible by 100 are *not*
    leap years.
  prefs: []
  type: TYPE_NORMAL
- en: • All other years divisible by 4 *are* leap years.
  prefs: []
  type: TYPE_NORMAL
- en: As you read through the source code in [Listing 1-14](ch01.xhtml#ch1ex14), notice
    how this script utilizes `normdate` to ensure a consistent date format before
    proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-14: The* `*valid-date*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a fun script to write because it requires a fair amount of smart conditional
    testing for days in month, leap years, and so on. The logic doesn’t just specify
    month = 1–12, day = 1–31, and so on. For the sake of organization, specific functions
    are used to make things easier to both write and understand.
  prefs: []
  type: TYPE_NORMAL
- en: To start, `exceedsDaysInMonth()` parses the user’s month specifier, being very
    loose in its analysis (meaning that the month name `JANUAR` would work just fine).
    This is done at ➊ with a `case` statement that translates its argument into lowercase
    and then compares values to ascertain the days in the month. This works, but it
    assumes that February always has 28 days.
  prefs: []
  type: TYPE_NORMAL
- en: To address leap years, the second function `isLeapYear()` uses some basic mathematical
    tests to ascertain whether the year specified had a February 29th ➋.
  prefs: []
  type: TYPE_NORMAL
- en: In the main script, the input is passed to the previously presented script `normdate`
    to normalize the input format ➌ and then split into the three fields `$month`,
    `$day`, and `$year`. Then the function `exceedsDaysInMonth` is invoked to see
    whether the day is invalid for the specified month (such as Sept 31), with the
    special conditional triggered if the user specified February as the month and
    29 as the day. That’s tested against the year with `isLeapYear`, and at ➍, an
    error is generated as appropriate. If the user input survives all of these tests,
    it’s a valid date!
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the script (as [Listing 1-15](ch01.xhtml#ch1ex15) shows), enter a date
    into the command line in month-day-year format. The month can be a three-letter
    abbreviation, a full word, or a numeric value; the year must be four digits.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-15: Testing the* `*valid-date*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A similar approach to this script could validate time specifications, using
    either a 24-hour clock or an ante meridiem/post meridiem (AM/PM) suffix. Split
    the value at the colon, ensure that the minutes and seconds (if specified) are
    between 0 and 60, and then check that the first value is between 0 and 12 if allowing
    AM/PM, or between 0 and 24 if you prefer a 24-hour clock. Fortunately, while there
    are leap seconds and other tiny variations in time to help keep the calendar balanced,
    we can safely ignore them on a day-to-day basis, so there’s no need to fret over
    implementing such hairy time calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very different way to test for leap years is a possibility if you have access
    to GNU `date` on your Unix or GNU/Linux implementation. Test by specifying this
    command and seeing what result you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you have the newer, better version of `date`, you’ll see `366`. In the older
    version, well, it’ll just complain about the input format. Now think about that
    result from the newer `date` command and see if you can figure out a two-line
    function that tests whether a given year is a leap year!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this script is quite permissive about month names; `febmama` works
    just fine since the `case` statement at ➊ checks only the first three letters
    of the specified word. This can be cleaned up and improved if you’d prefer by
    either testing for common abbreviations (like `feb`) along with the fully spelled
    out month name (`february`) and perhaps even common misspellings (`febuary`).
    All are easily done if you’re so motivated!
  prefs: []
  type: TYPE_NORMAL
- en: '**#8 Sidestepping Poor echo Implementations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in ““[What Is POSIX?](ch01.xhtml#ch01lev1sec01)” on [page 10](ch01.xhtml#page_10),
    while most modern Unix and GNU/Linux implementations have a version of the `echo`
    command that knows the `-n` flag should suppress trailing newlines on the output,
    not all implementations work that way. Some use `\c` as a special embedded character
    to defeat this default behavior, and others simply insist on including the trailing
    newline regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Figuring out whether your particular `echo` is well implemented is easy: Simply
    enter these commands and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If your `echo` works with the `-n` flag, you’ll see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If it doesn’t, you’ll see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Ensuring that the script output is presented to the user as desired is important
    and will become increasingly important as our scripts become more interactive.
    To that end, we’ll write an alternate version of `echo`, called `echon`, that
    will always suppress the trailing newline. That way we’ll have something reliable
    to call every time we want the `echo -n` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are as many ways to solve this quirky `echo` problem as there are pages
    in this book. One of our favorites is very succinct; it simply filters its input
    through the `awk printf` command, as [Listing 1-16](ch01.xhtml#ch1ex16) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-16: A simple* `*echo*` *alternative using the* `*awk printf*` *command*'
  prefs: []
  type: TYPE_NORMAL
- en: However, you may prefer to avoid the overhead incurred when calling the `awk`
    command. If you have a user-level `printf` command, you can write `echon` to filter
    input through that instead, as in [Listing 1-17](ch01.xhtml#ch1ex17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-17: An* `*echo*` *alternative using a simple* `*printf*` *command*'
  prefs: []
  type: TYPE_NORMAL
- en: What if you don’t have `printf` and you don’t want to call `awk`? Then use the
    `tr` command to chop off any final carriage return, just like in [Listing 1-18](ch01.xhtml#ch1ex18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-18: A simple* `*echo*` *alternative using the* `*tr*` *utility*'
  prefs: []
  type: TYPE_NORMAL
- en: This method is simple and efficient, and it should be quite portable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Simply add the script file to your `PATH`, and you’ll be able to replace any
    `echo -n` calls with `echon` to reliably leave the user’s cursor at the end of
    the line after a printout.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `echon` shell script works by taking an argument and printing it and then
    reading some user input to demonstrate the `echon` function. [Listing 1-19](ch01.xhtml#ch1ex19)
    shows the test script in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-19: Testing the* `*echon*` *command*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We won’t lie. The fact that some shells have an `echo` statement that knows
    the `-n` flag and others expect `\c` as the closing sequence, while others just
    don’t seem to have the ability to avoid adding the carriage return, is a huge
    pain for scripters. To address this inconsistency, you could create a function
    to automatically test the output of `echo` to determine which scenario was in
    force and then modify its invocation appropriately. For example, you might write
    something like `echo -n hi | wc -c` and then test whether the result was two characters
    (`hi`), three characters (`hi` plus a carriage return), four characters (`-n hi`),
    or five characters (`-n hi` plus a carriage return).
  prefs: []
  type: TYPE_NORMAL
- en: '**#9 An Arbitrary-Precision Floating-Point Calculator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most commonly used sequences in script writing is `$(( ))`, which
    lets you perform calculations using various rudimentary mathematical functions.
    This sequence can be quite useful, facilitating common operations like incrementing
    counter variables. It supports addition, subtraction, division, remainder (or
    modulo), and multiplication operations, though not with fractions or decimal values.
    Thus, the following command returns 0, not 0.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So when calculating values that need better precision, you’ve got a challenge
    on your hands. There just aren’t many good calculator programs that work on the
    command line. The one exception is `bc`, an oddball program that few Unix people
    are taught. Billing itself as an arbitrary-precision calculator, the `bc` program
    harks back to the dawn of Unix, complete with cryptic error messages, exactly
    zero prompts, and the assumption that if you’re using it, you already know what
    you’re doing. But that’s okay. We can write a wrapper to make `bc` more user-friendly,
    as [Listing 1-20](ch01.xhtml#ch1ex20) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-20: The* `*scriptbc*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `<<` notation at ➌ allows you to include content from the script and treat
    it as if it were typed directly into the input stream, which in this case provides
    an easy mechanism for handing commands to the `bc` program. This is referred to
    as writing a *here document*. In this notation, whatever you put after the `<<`
    sequence is what it’ll then seek to match (on a line by itself) to denote the
    end of that input stream. In [Listing 1-20](ch01.xhtml#ch1ex20), it’s `EOF`.
  prefs: []
  type: TYPE_NORMAL
- en: This script also demonstrates how you can use arguments to make commands more
    flexible. Here, if the script is invoked with a `-p` flag ➊, it allows you to
    specify the desired precision of the output number. If no precision is specified,
    the program defaults to `scale=2` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: When working with `bc`, it’s critical to understand the difference between `length`
    and `scale`. As far as `bc` is concerned, `length` refers to the total number
    of digits in the number, while `scale` is the total number of digits after the
    decimal point. Thus, 10.25 has a `length` of 4 and a `scale` of 2, while 3.14159
    has a `length` of 6 and a `scale` of 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `bc` has a variable value for `length`, but because it has a `scale`
    of zero, `bc` without any modifications works exactly as the `$(( ))` notation
    does. Fortunately, if you add a `scale` setting to `bc`, you find that there’s
    lots of hidden power under the hood, as shown in this example, which calculates
    how many weeks elapsed between 1962 and 2002 (excluding leap days):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To allow access to the `bc` capabilities from the command line, a wrapper script
    has to silence the opening copyright information, if present—though most `bc`
    implementations already silence the header if their input isn’t the terminal (`stdin`).
    The wrapper also sets the `scale` to a reasonable value, feeds in the actual expression
    to the `bc` program, and then exits with a `quit` command.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run this script, feed a mathematical expression to the program as an argument
    as [Listing 1-21](ch01.xhtml#ch1ex21) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-21: Testing the* `*scriptbc*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '**#10 Locking Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any script that reads or appends to a shared file, such as a log file, needs
    a reliable way to lock files so that other instantiations of the script don’t
    accidentally overwrite data before it’s done being used. A common way to accomplish
    this is to create a separate *lock file* for each file being used. The existence
    of a lock file serves as a *semaphore*, an indicator that a file is being used
    by a different script and is not available. The requesting script then repeatedly
    waits and tries again until the semaphore lock file is removed, indicating that
    the file is free to edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lock files are tricky, though, because many seemingly foolproof solutions don’t
    actually work. For example, the following code is a typical approach to solving
    this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Seems like it would work, doesn’t it? The code loops until the lock file doesn’t
    exist and then creates it to ensure that you own the lock and can therefore modify
    the base file safely. If another script with the same loop sees your lock, it
    will also spin until the lock file vanishes. However, this doesn’t work in practice.
    Imagine what would happen if, just after the `while` loop exited but before the
    `touch` was executed, this script was swapped out and put back in the processor
    queue, giving another script a chance to run.
  prefs: []
  type: TYPE_NORMAL
- en: In case you’re not sure what we’re referring to, remember that although your
    computer seems to be doing one thing at a time, it’s actually running multiple
    programs at the same time by doing a tiny bit with one, switching to another one,
    doing a tiny bit with that, and switching back. The problem here is that in the
    time between when your script finishes checking for a lock file and when it creates
    its own, the system might swap to another script, which could dutifully test for
    a lock file, find it absent, and create its own version. Then that script could
    swap out, and your script could swap back in to resume executing the `touch` command.
    The result would be that both scripts now think they have exclusive access to
    the lock file, which is exactly what we were trying to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Stephen van den Berg and Philip Guenther, authors of the `procmail`
    email-filtering program, also created a command line utility, `lockfile`, that
    lets you safely and reliably work with lock files in shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Unix distributions, including GNU/Linux and OS X, have `lockfile` already
    installed. You can check whether your system has `lockfile` simply by entering
    `man 1 lockfile`. If you get a man page, you’re in luck! The script in [Listing
    1-22](ch01.xhtml#ch1ex22) assumes that you have the `lockfile` command, and subsequent
    scripts require the reliable locking mechanism of [Script #10](ch01.xhtml#ch01lev1sec11)
    to function, so make sure the `lockfile` command is installed on your system.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-22: The* `*filelock*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As is typical with a well-written shell script, half of [Listing 1-22](ch01.xhtml#ch1ex22)
    is parsing input variables and checking for error conditions. Finally, it gets
    to the `if` statement, and then it tries to actually use the system `lockfile`
    command. If there is one, it invokes it with a specified number of retries, generating
    its own error message if it does not finally succeed. What if you requested an
    unlock (for example, removal of an existing lock) and there is none? That generates
    another error. Otherwise, the `lockfile` is removed and you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, the first block ➊ uses the powerful `getopts` function to
    parse all the possible user input flags (`-l`, `-u`, `-r`) with a `while` loop.
    This is a common way to utilize `getopts`, which will occur again and again in
    the book. Note the shift `$(($OPTIND - 1 ))` statement at ➋: `OPTIND` is set by
    `getopts`, which lets the script keep shifting values down (so `$2` becomes `$1`,
    for example) until it is done processing those values with a leading dash.'
  prefs: []
  type: TYPE_NORMAL
- en: Since this script utilizes the system `lockfile` utility, it’s good form to
    ensure the utility is in the user’s path before invoking it ➌, failing with an
    error message if that’s not the case. Then there’s a simple conditional at ➍ to
    see whether we’re locking or unlocking and the appropriate invocation to the `lockfile`
    utility in each case.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the `lockfile` script isn’t one you’d ordinarily use by itself, you can
    test it by having two terminal windows open. To create a lock, simply specify
    the name of the file you want to lock as an argument of `filelock`. To remove
    the lock, run the script again with the `-u` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, create a locked file as [Listing 1-23](ch01.xhtml#ch1ex23) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-23: Creating a file lock with the* `*filelock*` *command*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second time you attempt to lock the file, `filelock` tries the default
    number of times (10) and then fails (shown in [Listing 1-24](ch01.xhtml#ch1ex24)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-24: The* `*filelock*` *command failing to create a lock file*'
  prefs: []
  type: TYPE_NORMAL
- en: When the first process is done with the file, you can release the lock, as [Listing
    1-25](ch01.xhtml#ch1ex25) details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-25: Releasing a lock on a file with the* `*filelock*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: To see how the `filelock` script works with two terminals, run the unlock command
    in one window while the other is spinning, trying to establish its own exclusive
    lock.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because this script relies on the existence of a lock file as proof that the
    lock is still enforced, it would be useful to have an additional parameter, say,
    the longest length of time for which a lock should be valid. If the `lockfile`
    routine times out, the last accessed time of the locked file could then be checked,
    and if the locked file is older than the value of this parameter, it can safely
    be deleted as a stray, perhaps with a warning message.
  prefs: []
  type: TYPE_NORMAL
- en: This is unlikely to affect you, but `lockfile` doesn’t work with network filesystem
    (NFS) mounted networked drives. In fact, a reliable file-locking mechanism on
    an NFS-mounted disk is quite complex. A better strategy that sidesteps the problem
    entirely is to create lock files only on local disks or to use a network-aware
    script that can manage locks across multiple systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**#11 ANSI Color Sequences**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although you might not realize it, most terminal applications support different
    styles of presenting text. Quite a few variations are possible, whether you’d
    like to have certain words in your script displayed in boldface or even in red
    against a yellow background. However, working with *ANSI (American National Standards
    Institute)* sequences to represent these variations can be difficult because they’re
    quite user-unfriendly. To simplify them, [Listing 1-26](ch01.xhtml#ch1ex26) creates
    a set of variables whose values represent the ANSI codes, which can be used to
    toggle various color and formatting options on and off.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-26: The* `*initializeANSI*` *script function*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re used to HTML, you might be baffled by the way these sequences work.
    In HTML, you open and close modifiers in opposite order, and you must close every
    modifier you open. Thus, to create an italicized passage within a sentence displayed
    in bold, you’d use the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Closing the bold tag without closing the italics wreaks havoc and can mess
    up some web browsers. But with the ANSI color sequences, some modifiers actually
    override the previous ones, and there is also a reset sequence that closes all
    modifiers. With ANSI sequences, you must make sure to output the reset sequence
    after using colors and to use the `off` feature for anything you turn `on`. Using
    the variable definitions in this script, you would rewrite the previous sequence
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To run this script, first call the initialization function and then output
    a few `echo` statements with different combinations of color and type effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The results in [Listing 1-27](ch01.xhtml#ch1ex27) don’t look too thrilling in
    this book, but on a display that supports these color sequences, they definitely
    catch your attention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-27: The text that would be printed if the script in [Listing 1-26](ch01.xhtml#ch1ex26)
    were run*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When using this script, you may see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you do, the problem might be that your terminal or window doesn’t support
    ANSI color sequences or that it doesn’t understand the `\033` notation for the
    all-important `esc` variable. To remedy the latter problem, open up the script
    in `vi` or your favorite terminal editor, delete the `\033` sequence, and replace
    it by entering a `^V` (CTRL-V) keystroke followed by an ESC key press, which should
    show up as `^[`. If the results on screen look like `esc="^["`, all should work
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, your terminal or window doesn’t support ANSI sequences
    at all, you might want to upgrade so that you can add colorized and typeface-enhanced
    output to your other scripts. But before you ditch your current terminal, check
    your terminal’s preferences—some have a setting you can enable for full ANSI support.
  prefs: []
  type: TYPE_NORMAL
- en: '**#12 Building a Shell Script Library**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the scripts in this chapter have been written as functions rather than
    as stand-alone scripts so that they can be easily incorporated into other scripts
    without incurring the overhead of making system calls. While there’s no `#include`
    feature in a shell script as there is in C, there is a tremendously important
    capability called *sourcing* a file that serves the same purpose, allowing you
    to include other scripts as though they are library functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see why this is important, let’s consider the alternative. If you invoke
    a shell script within a shell, by default that script is run within its own subshell.
    You can see this experimentally here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The script *tinyscript.sh* changed the value of the variable `test`, but only
    within the subshell running the script, so the value of the existing `test` variable
    in our shell’s environment was not affected. If instead you run the script using
    the dot (`.`) notation to source the script, then it is handled as though each
    command in the script were typed directly into the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, if you source a script that has an `exit 0` command, it
    will exit the shell and log out of the window, because the `source` operation
    makes the sourced script the primary running process. If you had a script running
    in a subshell, it would exit without the main script stopping. That’s a major
    difference and one reason to opt for sourcing scripts with `.` or `source` or
    (as we’ll explain later) `exec`. The `.` notation is actually identical to the
    `source` command in bash; we’re using `.` because it’s more portable across different
    POSIX shells.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To turn the functions in this chapter into a library for use in other scripts,
    extract all the functions and any needed global variables or arrays (that is,
    values that are common across multiple functions) and concatenate them into one
    big file. If you call this file *library.sh*, you can use the following test script
    to access all the functions we’ve written in this chapter and see whether they’re
    working properly, as [Listing 1-28](ch01.xhtml#ch1ex28) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-28: Sourcing the previously implemented functions as a single library
    and calling them*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that the library is incorporated and all functions are read and included
    in the runtime environment of the script, with the single line at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: This useful approach for working with many scripts in this book can be exploited
    again and again as needed. Just make sure that the library file you’re including
    is accessible from your `PATH` so that the `.` command can find it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the test script, invoke it from the command line as you would any other,
    just like in [Listing 1-29](ch01.xhtml#ch1ex29).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-29: Running the* `*library-test*` *script*'
  prefs: []
  type: TYPE_NORMAL
- en: On your screen, the error messages for a value that is too large will be in
    bold. Also, the correct guess of a leap year will be displayed in green.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, 432 wasn’t a leap year because leap years didn’t start appearing
    in the calendar until 1752\. But we’re talking about shell scripts, not calendar
    hacks, so we’ll let this slide.
  prefs: []
  type: TYPE_NORMAL
- en: '**#13 Debugging Shell Scripts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this section doesn’t contain a true script per se, we want to spend
    a few pages talking about some basics of debugging shell scripts, because it’s
    a sure bet that bugs are always going to creep in!
  prefs: []
  type: TYPE_NORMAL
- en: 'In our experience, the best debugging strategy is to build scripts incrementally.
    Some script programmers have a high degree of optimism that everything will work
    right the first time, but starting small can really help move things along. Additionally,
    you should make liberal use of `echo` statements to track variables and invoke
    your scripts explicitly using `bash -x` to display debugging output, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run `set -x` beforehand to enable debugging and `set
    +x` afterward to stop it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: To see the `-x` and `+x` sequences in action, let’s debug a simple number-guessing
    game, shown in [Listing 1-30](ch01.xhtml#ch1ex30).
  prefs: []
  type: TYPE_NORMAL
- en: '***The Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-30: The* `*hilow*` *script, which may contain a few errors in need
    of debugging ...*'
  prefs: []
  type: TYPE_NORMAL
- en: '***How It Works***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand how the random number portion at ➊ works, keep in mind that the
    sequence `$$` is the processor ID (PID) of the shell that runs the script, typically
    a 5- or 6-digit value. Each time you run the script, it gets a different PID.
    The `% $biggest` sequence then divides the PID value by the specified biggest
    acceptable value and returns the remainder. In other words, `5 % 4 = 1`, as does
    `41 % 4`. It’s an easy way to produce a semi-random number between 1 and `$biggest`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step in debugging this game is to test and ensure that the number
    generated will be sufficiently random. To do this, we take the PID of the shell
    in which the script is run, using the `$$` notation, and reduce it to a usable
    range using the `%` mod function ➊. To test the function, enter the commands into
    the shell directly, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This worked, but it’s not very random. A moment’s thought reveals why: when
    the command is run directly on the command line, the PID is always the same; but
    when run in a script, the command is in a different subshell each time, so the
    PID varies.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to generate a random number is by referencing the environment variable
    `$RANDOM`. It’s magic! Each time you reference it, you get a different value.
    To generate a number between 1 and `$biggest`, you’d use `$(( $RANDOM % $biggest
    + 1 ))` at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add the basic logic of the game. A random number between
    1 and 100 is generated ➊; the player makes guesses ➋; and after each guess, the
    player is told whether the guess is too high ➌ or too low ➍, until they finally
    guess the correct value. After entering all the basic code, it’s time to run the
    script and see how it goes. Here we use [Listing 1-30](ch01.xhtml#ch1ex30), warts
    and all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Ugh, the bane of shell script developers: an unexpected end of file (EOF).
    Just because the message says the error is on line 19 doesn’t mean it’s actually
    there. In fact, line 19 is perfectly fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To understand what’s going on, remember that quoted passages can contain newlines.
    This means that when the shell hits a quoted passage that we haven’t closed properly,
    it will just keep reading down the script looking for matching quotes, only stopping
    when it hits the very last quote and realizes something is amiss.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem, therefore, must come earlier in the script. The only really useful
    thing about the error message from the shell is that it tells you which character
    is mismatched, so we can `grep` to try to extract all lines that have a quote
    and then filter out the ones that have two quotes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it! The closing quote is missing on the line that tells the user they
    must guess a smaller number ➍. We’ll add the missing quote at the end of the line
    and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Nope. Another problem. Because there are so few parenthesized expressions in
    the script, we can just eyeball this problem and see that the closing parenthesis
    of the random number instantiation was mistakenly truncated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix this by adding the closing parenthesis to the end of the line but
    before the code comment. Does the game work now? Let’s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Almost. But because 100 is the maximum possible value, there seems to be an
    error in the code’s logic. These errors are particularly tricky because there’s
    no fancy `grep` or `sed` invocation to identify the problem. Look back at the
    code and see if you can identify what’s going wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug this, we can add a few `echo` statements to output the user’s chosen
    number and verify that what was entered is what’s being tested. The relevant section
    of code starts at ➋, but we’ve reprinted the lines here for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, as we modified the `echo` statement and looked at these two lines,
    we realized the error: the variable being read is `answer`, but the variable being
    tested is called `guess`. A boneheaded error, but not an uncommon one (particularly
    if you have oddly spelled variable names). To fix this, we should change `read
    answer` to `read guess`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Results***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, it works as expected, shown in [Listing 1-31](ch01.xhtml#ch1ex31).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-31: The* `*hilow*` *shell script game working in all its glory*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking the Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The most grievous bug lurking in this little script is that it doesn’t validate
    input. Enter anything at all other than an integer and the script sputters and
    fails. Including a rudimentary test could be as easy as adding the following lines
    of code inside the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Problem is, confirming that it’s a nonzero input doesn’t mean it’s a number,
    and you can generate errors from the test command with an input like `hi`. To
    fix the problem, add a call to the `validint` function from [Script #5](ch01.xhtml#ch01lev1sec06)
    on [page 23](ch01.xhtml#page_23).'
  prefs: []
  type: TYPE_NORMAL
