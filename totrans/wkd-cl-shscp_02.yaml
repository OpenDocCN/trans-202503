- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**THE MISSING CODE LIBRARY**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺失的代码库**'
- en: '![image](../images/common4.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common4.jpg)'
- en: One of Unix’s greatest strengths is that it lets you create new commands by
    combining old ones in novel ways. But even though Unix includes hundreds of commands
    and there are thousands of ways to combine them, you will still encounter situations
    where nothing does the job quite right. This chapter focuses on the stepping stones
    that allow you to create smarter and more sophisticated programs within the world
    of shell scripting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Unix的最大优势之一在于，它允许你通过以新颖的方式将旧命令组合起来，创建新的命令。尽管Unix包括数百个命令，并且有成千上万种组合它们的方法，但你仍然会遇到一些情况，没有任何一个命令能完全满足需求。本章将重点介绍一些垫脚石，帮助你在shell脚本的世界中创建更智能、更复杂的程序。
- en: 'There’s also something we should address up front: the shell script programming
    environment isn’t as sophisticated as a real programming environment. Perl, Python,
    Ruby, and even C have structures and libraries that offer extended capabilities,
    but shell scripts are more of a “roll your own” world. The scripts in this chapter
    will help you make your way in that world. They’re the building blocks that will
    help you write the wicked cool shell scripts that come later in the book.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我们应该提前说明：shell脚本编程环境并不像真实的编程环境那么复杂。Perl、Python、Ruby甚至C语言都有提供扩展功能的结构和库，但shell脚本更像是一个“自创”的世界。本章中的脚本将帮助你在这个世界中找到自己的路。它们是构建块，帮助你编写本书后面将介绍的酷炫shell脚本。
- en: Much of the challenge of script writing also arises from subtle variations among
    different flavors of Unix and among the many different GNU/Linux distributions.
    While the IEEE POSIX standards supposedly provide a common base of functionality
    across Unix implementations, it can still be confusing to use an OS X system after
    a year in a Red Hat GNU/Linux environment. The commands are different, they’re
    in different locations, and they often have subtly different command flags. These
    variations can make writing shell scripts tricky, but we’ll learn a few tricks
    to keep these variations at bay.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本的挑战之一，来自于不同版本的Unix和不同的GNU/Linux发行版之间的微妙差异。尽管IEEE的POSIX标准应该为Unix的实现提供一个共同的功能基础，但在Red
    Hat GNU/Linux环境中使用了一年之后，再使用OS X系统可能会感到困惑。命令不同，位置不同，且它们的命令标志也常常有所不同。这些差异可能使得编写shell脚本变得棘手，但我们将学习一些技巧，帮助你应对这些变化。
- en: '**What Is POSIX?**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是POSIX？**'
- en: The early days of Unix were the Wild West, with companies innovating and taking
    the operating system in different directions while simultaneously assuring customers
    that all these new versions were compatible with each other and just like every
    other Unix. The Institute for Electrical and Electronic Engineers (IEEE) stepped
    in and, with tremendous effort from all the major Unix vendors, created a standard
    definition for Unix called the Portable Operating System Interface, or *POSIX*
    for short, against which all commercial and open source Unix implementations are
    measured. You can’t buy a POSIX operating system per se, but the Unix or GNU/Linux
    you run is generally POSIX compliant (though there’s some debate about whether
    we even need a POSIX standard at all, when GNU/Linux has become a de facto standard
    of its own).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Unix的早期就像是西部荒野，许多公司在创新并将操作系统带向不同的方向，同时还向客户保证所有这些新版本彼此兼容，并且与其他Unix系统没有区别。电气和电子工程师协会（IEEE）介入，并在所有主要Unix供应商的巨大努力下，创建了一个Unix的标准定义，称为可移植操作系统接口（Portable
    Operating System Interface），简称*POSIX*，所有商业和开源的Unix实现都以此为衡量标准。你不能单纯地购买一个POSIX操作系统，但你运行的Unix或GNU/Linux通常是POSIX兼容的（尽管是否需要POSIX标准一直存在争议，特别是当GNU/Linux本身已成为事实上的标准时）。
- en: 'At the same time, even POSIX-compliant Unix implementations can vary. One example
    addressed later in this chapter involves the `echo` command. Some versions of
    this command support an `-n` flag, which disables the trailing newline that’s
    a standard part of the command execution. Other versions of `echo` support the
    `\c` escape sequence as a special “don’t include a newline” notation, while still
    others have no way to avoid the newline at the end of the output. To make things
    even more interesting, some Unix systems have a command shell with a built-in
    `echo` function that ignores the `-n` and `\c` flags, as well as a stand-alone
    binary `/bin/echo` that understands these flags. This makes it tough to prompt
    for input in a shell script, because scripts should work identically on as many
    Unix systems as possible. So for functional scripts, it’s critical to normalize
    the `echo` command to work the same way across systems. Later in this chapter,
    in [Script #8](ch01.xhtml#ch01lev1sec09) on [page 33](ch01.xhtml#page_33), we’ll
    see how to wrap `echo` inside a shell script to create just such a normalized
    version of the command.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，即使是POSIX兼容的Unix实现也可能有所不同。章节后面将提到的一个例子涉及`echo`命令。某些版本的`echo`支持`-n`选项，该选项禁用命令执行时的尾随换行符。其他版本的`echo`支持`\c`转义序列作为特殊的“不包含换行符”标记，而还有一些版本无法避免输出末尾的换行符。更有趣的是，一些Unix系统具有内置的`echo`函数，它忽略`-n`和`\c`选项，同时也有独立的二进制文件`/bin/echo`，可以理解这些选项。这使得在Shell脚本中提示输入变得棘手，因为脚本应该尽可能在多个Unix系统中表现一致。因此，对于功能性的脚本，必须对`echo`命令进行规范化，以确保它在不同系统上表现相同。稍后在本章的[脚本#8](ch01.xhtml#ch01lev1sec09)中，位于[第33页](ch01.xhtml#page_33)，我们将看到如何将`echo`包装在Shell脚本中，以创建这种规范化版本的命令。
- en: '**NOTE**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some of the scripts in this book take advantage of bash-style features that
    may not be supported by all POSIX-compatible shells.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书中的一些脚本利用了bash风格的特性，这些特性可能并非所有POSIX兼容的Shell都支持。*'
- en: But enough backstory—let’s start looking at scripts to include in our shell
    script library!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说——让我们开始查看可以加入我们Shell脚本库的脚本吧！
- en: '**#1 Finding Programs in the PATH**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#1 在PATH中查找程序**'
- en: 'Shell scripts that use environment variables (like `MAILER` and `PAGER`) have
    a hidden danger: some of their settings may point to nonexistent programs. In
    case you haven’t bumped into these environment variables before, `MAILER` should
    be set to the email program you prefer (like `/usr/bin/mailx`), and `PAGER` should
    be set to the program that you use to view long documents one screenful (page)
    at a time. For example, if you decide to be flexible by using the `PAGER` setting
    to display script output instead of using the system’s default paging program
    (common values would be the `more` or `less` programs), how do you ensure that
    the `PAGER` environment value is set to a valid program?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量（如`MAILER`和`PAGER`）的Shell脚本存在一个潜在的危险：它们的某些设置可能指向不存在的程序。如果你之前没有接触过这些环境变量，`MAILER`应该设置为你偏好的电子邮件程序（如`/usr/bin/mailx`），而`PAGER`应该设置为你用来逐页查看长文档的程序。例如，如果你决定通过使用`PAGER`设置来显示脚本输出，而不是使用系统默认的分页程序（常见的值是`more`或`less`程序），你如何确保`PAGER`环境变量设置为有效的程序呢？
- en: This first script addresses how to test whether a given program can be found
    in the user’s `PATH`. It’s also a good demonstration of a number of different
    shell-scripting techniques, including script functions and variable slicing. [Listing
    1-1](ch01.xhtml#ch1ex1) shows how you can verify that paths are valid.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本解决了如何测试给定程序是否可以在用户的`PATH`中找到的问题。它同时展示了多种Shell脚本技巧，包括脚本函数和变量切片。[清单 1-1](ch01.xhtml#ch1ex1)展示了如何验证路径是否有效。
- en: '***The Code***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 1-1: The* `*inpath*` *shell script functions*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-1：* `*inpath*` *Shell脚本功能*'
- en: As stated in [Chapter 0](ch00.xhtml#ch00), we recommend that you create a new
    directory called *scripts* in your home directory, and then add that fully qualified
    directory name to your `PATH` variable. Use `echo $PATH` to see your current `PATH`
    and edit the contents of your login script (*.login*, *.profile*, *.bashrc*, or
    *.bash_profile*, depending on the shell) to modify your `PATH` appropriately.
    See “[Configuring Your Login Script](ch00.xhtml#ch00lev1sec03)” on [page 4](ch00.xhtml#page_4)
    for more details.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第0章](ch00.xhtml#ch00)所述，我们建议你在主目录中创建一个名为*scripts*的新目录，并将该完全限定的目录名添加到你的`PATH`变量中。使用`echo
    $PATH`来查看当前的`PATH`，并编辑你的登录脚本（*login*、*profile*、*bashrc*或*bash_profile*，具体取决于所用的Shell），以适当地修改`PATH`。更多详细信息请参见[“配置登录脚本”](ch00.xhtml#ch00lev1sec03)，详见[第4页](ch00.xhtml#page_4)。
- en: '**NOTE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you are listing files in the terminal with the* `*ls*` *command, some special
    files, like* .bashrc *or* .bash_profile*, may not show up at first. This is because
    files that start with a period, as* .bashrc *does, are considered “hidden” by
    the filesystem. (This turned out to be a bit of a bug-turned-feature very early
    on in Unix.) To list all the files in a directory, including the hidden ones,
    use the* `*-a*` *argument with* `*ls*`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在终端使用* `*ls*` *命令列出文件，一些特殊文件，如* .bashrc *或* .bash_profile*，可能一开始不会显示。这是因为以点号开头的文件（如*
    .bashrc*）被文件系统视为“隐藏”文件。（这实际上是 Unix 初期出现的一个 bug，但后来变成了特性。）要列出目录中的所有文件，包括隐藏文件，可以使用*
    `*-a*` *参数和* `*ls*`。'
- en: Definitely worth mentioning again is the assumption that you’re running bash
    as your shell for all these scripts. Note that this script explicitly sets the
    first line (called the *shebang*) to call `/bin/bash`. Many systems also support
    a `/usr/bin/env bash` shebang setting as the runtime for the script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一下，我们假设你使用的是 bash 作为所有这些脚本的 shell。请注意，脚本明确设置了第一行（称为 *shebang*）来调用 `/bin/bash`。许多系统也支持
    `/usr/bin/env bash` 作为脚本的运行时环境。
- en: '**A NOTE ON COMMENTS**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的说明**'
- en: We wrestled with whether to include a detailed explanation of how each script
    works. In some cases, we’ll provide an explanation of a tricky coding segment
    after the code, but in general we’ll use code comments to explain, in context,
    what’s happening. Look for lines that begin with the `#` symbol or, sometimes,
    anything that appears after the `#` on a line of code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经纠结是否要包含每个脚本如何工作的详细解释。在某些情况下，我们会在代码后提供对一些复杂编码片段的解释，但通常我们会使用代码注释在上下文中解释发生了什么。请注意以
    `#` 符号开头的行，或者有时是代码行中 `#` 后面的任何内容。
- en: Since you’ll doubtless find yourself reading other people’s scripts (other than
    ours, of course!), it’s useful to practice figuring out what the heck is going
    on in a script by reading the comments. Commenting is also an excellent habit
    to get into when writing scripts of your own, to help you define what you seek
    to accomplish in specific blocks of code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你很可能会阅读其他人的脚本（当然不是我们的脚本！），因此练习通过阅读注释来弄清楚脚本中的内容非常有用。注释也是编写自己脚本时的一个好习惯，可以帮助你定义在特定代码块中要完成的任务。
- en: '***How It Works***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The key to getting `checkForCmdInPath` to work is for it to be able to differentiate
    between variables that contain just the program name (like `echo`) and variables
    that contain a full directory path plus the filename (like `/bin/echo`). It does
    this by examining the first character of the given value to see whether it’s a
    `/`; hence, we have the need to isolate the first character from the rest of the
    variable value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使 `checkForCmdInPath` 正常工作的关键是能够区分仅包含程序名称（如 `echo`）的变量和包含完整目录路径加文件名（如 `/bin/echo`）的变量。它通过检查给定值的第一个字符是否为
    `/` 来实现这一点；因此，我们需要将第一个字符与变量值的其余部分隔离开来。
- en: 'Note that the variable-slicing syntax `${var:0:1}` at ➊ is a shorthand notation
    that lets you specify substrings in a string, starting from an offset and continuing
    up to the given length (returning the entire rest of the string if no length is
    provided). The expression `${var:10}`, for example, will return the remaining
    value of `$var` starting from the 10th character, while `${var:10:5}` constrains
    the substring to just the characters between positions 10 and 15, inclusive. You
    can see what we mean here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变量切片语法 `${var:0:1}` 在 ➊ 处是一个简写表示法，允许你在字符串中指定子字符串，从偏移量开始并持续到给定的长度（如果没有提供长度，则返回字符串的其余部分）。例如，表达式
    `${var:10}` 将返回从第 10 个字符开始的 `$var` 的剩余值，而 `${var:10:5}` 将子字符串限制为第 10 到第 15 个字符之间的字符（包括
    10 和 15）。你可以通过以下方式理解我们的意思：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [Listing 1-1](ch01.xhtml#ch1ex1), the syntax is just used to see whether
    the specified path has a leading slash. Once we have determined whether the path
    passed to the script starts with a leading slash, we check if we can actually
    find the path on the filesystem. If the path begins with a `/`, we assume the
    path given is an absolute path and check whether it exists using the `-x` bash
    operator ➋. Otherwise, we pass the value to our `inpath` function ➌ to see whether
    the value can be found in any of the directories set in our default `PATH`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 1-1](ch01.xhtml#ch1ex1)中，语法仅用于查看指定路径是否有前导斜杠。一旦我们确定传递给脚本的路径是否以斜杠开头，我们就检查是否可以在文件系统中找到该路径。如果路径以`/`开头，我们假设给定的路径是绝对路径，并使用`-x`
    bash运算符 ➋ 检查它是否存在。否则，我们将该值传递给`inpath`函数 ➌，看看它是否能在默认的`PATH`中设置的任何目录中找到。
- en: '***Running the Script***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To run this script as a stand-alone program, we first need to append a short
    block of commands to the very end of the file. These commands will do the basic
    work of actually getting user input and passing it to the function we wrote, as
    shown here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此脚本作为独立程序运行，我们首先需要在文件的末尾添加一小段命令。这些命令将执行获取用户输入并将其传递给我们编写的函数的基本工作，如下所示。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you’ve added the code, you can invoke the script directly, as shown next
    in “The Results.” Make sure to remove or comment out this additional code when
    you’re done with the script, however, so it can be included as a library function
    later without messing things up.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了代码，就可以直接调用脚本，如下所示的“结果”部分。但是，在完成脚本后，确保删除或注释掉这段附加代码，这样它就可以作为库函数在以后使用，而不会搞乱其他内容。
- en: '***The Results***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: 'To test the script, let’s invoke `inpath` with the names of three programs:
    a program that exists, a program that exists but isn’t in the `PATH`, and a program
    that does not exist but that has a fully qualified filename and path. [Listing
    1-2](ch01.xhtml#ch1ex2) shows an example test of the script.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试脚本，让我们用三种程序的名称来调用`inpath`：一个存在的程序，一个存在但不在`PATH`中的程序，以及一个不存在但有完整文件名和路径的程序。[列表
    1-2](ch01.xhtml#ch1ex2)展示了脚本的示例测试。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 1-2: Testing the* `*inpath*` *script*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-2：测试* `*inpath*` *脚本*'
- en: The last block of code we added translates the results of the `in_path` function
    into something more readable, so now we can easily see that each of the three
    cases get handled as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的最后一块代码将`in_path`函数的结果转换为更易读的格式，现在我们可以轻松地看到，三种情况都按预期处理了。
- en: '***Hacking the Script***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'If you want to be a code ninja here on the very first script, switch the expression
    `${var:0:1}` to its more complicated cousin: `${var%${var#?}}`. This is the POSIX
    variable-slicing method. The apparent gobbledygook is really two nested string
    slices. The inner call of `${var#?}` extracts everything but the first character
    of `var`, where `#` is a call to delete the first instance of a given pattern
    and `?` is a regular expression that matches exactly one character.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想成为这里第一个脚本的代码忍者，可以将表达式`${var:0:1}`换成它更复杂的版本：`${var%${var#?}}`。这就是POSIX变量切片方法。看似复杂的语法实际上是两个嵌套的字符串切片操作。内层调用`${var#?}`提取除了`var`的第一个字符之外的所有内容，其中`#`表示删除给定模式的第一个实例，而`?`是一个正则表达式，匹配恰好一个字符。
- en: Next, the call `${var%*pattern*}` produces a substring with everything left
    over once the specified pattern is removed from `var`. In this case, the pattern
    being removed is the result of the inner call, so what’s left is the first character
    of the string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`${var%*pattern*}`会生成一个子字符串，去掉指定模式后的剩余部分。在这种情况下，删除的模式是内层调用的结果，因此剩下的就是字符串的第一个字符。
- en: If this POSIX notation is too funky for you, most shells (including bash, ksh,
    and zsh) support the other method of variable slicing, `${*varname*:*start*:*size*}`,
    which was used in the script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种POSIX表示法对你来说太复杂，大多数shell（包括bash、ksh和zsh）都支持另一种变量切片方法，`${*varname*:*start*:*size*}`，这在脚本中也有使用。
- en: 'Of course, if you don’t like either of these techniques for extracting the
    first character, you can also use a system call: `$(echo $var | cut -c1)`. With
    bash programming, there will likely be multiple ways to solve a given problem,
    be it extracting, transforming, or loading data from the system in different ways.
    It’s important to realize and understand that this “many ways to skin a cat” approach
    doesn’t mean one way is better than another.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你不喜欢这些提取第一个字符的技术，你还可以使用系统调用：`$(echo $var | cut -c1)`。在bash编程中，通常会有多种方式来解决一个给定的问题，无论是提取、转换，还是以不同的方式从系统加载数据。重要的是要意识到并理解，“多种方式解题”并不意味着某一种方式比其他方式更好。
- en: 'Also, if you want to create a version of this, or any script, that can differentiate
    between when it’s running as a stand-alone and when it’s invoked from another
    script, consider adding a conditional test near the beginning, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你想创建一个版本的脚本，能够区分它是在独立运行还是从另一个脚本中调用，考虑在开头添加一个条件测试，正如这里所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll leave it as an exercise for you, dear reader, to write the rest of the
    snippet after some experimentation!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把剩下的代码片段留给你，亲爱的读者，通过一些实验来完成！
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Script #47](ch06.xhtml#ch06lev1sec03) on [page 150](ch06.xhtml#page_150)
    is a useful script that’s closely related to this one. It validates both the directories
    in the* `*PATH*` *and the environment variables in the user’s login environment.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*[脚本 #47](ch06.xhtml#ch06lev1sec03) 在 [第150页](ch06.xhtml#page_150) 是一个与此脚本紧密相关的有用脚本。它验证了`*PATH*`中的两个目录以及用户登录环境中的环境变量。*'
- en: '**#2 Validating Input: Alphanumeric Only**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#2 验证输入：仅限字母数字**'
- en: Users are constantly ignoring directions and entering data that is inconsistent,
    is incorrectly formatted, or uses incorrect syntax. As a shell script developer,
    you need to identify and flag these errors before they become problems.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常忽视指示，输入不一致、格式不正确或语法错误的数据。作为一个Shell脚本开发者，你需要在这些问题变成麻烦之前，识别并标记这些错误。
- en: A typical situation involves filenames or database keys. Your program prompts
    the user for a string that’s supposed to be *alphanumeric*, consisting exclusively
    of uppercase characters, lowercase characters, and digits—no punctuation, no special
    characters, no spaces. Did they enter a valid string? That’s what the script in
    [Listing 1-3](ch01.xhtml#ch1ex3) tests.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的情况涉及文件名或数据库键。你的程序提示用户输入一个字符串，应该是*字母数字*的，只包含大写字母、小写字母和数字——没有标点符号，没有特殊字符，没有空格。用户输入的是有效字符串吗？这就是[清单
    1-3](ch01.xhtml#ch1ex3)中测试的内容。
- en: '***The Code***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 1-3: The* `*validalnum*` *script*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-3：`*validalnum*` 脚本*'
- en: '***How It Works***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The logic of this script is straightforward. First, create a new version of
    the entered information with a `sed`-based transform that removes all invalid
    characters ➊. Then, compare the new version with the original ➋. If the two are
    the same, all is well. If not, the transformation lost data that wasn’t part of
    the acceptable (alphabetic plus numeric) character set, and the input is invalid.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的逻辑很简单。首先，使用基于`sed`的转换创建输入信息的新版本，去除所有无效字符 ➊。然后，将新版本与原始版本进行比较 ➋。若两者相同，表示一切正常。如果不同，说明转换过程中丢失了不属于可接受字符集（字母加数字）的数据，输入无效。
- en: This works because the `sed` substitution removes any characters not in the
    set `[:alnum:]`, which is the POSIX regular expression shorthand for all alphanumeric
    characters. If the value of this transformation doesn’t match the original input
    entered earlier, it reveals the presence of nonalphanumeric values in the input
    string, thus indicating the input is invalid. The function returns a nonzero result
    to indicate a problem. Keep in mind, we are expecting only ASCII text.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为`sed`替换会去除所有不在`[:alnum:]`集合中的字符，这是POSIX正则表达式中表示所有字母数字字符的简写。如果这个转换后的值与之前输入的原始值不匹配，就揭示了输入字符串中存在非字母数字字符，从而表示输入无效。该函数返回非零结果以指示问题。请记住，我们只期望ASCII文本。
- en: '***Running the Script***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'This script is self-contained. It prompts for input and then informs you whether
    the input is valid. A more typical use of this function, however, would be to
    copy and paste it at the top of another shell script or to reference it as part
    of a library as shown in [Script #12](ch01.xhtml#ch01lev1sec13) on [page 42](ch01.xhtml#page_42).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '这个脚本是自包含的。它会提示用户输入，然后告知输入是否有效。然而，这个函数的更典型使用方式是将其复制并粘贴到另一个 shell 脚本的顶部，或将其作为库的一部分引用，如在[脚本
    #12](ch01.xhtml#ch01lev1sec13)中展示的[第42页](ch01.xhtml#page_42)。'
- en: '`validalnum` is also a good example of a general shell script programming technique.
    Write your functions and then test them before you integrate them into larger,
    more complex scripts. By doing so, you’ll spare yourself lots of headaches.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`validalnum` 也是一个很好的通用 shell 脚本编程技巧示例。编写函数后再进行测试，然后再将它们集成到更大、更复杂的脚本中。这样做，你将避免很多麻烦。'
- en: '***The Results***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `validalnum` shell script is simple to use, asking the user to enter a string
    to validate. [Listing 1-4](ch01.xhtml#ch1ex4) shows how the script handles valid
    and invalid input.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`validalnum` shell 脚本很容易使用，它会提示用户输入一个字符串进行验证。[列表 1-4](ch01.xhtml#ch1ex4)展示了脚本如何处理有效和无效的输入。'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 1-4: Testing the* `*validalnum*` *script*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-4：测试* `*validalnum*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***黑客脚本***'
- en: 'This “remove the good characters and see what’s left” approach is nice because
    it’s flexible, particularly if you remember to wrap both your input variable and
    matching pattern (or no pattern at all) in double quotes to avoid empty input
    errors. Empty patterns are a constant problem with scripting because they turn
    a valid conditional test into a broken statement, producing an error message.
    It’s beneficial to always keep in mind that a zero-character quoted phrase is
    different from a blank phrase. Want to require uppercase letters but also allow
    spaces, commas, and periods? Simply change the substitution pattern at ➊ to the
    code shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“去除有效字符，看看剩下什么”的方法很好，因为它很灵活，特别是当你记得将输入变量和匹配模式（或根本不使用模式）都用双引号括起来，以避免空输入错误时。空模式在脚本编写中是一个常见问题，因为它会将有效的条件判断转变为一个无效的语句，产生错误信息。始终记住，零字符的带引号短语与空白短语是不同的，这一点是非常有益的。如果你想要求大写字母，同时允许空格、逗号和句号，只需将➊处的替换模式更改为这里显示的代码：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also use a simple test like the following for validating phone number
    input (allowing integer values, spaces, parentheses, and dashes but not leading
    spaces or multiple spaces in sequence):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下简单的测试来验证电话号码输入（允许整数值、空格、括号和破折号，但不允许前导空格或连续多个空格）：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But if you want to limit input to integer values only, you must beware of a
    pitfall. As an example, you might be tempted to try this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想将输入限制为整数值，你必须小心一个陷阱。例如，你可能会想尝试这样做：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code works for positive numbers, but what if you want to permit entry
    of negative numbers? If you just add the minus sign to the valid character set,
    `-3-4` would be valid input, though it’s clearly not a legal integer. [Script
    #5](ch01.xhtml#ch01lev1sec06) on [page 23](ch01.xhtml#page_23) addresses how to
    handle negative numbers.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码适用于正数，但如果你想允许负数输入呢？如果你只是将负号添加到有效字符集里，`-3-4` 就会变成有效输入，尽管它显然不是一个合法的整数。[脚本
    #5](ch01.xhtml#ch01lev1sec06) 在[第23页](ch01.xhtml#page_23)中讨论了如何处理负数。'
- en: '**#3 Normalizing Date Formats**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#3 规范化日期格式**'
- en: 'One issue with shell script development is the number of inconsistent data
    formats; normalizing them can range from a bit tricky to quite difficult. Date
    formats are some of the most challenging to work with because a date can be specified
    in so many different ways. Even if you prompt for a specific format, like month-day-year,
    you’ll likely be given inconsistent input: a month number instead of a month name,
    an abbreviation for a month name, or even a full name in all uppercase letters.
    For this reason, a function that normalizes dates, though rudimentary on its own,
    will prove a very helpful building block for subsequent script work, especially
    for [Script #7](ch01.xhtml#ch01lev1sec08) on [page 29](ch01.xhtml#page_29).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'Shell 脚本开发中的一个问题是数据格式的不一致性；将它们规范化可能从有点棘手到非常困难。日期格式是最难处理的，因为日期可以有很多不同的表示方式。即使你提示输入一个特定的格式，比如月-日-年，你也很可能会得到不一致的输入：例如数字表示月份而不是月份名称，月份名称的缩写，甚至是全部大写的月份名称。由于这个原因，一个规范化日期的函数，尽管它本身很基础，但将为后续脚本工作提供非常有用的构建块，特别是[脚本
    #7](ch01.xhtml#ch01lev1sec08)中在[第29页](ch01.xhtml#page_29)展示的。'
- en: '***The Code***'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: 'The script in [Listing 1-5](ch01.xhtml#ch1ex5) normalizes date formats that
    meet a relatively simple set of criteria: the month must be given either as a
    name or as a value between 1 and 12, and the year must be given as a four-digit
    value. The normalized date consists of the month’s name (as a three-letter abbreviation),
    followed by the day, followed by the four-digit year.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-5](ch01.xhtml#ch1ex5)中的脚本规范化符合相对简单条件集的日期格式：月份必须以名称或1到12之间的数字表示，年份必须以四位数字表示。规范化后的日期包括月份名称（以三字母缩写表示），接着是日期，再接着是四位数字的年份。'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 1-5: The* `*normdate*` *shell script*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-5：`*normdate*` Shell脚本*'
- en: '***How It Works***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: Notice the third conditional in this script at ➊. It strips out all the digits
    from the first input field and then uses the `-z` test to see whether the result
    is blank. If the result is blank, that means the input is only digits, so we can
    map it directly to a month name with `monthNumToName`, which also validates whether
    the number represents a valid month. Otherwise, we assume the first input is a
    month string, and we normalize it with a complex sequence of `cut` and `tr` pipes
    using two subshell calls (that is, sequences surrounded by `$(` and `)`, where
    the enclosed commands get invoked and substituted with their output).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意脚本中的第三个条件判断，位于➊。它会从第一个输入字段中剥离所有数字，然后使用`-z`测试检查结果是否为空。如果结果为空，说明输入仅包含数字，因此可以直接通过`monthNumToName`映射为一个月份名称，并验证该数字是否代表有效的月份。否则，我们假设第一个输入是一个月份字符串，并使用复杂的`cut`和`tr`管道结合两个子壳调用（即被`$(`和`)`括起来的命令序列，在这种情况下，命令会被调用并用其输出替代）对其进行规范化。
- en: The first subshell sequence, at ➋, extracts just the first character of the
    input and makes it uppercase with `tr` (though the sequence `echo $1|cut -c1`
    could also be written as `${1%${1#?}}` in the POSIX manner, as seen earlier).
    The second sequence, at ➌, extracts the second and third characters and forces
    them to be lowercase, resulting in a capitalized three-letter abbreviation for
    `month`. Note that this string manipulation method doesn’t check whether the input
    is actually a valid month, unlike when a digit for the month is passed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个子壳序列位于➋，它提取输入的第一个字符并使用`tr`将其转换为大写（尽管`echo $1|cut -c1`序列也可以写成`${1%${1#?}}`，如之前在POSIX中所见）。第二个序列位于➌，它提取第二和第三个字符，并强制将其转换为小写，最终得到一个大写的三字母缩写形式的`month`。注意，这种字符串操作方法并不会检查输入是否实际是一个有效的月份，与传入数字的月份不同。
- en: '***Running the Script***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To ensure maximum flexibility with future scripts that incorporate the `normdate`
    functionality, this script was designed to accept input as three fields entered
    on the command line, as [Listing 1-6](ch01.xhtml#ch1ex6) shows. If you expected
    to use this script only interactively, you’d prompt the user for the three fields,
    though that would make it more difficult to invoke `normdate` from other scripts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保未来涉及`normdate`功能的脚本具有最大灵活性，本脚本设计为接受命令行输入的三个字段，如[清单 1-6](ch01.xhtml#ch1ex6)所示。如果你只打算交互式使用此脚本，应该提示用户输入这三个字段，但这会使得从其他脚本调用`normdate`变得更加困难。
- en: '***The Results***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 1-6: Testing the* `*normdate*` *script*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-6：测试`*normdate*`脚本*'
- en: Notice that this script just normalizes month representations; day formats (such
    as those with leading zeros) and years remain untouched.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个脚本只规范化月份表示方式；日期格式（例如带前导零的日期）和年份保持不变。
- en: '***Hacking the Script***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'Before you get too excited about the many extensions you can add to this script
    to make it more sophisticated, check out [Script #7](ch01.xhtml#ch01lev1sec08)
    on [page 29](ch01.xhtml#page_29), which uses `normdate` to validate input dates.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '在你为这个脚本能添加的众多扩展感到兴奋之前，先查看一下[脚本 #7](ch01.xhtml#ch01lev1sec08)，它使用`normdate`来验证输入的日期，具体内容见[第29页](ch01.xhtml#page_29)。'
- en: One modification you could make, however, would be to allow the script to accept
    dates in the format MM/DD/YYYY or MM-DD-YYYY by adding the following code immediately
    before the first conditional.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以做一个修改，允许脚本接受MM/DD/YYYY或MM-DD-YYYY格式的日期，方法是将以下代码添加到第一个条件判断之前。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this modification, you can then enter and normalize the following common
    formats:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，你可以输入并规范化以下常见格式：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you read the code carefully, you’ll realize that it would be improved with
    a more sophisticated approach to validating the year in a specified date, not
    to mention taking into account various international date formats. We leave those
    to you as an exercise to explore!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细阅读代码，你会意识到，通过采用更复杂的方法验证指定日期中的年份，脚本将会得到改进，更不用说考虑到各种国际日期格式了。这些作为练习留给你去探索！
- en: '**#4 Presenting Large Numbers Attractively**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#4 以吸引人的方式展示大数字**'
- en: A common mistake that programmers make is to present the results of calculations
    to the user without formatting them first. It’s difficult for users to ascertain
    whether `43245435` goes into the millions without counting from right to left
    and mentally inserting a comma every three digits. The script in [Listing 1-7](ch01.xhtml#ch1ex7)
    formats your numbers nicely.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常犯的一个错误是，在将计算结果展示给用户之前，没有先对其进行格式化。用户很难判断`43245435`是否属于百万级别，除非他们从右到左数，并在每三个数字处
    mentally 插入一个逗号。[清单 1-7](ch01.xhtml#ch1ex7)中的脚本会很好地格式化你的数字。
- en: '***The Code***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 1-7: The* `*nicenumber*` *script formats long numbers to make them
    more readable.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-7: `*nicenumber*` 脚本将长数字格式化，使其更易于阅读。*'
- en: '***How It Works***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The heart of this script is the `while` loop within the `nicenumber()` function
    ➌, which iteratively keeps removing the three least significant digits from the
    numeric value stored in the variable `thousands` ➍ and attaches these digits to
    the pretty version of the number that it’s building up ➎. The loop then reduces
    the number stored in thousands ➏ and feeds it through the loop again if necessary.
    Once the `nicenumber()` function is done, the main script logic starts. First
    it parses any options passed to the script with `getopts` ➐ and then finally it
    calls the `nicenumber()` function ➑ with the last argument the user specified.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的核心是`nicenumber()`函数中的`while`循环 ➌，它通过迭代不断从存储在变量`thousands`中的数值中移除后三位，并将这些数字附加到正在构建的漂亮数字版本
    ➎。然后，循环会减少存储在`thousands`中的数字 ➏，如果需要，再次将其输入循环。`nicenumber()`函数完成后，主脚本逻辑开始。首先，它解析传递给脚本的任何选项，使用`getopts`
    ➐，然后最后调用`nicenumber()`函数 ➑，并将用户指定的最后一个参数传递给它。
- en: '***Running the Script***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To run this script, simply specify a very large numeric value. The script will
    add a decimal point and separators as needed, using either the default values
    or the characters specified through flags.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个脚本，只需指定一个非常大的数值。脚本会根据需要添加小数点和分隔符，使用默认值或通过标志指定的字符。
- en: 'The result can be incorporated within an output message, as demonstrated here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以纳入输出消息中，如下所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***The Results***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `nicenumber` shell script is easy to use but can also take some advanced
    options. [Listing 1-8](ch01.xhtml#ch1ex8) demonstrates using the script to format
    a few numbers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`nicenumber`脚本易于使用，但也可以接受一些高级选项。[清单 1-8](ch01.xhtml#ch1ex8)演示了使用脚本格式化一些数字。'
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 1-8: Testing the* `*nicenumber*` *script*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-8: 测试 `*nicenumber*` 脚本*'
- en: '***Hacking the Script***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: Different countries use different characters for the thousands and decimal delimiters,
    so we can add flexible calling flags to this script. For example, Germans and
    Italians would use `-d "."` and `-t ","`, the French use `-d ","` and `-t " "`,
    and the Swiss, who have four national languages, use `-d "."` and `-t "'"`. This
    is a great example of a situation in which flexible is better than hardcoded so
    the tool is useful to the largest possible user community.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不同国家使用不同的字符作为千位和小数点分隔符，因此我们可以为这个脚本添加灵活的调用标志。例如，德国人和意大利人使用`-d "."`和`-t ","`，法国人使用`-d
    ","`和`-t " "`，而瑞士有四种官方语言，他们使用`-d "."`和`-t "'"`。这是一个很好的例子，说明灵活性优于硬编码，使得该工具对尽可能广泛的用户群体都很有用。
- en: On the other hand, we did hardcode the `"."` as the decimal separator for input
    values, so if you are anticipating fractional input values using a different delimiter,
    you can change the two calls to `cut` at ➊ and ➋ that currently specify a `"."`
    as the decimal delimiter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们确实硬编码了 `"."` 作为输入值的小数分隔符，因此如果你预计会使用不同的分隔符来处理带小数的输入值，可以修改在 ➊ 和 ➋ 处调用的
    `cut` 命令，这里目前指定了 `"."` 作为小数分隔符。
- en: 'The following code shows one solution:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一种解决方案：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code works, unless the decimal separator character in the input is different
    from the separator specified for the output, in which case the script breaks silently.
    A more sophisticated solution would include a test just before these two lines
    to ensure that the input decimal separator is the same as the one requested by
    the user. We could implement this test by using the same trick shown in [Script
    #2](ch01.xhtml#ch01lev1sec03) on [page 15](ch01.xhtml#page_15): cut out all the
    digits and see what’s left, as in the following code.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码有效，除非输入中的小数分隔符与输出中指定的分隔符不同，在这种情况下，脚本会静默中断。一个更复杂的解决方案是在这两行之前加入一个测试，确保输入的小数分隔符与用户请求的相同。我们可以通过使用[脚本
    #2](ch01.xhtml#ch01lev1sec03)中展示的相同技巧来实现这一测试，如[第15页](ch01.xhtml#page_15)所示：将所有数字去掉，看看剩下什么，就像下面的代码一样。'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**#5 Validating Integer Input**'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#5 验证整数输入**'
- en: 'As you saw in [Script #2](ch01.xhtml#ch01lev1sec03) on [page 15](ch01.xhtml#page_15),
    validating integer input seems like a breeze, until you want to ensure that negative
    values are acceptable too. The problem is that each numeric value can have only
    one negative sign, which must come at the very beginning of the value. The validation
    routine in [Listing 1-9](ch01.xhtml#ch1ex9) makes sure that negative numbers are
    correctly formatted, and, more generally useful, it can check whether values are
    within a range specified by the user.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你在[脚本 #2](ch01.xhtml#ch01lev1sec03)中看到的那样，验证整数输入看起来很简单，直到你希望确保负值也能被接受。问题在于，每个数字值只能有一个负号，而且负号必须出现在值的最前面。[列表
    1-9](ch01.xhtml#ch1ex9)中的验证例程确保负数格式正确，并且更广泛地，它可以检查值是否在用户指定的范围内。'
- en: '***The Code***'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 1-9: The* `*validint*` *script*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-9：* `*validint*` *脚本*'
- en: '***How It Works***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***原理解释***'
- en: Validating an integer is fairly straightforward because values are either just
    a series of digits (0 through 9) or, possibly, a leading minus sign that can only
    occur once. If the `validint()` function is invoked with a minimum or maximum
    value, or both, it also checks against those to ensure that the entered value
    is within bounds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 验证整数是相对直接的，因为值要么只是数字（0到9）的序列，要么可能带有一个只能出现一次的负号。如果调用`validint()`函数并传入最小值或最大值，或者两者，它还会检查这些值，以确保输入的值在范围内。
- en: The function ensures at ➊ that the user hasn’t skipped entry entirely (here’s
    another place where it’s critical to anticipate the possibility of an empty string
    with the use of quotes to ensure that we don’t generate an error message). Then
    at ➋, it looks for the minus sign and, at ➌, creates a version of the entered
    value with all digits removed. If that value is not zero length, there’s a problem
    and the test fails.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在➊处确保用户没有完全跳过输入（这里另一个关键点是需要预见到可能出现空字符串的情况，使用引号来确保不会生成错误信息）。接着，在➋处，它检查负号，并在➌处创建一个去掉所有数字的输入值版本。如果该值的长度不为零，则表示存在问题，测试失败。
- en: If the value is valid, the user-entered number is compared against the min and
    max values ➍. Finally, the function returns 1 upon error or 0 upon success.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值有效，用户输入的数字会与最小值和最大值进行比较 ➍。最后，函数返回1表示出错，返回0表示成功。
- en: '***Running the Script***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: This entire script is a function that can be copied into other shell scripts
    or included as a library file. To turn this into a command, simply append the
    code in [Listing 1-10](ch01.xhtml#ch1ex10) to the bottom of the script.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 整个脚本是一个函数，可以复制到其他Shell脚本中或作为库文件包含。要将其转为命令，只需将[列表 1-10](ch01.xhtml#ch1ex10)中的代码附加到脚本的底部。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 1-10: Adding support to* `*validint*` *to run it as a command*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-10：为* `*validint*` *添加支持，以使其作为命令运行*'
- en: '***The Results***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: 'After placing [Listing 1-10](ch01.xhtml#ch1ex10) in your script, you should
    be able to use it as [Listing 1-11](ch01.xhtml#ch1ex11) shows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表 1-10](ch01.xhtml#ch1ex10)放入脚本中后，你应该能够像[列表 1-11](ch01.xhtml#ch1ex11)所示那样使用它：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 1-11: Testing the* `*validint*` *script*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-11：测试* `*validint*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'Notice the test at ➋ checks whether the number’s first character is a negative
    sign:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在➋处的测试检查数字的第一个字符是否为负号：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the first character is a negative sign, `testvalue` is assigned the numeric
    portion of the integer value. This non-negative value is then stripped of digits
    and tested further.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个字符是负号，`testvalue`将被赋值为整数值的数字部分。然后，这个非负值会去掉数字并进一步测试。
- en: 'You might be tempted to use a logical AND (`-a`) to connect expressions and
    shrink some of the nested `if` statements. For example, it seems as though this
    code should work:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想使用逻辑与（`-a`）来连接表达式并缩减一些嵌套的`if`语句。例如，看起来这段代码应该是有效的：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, it doesn’t, because even if the first condition of an AND expression
    proves false, you can’t guarantee that the second condition won’t be tested as
    well (unlike in most other programming languages). That means you’re liable to
    experience all sorts of bugs from invalid or unexpected comparison values if you
    try this. It shouldn’t be the case, but that’s shell scripting for you.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际并不是这样，因为即使一个AND表达式的第一个条件为假，你也不能保证第二个条件不会被测试（这与大多数其他编程语言不同）。这意味着，如果你尝试这样做，你可能会遇到各种无效或意外的比较值所导致的错误。这本不应该是这样，但这就是
    shell 脚本的特性。
- en: '**#6 Validating Floating-Point Input**'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#6 验证浮点输入**'
- en: Upon first glance, the process of validating a floating-point (or “real”) value
    within the confines and capabilities of a shell script might seem daunting, but
    consider that a floating-point number is only two integers separated by a decimal
    point. Couple that insight with the ability to reference a different script inline
    (`validint`), and you’ll see that a floating-point validation test can be surprisingly
    short. The script in [Listing 1-12](ch01.xhtml#ch1ex12) assumes it is being run
    from the same directory as the `validint` script.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，验证浮点（或“实数”）值的过程在 shell 脚本的范围和能力内可能看起来令人畏惧，但请考虑到，浮点数仅仅是两个整数通过小数点分隔开。结合这个洞察力，再加上能够内联引用不同脚本（`validint`）的能力，你会发现浮点数验证测试竟然可以出奇的简短。[清单
    1-12](ch01.xhtml#ch1ex12)中的脚本假设它是从与`validint`脚本相同的目录下运行的。
- en: '***The Code***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 1-12: The* `*validfloat*` *script*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-12：* `*validfloat*` *脚本*'
- en: '***How It Works***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: The script first checks whether the input value includes a decimal point ➊.
    If it doesn’t, it’s not a floating-point number. Next, the decimal ➋ and fractional
    ➌ portions of the value are chopped out for analysis. Then at ➍, the script checks
    whether the decimal portion (the number to the *left* of the decimal point) is
    a valid integer. The next sequence is more complicated, because we need to check
    at ➎ that there’s no extra negative sign (to avoid weirdness like 17\. –30) and
    then, again, ensure that the fractional part (the number to the *right* of the
    decimal point) is a valid integer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先检查输入值是否包含小数点 ➊。如果没有，它就不是浮点数。接下来，小数 ➋ 和分数 ➌ 部分的值会被切割出来进行分析。然后在 ➍，脚本检查小数部分（小数点*左侧*的数字）是否是一个有效的整数。接下来的检查较为复杂，因为我们需要在
    ➎ 检查是否没有额外的负号（避免出现像17\. –30这样的奇怪情况），然后再次确保分数部分（小数点*右侧*的数字）是一个有效的整数。
- en: The last check, at ➏, is whether the user specified just a minus sign and a
    decimal point (which would be pretty peculiar, you have to admit).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的检查在 ➏，是检查用户是否仅指定了负号和小数点（这会很奇怪，必须承认）。
- en: All good? Then the script returns 0, indicating that the user input a valid
    float.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常吗？如果是，那么脚本返回0，表示用户输入了一个有效的浮点数。
- en: '***Running the Script***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'If no error message is produced when the function is called, the return code
    is 0, and the number specified is a valid floating-point value. You can test this
    script by appending the following few lines to the end of the code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用该函数时没有产生错误信息，返回代码为0，并且指定的数字是一个有效的浮点值。你可以通过在代码末尾添加以下几行来测试这个脚本：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If `validint` is generating an error, make sure that you have it in your `PATH`
    as a separate function accessible to the script or just copy and paste it into
    the script file directly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`validint`产生了错误，确保它作为一个独立的函数在`PATH`中可以被脚本访问，或者直接将它复制粘贴到脚本文件中。
- en: '***The Results***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `validfloat` shell script simply takes an argument to attempt to validate.
    [Listing 1-13](ch01.xhtml#ch1ex13) uses the `validfloat` script to validate a
    few inputs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`validfloat` shell 脚本仅接受一个参数来进行验证。[清单 1-13](ch01.xhtml#ch1ex13)使用`validfloat`脚本验证几个输入。'
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 1-13: Testing the* `*validfloat*` *script*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-13：测试* `*validfloat*` *脚本*'
- en: 'If you see additional output at this point, it might be because you added a
    few lines to test out `validint` earlier but forgot to remove them when you moved
    on to this script. Simply go back to [Script #5](ch01.xhtml#ch01lev1sec06) on
    [page 23](ch01.xhtml#page_23) and ensure that the last few lines that let you
    run the function as a stand-alone are commented out or deleted.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你在此时看到额外的输出，可能是因为你之前为了测试 `validint` 添加了一些行，但在切换到这个脚本时忘记删除它们。只需返回到[脚本 #5](ch01.xhtml#ch01lev1sec06)的[第23页](ch01.xhtml#page_23)，确保那些让你以独立方式运行函数的最后几行已经被注释掉或删除。'
- en: '***Hacking the Script***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'A cool additional hack would be to extend this function to allow scientific
    notation, as demonstrated in the last example. It wouldn’t be too difficult. You’d
    test for the presence of `''e''` or `''E''` and then split the result into three
    segments: the decimal portion (always a single digit), the fractional portion,
    and the power of 10\. Then you’d just need to ensure that each is a `validint`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很酷的附加技巧是扩展这个函数以允许科学记数法，如最后一个例子所示。这并不难。你可以检测是否存在 `'e'` 或 `'E'`，然后将结果分为三个部分：小数部分（始终是一个数字），分数部分和10的幂。然后你只需要确保每部分都是一个
    `validint`。
- en: If you don’t want to require a leading zero before the decimal point, you could
    also modify the conditional test at ➏ in [Listing 1-12](ch01.xhtml#ch1ex12). Be
    careful with odd formats, however.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想要求小数点前有前导零，你也可以修改[列表1-12](ch01.xhtml#ch1ex12)中的条件测试。在处理奇怪格式时要小心。
- en: '**#7 Validating Date Formats**'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#7 验证日期格式**'
- en: One of the most challenging validation tasks, but one that’s crucial for shell
    scripts that work with dates, is to ensure that a specific date is actually possible
    on the calendar. If we ignore leap years, this task isn’t too bad, because the
    calendar is consistent every year. All we need in that case is a table with the
    maximum number of days per month against which to compare a specified date. To
    take leap years into account, you have to add some additional logic to the script,
    and that’s where it gets a bit more complicated.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最具挑战性的验证任务之一，但对于处理日期的Shell脚本至关重要的是，确保指定的日期在日历上实际存在。如果我们忽略闰年，这项任务不算太难，因为每年的日历是恒定的。在这种情况下，我们只需要一个包含每个月最大天数的表格，来与指定的日期进行比较。为了考虑闰年，你需要向脚本中添加一些额外的逻辑，这也使得问题变得更加复杂。
- en: 'One set of rules for testing whether a given year is a leap year is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 判断某一年是否为闰年的一组规则如下：
- en: • Years not divisible by 4 are *not* leap years.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: • 不能被4整除的年份*不是*闰年。
- en: • Years divisible by 4 and by 400 *are* leap years.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: • 能被4和400整除的年份*是*闰年。
- en: • Years divisible by 4, not divisible by 400, but divisible by 100 are *not*
    leap years.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: • 能被4整除，但不能被400整除的年份，以及能被100整除的年份*不是*闰年。
- en: • All other years divisible by 4 *are* leap years.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: • 所有其他能被4整除的年份*是*闰年。
- en: As you read through the source code in [Listing 1-14](ch01.xhtml#ch1ex14), notice
    how this script utilizes `normdate` to ensure a consistent date format before
    proceeding.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览[源代码列表1-14](ch01.xhtml#ch1ex14)时，注意这个脚本如何利用 `normdate` 来确保在继续之前日期格式一致。
- en: '***The Code***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 1-14: The* `*valid-date*` *script*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-14：* `*valid-date*` *脚本*'
- en: '***How It Works***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: This is a fun script to write because it requires a fair amount of smart conditional
    testing for days in month, leap years, and so on. The logic doesn’t just specify
    month = 1–12, day = 1–31, and so on. For the sake of organization, specific functions
    are used to make things easier to both write and understand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的脚本编写，因为它需要进行大量的智能条件测试，涉及到月份天数、闰年等内容。逻辑不仅仅是指定月份 = 1–12，日期 = 1–31 等等。为了组织性，使用了特定的函数来简化编写和理解过程。
- en: To start, `exceedsDaysInMonth()` parses the user’s month specifier, being very
    loose in its analysis (meaning that the month name `JANUAR` would work just fine).
    This is done at ➊ with a `case` statement that translates its argument into lowercase
    and then compares values to ascertain the days in the month. This works, but it
    assumes that February always has 28 days.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`exceedsDaysInMonth()` 解析用户的月份指定，分析非常宽松（这意味着月份名称 `JANUAR` 也能正常工作）。这一过程在 ➊
    使用一个 `case` 语句完成，该语句将其参数转换为小写字母，然后进行比较以确定该月的天数。这种方法可行，但假设二月总是28天。
- en: To address leap years, the second function `isLeapYear()` uses some basic mathematical
    tests to ascertain whether the year specified had a February 29th ➋.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决闰年问题，第二个函数 `isLeapYear()` 使用一些基本的数学测试来确定指定的年份是否有2月29日 ➋。
- en: In the main script, the input is passed to the previously presented script `normdate`
    to normalize the input format ➌ and then split into the three fields `$month`,
    `$day`, and `$year`. Then the function `exceedsDaysInMonth` is invoked to see
    whether the day is invalid for the specified month (such as Sept 31), with the
    special conditional triggered if the user specified February as the month and
    29 as the day. That’s tested against the year with `isLeapYear`, and at ➍, an
    error is generated as appropriate. If the user input survives all of these tests,
    it’s a valid date!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在主脚本中，输入被传递到之前展示的脚本 `normdate`，以规范化输入格式 ➌，然后将其拆分为三个字段 `$month`、`$day` 和 `$year`。接着，调用
    `exceedsDaysInMonth` 函数，检查指定月份的日期是否无效（例如 9月31日），如果用户指定了 2月并且日期为 29日，则会触发特殊条件。通过
    `isLeapYear` 来测试该年是否为闰年，在 ➍ 处生成适当的错误。如果用户输入通过了所有这些测试，那么它就是一个有效日期！
- en: '***Running the Script***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To run the script (as [Listing 1-15](ch01.xhtml#ch1ex15) shows), enter a date
    into the command line in month-day-year format. The month can be a three-letter
    abbreviation, a full word, or a numeric value; the year must be four digits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本（如[清单 1-15](ch01.xhtml#ch1ex15)所示），在命令行中输入日期，格式为月-日-年。月份可以是三字母缩写、完整单词或数字值；年份必须是四位数字。
- en: '***The Results***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 1-15: Testing the* `*valid-date*` *script*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-15：测试* `*valid-date*` *脚本*'
- en: '***Hacking the Script***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: A similar approach to this script could validate time specifications, using
    either a 24-hour clock or an ante meridiem/post meridiem (AM/PM) suffix. Split
    the value at the colon, ensure that the minutes and seconds (if specified) are
    between 0 and 60, and then check that the first value is between 0 and 12 if allowing
    AM/PM, or between 0 and 24 if you prefer a 24-hour clock. Fortunately, while there
    are leap seconds and other tiny variations in time to help keep the calendar balanced,
    we can safely ignore them on a day-to-day basis, so there’s no need to fret over
    implementing such hairy time calculations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 采用类似的方法，脚本可以验证时间规格，使用 24 小时制时钟或午前/午后（AM/PM）后缀。将值按照冒号分隔，确保分钟和秒数（如果指定）在 0 到 60
    之间，然后检查第一个值，如果允许 AM/PM，则应在 0 到 12 之间；如果使用 24 小时制，则应在 0 到 24 之间。幸运的是，虽然有闰秒和其他微小的时间变化来保持日历平衡，但我们在日常使用中可以安全忽略这些，因此不需要担心实现如此复杂的时间计算。
- en: 'A very different way to test for leap years is a possibility if you have access
    to GNU `date` on your Unix or GNU/Linux implementation. Test by specifying this
    command and seeing what result you get:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Unix 或 GNU/Linux 实现中能够访问到 GNU `date`，测试闰年的方法会有所不同。通过指定以下命令并查看得到的结果来进行测试：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you have the newer, better version of `date`, you’ll see `366`. In the older
    version, well, it’ll just complain about the input format. Now think about that
    result from the newer `date` command and see if you can figure out a two-line
    function that tests whether a given year is a leap year!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是更新、更好的 `date` 版本，你会看到 `366`。在较旧的版本中，它会抱怨输入格式。现在想想从更新版 `date` 命令得到的结果，看看你是否能想出一个两行的函数来测试某个年份是否为闰年！
- en: Finally, this script is quite permissive about month names; `febmama` works
    just fine since the `case` statement at ➊ checks only the first three letters
    of the specified word. This can be cleaned up and improved if you’d prefer by
    either testing for common abbreviations (like `feb`) along with the fully spelled
    out month name (`february`) and perhaps even common misspellings (`febuary`).
    All are easily done if you’re so motivated!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个脚本对于月份名称非常宽容；`febmama` 完全可以正常工作，因为 ➊ 处的 `case` 语句仅检查指定单词的前三个字母。如果你愿意，可以通过测试常见的缩写（如
    `feb`）以及完全拼写的月份名称（如 `february`），甚至是常见的拼写错误（如 `febuary`），来清理和改进这一点。如果你有动机，这些都很容易实现！
- en: '**#8 Sidestepping Poor echo Implementations**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#8 绕过不良的 echo 实现**'
- en: As mentioned in ““[What Is POSIX?](ch01.xhtml#ch01lev1sec01)” on [page 10](ch01.xhtml#page_10),
    while most modern Unix and GNU/Linux implementations have a version of the `echo`
    command that knows the `-n` flag should suppress trailing newlines on the output,
    not all implementations work that way. Some use `\c` as a special embedded character
    to defeat this default behavior, and others simply insist on including the trailing
    newline regardless.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 “[什么是 POSIX？](ch01.xhtml#ch01lev1sec01)”（第[10页](ch01.xhtml#page_10)）中提到的，虽然大多数现代
    Unix 和 GNU/Linux 实现都具有 `echo` 命令版本，并且知道 `-n` 标志应抑制输出中的尾随换行符，但并不是所有实现都如此。一些实现使用
    `\c` 作为特殊嵌入字符来防止默认行为，而其他一些则坚持在输出中始终包括尾随换行符。
- en: 'Figuring out whether your particular `echo` is well implemented is easy: Simply
    enter these commands and see what happens:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 判断你的 `echo` 是否正确实现很简单：只需输入这些命令并查看发生了什么：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If your `echo` works with the `-n` flag, you’ll see output like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 `echo` 支持 `-n` 标志，你会看到类似这样的输出：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If it doesn’t, you’ll see output like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，你会看到类似这样的输出：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ensuring that the script output is presented to the user as desired is important
    and will become increasingly important as our scripts become more interactive.
    To that end, we’ll write an alternate version of `echo`, called `echon`, that
    will always suppress the trailing newline. That way we’ll have something reliable
    to call every time we want the `echo -n` functionality.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 确保脚本输出按照预期呈现给用户非常重要，随着我们的脚本变得越来越互动，这一点将变得尤为重要。为此，我们将编写一个 `echo` 的替代版本，称为 `echon`，它将始终抑制尾部的换行符。这样，每次我们需要
    `echo -n` 功能时，就可以可靠地调用它。
- en: '***The Code***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: There are as many ways to solve this quirky `echo` problem as there are pages
    in this book. One of our favorites is very succinct; it simply filters its input
    through the `awk printf` command, as [Listing 1-16](ch01.xhtml#ch1ex16) shows.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个奇怪的 `echo` 问题的方式和本书中的页数一样多。我们最喜欢的方式之一非常简洁；它只是简单地通过 `awk printf` 命令过滤输入，正如
    [示例 1-16](ch01.xhtml#ch1ex16) 所示。
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 1-16: A simple* `*echo*` *alternative using the* `*awk printf*` *command*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-16：一个简单的* `*echo*` *替代方案，使用* `*awk printf*` *命令*'
- en: However, you may prefer to avoid the overhead incurred when calling the `awk`
    command. If you have a user-level `printf` command, you can write `echon` to filter
    input through that instead, as in [Listing 1-17](ch01.xhtml#ch1ex17).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能希望避免调用 `awk` 命令时产生的开销。如果你有一个用户级的 `printf` 命令，你可以写一个 `echon` 函数，使用它来过滤输入，就像在
    [示例 1-17](ch01.xhtml#ch1ex17) 中所示。
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 1-17: An* `*echo*` *alternative using a simple* `*printf*` *command*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-17：使用简单的* `*printf*` *命令的* `*echo*` *替代方案*'
- en: What if you don’t have `printf` and you don’t want to call `awk`? Then use the
    `tr` command to chop off any final carriage return, just like in [Listing 1-18](ch01.xhtml#ch1ex18).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 `printf`，并且不想调用 `awk`，那么可以使用 `tr` 命令去除任何最终的换行符，就像在 [示例 1-18](ch01.xhtml#ch1ex18)
    中所示。
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 1-18: A simple* `*echo*` *alternative using the* `*tr*` *utility*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-18：使用* `*tr*` *工具的一个简单* `*echo*` *替代方案*'
- en: This method is simple and efficient, and it should be quite portable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单高效，并且应该具有很好的可移植性。
- en: '***Running the Script***'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: Simply add the script file to your `PATH`, and you’ll be able to replace any
    `echo -n` calls with `echon` to reliably leave the user’s cursor at the end of
    the line after a printout.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将脚本文件添加到你的 `PATH`，你就可以用 `echon` 替代任何 `echo -n` 调用，确保每次输出后，用户的光标都停留在行尾。
- en: '***The Results***'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The `echon` shell script works by taking an argument and printing it and then
    reading some user input to demonstrate the `echon` function. [Listing 1-19](ch01.xhtml#ch1ex19)
    shows the test script in use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`echon` shell 脚本通过接收一个参数并打印它，然后读取一些用户输入来演示 `echon` 功能。[示例 1-19](ch01.xhtml#ch1ex19)
    展示了该测试脚本的使用。'
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 1-19: Testing the* `*echon*` *command*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-19：测试* `*echon*` *命令*'
- en: '***Hacking the Script***'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修改脚本***'
- en: We won’t lie. The fact that some shells have an `echo` statement that knows
    the `-n` flag and others expect `\c` as the closing sequence, while others just
    don’t seem to have the ability to avoid adding the carriage return, is a huge
    pain for scripters. To address this inconsistency, you could create a function
    to automatically test the output of `echo` to determine which scenario was in
    force and then modify its invocation appropriately. For example, you might write
    something like `echo -n hi | wc -c` and then test whether the result was two characters
    (`hi`), three characters (`hi` plus a carriage return), four characters (`-n hi`),
    or five characters (`-n hi` plus a carriage return).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会撒谎。事实是，某些 shell 的 `echo` 语句知道 `-n` 标志，而其他 shell 则期望使用 `\c` 作为结束符，还有一些 shell
    看似根本没有避免添加换行符的能力，这对于脚本编写者来说是个巨大的痛苦。为了解决这种不一致，你可以创建一个函数，自动测试 `echo` 的输出，以确定当前使用的是哪种情况，然后相应地修改调用。例如，你可以写类似于
    `echo -n hi | wc -c` 的命令，然后测试结果是两个字符（`hi`）、三个字符（`hi` 加上换行符）、四个字符（`-n hi`），还是五个字符（`-n
    hi` 加上换行符）。
- en: '**#9 An Arbitrary-Precision Floating-Point Calculator**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#9 一个任意精度的浮点计算器**'
- en: 'One of the most commonly used sequences in script writing is `$(( ))`, which
    lets you perform calculations using various rudimentary mathematical functions.
    This sequence can be quite useful, facilitating common operations like incrementing
    counter variables. It supports addition, subtraction, division, remainder (or
    modulo), and multiplication operations, though not with fractions or decimal values.
    Thus, the following command returns 0, not 0.5:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本编写中最常用的序列之一是`$(( ))`，它允许你使用各种基本的数学函数进行计算。这个序列非常有用，能够简化常见操作，例如递增计数器变量。它支持加法、减法、除法、余数（或取模）和乘法操作，但不支持分数或小数值。因此，以下命令返回0，而不是0.5：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So when calculating values that need better precision, you’ve got a challenge
    on your hands. There just aren’t many good calculator programs that work on the
    command line. The one exception is `bc`, an oddball program that few Unix people
    are taught. Billing itself as an arbitrary-precision calculator, the `bc` program
    harks back to the dawn of Unix, complete with cryptic error messages, exactly
    zero prompts, and the assumption that if you’re using it, you already know what
    you’re doing. But that’s okay. We can write a wrapper to make `bc` more user-friendly,
    as [Listing 1-20](ch01.xhtml#ch1ex20) shows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当计算需要更高精度的值时，你会面临一定的挑战。目前，命令行上并没有很多优秀的计算器程序。唯一的例外是`bc`，这个少数Unix用户了解的奇特程序。`bc`自称是一个任意精度的计算器，回溯到Unix的黎明时期，带有神秘的错误信息，完全没有提示，并假设你如果使用它，已经知道该怎么做。不过，这没关系。我们可以编写一个包装器，使`bc`更加用户友好，正如[清单
    1-20](ch01.xhtml#ch1ex20)所示。
- en: '***The Code***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 1-20: The* `*scriptbc*` *script*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-20: The* `*scriptbc*` *脚本*'
- en: '***How It Works***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: The `<<` notation at ➌ allows you to include content from the script and treat
    it as if it were typed directly into the input stream, which in this case provides
    an easy mechanism for handing commands to the `bc` program. This is referred to
    as writing a *here document*. In this notation, whatever you put after the `<<`
    sequence is what it’ll then seek to match (on a line by itself) to denote the
    end of that input stream. In [Listing 1-20](ch01.xhtml#ch1ex20), it’s `EOF`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ➌处的`<<`表示法允许你从脚本中包含内容，并将其当作直接输入流的一部分处理，在本例中，它为将命令传递给`bc`程序提供了一个简单的机制。这被称为编写*here文档*。在这种表示法中，紧跟在`<<`序列之后的内容将会匹配（独立成行），用以表示输入流的结束。在[清单
    1-20](ch01.xhtml#ch1ex20)中，它是`EOF`。
- en: This script also demonstrates how you can use arguments to make commands more
    flexible. Here, if the script is invoked with a `-p` flag ➊, it allows you to
    specify the desired precision of the output number. If no precision is specified,
    the program defaults to `scale=2` ➋.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本还展示了如何使用参数来使命令更加灵活。在这里，如果脚本调用时使用`-p`标志 ➊，它允许你指定输出数字的精度。如果未指定精度，程序默认`scale=2`
    ➋。
- en: When working with `bc`, it’s critical to understand the difference between `length`
    and `scale`. As far as `bc` is concerned, `length` refers to the total number
    of digits in the number, while `scale` is the total number of digits after the
    decimal point. Thus, 10.25 has a `length` of 4 and a `scale` of 2, while 3.14159
    has a `length` of 6 and a `scale` of 5.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`bc`时，了解`length`和`scale`之间的区别至关重要。就`bc`而言，`length`指的是数字中的总位数，而`scale`则是小数点后面的数字位数。因此，10.25的`length`为4，`scale`为2，而3.14159的`length`为6，`scale`为5。
- en: 'By default, `bc` has a variable value for `length`, but because it has a `scale`
    of zero, `bc` without any modifications works exactly as the `$(( ))` notation
    does. Fortunately, if you add a `scale` setting to `bc`, you find that there’s
    lots of hidden power under the hood, as shown in this example, which calculates
    how many weeks elapsed between 1962 and 2002 (excluding leap days):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`bc`的`length`值是可变的，但由于其`scale`为零，未做任何修改的`bc`与`$(( ))`表示法的功能完全相同。幸运的是，如果你为`bc`添加`scale`设置，你会发现它的潜力巨大，正如这个示例所示，计算了1962年到2002年（不包括闰日）之间经过了多少周：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To allow access to the `bc` capabilities from the command line, a wrapper script
    has to silence the opening copyright information, if present—though most `bc`
    implementations already silence the header if their input isn’t the terminal (`stdin`).
    The wrapper also sets the `scale` to a reasonable value, feeds in the actual expression
    to the `bc` program, and then exits with a `quit` command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许从命令行访问 `bc` 功能，包装脚本必须屏蔽开头的版权信息（如果有的话），尽管大多数 `bc` 实现已经在其输入不是终端（`stdin`）时屏蔽了该信息。包装脚本还会将
    `scale` 设置为一个合理的值，将实际的表达式传递给 `bc` 程序，然后通过 `quit` 命令退出。
- en: '***Running the Script***'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To run this script, feed a mathematical expression to the program as an argument
    as [Listing 1-21](ch01.xhtml#ch1ex21) shows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个脚本，将一个数学表达式作为参数传递给程序，如[清单 1-21](ch01.xhtml#ch1ex21)所示。
- en: '***The Results***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 1-21: Testing the* `*scriptbc*` *script*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-21：测试 `*scriptbc*` 脚本*'
- en: '**#10 Locking Files**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#10 锁定文件**'
- en: Any script that reads or appends to a shared file, such as a log file, needs
    a reliable way to lock files so that other instantiations of the script don’t
    accidentally overwrite data before it’s done being used. A common way to accomplish
    this is to create a separate *lock file* for each file being used. The existence
    of a lock file serves as a *semaphore*, an indicator that a file is being used
    by a different script and is not available. The requesting script then repeatedly
    waits and tries again until the semaphore lock file is removed, indicating that
    the file is free to edit.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 任何读取或追加到共享文件的脚本，比如日志文件，都需要一种可靠的方式来锁定文件，以防其他脚本实例在数据使用完之前不小心覆盖数据。一种常见的做法是为每个正在使用的文件创建一个单独的
    *锁文件*。锁文件的存在作为一个 *信号量*，表示文件正在被另一个脚本使用，无法访问。请求的脚本会反复等待并重试，直到信号量锁文件被移除，表明文件可以自由编辑。
- en: 'Lock files are tricky, though, because many seemingly foolproof solutions don’t
    actually work. For example, the following code is a typical approach to solving
    this problem:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，锁文件是棘手的，因为许多看似万无一失的解决方案实际上并不起作用。例如，以下代码是解决这个问题的典型方法：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Seems like it would work, doesn’t it? The code loops until the lock file doesn’t
    exist and then creates it to ensure that you own the lock and can therefore modify
    the base file safely. If another script with the same loop sees your lock, it
    will also spin until the lock file vanishes. However, this doesn’t work in practice.
    Imagine what would happen if, just after the `while` loop exited but before the
    `touch` was executed, this script was swapped out and put back in the processor
    queue, giving another script a chance to run.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像可以工作，对吧？这段代码会一直循环，直到锁文件不存在，然后创建它，以确保你拥有锁并且可以安全地修改基础文件。如果另一个具有相同循环的脚本看到你的锁文件，它也会一直循环，直到锁文件消失。然而，实际上这并不起作用。试想一下，如果在
    `while` 循环退出之后，但在执行 `touch` 命令之前，这个脚本被交换出去，并重新排入处理器队列，给另一个脚本运行的机会，会发生什么。
- en: In case you’re not sure what we’re referring to, remember that although your
    computer seems to be doing one thing at a time, it’s actually running multiple
    programs at the same time by doing a tiny bit with one, switching to another one,
    doing a tiny bit with that, and switching back. The problem here is that in the
    time between when your script finishes checking for a lock file and when it creates
    its own, the system might swap to another script, which could dutifully test for
    a lock file, find it absent, and create its own version. Then that script could
    swap out, and your script could swap back in to resume executing the `touch` command.
    The result would be that both scripts now think they have exclusive access to
    the lock file, which is exactly what we were trying to avoid.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定我们在说什么，记住，虽然你的计算机似乎一次只做一件事，但实际上它是在同时运行多个程序，通过在每个程序之间切换，每次只做一点点。这里的问题是，在脚本完成检查锁文件和创建自己锁文件之间的这段时间，系统可能会切换到另一个脚本，而这个脚本会照常检查锁文件，发现没有锁文件并创建自己的锁文件。然后该脚本可能会被切换出去，而你的脚本可能会恢复执行
    `touch` 命令。结果是两个脚本都认为它们独占了锁文件，而这正是我们想要避免的情况。
- en: Fortunately, Stephen van den Berg and Philip Guenther, authors of the `procmail`
    email-filtering program, also created a command line utility, `lockfile`, that
    lets you safely and reliably work with lock files in shell scripts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`procmail` 邮件过滤程序的作者 Stephen van den Berg 和 Philip Guenther 也创建了一个命令行工具
    `lockfile`，该工具可以让你在 shell 脚本中安全、可靠地操作锁文件。
- en: 'Many Unix distributions, including GNU/Linux and OS X, have `lockfile` already
    installed. You can check whether your system has `lockfile` simply by entering
    `man 1 lockfile`. If you get a man page, you’re in luck! The script in [Listing
    1-22](ch01.xhtml#ch1ex22) assumes that you have the `lockfile` command, and subsequent
    scripts require the reliable locking mechanism of [Script #10](ch01.xhtml#ch01lev1sec11)
    to function, so make sure the `lockfile` command is installed on your system.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '许多Unix发行版，包括GNU/Linux和OS X，都已预安装`lockfile`。你可以通过输入`man 1 lockfile`来检查你的系统是否有`lockfile`。如果显示了手册页，那就表示你的运气不错！[清单
    1-22](ch01.xhtml#ch1ex22)中的脚本假设你已经安装了`lockfile`命令，后续脚本需要[脚本 #10](ch01.xhtml#ch01lev1sec11)中可靠的锁机制来运行，因此请确保你的系统上已安装`lockfile`命令。'
- en: '***The Code***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 1-22: The* `*filelock*` *script*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-22：`*filelock*`脚本*'
- en: '***How It Works***'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: As is typical with a well-written shell script, half of [Listing 1-22](ch01.xhtml#ch1ex22)
    is parsing input variables and checking for error conditions. Finally, it gets
    to the `if` statement, and then it tries to actually use the system `lockfile`
    command. If there is one, it invokes it with a specified number of retries, generating
    its own error message if it does not finally succeed. What if you requested an
    unlock (for example, removal of an existing lock) and there is none? That generates
    another error. Otherwise, the `lockfile` is removed and you’re done.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如一个编写良好的Shell脚本通常会做的那样，[清单 1-22](ch01.xhtml#ch1ex22)的一半内容是解析输入变量并检查错误条件。最后，它到达了`if`语句，然后尝试实际使用系统的`lockfile`命令。如果有该命令，它会指定重试次数并调用它，如果最终失败，则生成自己的错误信息。如果你请求解锁（例如，移除现有的锁），但并没有锁定文件呢？这时会产生另一个错误。否则，`lockfile`将被移除，操作完成。
- en: 'More specifically, the first block ➊ uses the powerful `getopts` function to
    parse all the possible user input flags (`-l`, `-u`, `-r`) with a `while` loop.
    This is a common way to utilize `getopts`, which will occur again and again in
    the book. Note the shift `$(($OPTIND - 1 ))` statement at ➋: `OPTIND` is set by
    `getopts`, which lets the script keep shifting values down (so `$2` becomes `$1`,
    for example) until it is done processing those values with a leading dash.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，第一个代码块➊使用强大的`getopts`函数通过`while`循环解析所有可能的用户输入标志（`-l`，`-u`，`-r`）。这是利用`getopts`的常见方式，书中会多次出现这个模式。请注意第➋步的`shift
    $(($OPTIND - 1 ))`语句：`OPTIND`由`getopts`设置，它使得脚本能够不断将值向下移动（例如，`$2`变成`$1`），直到处理完带有破折号的这些值。
- en: Since this script utilizes the system `lockfile` utility, it’s good form to
    ensure the utility is in the user’s path before invoking it ➌, failing with an
    error message if that’s not the case. Then there’s a simple conditional at ➍ to
    see whether we’re locking or unlocking and the appropriate invocation to the `lockfile`
    utility in each case.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个脚本使用了系统的`lockfile`工具，因此在调用它之前确保该工具在用户的路径中是一个良好的做法。如果路径中没有该工具，它将显示错误信息。然后，在第➍步会有一个简单的条件判断，查看我们是在锁定还是解锁，并根据情况调用`lockfile`工具。
- en: '***Running the Script***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: While the `lockfile` script isn’t one you’d ordinarily use by itself, you can
    test it by having two terminal windows open. To create a lock, simply specify
    the name of the file you want to lock as an argument of `filelock`. To remove
    the lock, run the script again with the `-u` flag.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`lockfile`脚本不是你通常会单独使用的脚本，但你可以通过打开两个终端窗口来进行测试。要创建一个锁，只需将你想要锁定的文件名作为`filelock`的参数指定即可。要移除锁，再次运行脚本并添加`-u`标志。
- en: '***The Results***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: First, create a locked file as [Listing 1-23](ch01.xhtml#ch1ex23) shows.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照[清单 1-23](ch01.xhtml#ch1ex23)所示创建一个锁定的文件。
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Listing 1-23: Creating a file lock with the* `*filelock*` *command*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-23：使用`*filelock*`命令创建文件锁*'
- en: 'The second time you attempt to lock the file, `filelock` tries the default
    number of times (10) and then fails (shown in [Listing 1-24](ch01.xhtml#ch1ex24)):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第二次尝试锁定文件时，`filelock`会尝试默认的次数（10次），然后失败（如[清单 1-24](ch01.xhtml#ch1ex24)所示）：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 1-24: The* `*filelock*` *command failing to create a lock file*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-24：`*filelock*`命令未能创建锁文件*'
- en: When the first process is done with the file, you can release the lock, as [Listing
    1-25](ch01.xhtml#ch1ex25) details.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个进程完成文件操作后，你可以按照[清单 1-25](ch01.xhtml#ch1ex25)所示释放锁。
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Listing 1-25: Releasing a lock on a file with the* `*filelock*` *script*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-25：使用`*filelock*`脚本释放文件锁*'
- en: To see how the `filelock` script works with two terminals, run the unlock command
    in one window while the other is spinning, trying to establish its own exclusive
    lock.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`filelock`脚本如何在两个终端中工作，可以在一个窗口中运行解锁命令，而另一个窗口则持续运行，尝试建立它自己的独占锁。
- en: '***Hacking the Script***'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: Because this script relies on the existence of a lock file as proof that the
    lock is still enforced, it would be useful to have an additional parameter, say,
    the longest length of time for which a lock should be valid. If the `lockfile`
    routine times out, the last accessed time of the locked file could then be checked,
    and if the locked file is older than the value of this parameter, it can safely
    be deleted as a stray, perhaps with a warning message.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该脚本依赖于锁文件的存在来证明锁仍然有效，所以如果有一个附加参数，比如锁应该有效的最长时间长度会很有用。如果`lockfile`例程超时，则可以检查被锁定文件的最后访问时间，如果被锁定的文件比该参数值还要旧，那么它就可以安全地作为多余的文件删除，或许可以带上警告信息。
- en: This is unlikely to affect you, but `lockfile` doesn’t work with network filesystem
    (NFS) mounted networked drives. In fact, a reliable file-locking mechanism on
    an NFS-mounted disk is quite complex. A better strategy that sidesteps the problem
    entirely is to create lock files only on local disks or to use a network-aware
    script that can manage locks across multiple systems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这不太可能影响你，但`lockfile`不适用于网络文件系统（NFS）挂载的网络驱动器。实际上，NFS挂载磁盘上的可靠文件锁定机制相当复杂。一个完全避开这个问题的更好策略是只在本地磁盘上创建锁文件，或者使用一个可以跨多个系统管理锁的网络感知脚本。
- en: '**#11 ANSI Color Sequences**'
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#11 ANSI颜色序列**'
- en: Although you might not realize it, most terminal applications support different
    styles of presenting text. Quite a few variations are possible, whether you’d
    like to have certain words in your script displayed in boldface or even in red
    against a yellow background. However, working with *ANSI (American National Standards
    Institute)* sequences to represent these variations can be difficult because they’re
    quite user-unfriendly. To simplify them, [Listing 1-26](ch01.xhtml#ch1ex26) creates
    a set of variables whose values represent the ANSI codes, which can be used to
    toggle various color and formatting options on and off.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能没有意识到，大多数终端应用程序都支持不同风格的文本呈现。无论你是希望在脚本中将某些单词显示为粗体，还是希望将它们显示为红色配黄色背景，都是可能的。然而，使用*ANSI（美国国家标准协会）*序列来表示这些变化可能会很困难，因为它们相当不友好。为了简化它们，[清单1-26](ch01.xhtml#ch1ex26)创建了一组变量，这些变量的值表示ANSI代码，可以用于开关各种颜色和格式选项。
- en: '***The Code***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 1-26: The* `*initializeANSI*` *script function*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-26：*`*initializeANSI*`*脚本函数*'
- en: '***How It Works***'
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***它是如何工作的***'
- en: 'If you’re used to HTML, you might be baffled by the way these sequences work.
    In HTML, you open and close modifiers in opposite order, and you must close every
    modifier you open. Thus, to create an italicized passage within a sentence displayed
    in bold, you’d use the following HTML:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯了HTML，可能会对这些序列的工作方式感到困惑。在HTML中，你需要以相反的顺序打开和关闭修饰符，并且你必须关闭每个打开的修饰符。因此，要在一个句子中创建一个斜体部分并显示为粗体，你将使用以下HTML代码：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Closing the bold tag without closing the italics wreaks havoc and can mess
    up some web browsers. But with the ANSI color sequences, some modifiers actually
    override the previous ones, and there is also a reset sequence that closes all
    modifiers. With ANSI sequences, you must make sure to output the reset sequence
    after using colors and to use the `off` feature for anything you turn `on`. Using
    the variable definitions in this script, you would rewrite the previous sequence
    like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有关闭斜体标签的情况下关闭粗体标签会引发混乱，并可能会搞乱一些网页浏览器。但对于ANSI颜色序列，一些修饰符实际上会覆盖前一个修饰符，并且还有一个重置序列，它会关闭所有修饰符。使用ANSI序列时，你必须确保在使用颜色后输出重置序列，并且对任何你打开的功能使用`off`选项。使用此脚本中的变量定义，你可以像这样重写前面的序列：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***Running the Script***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'To run this script, first call the initialization function and then output
    a few `echo` statements with different combinations of color and type effect:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，首先调用初始化函数，然后输出一些带有不同颜色和效果组合的`echo`语句：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***The Results***'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: The results in [Listing 1-27](ch01.xhtml#ch1ex27) don’t look too thrilling in
    this book, but on a display that supports these color sequences, they definitely
    catch your attention.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单1-27](ch01.xhtml#ch1ex27)中的结果在本书中看起来并不太惊艳，但在支持这些颜色序列的显示器上，它们肯定会引起你的注意。'
- en: '[PRE50]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 1-27: The text that would be printed if the script in [Listing 1-26](ch01.xhtml#ch1ex26)
    were run*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-27：如果运行 [清单 1-26](ch01.xhtml#ch1ex26) 中的脚本，打印出的文本*'
- en: '***Hacking the Script***'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解脚本***'
- en: 'When using this script, you may see output like the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此脚本时，你可能会看到如下输出：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you do, the problem might be that your terminal or window doesn’t support
    ANSI color sequences or that it doesn’t understand the `\033` notation for the
    all-important `esc` variable. To remedy the latter problem, open up the script
    in `vi` or your favorite terminal editor, delete the `\033` sequence, and replace
    it by entering a `^V` (CTRL-V) keystroke followed by an ESC key press, which should
    show up as `^[`. If the results on screen look like `esc="^["`, all should work
    fine.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这么做了，问题可能出在你的终端或窗口不支持 ANSI 颜色序列，或者它不理解重要的 `esc` 变量的 `\033` 符号。要解决后者的问题，打开脚本文件，使用
    `vi` 或你喜欢的终端编辑器，删除 `\033` 序列，并通过按下 `^V`（CTRL-V）键，再按下 ESC 键，这应该会显示为 `^[`。如果屏幕上显示
    `esc="^[`，一切应该正常。
- en: If, on the other hand, your terminal or window doesn’t support ANSI sequences
    at all, you might want to upgrade so that you can add colorized and typeface-enhanced
    output to your other scripts. But before you ditch your current terminal, check
    your terminal’s preferences—some have a setting you can enable for full ANSI support.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的终端或窗口根本不支持 ANSI 序列，你可能需要升级，以便能够为你的其他脚本添加彩色和增强的字体输出。但在放弃当前终端之前，请检查终端的偏好设置—某些终端有一个可以启用完全
    ANSI 支持的设置。
- en: '**#12 Building a Shell Script Library**'
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#12 构建一个 Shell 脚本库**'
- en: Many of the scripts in this chapter have been written as functions rather than
    as stand-alone scripts so that they can be easily incorporated into other scripts
    without incurring the overhead of making system calls. While there’s no `#include`
    feature in a shell script as there is in C, there is a tremendously important
    capability called *sourcing* a file that serves the same purpose, allowing you
    to include other scripts as though they are library functions.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多脚本都是作为函数编写的，而不是独立脚本，这样它们可以轻松地集成到其他脚本中，而不会增加系统调用的开销。虽然 shell 脚本中没有像 C 语言中的
    `#include` 功能，但有一个非常重要的功能叫做 *source* 文件，它起到相同的作用，允许你像包含库函数一样包含其他脚本。
- en: 'To see why this is important, let’s consider the alternative. If you invoke
    a shell script within a shell, by default that script is run within its own subshell.
    You can see this experimentally here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这为什么很重要，我们来考虑一下另一种情况。如果你在一个 shell 中调用一个 shell 脚本，默认情况下，该脚本会在它自己的子 shell
    中运行。你可以通过实验来验证这一点：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The script *tinyscript.sh* changed the value of the variable `test`, but only
    within the subshell running the script, so the value of the existing `test` variable
    in our shell’s environment was not affected. If instead you run the script using
    the dot (`.`) notation to source the script, then it is handled as though each
    command in the script were typed directly into the current shell:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本*tinyscript.sh*修改了变量`test`的值，但只是在运行该脚本的子 shell 中，所以我们 shell 环境中现有的`test`变量的值没有受到影响。如果你改用点（`.`）符号来运行脚本，这样就相当于每个脚本中的命令直接输入到当前的
    shell 中：
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you might expect, if you source a script that has an `exit 0` command, it
    will exit the shell and log out of the window, because the `source` operation
    makes the sourced script the primary running process. If you had a script running
    in a subshell, it would exit without the main script stopping. That’s a major
    difference and one reason to opt for sourcing scripts with `.` or `source` or
    (as we’ll explain later) `exec`. The `.` notation is actually identical to the
    `source` command in bash; we’re using `.` because it’s more portable across different
    POSIX shells.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，如果你 source 一个包含 `exit 0` 命令的脚本，它将退出 shell 并注销窗口，因为 `source` 操作使得被
    source 的脚本成为主要运行进程。如果你有一个在子 shell 中运行的脚本，它会退出，但不会影响主脚本的执行。这是一个重要的区别，也是选择使用 `.`
    或 `source` 或（如我们稍后会解释的）`exec` 来 source 脚本的原因之一。`.` 符号实际上与 bash 中的 `source` 命令是相同的；我们使用
    `.` 是因为它在不同的 POSIX shell 中更具可移植性。
- en: '***The Code***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: To turn the functions in this chapter into a library for use in other scripts,
    extract all the functions and any needed global variables or arrays (that is,
    values that are common across multiple functions) and concatenate them into one
    big file. If you call this file *library.sh*, you can use the following test script
    to access all the functions we’ve written in this chapter and see whether they’re
    working properly, as [Listing 1-28](ch01.xhtml#ch1ex28) shows.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要将本章中的函数转换为可在其他脚本中使用的库，请提取所有函数以及任何需要的全局变量或数组（即跨多个函数共享的值），并将它们合并为一个大文件。如果你将此文件命名为*library.sh*，你可以使用以下测试脚本访问我们在本章中编写的所有函数，并查看它们是否正常工作，如[列表
    1-28](ch01.xhtml#ch1ex28)所示。
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 1-28: Sourcing the previously implemented functions as a single library
    and calling them*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-28：将先前实现的函数作为单个库源代码并调用它们*'
- en: '***How It Works***'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: Notice that the library is incorporated and all functions are read and included
    in the runtime environment of the script, with the single line at ➊.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，库文件已被引入，所有函数都会被读取并包含到脚本的运行时环境中，在➊的单行代码处。
- en: This useful approach for working with many scripts in this book can be exploited
    again and again as needed. Just make sure that the library file you’re including
    is accessible from your `PATH` so that the `.` command can find it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理本书中多个脚本的有用方法可以根据需要反复利用。只要确保你包含的库文件可以从`PATH`中访问，这样`.`命令就能找到它。
- en: '***Running the Script***'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: To run the test script, invoke it from the command line as you would any other,
    just like in [Listing 1-29](ch01.xhtml#ch1ex29).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试脚本，只需像运行任何其他脚本一样从命令行调用它，就像在[列表 1-29](ch01.xhtml#ch1ex29)中所示。
- en: '***The Results***'
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Listing 1-29: Running the* `*library-test*` *script*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-29：运行* `*library-test*` *脚本*'
- en: On your screen, the error messages for a value that is too large will be in
    bold. Also, the correct guess of a leap year will be displayed in green.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的屏幕上，值过大时的错误信息会以粗体显示。此外，正确的闰年猜测将以绿色显示。
- en: Historically, 432 wasn’t a leap year because leap years didn’t start appearing
    in the calendar until 1752\. But we’re talking about shell scripts, not calendar
    hacks, so we’ll let this slide.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，432年不是闰年，因为闰年直到1752年才出现在日历中。但是我们现在讨论的是 Shell 脚本，而不是日历技巧，所以我们就不再纠结这个问题。
- en: '**#13 Debugging Shell Scripts**'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**#13 调试 Shell 脚本**'
- en: Although this section doesn’t contain a true script per se, we want to spend
    a few pages talking about some basics of debugging shell scripts, because it’s
    a sure bet that bugs are always going to creep in!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节没有包含真正的脚本，但我们仍然想花几页时间讨论一些调试 Shell 脚本的基础知识，因为bug总是不可避免地会出现！
- en: 'In our experience, the best debugging strategy is to build scripts incrementally.
    Some script programmers have a high degree of optimism that everything will work
    right the first time, but starting small can really help move things along. Additionally,
    you should make liberal use of `echo` statements to track variables and invoke
    your scripts explicitly using `bash -x` to display debugging output, like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，最佳的调试策略是逐步构建脚本。一些脚本程序员对第一次就能正确运行充满乐观，但从小处开始确实能帮助推进进程。此外，你应该大量使用`echo`语句来追踪变量，并明确调用你的脚本，使用`bash
    -x`来显示调试输出，如下所示：
- en: '[PRE56]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, you can run `set -x` beforehand to enable debugging and `set
    +x` afterward to stop it, as shown here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以提前运行`set -x`来启用调试，运行结束后使用`set +x`来停止调试，如此处所示：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To see the `-x` and `+x` sequences in action, let’s debug a simple number-guessing
    game, shown in [Listing 1-30](ch01.xhtml#ch1ex30).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`-x`和`+x`的效果，我们来调试一个简单的数字猜测游戏，如[列表 1-30](ch01.xhtml#ch1ex30)所示。
- en: '***The Code***'
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***代码***'
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 1-30: The* `*hilow*` *script, which may contain a few errors in need
    of debugging ...*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-30：`*hilow*` 脚本，可能包含一些需要调试的错误...*'
- en: '***How It Works***'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作原理***'
- en: To understand how the random number portion at ➊ works, keep in mind that the
    sequence `$$` is the processor ID (PID) of the shell that runs the script, typically
    a 5- or 6-digit value. Each time you run the script, it gets a different PID.
    The `% $biggest` sequence then divides the PID value by the specified biggest
    acceptable value and returns the remainder. In other words, `5 % 4 = 1`, as does
    `41 % 4`. It’s an easy way to produce a semi-random number between 1 and `$biggest`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解在 ➊处的随机数部分如何工作，请记住，序列 `$$` 是运行脚本的 Shell 的处理器 ID（PID），通常是一个 5 位或 6 位的数字值。每次运行脚本时，它都会得到一个不同的
    PID。`% $biggest`序列将 PID 值除以指定的最大可接受值并返回余数。换句话说，`5 % 4 = 1`，`41 % 4`也等于 1。这是一种生成
    1 到 `$biggest`之间的半随机数的简单方法。
- en: '***Running the Script***'
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***运行脚本***'
- en: 'The first step in debugging this game is to test and ensure that the number
    generated will be sufficiently random. To do this, we take the PID of the shell
    in which the script is run, using the `$$` notation, and reduce it to a usable
    range using the `%` mod function ➊. To test the function, enter the commands into
    the shell directly, as shown here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 调试这个游戏的第一步是测试并确保生成的数字足够随机。为此，我们获取运行脚本的 Shell 的 PID，使用`$$`表示法，并通过 `%` 模运算函数 ➊
    将其缩小到一个可用的范围。要测试此函数，请将命令直接输入到 Shell 中，如下所示：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This worked, but it’s not very random. A moment’s thought reveals why: when
    the command is run directly on the command line, the PID is always the same; but
    when run in a script, the command is in a different subshell each time, so the
    PID varies.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这样是可行的，但它并不算真正的随机。稍微思考一下就能发现原因：当命令直接在命令行上运行时，PID 总是相同的；但当它在脚本中运行时，每次都会在不同的子
    Shell 中运行，因此 PID 会有所不同。
- en: Another way to generate a random number is by referencing the environment variable
    `$RANDOM`. It’s magic! Each time you reference it, you get a different value.
    To generate a number between 1 and `$biggest`, you’d use `$(( $RANDOM % $biggest
    + 1 ))` at ➊.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的另一种方式是通过引用环境变量`$RANDOM`。它就像魔法一样！每次引用它，你都会得到不同的值。要生成一个在 1 到`$biggest`之间的随机数，你可以在
    ➊处使用`$(( $RANDOM % $biggest + 1 ))`。
- en: 'The next step is to add the basic logic of the game. A random number between
    1 and 100 is generated ➊; the player makes guesses ➋; and after each guess, the
    player is told whether the guess is too high ➌ or too low ➍, until they finally
    guess the correct value. After entering all the basic code, it’s time to run the
    script and see how it goes. Here we use [Listing 1-30](ch01.xhtml#ch1ex30), warts
    and all:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加游戏的基本逻辑。首先生成一个 1 到 100 之间的随机数 ➊；玩家进行猜测 ➋；每次猜测后，玩家会被告知猜测是太大 ➌ 还是太小 ➍，直到他们最终猜中正确的值。在输入完所有基本代码后，接下来就是运行脚本，看看效果如何。这里我们使用了[清单
    1-30](ch01.xhtml#ch1ex30)，包括所有瑕疵：
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Ugh, the bane of shell script developers: an unexpected end of file (EOF).
    Just because the message says the error is on line 19 doesn’t mean it’s actually
    there. In fact, line 19 is perfectly fine:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 呃，Shell 脚本开发者的噩梦：意外的文件结尾（EOF）。仅仅因为错误信息提示错误出现在第19行，并不意味着问题真的是出在这一行。实际上，第19行是完全正常的：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To understand what’s going on, remember that quoted passages can contain newlines.
    This means that when the shell hits a quoted passage that we haven’t closed properly,
    it will just keep reading down the script looking for matching quotes, only stopping
    when it hits the very last quote and realizes something is amiss.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么，记住引号中的内容可以包含换行符。这意味着当 Shell 遇到一个未正确关闭的引号时，它会一直读取脚本，寻找匹配的引号，直到最后一个引号，才会意识到有什么地方不对劲。
- en: 'The problem, therefore, must come earlier in the script. The only really useful
    thing about the error message from the shell is that it tells you which character
    is mismatched, so we can `grep` to try to extract all lines that have a quote
    and then filter out the ones that have two quotes, as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题可能出现在脚本的早期部分。Shell 返回的错误信息中唯一真正有用的内容是它告诉你哪个字符不匹配，因此我们可以使用 `grep` 来提取所有包含引号的行，并过滤掉那些包含两个引号的行，如下所示：
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'That’s it! The closing quote is missing on the line that tells the user they
    must guess a smaller number ➍. We’ll add the missing quote at the end of the line
    and try again:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！缺少了一个闭合引号，具体是在告知用户必须猜更小数字的那一行 ➍。我们将缺失的引号加到行尾，然后再试一次：
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Nope. Another problem. Because there are so few parenthesized expressions in
    the script, we can just eyeball this problem and see that the closing parenthesis
    of the random number instantiation was mistakenly truncated:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 不行。又有问题了。因为脚本中括号表达式非常少，所以我们可以直接通过目测发现随机数实例化的闭合括号被错误地截断了：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can fix this by adding the closing parenthesis to the end of the line but
    before the code comment. Does the game work now? Let’s find out:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在行尾加上右括号来修复这个问题，但要放在代码注释之前。现在游戏是否能正常运行了呢？让我们来看看：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Almost. But because 100 is the maximum possible value, there seems to be an
    error in the code’s logic. These errors are particularly tricky because there’s
    no fancy `grep` or `sed` invocation to identify the problem. Look back at the
    code and see if you can identify what’s going wrong.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎解决了。但因为100是最大可能值，似乎代码的逻辑有问题。这些错误特别棘手，因为没有 fancy 的`grep`或`sed`命令来帮助定位问题。回顾一下代码，看看你能不能找出问题所在。
- en: 'To debug this, we can add a few `echo` statements to output the user’s chosen
    number and verify that what was entered is what’s being tested. The relevant section
    of code starts at ➋, but we’ve reprinted the lines here for convenience:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试这个问题，我们可以添加几个`echo`语句来输出用户选择的数字，并验证输入的内容是否与被测试的内容一致。相关的代码部分从➋开始，但我们在这里为了方便重新打印了这些行：
- en: '[PRE66]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In fact, as we modified the `echo` statement and looked at these two lines,
    we realized the error: the variable being read is `answer`, but the variable being
    tested is called `guess`. A boneheaded error, but not an uncommon one (particularly
    if you have oddly spelled variable names). To fix this, we should change `read
    answer` to `read guess`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当我们修改了`echo`语句并查看这两行时，我们意识到了错误：读取的变量是`answer`，但被测试的变量叫做`guess`。这是个明显的错误，但并不罕见（尤其是当你使用奇怪的变量名时）。要修复这个问题，我们应该把`read
    answer`改成`read guess`。
- en: '***The Results***'
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: Finally, it works as expected, shown in [Listing 1-31](ch01.xhtml#ch1ex31).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，它按预期工作了，如[示例 1-31](ch01.xhtml#ch1ex31)所示。
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '*Listing 1-31: The* `*hilow*` *shell script game working in all its glory*'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-31：* `*hilow*` *shell 脚本游戏的完整运行*'
- en: '***Hacking the Script***'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***脚本调试***'
- en: 'The most grievous bug lurking in this little script is that it doesn’t validate
    input. Enter anything at all other than an integer and the script sputters and
    fails. Including a rudimentary test could be as easy as adding the following lines
    of code inside the `while` loop:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小脚本中最严重的错误是它没有验证输入。输入任何非整数的内容，脚本就会卡住并失败。包含一个基本的测试，最简单的方式是将以下代码行添加到`while`循环中：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Problem is, confirming that it’s a nonzero input doesn’t mean it’s a number,
    and you can generate errors from the test command with an input like `hi`. To
    fix the problem, add a call to the `validint` function from [Script #5](ch01.xhtml#ch01lev1sec06)
    on [page 23](ch01.xhtml#page_23).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，确认它是一个非零输入并不意味着它是一个数字，像输入`hi`这样的内容会导致`test`命令出错。为了解决这个问题，可以在[第5章脚本](ch01.xhtml#ch01lev1sec06)中调用`validint`函数，见[第23页](ch01.xhtml#page_23)。
