["```\n// [Listing13-1](#listinganchor13-1).ino\n//\n// A simple program that demonstrates\n// MCP23017 programming.\n//\n// This program writes a value to port B, reads\n// a value from port A, and verifies that the\n// value sent to port B was properly read on port A.\n\n#include <Wire.h>\n#define mcp23017    (0x20)\n // MCP23017 registers:\n\n#define IODIRA (0)\n#define IOCON  (0x0A)\n#define GPPUA  (0x0C)\n#define GPIOA  (0x12)\n#define OLATB  (0x15)\n\nvoid setup( void )\n{\n\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"Test reading and writing MCP23017\" );\n\n    Wire.begin(); // Initialize I2C library\n\n    // Initialize the MCP23017:\n    //\n    // - Sequential port A/B registers (BANK = 0)\n    // - Don't mirror INT pins (MIRROR = 0)\n    // - Autoincrement register numbers (SEQOP = 0)\n    // - Slew rate control on (DISSLW = 0)\n    // - ODR in open-drain mode (ODR = 1)\n    // - Interrupt polarity is active low (INTP = 0)\n\n    #define initIOCON (4)   // ODR = 1\n\n    Wire.beginTransmission( mcp23017 );\n    Wire.write( IOCON );\n    Wire.write( initIOCON );\n    Wire.endTransmission(); // Sends stop condition\n\n    // Set port A to input, port B to output,\n    // and polarity noninverting.\n\n    Wire.beginTransmission( mcp23017 );\n    Wire.write( IODIRA );\n    Wire.write( 0xff );     // Port A = inputs\n    Wire.write( 0 );        // Port B = outputs\n    Wire.write( 0 );        // Port A noninverting\n    Wire.endTransmission(); // Sends stop condition\n\n    // Disable pullup resistors on port A.\n\n    Wire.beginTransmission( mcp23017 );\n    Wire.write( GPPUA );\n    Wire.write( 0 );        // Port A = no pullups\n    Wire.endTransmission(); // Sends stop condition\n\n}\n\nvoid loop( void )\n{\n    static byte outputValue   = 0;\n    static byte expectedValue = 0;\n\n    ++outputValue;\n\n    // You simplified the wiring and connected\n    // GPB0 to GPA7, GPB1 to GPA6, ..., GPB7 to GPA0.\n    // So you need to reverse the bits in the\n    // expected value.\n\n    expectedValue =   ((outputValue & 0x01) << 7)\n                    | ((outputValue & 0x02) << 5)\n                    | ((outputValue & 0x04) << 3)\n                    | ((outputValue & 0x08) << 1)\n                    | ((outputValue & 0x10) >> 1)\n                    | ((outputValue & 0x20) >> 3)\n                    | ((outputValue & 0x40) >> 5)\n                    | ((outputValue & 0x80) >> 7);\n\n    // Write the byte to the output (port B).\n\n    Wire.beginTransmission( mcp23017 );\n    Wire.write( OLATB );\n    Wire.write( outputValue );\n    Wire.endTransmission(); // Sends stop condition\n\n    // Read a byte from the input (port A).\n\n    Wire.beginTransmission( mcp23017 );\n    Wire.write( GPIOA );                // Send register address\n    Wire.endTransmission( false );      // No stop condition\n\n    Wire.requestFrom( mcp23017, 1 );    // Read from portA\n    while( !Wire.available() ){}        // Wait for byte\n\n    byte b = Wire.read();               // Get input byte\n\n    if( b != expectedValue)\n    {\n        Serial.print\n        ( \n            \"Error writing and reading MCP23017, value=0x\" \n        );\n        Serial.print( b, 16 );\n        Serial.print( \", output 0x\" );\n        Serial.print( outputValue, 16 );\n        Serial.print( \", expected 0x\" );\n        Serial.println( expectedValue, 16 );\n    }\n    else\n{\n        static uint32_t count = 0;\n\n        if( ++count & 0x3f )\n Serial.print( \".\" );\n        else\n            Serial.println( \".\" );\n    }\n}\n```", "```\n    attachInterrupt( digitalPinToInterrupt( `pin` ), `ISR`, `mode` );\n    ```", "```\n// [Listing13-2](#listinganchor13-2).ino\n//\n// Demonstrate reading a rotary encoder\n// using an MCP23008 with interrupts.\n//\n// Assumptions:\n//\n// - MCP23008 INT line connected to\n//   digital I/O line 2.\n//\n// - SparkFun illuminated R/G rotary\n//   encoder output A connected to\n//   GP1 on MCP23008.\n//\n// - SparkFun illuminated R/G rotary\n//   encoder output B connected to\n//   GP0 on MCP23008.\n//\n// - MCP23008 wired to use address\n//   0x20 (A0, A1, A2 = 0, 0 0).\n\n#include <Wire.h>\n\n#define led         (13)\n#define mcp23008    (0x20)\n\n#define IODIR       (0)\n#define IOPOL       (1)\n#define GPINTEN     (2)\n#define DEFVAL      (3)\n#define INTCON      (4)\n#define IOCON       (5)\n#define GPPU        (6)\n#define INTF        (7)\n#define INTCAP      (8)\n#define GPIO        (9)\n#define OLAT        (10)\n\n// The following variable tracks\n// rotations on the rotary encoder.\n// This variable is negative if there\n// have been more clockwise rotations\n// than counterclockwise (likewise,\n// it's positive if there have been\n// more counterclockwise rotations).\n\nvolatile int rotaryPosn = 0;\n\n// Write a value to an MCP23008 register:\n\n❶ void writeReg( int reg, int val )\n{\n    Wire.beginTransmission( mcp23008 );\n    Wire.write( reg );\n    Wire.write( val );\n    Wire.endTransmission();\n}\n\n// Read a value from an MCP23008 register:\n\n❷ int readReg( int reg )\n{\n    Wire.beginTransmission( mcp23008 );\n    Wire.write( reg );\n    Wire.endTransmission( false );\n    Wire.requestFrom( mcp23008, 1 );\n    return Wire.read();\n}\n\n// Reset the MCP23008 to a known state:\n\n❸ void mcpReset( void )\n{\n    // I2C General Call is not mentioned in\n    // the manual so do this the hard way.\n\n    // INTF   is read only.\n    // INTCAP is read only.\n\n    // Disable interrupts\n    // and clear any pending.\n\n    writeReg( GPINTEN, 0 );\n    readReg( INTCAP );\n\n    // Set remaining registers\n    // to POR/RST values.\n\n    writeReg( IODIR,   0xFF );\n    writeReg( IOPOL,   0 );\n    writeReg( GPINTEN, 0 );\n    writeReg( DEFVAL,  0 );\n    writeReg( INTCON,  0 );\n    writeReg( IOCON,   0 );\n    writeReg( GPPU,    0 );\n    writeReg( GPIO,    0 );\n    writeReg( OLAT,    0 );\n}\n\n// Interrupt service routine that gets\n// called whenever the INT pin on the\n// MCP23008 goes from high to low.\n// This function needs to be *fast*.\n// That means minimizing the number\n// of I2C transactions.\n\n❹ void ISRFunc( void )\n\n{\n    // Read the INTCAP register.\n    // This reads the GPIO pins at\n    // the time of the interrupt and\n    // also clears the interrupt flags.\n    //\n    // Note: A rotary encoder input in GPA1,\n    // B rotary encoder input in GPA0.\n\n    int cur = readReg( INTCAP ) & 0x3;\n\n    // You have CCW rotation if:\n    //\n    //      A:0->1 && B==1  (cur=3)\n    // or   A:1->0 && B==0  (cur=0)\n\n    if( cur == 0 || cur == 3 )\n    {\n        ++rotaryPosn;\n    }\n    else if( cur == 1 || cur == 2 )\n    {\n        --rotaryPosn;   // CW rotation\n    }\n    // else illegal reading . . .\n}\n\n// Usual Arduino initialization code:\n\n❺ void setup( void )\n{\n    Serial.begin( 9600 );\n    delay( 1000 );\n    Serial.println( \"Rotary Encoder test\" );\n\n    pinMode( 0, INPUT_PULLUP );\n    pinMode( 1, INPUT_PULLUP );\n    pinMode( 2, INPUT );\n    pinMode( led, OUTPUT );\n    digitalWrite( led, 0 );\n\n    Wire.begin();\n\n    // Reset the MCP23008 to a known state.\n\n    mcpReset();\n\n    // Initialize the MCP23008 (this is the default\n // state, so just defensive coding). Note that\n    // SEQOP = 0 is autoincrementing registers and\n    // INTPOL = 0 yields active low interrupts.\n\n    writeReg( IOCON, 0 );\n\n    // Set data direction to input and\n    // turn pullups on for GPA0/GPA1.\n    // Set polarity to inverting for GPA0/GPA1.\n\n    writeReg( IODIR, 0xff );\n    writeReg( IOPOL, 3 );\n    writeReg( GPPU, 3 );\n\n    // Initialize MCP23008 interrupts.\n\n    writeReg( INTCON, 0 );      // GPA1 int on change\n    writeReg( GPINTEN, 0x2 );   // Enable GPA1 interrupt\n\n    attachInterrupt( digitalPinToInterrupt(2), ISRFunc, FALLING );\n    interrupts();               // Ensure CPU interrupts enabled\n}\n\n// Main Arduino loop:\n\n❻ void loop( void )\n{\n    static int lastRP = 0;\n\n    if( rotaryPosn != lastRP )\n    {\n        Serial.print( \"Posn=\" ); Serial.println( rotaryPosn );\n        lastRP = rotaryPosn;\n    }\n}\n```", "```\nPosn=0\nPosn=-1\nPosn=-2\nPosn=-3\nPosn=-4\nPosn=-5\nPosn=-6\nPosn=-7\nPosn=-8\nPosn=-7\nPosn=-6\nPosn=-5\nPosn=-4\nPosn=-3\nPosn=-2\nPosn=-1\nPosn=0\nPosn=1\nPosn=2\nPosn=3\nPosn=4\n```"]