- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    STATE MACHINE</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">状态机</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: A *state machine* is a model for controlling a sequence of actions. In a state
    machine, a task is broken down into a series of stages, or *states*. The system
    flows through these states along prescribed routes, transitioning from one state
    to another based on inputs or other triggers. State machines are widely used to
    organize the operations in an FPGA, so understanding how they work is crucial
    to developing sophisticated FPGA designs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态机* 是一种控制一系列动作的模型。在状态机中，一项任务被分解成一系列的阶段，或*状态*。系统沿着预定的路径在这些状态之间流动，根据输入或其他触发条件从一个状态转换到另一个状态。状态机被广泛用于组织FPGA中的操作，因此理解它们的工作原理对于开发复杂的FPGA设计至关重要。'
- en: Some common examples of state machines control behaviors in elevators, traffic
    lights, and vending machines. Each of these devices can only be in one unique
    state at any given time and can perform different actions as a result of inputs.
    In the case of an elevator, for example, the elevator car remains on its current
    floor until someone pushes a button to request a ride. The floor that the elevator
    is on is its state, and pushing a button is the input that triggers a change in
    that state. In the case of a traffic light, the possible states are red, yellow,
    and green, and the light changes based on some kind of input—perhaps a timer or
    a motion sensor. Certain transitions are possible, such as going from red to green
    or from yellow to red, while other transitions, such as yellow to green, are not.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机的常见示例包括电梯、交通信号灯和自动售货机。这些设备在任何给定时刻只能处于一个独特的状态，并且可以根据输入执行不同的动作。例如，在电梯的情况下，电梯厢会停留在当前楼层，直到有人按下按钮请求乘坐。电梯所在的楼层就是它的状态，而按下按钮就是触发状态变化的输入。交通信号灯的情况也是类似，可能的状态有红色、黄色和绿色，信号灯会根据某种输入变化——可能是定时器或运动传感器。某些状态转换是可能的，例如从红色到绿色，或者从黄色到红色，而其他转换，比如从黄色到绿色，则不可能。
- en: Within an FPGA, you might have several state machines performing different independent
    tasks, all running simultaneously. You might have one state machine that initializes
    an LPDDR memory, another that receives data from an external sensor, and a third
    for communicating with an external microcontroller, for example. And since an
    FPGA is a parallel device, these state machines will all be running in parallel,
    with each state machine coordinating its own complicated series of actions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在FPGA中，可能有多个状态机执行不同的独立任务，所有任务同时运行。例如，你可能有一个状态机初始化LPDDR内存，另一个接收来自外部传感器的数据，第三个用于与外部微控制器通信。由于FPGA是并行设备，这些状态机会并行运行，每个状态机协调其自己的复杂操作序列。
- en: In this chapter, you’ll learn the basic concepts behind state machines and see
    how to design them with Verilog and VHDL. You’ll learn strategies for keeping
    your state machines clear and concise, which reduces the likelihood of bugs in
    your designs. Finally, you’ll gain hands-on experience with state machines by
    designing a Simon-style memory game for your development board.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将学习状态机背后的基本概念，并了解如何使用Verilog和VHDL设计它们。你将学习保持状态机简洁清晰的策略，从而减少设计中出现bug的可能性。最后，你将通过设计一个Simon风格的记忆游戏来获得使用状态机的实践经验，适用于你的开发板。
- en: <samp class="SANS_Futura_Std_Bold_B_11">States, Transitions, and Events</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">状态、转换与事件</samp>
- en: 'State machines revolve around three interrelated concepts: states, transitions,
    and events. A *state* describes the status of a system when it’s waiting to execute
    a transition. Going back to the elevator example, if a button is never pressed,
    the elevator will simply remain in its current state; that is, waiting on its
    current floor. A state machine can only ever be in one state at a time (an elevator
    can’t be on two floors at once), and there are only so many possible states that
    it can be in (we haven’t yet figured out how to build a building with an infinite
    number of floors). For this reason, state machines are also called *finite state
    machines (FSMs)*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机围绕三个相互关联的概念展开：状态、转换和事件。*状态*描述的是系统在等待执行转换时的状态。以电梯为例，如果从未按下按钮，电梯将保持在当前状态，也就是停留在当前楼层。状态机一次只能处于一个状态（电梯不能同时在两个楼层），而且它只能处于有限数量的状态（我们还没有解决如何建造一个具有无限楼层的建筑的问题）。因此，状态机也被称为*有限状态机（FSMs）*。
- en: A *transition* is the action of moving from one state to another. For an elevator,
    that would include opening and closing the doors, running a motor to raise or
    lower the car, and so on. Transitions are usually caused by *events*, which can
    include inputs like a button press or a timer expiring. Transitions between states
    can also occur without an external event, which would be an internal transition.
    The same event might trigger a different transition, depending on the current
    state of the state machine. For example, pushing the 5 button will make an elevator
    go down if it’s on the tenth floor, or go up if it’s on the first floor. The elevator’s
    next state is influenced by both its current state and the input event.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换*是指从一个状态移动到另一个状态的动作。对于电梯来说，这包括开关门、运行电机升降轿厢等。转换通常由*事件*引起，事件可以是按键或计时器到期等输入。状态之间的转换也可能在没有外部事件的情况下发生，这称为内部转换。相同的事件可能根据当前状态触发不同的转换。例如，如果电梯在十楼，按下5号按钮会让电梯向下行驶；如果电梯在一楼，按下5号按钮则会让电梯向上行驶。电梯的下一个状态受到当前状态和输入事件的共同影响。'
- en: Designing a state machine entails determining all the possible states, planning
    out the transitions between the states, and identifying the events that can trigger
    those transitions. The easiest way to do this is to draw a diagram. To demonstrate,
    let’s explore an example of a simple state machine, one that controls a coin-operated
    turnstile like you might use to enter a subway station. [Figure 8-1](#fig8-1)
    shows a diagram of this state machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设计状态机需要确定所有可能的状态，规划状态之间的转换，并识别可以触发这些转换的事件。最简单的方法是绘制一个图表。为了演示这一点，让我们探讨一个简单的状态机例子，它控制着一个硬币投币的旋转门，类似于你在地铁站入口处可能会使用的设备。[图
    8-1](#fig8-1)展示了这个状态机的图示。
- en: '![](../images/Figure8-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: A state machine
    for a turnstile</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-1：一个旋转门的状态机</samp>
- en: 'In a state machine diagram, states are traditionally represented as labeled
    circles, transitions are represented as arrows between circles, and events are
    represented as text alongside the transitions they trigger. Our turnstile state
    machine has two possible states: Locked and Unlocked. The black dot beneath the
    Locked state indicates that Locked is the *initial state* of the machine. This
    is where the state machine will go when power is first applied, or if the user
    hits a reset button.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态机图中，状态通常用带标签的圆圈表示，转换用圆圈之间的箭头表示，事件则用触发这些转换的文本表示。我们的旋转门状态机有两个可能的状态：锁定和解锁。锁定状态下方的黑点表示锁定是机器的*初始状态*。当首次通电或用户按下重置按钮时，状态机将进入此状态。
- en: 'Let’s consider what happens once we’re in the Locked state. There are two possible
    events that can trigger a transition: pushing on the turnstile, or depositing
    a coin. A Push event causes a transition from Locked back to Locked, represented
    by the arrow on the left of the diagram. In this case, the state machine stays
    in the Locked state. It’s not until a user deposits a coin (the Coin event) that
    we transition to the Unlocked state. At this point, if the user pushes the turnstile,
    it will let them through, then transition back to the Locked state for the next
    user. Finally, notice that if a user deposits a coin into a system that’s already
    Unlocked, it transitions back into the Unlocked state.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一旦我们处于 Locked 状态时会发生什么。有两个可能的事件可以触发转换：推旋转门或投币。Push 事件导致从 Locked 状态返回到 Locked
    状态，这由图中左侧的箭头表示。在这种情况下，状态机保持在 Locked 状态。直到用户投币（Coin 事件）时，我们才会转换到 Unlocked 状态。此时，如果用户推旋转门，它将让他们通过，然后转换回
    Locked 状态以供下一个用户使用。最后，请注意，如果用户将硬币投到一个已经是 Unlocked 状态的系统中，它将转换回 Unlocked 状态。
- en: It may seem trivial to define the behavior of a subway turnstile this way, but
    it’s good practice for getting to know how state machines are organized and represented.
    For systems that have a large sequence of states, events, and transitions, explicitly
    documenting the state machine is critical for generating the desired behavior.
    Even something as simple as a calculator can require a surprisingly complex state
    machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式定义地铁旋转门的行为可能显得微不足道，但它是了解状态机如何组织和表示的好方法。对于那些有大量状态、事件和转换的系统，明确地记录状态机对于生成期望的行为至关重要。即使是像计算器这样简单的东西，也可能需要一个出人意料复杂的状态机。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Implementing a State Machine</samp>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实现状态机</samp>
- en: 'Let’s look at how to implement our basic subway turnstile state machine in
    an FPGA using Verilog or VHDL. We’ll consider two common approaches: the first
    uses two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks, while the second
    uses just one. It’s important to understand both of these approaches to implementing
    a state machine, since they’re both widely used. However, as you’ll see, there
    are reasons to prefer the latter approach.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 FPGA 中使用 Verilog 或 VHDL 实现我们的基本地铁旋转门状态机。我们将考虑两种常见的方法：第一种方法使用两个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块，而第二种方法只使用一个。理解这两种实现状态机的方法非常重要，因为它们都被广泛使用。然而，正如你将看到的，有理由更倾向于后一种方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Two always
    or process Blocks</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用两个 always 或 process
    块</samp>
- en: Using two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks is a more traditional
    way of implementing a state machine. Historically, FPGA synthesis tools weren’t
    very good. They could make mistakes when trying to synthesize state machines.
    The two-block approach was devised to get around these limitations. One <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block controls the synchronous logic, using a register to keep track of the current
    state. The other <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block controls the
    combinational logic; it looks for transition-triggering events and determines
    what the next state should be. [Figure 8-2](#fig8-2) illustrates this arrangement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块是实现状态机的更传统方法。历史上，FPGA 合成工具并不十分出色，它们在尝试合成状态机时可能会出错。两个块的方法就是为了解决这些限制而设计的。一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块控制同步逻辑，使用寄存器来跟踪当前状态。另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块控制组合逻辑；它寻找触发事件并确定下一个状态应该是什么。[图
    8-2](#fig8-2) 说明了这种安排。
- en: '![](../images/Figure8-2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: A block diagram
    of a state machine with two always or process blocks</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-2：使用两个 always 或 process
    块的状态机框图</samp>
- en: Notice that the next state logic in this diagram doesn’t have a clock as an
    input. It determines the next state immediately, based on the current state and
    any inputs (events). Only the current state register has a clock input, which
    it uses to register the output of the next state logic. In this way, it stores
    the current state of the machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图中的下一个状态逻辑没有时钟作为输入。它基于当前状态和任何输入（事件）立即确定下一个状态。只有当前状态寄存器才有时钟输入，用来注册下一个状态逻辑的输出。通过这种方式，它存储机器的当前状态。
- en: 'Here’s how to implement the turnstile state machine using this two-block approach:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这种双块方法实现转闸状态机的方式：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create the states using enumeration ❶, meaning each state name has an assigned
    number. In Verilog, you need to create the list of states manually. I like to
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp> to define
    each state, assigning them numbers in an incrementing order. In VHDL, you instead
    create a user-defined type for your state machine (<samp class="SANS_TheSansMonoCd_W5Regular_11">t_State</samp>).
    Then you list the states in order, and VHDL automatically assigns them numbers.
    If you’re familiar with C programming, the VHDL method is similar to how enumerations
    work in C.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用枚举 ❶ 来创建状态，意味着每个状态名称都有一个分配的编号。在 Verilog 中，你需要手动创建状态列表。我喜欢使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp>
    来定义每个状态，并按递增顺序为它们分配编号。在 VHDL 中，你则创建一个用户定义的类型来表示状态机（<samp class="SANS_TheSansMonoCd_W5Regular_11">t_State</samp>）。然后按顺序列出这些状态，VHDL
    会自动为它们分配编号。如果你熟悉 C 编程，VHDL 的方法类似于 C 中枚举的工作方式。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*SystemVerilog supports automatic enumeration, but it doesn’t exist in regular
    Verilog, so we just number the states manually in the Verilog code.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*SystemVerilog 支持自动枚举，但常规 Verilog 中没有此功能，因此我们在 Verilog 代码中手动编号状态。*'
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block ❷, the current state
    register, is driven by a clock. It keeps track of the current state by assigning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>
    on every rising clock edge ❹. Notice that this block also has the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    signal in its sensitivity list, and that this signal is checked in the block.
    It’s important to include a way to get the state machine to its initial condition,
    and we use <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> for that.
    The block’s <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statement
    (Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">if…elsif</samp> statement
    (VHDL) checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    is high *before* checking to see if we have a rising edge of the clock. This means
    we’re using an *asynchronous reset*; the reset can occur at any time, not necessarily
    on the rising edge of the clock. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    is high, we set the current state to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    ❸. This is in keeping with the initial state indication in [Figure 8-1](#fig8-1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块 ❷，当前状态寄存器，由时钟驱动。它通过在每个时钟上升沿 ❹ 时将 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>
    赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp> 来跟踪当前状态。请注意，这个块的敏感列表中还包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> 信号，并且该信号在块中会被检查。包括一种方法来将状态机重置到初始状态非常重要，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> 来实现。块中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>
    语句（Verilog）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">if…elsif</samp> 语句（VHDL）会先检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> 是否为高电平，再检查时钟是否有上升沿。这意味着我们使用的是
    *异步复位*；复位可以在任何时间发生，而不必在时钟的上升沿发生。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    为高时，我们将当前状态设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> ❸。这与
    [图 8-1](#fig8-1) 中的初始状态表示一致。
- en: The second <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block ❺ is the combinational
    one. It contains the logic for determining how to set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>.
    Notice that the sensitivity list ❺ and the block itself don’t include a clock,
    so this block won’t generate any flip-flops, just LUTs. We set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>
    using a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement tied
    to the current state ❻, and by looking at our inputs. For example, if the state
    is currently <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Coin</samp> input is high, then
    the next state will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>
    ❼. Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement
    and conditional logic with the state machine diagram in [Figure 8-1](#fig8-1),
    and you’ll see that we’ve addressed all the transitions and events shown in the
    diagram that result in an actual change of state. We don’t need to write code
    for transitions that don’t cause the signal to change. For example, if the current
    state is <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp> is high, we’ll just stay
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> state. We could
    add a check for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp> in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> case and write
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> to make this explicit,
    but that’s unnecessary. Adding this line can make the designer’s intent clearer,
    but it also clutters up the code with additional assignments. It’s up to you which
    style you prefer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块 ❺ 是组合逻辑块。它包含了确定如何设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>
    的逻辑。请注意，敏感列表 ❺ 和块本身并不包含时钟，因此该块不会生成任何触发器，只会生成查找表（LUT）。我们通过与当前状态 ❻ 相关联的 <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    语句来设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>，并根据输入来确定下一状态。例如，如果当前状态是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> 且 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Coin</samp>
    输入为高电平，那么下一个状态将是 <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>
    ❼。将 <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 语句和条件逻辑与 [图 8-1](#fig8-1)
    中的状态机图进行对比，你会看到我们已经涵盖了图中所有导致状态实际变化的转换和事件。对于那些不会导致信号变化的转换，我们无需编写代码。例如，如果当前状态是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> 且 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp>
    为高电平，我们将保持在 <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> 状态。我们本可以在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> 情况下添加对 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp>
    的检查，并写出 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    来明确表达这一点，但这是不必要的。添加这一行可以让设计者的意图更加明确，但也会使代码变得臃肿，增加了不必要的赋值。究竟选择哪种风格，取决于你的个人偏好。
- en: 'We could also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    case (in Verilog) or a <samp class="SANS_TheSansMonoCd_W5Regular_11">when others</samp>
    case (in VHDL) above the <samp class="SANS_TheSansMonoCd_W5Regular_11">endcase</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">end case</samp> statement ❽,
    to cover any conditions not explicitly called out in the state machine. Again,
    this is not required, but it can be a good idea; if you forget or omit a case,
    the default case will catch it. In this instance, I chose not to include a default.
    In fact, my code editor displays a suggestion for the VHDL when I try to include
    it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">endcase</samp> 或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">end case</samp> 语句 ❽ 之前添加一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    情况（在 Verilog 中）或 <samp class="SANS_TheSansMonoCd_W5Regular_11">when others</samp>
    情况（在 VHDL 中），以覆盖状态机中没有显式列出的所有条件。同样，这不是强制要求的，但这可能是一个好主意；如果你忘记或遗漏了某个情况，默认情况会捕捉到它。在这种情况下，我选择不包括默认情况。事实上，当我尝试在
    VHDL 中包括它时，我的代码编辑器会显示一个建议：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code ends by assigning the module’s single output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Locked</samp>
    ❾. It will be high when we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    state, or low otherwise. If this code were really controlling a physical turnstile,
    we’d use changes in this output to trigger the actions that occur during state
    transitions, such as enabling or disabling the mechanism that locks the turnstile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过赋值模块的单个输出<sup class="SANS_TheSansMonoCd_W5Regular_11">o_Locked</samp>❾来结束。当我们处于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>状态时，它会为高电平，否则为低电平。如果这段代码实际上是在控制一个物理的旋转门，我们会使用这个输出的变化来触发状态转换过程中发生的动作，比如启用或禁用旋转门的锁定机制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using One always
    or process Block</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用一个always或process块</samp>
- en: 'The other approach to implementing a state machine combines all the logic into
    a single <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. As synthesis tools
    have improved over the years, they’ve gotten much better at understanding when
    you want to create a state machine, and where this one-block approach may once
    have been hard to synthesize, it’s now perfectly viable (and arguably more straightforward
    to code). Here’s the same turnstile state machine implemented with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实现状态机的另一种方法是将所有逻辑合并到一个单独的<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块中。随着综合工具的不断改进，它们在理解你想要创建状态机的场景上变得更加精准。曾经这种单块方法可能难以综合，现在它完全可行（并且可以说更加简单易懂）。以下是使用单个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块实现的相同旋转门状态机：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Everything works the same in the two approaches; the differences are purely
    stylistic, not functional. In this version of the state machine, we have a single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block ❶ that’s sensitive to the clock and the reset signal. Rather than having
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> to worry about, we
    now only have <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>.
    None of the actual logic has changed, however. All we’ve done is move the work
    that was being done in the combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block into the
    sequential one, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement will be evaluated at every rising clock edge ❷.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，一切运行方式相同；它们的区别完全是风格上的，而不是功能上的。在这一版本的状态机中，我们有一个单独的<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块❶，它对时钟和复位信号敏感。与其需要同时关注<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>，现在我们只需要关注<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>。然而，实际的逻辑并没有改变。我们所做的只是将原本在组合<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块中执行的工作移动到了顺序块中，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句将在每个时钟上升沿❷时被评估。
- en: I’m not a big fan of the first approach we looked at, with the two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks. There
    are a few reasons for this. First, separating the LUT-based logic and the flip-flop-based
    logic into two separate blocks can be confusing, especially for beginners. Compared
    to the single-block solution, the design is more complicated and less intuitive,
    and it’s easier to make mistakes. Second, as I said back in [Chapter 4](chapter4.xhtml),
    I prefer not to use combinational-only <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks if I can
    avoid them. They can generate latches if you’re not careful, which can result
    in unwanted behavior. I recommend keeping your state machine logic within a single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block. The code is easier to read and understand, and the tools are good enough
    now to build the state machine correctly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我不太喜欢我们刚才看过的第一种方法，涉及两个<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块。原因有几个。首先，将基于LUT的逻辑和基于触发器的逻辑分成两个独立的块可能会让人困惑，特别是对于初学者来说。与单一块的解决方案相比，设计更复杂、不够直观，也更容易出错。其次，正如我在[第4章](chapter4.xhtml)中所说，我倾向于避免使用仅由组合逻辑构成的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块。如果不小心，它们可能会生成锁存器，从而导致不期望的行为。我建议将状态机逻辑保持在一个单独的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块内。这样代码更容易阅读和理解，而且如今工具足够强大，可以正确构建状态机。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Design</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试设计</samp>
- en: 'Let’s generate a testbench for this state machine to ensure that we’re getting
    the output we desire:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个状态机生成一个测试平台，以确保我们得到期望的输出：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This testbench drives the inputs in all possible combinations and monitors the
    single output (<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>)
    to see how it behaves. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp>
    is initialized to high at the outset ❶, which should put us in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    state. Then, after 10 ns, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp>
    low ❷. This should have no effect on the state, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    keyword in both VHDL and Verilog to verify that we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    state (indicated by a <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) ❸. We then continue
    manipulating the other inputs and asserting the expected output (for instance,
    driving <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Coin</samp> high ❹ should
    put us in an <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp> state).
    Our use of <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> statements
    to automatically alert us to any failures makes this a self-checking testbench.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试平台驱动所有可能组合的输入，并监控单一输出（<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>）来查看它的行为。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp>在开始时被初始化为高电平❶，这应该将我们置于<|samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>状态。然后，在10ns后，我们将<|samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp>拉低❷。这应该对状态没有影响，因此我们在VHDL和Verilog中都使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>关键字来验证我们是否处于<|samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>状态（由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>值为<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>指示）❸。然后，我们继续操作其他输入，并断言预期的输出（例如，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Coin</samp>拉高❹应该将我们置于<|samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>状态）。我们通过使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>语句自动提醒我们任何失败，使得这个测试平台成为一个自检的工具。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*For Verilog users, remember that assert only exists in SystemVerilog. Be sure
    to tell the simulator that your testbench is a SystemVerilog file, rather than
    regular Verilog.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于Verilog用户，请记住，assert仅在SystemVerilog中存在。请确保告诉模拟器你的测试平台是SystemVerilog文件，而不是常规的Verilog文件。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">State Machine Best Practices</samp>
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">状态机最佳实践</samp>
- en: 'Before moving on, I want to share some recommendations for developing successful
    state machines. These are guidelines that I find helpful when I write my own FPGA
    state machines, and they’re all modeled in the turnstile example we reviewed in
    the previous section:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想分享一些关于开发成功状态机的建议。这些是我在编写FPGA状态机时发现有帮助的指导原则，它们都以我们在上一节回顾过的转闸示例为模型：
- en: '**Include one state machine per file.**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个文件包含一个状态机。**'
- en: It’s certainly possible to write many state machines within a single file, but
    I strongly suggest that you limit the scope of any given Verilog or VHDL file
    to a single state machine. When you put two or more state machines in the same
    file, it can be hard to keep them from getting logically intertwined. It might
    require more typing to break things into multiple files, but it will save you
    time in the debugging stage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在一个文件中编写多个状态机，但我强烈建议你将任何给定的Verilog或VHDL文件的范围限制为一个状态机。当你把两个或更多的状态机放在同一个文件里时，它们很容易逻辑上交织在一起。虽然将其分解为多个文件可能需要更多的输入，但它将在调试阶段节省时间。
- en: '**Use the single-block approach.**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用单块方法。**'
- en: As I’ve stated, I find that it’s easier to write cleaner and less error-prone
    state machines if you only have one <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block to worry
    about, rather than two. The one-block approach also avoids the need for combinational
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    blocks, which can generate latches if you’re not careful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，我发现如果只有一个<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块需要关注，而不是两个，会更容易写出更干净、出错更少的状态机。这种单块方法还避免了需要组合性<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块的情况，如果不小心，可能会生成锁存器。
- en: '**Give your states meaningful names.**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**为你的状态命名有意义的名称。**'
- en: It’s much easier to read a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement that has actual words associated with each of the cases, provided you’ve
    named your states thoughtfully. For example, use descriptive names like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IDLE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">START_COUNT</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>,
    and so on, rather than generic names like <samp class="SANS_TheSansMonoCd_W5Regular_11">S0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">S2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">S3</samp>. Meaningful state
    names will help other people reading the code understand what’s going on. Additionally,
    you’ll thank yourself for descriptive state naming when you come back to your
    code after not looking at it for months. Enumeration allows you to do this. Enumeration
    is a common programming technique that allows you to use words in place of integers
    in your code. This is done either through <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp>
    in Verilog or a user-defined type in VHDL.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读一个包含实际单词的<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句要容易得多，前提是你为你的状态命名时考虑周到。例如，使用描述性的名称，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IDLE</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">START_COUNT</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>等，而不是像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">S0</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">S1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">S2</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">S3</samp>这类通用名称。具有意义的状态名称可以帮助其他阅读代码的人理解发生了什么。此外，当你几个月后重新回到自己的代码时，你会感谢自己为状态命名时的描述性命名。枚举允许你做到这一点。枚举是一种常见的编程技术，它允许你在代码中用单词代替整数。这可以通过Verilog中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp>或VHDL中的用户定义类型来实现。
- en: '**Draw your state machine flow before coding.**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**在编码之前绘制状态机流程。**'
- en: Diving headfirst into coding a state machine is a recipe for disaster. Begin
    by drawing a diagram of the state machine that you want to implement, like the
    one you saw in [Figure 8-1](#fig8-1). This will help you ensure that you’ve thought
    through the entire flow, from the initial transition through all the possible
    permutations. If you realize that you’ve missed something once you start working
    on the code, that’s fine; just be sure to go back and update your diagram to keep
    it in sync with the code you’re writing. Your future self will thank you if you
    have this documentation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 直接跳进编写状态机的代码是灾难的开始。首先绘制你想要实现的状态机图表，就像你在[图 8-1](#fig8-1)中看到的那样。这将帮助你确保你已经思考了整个流程，从初始状态到所有可能的变换。如果你在开始编写代码后发现自己漏掉了什么，也没关系；只要确保回去更新你的图表，使其与正在编写的代码保持同步。如果你有这些文档，你未来的自己会感谢你的。
- en: It is by no means mandatory to follow these suggestions, but doing so will help
    you avoid some common pitfalls and create state machines within your FPGAs that
    are bug-free, easy to understand, and easy to maintain. The more complex your
    state machines become, the more helpful these best practices will be.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些建议绝非强制性的，但这样做将有助于你避免一些常见的陷阱，并在你的 FPGA 中创建无错、易懂且易于维护的状态机。你的状态机越复杂，这些最佳实践就越有帮助。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #6: Creating a Memory Game</samp>'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #6：创建一个记忆游戏</samp>'
- en: We’ll now put what you’ve learned about state machines into action by creating
    a memory game that runs on your development board. The player will have to remember
    and reproduce a pattern that grows longer as the game progresses, similar to a
    game like Simon. If the player can remember the entire pattern, they win.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把你学到的关于状态机的知识付诸实践，创建一个在你的开发板上运行的记忆游戏。玩家需要记住并重现一个随着游戏进展而变得越来越长的模式，类似于 Simon
    游戏。如果玩家能记住整个模式，他们就赢了。
- en: The pattern is displayed using four LEDs. It starts simply, with just one LED
    lighting up. Then it’s the player’s turn to re-create the pattern by pressing
    the switch that matches the LED. If they push the wrong switch, the game is over.
    If they push the correct switch, the game continues, with the pattern expanding
    to a sequence of two LED blinks. The pattern keeps expanding until it’s seven
    blinks long (although you’ll be able to adjust the code to make it longer if you
    want). If the player re-creates the last pattern correctly, they may choose to
    play another round with a new pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式通过四个 LED 显示。它从简单的一个 LED 开始点亮。然后轮到玩家通过按下与 LED 对应的开关来重现模式。如果按错了开关，游戏就结束。如果按对了开关，游戏继续，模式扩展到两个
    LED 的闪烁序列。模式将继续扩展，直到达到七次闪烁（虽然你可以调整代码使其更长）。如果玩家正确重现了最后的模式，他们可以选择再来一局，生成新的模式。
- en: 'This project takes advantage of a peripheral that we haven’t used before: a
    *seven-segment display*. This device uses an arrangement of seven LEDs to display
    the digits 0 through 9 (and a selection of letters), like something you’d see
    on a digital clock. It will serve as a scoreboard, keeping track of the player’s
    progress through the pattern. We’ll also use it to display an F (for *failure*)
    if the player makes a mistake, or an A when the game is won.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目利用了我们之前没有使用过的外设：*七段显示器*。这个设备使用七个 LED 的排列显示数字 0 到 9（以及一些字母），就像你在数字时钟上看到的那样。它将作为记分板，跟踪玩家在模式中的进度。我们还将使用它来显示
    F（表示*失败*），如果玩家犯错，或者显示 A，当游戏获胜时。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*If your development board doesn’t have four LEDs and switches, you can adapt
    the project’s code to work with the resources available. If it doesn’t have a
    seven-segment display, try connecting one to your board, for example using a Pmod
    connector.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的开发板没有四个 LED 和开关，你可以调整项目的代码以适应可用的资源。如果没有七段显示器，可以尝试将一个连接到你的板子上，例如使用 Pmod
    连接器。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning the State
    Machine</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规划状态机</samp>
- en: To create the game, we’ll need to control the FPGA’s flow through various states
    of operation, such as displaying the pattern and waiting for the player’s response.
    Sounds like a perfect opportunity to use a state machine! In keeping with our
    best practices, we’ll use a diagram to plan out the state machine before we write
    any code. [Figure 8-3](#fig8-3) shows a diagram for a state machine that satisfies
    the description of the game.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个游戏，我们需要控制FPGA在不同操作状态之间的流转，比如显示模式和等待玩家的回应。听起来这是使用状态机的完美时机！按照我们的最佳实践，我们会在编写任何代码之前，使用图示来规划状态机。[图8-3](#fig8-3)展示了一个满足游戏描述的状态机图示。
- en: '![](../images/Figure8-3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The memory game
    state machine diagram</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-3：记忆游戏状态机图示</samp>
- en: Starting from the top-left corner, we have a reset/initial condition, which
    will jump into the Start state from any other state. I didn’t draw arrows from
    every state back to Start, to avoid cluttering the diagram; just remember that
    you can always jump back to Start from any state when the reset condition occurs.
    We remain in the Start state until the reset is cleared, at which point we transition
    into the Pattern Off state. We wait here with all LEDs off for a set amount of
    time, and then we transition into the Pattern Show state, where we illuminate
    a single LED from the pattern, again for a set amount of time. If it’s the last
    LED in the pattern (the pattern is done), we then transition to the Wait Player
    state to await the player’s response. If the LED pattern is not done, we transition
    back to Pattern Off. We keep cycling between Pattern Show and Pattern Off, lighting
    up the LEDs in the pattern one at a time, until the pattern is done. The transitions
    back to Pattern Off add a pause between each blink, which avoids ambiguity in
    cases where the pattern includes the same LED twice in a row. This is the part
    of the game where the LED pattern is being shown to the player, for them to try
    to re-create later on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从左上角开始，我们有一个复位/初始条件，它会让状态机从任何其他状态跳转到开始状态（Start）。为了避免图示杂乱，我没有从每个状态画回到开始状态的箭头；只要记住，当复位条件发生时，您总是可以从任何状态跳回开始状态。我们会保持在开始状态，直到复位被清除，此时我们过渡到模式关闭（Pattern
    Off）状态。在此状态下，所有LED灯会关闭，并保持一段时间，然后我们过渡到模式显示（Pattern Show）状态，在这里我们点亮模式中的一个LED，同样保持一段时间。如果这是模式中的最后一个LED（模式已完成），我们则过渡到等待玩家（Wait
    Player）状态，等待玩家的回应。如果LED模式尚未完成，我们则过渡回模式关闭状态。我们在模式显示和模式关闭状态之间不断循环，一次点亮模式中的一个LED，直到模式完成。过渡回模式关闭状态为每次闪烁之间增加了暂停，避免了在模式中有相同LED连续两次出现时的歧义。这部分是游戏的关键，LED模式正在展示给玩家，以便他们稍后尝试重新创建。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The diamond in the diagram between the Pattern Show and Wait Player states
    represents a* guard condition*, a Boolean expression that determines the state
    machine flow. In this case, the guard condition is checking whether the pattern
    is done.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图中的菱形位于模式显示（Pattern Show）和等待玩家（Wait Player）状态之间，表示一个*守卫条件*，它是一个布尔表达式，用于确定状态机的流转。在这种情况下，守卫条件检查模式是否完成。*'
- en: Once we’re in the Wait Player state, the FPGA monitors the input from the buttons
    until one of two things happens. If the player pushes an incorrect button in the
    sequence, then we transition to the Loser state and show an F on the seven-segment
    display. If the player successfully re-creates the entire pattern, then we transition
    to the Incr Score (Increment Score) state. Here we check if the game is done,
    in which case the player has won and we transition to the Winner state, where
    we show an A on the seven-segment display. If the game isn’t done, then we go
    back to Pattern Off to get ready to display the pattern again, this time with
    one additional LED blink added to the sequence.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入等待玩家（Wait Player）状态，FPGA会监控按钮的输入，直到发生以下两种情况之一。如果玩家按错了序列中的按钮，我们就过渡到失败（Loser）状态，并在七段显示器上显示F。如果玩家成功地重新创建了整个模式，我们就过渡到增加得分（Incr
    Score）状态。在这里，我们检查游戏是否完成，如果完成，则玩家获胜，我们过渡到胜利（Winner）状态，并在七段显示器上显示A。如果游戏尚未完成，我们则回到模式关闭状态，准备再次显示模式，并在序列中增加一个额外的LED闪烁。
- en: There are nearly endless possibilities for designing state machines, so by no
    means is the arrangement shown in [Figure 8-3](#fig8-3) the only option. For example,
    we could have combined Pattern Off and Pattern Show into a single state that handles
    turning the LEDs both on and off. Our design, however, strikes a balance between
    the number of states and the complexity of each individual state. As a general
    rule, if one state is responsible for several actions, it might be an indication
    that the state should be broken into two or more states.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设计状态机的可能性几乎是无穷无尽的，因此[图8-3](#fig8-3)所示的排列并不是唯一的选择。例如，我们可以将“Pattern Off”和“Pattern
    Show”合并为一个状态，用于处理LED的开关。但我们的设计在状态数量和每个状态的复杂性之间找到了一个平衡。一般来说，如果一个状态负责多个动作，那么这可能是一个信号，表明该状态应该被拆分成两个或更多状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organizing the Design</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">组织设计</samp>
- en: Next, we’ll take a look at the overall organization of the project. [Figure
    8-4](#fig8-4) shows a block diagram of the design.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看项目的整体组织。[图8-4](#fig8-4)显示了设计的框图。
- en: '![](../images/Figure8-4.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: The Project #6
    block diagram</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-4：项目#6的框图</samp>
- en: Let’s trace the flow of data through the block diagram. First, we have four
    switches (buttons) that are used to control the entire game. Remember that these
    are mechanical switches, so they’re subject to bouncing. To get reliable button
    responses, these inputs must be debounced, which is the first thing that we do
    to each switch’s signal as it enters the FPGA. We’ll use the debounce filter module
    we implemented in [Chapter 5](chapter5.xhtml) for this. The FPGA also has a clock
    input, which we’ll use to drive all the flip-flops in this design.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们追踪数据流通过框图的过程。首先，我们有四个开关（按钮），用于控制整个游戏。记住，这些是机械开关，因此它们会有抖动。为了获得可靠的按钮响应，这些输入必须进行消抖，这是我们对每个开关信号进行的第一步处理，处理时信号进入FPGA。我们将使用在[第5章](chapter5.xhtml)中实现的消抖滤波模块来处理它们。FPGA还有一个时钟输入，我们将用它来驱动设计中的所有触发器。
- en: 'Next, we have the memory game module itself, which is where the state machine
    lives. We’ll explore this code in detail shortly. Notice that this module instantiates
    two submodules: <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    and the LFSR module, both of which you saw in [Chapter 6](chapter6.xhtml). Remember
    that LFSRs are pseudorandom pattern generators, so we’ll use one here to create
    a random pattern for the game. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module to keep track of how long to display each LED in the pattern sequence;
    the toggling of this module will trigger transitions between states.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是记忆游戏模块本身，就是状态机所在的地方。我们将很快详细探讨这段代码。请注意，这个模块实例化了两个子模块：<samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>和LFSR模块，你在[第6章](chapter6.xhtml)中见过它们。记住，LFSR是伪随机模式生成器，因此我们将在这里使用它来创建游戏的随机模式。我们将使用<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>模块来跟踪每个LED在模式序列中显示的时间；该模块的切换将触发状态之间的转换。
- en: Finally, we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp>
    module, which takes a binary input representing the player’s score and drives
    the seven-segment display to light up that score. We’ll look at how this works
    next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有<сamp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp>模块，它接收一个表示玩家得分的二进制输入，并驱动七段显示器点亮该分数。我们接下来将探讨这个模块的工作原理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Seven-Segment
    Display</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用七段显示器</samp>
- en: A seven-segment display consists of an arrangement of seven LEDs that can be
    lit in various combinations to produce different patterns. [Figure 8-5](#fig8-5)
    shows the seven segments of the display, labeled A through G. We’ll use one of
    these displays to keep track of the score in this project, incrementing it each
    time the player successfully repeats the pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 七段显示器由七个LED组成，可以通过不同的组合点亮这些LED，从而产生不同的模式。[图8-5](#fig8-5)显示了显示器的七个部分，标记为A到G。在这个项目中，我们将使用其中一个显示器来跟踪得分，每当玩家成功重复模式时，得分会递增。
- en: '![](../images/Figure8-5.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A seven-segment
    display</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-5：七段显示器</samp>
- en: 'Conventionally, seven-segment displays are used to show the decimal numbers
    0 through 9, but we can extend our display’s range further by showing the hexadecimal
    numbers A through F (for 10 through 15) as well. We can’t simply tell the display
    to light up a particular number, however, since each segment in the display is
    controlled separately. Instead, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary
    _To_7Segment</samp> module takes in the number to be shown and translates it into
    the appropriate signals for driving the display. Let’s take a look at the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，七段显示器用于显示十进制数字0到9，但我们可以通过显示十六进制数字A到F（即10到15）来扩展显示器的显示范围。然而，我们不能简单地告诉显示器点亮某个特定的数字，因为显示器中的每一段都是单独控制的。因此，我们的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary _To_7Segment</samp>模块接收要显示的数字，并将其转换为驱动显示器的适当信号。让我们看看代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This module takes a 4-bit binary input ❶ and uses seven outputs to light up
    the appropriate segments in the display, given the input. The <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement ❷ captures all possible inputs, from <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp> (0 through 15), and
    translates each number into the correct output pattern using the 7-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>
    register. Each bit in the register maps to one of the segments in the display:
    bit 6 maps to segment A, bit 5 maps to segment B, and so on. To see how this works,
    let’s consider a specific input—say, <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>,
    which is the digit 7—as an example. [Figure 8-6](#fig8-6) illustrates how to illuminate
    a seven-segment display to show this digit.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块接收一个4位二进制输入❶，并使用七个输出根据输入点亮显示屏中相应的段。<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句❷捕捉所有可能的输入，从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>（0到15），并通过7位的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>寄存器将每个数字转换为正确的输出模式。寄存器中的每一位都映射到显示器中的一个段：位6映射到段A，位5映射到段B，依此类推。为了理解这一点，我们可以考虑一个特定的输入——比如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>，即数字7——作为例子。[图8-6](#fig8-6)展示了如何点亮七段显示器以显示这个数字。
- en: '![](../images/Figure8-6.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: Illuminating a
    7 on a seven- segment display</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图8-6：在七段显示器上点亮数字7</samp>
- en: As you can see in the figure, we need to illuminate segments A, B, and C, while
    keeping the other segments turned off, to show the digit 7\. In the code at ❸,
    we therefore set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">1110000</samp>
    in binary, putting 1s on the three bits corresponding to segments A, B, and C.
    Then, outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement,
    we extract each individual bit from the register and pass it to the appropriate
    output using a continuous assignment ❹. This approach of encoding the pattern
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp> register
    saves a lot of typing; we don’t have to assign all seven outputs in every single
    branch of the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们需要点亮段A、B和C，同时保持其他段关闭，以显示数字7。在❸处的代码中，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>，即二进制的<samp class="SANS_TheSansMonoCd_W5Regular_11">1110000</samp>，将1放在对应段A、B和C的三个位上。然后，在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句外，我们从寄存器中提取每一位，并通过连续赋值❹将其传递到相应的输出。这种将模式编码到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>寄存器中的方法节省了大量的代码；我们不需要在每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句的每个分支中分配所有七个输出。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coding the Top-Level
    Module</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编码顶层模块</samp>
- en: 'Next, let’s jump into the top module of the project to see how everything is
    wired up at the highest level. If you refer back to the block diagram in [Figure
    8-4](#fig8-4), you’ll see this module represented by the square with the dotted
    line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进入项目的顶层模块，看看一切是如何在最高层级连接的。如果你回顾一下 [图8-4](#fig8-4) 中的框图，你会看到这个模块由带虚线的方框表示：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: My goal for writing the top module of a design, especially as the design becomes
    more complicated, is to minimize the amount of functional code within it. Ideally,
    code that performs functionality should be pushed into lower levels, so the highest
    level is just wires and module instantiation. This helps keep the code clean and
    ensures that each module is focused on performing what’s needed of it, without
    spreading the functionality across multiple layers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写设计顶层模块的目标，尤其是当设计变得越来越复杂时，是尽量减少其中的功能代码量。理想情况下，执行功能的代码应该被推送到更低的层级，这样顶层就只需要包含信号线和模块实例化。这样有助于保持代码的整洁，并确保每个模块专注于执行其需要完成的任务，而不是将功能分散到多个层次。
- en: For this project, we first instantiate four debounce filter modules, one for
    each push button ❷. Then we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>
    module, which contains the logic for the state machine and the game itself ❸.
    The inputs to this module, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_4</samp>, are the
    outputs of the debounce filters, so this module can trust that the input signals
    are stable. Notice that the module has two parameters (Verilog) or generics (VHDL),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>,
    both of which were set earlier ❶. The former specifies the number of clock cycles
    per second (needed for keeping track of time), and is there in case the design
    is run at a different clock frequency. The latter controls the maximum length
    of the pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们首先实例化四个去抖动滤波模块，每个按钮一个 ❷。然后我们实例化了 <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>
    模块，它包含了状态机和游戏本身的逻辑 ❸。这个模块的输入，<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_1</samp>
    到 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_4</samp>，是去抖动滤波器的输出，因此该模块可以信任输入信号是稳定的。请注意，该模块有两个参数（Verilog）或泛型（VHDL），<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>，这两个参数在之前已设置
    ❶。前者指定每秒钟的时钟周期数（用于跟踪时间），并且它的存在是为了适应设计在不同时钟频率下运行。后者控制模式的最大长度。
- en: Next we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp>
    module ❹, which takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Score</samp>
    output from the game as an input so the score will be displayed to the player.
    Notice, however, that we invert all the outputs from the display module before
    outputting them at the top level ❺. A low on the output may be needed, rather
    than a high, to light up each segment, depending on the way the seven-segment
    display is connected on your development board’s PCB. If your display isn’t behaving
    as expected, try removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>s
    from the Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>s
    from the VHDL to avoid inverting the outputs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化了 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp>
    模块 ❹，它将游戏中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Score</samp> 输出作为输入，以便将分数显示给玩家。不过需要注意的是，我们在将显示模块的所有输出传递到顶层之前，都会先对其进行反转
    ❺。由于七段显示器的连接方式可能不同，输出端可能需要低电平而不是高电平来点亮每个段。如果你的显示器行为不符合预期，尝试去掉 Verilog 中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp> 或 VHDL 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>，避免反转输出。
- en: 'Our top-level module doesn’t instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> modules
    directly: those are instantiated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>
    module. You’re starting to see here how a hierarchy can be established inside
    an FPGA, and how a complex design can be built up from relatively simple modules.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶层模块并没有直接实例化 <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR</samp> 或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> 模块：这些模块是在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> 模块中实例化的。你开始能看到
    FPGA 内部如何建立层次结构，以及如何从相对简单的模块构建起复杂的设计。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coding the State
    Machine</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">状态机编码</samp>
- en: 'Now let’s get to the meat of the project: the state machine itself. We’ll examine
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module
    in sections, but remember that you can view the complete code listing in the book’s
    GitHub repository ([*https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas*](https://github.com/nandland/getting-started-with-fpgas)).
    The module starts, as usual, by declaring the inputs, outputs, and internal signals:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入项目的核心部分：状态机本身。我们将分部分地检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>
    模块，但请记住，你可以在书籍的 GitHub 仓库中查看完整的代码列表（[*https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas*](https://github.com/nandland/getting-started-with-fpgas)）。该模块首先像往常一样，声明输入、输出和内部信号：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use the enumeration approach described earlier in the chapter to name each
    state ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> signal
    ❷ will keep track of the current state. It needs to have enough bits to convey
    all the possible states. In this case, we have seven total states, which can fit
    inside a 3-bit-wide register. In Verilog, we explicitly declare the signal as
    having 3 bits. In VHDL, however, we just create the state machine signal to be
    of the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">t_SM_Main</samp> data
    type (the enumeration that we created ❶), and it will be sized automatically.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用章节前面描述的枚举方法来命名每个状态 ❶。<samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    信号 ❷ 将跟踪当前状态。它需要足够的位数来表示所有可能的状态。在这种情况下，我们总共有七个状态，可以适配一个 3 位宽的寄存器。在 Verilog 中，我们明确声明该信号为
    3 位。而在 VHDL 中，我们只是创建一个自定义的状态机信号 <samp class="SANS_TheSansMonoCd_W5Regular_11">t_SM_Main</samp>
    数据类型（我们之前创建的枚举 ❶），它会自动调整大小。
- en: Another important signal we’re creating is <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>,
    which stores the pattern for the game ❸. This is the second time that we’ve created
    a two-dimensional signal within our FPGA (the first time was back in [Chapter
    6](chapter6.xhtml), when we were creating RAM). Specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    is 2 bits wide by 11 items deep, for a total storage of 22 bits. Each pair of
    bits in this signal corresponds to one of the four LEDs (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    indicates LED1, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> indicates
    LED2, and so on), giving us a sequence of LEDs to light up (and a sequence of
    switches to press). [Table 8-1](#tab8-1) shows an example of what the data in
    this 2D register might look like.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的另一个重要信号是 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>，它存储游戏模式
    ❸。这是我们在 FPGA 中创建的第二个二维信号（第一次是在[第6章](chapter6.xhtml)时，我们创建了 RAM）。具体来说，<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    宽度为 2 位，深度为 11 项，总共存储 22 位。该信号中的每一对位对应四个 LED 之一（<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    表示 LED1，<samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> 表示 LED2，以此类推），从而为我们提供一个
    LED 序列来点亮（以及一个按键序列）。[表 8-1](#tab8-1) 显示了这个 2D 寄存器中数据的示例。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Pattern
    Storage Example</samp>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 8-1：</samp> <samp class="SANS_Futura_Std_Book_11">模式存储示例</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Index</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">LED/switch</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">索引</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">二进制</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">LED/开关</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
- en: In this example, the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, which correlates to
    the second LED/switch, the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, which correlates to
    the fourth LED/switch, and so on. We’ll be able to use the index to increment
    through the register, getting 2 bits for each index. The binary pattern itself
    comes from the LFSR, and will be random each time. The LFSR is 22 bits wide, so
    each bit of the LFSR output is mapped to a bit in this 2D register. This means
    that the maximum length of the memory pattern that we can create is 11 LED blinks
    long. After playing this game several times, however, I can tell you that it gets
    quite challenging to remember patterns that go that high. As I noted earlier,
    the actual limit for the game is set by the parameter/generic <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>,
    which can be overridden from the top module. If you want to set the game to the
    maximum difficulty, try changing <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，索引为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 的值是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp>，它与第二个LED/开关相关联，索引为 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    的值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>，它与第四个LED/开关相关联，依此类推。我们可以使用索引逐步遍历寄存器，每个索引获取2位数据。二进制模式本身来自LFSR，每次都会是随机的。LFSR的宽度是22位，因此LFSR输出的每一位都映射到该2D寄存器中的一位。这意味着我们可以创建的最大内存模式长度是11个LED闪烁。但在多次玩这个游戏之后，我可以告诉你，记住这么高的模式会变得非常有挑战性。正如我之前提到的，游戏的实际限制由参数/泛型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp> 设置，可以从顶层模块覆盖。如果你想将游戏设置为最大难度，可以尝试将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp> 改为 <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>。
- en: 'The module continues by handling reset conditions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模块继续处理复位条件：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The player must push switch 1 and switch 2 at the same time to trigger the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">START</samp> state. We check for this
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement ❶. Notice
    that this check occurs outside the state machine’s main <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement, which we initiate in the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch ❷. This means that on every clock cycle we’ll check if both switches are
    pressed, and enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    state if they are or run the state machine for the game if they aren’t. It would
    have been easier if we had a fifth button that was dedicated to resetting the
    state machine, but alas, I did not, so I had to be a bit creative here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家必须同时按下开关1和开关2才能触发 <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    状态。我们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句 ❶ 来检查这一点。请注意，这个检查发生在状态机的主要
    <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 语句之外，我们在 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    分支中启动它 ❷。这意味着在每个时钟周期，我们都会检查两个开关是否都被按下，如果是的话，就进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    状态，否则运行游戏的状态机。如果我们有一个专门用于重置状态机的第五个按钮，那就容易多了，但遗憾的是，我没有，所以我不得不在这里稍微动点脑筋。
- en: 'Now let’s look at the first few states in the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 语句中的前几个状态：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First we handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    state ❶, where we wait for the reset condition to be removed. This happens when
    switches 1 and 2 are released ❷. Notice that we’re looking not only for a low
    on the two switches, but also for a high on <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>.
    We use this signal throughout the module to detect falling edges—that is, releases—on
    the four switches. You’ll see how this works later in the code. When the reset
    is cleared, we set the score and the pattern index to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    then go into the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp> 状态 ❶，在这个状态中，我们等待复位条件被解除。这个条件在释放开关1和开关2时发生
    ❷。请注意，我们不仅仅是检测两个开关的低电平，还要检测 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>
    的高电平。我们在整个模块中使用这个信号来检测下降沿——也就是开关的释放——你将在代码中看到它是如何工作的。当复位被清除时，我们将得分和模式索引设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，然后进入 <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    状态。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state
    ❸ simply waits for a timer, driven by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And
    _Toggle</samp> module, to expire. When this happens we transition to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN _SHOW</samp> state ❹, during which
    we’ll be illuminating one of the LEDs (you’ll see the code for illuminating the
    LEDs later). The transition out of <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>
    is also triggered by the timer in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module. When the timer expires we need to decide if we’re done displaying the
    pattern, which we do by checking whether the player’s score (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>)
    equals the current index into the pattern (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>)
    ❺. If it doesn’t, we aren’t done, so we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>
    to get ready to light up the next LED in the pattern ❼ and we go back to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state. If we are done,
    we reset <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❻ and transition to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> state. Let’s look at
    that now:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> 状态 ❸ 仅仅等待由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And _Toggle</samp> 模块驱动的计时器到期。当这种情况发生时，我们过渡到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN _SHOW</samp> 状态 ❹，在此期间我们将点亮其中一个LED（稍后你将看到点亮LED的代码）。从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> 状态的过渡也是由 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> 模块中的计时器触发的。当计时器到期时，我们需要决定是否完成了模式的显示，方法是检查玩家的得分（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>）是否等于当前模式索引（<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>）
    ❺。如果不相等，说明我们没有完成，于是我们增加 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>，准备点亮下一个LED
    ❼，并回到 <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> 状态。如果完成了，我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> 重置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    ❻ 并过渡到 <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> 状态。现在我们来看一下：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> state,
    we wait for <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp> to
    go high, indicating the player has pressed and released a switch ❶. Then we check
    if the player has correctly pressed the next switch in the pattern. As you’ll
    see later, each time any switch is released, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    is set to indicate which switch it was (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    for switch 1, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> for switch
    2, and so on), so we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    with a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> as an index
    into the 2D array. There are three possibilities. If the switch is correct and
    we’re at the end of the pattern ❷, we reset <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>
    and transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>
    state. If the switch is incorrect, we transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp>
    state ❹. Otherwise, the switch is correct but we aren’t done with the pattern,
    so we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> and
    wait for the next press ❺. Notice in this last case that we don’t explicitly assign
    the state, so <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> will
    just retain its previous assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>).
    We could add a line at the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement that says <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER;</samp>
    but it’s not necessary. If <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    isn’t assigned, then we know that path doesn’t cause a state change.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> 状态下，我们等待
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp> 变高，表示玩家已经按下并释放了一个开关
    ❶。然后我们检查玩家是否正确按下了下一个模式中的开关。正如你稍后将看到的，每次有开关被释放时，<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    会被设置为指示是哪一个开关 (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> 代表开关 1，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp> 代表开关 2，依此类推)，因此我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    与 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp> 中的值进行比较，使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> 作为二维数组的索引。这里有三种可能性。如果开关是正确的并且我们已经到达模式的末尾
    ❷，我们会重置 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> 并转换到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> 状态。如果开关是错误的，我们会转换到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp> 状态 ❹。否则，开关是正确的，但我们还没有完成模式，所以我们会增加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> 并等待下一个按下 ❺。注意，在这种情况下，我们没有显式地分配状态，因此
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> 会保留其之前的分配（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>）。我们可以在 <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    语句的末尾添加一行代码：<samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER;</samp>，但这并不是必须的。如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> 没有被分配值，那么我们知道该路径不会导致状态变化。
- en: One difference between the Verilog and the VHDL is that in the latter we need
    to be very explicit about the types we’re comparing. In the VHDL only, we need
    to cast <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> type ❸ so that we can
    compare it to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>, which
    is also of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>.
    Verilog is much more forgiving, so we don’t need this extra conversion. We’ll
    discuss numerical data types in detail in [Chapter 10](chapter10.xhtml).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Verilog 和 VHDL 之间的一个区别是，在后者中我们需要非常明确地指定我们要比较的类型。在 VHDL 中，我们需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp>
    强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> 类型 ❸，这样我们才能将其与同样是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> 类型的 <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>
    进行比较。Verilog 则宽容得多，因此我们不需要这个额外的转换。我们将在 [第10章](chapter10.xhtml) 中详细讨论数值数据类型。
- en: 'Now let’s look at the remaining states in the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下 <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> 语句中的其余状态：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> ❶, we increment
    the score variable and compare it with <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>
    to check if the game is over. If so, we go to the <samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp>
    state, and if not, we go back to <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    to continue the memory sequence. Notice that we’ll only be in this state for a
    single clock cycle. You could perhaps make the argument that <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>
    isn’t a necessary state, and that this logic should happen in <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>
    instead. I chose to treat <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>
    as a separate state to avoid making <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>
    too complicated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> ❶ 中，我们递增得分变量并与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>进行比较，检查游戏是否结束。如果是，我们进入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp>状态；如果不是，我们返回到<samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>状态继续记忆序列。请注意，我们将在此状态中停留一个时钟周期。你或许可以认为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>不是一个必要的状态，且这段逻辑应当在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>中执行。我选择将<samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>作为一个独立的状态，以避免使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>变得过于复杂。
- en: For the <samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp> ❷ and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp> ❸ states, we simply set the
    score value to show an A or F on the seven-segment display and remain in the current
    state. The state machine can only leave these states in the event of a reset condition,
    in which switches 1 and 2 are both pressed at the same time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于<samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp> ❷ 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp>
    ❸ 状态，我们简单地设置得分值，在七段显示器上显示A或F，并保持当前状态。状态机只有在重置条件下才会离开这些状态，重置条件是同时按下开关1和开关2。
- en: We also include a default clause at the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement ❹, which specifies what behavior to take in the event that <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    isn’t one of the previously defined states. This shouldn’t ever happen, but it’s
    good practice to create a default case where we go back to <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> statements at the
    end of this listing close out the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement, <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statement,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block that the state machine was wrapped in.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句 ❹ 的末尾包括了一个默认子句，用于指定当<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>不是之前定义的状态时应该采取什么行为。虽然这种情况不应该发生，但创建一个默认的情况是好的做法，在这里我们会返回到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">START</samp>状态。这个清单末尾的<samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>语句结束了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句、<samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp>语句以及包含状态机的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块。
- en: 'We’ve now finished coding the state machine itself. The rest of the code in
    the module handles logic for helping with the tasks that occur during the various
    states. First we have the code for randomly generating the pattern:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了状态机本身的编码。模块中的其余代码处理帮助完成在不同状态下发生的任务的逻辑。首先是生成模式的代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to generate a different pattern each time the game is played, while
    also making sure the pattern gets “locked in” once the game is underway. To do
    this, we first check if we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    state ❶. If so, the game isn’t currently in progress, so we use the LFSR to create
    a new pattern. Recall that the output of our LFSR is a pseudorandom string of
    bits, which changes on every clock cycle. We take 2-bit sections from the LFSR
    output and place them into the 11 slots in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>.
    This will keep happening every clock cycle until the player releases switches
    1 and 2, triggering the transition out of <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>.
    At that point, the current values of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    will be locked in for the duration of the game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每次游戏开始时生成不同的模式，同时确保模式一旦开始游戏就会“锁定”。为此，我们首先检查是否处于<samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>状态
    ❶。如果是，则说明游戏当前没有进行，因此我们使用LFSR生成新模式。回想一下，我们的LFSR输出是一个伪随机的位串，每个时钟周期都会变化。我们从LFSR的输出中提取2位的片段，并将它们放入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>的11个槽位中。每个时钟周期都会继续进行，直到玩家释放开关1和开关2，从而触发从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">START</samp>状态的转换。此时，<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>的当前值将被锁定，直到游戏结束。
- en: In VHDL, we also need to create an intermediary signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp>
    ❷, which is just the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>.
    Again, since VHDL is strongly typed, you’ll often see intermediary signals used
    for generating the “correct” signal types. I could have put this line anywhere
    since it’s a combinational assignment; as long as it’s outside of a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block, its precise location in the file makes no functional difference.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在VHDL中，我们还需要创建一个中间信号<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp>
    ❷，它只是<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>的<samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>表示。再次强调，由于VHDL是强类型的，你经常会看到使用中间信号来生成“正确”的信号类型。我本可以把这行代码放在任何地方，因为它是一个组合赋值；只要它不在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块内，它在文件中的位置对功能没有任何影响。
- en: 'Next comes the code for illuminating the four LEDs:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是用于点亮四个LED的代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we have four continuous assignment statements, one for each LED. In each
    one, we use the ternary operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>)
    in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">when/else</samp> in
    VHDL to illuminate the LED in one of two cases. First, we’ll drive the LED high
    if we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>
    state and the value at the current index of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    matches the current LED. This will only ever be true for one LED at a time, so
    only one LED can be illuminated during each <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>.
    Second, if we aren’t in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>
    state, the LED will be driven based on the input from its associated switch. This
    way the LED will light up when the player presses the corresponding switch, giving
    them visual feedback about the pattern they’re entering.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有四个连续赋值语句，每个LED一个。在每个语句中，我们使用三元运算符（<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>）在Verilog中，或者在VHDL中使用<sam
    class="SANS_TheSansMonoCd_W5Regular_11">when/else</samp>来在两种情况下点亮LED。首先，如果我们处于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>状态，且当前<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>的当前索引与当前LED匹配，我们会驱动LED为高电平。这将仅在一次显示一个LED时成立，因此每次<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>时只能点亮一个LED。其次，如果我们不处于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>状态，LED将根据其相关开关的输入进行驱动。这样，当玩家按下相应开关时，LED会亮起，给他们关于正在输入的模式的可视反馈。
- en: 'The next part of the code uses falling edge detection to identify timeouts
    and button presses:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分使用下降沿检测来识别超时和按钮按下事件：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice we are still using the rising edge of the clock; we’re just looking for
    falling edges for our timeouts and button presses. Recall that this falling edge
    is used to progress through the state machine. We perform falling edge detection
    on the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module, where the output represents the timer expiring. We do this by first registering
    its output, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp>, and
    assigning it to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>
    ❶. (The actual instantiation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module will be handled momentarily.) This creates a one-clock-cycle-delayed version
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp> on <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>.
    Then, as shown previously, we look for the condition where the current value (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp>) is low, but the previous
    value (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>) is high.
    We used this earlier to trigger transitions out of <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们仍然使用时钟的上升沿；我们只是为了超时和按钮按下事件寻找下降沿。回想一下，下降沿用于在状态机中推进。我们在<sup class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</sup>模块的输出上执行下降沿检测，该输出表示定时器过期。我们首先注册其输出<sup
    class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</sup>，并将其分配给<sup class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</sup>
    ❶。（<sup class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</sup>模块的实际实例化将在稍后处理。）这会创建一个<sup
    class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</sup>在<sup class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</sup>上的一个时钟周期延迟版本。然后，如前所示，我们寻找当前值（<sup
    class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</sup>）为低，而前一个值（<sup class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</sup>）为高的情况。我们之前用这个来触发从<sup
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</sup>和<sup class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</sup>状态的过渡。
- en: For our switches, when a switch is pressed, it has the value 1; when a switch
    is not pressed, it has the value 0\. We are looking for the situation in which
    the switch goes from a 1 to a 0, which is the falling edge of the switch, representing
    the switch being released. We register each switch ❷ in order to detect the falling
    edge from the switch being released. This is followed by the actual edge detection
    logic ❸. For each switch, when we see a falling edge, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>
    high. As you’ve seen elsewhere in the code, this signal serves as a flag to indicate
    that some switch, any switch, has been released. We also set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    to the switch’s 2-bit binary code, so we’ll know which switch it was. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement ❹ clears <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp> to get ready
    for the next falling edge.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的开关，当开关按下时，其值为1；当开关未按下时，其值为0。我们正在寻找开关从1到0的情况，即开关的下降沿，表示开关被释放。我们注册每个开关❷以检测开关释放时的下降沿。接下来是实际的边缘检测逻辑❸。对于每个开关，当我们看到下降沿时，我们将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</sup>设置为高。如你在其他代码中看到的，这个信号作为标志，指示某个开关（任意开关）已被释放。我们还将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</sup>设置为开关的2位二进制代码，这样我们就知道是哪个开关被释放。<sup
    class="SANS_TheSansMonoCd_W5Regular_11">else</sup>语句❹清除<sup class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</sup>和<sup
    class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</sup>，为下一个下降沿做好准备。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*I’ve chosen to make the state machine react to button releases rather than
    button presses. You could try inverting the test cases* ❸ *to see the difference.
    I think you’ll find it a bit unnatural if the game responds the moment a button
    is pressed instead of the moment it’s released.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*我选择让状态机响应按钮释放事件，而不是按钮按下事件。你可以尝试反转测试用例* ❸ *来查看区别。我认为如果游戏在按钮按下的瞬间做出响应，而不是在按钮释放的瞬间响应，你可能会觉得有点不自然。*'
- en: 'The final section of the code instantiates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp> modules. Remember,
    you’ve seen the code for these modules before, in [Chapter 6](chapter6.xhtml):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分实例化了<samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp>模块。记住，你之前在[第六章](chapter6.xhtml)中已经见过这些模块的代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module ❷. As you saw in [Chapter 6](chapter6.xhtml), it measures out a set amount
    of time by incrementing a register on each clock cycle until it reaches the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp> parameter/generic.
    Here we’ve set <samp class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp> to make
    each <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> state last a quarter
    of a second, but feel free to change this to make the game run faster or slower.
    Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp>
    is a constant (in this case, 25,000,000 / 4 = 6,250,000) that the synthesis tools
    will calculate in advance, so the division operation (which would require a lot
    of resources) won’t have to be performed inside the FPGA itself. The continuous
    assignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Count_En</samp>
    ❶ only enables the counter during the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> states,
    since we don’t want it running during other phases of the game.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化<samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>模块❷。正如你在[第六章](chapter6.xhtml)中看到的，它通过在每个时钟周期递增寄存器，直到达到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp>参数/泛型，从而计量出一定的时间。在这里，我们将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp>设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp>，使得每个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>状态持续四分之一秒，但你可以自由修改这个值，使游戏运行得更快或更慢。请记住，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp>是一个常量（在此情况下为25,000,000
    / 4 = 6,250,000），综合工具会提前计算出这个值，因此除法操作（通常会消耗大量资源）不必在FPGA内部执行。持续分配<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Count_En</samp>❶仅在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>状态下启用计数器，因为我们不希望它在游戏的其他阶段运行。
- en: 'Next, we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp>
    module ❸. Recall from [Chapter 6](chapter6.xhtml) that this module has two outputs:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> for the data
    itself, and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> to
    signal each repetition of the LFSR’s cycle. For this project we don’t need <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp>, so we leave the unused
    output unconnected in Verilog, or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    keyword in VHDL ❹. When we write general-purpose modules like this, we won’t always
    need every single output in every single application. When we don’t use an output,
    the synthesis tools are intelligent enough to remove the associated logic, so
    there’s no hit to our resource utilization when we have unused code.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: "接下来，我们实例化<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">LFSR_22</samp>模块❸。回顾[第六章](chapter6.xhtml)，这个模块有两个输出：<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">o_LFSR_Data</samp>用于数据本身，<samp class=\"\
    SANS_TheSansMonoCd_W5Regular_11\">o_LFSR_Done</samp>用于指示每次LFSR周期的重复。对于这个项目，我们不需要<\t\
    samp class=\"SANS_TheSansMonoCd_W5Regular_11\">o_LFSR_Done</samp>，因此我们在Verilog中将未使用的输出保持未连接，或者在VHDL中使用<samp\
    \ class=\"SANS_TheSansMonoCd_W5Regular_11\">open</samp>关键字❹。当我们编写像这样的通用模块时，并不总是需要每个应用中的每个输出。当我们不使用某个输出时，综合工具足够智能，能够去除相关的逻辑，因此即使我们有未使用的代码，也不会影响我们的资源利用率。"
- en: 'Finally, in VHDL we need to perform one more action: converting <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>,
    which is an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> type,
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> so
    we can assign that value to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>
    ❺. Because VHDL is strongly typed, you’ll frequently see type conversions like
    this when looking at VHDL code.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在VHDL中我们需要执行另一个操作：将<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>（无符号类型）转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>，以便我们可以将该值赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>❺。由于VHDL是强类型的，因此在查看VHDL代码时，你会经常看到这种类型转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Memory
    Game</samp>
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">测试记忆游戏</samp>
- en: The code and state machine diagram that we’ve been looking at here represent
    the final version of this game, but it went through some improvements and fixes
    as I developed it. A lot of the changes were a result of me actually playing the
    game and experimenting to see what I liked and didn’t like. For example, when
    I was first designing the state machine, I went straight from <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> without passing
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>. This
    made the first LED come on immediately, which was confusing; it was hard to tell
    whether the game had started or not. So, I switched the order to add a delay at
    the outset.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的代码和状态机图表示的是游戏的最终版本，但在我开发过程中，它经历了一些改进和修复。很多更改是我实际玩游戏并通过实验来了解我喜欢和不喜欢的部分的结果。例如，当我最初设计状态机时，我直接从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">START</samp>跳到<samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>，没有经过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>。这导致第一个LED立即亮起，令人困惑，很难判断游戏是否已经开始。因此，我调整了顺序，在开始时加入了一个延迟。
- en: 'Most of the changes that I made followed this same pattern: program the board,
    play the game, see behavior I don’t like, change the code, play the game. Another
    example is that the LED on-time was too long initially, so I decreased it to make
    the gameplay snappier. These sorts of issues are more about feel; running a simulation
    wouldn’t have identified them.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我做的大多数更改都遵循了这个相同的模式：编程板子，玩游戏，发现不喜欢的行为，修改代码，继续玩游戏。另一个例子是最初LED的点亮时间太长了，因此我将其缩短，以使游戏节奏更快。这类问题更多是关乎“感觉”，而运行仿真是无法发现这些问题的。
- en: Simulations and testbenches are valuable for understanding where and why bugs
    are occurring and how to fix them. Most of my “problems” weren’t bugs, but behaviors
    that I wanted to change based on my experience playing the game. I did create
    a testbench that allowed me to simulate button presses, however, to see how the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module
    responded. That code is available in the book’s GitHub repository, if you’d like
    to look at it. It’s a simple testbench, not one that performs any self-checking,
    but it did help me find a few bugs when I was initially writing this state machine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真和测试平台对于理解错误发生的原因及如何修复它们非常有价值。我的大多数“问题”并不是错误，而是基于我玩游戏的经验，我希望改变的行为。不过，我确实创建了一个测试平台，允许我模拟按键按下，以观察<samp
    class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>模块的响应。如果你有兴趣查看，这段代码可以在本书的GitHub仓库中找到。这是一个简单的测试平台，并没有执行任何自检，但它在我最初编写状态机时，确实帮助我找到了几个bug。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Pin Constraints</samp>
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加引脚约束</samp>
- en: 'Since we’ve added a new interface at the highest level (the seven-segment display),
    we need to add those signals to our physical constraints file. If we forget this
    step, the place and route tool will likely automatically choose pins for us, which
    will almost certainly be incorrect. You’ll have to refer to the schematic for
    your development board to trace the signal paths from the seven-segment display
    back to your FPGA for each signal. Here are the constraints needed for the Go
    Board, for example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在最高层添加了一个新接口（七段显示器），因此需要将这些信号添加到我们的物理约束文件中。如果我们忘记这一步，放置和布线工具可能会自动为我们选择引脚，而这些引脚几乎肯定是错误的。你需要参考开发板的原理图，追踪七段显示器到FPGA的信号路径。以下是Go板所需的约束示例：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See [Chapter 2](chapter2.xhtml) for a reminder on how to add physical constraints
    to your iCEcube2 project.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第2章](chapter2.xhtml)以回顾如何将物理约束添加到你的 iCEcube2 项目中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建和编程 FPGA</samp>
- en: 'At this point, we’re ready to build the code for the FPGA. Let’s take a look
    at the synthesis results of both the Verilog and the VHDL. Your report should
    look similar to the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为 FPGA 构建代码。让我们看一下 Verilog 和 VHDL 的综合结果。你的报告应该类似于以下内容：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The results are pretty close between the Verilog and VHDL versions; we’re using
    about 12 percent of the available flip-flops and 18 percent of the available LUTs
    for this project. We have an entire memory game consisting of a few hundred lines
    of code, and we’ve used less than 20 percent of the FPGA’s main resources. Not
    bad!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Verilog 和 VHDL 版本的结果非常接近；我们为这个项目使用了大约12%的可用触发器和18%的可用查找表（LUT）。我们有一个包含几百行代码的完整记忆游戏，而且我们只用了
    FPGA 主资源的不到20%。不错！
- en: Program your development board and play the game. See if you can beat it, and
    if you can, try increasing the difficulty by changing <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>
    up to its maximum difficulty of 11\. I found it quite challenging!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 编程你的开发板并玩游戏。看看你能不能赢，如果能，试着通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>增加到最大难度11来提高挑战性。我发现这很有挑战性！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you’ve learned about state machines, which are critical building
    blocks in many programming disciplines, including FPGAs. State machines are used
    to precisely control the flow through a sequence of operations. The operations
    are organized into a network of states, with events that trigger transitions between
    those states. After reviewing a simple example, you designed and implemented a
    sophisticated state machine to control a memory game for your development board.
    The project combined many elements that we’ve discussed throughout the book, including
    debounce logic to clean up the inputs from the switches, an LFSR for pseudorandom
    number generation, and a counter to keep track of time. You also learned to use
    a seven-segment display to create the game’s scoreboard.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了状态机，它是许多编程学科中的关键构建块，包括 FPGA。状态机用于精确控制一系列操作的流动。这些操作被组织成一个状态网络，事件触发状态之间的转换。在回顾一个简单的例子后，你设计并实现了一个复杂的状态机来控制开发板上的记忆游戏。该项目结合了我们在书中讨论的许多元素，包括去抖动逻辑来清理来自开关的输入，一个用于伪随机数生成的
    LFSR，以及一个用于跟踪时间的计数器。你还学会了使用七段显示器来创建游戏的得分板。
