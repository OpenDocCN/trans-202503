- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">THE
    STATE MACHINE</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: A *state machine* is a model for controlling a sequence of actions. In a state
    machine, a task is broken down into a series of stages, or *states*. The system
    flows through these states along prescribed routes, transitioning from one state
    to another based on inputs or other triggers. State machines are widely used to
    organize the operations in an FPGA, so understanding how they work is crucial
    to developing sophisticated FPGA designs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Some common examples of state machines control behaviors in elevators, traffic
    lights, and vending machines. Each of these devices can only be in one unique
    state at any given time and can perform different actions as a result of inputs.
    In the case of an elevator, for example, the elevator car remains on its current
    floor until someone pushes a button to request a ride. The floor that the elevator
    is on is its state, and pushing a button is the input that triggers a change in
    that state. In the case of a traffic light, the possible states are red, yellow,
    and green, and the light changes based on some kind of input—perhaps a timer or
    a motion sensor. Certain transitions are possible, such as going from red to green
    or from yellow to red, while other transitions, such as yellow to green, are not.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Within an FPGA, you might have several state machines performing different independent
    tasks, all running simultaneously. You might have one state machine that initializes
    an LPDDR memory, another that receives data from an external sensor, and a third
    for communicating with an external microcontroller, for example. And since an
    FPGA is a parallel device, these state machines will all be running in parallel,
    with each state machine coordinating its own complicated series of actions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn the basic concepts behind state machines and see
    how to design them with Verilog and VHDL. You’ll learn strategies for keeping
    your state machines clear and concise, which reduces the likelihood of bugs in
    your designs. Finally, you’ll gain hands-on experience with state machines by
    designing a Simon-style memory game for your development board.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">States, Transitions, and Events</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'State machines revolve around three interrelated concepts: states, transitions,
    and events. A *state* describes the status of a system when it’s waiting to execute
    a transition. Going back to the elevator example, if a button is never pressed,
    the elevator will simply remain in its current state; that is, waiting on its
    current floor. A state machine can only ever be in one state at a time (an elevator
    can’t be on two floors at once), and there are only so many possible states that
    it can be in (we haven’t yet figured out how to build a building with an infinite
    number of floors). For this reason, state machines are also called *finite state
    machines (FSMs)*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机围绕三个相互关联的概念展开：状态、转换和事件。*状态*描述的是系统在等待执行转换时的状态。以电梯为例，如果从未按下按钮，电梯将保持在当前状态，也就是停留在当前楼层。状态机一次只能处于一个状态（电梯不能同时在两个楼层），而且它只能处于有限数量的状态（我们还没有解决如何建造一个具有无限楼层的建筑的问题）。因此，状态机也被称为*有限状态机（FSMs）*。
- en: A *transition* is the action of moving from one state to another. For an elevator,
    that would include opening and closing the doors, running a motor to raise or
    lower the car, and so on. Transitions are usually caused by *events*, which can
    include inputs like a button press or a timer expiring. Transitions between states
    can also occur without an external event, which would be an internal transition.
    The same event might trigger a different transition, depending on the current
    state of the state machine. For example, pushing the 5 button will make an elevator
    go down if it’s on the tenth floor, or go up if it’s on the first floor. The elevator’s
    next state is influenced by both its current state and the input event.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换*是指从一个状态移动到另一个状态的动作。对于电梯来说，这包括开关门、运行电机升降轿厢等。转换通常由*事件*引起，事件可以是按键或计时器到期等输入。状态之间的转换也可能在没有外部事件的情况下发生，这称为内部转换。相同的事件可能根据当前状态触发不同的转换。例如，如果电梯在十楼，按下5号按钮会让电梯向下行驶；如果电梯在一楼，按下5号按钮则会让电梯向上行驶。电梯的下一个状态受到当前状态和输入事件的共同影响。'
- en: Designing a state machine entails determining all the possible states, planning
    out the transitions between the states, and identifying the events that can trigger
    those transitions. The easiest way to do this is to draw a diagram. To demonstrate,
    let’s explore an example of a simple state machine, one that controls a coin-operated
    turnstile like you might use to enter a subway station. [Figure 8-1](#fig8-1)
    shows a diagram of this state machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 设计状态机需要确定所有可能的状态，规划状态之间的转换，并识别可以触发这些转换的事件。最简单的方法是绘制一个图表。为了演示这一点，让我们探讨一个简单的状态机例子，它控制着一个硬币投币的旋转门，类似于你在地铁站入口处可能会使用的设备。[图
    8-1](#fig8-1)展示了这个状态机的图示。
- en: '![](../images/Figure8-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: A state machine
    for a turnstile</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-1：一个旋转门的状态机</samp>
- en: 'In a state machine diagram, states are traditionally represented as labeled
    circles, transitions are represented as arrows between circles, and events are
    represented as text alongside the transitions they trigger. Our turnstile state
    machine has two possible states: Locked and Unlocked. The black dot beneath the
    Locked state indicates that Locked is the *initial state* of the machine. This
    is where the state machine will go when power is first applied, or if the user
    hits a reset button.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态机图中，状态通常用带标签的圆圈表示，转换用圆圈之间的箭头表示，事件则用触发这些转换的文本表示。我们的旋转门状态机有两个可能的状态：锁定和解锁。锁定状态下方的黑点表示锁定是机器的*初始状态*。当首次通电或用户按下重置按钮时，状态机将进入此状态。
- en: 'Let’s consider what happens once we’re in the Locked state. There are two possible
    events that can trigger a transition: pushing on the turnstile, or depositing
    a coin. A Push event causes a transition from Locked back to Locked, represented
    by the arrow on the left of the diagram. In this case, the state machine stays
    in the Locked state. It’s not until a user deposits a coin (the Coin event) that
    we transition to the Unlocked state. At this point, if the user pushes the turnstile,
    it will let them through, then transition back to the Locked state for the next
    user. Finally, notice that if a user deposits a coin into a system that’s already
    Unlocked, it transitions back into the Unlocked state.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一旦我们处于 Locked 状态时会发生什么。有两个可能的事件可以触发转换：推旋转门或投币。Push 事件导致从 Locked 状态返回到 Locked
    状态，这由图中左侧的箭头表示。在这种情况下，状态机保持在 Locked 状态。直到用户投币（Coin 事件）时，我们才会转换到 Unlocked 状态。此时，如果用户推旋转门，它将让他们通过，然后转换回
    Locked 状态以供下一个用户使用。最后，请注意，如果用户将硬币投到一个已经是 Unlocked 状态的系统中，它将转换回 Unlocked 状态。
- en: It may seem trivial to define the behavior of a subway turnstile this way, but
    it’s good practice for getting to know how state machines are organized and represented.
    For systems that have a large sequence of states, events, and transitions, explicitly
    documenting the state machine is critical for generating the desired behavior.
    Even something as simple as a calculator can require a surprisingly complex state
    machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式定义地铁旋转门的行为可能显得微不足道，但它是了解状态机如何组织和表示的好方法。对于那些有大量状态、事件和转换的系统，明确地记录状态机对于生成期望的行为至关重要。即使是像计算器这样简单的东西，也可能需要一个出人意料复杂的状态机。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Implementing a State Machine</samp>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">实现状态机</samp>
- en: 'Let’s look at how to implement our basic subway turnstile state machine in
    an FPGA using Verilog or VHDL. We’ll consider two common approaches: the first
    uses two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks, while the second
    uses just one. It’s important to understand both of these approaches to implementing
    a state machine, since they’re both widely used. However, as you’ll see, there
    are reasons to prefer the latter approach.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 FPGA 中使用 Verilog 或 VHDL 实现我们的基本地铁旋转门状态机。我们将考虑两种常见的方法：第一种方法使用两个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块，而第二种方法只使用一个。理解这两种实现状态机的方法非常重要，因为它们都被广泛使用。然而，正如你将看到的，有理由更倾向于后一种方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Two always
    or process Blocks</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用两个 always 或 process
    块</samp>
- en: Using two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks is a more traditional
    way of implementing a state machine. Historically, FPGA synthesis tools weren’t
    very good. They could make mistakes when trying to synthesize state machines.
    The two-block approach was devised to get around these limitations. One <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block controls the synchronous logic, using a register to keep track of the current
    state. The other <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block controls the
    combinational logic; it looks for transition-triggering events and determines
    what the next state should be. [Figure 8-2](#fig8-2) illustrates this arrangement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块是实现状态机的更传统方法。历史上，FPGA 合成工具并不十分出色，它们在尝试合成状态机时可能会出错。两个块的方法就是为了解决这些限制而设计的。一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    块控制同步逻辑，使用寄存器来跟踪当前状态。另一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> 块控制组合逻辑；它寻找触发事件并确定下一个状态应该是什么。[图
    8-2](#fig8-2) 说明了这种安排。
- en: '![](../images/Figure8-2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: A block diagram
    of a state machine with two always or process blocks</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-2：使用两个 always 或 process
    块的状态机框图</samp>
- en: Notice that the next state logic in this diagram doesn’t have a clock as an
    input. It determines the next state immediately, based on the current state and
    any inputs (events). Only the current state register has a clock input, which
    it uses to register the output of the next state logic. In this way, it stores
    the current state of the machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to implement the turnstile state machine using this two-block approach:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We create the states using enumeration ❶, meaning each state name has an assigned
    number. In Verilog, you need to create the list of states manually. I like to
    use <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp> to define
    each state, assigning them numbers in an incrementing order. In VHDL, you instead
    create a user-defined type for your state machine (<samp class="SANS_TheSansMonoCd_W5Regular_11">t_State</samp>).
    Then you list the states in order, and VHDL automatically assigns them numbers.
    If you’re familiar with C programming, the VHDL method is similar to how enumerations
    work in C.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*SystemVerilog supports automatic enumeration, but it doesn’t exist in regular
    Verilog, so we just number the states manually in the Verilog code.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block ❷, the current state
    register, is driven by a clock. It keeps track of the current state by assigning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>
    on every rising clock edge ❹. Notice that this block also has the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    signal in its sensitivity list, and that this signal is checked in the block.
    It’s important to include a way to get the state machine to its initial condition,
    and we use <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp> for that.
    The block’s <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statement
    (Verilog) or <samp class="SANS_TheSansMonoCd_W5Regular_11">if…elsif</samp> statement
    (VHDL) checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    is high *before* checking to see if we have a rising edge of the clock. This means
    we’re using an *asynchronous reset*; the reset can occur at any time, not necessarily
    on the rising edge of the clock. When <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Reset</samp>
    is high, we set the current state to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    ❸. This is in keeping with the initial state indication in [Figure 8-1](#fig8-1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The second <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block ❺ is the combinational
    one. It contains the logic for determining how to set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>.
    Notice that the sensitivity list ❺ and the block itself don’t include a clock,
    so this block won’t generate any flip-flops, just LUTs. We set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp>
    using a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement tied
    to the current state ❻, and by looking at our inputs. For example, if the state
    is currently <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Coin</samp> input is high, then
    the next state will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>
    ❼. Compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement
    and conditional logic with the state machine diagram in [Figure 8-1](#fig8-1),
    and you’ll see that we’ve addressed all the transitions and events shown in the
    diagram that result in an actual change of state. We don’t need to write code
    for transitions that don’t cause the signal to change. For example, if the current
    state is <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp> is high, we’ll just stay
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> state. We could
    add a check for <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Push</samp> in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> case and write
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp> to make this explicit,
    but that’s unnecessary. Adding this line can make the designer’s intent clearer,
    but it also clutters up the code with additional assignments. It’s up to you which
    style you prefer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    case (in Verilog) or a <samp class="SANS_TheSansMonoCd_W5Regular_11">when others</samp>
    case (in VHDL) above the <samp class="SANS_TheSansMonoCd_W5Regular_11">endcase</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">end case</samp> statement ❽,
    to cover any conditions not explicitly called out in the state machine. Again,
    this is not required, but it can be a good idea; if you forget or omit a case,
    the default case will catch it. In this instance, I chose not to include a default.
    In fact, my code editor displays a suggestion for the VHDL when I try to include
    it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code ends by assigning the module’s single output, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Locked</samp>
    ❾. It will be high when we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    state, or low otherwise. If this code were really controlling a physical turnstile,
    we’d use changes in this output to trigger the actions that occur during state
    transitions, such as enabling or disabling the mechanism that locks the turnstile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using One always
    or process Block</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The other approach to implementing a state machine combines all the logic into
    a single <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block. As synthesis tools
    have improved over the years, they’ve gotten much better at understanding when
    you want to create a state machine, and where this one-block approach may once
    have been hard to synthesize, it’s now perfectly viable (and arguably more straightforward
    to code). Here’s the same turnstile state machine implemented with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Everything works the same in the two approaches; the differences are purely
    stylistic, not functional. In this version of the state machine, we have a single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block ❶ that’s sensitive to the clock and the reset signal. Rather than having
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Next_State</samp> to worry about, we
    now only have <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Curr_State</samp>.
    None of the actual logic has changed, however. All we’ve done is move the work
    that was being done in the combinational <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block into the
    sequential one, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement will be evaluated at every rising clock edge ❷.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: I’m not a big fan of the first approach we looked at, with the two <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks. There
    are a few reasons for this. First, separating the LUT-based logic and the flip-flop-based
    logic into two separate blocks can be confusing, especially for beginners. Compared
    to the single-block solution, the design is more complicated and less intuitive,
    and it’s easier to make mistakes. Second, as I said back in [Chapter 4](chapter4.xhtml),
    I prefer not to use combinational-only <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> blocks if I can
    avoid them. They can generate latches if you’re not careful, which can result
    in unwanted behavior. I recommend keeping your state machine logic within a single
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block. The code is easier to read and understand, and the tools are good enough
    now to build the state machine correctly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Design</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s generate a testbench for this state machine to ensure that we’re getting
    the output we desire:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This testbench drives the inputs in all possible combinations and monitors the
    single output (<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>)
    to see how it behaves. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp>
    is initialized to high at the outset ❶, which should put us in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    state. Then, after 10 ns, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Reset</samp>
    low ❷. This should have no effect on the state, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    keyword in both VHDL and Verilog to verify that we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>
    state (indicated by a <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Locked</samp>
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>) ❸. We then continue
    manipulating the other inputs and asserting the expected output (for instance,
    driving <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Coin</samp> high ❹ should
    put us in an <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp> state).
    Our use of <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> statements
    to automatically alert us to any failures makes this a self-checking testbench.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '*For Verilog users, remember that assert only exists in SystemVerilog. Be sure
    to tell the simulator that your testbench is a SystemVerilog file, rather than
    regular Verilog.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">State Machine Best Practices</samp>
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">状态机最佳实践</samp>
- en: 'Before moving on, I want to share some recommendations for developing successful
    state machines. These are guidelines that I find helpful when I write my own FPGA
    state machines, and they’re all modeled in the turnstile example we reviewed in
    the previous section:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想分享一些关于开发成功状态机的建议。这些是我在编写FPGA状态机时发现有帮助的指导原则，它们都以我们在上一节回顾过的转闸示例为模型：
- en: '**Include one state machine per file.**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个文件包含一个状态机。**'
- en: It’s certainly possible to write many state machines within a single file, but
    I strongly suggest that you limit the scope of any given Verilog or VHDL file
    to a single state machine. When you put two or more state machines in the same
    file, it can be hard to keep them from getting logically intertwined. It might
    require more typing to break things into multiple files, but it will save you
    time in the debugging stage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在一个文件中编写多个状态机，但我强烈建议你将任何给定的Verilog或VHDL文件的范围限制为一个状态机。当你把两个或更多的状态机放在同一个文件里时，它们很容易逻辑上交织在一起。虽然将其分解为多个文件可能需要更多的输入，但它将在调试阶段节省时间。
- en: '**Use the single-block approach.**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用单块方法。**'
- en: As I’ve stated, I find that it’s easier to write cleaner and less error-prone
    state machines if you only have one <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp> block to worry
    about, rather than two. The one-block approach also avoids the need for combinational
    <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    blocks, which can generate latches if you’re not careful.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我所说，我发现如果只有一个<samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块需要关注，而不是两个，会更容易写出更干净、出错更少的状态机。这种单块方法还避免了需要组合性<samp
    class="SANS_TheSansMonoCd_W5Regular_11">always</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块的情况，如果不小心，可能会生成锁存器。
- en: '**Give your states meaningful names.**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**为你的状态命名有意义的名称。**'
- en: It’s much easier to read a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement that has actual words associated with each of the cases, provided you’ve
    named your states thoughtfully. For example, use descriptive names like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IDLE</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">START_COUNT</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>,
    and so on, rather than generic names like <samp class="SANS_TheSansMonoCd_W5Regular_11">S0</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">S2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">S3</samp>. Meaningful state
    names will help other people reading the code understand what’s going on. Additionally,
    you’ll thank yourself for descriptive state naming when you come back to your
    code after not looking at it for months. Enumeration allows you to do this. Enumeration
    is a common programming technique that allows you to use words in place of integers
    in your code. This is done either through <samp class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp>
    in Verilog or a user-defined type in VHDL.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读一个包含实际单词的<samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>语句要容易得多，前提是你为你的状态命名时考虑周到。例如，使用描述性的名称，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IDLE</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">START_COUNT</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOCKED</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">UNLOCKED</samp>等，而不是像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">S0</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">S1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">S2</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">S3</samp>这类通用名称。具有意义的状态名称可以帮助其他阅读代码的人理解发生了什么。此外，当你几个月后重新回到自己的代码时，你会感谢自己为状态命名时的描述性命名。枚举允许你做到这一点。枚举是一种常见的编程技术，它允许你在代码中用单词代替整数。这可以通过Verilog中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">localparam</samp>或VHDL中的用户定义类型来实现。
- en: '**Draw your state machine flow before coding.**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**在编码之前绘制状态机流程。**'
- en: Diving headfirst into coding a state machine is a recipe for disaster. Begin
    by drawing a diagram of the state machine that you want to implement, like the
    one you saw in [Figure 8-1](#fig8-1). This will help you ensure that you’ve thought
    through the entire flow, from the initial transition through all the possible
    permutations. If you realize that you’ve missed something once you start working
    on the code, that’s fine; just be sure to go back and update your diagram to keep
    it in sync with the code you’re writing. Your future self will thank you if you
    have this documentation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: It is by no means mandatory to follow these suggestions, but doing so will help
    you avoid some common pitfalls and create state machines within your FPGAs that
    are bug-free, easy to understand, and easy to maintain. The more complex your
    state machines become, the more helpful these best practices will be.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #6: Creating a Memory Game</samp>'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll now put what you’ve learned about state machines into action by creating
    a memory game that runs on your development board. The player will have to remember
    and reproduce a pattern that grows longer as the game progresses, similar to a
    game like Simon. If the player can remember the entire pattern, they win.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The pattern is displayed using four LEDs. It starts simply, with just one LED
    lighting up. Then it’s the player’s turn to re-create the pattern by pressing
    the switch that matches the LED. If they push the wrong switch, the game is over.
    If they push the correct switch, the game continues, with the pattern expanding
    to a sequence of two LED blinks. The pattern keeps expanding until it’s seven
    blinks long (although you’ll be able to adjust the code to make it longer if you
    want). If the player re-creates the last pattern correctly, they may choose to
    play another round with a new pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'This project takes advantage of a peripheral that we haven’t used before: a
    *seven-segment display*. This device uses an arrangement of seven LEDs to display
    the digits 0 through 9 (and a selection of letters), like something you’d see
    on a digital clock. It will serve as a scoreboard, keeping track of the player’s
    progress through the pattern. We’ll also use it to display an F (for *failure*)
    if the player makes a mistake, or an A when the game is won.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '*If your development board doesn’t have four LEDs and switches, you can adapt
    the project’s code to work with the resources available. If it doesn’t have a
    seven-segment display, try connecting one to your board, for example using a Pmod
    connector.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning the State
    Machine</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the game, we’ll need to control the FPGA’s flow through various states
    of operation, such as displaying the pattern and waiting for the player’s response.
    Sounds like a perfect opportunity to use a state machine! In keeping with our
    best practices, we’ll use a diagram to plan out the state machine before we write
    any code. [Figure 8-3](#fig8-3) shows a diagram for a state machine that satisfies
    the description of the game.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-3.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: The memory game
    state machine diagram</samp>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the top-left corner, we have a reset/initial condition, which
    will jump into the Start state from any other state. I didn’t draw arrows from
    every state back to Start, to avoid cluttering the diagram; just remember that
    you can always jump back to Start from any state when the reset condition occurs.
    We remain in the Start state until the reset is cleared, at which point we transition
    into the Pattern Off state. We wait here with all LEDs off for a set amount of
    time, and then we transition into the Pattern Show state, where we illuminate
    a single LED from the pattern, again for a set amount of time. If it’s the last
    LED in the pattern (the pattern is done), we then transition to the Wait Player
    state to await the player’s response. If the LED pattern is not done, we transition
    back to Pattern Off. We keep cycling between Pattern Show and Pattern Off, lighting
    up the LEDs in the pattern one at a time, until the pattern is done. The transitions
    back to Pattern Off add a pause between each blink, which avoids ambiguity in
    cases where the pattern includes the same LED twice in a row. This is the part
    of the game where the LED pattern is being shown to the player, for them to try
    to re-create later on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '*The diamond in the diagram between the Pattern Show and Wait Player states
    represents a* guard condition*, a Boolean expression that determines the state
    machine flow. In this case, the guard condition is checking whether the pattern
    is done.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Once we’re in the Wait Player state, the FPGA monitors the input from the buttons
    until one of two things happens. If the player pushes an incorrect button in the
    sequence, then we transition to the Loser state and show an F on the seven-segment
    display. If the player successfully re-creates the entire pattern, then we transition
    to the Incr Score (Increment Score) state. Here we check if the game is done,
    in which case the player has won and we transition to the Winner state, where
    we show an A on the seven-segment display. If the game isn’t done, then we go
    back to Pattern Off to get ready to display the pattern again, this time with
    one additional LED blink added to the sequence.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: There are nearly endless possibilities for designing state machines, so by no
    means is the arrangement shown in [Figure 8-3](#fig8-3) the only option. For example,
    we could have combined Pattern Off and Pattern Show into a single state that handles
    turning the LEDs both on and off. Our design, however, strikes a balance between
    the number of states and the complexity of each individual state. As a general
    rule, if one state is responsible for several actions, it might be an indication
    that the state should be broken into two or more states.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Organizing the Design</samp>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll take a look at the overall organization of the project. [Figure
    8-4](#fig8-4) shows a block diagram of the design.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-4.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: The Project #6
    block diagram</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Let’s trace the flow of data through the block diagram. First, we have four
    switches (buttons) that are used to control the entire game. Remember that these
    are mechanical switches, so they’re subject to bouncing. To get reliable button
    responses, these inputs must be debounced, which is the first thing that we do
    to each switch’s signal as it enters the FPGA. We’ll use the debounce filter module
    we implemented in [Chapter 5](chapter5.xhtml) for this. The FPGA also has a clock
    input, which we’ll use to drive all the flip-flops in this design.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the memory game module itself, which is where the state machine
    lives. We’ll explore this code in detail shortly. Notice that this module instantiates
    two submodules: <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    and the LFSR module, both of which you saw in [Chapter 6](chapter6.xhtml). Remember
    that LFSRs are pseudorandom pattern generators, so we’ll use one here to create
    a random pattern for the game. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module to keep track of how long to display each LED in the pattern sequence;
    the toggling of this module will trigger transitions between states.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp>
    module, which takes a binary input representing the player’s score and drives
    the seven-segment display to light up that score. We’ll look at how this works
    next.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Seven-Segment
    Display</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A seven-segment display consists of an arrangement of seven LEDs that can be
    lit in various combinations to produce different patterns. [Figure 8-5](#fig8-5)
    shows the seven segments of the display, labeled A through G. We’ll use one of
    these displays to keep track of the score in this project, incrementing it each
    time the player successfully repeats the pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-5.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A seven-segment
    display</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Conventionally, seven-segment displays are used to show the decimal numbers
    0 through 9, but we can extend our display’s range further by showing the hexadecimal
    numbers A through F (for 10 through 15) as well. We can’t simply tell the display
    to light up a particular number, however, since each segment in the display is
    controlled separately. Instead, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary
    _To_7Segment</samp> module takes in the number to be shown and translates it into
    the appropriate signals for driving the display. Let’s take a look at the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This module takes a 4-bit binary input ❶ and uses seven outputs to light up
    the appropriate segments in the display, given the input. The <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement ❷ captures all possible inputs, from <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp> (0 through 15), and
    translates each number into the correct output pattern using the 7-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>
    register. Each bit in the register maps to one of the segments in the display:
    bit 6 maps to segment A, bit 5 maps to segment B, and so on. To see how this works,
    let’s consider a specific input—say, <samp class="SANS_TheSansMonoCd_W5Regular_11">0111</samp>,
    which is the digit 7—as an example. [Figure 8-6](#fig8-6) illustrates how to illuminate
    a seven-segment display to show this digit.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure8-6.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: Illuminating a
    7 on a seven- segment display</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the figure, we need to illuminate segments A, B, and C, while
    keeping the other segments turned off, to show the digit 7\. In the code at ❸,
    we therefore set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x70</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">1110000</samp>
    in binary, putting 1s on the three bits corresponding to segments A, B, and C.
    Then, outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement,
    we extract each individual bit from the register and pass it to the appropriate
    output using a continuous assignment ❹. This approach of encoding the pattern
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Hex_Encoding</samp> register
    saves a lot of typing; we don’t have to assign all seven outputs in every single
    branch of the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coding the Top-Level
    Module</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s jump into the top module of the project to see how everything is
    wired up at the highest level. If you refer back to the block diagram in [Figure
    8-4](#fig8-4), you’ll see this module represented by the square with the dotted
    line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: My goal for writing the top module of a design, especially as the design becomes
    more complicated, is to minimize the amount of functional code within it. Ideally,
    code that performs functionality should be pushed into lower levels, so the highest
    level is just wires and module instantiation. This helps keep the code clean and
    ensures that each module is focused on performing what’s needed of it, without
    spreading the functionality across multiple layers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we first instantiate four debounce filter modules, one for
    each push button ❷. Then we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>
    module, which contains the logic for the state machine and the game itself ❸.
    The inputs to this module, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Switch_4</samp>, are the
    outputs of the debounce filters, so this module can trust that the input signals
    are stable. Notice that the module has two parameters (Verilog) or generics (VHDL),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>,
    both of which were set earlier ❶. The former specifies the number of clock cycles
    per second (needed for keeping track of time), and is there in case the design
    is run at a different clock frequency. The latter controls the maximum length
    of the pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Next we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary_To_7Segment</samp>
    module ❹, which takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Score</samp>
    output from the game as an input so the score will be displayed to the player.
    Notice, however, that we invert all the outputs from the display module before
    outputting them at the top level ❺. A low on the output may be needed, rather
    than a high, to light up each segment, depending on the way the seven-segment
    display is connected on your development board’s PCB. If your display isn’t behaving
    as expected, try removing the <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>s
    from the Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp>s
    from the VHDL to avoid inverting the outputs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Our top-level module doesn’t instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp> modules
    directly: those are instantiated within the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp>
    module. You’re starting to see here how a hierarchy can be established inside
    an FPGA, and how a complex design can be built up from relatively simple modules.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coding the State
    Machine</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s get to the meat of the project: the state machine itself. We’ll examine
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module
    in sections, but remember that you can view the complete code listing in the book’s
    GitHub repository ([*https://<wbr>github<wbr>.com<wbr>/nandland<wbr>/getting<wbr>-started<wbr>-with<wbr>-fpgas*](https://github.com/nandland/getting-started-with-fpgas)).
    The module starts, as usual, by declaring the inputs, outputs, and internal signals:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use the enumeration approach described earlier in the chapter to name each
    state ❶. The <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> signal
    ❷ will keep track of the current state. It needs to have enough bits to convey
    all the possible states. In this case, we have seven total states, which can fit
    inside a 3-bit-wide register. In Verilog, we explicitly declare the signal as
    having 3 bits. In VHDL, however, we just create the state machine signal to be
    of the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">t_SM_Main</samp> data
    type (the enumeration that we created ❶), and it will be sized automatically.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Another important signal we’re creating is <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>,
    which stores the pattern for the game ❸. This is the second time that we’ve created
    a two-dimensional signal within our FPGA (the first time was back in [Chapter
    6](chapter6.xhtml), when we were creating RAM). Specifically, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    is 2 bits wide by 11 items deep, for a total storage of 22 bits. Each pair of
    bits in this signal corresponds to one of the four LEDs (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    indicates LED1, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> indicates
    LED2, and so on), giving us a sequence of LEDs to light up (and a sequence of
    switches to press). [Table 8-1](#tab8-1) shows an example of what the data in
    this 2D register might look like.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp> <samp class="SANS_Futura_Std_Book_11">Pattern
    Storage Example</samp>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Index</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">LED/switch</samp> |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">6</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp> |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>
    | <samp class="SANS_Futura_Std_Book_11">4</samp> |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    | <samp class="SANS_Futura_Std_Book_11">1</samp> |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    | <samp class="SANS_Futura_Std_Book_11">3</samp> |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: In this example, the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, which correlates to
    the second LED/switch, the value at index <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>, which correlates to
    the fourth LED/switch, and so on. We’ll be able to use the index to increment
    through the register, getting 2 bits for each index. The binary pattern itself
    comes from the LFSR, and will be random each time. The LFSR is 22 bits wide, so
    each bit of the LFSR output is mapped to a bit in this 2D register. This means
    that the maximum length of the memory pattern that we can create is 11 LED blinks
    long. After playing this game several times, however, I can tell you that it gets
    quite challenging to remember patterns that go that high. As I noted earlier,
    the actual limit for the game is set by the parameter/generic <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>,
    which can be overridden from the top module. If you want to set the game to the
    maximum difficulty, try changing <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">11</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The module continues by handling reset conditions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The player must push switch 1 and switch 2 at the same time to trigger the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">START</samp> state. We check for this
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement ❶. Notice
    that this check occurs outside the state machine’s main <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement, which we initiate in the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    branch ❷. This means that on every clock cycle we’ll check if both switches are
    pressed, and enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    state if they are or run the state machine for the game if they aren’t. It would
    have been easier if we had a fifth button that was dedicated to resetting the
    state machine, but alas, I did not, so I had to be a bit creative here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the first few states in the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First we handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    state ❶, where we wait for the reset condition to be removed. This happens when
    switches 1 and 2 are released ❷. Notice that we’re looking not only for a low
    on the two switches, but also for a high on <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>.
    We use this signal throughout the module to detect falling edges—that is, releases—on
    the four switches. You’ll see how this works later in the code. When the reset
    is cleared, we set the score and the pattern index to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    then go into the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state
    ❸ simply waits for a timer, driven by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And
    _Toggle</samp> module, to expire. When this happens we transition to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN _SHOW</samp> state ❹, during which
    we’ll be illuminating one of the LEDs (you’ll see the code for illuminating the
    LEDs later). The transition out of <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>
    is also triggered by the timer in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module. When the timer expires we need to decide if we’re done displaying the
    pattern, which we do by checking whether the player’s score (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>)
    equals the current index into the pattern (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>)
    ❺. If it doesn’t, we aren’t done, so we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>
    to get ready to light up the next LED in the pattern ❼ and we go back to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> state. If we are done,
    we reset <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp> ❻ and transition to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> state. Let’s look at
    that now:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp> state,
    we wait for <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp> to
    go high, indicating the player has pressed and released a switch ❶. Then we check
    if the player has correctly pressed the next switch in the pattern. As you’ll
    see later, each time any switch is released, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    is set to indicate which switch it was (<samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    for switch 1, <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> for switch
    2, and so on), so we compare <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    with a value in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> as an index
    into the 2D array. There are three possibilities. If the switch is correct and
    we’re at the end of the pattern ❷, we reset <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>
    and transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>
    state. If the switch is incorrect, we transition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp>
    state ❹. Otherwise, the switch is correct but we aren’t done with the pattern,
    so we increment <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp> and
    wait for the next press ❺. Notice in this last case that we don’t explicitly assign
    the state, so <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp> will
    just retain its previous assignment (<samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>).
    We could add a line at the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    statement that says <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER;</samp>
    but it’s not necessary. If <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    isn’t assigned, then we know that path doesn’t cause a state change.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: One difference between the Verilog and the VHDL is that in the latter we need
    to be very explicit about the types we’re comparing. In the VHDL only, we need
    to cast <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> type ❸ so that we can
    compare it to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>, which
    is also of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>.
    Verilog is much more forgiving, so we don’t need this extra conversion. We’ll
    discuss numerical data types in detail in [Chapter 10](chapter10.xhtml).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the remaining states in the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp> ❶, we increment
    the score variable and compare it with <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>
    to check if the game is over. If so, we go to the <samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp>
    state, and if not, we go back to <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    to continue the memory sequence. Notice that we’ll only be in this state for a
    single clock cycle. You could perhaps make the argument that <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>
    isn’t a necessary state, and that this logic should happen in <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>
    instead. I chose to treat <samp class="SANS_TheSansMonoCd_W5Regular_11">INCR_SCORE</samp>
    as a separate state to avoid making <samp class="SANS_TheSansMonoCd_W5Regular_11">WAIT_PLAYER</samp>
    too complicated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For the <samp class="SANS_TheSansMonoCd_W5Regular_11">WINNER</samp> ❷ and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LOSER</samp> ❸ states, we simply set the
    score value to show an A or F on the seven-segment display and remain in the current
    state. The state machine can only leave these states in the event of a reset condition,
    in which switches 1 and 2 are both pressed at the same time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We also include a default clause at the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement ❹, which specifies what behavior to take in the event that <samp class="SANS_TheSansMonoCd_W5Regular_11">r_SM_Main</samp>
    isn’t one of the previously defined states. This shouldn’t ever happen, but it’s
    good practice to create a default case where we go back to <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp> statements at the
    end of this listing close out the <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>
    statement, <samp class="SANS_TheSansMonoCd_W5Regular_11">if…else</samp> statement,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">always</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block that the state machine was wrapped in.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve now finished coding the state machine itself. The rest of the code in
    the module handles logic for helping with the tasks that occur during the various
    states. First we have the code for randomly generating the pattern:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We need to generate a different pattern each time the game is played, while
    also making sure the pattern gets “locked in” once the game is underway. To do
    this, we first check if we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    state ❶. If so, the game isn’t currently in progress, so we use the LFSR to create
    a new pattern. Recall that the output of our LFSR is a pseudorandom string of
    bits, which changes on every clock cycle. We take 2-bit sections from the LFSR
    output and place them into the 11 slots in <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>.
    This will keep happening every clock cycle until the player releases switches
    1 and 2, triggering the transition out of <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>.
    At that point, the current values of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    will be locked in for the duration of the game.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In VHDL, we also need to create an intermediary signal, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Index_SLV</samp>
    ❷, which is just the <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp>
    representation of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Index</samp>.
    Again, since VHDL is strongly typed, you’ll often see intermediary signals used
    for generating the “correct” signal types. I could have put this line anywhere
    since it’s a combinational assignment; as long as it’s outside of a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block, its precise location in the file makes no functional difference.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the code for illuminating the four LEDs:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we have four continuous assignment statements, one for each LED. In each
    one, we use the ternary operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>)
    in Verilog or <samp class="SANS_TheSansMonoCd_W5Regular_11">when/else</samp> in
    VHDL to illuminate the LED in one of two cases. First, we’ll drive the LED high
    if we’re in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>
    state and the value at the current index of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Pattern</samp>
    matches the current LED. This will only ever be true for one LED at a time, so
    only one LED can be illuminated during each <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>.
    Second, if we aren’t in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>
    state, the LED will be driven based on the input from its associated switch. This
    way the LED will light up when the player presses the corresponding switch, giving
    them visual feedback about the pattern they’re entering.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the code uses falling edge detection to identify timeouts
    and button presses:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice we are still using the rising edge of the clock; we’re just looking for
    falling edges for our timeouts and button presses. Recall that this falling edge
    is used to progress through the state machine. We perform falling edge detection
    on the output of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module, where the output represents the timer expiring. We do this by first registering
    its output, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp>, and
    assigning it to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>
    ❶. (The actual instantiation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module will be handled momentarily.) This creates a one-clock-cycle-delayed version
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp> on <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>.
    Then, as shown previously, we look for the condition where the current value (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Toggle</samp>) is low, but the previous
    value (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Toggle</samp>) is high.
    We used this earlier to trigger transitions out of <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp>.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: For our switches, when a switch is pressed, it has the value 1; when a switch
    is not pressed, it has the value 0\. We are looking for the situation in which
    the switch goes from a 1 to a 0, which is the falling edge of the switch, representing
    the switch being released. We register each switch ❷ in order to detect the falling
    edge from the switch being released. This is followed by the actual edge detection
    logic ❸. For each switch, when we see a falling edge, we drive <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>
    high. As you’ve seen elsewhere in the code, this signal serves as a flag to indicate
    that some switch, any switch, has been released. We also set <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp>
    to the switch’s 2-bit binary code, so we’ll know which switch it was. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement ❹ clears <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_DV</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Button_ID</samp> to get ready
    for the next falling edge.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve chosen to make the state machine react to button releases rather than
    button presses. You could try inverting the test cases* ❸ *to see the difference.
    I think you’ll find it a bit unnatural if the game responds the moment a button
    is pressed instead of the moment it’s released.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The final section of the code instantiates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp> modules. Remember,
    you’ve seen the code for these modules before, in [Chapter 6](chapter6.xhtml):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Count_And_Toggle</samp>
    module ❷. As you saw in [Chapter 6](chapter6.xhtml), it measures out a set amount
    of time by incrementing a register on each clock cycle until it reaches the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp> parameter/generic.
    Here we’ve set <samp class="SANS_TheSansMonoCd_W5Regular_11">COUNT_LIMIT</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp> to make
    each <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> state last a quarter
    of a second, but feel free to change this to make the game run faster or slower.
    Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">CLKS_PER_SEC/4</samp>
    is a constant (in this case, 25,000,000 / 4 = 6,250,000) that the synthesis tools
    will calculate in advance, so the division operation (which would require a lot
    of resources) won’t have to be performed inside the FPGA itself. The continuous
    assignment of <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Count_En</samp>
    ❶ only enables the counter during the <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> states,
    since we don’t want it running during other phases of the game.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we instantiate the <samp class="SANS_TheSansMonoCd_W5Regular_11">LFSR_22</samp>
    module ❸. Recall from [Chapter 6](chapter6.xhtml) that this module has two outputs:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Data</samp> for the data
    itself, and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp> to
    signal each repetition of the LFSR’s cycle. For this project we don’t need <samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LFSR_Done</samp>, so we leave the unused
    output unconnected in Verilog, or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">open</samp>
    keyword in VHDL ❹. When we write general-purpose modules like this, we won’t always
    need every single output in every single application. When we don’t use an output,
    the synthesis tools are intelligent enough to remove the associated logic, so
    there’s no hit to our resource utilization when we have unused code.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in VHDL we need to perform one more action: converting <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Score</samp>,
    which is an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> type,
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">std_logic_vector</samp> so
    we can assign that value to <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Score</samp>
    ❺. Because VHDL is strongly typed, you’ll frequently see type conversions like
    this when looking at VHDL code.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Memory
    Game</samp>
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code and state machine diagram that we’ve been looking at here represent
    the final version of this game, but it went through some improvements and fixes
    as I developed it. A lot of the changes were a result of me actually playing the
    game and experimenting to see what I liked and didn’t like. For example, when
    I was first designing the state machine, I went straight from <samp class="SANS_TheSansMonoCd_W5Regular_11">START</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_SHOW</samp> without passing
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">PATTERN_OFF</samp>. This
    made the first LED come on immediately, which was confusing; it was hard to tell
    whether the game had started or not. So, I switched the order to add a delay at
    the outset.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the changes that I made followed this same pattern: program the board,
    play the game, see behavior I don’t like, change the code, play the game. Another
    example is that the LED on-time was too long initially, so I decreased it to make
    the gameplay snappier. These sorts of issues are more about feel; running a simulation
    wouldn’t have identified them.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Simulations and testbenches are valuable for understanding where and why bugs
    are occurring and how to fix them. Most of my “problems” weren’t bugs, but behaviors
    that I wanted to change based on my experience playing the game. I did create
    a testbench that allowed me to simulate button presses, however, to see how the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">State_Machine_Game</samp> module
    responded. That code is available in the book’s GitHub repository, if you’d like
    to look at it. It’s a simple testbench, not one that performs any self-checking,
    but it did help me find a few bugs when I was initially writing this state machine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Pin Constraints</samp>
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we’ve added a new interface at the highest level (the seven-segment display),
    we need to add those signals to our physical constraints file. If we forget this
    step, the place and route tool will likely automatically choose pins for us, which
    will almost certainly be incorrect. You’ll have to refer to the schematic for
    your development board to trace the signal paths from the seven-segment display
    back to your FPGA for each signal. Here are the constraints needed for the Go
    Board, for example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See [Chapter 2](chapter2.xhtml) for a reminder on how to add physical constraints
    to your iCEcube2 project.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we’re ready to build the code for the FPGA. Let’s take a look
    at the synthesis results of both the Verilog and the VHDL. Your report should
    look similar to the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The results are pretty close between the Verilog and VHDL versions; we’re using
    about 12 percent of the available flip-flops and 18 percent of the available LUTs
    for this project. We have an entire memory game consisting of a few hundred lines
    of code, and we’ve used less than 20 percent of the FPGA’s main resources. Not
    bad!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Program your development board and play the game. See if you can beat it, and
    if you can, try increasing the difficulty by changing <samp class="SANS_TheSansMonoCd_W5Regular_11">GAME_LIMIT</samp>
    up to its maximum difficulty of 11\. I found it quite challenging!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter you’ve learned about state machines, which are critical building
    blocks in many programming disciplines, including FPGAs. State machines are used
    to precisely control the flow through a sequence of operations. The operations
    are organized into a network of states, with events that trigger transitions between
    those states. After reviewing a simple example, you designed and implemented a
    sophisticated state machine to control a memory game for your development board.
    The project combined many elements that we’ve discussed throughout the book, including
    debounce logic to clean up the inputs from the switches, an LFSR for pseudorandom
    number generation, and a counter to keep track of time. You also learned to use
    a seven-segment display to create the game’s scoreboard.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
