<html><head></head><body><section class="chapter" title="Chapter&#xA0;10.&#xA0;Building Data-Driven Web Applications: Part 2" epub:type="chapter" id="building_data-driven_web_applica-id00044"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Building Data-Driven Web Applications: Part 2</h2></div></div></div><p>In <a class="xref" href="ch09.html" title="Chapter 9. Building Data-Driven Web Applications: Part 1">Chapter 9</a>, we set up the framework of our web application and walked through the visualizations that will be displayed for each view. But before our web application is complete, we have several other details to attend to. First, we have to make the web application communicate with the Nike+ service and <a id="iddle1059" class="indexterm"/><a id="iddle1064" class="indexterm"/><a id="iddle1984" class="indexterm"/><a id="iddle2130" class="indexterm"/>account for some quirks specific to that service. Then we’ll work on making our application easier to navigate. In this chapter we’ll look at the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>How to connect application models with an external REST API</p></li><li class="listitem"><p>How to support web browser conventions in a single-page application</p></li></ul></div><div class="sect1" title="Connecting with the Nike+ Service"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="connecting_with_the_nikeplus_service">Connecting with the Nike+ Service</h2></div></div></div><p>Although our example application relies on the Nike+ service for its data, we haven’t looked at the details of that service’s interface. As I’ve mentioned, Nike+ doesn’t quite conform to common REST API conventions that application libraries such as Backbone.js expect. But Nike+ isn’t very unusual in that regard. There really isn’t a true <span class="emphasis"><em>standard</em></span> for REST APIs, and many other services take approaches similar to Nike+’s. Fortunately Backbone.js anticipates this variation. As we’ll see in the following steps, extending Backbone.js to support REST API variations isn’t all that difficult.</p><div class="sect2" title="Step 1: Authorize Users"><div class="titlepage"><div><div><h3 class="title" id="step_1_authorize_users">Step 1: Authorize Users</h3></div></div></div><p>As you might expect, Nike+ doesn’t allow anyone on the Internet to retrieve details for any user’s runs. Users expect at least some level of privacy for that information. Before our app can retrieve any running information, therefore, it will need the user’s permission. We won’t go into the details of that process here, but its result will be an <code class="literal">authorization_token</code>. This object is an arbitrary string that our app will have to include with every Nike+ request. If the token is missing or invalid, Nike+ will deny our app access to the data.</p><p>Up until now we’ve let Backbone.js handle all of the details of the REST API. Next, we’ll have to modify how Backbone.js constructs its AJAX calls. Fortunately, this isn’t as tricky as it sounds. All we need to do is add a <code class="literal">sync()</code> method to our Runs collection. When a <code class="literal">sync()</code> method is present in a collection, Backbone.js calls it whenever it makes an AJAX request. (If there is no such method for a collection, Backbone.js calls its primary <code class="literal">Backbone.sync()</code> method.) We’ll define the new method directly in the collection.</p><a id="pro_id00550"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="olive">extend</span>({

    <span class="dodgerblue">sync</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(method, collection, options) {
        <span class="indianred"><span class="emphasis"><em>// Handle the AJAX request</em></span></span>
    }</pre><p>As you can see, <code class="literal">sync()</code> is passed a <code class="literal">method</code> (<code class="literal">GET</code>, <code class="literal">POST</code>, etc.), the collection in question, and an object containing options for the request. To send the authorization token to Nike+, we can add it as a parameter using this <code class="literal">options</code> object.</p><a id="pro_id00551"/><pre class="programlisting">sync: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(method, collection, options) {
    options = options || {};
    <span class="olive">_</span>(options).<span class="olive">extend</span>({
        <span class="dodgerblue">data</span>: { <span class="dodgerblue">authorization_token</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">authorization_token</span> }
    });
    <span class="steelblue">Backbone</span>.<span class="olive">sync</span>(method, collection, options);
}</pre><p><a id="iddle1242" class="indexterm"/><a id="iddle1321" class="indexterm"/><a id="iddle1489" class="indexterm"/><a id="iddle1728" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle1883" class="indexterm"/>The first line in the method makes sure that the <code class="literal">options</code> parameter exists. If the caller doesn’t provide a value, we set it to an empty object (<code class="literal">{}</code>). The next statement adds a <code class="literal">data</code> property to the <code class="literal">options</code> object using the <code class="literal">extend()</code> utility from Underscore.js. The <code class="literal">data</code> property is itself an object, and in it we store the authorization token. We’ll look at how to do that next, but first let’s finish up the <code class="literal">sync()</code> method. Once we’ve added the token, our request is a standard AJAX request, so we can let Backbone.js take it from there by calling <code class="literal">Backbone.sync()</code>.</p><p>Now we can turn our attention to the <code class="literal">settings</code> object from which our <code class="literal">sync()</code> method obtained the authorization token. We’re using that object to hold properties related to the collection as a whole. It’s the collection’s equivalent of a model’s attributes. Backbone.js doesn’t create this object for us automatically, but it’s easy enough to do it ourselves. We’ll do it in the collection’s <code class="literal">initialize()</code> method. That method accepts two parameters: an array of models for the collection, and any collection options.</p><a id="pro_id00552"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="olive">extend</span>({

    <span class="dodgerblue">initialize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(models, options) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span> = { <span class="dodgerblue">authorization_token</span>: <span class="maroon">""</span> };
        options = options || {};
        <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span>).<span class="olive">extend</span>(<span class="olive">_</span>(options)
            .<span class="olive">pick</span>(_(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span>).<span class="olive">keys</span>()));
    },</pre><p>The first statement in the <code class="literal">initialize()</code> method defines a <code class="literal">settings</code> object for the collection and establishes default values for that object. Since there isn’t an appropriate default value for the authorization token, we’ll use an empty string.</p><p>The next statement makes sure that the <code class="literal">options</code> object exists. If none is passed as a parameter, we’ll at least have an empty object.</p><p>The final statement extracts all the keys in the settings, finds any values in the <code class="literal">options</code> object with the same keys, and updates the <code class="literal">settings</code> object by extending it with those new key values. Once again, we take advantage of some Underscore.js utilities: <code class="literal">extend()</code> and <code class="literal">pick()</code>.</p><p>When we first create the Runs collection, we can pass the authorization token as a parameter. We supply an empty array as the first parameter because we don’t have any models for the collection. Those will come from Nike+. In the following code fragment, we’re using a dummy value for the authorization token. A real application would use code that Nike provides to get the true value.</p><a id="pro_id00553"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> runs = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([], {
    <span class="dodgerblue">authorization_token</span>: <span class="maroon">"authorize me"</span>
});</pre><p><a id="iddle1066" class="indexterm"/><a id="iddle1071" class="indexterm"/><a id="iddle1243" class="indexterm"/><a id="iddle1737" class="indexterm"/><a id="iddle2133" class="indexterm"/><a id="iddle2142" class="indexterm"/>With just a small bit of extra code, we’ve added the authorization token to our AJAX requests to Nike+.</p></div><div class="sect2" title="Step 2: Accept the Nike+ Response"><div class="titlepage"><div><div><h3 class="title" id="step_2_accept_the_nikeplus_response">Step 2: Accept the Nike+ Response</h3></div></div></div><p>When our collection queries Nike+ for a list of user activities, Backbone.js is prepared for a response in a particular format. More specifically, Backbone.js expects the response to be a simple array of models.</p><a id="pro_id00554"/><pre class="programlisting">[
  { <span class="maroon">"activityId"</span>: <span class="maroon">"2126456911"</span>, <span class="indianred"><span class="emphasis"><em>/* Data continues... */</em></span></span> },
  { <span class="maroon">"activityId"</span>: <span class="maroon">"2125290225"</span>, <span class="indianred"><span class="emphasis"><em>/* Data continues... */</em></span></span> },
  { <span class="maroon">"activityId"</span>: <span class="maroon">"2124784253"</span>, <span class="indianred"><span class="emphasis"><em>/* Data continues... */</em></span></span> },
  <span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span>
]</pre><p>In fact, however, Nike+ returns its response as an object. The array of activities is one property of the object.</p><a id="pro_id00555"/><pre class="programlisting">{
  <span class="maroon">"data"</span>: [
    { <span class="maroon">"activityId"</span>: <span class="maroon">"2126456911"</span>, <span class="indianred"><span class="emphasis"><em>/* Data continues... */</em></span></span> },
    { <span class="maroon">"activityId"</span>: <span class="maroon">"2125290225"</span>, <span class="indianred"><span class="emphasis"><em>/* Data continues... */</em></span></span> },
    { <span class="maroon">"activityId"</span>: <span class="maroon">"2124784253"</span>, <span class="indianred"><span class="emphasis"><em>/* Data continues... */</em></span></span> },
    <span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span>
  ],
  <span class="indianred"><span class="emphasis"><em>// Response continues...</em></span></span>
}</pre><p>To help Backbone.js cope with this response, we add a <code class="literal">parse()</code> method to our collection. The job of that function is to take the response that the server provides and return the response that Backbone.js expects.</p><a id="pro_id00556"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="olive">extend</span>({

    <span class="dodgerblue">parse</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(response) {
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">response</span>.<span class="olive">data</span>;
    },</pre><p>In our case, we just return the <code class="literal">data</code> property of the response.</p></div><div class="sect2" title="Step 3: Page the Collection"><div class="titlepage"><div><div><h3 class="title" id="step_3_page_the_collection">Step 3: Page the Collection</h3></div></div></div><p>The next aspect of the Nike+ API we’ll tackle is its paging. When we request the activities for a user, the service doesn’t normally return <span class="emphasis"><em>all</em></span> of them. Users may have thousands of activities stored in Nike+, and returning all of them at once might overwhelm the app. It could certainly add a noticeable delay, as the app would have to wait for the entire response before it could process it. To avoid this <a id="iddle1169" class="indexterm"/><a id="iddle1716" class="indexterm"/><a id="iddle1985" class="indexterm"/>problem, Nike+ divides user activities into pages, and it responds with one page of activities at a time. We’ll have to adjust our app for that behavior, but we’ll gain the benefit of a more responsive user experience.</p><p>The first adjustment we’ll make is in our request. We can add parameters to that request to indicate how many activities we’re prepared to accept in the response. The two parameters are <code class="literal">offset</code> and <code class="literal">count</code>. The <code class="literal">offset</code> tells Nike+ which activity we want to be first in the response, while <code class="literal">count</code> indicates how many activities Nike+ should return. If we wanted the first 20 activities, for example, we can set <code class="literal">offset</code> to <code class="literal">1</code> and <code class="literal">count</code> to <code class="literal">20</code>. Then, to get the next 20 activities, we’d set <code class="literal">offset</code> to <code class="literal">21</code> (and keep <code class="literal">count</code> at <code class="literal">20</code>).</p><p>We add these parameters to our request the same way we added the authorization token—in the <code class="literal">sync()</code> method.</p><a id="pro_id00557"/><pre class="programlisting">sync: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(method, collection, options) {
    options = options || {};
    <span class="olive">_</span>(options).<span class="olive">extend</span>({
        <span class="dodgerblue">data</span>: {
            <span class="dodgerblue">authorization_token</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">authorization_token</span>,
            <span class="dodgerblue">count</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">count</span>,
            <span class="dodgerblue">offset</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">offset</span>
        }
    });
    <span class="steelblue">Backbone</span>.<span class="olive">sync</span>(method, collection, options);
}</pre><p>We will also have to provide default values for those settings during initialization.</p><a id="pro_id00558"/><pre class="programlisting">initialize: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(models, options) {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span> = {
        <span class="dodgerblue">authorization_token</span>: <span class="maroon">""</span>,
        <span class="dodgerblue">count</span>: <span class="red">25</span>,
        <span class="dodgerblue">offset</span>: <span class="red">1</span>
    };</pre><p>Those values will get the first 25 activities, but that’s only a start. Our users will probably want to see all of their runs, not just the first 25. To get the additional activities, we’ll have to make more requests to the server. Once we get the first 25 activities, we can request the next 25. And once those arrive, we can ask for 25 more. We’ll keep at this until either we reach some reasonable limit or the server runs out of activities.</p><p>First we define a reasonable limit as another settings value. In the following code, we’re using <code class="literal">10000</code> as that limit.</p><a id="pro_id00559"/><pre class="programlisting">initialize: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(models, options) {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span> = {
        <span class="dodgerblue">authorization_token</span>: <span class="maroon">""</span>,
        <span class="dodgerblue">count</span>: <span class="red">25</span>,
        <span class="dodgerblue">offset</span>: <span class="red">1</span>,
        <span class="dodgerblue">max</span>: <span class="red">10000</span>
    };</pre><p><a id="iddle1113" class="indexterm"/><a id="iddle1323" class="indexterm"/><a id="iddle1331" class="indexterm"/><a id="iddle1738" class="indexterm"/>Next we need to modify the <code class="literal">fetch()</code> method for our collection since the standard Backbone.js <code class="literal">fetch()</code> can’t handle paging. There are three steps in our implementation of the method:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Save a copy of whatever options Backbone.js is using for the request.</p></li><li class="listitem"><p>Extend those options by adding a callback function when the request succeeds.</p></li><li class="listitem"><p>Pass control to the normal Backbone.js <code class="literal">fetch()</code> method for collections.</p></li></ol></div><p>Each of those steps is a line in the following implementation. The last one might seem a little tricky, but it makes sense if you take it one piece at a time. The expression <code class="literal">Backbone.Collection.prototype.fetch</code> refers to the normal <code class="literal">fetch()</code> method of a Backbone.js collection. We execute this method using <code class="literal">.call()</code> so that we can set the context for the method to be our collection. That’s the first <code class="literal">this</code> parameter of <code class="literal">call()</code>. The second parameter holds the options for <code class="literal">fetch()</code>, which are just the extended options we created in Step 2.</p><a id="pro_id00560"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="olive">extend</span>({

    <span class="dodgerblue">fetch</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(options) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span> = options = options || {};
        <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>).<span class="olive">extend</span>({ <span class="dodgerblue">success</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchMore</span> });
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(
            <span class="steelblue"><span class="strong"><strong>this</strong></span></span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>
        );
    },</pre><p>By adding a <code class="literal">success</code> callback to the AJAX request, we’re asking to be notified when the request completes. In fact, we’ve said that we want the <code class="literal">this.fetchMore()</code> function to be called. It’s time to write that function; it, too, is a method of the Runs collection. This function checks to see if there are more activities left. If so, it executes another call to Backbone.js’s regular collection <code class="literal">fetch()</code> just as in the preceding code.</p><a id="pro_id00561"/><pre class="programlisting">fetchMore: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">offset</span> &lt; <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">max</span>) {
        <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>);
    }
}</pre><p>Since <code class="literal">fetchMore()</code> is looking at the settings to decide when to stop, we’ll need to update those values. Because we already have a <code class="literal">parse()</code> method, and because Backbone calls this method with each response, that’s a convenient place for the update. Let’s add a bit of code before the return statement. If the number of activities that the server returns is less than the number we asked for, then we’ve <a id="iddle1324" class="indexterm"/><a id="iddle1332" class="indexterm"/><a id="iddle1805" class="indexterm"/>exhausted the list of activities. We’ll set the <code class="literal">offset</code> to the <code class="literal">max</code> so <code class="literal">fetchMore()</code> knows to stop. Otherwise, we increment <code class="literal">offset</code> by the number of activities.</p><a id="pro_id00562"/><pre class="programlisting">parse: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(response) {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue">response</span>.<span class="steelblue">data</span>.<span class="olive">length</span> &lt; <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">count</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">offset</span> = <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">max</span>;
    } <span class="steelblue"><span class="strong"><strong>else</strong></span></span> {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">offset</span> += <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">count</span>;
    }
    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">response</span>.<span class="olive">data</span>;
}</pre><p>The code we’ve written so far is almost complete, but it has a problem. When Backbone.js fetches a collection, it assumes that it’s fetching the whole collection. By default, therefore, each fetched response replaces the models already in the collection with those in the response. That behavior is fine the first time we call <code class="literal">fetch()</code>, but it’s definitely not okay for <code class="literal">fetchMore()</code>, which is meant to add to the collection instead of replacing it. Fortunately, we can easily tweak this behavior by setting the <code class="literal">remove</code> option.</p><p>In our <code class="literal">fetch()</code> method, we set that option to <code class="literal">true</code> so Backbone.js will start a new collection.</p><a id="pro_id00563"/><pre class="programlisting">fetch: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(options) {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span> = options = options || {};
    <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>).<span class="olive">extend</span>({
        <span class="dodgerblue">success</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchMore</span>,
        <span class="dodgerblue">remove</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span>
     });
    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>,
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>
    );
}</pre><p>Now, in the <code class="literal">fetchMore()</code> method, we can reset this option to <code class="literal">false</code>, and Backbone.js will add to models instead of replacing them in the collection.</p><a id="pro_id00564"/><pre class="programlisting">fetchMore: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">fetchoptions</span>.<span class="olive">remove</span> = <span class="steelblue"><span class="strong"><strong>false</strong></span></span>;
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">offset</span> &lt; <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">max</span>) {
        <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>);
    }
}</pre><p>There is still a small problem with the <code class="literal">fetchMore()</code> method. That code references properties of the collection (<code class="literal">this.fetchoptions</code> and <code class="literal">this.settings</code>), but the method will be called asynchronously when the AJAX request completes. When that occurs, the collection won’t be in context, so <code class="literal">this</code> won’t be set to the collection. To fix that, we can bind <code class="literal">fetchMore()</code> to the collection during initialization. Once again, an Underscore.js utility function comes in handy.</p><a id="pro_id00565"/><pre class="programlisting">initialize: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(models, options) {
    <span class="steelblue">_</span>.<span class="olive">bindAll</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>, <span class="maroon">"fetchMore"</span>);</pre><p><a id="iddle1076" class="indexterm"/><a id="iddle1325" class="indexterm"/><a id="iddle2150" class="indexterm"/>For the final part of this step, we can make our collection a little friendlier to code that uses it. To keep fetching additional pages, we’ve set the <code class="literal">success</code> callback for the <code class="literal">fetch()</code> options. What happens if the code that uses our collection has its own callback? Unfortunately, we’ve erased that callback to substitute our own. It would be better to simply set aside an existing callback function and then restore it once we’ve finished fetching the entire collection. We’ll do that first in our <code class="literal">fetch()</code> method. Here’s the full code for the method:</p><a id="pro_id00566"/><pre class="programlisting">fetch: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(options) {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span> = options = options || {};
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchsuccess</span> = <span class="steelblue">options</span>.<span class="olive">success</span>;
    <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>).<span class="olive">extend</span>({
        <span class="dodgerblue">success</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchMore</span>,
        <span class="dodgerblue">remove</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span>
        });
    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>,
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>
    );
}</pre><p>And here’s the code for <code class="literal">fetchMore()</code>:</p><a id="pro_id00567"/><pre class="programlisting">fetchMore: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">fetchoptions</span>.<span class="olive">remove</span> = <span class="steelblue"><span class="strong"><strong>false</strong></span></span>;
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">offset</span> &lt; <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">max</span>) {
        <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>);
    } <span class="steelblue"><span class="strong"><strong>else</strong></span></span> <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchsuccess</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchsuccess</span>();
    }
}</pre><p>Now we can execute that callback in <code class="literal">fetchMore()</code> when we’ve exhausted the server’s list.</p></div><div class="sect2" title="Step 4: Dynamically Update the View"><div class="titlepage"><div><div><h3 class="title" id="step_4_dynamically_update_the_view">Step 4: Dynamically Update the View</h3></div></div></div><p>By fetching the collection of runs in pages, we’ve made our application much more responsive. We can start displaying summary data for the first 25 runs even while we’re waiting to retrieve the rest of the user’s runs from the server. To do that effectively, though, we need to make a small change to our Summary view. As it stands now, our view is listening for any changes to the collection. When a change occurs, it renders the view from scratch.</p><a id="pro_id00568"/><pre class="programlisting">initialize: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> () {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">listenTo</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">collection</span>, <span class="maroon">"change"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">render</span>);
    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue"><span class="strong"><strong>this</strong></span></span>;
}</pre><p><a id="iddle1015" class="indexterm"/><a id="iddle1065" class="indexterm"/><a id="iddle1118" class="indexterm"/><a id="iddle1815" class="indexterm"/><a id="iddle2113" class="indexterm"/><a id="iddle2132" class="indexterm"/>Every time we fetch a new page of runs, the collection will change and our code will re-render the entire view. That’s almost certainly going to be annoying to our users, as each fetched page will cause the browser to temporarily blank out the page and then refill it. Instead, we’d like to render only views for the newly added models, leaving existing model views alone. To do that, we can listen for an <code class="literal">"add"</code> event instead of a <code class="literal">"change"</code> event. And when this event triggers, we can just render the view for that model. We’ve already implemented the code to create and render a view for a single Run model: the <code class="literal">renderRun()</code> method. Our Summary view, therefore, can be modified as shown here:</p><a id="pro_id00569"/><pre class="programlisting">initialize: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> () {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">listenTo</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">collection</span>, <span class="maroon">"add"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">renderRun</span>);
    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue"><span class="strong"><strong>this</strong></span></span>;
}</pre><p>Now as our collection fetches new Run models from the server, they’ll be added to the collection, triggering an <code class="literal">"add"</code> event, which our view captures. The view then renders each run on the page.</p></div><div class="sect2" title="Step 5: Filter the Collection"><div class="titlepage"><div><div><h3 class="title" id="step_5_filter_the_collection">Step 5: Filter the Collection</h3></div></div></div><p>Although our app is interested only in running, the Nike+ service supports a variety of athletic activities. When our collection fetches from the service, the response will include those other activities as well. To avoid including them in our app, we can filter them from the response.</p><p>We could filter the response manually, checking every activity and removing those that aren’t runs. That’s a lot of work, however, and Backbone.js gives us an easier approach. To take advantage of Backbone.js, we’ll first add a <code class="literal">validate()</code> method to our Run model. This method takes as parameters the attributes of a potential model as well as any options used when it was created or modified. In our case, we care only about the attributes. We’ll check to make sure the <code class="literal">activityType</code> equals <code class="literal">"RUN"</code>.</p><a id="pro_id00570"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Model</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">validate</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(attributes, options) {
        <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue">attributes</span>.<span class="steelblue">activityType</span>.<span class="olive">toUpperCase</span>() !== <span class="maroon">"RUN"</span>) {
            <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="maroon">"Not a run"</span>;
        }
    },</pre><p>You can see from this code how <code class="literal">validate()</code> functions should behave. If there is an error in the model, then <code class="literal">validate()</code> returns a value. The specifics of the value don’t matter as long as JavaScript considers it true. If there is no error, then <code class="literal">validate()</code> doesn’t need to return anything at all.</p><p>Now that our model has a <code class="literal">validate()</code> method, we need to make sure Backbone.js calls it. Backbone.js automatically checks with <code class="literal">validate()</code> whenever a model is created or modified by the code, but it doesn’t normally validate responses from the server. In our case, however, we do want to validate the server <a id="iddle1013" class="indexterm"/><a id="iddle1072" class="indexterm"/><a id="iddle1073" class="indexterm"/><a id="iddle1326" class="indexterm"/><a id="iddle2114" class="indexterm"/><a id="iddle2143" class="indexterm"/><a id="iddle2144" class="indexterm"/>responses. That requires that we set the <code class="literal">validate()</code> property in the <code class="literal">fetch()</code> options for our Runs collection. Here’s the full <code class="literal">fetch()</code> method with this change included.</p><a id="pro_id00571"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">fetch</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(options) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span> = options = options || {};
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchsuccess</span> = <span class="steelblue">options</span>.<span class="olive">success</span>;
        <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>).<span class="olive">extend</span>({
            <span class="dodgerblue">success</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchMore</span>,
            <span class="dodgerblue">remove</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span>,
            <span class="dodgerblue">validate</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span>
          });
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Backbone</span>.<span class="steelblue">Collection</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>,
          <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchoptions</span>
        );
    },</pre><p>Now when Backbone.js receives server responses, it passes all of the models in those responses through the model’s <code class="literal">validate()</code> method. Any model that fails validation is removed from the collection, and our app never has to bother with activities that aren’t runs.</p></div><div class="sect2" title="Step 6: Parse the Response"><div class="titlepage"><div><div><h3 class="title" id="step_6_parse_the_response">Step 6: Parse the Response</h3></div></div></div><p>As long as we’re adding code to the Run model, there’s another change that will make Backbone.js happy. Backbone.js requires models to have an attribute that makes each object unique; it can use this identifier to distinguish one run from any other. By default, Backbone.js expects this attribute to be <code class="literal">id</code>, as that’s a common convention. Nike+, however, doesn’t have an <code class="literal">id</code> attribute for its runs. Instead, the service uses the <code class="literal">activityId</code> attribute. We can tell Backbone.js about this with an extra property in the model.</p><a id="pro_id00572"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Model</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">idAttribute</span>: <span class="maroon">"activityId"</span>,</pre><p>This property lets Backbone.js know that for our runs, the <code class="literal">activityId</code> property is the unique identifier.</p></div><div class="sect2" title="Step 7: Retrieve Details"><div class="titlepage"><div><div><h3 class="title" id="step_7_retrieve_details">Step 7: Retrieve Details</h3></div></div></div><p>So far we’ve relied on the collection’s <code class="literal">fetch()</code> method to get running data. That method retrieves a list of runs from the server. When Nike+ returns a list of activities, however, it doesn’t include the full details of each activity. It returns summary information, but it omits the detailed metrics arrays and any GPS data. Getting those details requires additional requests, so we need to make one more change to our Backbone.js app.</p><p>We’ll first request the detailed metrics that are the basis for the Charts view. When the Runs collection fetches its list of runs from the server, each Run model will initially have an empty <code class="literal">metrics</code> array. To get the details for this array, we must <a id="iddle1014" class="indexterm"/><a id="iddle1148" class="indexterm"/><a id="iddle1327" class="indexterm"/><a id="iddle1490" class="indexterm"/>make another request to the server with the activity identifier included in the request URL. For example, if the URL to get a list of runs is <span class="emphasis"><em><a class="ulink" href="https://api.nike.com/v1/me/sport/activities/" target="_top">https://api.nike.com/v1/me/sport/activities/</a></em></span>, then the URL to get the details for a specific run, including its metrics, is <span class="emphasis"><em><a class="ulink" href="https://api.nike.com/v1/me/sport/activities/2126456911/" target="_top">https://api.nike.com/v1/me/sport/activities/2126456911/</a></em></span>. The number <span class="emphasis"><em>2126456911</em></span> at the end of that URL is the run’s <code class="literal">activityId</code>.</p><p>Thanks to the steps we’ve taken earlier in this section, it’s easy to get these details in Backbone.js. All we have to do is <code class="literal">fetch()</code> the model.</p><a id="pro_id00573"/><pre class="programlisting"><span class="steelblue">run</span>.<span class="olive">fetch</span>();</pre><p>Backbone.js knows the root of the URL because we set that in the Runs collection (and our model is a member of that collection). Backbone.js also knows that the unique identifier for each run is the <code class="literal">activityId</code> because we set that property in the previous step. And, fortunately for us, Backbone.js is smart enough to combine those bits of information and make the request.</p><p>We will have to help Backbone.js in one respect, though. The Nike+ app requires an authorization token for all requests, and so far we’ve added code for that token only to the collection. We have to add the same code to the model. This code is almost identical to the code from Step 1 in this section:</p><a id="pro_id00574"/><pre class="programlisting">   <span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Model</span>.<span class="olive">extend</span>({
       <span class="dodgerblue">sync</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(method, model, options) {
           options = options || {};
           <span class="olive">_</span>(options).<span class="olive">extend</span>({
               <span class="dodgerblue">data</span>: {
                   <span class="dodgerblue">authorization_token</span>:
➊                     <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">collection</span>.<span class="steelblue">settings</span>.<span class="olive">authorization_token</span>
               }
           });
           <span class="steelblue">Backbone</span>.<span class="olive">sync</span>(method, model, options);
       },</pre><p>We first make sure that the <code class="literal">options</code> object exists, then extend it by adding the authorization token. Finally, we defer to the regular Backbone.js <code class="literal">sync()</code> method. At ➊, we get the value for the token directly from the collection. We can use <code class="literal">this.collection</code> here because Backbone.js sets the <code class="literal">collection</code> property of the model to reference the collection to which it belongs.</p><p>Now we have to decide when and where to call a model’s <code class="literal">fetch()</code> method. We don’t actually need the metrics details for the Summary view on the main page of our app; we should bother getting that data only when we’re creating a Details view. We can conveniently do that in the view’s <code class="literal">initialize()</code> method.</p><a id="pro_id00575"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Details</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">View</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">initialize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> () {
        <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (!<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">model</span>.<span class="olive">get</span>(<span class="maroon">"metrics"</span>) ||
            <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">model</span>.<span class="olive">get</span>(<span class="maroon">"metrics"</span>).<span class="olive">length</span> === <span class="red">0</span>) {
            <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">model</span>.<span class="olive">fetch</span>();
        }
    },</pre><p><a id="iddle1328" class="indexterm"/><a id="iddle1491" class="indexterm"/><a id="iddle1675" class="indexterm"/><a id="iddle1813" class="indexterm"/>You might think that the asynchronous nature of the request could cause problems for our view. After all, we’re trying to draw the charts when we render the newly created view. Won’t it draw the charts before the server has responded (that is, before we have any data for the charts)? In fact, it’s almost guaranteed that our view will be trying to draw its charts before the data is available. Nonetheless, because of the way we’ve structured our views, there is no problem.</p><p>The magic is in a single statement in the <code class="literal">initialize()</code> method of our Charts view.</p><a id="pro_id00576"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Charts</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">View</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">initialize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> () {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">listenTo</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">model</span>,
            <span class="maroon">"change:metrics change:gps"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">render</span>);
        <span class="indianred"><span class="emphasis"><em>// Code continues...</em></span></span></pre><p>That statement tells Backbone.js that our view wants to know whenever the <code class="literal">metrics</code> (or <code class="literal">gps</code>) property of the associated model changes. When the server responds to a <code class="literal">fetch()</code> and updates that property, Backbone.js calls the view’s <code class="literal">render()</code> method and will try (again) to draw the charts.</p><p>There’s quite a lot going on in this process, so it may help to look at it one step at a time.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The application calls the <code class="literal">fetch()</code> method of a Runs collection.</p></li><li class="listitem"><p>Backbone.js sends a request to the server for a list of activities.</p></li><li class="listitem"><p>The server’s response includes summary information for each activity, which Backbone.js uses to create the initial Run models.</p></li><li class="listitem"><p>The application creates a Details view for a specific Run model.</p></li><li class="listitem"><p>The <code class="literal">initialize()</code> method of this view calls the <code class="literal">fetch()</code> method of the particular model.</p></li><li class="listitem"><p>Backbone.js sends a request to the server for that activity’s details.</p></li><li class="listitem"><p>Meanwhile, the application renders the Details view it just created.</p></li><li class="listitem"><p>The Details view creates a Charts view and renders that view.</p></li><li class="listitem"><p>Because there is no data for any charts, the Charts view doesn’t actually add anything to the page, but it is waiting to hear of any relevant changes to the model.</p></li><li class="listitem"><p>Eventually the server responds to the request in Step 6 with details for the activity.</p></li><li class="listitem"><p>Backbone.js updates the model with the new details and notices that, as a result, the <code class="literal">metrics</code> property has changed.</p></li><li class="listitem"><p>Backbone.js triggers the change event for which the Charts view has been listening.</p></li><li class="listitem"><p>The Charts view receives the event trigger and again renders itself.</p></li><li class="listitem"><p>Because chart data is now available, the <code class="literal">render()</code> method is able to create the charts and add them to the page.</p></li></ol></div><p>Whew! It’s a good thing that Backbone.js takes care of all that complexity.</p><p><a id="iddle1005" class="indexterm"/><a id="iddle1329" class="indexterm"/><a id="iddle1423" class="indexterm"/><a id="iddle1528" class="indexterm"/><a id="iddle2112" class="indexterm"/>At this point we’ve managed to retrieve the detailed metrics for a run, but we haven’t yet added any GPS data. Nike+ requires an additional request for that data, so we’ll use a similar process. In this case, though, we can’t rely on Backbone .js because the URL for the GPS request is unique to Nike+. That URL is formed by taking the individual activity’s URL and appending <span class="emphasis"><em>/gps</em></span>—for example, <span class="emphasis"><em><a class="ulink" href="https://api.nike.com/v1/me/sport/activities/2126456911/gps/" target="_top">https://api.nike.com/v1/me/sport/activities/2126456911/gps/</a></em></span>.</p><p>To make the additional request, we can add some code to the regular <code class="literal">fetch()</code> method. We’ll request the GPS data at the same time Backbone.js asks for the metrics details. The basic approach, which the following code fragment illustrates, is simple. We’ll first see if the activity even has any GPS data. We can do that by checking the <code class="literal">isGpsActivity</code> property, which the server provides on activity summaries. If it does, then we can request it. In either case, we also want to execute the normal <code class="literal">fetch()</code> process for the model. We do that by getting a reference to the standard <code class="literal">fetch()</code> method for the model (<code class="literal">Backbone.Model.prototype.fetch</code>) and then calling that method. We pass it the same <code class="literal">options</code> passed to us.</p><a id="pro_id00577"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Model</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">fetch</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(options) {
        <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">get</span>(<span class="maroon">"isGpsActivity"</span>)) {
            <span class="indianred"><span class="emphasis"><em>// Request GPS details from the server</em></span></span>
        }
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Backbone</span>.<span class="steelblue">Model</span>.<span class="steelblue">prototype</span>.<span class="steelblue">fetch</span>.<span class="olive">call</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>, options);
     },</pre><p>Next, to make the request to Nike+, we can use jQuery’s AJAX function. Since we’re asking for JavaScript objects (JSON data), the <code class="literal">$.getJSON()</code> function is the most appropriate. First we set aside a reference to the run by assigning <code class="literal">this</code> to the local variable <code class="literal">model</code>. We’ll need that variable because <code class="literal">this</code> won’t reference the model when jQuery executes our callback. Then we call <code class="literal">$.getJSON()</code> with three parameters. First is the URL for the request. We get that from Backbone.js by calling the <code class="literal">url()</code> method for the model and appending the trailing <span class="emphasis"><em>/gps</em></span>. The second parameter is the data values to be included with the request. As always, we need to include an authorization token. Just as we did before, we can get that token’s value from the collection. The final parameter is a callback function that JQuery executes when it receives the server’s response. In our case, the function simply sets the <code class="literal">gps</code> property of the model to the response data.</p><a id="pro_id00578"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">get</span>(<span class="maroon">"isGpsActivity"</span>)) {
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> model = <span class="steelblue"><span class="strong"><strong>this</strong></span></span>;
    <span class="steelblue">$</span>.<span class="olive">getJSON</span>(
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">url</span>() + <span class="maroon">"/gps"</span>,
        { <span class="dodgerblue">authorization_token</span>:
          <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">collection</span>.<span class="steelblue">settings</span>.<span class="olive">authorization_token</span> },
        <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(data) { <span class="steelblue">model</span>.<span class="olive">set</span>(<span class="maroon">"gps"</span>, data); }
    );
}</pre><p><a id="iddle1040" class="indexterm"/><a id="iddle1068" class="indexterm"/><a id="iddle1829" class="indexterm"/><a id="iddle1897" class="indexterm"/><a id="iddle1911" class="indexterm"/><a id="iddle2135" class="indexterm"/>Not surprisingly, the process of retrieving GPS data works the same way as retrieving the detailed metrics. Initially our Map view won’t have the data it needs to create a map for the run. Because it’s listening for changes to the <code class="literal">gps</code> property of the model, however, it will be notified when that data is available. At that point it can complete the <code class="literal">render</code> function and the user will be able to view a nice map of the run.</p></div></div><div class="sect1" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="putting_it_all_together">Putting It All Together</h2></div></div></div><p>At this point in the chapter, we have all the pieces for a simple data-driven web application. Now we’ll take those pieces and assemble them into the app. At the end of this section, we’ll have a complete application. Users start the app by visiting a web page, and our JavaScript code takes it from there. The result is a <span class="emphasis"><em>single-page application</em></span>, or SPA. SPAs have become popular because JavaScript code can respond to user interaction immediately in the browser, which is much quicker than traditional websites communicating with a server located halfway across the Internet. Users are often pleased with the snappy and responsive result.</p><p>Even though our app is executing in a single web page, our users still expect certain behaviors from their web browsers. They expect to be able to bookmark a page, share it with friends, or navigate using the browser’s forward and back buttons. Traditional websites can rely on the browser to support all of those behaviors, but a single-page application can’t. As we’ll see in the steps that follow, we have to write some additional code to give our users the behavior they expect.</p><div class="sect2" title="Step 1: Create a Backbone.js Router"><div class="titlepage"><div><div><h3 class="title" id="step_1_create_a_backbonedotjs_router">Step 1: Create a Backbone.js Router</h3></div></div></div><p>So far we’ve looked at three Backbone.js components—models, collections, and views—all of which may be helpful in any JavaScript application. The fourth component, the <span class="emphasis"><em>router</em></span>, is especially helpful for single-page applications. You won’t be surprised to learn that we can use Yeoman to create the scaffolding for a router.</p><a id="pro_id00579"/><pre class="programlisting">$ <span class="steelblue"><span class="strong"><strong>yo</strong></span></span> backbone:router app
   <span class="steelblue"><span class="strong"><strong>create</strong></span></span> app/scripts/routes/app.js
   <span class="steelblue"><span class="strong"><strong>invoke</strong></span></span>   backbone-mocha:router
   <span class="steelblue"><span class="strong"><strong>create</strong></span></span>     test/routers/app.spec.js</pre><p>Notice that we’ve named our router <code class="literal">app</code>. As you might expect from this name, we’re using this router as the main controller for our application. That approach has pros and cons. Some developers feel that a router should be limited strictly to routing, while others view the router as the natural place to coordinate the overall application. For a simple example such as ours, there isn’t really any harm in adding a bit of extra code to the router to control the app. In complex applications, however, it might be better to separate routing from application control. One of the nice things about Backbone.js is that it’s happy to support either approach.</p><p>With the scaffolding in place, we can start adding our router code to the <span class="emphasis"><em>app.js</em></span> file. The first property we’ll define is the <code class="literal">routes</code>. This property is an object whose keys are URL fragments and whose values are methods of the router. Here’s our starting point.</p><a id="pro_id00580"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">routes</span>: {
        <span class="maroon">""</span>:         <span class="maroon">"summary"</span>,
        <span class="maroon">"runs/:id"</span>: <span class="maroon">"details"</span>
    },
});</pre><p><a id="iddle1070" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1456" class="indexterm"/><a id="iddle1975" class="indexterm"/>The first route has an empty URL fragment (<code class="literal">""</code>). When a user visits our page without specifying a path, the router will call its <code class="literal">summary()</code> method. If, for example, we were hosting our app using the <span class="emphasis"><em>greatrunningapp.com</em></span> domain name, then users entering <span class="emphasis"><em><a class="ulink" href="http://greatrunningapp.com/" target="_top">http://greatrunningapp.com/</a></em></span> in their browsers would trigger that route. Before we look at the second route, let’s see what the <code class="literal">summary()</code> method does.</p><p>The code is exactly what we’ve seen before. The <code class="literal">summary()</code> method creates a new Runs collection, fetches that collection, creates a Summary view of the collection, and renders that view onto the page. Users visiting the home page for our app will see a summary of their runs.</p><a id="pro_id00581"/><pre class="programlisting">summary: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([],
        {<span class="dodgerblue">authorizationToken</span>: <span class="maroon">"authorize me"</span>});
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">fetch</span>();
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span>({<span class="dodgerblue">collection</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span>});
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
},</pre><p>Now we can consider our second route. It has a URL fragment of <span class="emphasis"><em>runs/:id</em></span>. The <span class="emphasis"><em>runs/</em></span> part is a standard URL path, while <span class="emphasis"><em>:id</em></span> is how Backbone.js identifies an arbitrary variable. With this route, we’re telling Backbone.js to look for a URL that starts out as <span class="emphasis"><em><a class="ulink" href="http://greatrunningapp.com/runs/" target="_top">http://greatrunningapp.com/runs/</a></em></span> and to consider whatever follows as the value for the <code class="literal">id</code> parameter. We’ll use that parameter in the router’s <code class="literal">details()</code> method. Here’s how we’ll start developing that method:</p><a id="pro_id00582"/><pre class="programlisting">details: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(id) {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span>();
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">id</span> = id;
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">fetch</span>();
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">detailsView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Details</span>({<span class="dodgerblue">model</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span>});
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
    },</pre><p>As you can see, the code is almost the same as the <code class="literal">summary()</code> method, except we’re showing only a single run instead of the whole collection. We create a new Run model, set its <code class="literal">id</code> to the value in the URL, fetch the model from the server, create a Details view, and render that view on the page.</p><p>The router lets users go straight to an individual run by using the appropriate URL. A URL of <span class="emphasis"><em><a class="ulink" href="http://greatrunningapp.com/runs/2126456911" target="_top">http://greatrunningapp.com/runs/2126456911</a></em></span>, for example, will fetch and display the details for the run that has an <code class="literal">activityId</code> equal to <code class="literal">2126456911</code>. <a id="iddle1067" class="indexterm"/><a id="iddle2134" class="indexterm"/>Notice that the router doesn’t have to worry about what specific attribute defines the model’s unique identifier. It uses the generic <code class="literal">id</code> property. Only the model itself needs to know the actual property name that the server uses.</p><p>With the router in place, our single-page application can support multiple URLs. One shows a summary of all runs, while others show the details of a specific run. Because the URLs are distinct, our users can treat them just like different web pages. They can bookmark them, email them, or share them on social networks. And whenever they or their friends return to a URL, it will show the same contents as before. That’s exactly how users expect the Web to behave.</p><p>There is another behavior that users expect, though, that we haven’t yet supported. Users expect to use their browser’s back and forward buttons to navigate through their browsing histories. Fortunately, Backbone.js has a utility that takes care of that functionality. It’s the <span class="emphasis"><em>history</em></span> feature, and we can enable it during the app router’s initialization.</p><a id="pro_id00583"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">initialize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
        <span class="steelblue">Backbone</span>.<span class="steelblue">history</span>.<span class="olive">start</span>({<span class="dodgerblue">pushState</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span>});
    },</pre><p>For our simple app, that’s all we have to do to handle browsing histories. Backbone.js takes care of everything else.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p><span class="strong"><strong>Support for multiple URLs will probably require some configuration of your web server. More specifically, you’ll want the server to map all URLs to the same <span class="emphasis"><em>index.html</em></span> file. The details of this configuration depend on the web server technology. With open source Apache servers, the</strong></span> <span class="emphasis"><em>.htaccess</em></span> <span class="strong"><strong>file can define the mapping.</strong></span></p></div></div><div class="sect2" title="Step 2: Support Run Models Outside of Any Collection"><div class="titlepage"><div><div><h3 class="title" id="step_2_support_run_models_outside_of_any">Step 2: Support Run Models Outside of Any Collection</h3></div></div></div><p>Unfortunately, if we try to use the preceding code with our existing Run model, we’ll encounter some problems. First among them is the fact that our Run model relies on its parent collection. It finds the authorization token, for example, using <code class="literal">this.collection.settings.authorization_token</code>. When the browser goes directly to the URL for a specific run, however, there won’t be a collection. In the following code, we make some tweaks to address this:</p><a id="pro_id00584"/><pre class="programlisting">    <span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
       <span class="dodgerblue">routes</span>: {
           <span class="maroon">""</span>:         <span class="maroon">"summary"</span>,
           <span class="maroon">"runs/:id"</span>: <span class="maroon">"details"</span>
       },
       <span class="dodgerblue">initialize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(options) {
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">options</span> = options;
           <span class="steelblue">Backbone</span>.<span class="steelblue">history</span>.<span class="olive">start</span>({<span class="dodgerblue">pushState</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span>});
       },
       <span class="dodgerblue">summary</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([],
➊             {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">fetch</span>();
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span>({
               <span class="dodgerblue">collection</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span>});
           <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
       },
       <span class="dodgerblue">details</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(id) {
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span>({},
➋             {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">id</span> = id;
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">fetch</span>();
           <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">detailsView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Details</span>({
               <span class="dodgerblue">model</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span>});
           <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
   });</pre><p><a id="iddle1727" class="indexterm"/>Now we provide the token to the Run model when we create it at ➋. We also make its value an option passed to the collection on creation at ➊.</p><p>Next we need to modify the Run model to use this new parameter. We’ll handle the token the same way we do in the Runs collection.</p><a id="pro_id00585"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Model</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">initialize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(attrs, options) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span> = { <span class="dodgerblue">authorization_token</span>: <span class="maroon">""</span> };
        options = options || {};
        <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">collection</span>) {
            <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span>).<span class="olive">extend</span>(<span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">collection</span>.<span class="olive">settings</span>)
                .<span class="olive">pick</span>(_(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span>).<span class="olive">keys</span>()));
        }
        <span class="olive">_</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span>).<span class="olive">extend</span>(<span class="olive">_</span>(options)
            .<span class="olive">pick</span>(_(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">settings</span>).<span class="olive">keys</span>()));
},</pre><p>We start by defining default values for all the settings. Unlike with the collection, the only setting our model needs is the <code class="literal">authorization_token</code>. Next we make sure that we have an <code class="literal">options</code> object. If none was provided, we create an empty one. For the third step, we check to see if the model is part of a collection by looking at <code class="literal">this.collection</code>. If that property exists, then we grab any settings from the collection and override our defaults. The final step overrides the result with any settings passed to our constructor as options. When, as in the preceding code, our router provides an <code class="literal">authorization_token</code> value, that’s the value our model will use. When the model is part of a collection, there is no specific token associated with the model. In that case, we fall back to the collection’s token.</p><p>Now that we have an authorization token, we can add it to the model’s AJAX requests. The code is again pretty much the same as our code in the Runs collection. We’ll need a property that specifies the URL for the REST service, and we’ll need to override the regular <code class="literal">sync()</code> method to add the token to any requests.</p><a id="pro_id00586"/><pre class="programlisting">urlRoot: <span class="maroon">"https://api.nike.com/v1/me/sport/activities"</span>,

sync: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(method, model, options) {
    options = options || {};
    <span class="olive">_</span>(options).<span class="olive">extend</span>({
        <span class="dodgerblue">data</span>: { <span class="dodgerblue">authorization_token</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">authorization_token</span> }
    });
    <span class="steelblue">Backbone</span>.<span class="olive">sync</span>(method, model, options);
},</pre><p><a id="iddle1330" class="indexterm"/><a id="iddle1529" class="indexterm"/><a id="iddle1986" class="indexterm"/>This extra code takes care of the authorization, but there’s still a problem with our model. In the previous section, Run models existed only as part of a Runs collection, and the act of fetching that collection populated each of its models with summary attributes, including, for example, <code class="literal">isGpsActivity</code>. The model could safely check that property whenever we tried to fetch the model details and, if appropriate, simultaneously initiate a request for the GPS data. Now, however, we’re creating a Run model on its own without the benefit of a collection. When we fetch the model, the only property we’ll know is the unique identifier. We can’t decide whether or not to request GPS data, therefore, until after the server responds to the fetch.</p><p>To separate the request for GPS data from the general fetch, we can move that request to its own method. The code is the same as before (except, of course, we get the authorization token from local settings).</p><a id="pro_id00587"/><pre class="programlisting">fetchGps: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">get</span>(<span class="maroon">"isGpsActivity"</span>) &amp;&amp; !<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">get</span>(<span class="maroon">"gps"</span>)) {
        <span class="steelblue"><span class="strong"><strong>var</strong></span></span> model = <span class="steelblue"><span class="strong"><strong>this</strong></span></span>;
        <span class="steelblue">$</span>.<span class="olive">getJSON</span>(
            <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">url</span>() + <span class="maroon">"/gps"</span>,
            { <span class="dodgerblue">authorization_token</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">settings</span>.<span class="olive">authorization_token</span> },
            <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(data) { <span class="steelblue">model</span>.<span class="olive">set</span>(<span class="maroon">"gps"</span>, data); }
        );
    }
}</pre><p>To trigger this method, we’ll tell Backbone.js that whenever the model changes, it should call the <code class="literal">fetchGps()</code> method.</p><a id="pro_id00588"/><pre class="programlisting">initialize: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(attrs, options) {
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">on</span>(<span class="maroon">"change"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">fetchGps</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);</pre><p>Backbone.js will detect just such a change when the <code class="literal">fetch()</code> response arrives and populates the model, at which time our code can safely check <code class="literal">isGpsActivity()</code> and make the additional request.</p></div><div class="sect2" title="Step 3: Let Users Change Views"><div class="titlepage"><div><div><h3 class="title" id="step_3_let_users_change_views">Step 3: Let Users Change Views</h3></div></div></div><p><a id="iddle1075" class="indexterm"/><a id="iddle1139" class="indexterm"/><a id="iddle1312" class="indexterm"/><a id="iddle2147" class="indexterm"/>Now that our app can correctly display two different views, it’s time to let our users in on the fun. For this step, we’ll give them an easy way to change back and forth between the views. Let’s first consider the Summary view. It would be nice if a user could click on any run that appears in the table and be instantly taken to the detailed view for that run.</p><p>Our first decision is where to put the code that listens for clicks. At first, it might seem like the SummaryRow view is a natural place for that code. That view is responsible for rendering the row, so it seems logical to let that view handle events related to the row. If we wanted to do that, Backbone.js makes it very simple; all we need is an extra property and an extra method in the view. They might look like the following:</p><a id="pro_id00589"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">SummaryRow</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">View</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">events</span>: {
        <span class="maroon">"click"</span>: <span class="maroon">"clicked"</span>
    },
    <span class="dodgerblue">clicked</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
        <span class="indianred"><span class="emphasis"><em>// Do something to show the Details view for this.model</em></span></span>
    },</pre><p>The <code class="literal">events</code> property is an object that lists the events of interest to our view. In this case there’s only one: the <code class="literal">click</code> event. The value—in this case, <code class="literal">clicked</code>—identifies the method that Backbone.js should call when the event occurs. We’ve skipped the details of that method for now.</p><p>There is nothing technically wrong with this approach, and if we were to continue the implementation, it would probably work just fine. It is, however, very inefficient. Consider a user who has hundreds of runs stored on Nike+. The summary table would have hundreds of rows, and each row would have its own function listening for <code class="literal">click</code> events. Those event handlers can use up a lot of memory and other resources in the browser and make our app sluggish. Fortunately, there’s a different approach that’s far less stressful to the browser.</p><p>Instead of having potentially hundreds of event handlers, each listening for clicks on a single row, we’d be better off with one event handler listening for clicks on all of the table rows. Since the Summary view is responsible for all of those rows, it’s the natural place to add that handler. We can still take advantage of Backbone .js to make its implementation easy by adding an <code class="literal">events</code> object to our view. In this case, we can do even better, though. We don’t care about <code class="literal">click</code> events on the table header; only the rows in the table body matter. By adding a jQuery-style selector after the event name, we can restrict our handler to elements that match that selector.</p><a id="pro_id00590"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">View</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">events</span>: {
        <span class="maroon">"click tbody"</span>: <span class="maroon">"clicked"</span>
    },</pre><p><a id="iddle1140" class="indexterm"/><a id="iddle1142" class="indexterm"/><a id="iddle1246" class="indexterm"/><a id="iddle1736" class="indexterm"/><a id="iddle1816" class="indexterm"/><a id="iddle2002" class="indexterm"/>The preceding code asks Backbone.js to watch for <code class="literal">click</code> events within the <code class="literal">&lt;tbody&gt;</code> element of our view. When an event occurs, Backbone.js will call the <code class="literal">clicked()</code> method of our view.</p><p>Before we develop any code for that <code class="literal">clicked()</code> method, we need a way for it to figure out which specific run model the user has selected. The event handler will be able to tell which row the user clicked, but how will it know which model that row represents? To make the answer easy for the handler, we can embed the necessary information directly in the markup for the row. That requires a few small adjustments to the <code class="literal">renderRun()</code> method we created earlier.</p><p>The revised method still creates a SummaryRow view for each model, renders that view, and appends the result to the table body. Now, though, we’ll add one extra step just before the row is added to the page. We add a special attribute, <code class="literal">data-id</code>, to the row and set its value equal to the model’s unique identifier. We use <code class="literal">data-id</code> because the HTML5 standard allows any attribute with a name that begins with <code class="literal">data-</code>. Custom attributes in this form won’t violate the standard and won’t cause browser errors.</p><a id="pro_id00591"/><pre class="programlisting">renderRun: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> (run) {
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> row = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">SummaryRow</span>({ <span class="dodgerblue">model</span>: run });
    <span class="steelblue">row</span>.<span class="olive">render</span>();
    <span class="steelblue">row</span>.<span class="steelblue">$el</span>.<span class="olive">attr</span>(<span class="maroon">"data-id"</span>, <span class="steelblue">run</span>.<span class="olive">id</span>);
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">$</span>(<span class="maroon">"tbody"</span>).<span class="olive">append</span>(<span class="steelblue">row</span>.<span class="olive">$el</span>);
},</pre><p>The resulting markup for a run with an identifier of <code class="literal">2126456911</code> would look like the following example:</p><a id="pro_id00592"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>&lt;tr</strong></span></span> <span class="steelblue">data-id=</span><span class="maroon">"2126456911"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;td&gt;</strong></span></span>04/09/2013<span class="steelblue"><span class="strong"><strong>&lt;/td&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;td&gt;</strong></span></span>0:22:39<span class="steelblue"><span class="strong"><strong>&lt;/td&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;td&gt;</strong></span></span>2.33 Miles<span class="steelblue"><span class="strong"><strong>&lt;/td&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;td&gt;</strong></span></span>240<span class="steelblue"><span class="strong"><strong>&lt;/td&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;td&gt;</strong></span></span>9:43<span class="steelblue"><span class="strong"><strong>&lt;/td&gt;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>&lt;/tr&gt;</strong></span></span></pre><p>Once we’ve made sure that the markup in the page has a reference back to the Run models, we can take advantage of that markup in our <code class="literal">clicked</code> event handler. When Backbone.js calls the handler, it passes it an event object. From that object, we can find the target of the event. In the case of a <code class="literal">click</code> event, the target is the HTML element on which the user clicked.</p><a id="pro_id00593"/><pre class="programlisting">clicked: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> (ev) {
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> $target = <span class="olive">$</span>(<span class="steelblue">ev</span>.<span class="olive">target</span>)</pre><p>From the preceding markup, it’s clear that most of the table row is made up of table cells (<code class="literal">&lt;td&gt;</code> elements), so a table cell will be the likely target of the <code class="literal">click</code> event. We can use the jQuery <code class="literal">parents()</code> function to find the table row that is the parent of the click target.</p><a id="pro_id00594"/><pre class="programlisting">clicked: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> (ev) {
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> $target = <span class="olive">$</span>(<span class="steelblue">ev</span>.<span class="olive">target</span>)
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> id = <span class="steelblue">$target</span>.<span class="olive">attr</span>(<span class="maroon">"data-id"</span>) ||
             <span class="steelblue">$target</span>.<span class="olive">parents</span>(<span class="maroon">"[data-id]"</span>).<span class="olive">attr</span>(<span class="maroon">"data-id"</span>);</pre><p><a id="iddle1247" class="indexterm"/><a id="iddle1976" class="indexterm"/>Once we’ve found that parent row, we extract the <code class="literal">data-id</code> attribute value. To be on the safe side, we also handle the case in which the user somehow manages to click on the table row itself rather than an individual table cell.</p><p>After retrieving the attribute value, our view knows which run the user selected; now it has to do something with the information. It might be tempting to have the Summary view directly render the Details view for the run, but that action would not be appropriate. A Backbone.js view should take responsibility only for itself and any child views that it contains. That approach allows the view to be safely reused in a variety of contexts. Our Summary view, for example, might well be used in a context in which the Details view isn’t even available. In that case, trying to switch directly to the Details view would, at best, generate an error.</p><p>Because the Summary view cannot itself respond to the user clicking on a table row, it should instead follow the hierarchy of the application and, in effect, pass the information “up the chain of command.” Backbone.js provides a convenient mechanism for this type of communication: custom events. Instead of responding directly to the user click, the Summary view triggers a custom event. Other parts can listen for this event and respond appropriately. If no other code is listening for the event, then nothing happens, but at least the Summary view can say that it’s done its job.</p><p>Here’s how we can generate a custom event in our view:</p><a id="pro_id00595"/><pre class="programlisting">clicked: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> (ev) {
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> $target = <span class="olive">$</span>(<span class="steelblue">ev</span>.<span class="olive">target</span>)
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> id = <span class="steelblue">$target</span>.<span class="olive">attr</span>(<span class="maroon">"data-id"</span>) ||
             <span class="steelblue">$target</span>.<span class="olive">parents</span>(<span class="maroon">"[data-id]"</span>).<span class="olive">attr</span>(<span class="maroon">"data-id"</span>);
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">trigger</span>(<span class="maroon">"select"</span>, id);
}</pre><p>We call the event <code class="literal">select</code> to indicate that the user has selected a specific run, and we pass the identifier of that run as a parameter associated with the event. At this point, the Summary view is complete.</p><p>The component that should respond to this custom event is the same component that created the Summary view in the first place: our app router. We’ll first need to listen for the event. We can do that right after we create it in the <code class="literal">summary()</code> method.</p><a id="pro_id00596"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">summary</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([],
            {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">fetch</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span>({
            <span class="dodgerblue">collection</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span>});
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">on</span>(<span class="maroon">"select"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">selected</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
},</pre><p><a id="iddle1266" class="indexterm"/><a id="iddle1694" class="indexterm"/><a id="iddle1867" class="indexterm"/><a id="iddle2083" class="indexterm"/>When the user selects a specific run from the Summary view, Backbone.js calls our router’s <code class="literal">selected()</code> method, which will receive any event data as parameters. In our case, the event data is the unique identifier, so that becomes the method’s parameter.</p><a id="pro_id00597"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">selected</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(id) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">navigate</span>(<span class="maroon">"runs/"</span> + id, { <span class="dodgerblue">trigger</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span> });
    }</pre><p>As you can see, the event handler code is quite simple. It constructs a URL that corresponds to the Details view (<code class="literal">"runs/" + id</code>) and passes that URL to the router’s own <code class="literal">navigate()</code> method. That method updates the browser’s navigation history. The second parameter (<code class="literal">{ trigger: true }</code>) tells Backbone.js to also act as if the user had actually navigated to the URL. Because we’ve set up the <code class="literal">details()</code> method to respond to URLs of the form <span class="emphasis"><em>runs/:id</em></span>, Backbone.js will call <code class="literal">details()</code>, and our router will show the details for the selected run.</p><p>When users are looking at a Details view, we’d also like to provide a button to let them easily navigate to the Summary view. As with the Summary view, we can add an event handler for the button and trigger a custom event when a user clicks it.</p><a id="pro_id00598"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Details</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">View</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">events</span>: {
        <span class="maroon">"click button"</span>: <span class="maroon">"clicked"</span>
    },
    <span class="dodgerblue">clicked</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span> () {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">trigger</span>(<span class="maroon">"summarize"</span>);
    }</pre><p>And, of course, we need to listen for that custom event in our router.</p><a id="pro_id00599"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">details</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(id) {
        <span class="indianred"><span class="emphasis"><em>// Set up the Details view</em></span></span>
        <span class="indianred"><span class="emphasis"><em>// Code continues...</em></span></span>
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">on</span>(<span class="maroon">"summarize"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summarize</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
    },
    <span class="dodgerblue">summarize</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">navigate</span>(<span class="maroon">""</span>, { <span class="dodgerblue">trigger</span>: <span class="steelblue"><span class="strong"><strong>true</strong></span></span> });
    },</pre><p>Once again we respond to the user by constructing an appropriate URL and triggering a navigation to it.</p><p><a id="iddle1069" class="indexterm"/><a id="iddle1977" class="indexterm"/><a id="iddle2137" class="indexterm"/>You might be wondering why we have to explicitly trigger the navigation change. Shouldn’t that be the default behavior? Although that may seem reasonable, in most cases it wouldn’t be appropriate. Our application is simple enough that triggering the route works fine. More complex applications, however, probably want to take different actions depending on whether the user performs an action within the app or navigates directly to a particular URL. It’s better to have different code handling each of those cases. In the first case the app would still want to update the browser’s history, but it wouldn’t want to trigger a full navigation action.</p></div><div class="sect2" title="Step 4: Fine-Tuning the Application"><div class="titlepage"><div><div><h3 class="title" id="step_4_fine-tuning_the_application">Step 4: Fine-Tuning the Application</h3></div></div></div><p>At this point our app is completely functional. Our users can view their summaries, bookmark and share details of specific runs, and navigate the app using the browser’s back and forward buttons. Before we can call it complete, however, there’s one last bit of housekeeping for us. The app’s performance isn’t optimal, and, even more critically, it <span class="emphasis"><em>leaks</em></span> memory, using small amounts of the browser’s memory without ever releasing them.</p><p>The most obvious problem is in the router’s <code class="literal">summary()</code> method, reproduced here:</p><a id="pro_id00600"/><pre class="programlisting"><span class="steelblue">Running</span>.<span class="steelblue">Routers</span>.<span class="olive">App</span> = <span class="steelblue">Backbone</span>.<span class="steelblue">Router</span>.<span class="olive">extend</span>({
    <span class="dodgerblue">summary</span>: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([],
            {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">fetch</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span>({
            <span class="dodgerblue">collection</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span>});
        <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">on</span>(<span class="maroon">"select"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">selected</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
    },</pre><p>Every time this method executes, it creates a new collection, fetches that collection, and renders a Summary view for the collection. Clearly we have to go through those steps the first time the method executes, but there is no need to repeat them later. Neither the collection nor its view will change if the user selects a specific run and then returns to the summary. Let’s add a check to the method so that we take those steps only if the view doesn’t already exist.</p><a id="pro_id00601"/><pre class="programlisting">summary: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (!<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([],
            {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">fetch</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span>({
            <span class="dodgerblue">collection</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">render</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">on</span>(<span class="maroon">"select"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">selected</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
    }
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">el</span>);
},</pre><p><a id="iddle1267" class="indexterm"/><a id="iddle1978" class="indexterm"/>We can also add a check in the <code class="literal">details()</code> method. When that method executes and a Summary view is present, we can “set aside” the Summary view’s markup using jQuery’s <code class="literal">detach()</code> function. That will keep the markup and its event handlers ready for a quick reinsertion onto the page should the user return to the summary.</p><a id="pro_id00602"/><pre class="programlisting">details: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(id) {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="steelblue">$el</span>.<span class="olive">detach</span>();
    }
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span>({},
        {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">id</span> = id;
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">fetch</span>();
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">on</span>(<span class="maroon">"summarize"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summarize</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
},</pre><p>Those changes make switching to and from the Summary view more efficient. We can also make some similar changes for the Details view. In the <code class="literal">details()</code> method we don’t have to fetch the run if it’s already present in the collection. We can add a check, and if the data for the run is already available, we won’t bother with the fetch.</p><a id="pro_id00603"/><pre class="programlisting">details: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(id) {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (!<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> || !(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span> = <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">get</span>(id))) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Models</span>.<span class="olive">Run</span>({},
            {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">id</span> = id;
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">run</span>.<span class="olive">fetch</span>();
    }
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="steelblue">$el</span>.<span class="olive">detach</span>();
    }
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">detailsView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Details</span>({<span class="dodgerblue">model</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">run</span>});
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">render</span>().<span class="olive">el</span>);
    <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">on</span>(<span class="maroon">"summarize"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summarize</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
},</pre><p>In the <code class="literal">summary()</code> method, we don’t want to simply set aside the Details view as we did for the Summary view. That’s because there may be hundreds of Details views hanging around if a user starts looking at all of the runs available. Instead, we want to cleanly delete the Details view. That lets the browser know that it can release any memory that the view is consuming.</p><p><a id="iddle1804" class="indexterm"/>As you can see from the following code, we’ll do that in three steps.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Remove the event handler we added to the Details view to catch <code class="literal">summarize</code> events.</p></li><li class="listitem"><p>Call the view’s <code class="literal">remove()</code> method so it releases any memory it’s holding internally.</p></li><li class="listitem"><p>Set <code class="literal">this.detailsView</code> to <code class="literal">null</code> to indicate that the view no longer exists.</p></li></ol></div><a id="pro_id00604"/><pre class="programlisting">summary: <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">detailsView</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">off</span>(<span class="maroon">"summarize"</span>);
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">detailsView</span>.<span class="olive">remove</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">detailsView</span> = <span class="steelblue"><span class="strong"><strong>null</strong></span></span>;
    }
    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (!<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span>) {
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Collections</span>.<span class="olive">Runs</span>([],
            {<span class="dodgerblue">authorizationToken</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">options</span>.<span class="olive">token</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">runs</span>.<span class="olive">fetch</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">summaryView</span> = <span class="steelblue"><span class="strong"><strong>new</strong></span></span> <span class="steelblue">Running</span>.<span class="steelblue">Views</span>.<span class="olive">Summary</span>({
            <span class="dodgerblue">collection</span>: <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">runs</span>});
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">render</span>();
        <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">on</span>(<span class="maroon">"select"</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="olive">selected</span>, <span class="steelblue"><span class="strong"><strong>this</strong></span></span>);
    }
    <span class="olive">$</span>(<span class="maroon">"body"</span>).<span class="olive">html</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>.<span class="steelblue">summaryView</span>.<span class="olive">el</span>);
},</pre><p>And with that change, our application is complete! You can take a look at the final result in the book’s source code (<span class="emphasis"><em><a class="ulink" href="http://jsDataV.is/source/" target="_top">http://jsDataV.is/source/</a></em></span>).</p></div></div><div class="sect1" title="Summing Up"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summing_up-id00045">Summing Up</h2></div></div></div><p>In this chapter, we completed a data-driven web application. First, we saw how Backbone.js gives us the flexibility to interact with REST APIs that don’t quite follow the normal conventions. Then we worked with a Backbone.js router to make sure our single-page application behaves like a full website so that our users can interact with it just as they would expect.</p></div></section></body></html>