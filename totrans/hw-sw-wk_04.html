<html><head></head><body>
<h2 class="h2" id="ch04"><a id="page_57"/><strong><span class="big">4</span></strong><br/><strong>Movie CGI</strong></h2>
<div class="image1"><img alt="image" src="graphics/common-01.jpg"/></div>
<p class="noindent">Some of software’s most impressive work can be seen in movie theaters. Images that in earlier eras were painstakingly produced with models, matte paintings, elaborate costumes, and trick photography are now created by computers. More than merely simplifying the filmmaking process, <em>computer-generated imagery (CGI)</em> produces images that would have been impossible before. For many filmgoers, movies changed forever when they saw <em>Jurassic Park</em>. When Steven Spielberg was developing the movie, he expected to create his dinosaurs using old-school effects like automated puppets and animated miniatures, but once he saw some computer-animated test footage, he decided to use CGI for many of the dinosaur shots. The result left viewers astounded by images like the panorama shown in <a href="ch04.html#ch4fig1">Figure 4-1</a>. For comparison, the old way to put a dinosaur in a movie is shown in <a href="ch04.html#ch4fig2">Figure 4-2</a>.</p>
<div class="image"><a id="page_58"/><img alt="image" src="graphics/f04-01.jpg"/></div>
<p class="figuret"><a id="ch4fig1"/><em>Figure 4-1: CGI dinosaurs visit the watering hole in</em> Jurassic Park <em>(Universal Pictures/Amblin Entertainment, 1993).</em></p>
<div class="image"><img alt="image" src="graphics/f04-02.jpg"/></div>
<p class="figuret"><a id="ch4fig2"/><em>Figure 4-2:</em> The Beast from 20,000 Fathoms <em>(Jack Dietz Productions, 1953) munches on Coney Island.</em></p>
<p class="indent">Amazing as they were, films like <em>Jurassic Park</em> were just the beginning of the CGI revolution. Now movies like <em>Avatar</em> create whole worlds using CGI, so that viewers are never sure what parts of a shot are physically real, if any. With enough time and money, it seems like filmmakers can produce anything imaginable.</p>
<p class="indent"><a id="page_59"/>Before computers blew our minds with dinosaurs and lush alien planets, though, they were transforming the world of traditionally animated movies. Using computers not only radically altered the process of traditional animation, but as you’ll discover, the concepts and techniques employed are the foundation for almost everything in computer graphics. This is where the story of CGI begins.</p>
<h3 class="h3" id="ch04lev1sec01"><strong>Software for Traditional Animation</strong></h3>
<p class="noindent">A movie is a series of still images, or <em>frames</em>, presented to the eye in rapid succession, like a high-speed slideshow. Each frame lingers on the retina for a moment after it disappears from the screen, effectively blending with the next frame to provide the illusion of continuous motion—a phenomenon known as <em>persistence of vision</em>. Traditionally, movies are shown at a rate of 24 frames per second (fps). Making a movie means producing 24 images for every second of the film.</p>
<p class="indent">A live-action movie uses a camera to collect images in real time. A traditionally animated film like <em>Lady and the Tramp</em>, though, is created a bit differently: each frame of the movie is an individually photographed, hand-crafted work of art.</p>
<p class="indent">Traditional animation is a huge undertaking requiring a large team of artists. Typically, each character in an animated film is assigned a lead animator, but the lead animator does not draw the character on every frame in which he or she appears, because that’s too much work for one person. Instead, the lead animator draws only as many <em>keyframes</em> as are needed to suggest the action—perhaps one out of every few dozen frames of a finished animation sequence. Other animators draw the in-between frames to complete the sequence, a process known as <em>tweening</em>. At this stage, the animation is still just a series of pencil drawings on paper. The drawings must be transferred to transparent cellulose sheets, which is why this style of animation is also known as <em>cel animation</em>. Then comes what animators call “ink and paint”: the faint pencil lines are traced over with black ink, and the cel is colored. Then the sheets are placed in front of a separately painted background and photographed.</p>
<p class="indent">As you might expect, tweening, inking, and painting are tedious, time-intensive jobs. Beginning around 1990, computer imagery has been used to mimic the cel animation style with far less manual labor.</p>
<h4 class="h4" id="ch04lev2sec01"><strong><em>How Digital Images Work</em></strong></h4>
<p class="noindent">In a traditional animated film, each frame is a photograph of physical art, but computer animation works with <em>digital images</em>—pictures defined by numerical data.</p>
<p class="indent">When you look at a video display such as a television, a smartphone screen, or a digitally projected theater screen, the image that reaches your eyes is made up of dots of varying colors, known as <em>pixels</em>. <a href="ch04.html#ch4fig3">Figure 4-3</a> depicts a tree against a blue sky as a grid of pixels. Each of the 100 pixels in this 10×10 grid is assigned a color, here specified by name.</p>
<div class="image"><a id="page_60"/><img alt="image" src="graphics/f04-03.jpg"/></div>
<p class="figuret"><a id="ch4fig3"/><em>Figure 4-3: A tree made of pixels</em></p>
<p class="indent">Although we can think of each pixel as a solid color, the underlying reality is a bit different. For example, at home you might watch a movie on a common <em>liquid crystal display (LCD)</em> television in which pixel colors are determined by electrically controlled crystals. On the back of an LCD screen is a light source, either a fluorescent lamp or a series of <em>light-emitting diodes (LEDs)</em>. The light source itself is white. In front of the light is a translucent panel with bars in the three primary colors—red, green, and blue—as shown in <a href="ch04.html#ch4fig4">Figure 4-4</a>.</p>
<div class="image"><img alt="image" src="graphics/f04-04.jpg"/></div>
<p class="figuret"><a id="ch4fig4"/><em>Figure 4-4: Three bars of pure primary colors create one LCD pixel.</em></p>
<p class="indent">A layer of liquid crystals lying between the light source and the color panel puts an individually controlled crystal behind each of the translucent bars. You can think of these crystals as electrically operated doors, and the degree to which each crystal door is open determines how much light gets through. By varying the amount of red, green, or blue, any one of millions of colors can be produced by each pixel. This is <em>additive color mixing</em>, in which adding more color makes the result brighter. If we want a particular pixel to come across as bright yellow, for example, we would set the levels of red and green high, and the level of blue low. If we wanted a dark gray, we would set each of the color bars to the same low intensity. All three colors at maximum intensity produce pure white. Later in this chapter, we’ll see an example of <em>subtractive color mixing</em>, which is what you might remember from art class, where adding more color makes the result darker.</p>
<h4 class="h4" id="ch04lev2sec02"><strong><em>How Colors Are Defined</em></strong></h4>
<p class="noindent">The most common way to define a pixel’s color is with the <em>RGB</em> system, which uses three numbers to represent the intensity of red, green, and blue in the pixel. The numbers typically range from 0 to 255 to match the range of an eight-bit byte. This means that each RGB pixel is specified by three bytes of data.</p>
<p class="indent"><a id="page_61"/>As far as software is concerned, a digital image such as that shown in <a href="ch04.html#ch4fig3">Figure 4-3</a> is just a list of bytes of color data, three bytes for each pixel. This block of bytes is known as the image’s <em>bitmap</em>. The first three bytes in the bitmap are the red, green, and blue levels of the pixel in the upper-left corner of the image, and so on. The width and height of an image or bitmap in pixels is known as its <em>resolution</em>; for instance, <a href="ch04.html#ch4fig3">Figure 4-3</a>’s resolution is 10×10. A bitmap called a <em>display buffer</em> stores the colors of each pixel of a digital display like an LCD television; ultimately, computer graphics methods are about setting the numbers in a display buffer.</p>
<p class="indent">The location of a particular pixel in a bitmap is specified by two <em>coordinates</em>, an <em>x</em>-coordinate for horizontal position and a <em>y</em>-coordinate for vertical position. The (0,0) coordinate, known as the <em>origin</em>, can be located in a corner or in the center; it varies among different coordinate systems. When positioning pixels on a physical display, we refer to coordinates as <em>screen coordinates</em>. Screen coordinate systems commonly set the origin at the upper-left pixel, so a 1920×1080 screen would locate pixels as shown in <a href="ch04.html#ch4fig5">Figure 4-5</a>. Here, the y-axis increases moving down the image, the x-axis increases moving right across the image, and the center location is (960, 540).</p>
<div class="image"><img alt="image" src="graphics/f04-05.jpg"/></div>
<p class="figuret"><a id="ch4fig5"/><em>Figure 4-5: Locating pixels on a 1920×1080 screen</em></p>
<p class="indent">Coordinate systems are a ubiquitous part of computer graphics and, as you’ll see in this chapter and the next, much of the work of producing graphics involves converting coordinates from one system to another.</p>
<h4 class="h4" id="ch04lev2sec03"><strong><em>How Software Makes Cel Animations</em></strong></h4>
<p class="noindent">Now that you understand what’s inside a digital image, you’re ready to see how software can make digital images that look like traditional cels. The first step is getting the artist’s work inside the computer.</p>
<h5 class="h5" id="ch04lev3sec01"><strong>Transforming Drawings into Models</strong></h5>
<p class="noindent">Software-generated cel animation starts the same way as traditional animation: with an artist sketching a character. Instead of drawing on paper, though, the artist draws with a mouse or an electronic stylus and the drawings are recorded by software. In order to ultimately produce a bitmapped image, we need a system that defines the artist’s strokes numerically, <a id="page_62"/>producing a <em>model</em> of the drawing. Locations within a model are called <em>local coordinates</em>. <a href="ch04.html#ch4fig6">Figure 4-6</a> shows a drawing of a bug-man within a box that defines the local coordinate space.</p>
<div class="image"><img alt="image" src="graphics/f04-06.jpg"/></div>
<p class="figuret"><a id="ch4fig6"/><em>Figure 4-6: A bug-man drawing inside a box defining coordinate limits</em></p>
<p class="indent">Each line and curve in this model is defined in terms of these local coordinates. Straight line segments, like the antennae and legs of our character, can be defined by the coordinates of the points at either end of the line, as shown in <a href="ch04.html#ch4fig7">Figure 4-7</a>. Note that the coordinates here have fractional parts to increase precision.</p>
<div class="image"><img alt="image" src="graphics/f04-07.jpg"/></div>
<p class="figuret"><a id="ch4fig7"/><em>Figure 4-7: Defining straight line segments using the coordinates of the end points</em></p>
<p class="indent">For curves, <em>control points</em> are needed in addition to end points to define the direction and amount of curvature. Imagine that the control point is attached to the curve so that moving it controls the degree of curvature, as illustrated by the simple curves in <a href="ch04.html#ch4fig8">Figure 4-8</a>. If you’ve ever worked with a vector graphics application, you’ve likely worked with curves like this.</p>
<div class="image"><a id="page_63"/><img alt="image" src="graphics/f04-08.jpg"/></div>
<p class="figuret"><a id="ch4fig8"/><em>Figure 4-8: Curves defined by two end points and one control point</em></p>
<p class="indent">Simple curves can be represented by just two end points and one control point, but longer, more complicated curves are made up of sequences of simple curves, as shown with the bug-man’s shoe in <a href="ch04.html#ch4fig9">Figure 4-9</a>.</p>
<p class="indent">The lines and curves define just the outline of a character or other drawing; the colors inside the outline are defined using a system such as RGB. The character model, then, is a numerical representation of all the lines, curves, and color data.</p>
<div class="image"><img alt="image" src="graphics/f04-09.jpg"/></div>
<p class="figuret"><a id="ch4fig9"/><em>Figure 4-9: A complicated curve made of simple curves</em></p>
<h5 class="h5" id="ch04lev3sec02"><strong>Automatic Tweening</strong></h5>
<p class="noindent">Numerically defining drawings allows for automatic tweening. The animator draws one frame of a character’s animation sequence, then creates succeeding keyframes by moving the control points of the curves in the previous frames. The animation software can then generate the other frames through <em>interpolation</em>. The concept is demonstrated in <a href="ch04.html#ch4fig10">Figure 4-10</a>. Here, the coordinates of the middle point are calculated as the average of the coordinates of the other points. The x-coordinate of the interpolated point, 20, is halfway between 10 and 30; the y-coordinate, 120, is halfway between 100 and 140. In this example, all the points lie on a line, but the interpolation path can be a curve as well.</p>
<div class="image"><img alt="image" src="graphics/f04-10.jpg"/></div>
<p class="figuret"><a id="ch4fig10"/><em>Figure 4-10: Computing a middle point between two keyframe points via interpolation</em></p>
<p class="indent"><a id="page_64"/><a href="ch04.html#ch4fig11">Figure 4-11</a> shows how interpolation creates new frames of animation. The leftmost face is the original model; the second face shows some of the control points; and the third has a wide mouth created by repositioning two of the control points downward. The rightmost face was created through linear interpolation, placing each control point halfway between the two keyframe positions. Animation software can create as many in-between positions as necessary to fill the gap between keyframes.</p>
<div class="image"><img alt="image" src="graphics/f04-11.jpg"/></div>
<p class="figuret"><a id="ch4fig11"/><em>Figure 4-11: From left: a model, the model with selected control points, the model with two of the control points moved, and a tweened model created by interpolation between the positions of the previous two models</em></p>
<p class="indent">Although basic interpolation tweening can be a huge time-saver, adjusting the positions of lots of little points remains tedious. More advanced animation software can treat a character drawing as a complete, interconnected body, in which rigid connections and joints are specified. This means that an animator need only position the feet for each keyframe to make our bug-man walk, and the software positions the rest of the legs accordingly. The software might even handle real-world physics, so that a sequence of images of our bug-man falling over a log could be animated entirely by the software.</p>
<h5 class="h5" id="ch04lev3sec03"><strong>Positioning and Scaling</strong></h5>
<p class="noindent">Numerical modeling also allows the drawings to be placed anywhere in a frame at any size. Changing the size of a model is called <em>scaling</em>, and is accomplished by multiplying or dividing the coordinates for each of the points. <a href="ch04.html#ch4fig12">Figure 4-12</a> shows the bug-man model of <a href="ch04.html#ch4fig6">Figure 4-6</a> scaled down to a quarter of its original area by dividing each of the coordinates in half. One point on his antenna is highlighted to show the idea.</p>
<p class="indent">Placing a model in a particular location on the screen is called <em>translation</em>, and is accomplished by increasing or decreasing coordinates by fixed amounts. In <a href="ch04.html#ch4fig13">Figure 4-13</a>, the shrunken bug-man from <a href="ch04.html#ch4fig12">Figure 4-12</a> is translated to the middle of the screen by adding 700 to each x-coordinate and 200 to each y-coordinate.</p>
<div class="image"><a id="page_65"/><img alt="image" src="graphics/f04-12.jpg"/></div>
<p class="figuret"><a id="ch4fig12"/><em>Figure 4-12: Scaling a model means multiplying or dividing each of the coordinates.</em></p>
<div class="image"><img alt="image" src="graphics/f04-13.jpg"/></div>
<p class="figuret"><a id="ch4fig13"/><em>Figure 4-13: Translating a model means adding to or subtracting from coordinates.</em></p>
<h5 class="h5" id="ch04lev3sec04"><strong>“Ink and Paint” for Digital Images</strong></h5>
<p class="noindent">Now that the points on the models are mapped to screen coordinates, it’s time to transform each frame into a bitmap. This is the software version of cel animation’s “ink and paint.” To keep things simple, let’s look at how just the right arm of our bug-man model would be converted to a bitmap, or <em>rasterized</em>, when displayed over a solid white background. <a href="ch04.html#ch4fig14">Figure 4-14</a> shows the arm over a pixel grid, with circles marking the pixel centers.</p>
<p class="indent"><a id="page_66"/>With the model mathematically defined, the software can place the arm at any position on the bitmap and then apply the indicated color—in this case, black—to the appropriate pixels. Right away we see there’s a problem, though: the contours of the arm don’t match the borders of pixels, so how do we determine which pixels to color? A simple rule is to color pixels when their centers are covered. <a href="ch04.html#ch4fig15">Figure 4-15</a> shows the result of pixel-center coloring.</p>
<div class="image"><img alt="image" src="graphics/f04-14.jpg"/></div>
<p class="figuret"><a id="ch4fig14"/><em>Figure 4-14: The right arm of the bug-man superimposed over a pixel grid</em></p>
<div class="image"><img alt="image" src="graphics/f04-15.jpg"/></div>
<p class="figuret"><a id="ch4fig15"/><em>Figure 4-15: Coloring pixels solid black based on pixel centers</em></p>
<p class="indent">As you can see, though, this result is rather ugly. Because the pixels are square, this coloring rule replaces the gracefully curving border of the model with a jagged edge, which is why this problem is known as <em>the jaggies</em>. The general problem is that the model is smooth and continuous, while the bitmap is made with square black-and-white pixels. The bitmap is just an approximation of the model. The discrepancy between continuous models and their bitmap approximations is known as <em>aliasing</em>, and is the source of many visual anomalies in computer graphics.</p>
<p class="indent">To avoid the jaggies, we need to color pixels using an <em>anti-aliasing</em> technique. In our example, instead of coloring the pixels black and white, we’ll use a range of grays to produce a better approximation of the model. Each pixel will be colored based on how much of it is covered by the arm.</p>
<p class="indent">In order to put this idea into action, instead of checking only the center of each pixel, let’s test several points in each pixel to see how many of them lie within the model. In <a href="ch04.html#ch4fig16">Figure 4-16</a>, 7 of the 10 testing points scattered around the pixel area are covered by the shape, meaning this is 70 percent coverage.</p>
<p class="indent">The percentage of each pixel covered by the model determines the gray level. The result for our bug-man’s arm is shown in <a href="ch04.html#ch4fig17">Figure 4-17</a>. Although this example might not look like much, if you hold the page at arm’s length and squint, the edges should appear to smoothly blend into the white background, producing the illusion of a graceful curve.</p>
<div class="image"><a id="page_67"/><img alt="image" src="graphics/f04-16.jpg"/></div>
<p class="figuret"><a id="ch4fig16"/><em>Figure 4-16: A close-up of one pixel at the end of the bug-man’s arm, with a scattering of 10 points to estimate the area covered by the model</em></p>
<div class="image"><img alt="image" src="graphics/f04-17.jpg"/></div>
<p class="figuret"><a id="ch4fig17"/><em>Figure 4-17: Using grayscale to anti-alias, shown with and without the pixel grid.</em></p>
<h5 class="h5" id="ch04lev3sec05"><strong>Blending into Any Background</strong></h5>
<p class="noindent">We need to generalize the technique just described in order for it to work with a background other than solid white. Consider <a href="ch04.html#ch4fig18">Figure 4-18</a>. On the left is the bug-man model, and in the middle is the background for the shot in which he’ll appear: a close-up of a setting sun over a rocky terrain. On the right is the complete image with the model superimposed over the background.</p>
<div class="image"><img alt="image" src="graphics/f04-18.jpg"/></div>
<p class="figuret"><a id="ch4fig18"/><em>Figure 4-18: The bug-man model, a background, and the model superimposed over the background</em></p>
<p class="indent">This book is printed in black and white, but in this image the sun would be shades of reddish-orange and the ground would be shades of brown. As before, pixels along the model’s edge will appear jagged unless we use an anti-aliasing technique. But using the previous technique to color pixels in gray tones won’t help the black edge blend into a background of red-orange and brown pixels.</p>
<p class="indent">A more general anti-aliasing technique calculates an <em>alpha level</em> for each pixel based on the percentage of the pixel that’s covered by the model. You can think of an alpha level as a measure of opacity. Like the color levels, an alpha level is typically defined in the range of 0–255. In <a href="ch04.html#ch4fig19">Figure 4-19</a>, a black <a id="page_68"/>bar is superimposed over a tree at different alpha levels. At an alpha level of 255, the bar is entirely opaque, while at 25 the bar is barely visible. An alpha level of 0 would make the bar completely invisible.</p>
<p class="indent">The alpha levels of all the pixels in a bitmap are collectively referred to as its <em>alpha channel</em>. The process of making an alpha channel for a model is similar to how we anti-aliased the black arm against the white background, only rather than assigning a shade of gray based on the pixel’s coverage percentage, we assign an alpha value for the pixel instead. Each model is thus conceptually transformed into both a bitmap, showing the color of each pixel covered by the model, and an alpha channel, showing the opacity of each pixel. <a href="ch04.html#ch4fig20">Figure 4-20</a> shows the color bitmap (here, just black pixels) and the alpha channel of the bug-man arm separately.</p>
<div class="image"><img alt="image" src="graphics/f04-19.jpg"/></div>
<p class="figuret"><a id="ch4fig19"/><em>Figure 4-19: A tree covered by five black bars of varying alpha level</em></p>
<div class="image"><img alt="image" src="graphics/f04-20.jpg"/></div>
<p class="figuret"><a id="ch4fig20"/><em>Figure 4-20: The arm of the bug-man model with its corresponding color bitmap and alpha channel</em></p>
<p class="indent">Now the model can be applied to any background. The final color of each pixel is a blend of the color in the background and the model’s color bitmap, with the alpha level determining how much of each color goes into the mix. In the bug-man scene of <a href="ch04.html#ch4fig18">Figure 4-18</a>, if a black bug-man pixel with 30 percent alpha were placed on top of a red-orange sunset background pixel, the result would be a darker red-orange, as shown in <a href="ch04.html#ch4fig21">Figure 4-21</a>. The resulting amount of each color component lies somewhere between the two mixed colors, but because the black pixel is only 30 percent alpha, the red-orange background color dominates. For pixels completely covered by the model, the alpha level is 100 percent and the color in the final image is the same as in the model’s color bitmap. In this way, a bitmap with an alpha channel can be smoothly blended into any background.</p>
<div class="image"><a id="page_69"/><img alt="image" src="graphics/f04-21.jpg"/></div>
<p class="figuret"><a id="ch4fig21"/><em>Figure 4-21: The red, green, and blue components of three colors: the black of the model, the red-orange of the background pixel, and the result of mixing these two colors if the black has 30% alpha</em></p>
<h4 class="h4" id="ch04lev2sec04"><strong><em>From Cel Animation Software to Rendered 2D Graphics</em></strong></h4>
<p class="noindent">These techniques are now the default way to produce cel-style animation, and software is as common a tool for animation studios as brushes and paper were in earlier generations. While some animation studios use programs they developed themselves, most direct-to-video or television animation and some feature films are made with off-the-shelf software. One such program, Toon Boom, has been used for television shows such as <em>The Simpsons</em> and <em>Phineas and Ferb</em>, while the artists at Studio Ghibli use a program called Toonz to animate such movies as <em>Spirited Away</em>.</p>
<p class="indent">The usefulness of these techniques is not limited to filmmaking, though. More generally, the software techniques used to mimic traditional cel-style animation are called two-dimensional graphics, or <em>2D graphics</em>, because the control points for models are located with two coordinates, x and y. The general task of transforming models into final images is called <em>rendering</em>, and the software that performs the task is the <em>renderer</em>. Rendered 2D graphics are used throughout computing. Many video games, such as <em>Angry Birds</em>, use the cel-animation look. These rendering techniques are also used to display fonts and icons in applications such as browsers and word processors.</p>
<p class="indent">Although rendered 2D graphics are ubiquitous in computing and can make great cel-style animations, creating the mind-blowing visuals of films like <em>Avatar</em> requires extending these ideas to three dimensions.</p>
<h3 class="h3" id="ch04lev1sec02"><strong>Software for 3D CGI</strong></h3>
<p class="noindent">Breathtaking CGI in films like <em>Avatar</em> use <em>3D graphics</em>. The “3D” here doesn’t refer to simulated depth perception, like in a 3D movie, but rather to the three coordinates of each control point in the animation models: x- and y-coordinates for horizontal and vertical positioning and a <em>z</em>-coordinate to indicate depth. <a href="ch04.html#ch4fig22">Figure 4-22</a> shows a three-dimensional model of a box with a highlighted point defined by x-, y-, and z-coordinates.</p>
<div class="image"><a id="page_70"/><img alt="image" src="graphics/f04-22.jpg"/></div>
<p class="figuret"><a id="ch4fig22"/><em>Figure 4-22: A box in three-dimensional space</em></p>
<p class="indent">As with 2D graphics, 3D graphics are all about rendering models into bitmaps. The rendering methods that produce the most realistic results require the most processing time. Movie CGI is impressive largely because the renderer can process each frame for a very long time, resulting in the high-quality result that I’ll call <em>movie-quality rendering</em>. We’ll discuss the keys to movie-quality rendering in this chapter. Then, in <a href="ch05.html#ch05">Chapter 5</a>, we’ll talk about graphics for video games, and see how many of the techniques shown here have to be modified, faked, or scrapped altogether when images must be produced in real time in response to user interaction.</p>
<h4 class="h4" id="ch04lev2sec05"><strong><em>How 3D Scenes Are Described</em></strong></h4>
<p class="noindent">3D models are built out of lines and curves just like 2D models, but these lines and curves stretch across three dimensions instead of two. The box in <a href="ch04.html#ch4fig22">Figure 4-22</a> is a very simple model defined by eight points; the models used in movie CGI tend to be complex, defined by hundreds, thousands, or even tens of thousands of points. As with 2D rendering, models in 3D rendering are defined by local coordinates. The points at the corners of the box in <a href="ch04.html#ch4fig22">Figure 4-22</a>, for example, are defined relative to the local origin at the bottom of the box.</p>
<p class="indent">While 2D rendering can directly map from local coordinates to screen coordinates, 3D models are first placed into scenes in a virtual world that has its own coordinate space called <em>world coordinates</em>. Designing a 3D scene is the CGI equivalent of building a movie set. We can place as many models as we want in the virtual world, of any size and at any location, and the renderer can figure out the world coordinates for all the locations on the models.</p>
<p class="indent">Introducing another coordinate system might seem like an unnecessary complication, but world coordinates actually make 3D graphics much easier in the long run. For example, an artist can model a dining room chair independently of the other models for the scene in which it will be used. Then the artist can copy the single chair model to make as many seats as needed <a id="page_71"/>for the dining room scene. Also, a scene, like a movie set, isn’t built to produce a single image but to create a space that will be shown in many images from many different angles, as we’ll see in the next section.</p>
<h4 class="h4" id="ch04lev2sec06"><strong><em>The Virtual Camera</em></strong></h4>
<p class="noindent">With the scenery in place, a <em>viewpoint</em> is needed. On a movie set, a cinematographer determines what image is captured by placing the camera and choosing a lens. For CGI, the viewpoint determines how the three-dimensional scene is transformed into a two-dimensional rendered image.</p>
<p class="indent">Transformation from three dimensions to two is known as <em>projection</em>. To better understand projection, consider <a href="ch04.html#ch4fig23">Figure 4-23</a>, in which an imaginary pyramid originates from the eye of a viewer looking at a table. A translucent grid lies in the pyramid between the viewer and the scene. Looking through the grid, the viewer can map each visible location on the three-dimensional table to a particular square on the two-dimensional grid. That’s projection, but instead of a grid of squares, it’s a grid of pixels in a bitmap.</p>
<div class="image"><img alt="image" src="graphics/f04-23.jpg"/></div>
<p class="figuret"><a id="ch4fig23"/><em>Figure 4-23: Projecting a three-dimensional scene onto a flat display is like viewing a real-world scene through a translucent grid.</em></p>
<h4 class="h4" id="ch04lev2sec07"><strong><em>Direct Lighting</em></strong></h4>
<p class="noindent">There are many different methods of projection, but projection methods in movie-quality rendering are part of the larger issue of lighting. Although we don’t often realize it, our perception of an object’s color is determined <a id="page_72"/>not only by the object itself but also by the lighting under which we view the object. Knowing this, filmmakers carefully light their scenes for dramatic effect, but the problem of lighting in CGI is more fundamental. Without an accurate model of scene lighting, the resulting images won’t look realistic at all.</p>
<p class="indent">To understand why this is true, let’s take a simple scene of a yellow metal table in a green room, as shown in <a href="ch04.html#ch4fig24">Figure 4-24</a>.</p>
<div class="image"><img alt="image" src="graphics/f04-24.jpg"/></div>
<p class="figuret"><a id="ch4fig24"/><em>Figure 4-24: A 3D scene</em></p>
<p class="indent">From this viewpoint, some of the pixels will be “table” pixels and the others will be “wall” or “floor” pixels. A simple renderer might color every table pixel the same shade of yellow, while coloring all the other pixels an identical green. But because this coloring ignores the effect of lighting, the resulting image would be flat and unrealistic. (The blocks of solid color would make the image resemble an animation cel—an interesting effect, but not realistic.) A movie-quality renderer needs a <em>lighting model</em> so that the colors in our scenes are influenced by virtual light sources.</p>
<p class="indent">The essential real-world lighting effects modeled by CGI renderers include distance, diffuse reflection, and specular reflection.</p>
<h5 class="h5" id="ch04lev3sec06"><strong>The Distance Effect</strong></h5>
<p class="noindent">To understand the distance effect, imagine a lamp emitting pure white light hanging directly over the middle of the table, as in <a href="ch04.html#ch4fig25">Figure 4-25</a>.</p>
<p class="indent">The closer this light is to the table, the brighter the table appears. In the physical world, this effect is caused by the beam of light widening as it gets farther from its source. The more narrowly focused a light source is, the less the light diminishes with distance—which explains why the highly focused light of a laser hardly diminishes at all.</p>
<div class="image"><a id="page_73"/><img alt="image" src="graphics/f04-25.jpg"/></div>
<p class="figuret"><a id="ch4fig25"/><em>Figure 4-25: The closer a light is to a surface, the brighter the surface appears.</em></p>
<p class="indent">Renderers can model the distance effect realistically, but they also allow unrealistic distance effects in order to create a particular look or mood. For example, in a scene where a character carries a torch through a cave, a lighting designer will decide whether the torchlight extends a long way or barely penetrates the gloom.</p>
<p class="indent">All of the lighting effects we’ll discuss allow these kinds of adjustments. Although it may seem strange to intentionally create unrealistic light when the whole point of the lighting model is to make a realistic scene, there’s a subtle but important distinction between reality and viewers’ expectations of reality. Using light in unrealistic ways is an old cinematic trick. For example, when a character in a darkened bedroom turns on a lamp, a stage light in the ceiling of the set also turns on, so that the entire scene is softly lit. Without the extra, unrealistic light, the scene won’t look right—it will appear too dark. In the same way, CGI lighting models allow their controls to be tweaked to produce results that are a little wrong, but feel right.</p>
<h5 class="h5" id="ch04lev3sec07"><strong>The Diffuse Reflection Effect</strong></h5>
<p class="noindent">Light that strikes a surface head-on appears brighter than light that strikes a surface at a sharp angle. In <a href="ch04.html#ch4fig26">Figure 4-26</a>, the center of the table seems brighter, or yellower, than the corners.</p>
<div class="image"><a id="page_74"/><img alt="image" src="graphics/f04-26.jpg"/></div>
<p class="figuret"><a id="ch4fig26"/><em>Figure 4-26: Diffuse lighting depends on the angle at which light strikes a surface.</em></p>
<p class="indent">This is due in part to the distance effect—the center is closer to the lamp than the corners—but is mostly due to the <em>diffuse reflection</em> effect, a change in brightness caused by variation in the light’s <em>angle of incidence</em>. In <a href="ch04.html#ch4fig27">Figure 4-27</a>, the solid lines show the incident light rays, while the dashed lines are reflections. As you can see, the light strikes point B at a much larger angle than at point A, and therefore point B appears brighter than point A. But note that the <em>viewing angle</em>, or <em>angle of reflectance</em>, makes no difference in the diffuse reflection effect. Therefore, point A will look the same to both viewers, and so will point B.</p>
<div class="image"><img alt="image" src="graphics/f04-27.jpg"/></div>
<p class="figuret"><a id="ch4fig27"/><em>Figure 4-27: Diffuse lighting varies based on the angle at which the light strikes the surface, but is the same for all viewpoints.</em></p>
<h5 class="h5" id="ch04lev3sec08"><a id="page_75"/><strong>The Specular Reflection Effect</strong></h5>
<p class="noindent">Because the metal tabletop is highly reflective, it partially acts as a mirror. As with any mirror, what you see in it depends on what lies on the opposite angle to your point of view. <a href="ch04.html#ch4fig28">Figure 4-28</a> shows a shiny spot on the table where the hanging light is at the opposite angle from our viewpoint, approximately midway between the center of the table and the closest edge. Because this spot is a mirror-like reflection of the white light bulb, the spot will be white.</p>
<div class="image"><img alt="image" src="graphics/f04-28.jpg"/></div>
<p class="figuret"><a id="ch4fig28"/><em>Figure 4-28: Specular lighting depends on both the angle at which the light strikes the surface and the view angle.</em></p>
<p class="indent">These shiny spots are known as <em>specular reflections</em>, and appear where the light’s angle of incidence matches the angle of reflectance. <a href="ch04.html#ch4fig29">Figure 4-29</a> shows the location of specular reflections for two different viewpoints; notice that each ray rebounds at the same angle that it struck the table. Both viewers see a shiny spot on the table, but they see the spot in different places.</p>
<p class="indent">In the real world, some materials reflect differently than others. A shiny material like plastic has a high level of specular reflection, while a dull material like cotton cloth has more diffuse reflection. CGI lighting models allow artists to set different reflection properties for each surface on a model to match the appearance of real-world materials.</p>
<div class="image"><a id="page_76"/><img alt="image" src="graphics/f04-29.jpg"/></div>
<p class="figuret"><a id="ch4fig29"/><em>Figure 4-29: The specular light on the table appears in different places for different viewpoints.</em></p>
<h4 class="h4" id="ch04lev2sec08"><strong><em>Global Illumination</em></strong></h4>
<p class="noindent">So far we’ve been discussing <em>direct lighting</em>, the result of light flowing directly from a source to a surface. In reality, the color of every object in the physical world is influenced by the color of every other object nearby. A light-brown sofa in a room with white walls looks very different than it does in a room with blue walls, because the sofa gains a subtle tint from the reflected light of the walls. This is <em>indirect lighting</em>, and for a computer-generated image to look realistic, it must account for this effect. A lighting model that accounts for all of the light in the scene, both direct and indirect, is known as a <em>global illumination model</em>.</p>
<p class="indent">An example of indirect lighting is shown in <a href="ch04.html#ch4fig30">Figure 4-30</a>. Let’s assume the light bulb emits pure white light. The beam first hits a wall that is painted cyan (a light blue). The light reflecting from the wall is likewise cyan, and when the reflected cyan light strikes the yellow rug, the resulting reflected light is green. The bouncing colors therefore result in a subtle greenish tint in the yellow rug. This sequence of color changes is caused by <em>subtractive color</em>, where mixing colors results in a darker shade, the way a color inkjet makes different shades by mixing cyan, yellow, and magenta ink. Subtractive color is the opposite of the additive RGB system we discussed early in the chapter, in which mixing results in a brighter color.</p>
<div class="image"><a id="page_77"/><img alt="image" src="graphics/f04-30.jpg"/></div>
<p class="figuret"><a id="ch4fig30"/><em>Figure 4-30: Light bouncing off multiple surfaces influences apparent color.</em></p>
<h4 class="h4" id="ch04lev2sec09"><strong><em>How Light Is Traced</em></strong></h4>
<p class="noindent">A global illumination model seems to require following the paths of light beams as they bounce around the scene. A naive renderer, then, would use three-dimensional coordinate math to trace the path of every beam of light from each light source as it bounces from surface to surface. This would waste a lot effort, though, because it would deduce the color of every surface in the scene—including surfaces the viewer can’t actually see because they lie outside of the viewpoint’s field of view, are obscured by other objects, or are facing away from the viewpoint.</p>
<h5 class="h5" id="ch04lev3sec09"><strong>Why Light Is Traced Backward</strong></h5>
<p class="noindent">Renderers avoid this inefficiency by tracing beams backward from the viewpoint into the scene, a technique known as <em>ray tracing</em>. In ray tracing, an imaginary line is traced from the viewpoint through the center of each square in a pixel grid, as shown in <a href="ch04.html#ch4fig31">Figure 4-31</a>. The geometry of each model in the scene is compared with the imaginary line to see if the two intersect. The closest point of intersection to the viewpoint indicates the visible surface that will color the pixel. Note that this method of projection closely follows the explanation of <a href="ch04.html#ch4fig23">Figure 4-23</a>.</p>
<p class="indent">Next, more lines are traced outward from this known visible point. The goal is to discover which lines end at light sources, either directly or after bouncing off other objects. As shown in <a href="ch04.html#ch4fig31">Figure 4-31</a>, specular reflections trace only the rebound at the same angle of each impact, but diffuse reflections trace a number of lines in random directions. As the diffuse beams strike other objects, they will spawn more diffuse reflections, which means the number of paths to trace keeps multiplying the more the process continues. Renderers apply a cut-off to limit the number of bounces for each beam.</p>
<div class="image"><a id="page_78"/><img alt="image" src="graphics/f04-31.jpg"/></div>
<p class="figuret"><a id="ch4fig31"/><em>Figure 4-31: Tracing a beam of light from a viewpoint, through the center of the shaded pixel, until it reaches a model in the scene. To determine specular lighting, the tracing rebounds at the same angle as impact; for diffuse lighting, it rebounds at several random angles.</em></p>
<h5 class="h5" id="ch04lev3sec10"><strong>How Ray Tracing Models Real-World Effects</strong></h5>
<p class="noindent">Although ray tracing is a lot of work for even a network of computers, the method can accurately model many real-world visual effects.</p>
<p class="indent">One such effect is translucency. Although a bitmap can be made translucent by assigning low alpha values to pixels, that’s not the whole story for transparent materials like glass. A glass tumbler, for example, doesn’t merely allow light to pass through it, but also distorts whatever is behind it, as shown in <a href="ch04.html#ch4fig32">Figure 4-32</a>.</p>
<div class="image"><img alt="image" src="graphics/f04-32.jpg"/></div>
<p class="figuret"><a id="ch4fig32"/><em>Figure 4-32: The distortion of curved glass</em></p>
<p class="indent"><a id="page_79"/>A ray tracing renderer can refract light beams according to the laws of optics as they pass through translucent materials. This will not only allow the renderer to model glass in CGI, but will also help to reproduce the distorting effects of transparent materials and liquids like water.</p>
<p class="indent">Ray tracing can also be extended to simulate camera lenses. Normally, all objects in a computer-generated image are perfectly in focus. In images shot by a movie camera, though, only objects at a certain distance from the camera are in focus, leaving other objects less focused the farther they are from that distance. While one might consider having everything in focus an <em>advantage</em> of computer-generated imagery, skilled cinematographers use selective focus to help tell their stories. In <a href="ch04.html#ch4fig33">Figure 4-33</a>, Jimmy Stewart and Grace Kelly are in focus in the foreground, while the apartments in the background are blurry; the viewer’s attention is drawn to the actors, but the distant, open background is a subtle reminder of how visible the apartments in this courtyard are from each other—an important detail in the film. Because movie viewers have grown accustomed to receiving depth information about scenes through the use of focus, computer-generated images and movies often must simulate the use of photography lenses to match viewer expectations.</p>
<div class="image"><img alt="image" src="graphics/f04-33.jpg"/></div>
<p class="figuret"><a id="ch4fig33"/><em>Figure 4-33: Focus depth in</em> Rear Window <em>(Paramount Pictures/Patron Inc., 1954)</em></p>
<p class="indent">Shadows are another key component of a realistic computer-generated image. Ray tracing produces shadows naturally, as shown in <a href="ch04.html#ch4fig34">Figure 4-34</a>. Because no beam of light can reach the shadowed area, no beam traced back from the viewpoint can reach the light, so the area will remain dark.</p>
<div class="image"><a id="page_80"/><img alt="image" src="graphics/f04-34.jpg"/></div>
<p class="figuret"><a id="ch4fig34"/><em>Figure 4-34: Tracing beams of light renders shadows naturally.</em></p>
<p class="indent">Ray tracing can also model highly reflective surfaces simply by setting a very high specular reflection property on the material. For example, when you’re standing inside a well-lit room when it’s dark outside, the room in which you stand is clearly reflected in the window.</p>
<p class="indent">So although ray tracing is computationally intense, adding these real-world effects doesn’t add much extra work, and the effects add greatly to the realism of the final image. In the next chapter, you’ll see the tricks video games use to render reflective surfaces and shadowing in real time, when ray tracing isn’t an option. Some effects, like glass distortion, are usually not even attempted in real-time rendering; there’s simply not enough time.</p>
<h4 class="h4" id="ch04lev2sec10"><strong><em>Full-Scene Anti-Aliasing</em></strong></h4>
<p class="noindent">While the images rendered by ray tracing can be stunning, they can suffer from the same aliasing problems we saw with 2D graphics. Whenever one object is in front of another, each projected light beam will either hit the foreground object or miss and hit what lies behind the object. <a href="ch04.html#ch4fig35">Figure 4-35</a> shows a chair on a rug as seen from a particular viewpoint. Beams traced from this viewpoint near the edge of the chair seat hit either the chair or the rug, which assigns the associated pixel the color of one surface or the other. This causes a jagged edge like those we saw for 2D images.</p>
<p class="indent">The renderer can avoid the jaggies by applying anti-aliasing to the whole image. There are many methods for <em>full-screen anti-aliasing</em>, but with ray tracing, a direct way to anti-alias the entire scene is to project more beams from the viewpoint than necessary. For example, rather than just sending out a beam at the center of every pixel, the renderer might also send out beams into the spaces between the pixel centers. After the color for every beam is determined, the final color of each pixel is blended from the colors of the center beam and the beams at the neighboring corners. Pixels that lie along an edge in the image are thereby assigned intermediate colors, avoiding the jagged “staircase” effect.</p>
<div class="image"><a id="page_81"/><img alt="image" src="graphics/f04-35.jpg"/></div>
<p class="figuret"><a id="ch4fig35"/><em>Figure 4-35: In the highlighted area, each light beam trace ends on the chair or the rug, resulting in jaggies.</em></p>
<p class="indent"><a href="ch04.html#ch4fig36">Figure 4-36</a> demonstrates this idea. Each circle represents a beam projected into a scene. The pixels are colored based on the average of colors in the center and corners of each pixel, which results in the anti-aliased edge shown on the right. More beams can be traced for even better results, at the expense of more processing time.</p>
<div class="image"><img alt="image" src="graphics/f04-36.jpg"/></div>
<p class="figuret"><a id="ch4fig36"/><em>Figure 4-36: Each pixel’s final color is a blend of five beams traced into the scene, one at the center of the pixel, and four at the corners.</em></p>
<h3 class="h3" id="ch04lev1sec03"><strong>Combining the Real and the Fake</strong></h3>
<p class="noindent">In a completely computer-animated film, rendering is the final step in producing each frame, but when CGI is integrated into live-action films, there’s more work to be done. Imagine, for example, a scene in which a computer-generated <em>Tyrannosaurus rex</em> stalks through a real field of grass.</p>
<p class="indent"><a id="page_82"/>To make this happen, we first need two sequences of digital images. One sequence shows the grass field, and has either been shot on a digital camera or on a traditional film camera and then subsequently scanned. Either way, the movements of the camera are computer controlled, which allows the camera movement to match up precisely with the movement of the virtual camera in the other sequence, the computer-generated animation of the dinosaur.</p>
<p class="indent">Next, the two sequences are combined, frame-by-frame, in a process called <em>digital composition</em>. Although the dinosaur sequence was produced from 3D models, at this point both sequences are simply two-dimensional bitmaps and are combined using the same method used to place our bugman on top of the sunset back in <a href="ch04.html#ch4fig18">Figure 4-18</a>. Through the use of alpha blending, the edges of the dinosaur in each frame are smoothly blended with the field-of-grass background. Without this blending, the dinosaur will have a shimmering edge like that of a weatherman standing in front of the five-day forecast.</p>
<p class="indent">Digital composition is used throughout modern moviemaking, even when no computer-generated imagery is involved, such as for <em>dissolves</em> (a transition where one scene smoothly fades into the next). Formerly, dissolves were produced by a device known as an <em>optical printer</em>, which pointed a camera at a screen onto which several projectors were aimed. The camera would make a new film that combined the images of the projected films. A dissolve was accomplished by turning down the light in one projector while turning up the light on another. The results were acceptable, but you could always spot an optical printer sequence in a movie because the second-generation images would be blurry compared to the rest of the film. Now, dissolves, superimposed titles, and all sorts of other movie effects that you might not really think of as “effects” are performed with digital composition.</p>
<h3 class="h3" id="ch04lev1sec04"><strong>The Ideal of Movie-Quality Rendering</strong></h3>
<p class="noindent">When all the advanced rendering techniques described in this chapter come together, the results can be stunningly realistic, highly stylized, or anything in between. The only real limitation on CGI is time, but that’s a big limitation. The truth is, what I’ve been calling movie-quality rendering can be an unattainable ideal even for Hollywood. Although films can be in production for several years, there’s only so much time that can be allotted for each frame. Consider the computer-animated Pixar film <em>WALL-E</em>. With a running time of 98 minutes, the film required the rendering of over 140,000 high-resolution computer images. If Pixar wanted to produce all of the images for <em>WALL-E</em> in two years, it would have to render images, on average, every eight minutes.</p>
<p class="indent"><a id="page_83"/>Even on a networked “render farm,” eight minutes is not sufficient to use ray tracing, global illumination, glass refraction, and all the other high-end techniques for every single image. Faced with these practical constraints, filmmakers pick and choose which techniques to use on each sequence to maximize visual impact. When ideal rendering is required, the time is spent, but when the best effects won’t be missed or the budget won’t allow it, they aren’t used. The renderer used at Pixar—a program called RenderMan that was originally developed at Lucasfilm—can forgo ray tracing and its massive associated computational effort, but that means many of the realism-enhancing effects have to be produced some other way.</p>
<p class="indent">But how is that done? What kinds of tricks are needed to render images without ray tracing—images that may not be perfectly realistic but are still amazing? To answer this question, we’ll turn from Hollywood to the world of video games, where rendering is under an extreme time limitation. How extreme? If eight minutes isn’t enough time to produce an ideal render, imagine trying to render an image in under 20 <em>milliseconds</em>. In the next chapter, we’ll see how video games produce great graphics in a hurry.<a id="page_84"/></p>
</body></html>