- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE SQUARE-WAVE GENERATOR**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Signal generators*, also called waveform generators or function generators,
    create an alternating current (AC) voltage that can be used in a variety of electronic
    tests and diagnostic procedures. A *square-wave generator* like the one you will
    build in this chapter (shown in [Figure 9-1](ch09.xhtml#ch09fig9-1)) is an electronic
    lab instrument that creates a continuous sequence of equally spaced pulses of
    electricity that are on for a certain amount of time, switch off for an equal
    duration, and switch back on again, repeatedly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: The completed Square-Wave Generator*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Build a Square-Wave Generator?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Signal generators like this one are frequently used to perform diagnostic jobs,
    from evaluating the frequency response of components and subsystems to providing
    stimulus to systems under development. Some specific uses for signal generators
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: • Observing the integrity of an amplifier, attenuator, or other device
  prefs: []
  type: TYPE_NORMAL
- en: • Measuring timing characteristics of a circuit
  prefs: []
  type: TYPE_NORMAL
- en: • Simulating real-world on/off events
  prefs: []
  type: TYPE_NORMAL
- en: The signal generator part of this project is primarily a square-wave generator.
  prefs: []
  type: TYPE_NORMAL
- en: '***What Is a Square Wave?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What’s a square wave and what’s it good for, you ask? A *square wave* is an
    electrical signal that starts at zero voltage, rises to some level (its *amplitude*),
    stays at that level for some duration, returns to zero, and then repeats the process
    in a symmetric pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The square wave is one of the fundamental wave forms in electronics, and it
    is in many respects the most useful, in part because it has both a DC component
    and an AC component. The DC component is the fact that it stays at a certain voltage
    for a period of time and then almost instantaneously transitions to a different
    level. The AC component is that it repeats this transition at a regular period.
    [Figure 9-2](ch09.xhtml#ch09fig9-2) shows a square wave.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: A typical square wave*'
  prefs: []
  type: TYPE_NORMAL
- en: The square wave has an amplitude and a period. The *period* of the wave is the
    duration of a complete cycle, and it could be in seconds, minutes, milliseconds,
    microseconds, and so on. The *frequency* is how many cycles occur in a certain
    period of time (one second is the accepted standard) and is therefore the reciprocal
    of the period. For a period of *T*, the formula to determine the frequency is
    *f* = 1/*T*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Why Square Waves Are Useful***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Square waves are particularly useful when developing and testing electronic
    products. For example, the clock in a microcontroller system is essentially a
    square wave. In some diagnostic and test procedures, the microcontroller’s internal
    clock can be disconnected and replaced by an external signal generated by a signal
    generator—in this case, a square wave or sine wave work equally well. You can
    then test the microcontroller at different frequencies. For certain processors,
    it’s often valuable to slow a processor clock during testing to see exactly where
    software glitches occur.
  prefs: []
  type: TYPE_NORMAL
- en: Other uses include sending a signal into a device being tested in order to tune
    the circuit to the proper value or checking a device’s frequency response or integrity.
    A square-wave generator can also act as a pulse generator to test a variety of
    digital circuits. You will find this application useful in the Ballistic Chronograph
    in [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: Because a square wave’s voltage starts at zero and rises almost instantly, it
    can also be used as a switching voltage to turn circuits off and on at the frequency
    of the square wave. The frequency of the Square-Wave Generator in this chapter
    ranges from 1 kHz to around 30 MHz (with the divider switch included, it can go
    down to 100 Hz). This frequency range can be varied via a potentiometer, so you
    can turn things on and off at different rates. This allows the Square-Wave Generator
    to simulate almost any repetitive switching action, which is useful for cycling
    things on and off for life-test applications, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**OTHER USEFUL WAVEFORMS**'
  prefs: []
  type: TYPE_NORMAL
- en: A square wave is only one common type of waveform, though. Probably the most
    common is the *sine wave*, or sinusoidal wave, in which the wave is a continuous
    curve and one cycle represents 360 degrees. Yet another wave type frequently encountered
    in electronics is the triangle wave. Both are depicted in [Figure 9-3](ch09.xhtml#ch09fig9-3).
    The amplitude and period of a sine wave and a triangle wave are measured the same
    way as for a square wave.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: A sine wave (top) and a triangle wave (bottom)*'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these waveforms has specific characteristics that make them useful in
    different applications. Sine waves and triangle waves are both important in electronic
    music projects, for example. This project, however, focuses on the square wave,
    and as you progress through this chapter, you will see it can be applied in a
    variety of ways.
  prefs: []
  type: TYPE_NORMAL
- en: '***A Frequency Counter***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to providing a signal generator, this project includes a *frequency
    counter*, which reads wave frequencies, so you can display the generator’s output
    frequency on a digital readout. You can also use the frequency counter as a separate
    instrument on its own to measure frequency from an outside source and display
    it. This project also displays the period, or impulse time, of the wave.
  prefs: []
  type: TYPE_NORMAL
- en: In operation, the frequency counter receives an AC input signal and counts each
    pulse. After a certain number of pulses have been counted, the counter compares
    this against a clock signal, sometimes referred to as a *time base*, and displays
    the number of pulses per unit time—for example, pulses or cycles per second.
  prefs: []
  type: TYPE_NORMAL
- en: To assure accuracy, the counter compares the pulses against a clock, usually
    one that is crystal-based. For instruments that require the utmost accuracy, the
    crystal-clock assembly is a precision subsystem often placed in a temperature-controlled
    environment. The frequency counter in this project uses the 16 MHz crystal on
    the Arduino Pro Mini. In fact, the Pro Mini has most of the circuitry to implement
    a complete frequency counter with few additional components. It includes the clock
    registers for counting and just about everything else a frequency counter needs
    with no external components.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Professional laboratory and desktop instruments selling for hundreds (or thousands)
    of dollars often provide a very wide frequency range, from under 1 Hz to several
    GHz, and offer anywhere from 6- to 10-digit precision. Their displays can be switched
    to read frequency or time (the time between pulses), too*.'
  prefs: []
  type: TYPE_NORMAL
- en: To do all of this, the Square-Wave Generator takes advantage of the Arduino
    AT328 16 MHz, 5V Pro Mini, which is a smaller, lower-priced version of the Arduino
    Nano. The generator also includes special circuitry to divide a signal’s frequency,
    allowing you to provide an output of very low frequencies at one end and allowing
    the frequency counter to read very high frequencies—above what the Pro Mini can
    normally handle—at the other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shortcomings of the Square-Wave Generator**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this project produces a square-wave generator and a frequency counter
    that perform well in many applications, it has shortcomings compared with professional
    laboratory and bench instruments. The generator has a less than 1 percent frequency
    error, which is good for hobby projects but doesn’t match the tolerances of laboratory-grade
    and direct-digital-synthesizer (DDS) generator units. Those units often have errors
    measured in the part-per million (PPM) range. And the frequency counter uses the
    time base of the Arduino, which, while accurate, doesn’t match higher-priced units
    with crystal ovens and other special circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: This generator also doesn’t offer the resolution of multiple digits. Many lab
    and bench instruments have resolutions that go into as many as 10 digits. That
    said, the instrument has worked well for me in a broad variety of Arduino and
    other projects, where a greater resolution wasn’t required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Required Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drill and drill bits
  prefs: []
  type: TYPE_NORMAL
- en: Keyhole saw
  prefs: []
  type: TYPE_NORMAL
- en: Soldering iron and solder
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs: []
  type: TYPE_NORMAL
- en: '**Parts List**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the Arduino Pro Mini, you’ll need a Linear Technology oscillator
    chip and a small handful of other components. Here’s the complete parts list:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Pro Mini or clone (There are several available, and some have different
    pinouts—particularly for pins A4 and A5\. [Figure 9-4](ch09.xhtml#ch09fig9-4)
    shows the pinout for the particular clone that I used. Other units with different
    pinouts will work, but the connections on the shield may have to be changed.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Pinout of the Deek-Robot Pro Mini Arduino clone*'
  prefs: []
  type: TYPE_NORMAL
- en: One LTC1799 oscillator chip and breadboard-compatible adapter board, like the
    5-SOT-23 adapter board shown in [Figure 9-5](ch09.xhtml#ch09fig9-5) (See “[Using
    SOICs](ch00.xhtml#ch00lev1sec7)” on [page 20](ch00.xhtml#page_20) for tips on
    how to use a surface mount chip like this.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: This adapter board has a complete variable frequency oscillator
    (1 KHz to 30 KHz) and CMOS buffer circuit*.'
  prefs: []
  type: TYPE_NORMAL
- en: One 250-kilohm carbon potentiometer
  prefs: []
  type: TYPE_NORMAL
- en: Two 0.1 μF ceramic capacitors
  prefs: []
  type: TYPE_NORMAL
- en: One LM7805 voltage regulator
  prefs: []
  type: TYPE_NORMAL
- en: Two SPDT center-off toggle switches
  prefs: []
  type: TYPE_NORMAL
- en: Two SPDT toggle switches
  prefs: []
  type: TYPE_NORMAL
- en: One HCT4017 decade counter IC, like the CD4017 B shown in [Figure 9-6](ch09.xhtml#ch09fig9-6)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: The CD4017 B is a CMOS counter/divider comprising a 5-stage Johnson
    counter with 10 decoded outputs. It is used here as a divide-by-10 counter*.'
  prefs: []
  type: TYPE_NORMAL
- en: One 1 μF electrolytic capacitor
  prefs: []
  type: TYPE_NORMAL
- en: One 10 μF electrolytic capacitor
  prefs: []
  type: TYPE_NORMAL
- en: One 20×4 LCD
  prefs: []
  type: TYPE_NORMAL
- en: One I²C adapter, if not included with the LCD
  prefs: []
  type: TYPE_NORMAL
- en: One PCB shield (See “[Downloads](ch01.xhtml#ch01lev1sec3)” on [page 262](ch09.xhtml#page_262)
    if you don’t want to design your own.)
  prefs: []
  type: TYPE_NORMAL
- en: One Hammond 1595C sloped front enclosure (or equivalent)
  prefs: []
  type: TYPE_NORMAL
- en: One battery holder
  prefs: []
  type: TYPE_NORMAL
- en: One knob
  prefs: []
  type: TYPE_NORMAL
- en: Four 4-40×1/2-inch screws and washers
  prefs: []
  type: TYPE_NORMAL
- en: Eight 4-40 nuts
  prefs: []
  type: TYPE_NORMAL
- en: One piece of double-sided foam tape
  prefs: []
  type: TYPE_NORMAL
- en: One 9V battery
  prefs: []
  type: TYPE_NORMAL
- en: Assorted 28- or 30-gauge hook-up wires
  prefs: []
  type: TYPE_NORMAL
- en: (Optional) Four banana plug jacks *or* three BNC connectors
  prefs: []
  type: TYPE_NORMAL
- en: (Optional) One 3.5 mm jack
  prefs: []
  type: TYPE_NORMAL
- en: (Optional) One 9V, 100 mA, 110V wall power supply (for more information see
    “[Battery Power](ch09.xhtml#ch09lev2sec10)” on [page 278](ch09.xhtml#page_278))
  prefs: []
  type: TYPE_NORMAL
- en: Note that I elected to use banana plug jacks for the I/O on the front panel,
    though this is a bit old fashioned and probably not the best practice. You could
    replace the two output connectors with a BNC connector as is used in the pH meter
    project, which is a little more pricey and eliminates the need for a ground, as
    the BNC connector has a center conductor and a shielded ground surrounding it.
    The banana jacks have only one conductor each.
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloads**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sketch** *SquareWave.ino*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Front panel template** *SquareWaveEnclosure.pdf*'
  prefs: []
  type: TYPE_NORMAL
- en: '**PCB foil pattern** *Generator.pcb*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Schematic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Square-Wave Generator circuit in [Figure 9-7](ch09.xhtml#ch09fig9-7) doesn’t
    call for a lot of different components. However, before you start building, note
    that the Arduino Pro Mini has a very different pin configuration than the Nano.
    It is also worth noting that there are many versions of the Pro Mini available,
    so check the pinout of the version you buy. The particular Arduino I suggest in
    the parts list has the pinout detailed in [Figure 9-4](ch09.xhtml#ch09fig9-4).
    Read “[Important Notes on the Pro Mini](ch09.xhtml#ch09lev1sec7)” on [page 263](ch09.xhtml#page_263)
    for a description of key differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the schematic, notice the switches: SW1, SW2, SW3, and SW4\. SW2 provides
    the divide-by-10 display. SW3 allows you to use the frequency counter with an
    external source instead of the signal generator. SW1 connects the 1, 10, 100 divider
    for the master clock (the switch has a center-off position that doesn’t have a
    connection) for the LTC1799 oscillator. SW4 is the power switch; its center is
    off, and the other two positions are for either external supply or battery.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: Schematic of the Square-Wave Generator*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Notes on the Pro Mini**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you build the breadboard, note that one major pinout difference among
    Pro Mini boards is the placement of pins A4, A5, A6, and A7\. Some versions locate
    all four analog inputs on the short side of the board, while the Deek-Robot used
    in this project splits them (see [Figure 9-8](ch09.xhtml#ch09fig9-8)). It places
    A4 and A5 near the other analog pins, but not in line with them, and A6 and A7
    are on the short side of the board. Pins A4 and A5 are used to drive the I²C bus
    for the display.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other minor differences between the Pro Mini and the Arduino
    Nano, but one of the most prominent is that the Pro Mini does not include a USB
    interface, so you have to program it using an external serial interface of some
    kind. There are several serial adapters on the market using FTDI technology. (*FTDI*
    is an abbreviation for *Future Technology Devices International*, a privately
    held Scottish semiconductor device company specializing in USB technology.)
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to using FTDI-based, purpose-built serial adapters is to use
    another microprocessor board to program the Pro Mini. I use an Arduino Uno clone
    to program my Pro Mini because it’s inexpensive, it allows me to remove the processor
    chip so I don’t end up programming both boards, and it’s easy to use. I use a
    simple breadboard setup to do the programming. Go to “[Uploading Sketches to Your
    Arduino](ch00.xhtml#ch00lev1sec3)” on [page 5](ch00.xhtml#page_5) for connection
    details.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: The Deek-Robot Pro Mini next to a centimeter ruler. The pinout
    is a little different from similar Arduino clones. For example, pin A4 is the
    unmarked pad between A2 and A3, while A5 is the one between A3 and VCC*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How the Square-Wave Generator Was Developed**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project was developed to solve a need that emerged when creating the Ballistic
    Chronograph in [Chapter 8](ch08.xhtml#ch08). While developing the chronograph,
    I needed some way to test it to assure it worked properly without using a weapon
    with live ammunition and shooting holes in my shop.
  prefs: []
  type: TYPE_NORMAL
- en: The Square-Wave Generator was my solution to the problem. With it and a small
    handful of other parts, I was able to simulate the signal the chronograph should
    receive as a projectile breaks a sequence of light beams. I decided to start with
    the time it took a projectile to travel an arbitrary distance of 3 inches, which
    turned out to be somewhere between 50 and 1,000 microseconds, depending on the
    speed of the projectile. I then used the Square-Wave Generator to generate a signal
    at frequencies between 20,000 Hz and 1,000 Hz, the reciprocals of those times.
    Once I figured out what I needed for the chronograph, the Square-Wave Generator
    project took on a life of its own, and the final version is what you see in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Deciding How to Generate Signals***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, I looked for an easy way to satisfy my timing requirements. There were
    several DDS (direct digital synthesis) products and boards that would have easily
    solved the problem, but all of the solutions I found were a little pricier than
    I was hoping, and many had other shortcomings. Abandoning the DDS, I looked at
    several alternatives, some bringing me back to my old Radio Amateur days. One
    solution was to use a crystal oscillator and divide a fundamental frequency to
    achieve frequencies near the ones I needed. This presented several problems, not
    the least of which being that the circuit would likely need several divider chips.
  prefs: []
  type: TYPE_NORMAL
- en: Another solution was to create my own variable frequency oscillator (VFO) from
    scratch. While a possibility, that solution entailed more design work than I was
    prepared to do at the time, so I went back to the data sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'I found that Linear Technology’s LTC1799 single-chip precision oscillator had
    just about what the doctor ordered—and more. According to the data sheet, this
    chip provides a square-wave signal from 1 KHz to 33 MHz with a single variable
    resistor and a switch to divide the fundamental oscillator frequency by 1, 10,
    or 100\. It boasts good stability, too: nominally, it has less than 1 percent
    error. And it was a lot less pricey than the DDS solutions at just under $4.00.'
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the problem was to see what frequency the generator was creating.
    Without an external frequency counter or a calibrated oscilloscope, it would be
    extremely difficult to get even a close approximation of the frequency generated.
    So the project mushroomed to include a built-in frequency counter. Because the
    counter was there anyway, I included a switch to allow me to use the frequency
    counter as a stand-alone instrument.
  prefs: []
  type: TYPE_NORMAL
- en: '***Planning How to Display the Frequency***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now I could generate square waves, but there were still some other problems
    to be addressed. For example, how would I read the frequency from the outside?
    I could mark the potentiometer positions with calibrations—as many generators
    of yore have done—but that is at best a clumsy and inaccurate approach in today’s
    digital age. A built-in frequency counter and bright display seemed most practical.
  prefs: []
  type: TYPE_NORMAL
- en: I went back to the drawing board—and to the Arduino Library. I found several
    approaches to Arduino frequency counters online, including at least two separate
    frequency counter libraries. The simplest and most convenient library for this
    application was *FreqCount.h*, developed by Paul Stoffregen. How I used this library
    is discussed more under “[The Sketch](ch01.xhtml#ch01lev1sec8)” on [page 271](ch09.xhtml#page_271).
    For more information on the library itself or to get the latest updates, you can
    go to *[https://github.com/PaulStoffregen/FreqCount/](https://github.com/PaulStoffregen/FreqCount/)*.
  prefs: []
  type: TYPE_NORMAL
- en: A preliminary breadboard prototype indicated that the frequency counter worked
    well. I put the breadboard together using a 20×4 LCD display using the I²C interconnect.
    After labeling the display with the word *Frequency* and displaying the frequency
    in Hz under that, I still had two lines of 20 characters left (see [Figure 9-9](ch09.xhtml#ch09fig9-9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: The display of the Square-Wave Generator, showing the frequency
    and the impulse time*'
  prefs: []
  type: TYPE_NORMAL
- en: Waste not, I always say. Because at least two of the projects I planned to use
    the Square-Wave Generator with required evenly spaced pulses (more or less a pulse
    generator), I decided to use the second two lines of the display to indicate the
    time of the impulse. Calculating the time in the sketch would be relatively easy,
    as the time (in seconds) is a function of the frequency (*T* = 1/*f*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Signal Integrity**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without getting involved with the higher math of signal composition, a square
    wave can be thought of as an infinite series of sine wave harmonics added together.
    As the frequency increases, so does the complexity and fragility of the waveform.
    If you connect your breadboard circuit to an oscilloscope, you can observe this
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: This project was initially developed as a square-wave generator/frequency counter
    that could operate in the area of 1,000 Hz to 1 MHz. This generator does its job
    with panache, but the fundamental oscillator chip has a range far in excess of
    that.
  prefs: []
  type: TYPE_NORMAL
- en: In developing the project, I had two options. The first was to intentionally
    limit the device’s performance to the area that was initially proposed or to extend
    it closer to the limits of the oscillator and suffer some degradation at the higher
    end. I selected the latter. While the square wave starts rounding off at around
    15 MHz or so, the performance at the lower—and intended—frequencies is not impacted
    whatsoever. [Figure 9-10](ch09.xhtml#ch09fig9-10) shows four oscilloscope traces
    at different frequencies to demonstrate.
  prefs: []
  type: TYPE_NORMAL
- en: At 1 kHz, the wave pattern is close to perfect, as you can see from the display
    on my older analog oscilloscope (see [Figure 9-10A](ch09.xhtml#ch09fig9-10)).
    In [Figure 9-10B](ch09.xhtml#ch09fig9-10), at 5 MHz, the edges of the square wave
    are compromised a very small amount, showing a slight overshoot on the rising
    edge. When the frequency is increased to 12 MHz, the signal begins to look a little
    ragged, with even more distortion (see [Figure 9-10C](ch09.xhtml#ch09fig9-10)).
    Some of the distortions of the wave are a result of tuning, or stray capacitive
    and inductive effects, by certain components used in the construction. This is
    an avoidable phenomenon, and I mention it primarily so you’re aware of the shape
    of the waveform. I suspect that most of your applications for the generator will
    be in the lower-frequency area, at less than 1 MHz, where the wave pattern produced
    is as good as it gets. Further, I have used the generator in higher frequencies,
    and the slightly distorted waveform had virtually no effect on the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: Four oscilloscope traces showing the output of the Square-Wave
    Generator at 1 kHz (A), 5 MHz (B), 12 MHz (C), and 20 MHz (D). It quickly becomes
    apparent that the square-wave signal starts to lose integrity at around 12 MHz*.'
  prefs: []
  type: TYPE_NORMAL
- en: While the waves continue to distort at frequencies above 20 MHz (see [Figure
    9-10D](ch09.xhtml#ch09fig9-10)), they are fully recognizable as square waves and
    remain useful. At 30 MHz—the extent of the range of the Square-Wave Generator
    as built—the signal trace looks increasingly like a sine wave, but for most test
    purposes, it is still totally valid.
  prefs: []
  type: TYPE_NORMAL
- en: '**LISTENING TO SQUARE WAVES**'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting experiment that will provide you with some idea of the harmonics
    present in a square wave is to set the Square-Wave Generator to the audible range
    of the frequency spectrum and plug its output into the input of an amplifier and
    loudspeaker. Listen to the quality of the sound. The “fuzz” you hear is a result
    of rich harmonics produced by the square wave, which essentially comprises a composite
    of all other sine waves within the frequency limit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fine-tuning with a Decade Counter**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In designing the system, there were a couple final additions I settled on to
    add utility and improve performance. The frequency counter, as put together, had
    a frequency range of about 100 Hz to around 10 MHz tops. The LTC1799 oscillator
    offered a frequency range from 1 kHz to about 30 MHz, and for most applications,
    that would be far more than adequate. But there were some applications I had in
    mind that would need an AC source down to about 100 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there turned out to be a way to kill both birds, so to speak, with one
    chip: a divide-by-10 counter—in this case, an HCT4017 or CD4017 decade counter
    and a couple of switches.'
  prefs: []
  type: TYPE_NORMAL
- en: The decade counter accepts an AC signal, counts to 10, and then starts over.
    By looking at one of the counter outputs, it essentially divides by 10.
  prefs: []
  type: TYPE_NORMAL
- en: It was possible to feed the output of the oscillator through the divide-by-10
    counter and show output frequency on the LCD, while the actual output frequency
    would be 10 times the frequency shown. This workaround lets the Square-Wave Generator
    show frequencies well above 10 MHz on the LCD as long as you can mentally move
    the decimal point over one place. On the flip side, the switch (SW2) could be
    moved to take the output of the oscillator divided by 10 directly so that it could
    output a minimum output frequency as low as 100 Hz, or 1 kHz/10.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Oscillator in Detail**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The oscillator part of this project is pretty much self-contained in the LTC1799
    and requires only an external variable resistor, a bypass capacitor, and a switch
    used to divide the fundamental oscillator frequency by 1, 10, or 100 times. The
    value that the frequency is divided by depends on what you’re connecting to pin
    4\. When you connect pin 4, or the DIV pin, of the LTC1799 to GND, the frequency
    is divided by 1; when pin 4 is left floating or open, the frequency is divided
    by 10; and when pin 4 is connected to 5V, the frequency is divided by 100\. This
    allows the unit to cover a range of frequencies from 1 kHz to 30 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: Also, while I have chosen to use a 250-kilohm potentiometer between pins 1 and
    3 of the LTC1799, any potentiometer between 3 kilohms and 1 megaohm is acceptable.
    The frequency decreases as this resistor value increases, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: According to the manufacturer, the LTC1799 outputs a fairly crisp square wave
    throughout its frequency range. As frequencies increase, however, there are a
    variety of considerations that impact the integrity of the wave. These include
    stray capacitances and inductances due to the layout of the circuit, such as the
    output position, the hookup of the variable potentiometer, the switch, and other
    components. Because most applications I had in mind were in the lower end of the
    frequency spectrum offered by the LTC1799, I did not pay strict attention to the
    layout and thus probably have somewhat compromised integrity at the higher frequencies.
    See [Figure 9-10](ch09.xhtml#ch09fig9-10) for actual signal traces.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Breadboard**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in virtually all of my Arduino projects, somewhere during the design process,
    I end up making a breadboard layout. [Figure 9-11](ch09.xhtml#ch09fig9-11) shows
    the prototype for the Square-Wave Generator.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: The breadboard for the Square-Wave Generator*'
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the breadboards for testing posed no difficulty, with the exception that
    the oscillator became a little squirrely at the higher frequencies when using
    longer interconnect leads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect all of the red positive rails together and blue negative rails together.
    Be careful not to connect the red and blue rails under any circumstances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the LTC1799 oscillator module as close as possible to one end of the
    breadboard. See the far left-hand side of [Figure 9-11](ch09.xhtml#ch09fig9-11).
    The oscillator has to be mounted on an adapter board so it will fit in the 0.100
    centers of the breadboard, as shown in [Figure 9-12](ch09.xhtml#ch09fig9-12).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the Arduino Pro Mini into the breadboard. Connect the 5V terminal of
    the Pro Mini to the red positive rails of the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND of the Pro Mini to the blue negative rails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the HCT4017 decade counter into the breadboard. (It’s immediately to
    the left of the LCD in [Figure 9-11](ch09.xhtml#ch09fig9-11).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the LTC1799 on its adapter board into the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one end of the three-position (center-off) switch SW1 to ground. Connect
    the other end to VCC, and connect the center pin of the switch to pin 4 of the
    LTC1799.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one end of switch SW2 to pin 6 of the LTC1799 adapter board (or pin
    5 of the LTC1799).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one end of the potentiometer R1 to pin 3 of the LTC1799\. Connect pin
    1 of the LTC1799 to the red positive rail along with the other side of the potentiometer
    and the wiper, or the center pin of the potentiometer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin 6 of the LTC1799 will be the output of the oscillator, which will go to
    pin 14 of the HCT4017 and to one leg of switch SW2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capacitor C1 should have been installed on the adapter board as described.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pins 13 and 15 of the HCT4017 to ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other end of switch SW2 to pin 12 of the HCT4017 (CD4017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/fig9_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 9-12: The SOIC has been soldered to an adaptor board, which will fit
    into the 0.100-inch centers of the breadboard. The chip includes only 5 pins,
    but I used a 6-pin adapter*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect the center of switch SW2 to an empty row on the breadboard. (I used
    one between the Pro Mini and the HCT4017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one end of switch SW3 to the same empty row you used in step 8, which
    should be connected to the center of switch SW2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the center of switch SW3 to digital pin 5 (D5) on the Pro Mini.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pin 3 of switch SW3 will serve as the input if you use the breadboard in the
    frequency-counter-only mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*SW4, the AC/battery on/off switch, does not need to be configured in the breadboard,
    as the circuit can receive power from the computer while programming the Arduino.
    The LM7805 is not used in the breadboard configuration for the same reason*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check your LCD. If it includes the I²C subassembly board soldered to it, you’re
    okay to continue. Otherwise, solder the I²C board to the display as described
    in “[Affixing the I²C Board to the LCD](ch00.xhtml#ch00lev1sec2)” on [page 3](ch00.xhtml#page_3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your LCD is ready, you will need four male-to-female connector wires to
    hook it up. (In the finished version, you can make a small wire harness for it,
    including wires for VCC, GND, SCL, and SDA.) I usually color code these with red
    and black for positive and ground, green for SCL, and yellow for SDA. Plug the
    VCC wire into the red positive rail, the negative into the blue negative rail,
    SDA to A4 on the Pro Mini, and SCL to A5 on the Pro Mini.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, build your programming circuit or plug in your FTDI adapter, load the
    sketch onto the Pro Mini, and you’re all set to go.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sketch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Square-Wave Generator sketch simplified somewhat as I iterated on the project.
    The result is a mercifully compact program, thanks to the integration of the LTC1799
    and the *FreqCount.h* library (available from the Library Manager section of the
    Arduino IDE).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The sketch starts by including three libraries: *FreqCount.h* for the frequency
    counter and two others for working with the LCD. To add *FreqCount.h* to your
    Arduino IDE, go to **Sketch ▸ Include Library ▸ Manage Libraries…** and install
    the FreqCount library from the Library Manager. The `setup()` section prepares
    the LCD and starts the frequency counter. The `loop()` section fetches the frequency,
    calculates the impulse width, and displays both.'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino doesn’t actually have anything to do with generating the signal—that’s
    all done at the oscillator and subsequently in the divider. The Arduino’s function
    is to look at the signal and read out the frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although pin 5 on the Arduino is connected to the LTC1799 oscillator, I do
    not set it as an analog input in this sketch. That is apparently taken care of
    in the FreqCount library. See “Frequency Input Pin” at* [https://www.pjrc.com/teensy/td_libs_FreqCount.html](https://www.pjrc.com/teensy/td_libs_FreqCount.html)
    *for various Arduino models. Incidentally, using this library renders analog pins
    3, 9, 10, and 11 unusable as analog outputs (PWM)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Shield**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, I developed a small PCB shield to hold the various components.
    Although the shield could probably have been designed to use only a single layer,
    I elected to use a two-layer board. First, it greatly reduced layout time, and
    second, because I was producing another two-layer board at the same time, I could
    expose and etch them both at once with little additional effort. (It’s more efficient
    to etch multiple boards simultaneously, when you can.) [Figure 9-13](ch09.xhtml#ch09fig9-13)
    shows the top and bottom foil patterns of the shield.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-13: Top (left) and bottom (right) foil pattern for the Square-Wave
    Generator’s PCB shield*'
  prefs: []
  type: TYPE_NORMAL
- en: Assembling the components on the shield requires special attention to the bypass
    capacitor. The shorter the leads of the 0.1 μF capacitor from pin 1 of the LTC1799
    oscillator to ground, the better the oscillator works. I actually soldered the
    capacitor directly to the chip-mounting board.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-13](ch09.xhtml#ch09fig9-13) shows the component placement on the
    shield. Notice that the HCT4017 (CD 4017)is located beneath the Pro Mini; the
    PCB was designed this way to conserve space and hold high-frequency traces to
    a minimum length.'
  prefs: []
  type: TYPE_NORMAL
- en: As in other projects, it’s necessary to populate the headers for the Pro Mini
    only where they actually connect to the board, in addition to a header at pin
    1 to simplify aligning the Pro Mini on the shield. The LM7805 voltage regulator
    requires no heat sink.
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building the Square-Wave Generator was relatively straightforward, but note
    that I did not take particular care with wiring the leads for switch SW1, which
    provided the divider for the oscillator, or with the placing and wiring of the
    potentiometer. Shortening these wires—and perhaps adjusting the placement of the
    parts themselves—probably would have improved the integrity of the waveform somewhat
    at higher frequencies. [Figure 9-14](ch09.xhtml#ch09fig9-14) shows the inside
    of my Square-Wave Generator; if you look carefully, you can see my hand-scribbled
    notations as to where things are located.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-14: Everything fit easily in the slope-panel enclosure. The LCD was
    held in place with four screws, and the shield was mounted on top of the LCD with
    double-sided foam adhesive. The switches, I/O jacks, and potentiometer were soldered
    by hand*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Preparing the Enclosure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, mark the front of the enclosure for the following holes:'
  prefs: []
  type: TYPE_NORMAL
- en: • Two to aid in cutting out the space for the LCD
  prefs: []
  type: TYPE_NORMAL
- en: • Four for mounting holes for the LCD
  prefs: []
  type: TYPE_NORMAL
- en: • Four for the banana jacks
  prefs: []
  type: TYPE_NORMAL
- en: • Four for the switches
  prefs: []
  type: TYPE_NORMAL
- en: • One for the potentiometer
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the Hammond 1595C sloped-front enclosure I recommend in “[Parts
    List](ch01.xhtml#ch01lev1sec2)” on [page 260](ch09.xhtml#page_260) or an equivalent,
    you can follow the template in [Figure 9-15](ch09.xhtml#ch09fig9-15). Just locate
    the PDF of the drawing in this book’s resource files, print it out, lay it over
    the front of the enclosure, and carefully center punch for the holes. I also use
    a fine-tip Sharpie marker to indicate locations and to draw on the enclosure.
    Excess marker can be easily cleaned with isopropyl alcohol.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-16](ch09.xhtml#ch09fig9-16) shows how to use the radius of the enclosure
    to determine the measurement for the display.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-15: The drilling template for the Square-Wave Generator*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-16: The LCD is placed using the radius of the enclosure*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I drilled the holes in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Carefully drill 1/2-inch holes at the corners of the cutout for the LCD. If
    you mark the centers of the holes correctly, the edge of the display will be tangential
    to the outer diameter of the hole. You can then draw lines connecting the edges
    of the holes to use as a guide to cut out the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cut out the display using a keyhole saw or saber saw. The enclosure is made
    of a relatively soft ABS plastic, so you should have no difficulty making the
    cut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean debris from the cutout with a file if necessary, and check that the display
    fits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill the four mounting holes (labeled A in [Figure 9-15](ch09.xhtml#ch09fig9-15))
    for the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill four 5/16-inch holes for the banana jacks (labeled B).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill four 1/4-inch holes for the switches (labeled C). It’s a good idea to
    identify the switch locations with a permanent marker on the inside of the enclosure
    to simplify wiring them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drill a 9/32-inch hole for the potentiometer (labeled D).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate a position you like for the 3.5 mm power jack that is 3/4 inches from
    the edge of the enclosure and 1/2 inches from the bottom. Drill a 1/4-inch hole
    for a 3.5 mm jack there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the LCD with four 4-40 screws. Some LCDs have a protrusion on one side
    for the backlight. If yours does, you will have to raise the LCD off the surface
    of the enclosure to accommodate the backlight section on the right-hand edge (when
    looking at the LCD with the connections at the top). I simply put 4-40 nuts on
    the back of the screws to leave space. If a single nut is not enough (4-40 nuts
    can have different thicknesses), include a washer. Then, fasten the display to
    the enclosure. If your display does not include the protrusion, then just fasten
    the display to the case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the banana plug jacks and switches in the enclosure. It is sometimes easier
    to solder wires onto the switches and jacks to minimize damage to the enclosure
    from accidental contact with the soldering iron.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Wiring the Electronics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before mounting the PCB shield in the enclosure, solder the components to it,
    and solder all the wires for the LCD, the potentiometer, the switches, the power
    jack, and the banana jacks. You may find it helpful to solder the wires to the
    switches and jacks first. When in doubt, leave some extra length on the wires,
    but abide by the axiom, “If it’s too short, you can always splice it; if it’s
    too long, you won’t know what to do with it.” I suggest using male and female
    headers for the LCD to make hookup easier.
  prefs: []
  type: TYPE_NORMAL
- en: I mounted the shield directly to the rear of the LCD using double-sided foam
    tape. This, however, could have contributed to the distortion of the waveform
    at higher frequencies. You might prefer to mount the module as far from the display
    as possible. The front of the enclosure needs no special treatment other than
    the placement of the labels at your discretion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design Notes and Mods**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I toyed with several iterations of the Square-Wave Generator before arriving
    at the version described in this chapter. Along the way, I tweaked some aspects
    and considered other changes. While the ideas in this section didn’t make it into
    this project, you may enjoy trying them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Displaying Frequency in Other Units***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The sketch displays the square-wave frequency in Hz, as most of the applications
    I have planned are in the area of 100 Hz to 10 kHz. But if you find yourself using
    the device a lot in higher frequencies, looking at six or seven integers can be
    confusing. Never fear: it’s easily possible to change the sketch to show the frequency
    in kHz or even MHz by simply truncating the display.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To truncate the display, simply add a comma and the number of digits you want
    it to show. For example, to change from Hz to kHz, change these lines in the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(freq);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(10, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("Hz");
  prefs: []
  type: TYPE_NORMAL
- en: 'to these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(freq/1000);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.setCursor(10, 1);
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print("kHz");
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to reduce the number of digits appearing in the readout, change
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(freq/1000);
  prefs: []
  type: TYPE_NORMAL
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: lcd.print(freq/1000,3);
  prefs: []
  type: TYPE_NORMAL
- en: You can change `3` to the number of digits you want.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading External Input Frequencies***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The schematic and the finished project include a switch to change from generating
    pulses to reading the frequency of an external input. The switch (SW3) brings
    the input jack directly to the input (pin 5) of the Arduino, where the oscillator
    would normally connect. I have used this very successfully for a variety of applications,
    particularly when I wanted a quick frequency reading somewhere outside my shop.
  prefs: []
  type: TYPE_NORMAL
- en: There is no circuitry to protect the processor, so just be careful. The unit
    is meant to use inputs that are standard TTL levels—0 to 5V. The Arduino is relatively
    sensitive and can detect signals at somewhat lower levels. If you plan, however,
    to use it with very low-level inputs—that is, less than 0.5V—then you should build
    some kind of prescaler or preamp circuit.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to use the Square-Wave Generator as an independent frequency counter,
    you might want to consider using a preamp to provide the amplification and prevent
    damage to the processor. A simple one appears in [Figure 9-17](ch09.xhtml#ch09fig9-17),
    using one-sixth of a 74HC14 Hex Schmitt-trigger inverter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-17: Optional preamp/buffer for input to frequency counter*'
  prefs: []
  type: TYPE_NORMAL
- en: Using a preamp will help protect the input of the Arduino because the output
    of the preamp will be limited to the supply voltage.
  prefs: []
  type: TYPE_NORMAL
- en: '***Battery Power***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While this project was initially designed for use with an external power supply,
    it can be easily converted to battery power. The total current drain with the
    LCD backlight lit is just under 100 mA. The capacity of a zinc manganese battery
    is approximately 500 mA hours. Thus, you can expect a life of about 5 hours. Alkaline
    batteries will tend to do better.
  prefs: []
  type: TYPE_NORMAL
- en: To accommodate the battery power, I simply replaced the power switch with one
    that had a center-off position. I wired one outer terminal to the AC-based power
    jack, the other outer terminal to the positive terminal of the battery, and the
    center terminal to the positive rail on the PCB shield. The negative terminal
    of the battery goes to ground. That configuration is shown in the current schematic.
    If you use the enclosure I suggest, a battery should fit conveniently. You can
    use double-sided adhesive to attach a battery holder.
  prefs: []
  type: TYPE_NORMAL
