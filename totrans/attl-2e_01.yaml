- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AN END USER’S PERSPECTIVE ON THE GNU AUTOTOOLS
  prefs: []
  type: TYPE_NORMAL
- en: '*I am not afraid of storms, for I am learning how to sail my ship.*'
  prefs: []
  type: TYPE_NORMAL
- en: —*Louisa May Alcott*, Little Women
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’re not a software developer, either by trade or by hobby, you may still
    have a need or desire at some point to build open source software to be installed
    on your computer. Perhaps you’re a graphic artist who wishes to use the latest
    version of GIMP, or maybe you’re a video enthusiast and you need to build a late
    version of FFmpeg. This chapter, therefore, may be the only one you read in this
    book. I hope that is not the case, because even a power user can gain so much
    more by striving to understand what goes on under the covers. Nevertheless, this
    chapter is designed for you. Here, I’ll discuss what to do with that so-called
    *tarball* you downloaded from that project website. I’ll use the Autoconf package
    to illustrate, and I’ll try to provide enough context so that you can follow the
    same process for any package you download^([1](footnote.xhtml#ch01fn1)) from a
    project website.
  prefs: []
  type: TYPE_NORMAL
- en: If you are a software developer, there’s a good chance the material in this
    chapter is too basic for you; therefore, I’d recommend skipping right to the next
    chapter, where we’ll jump into a more developer-centric discussion of the Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: Software Source Archives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open source software is distributed as single-file source archives containing
    the source and build files necessary to build the software on your system. Linux
    distributions remove much of the pain for end users by prebuilding these source
    archives and packaging the built binaries into installation packages ending in
    extensions like *.rpm* (for Red Hat–based systems) and *.deb* (for Debian/Ubuntu-based
    systems). Installing software using your system package manager is relatively
    easy, but sometimes you need the latest feature set of some software and it hasn’t
    yet been packaged for your particular flavor of Linux. When this happens, you
    need to download the source archive from the project website’s download page and
    then build and install it yourself. Let’s begin by downloading version 2.69 of
    the Autoconf package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Source archive names generally follow a de facto standard format supported
    by the Autotools. Unless the project maintainer has gone out of their way to modify
    this format, the Autotools will automatically generate a source archive file named
    according to the following template: *pkgname*-*version*.*format*. Here, *pkgname*
    is the short name of the software, *version* is the version of the software, and
    *format* represents the archive format, or file extensions. The *format* portion
    may contain more than one period, depending on the way the archive was built.
    For instance, *.tar.gz* represents two encodings in the format—a `tar` archive
    that has been compressed with the `gzip` utility, as is the case with the Autoconf
    source archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unpacking a Source Archive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, source archives contain a single root directory as the top-level
    entry. You should feel safe unpacking a source archive to find only a single new
    directory in the current directory, named the same as the archive file minus the
    *format* portion. Source archives packaged using Autotools-based build systems
    never unpack the contents of the original top-level directory into the current
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, occasionally, you’ll download an archive and unpack it to find
    dozens of new files in the current directory. It’s therefore prudent to unpack
    a source archive of unknown origin into a new, empty subdirectory. You can always
    move it up a level if you need to. Additionally, you can see what will happen
    by using the `tar` utility’s `t` option (instead of `x`), which lists the contents
    of the archive without unpacking it. The `unzip` utility supports the `-l` option
    to the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source archives can take many shapes, each ending in a unique file extension:
    *.zip*, *.tar*, *.tar.gz* (or *.tgz*), *.tar.bz2*, *.tar.xz*, *tar.Z*, and so
    on. The files contained in these source archives are the source code and build
    files used to build the software. The most common of these formats are *.zip*,
    *.tar.gz* (or *.tgz*), and *.tar.bz2*. Newer formats that are gaining in popularity
    include *.xz* (for which the latest Autotools even have native support) and *.zstd*.'
  prefs: []
  type: TYPE_NORMAL
- en: ZIP files use compression techniques developed decades ago by Phil Katz on Microsoft
    DOS systems. ZIP was a proprietary multifile compressed archive format that was
    eventually released into the public domain. Since then, versions have been written
    for Microsoft Windows and Linux as well as other Unix-like operating systems.
    In later versions of Windows, a user can unpack a *.zip* file merely by right-clicking
    it in Windows Explorer and selecting an **Extract** menu option. The same is true
    of the Nautilus (Nemo on Mint’s Cinnamon desktop) file browser on Linux Gnome
    desktops.
  prefs: []
  type: TYPE_NORMAL
- en: 'ZIP files can be unpacked at the Linux command line using the more or less
    ubiquitous `unzip` program,^([2](footnote.xhtml#ch01fn2)) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: ZIP files are most often intended by project maintainers to be used on Microsoft
    Windows systems. A much more common format used on Linux platforms is the compressed
    *.tar* file. The name *tar* comes from *tape archive*. The `tar` utility was originally
    designed to stream the contents of online storage media, such as hard disk drives,
    to more archival storage formats, such as magnetic tape. Because it’s not a random-access
    format, magnetic tape doesn’t have a hierarchical filesystem. Rather, data is
    written to tape in one long string of bits, with these archive files appended
    end to end. To find a particular file on tape, you have to read from the beginning
    of the tape through to the file you’re interested in. Hence, it’s better to store
    fewer files on tape to reduce search time.
  prefs: []
  type: TYPE_NORMAL
- en: The `tar` utility was designed to convert a set of files in a hierarchical filesystem
    into just such a long string of bits—an archive. The `tar` utility was specifically
    *not* designed to compress this data in a manner that would reduce the amount
    of space it takes up, as there are other utilities to do that sort of thing—remember,
    a founding principle of Unix is that of a single responsibility per tool. In fact,
    a *.tar* file is usually slightly larger than the sum of the sizes of the files
    it contains because of the overhead of storing the hierarchy, names, and attributes
    of the archived files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally, you’ll find a source archive that ends only in a *.tar* extension.
    This implies that the file is an uncompressed *.tar* archive. More often, however,
    you’ll see extensions such as *.tar.gz*, *.tgz*, and *.tar.bz2*. These are compressed
    *.tar* archives. An archive is created from the contents of a directory tree using
    the `tar` utility, and then the archive is compressed using the `gzip` or `bzip2`
    utility. A file with an extension of *.tar.gz* or *.tgz* is a *.tar* archive that
    has been compressed with the `gzip` utility. Technically, you can extract the
    contents of a *.tar.gz* file by using a pipeline of commands to first uncompress
    the *.gz* file with `gunzip` and then unpack the remaining *.tar* file with `tar`,
    in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `tar` utility has evolved since it was used for creating tape
    data streams. Nowadays, it’s used as a general-purpose archive file management
    tool. It understands, based on file extensions and sometimes the initial bytes
    of an archive, how to execute the correct tools to uncompress a compressed *.tar*
    archive before unpacking the files. For example, the following command recognizes
    *autoconf-2.69.tar.gz* as a *.tar* archive that was subsequently compressed with
    the *gzip* utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command first executes the `gunzip` program (or the `gzip` program with
    the `-d` option) to uncompress the archive, and then it uses internal algorithms
    to convert the archive into its original multifile directory structure, complete
    with original timestamps and file attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve unpacked the source archive, the next step usually involves examining
    the contents of the unpacked directory tree in an effort to determine how the
    software should be built and installed. A few patterns have become pervasive in
    the open source world, and GNU and the Autotools try to promote the use of these
    patterns as the default behavior of an Autotools-based project.
  prefs: []
  type: TYPE_NORMAL
- en: First, look for a file named *INSTALL* in the root directory of the unpacked
    archive. This file usually contains step-by-step instructions for how to build
    and install the software, or it tells you how to find those instructions—perhaps
    via a URL reference to a project web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *INSTALL* file for GNU packages such as Autoconf is pretty verbose. The
    GNU project tends to try to set an example for the rest of the open source world.
    Nevertheless, it does carefully outline the steps required to build the Autoconf
    package. I’d recommend reading a GNU project *INSTALL* file completely at least
    once, because it contains details about how most GNU projects are built and installed.
    In fact, the one bundled with the Autoconf package is actually a generic one that
    GNU bundles with many of its packages—which in itself is a testament to the consistency
    of Autotools-generated build systems. Let’s dive in and see what it tells us about
    building Autoconf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The instructions indicate that you should use the `cd` command to change to
    the directory containing the project’s source code and then type `./configure`
    to configure the package for your system. However, it should be clear that if
    you’re reading the *INSTALL* file, you’re probably already in the directory containing
    `configure`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `configure` can take a while if the package is large and complex. For
    the Autoconf package, it takes only a couple of seconds and spews a single page
    of text to the screen in the process. Let’s take a closer look at what gets displayed
    during a successful Autoconf configuration process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are basically two parts to `configure`’s output. The first part contains
    lines that start with `checking` (though there are a few in the middle that start
    with `configure:`). These lines indicate the status of the features that `configure`
    was programmed to look for. If a feature is not found, the trailing text will
    be `no`. On the other hand, if the feature is found, the trailing text will sometimes
    be `yes` but will often be the filesystem location of the tool or feature that
    was discovered.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not uncommon for `configure` to fail due to missing tools or utilities,
    especially if this is a newly installed system or if you haven’t downloaded and
    built a lot of software on this system. A new user will often start posting questions
    to online forums at this point—or just give up.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to understand the contents of this section because it can help
    you figure out how to solve problems. Addressing a failure is often as simple
    as installing a compiler using your system’s package manager. For the Autoconf
    package, not much is required that isn’t installed by default on most Linux systems.
    There are a few exceptions, however. For example, here’s the output of `configure`
    on a system that doesn’t have M4 installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you’ll notice the last few lines show an error. The Autoconf package
    is a GNU software tool, and, true to form, it provides a lot of information to
    help you figure out what’s wrong. You need to install an M4 macro processor, and
    we’ll do that with our package manager. My system is a Linux Mint system, based
    on Ubuntu, so I’ll use the `apt` utility. If you’re using a Red Hat–based system,
    you may use `yum` to accomplish the same thing or just use the graphical user
    interface (GUI) for your system package manager from the GUI desktop. The key
    here is that we’re installing the m4 package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `configure` can complete successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second section is a set of lines beginning with `config.status:`. This
    section starts with the line `configure: creating ./config.status`, at ➊. The
    last thing `configure` does is create another script called *config.status* and
    then execute this script. The lines that start with `config.status:` are actually
    displayed by *config.status*. The primary task of *config.status* is to generate
    the build system based on the findings of `configure`. The lines output by this
    script merely tell you the names of the files being generated.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also run `configure` from a different directory, if you wish, by using
    a relative path to the `configure` command. This is useful if, for example, the
    project source code comes to you on a CD or via a read-only NFS mount. You could,
    at this point, create a build directory in your home directory and, using a relative
    or absolute path, execute `configure` from the read-only source directory. The
    `configure` script will create the entire build tree for the project in the current
    directory, including makefiles and any other files needed to build the project
    with `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `configure` has completed, it’s possible to run `make`. Before this point,
    there are no files in the directory tree named *Makefile*. Running `make` after
    `configure` yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The primary task of `configure` is to ensure that `make` will succeed, so it’s
    not likely that `make` will fail. If it does, the problem will probably be very
    specific to your system, so I can’t provide any guidelines here except to suggest
    a careful reading of the `make` output in order to determine what caused the failure.
    If you can’t discover the problem by reading the output, you can check the Autoconf
    mailing list archives, ask on the mailing list directly, and finally post a bug
    report to the Autoconf project website.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we’ve built the software using `make`, it would be nice to exercise any
    tests the project maintainers might have added to the build system to provide
    some level of assurance that the software will run correctly on our system.
  prefs: []
  type: TYPE_NORMAL
- en: When we built the software, we ran `make` without any command line arguments.
    This caused `make` to assume we wanted to build the *default target*, which by
    convention is the `all` target. Therefore, running `make all` is the same as running
    `make` without any arguments. However, Autotools build systems have many targets
    that can be directly specified on the `make` command line. The one we’re interested
    in at this point is the `check` target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `make check` within the source directory will build and execute any
    test programs that were included by the project maintainers (this takes several
    minutes to complete for Autoconf):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Your output may differ slightly in minor ways from mine. Different Linux distributions
    and tool versions display differently, so don’t be too concerned about minor differences.
    The number of tests skipped or failed may also differ from system to system due
    to differences in the tools installed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the Autoconf package provides 503 tests; 460 of those were
    run and 43 were purposely skipped. Of the 460 tests that were executed, six failed,
    but four of those were expected failures, so we have only two problems: test 501
    and test 503.'
  prefs: []
  type: TYPE_NORMAL
- en: With only two failures out of 460, I’d personally call this a whopping success,
    but if you would like to dig a little deeper to see what’s causing these problems,
    there are two approaches you can take. The first is to go to the Autoconf mailing
    list archives and either search for a similar question with answers or ask the
    list directly; notice the request in the preceding output to send the *tests/testsuite.log*
    file to *[bug-autoconf@gnu.org](mailto:bug-autoconf@gnu.org)*.
  prefs: []
  type: TYPE_NORMAL
- en: The other option requires a bit more programming skill. These tests are run
    by Autoconf’s *autotest* framework, which automatically creates a directory for
    each failed test under *tests/testsuite.dir*. Each directory found under *testsuite.dir*
    is named after the number of the failed test. If you look there, you’ll see six
    directories, including directories for the four expected failures. Each of these
    numbered directories contains a `run` script that will re-execute the failed test,
    displaying output to `stdout` rather than to a log file. This allows you to experiment
    with your system (perhaps by installing a different version of Libtool for test
    501, for example) and then try running the test again.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the possibility, however slight, that the project maintainers
    are aware of these test failures. In this case, they would likely respond to your
    email with a comment to this effect (or a quick search of the archives may also
    turn up the same answer), at which point you can simply ignore the failed tests.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Built Software
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running `make` usually leaves built software products—executables, libraries,
    and data files—scattered throughout the build directory tree. Take heart, you’re
    almost there. The final step is installing the built software onto your system
    so you can use it. Thankfully, most build systems, including those managed by
    the Autotools, provide a mechanism for installing built software.
  prefs: []
  type: TYPE_NORMAL
- en: A complex build system is only useful to non-experts if it assumes a lot of
    basic defaults; otherwise, the poor user would be required to specify dozens of
    command line options for even the simplest build. The location of software installation
    is one such assumption; by default, the build system assumes you want to install
    built software into the */usr/local* directory tree.
  prefs: []
  type: TYPE_NORMAL
- en: The */usr/local* directory tree mirrors the */usr* directory tree; it’s the
    standard location for software that is built locally. The */usr* directory tree,
    on the other hand, is where Linux distribution packages get installed. For instance,
    if you installed the Autoconf package using the command `sudo apt-get install
    autoconf` (or `sudo yum install autoconf`), the package binaries would be installed
    into the */usr/bin* directory. When you install your hand-built Autoconf binaries,
    they’ll go into */usr/local/bin*, by default.
  prefs: []
  type: TYPE_NORMAL
- en: It’s most often the case that */usr/local/bin* is positioned in your `PATH`
    environment variable before */usr/bin*. This allows your locally built and installed
    programs to override the ones installed by your distribution’s package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to override this default behavior and install your software into
    a different location, you can use the `--prefix` option on `configure`’s command
    line,^([3](footnote.xhtml#ch01fn3)) as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will cause `configure` to generate the build scripts such that executable
    binaries will be installed into your `$HOME`*/bin* directory.^([4](footnote.xhtml#ch01fn4))
    If you don’t have root access on your system, this is a good compromise that will
    allow you to install built software without asking your system administrator for
    extra rights.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for choosing a different `--prefix` location is to allow yourself
    to install the software into an isolated location. You can then examine the location
    after installation to see exactly what got installed and where it went, relative
    to `--prefix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first install into a private installation location so we can see what
    the Autoconf project installs onto our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg010-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As with the earlier build process, the number of files and directories on
    your system may differ slightly from mine, based on the difference in tool availability
    between our systems. If you have additional documentation tools installed, for
    example, you may see more directories than I do, as Autoconf will build more documentation
    if the tools are available.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that I specified the installation location on `configure`’s command line
    using a full path—the `PWD` environment variable contains the absolute path of
    the current directory in the shell. It’s important to always use a full path in
    `--prefix`. In many cases, using a relative path will cause installation failures
    because the `--prefix` argument is referenced from different directories during
    the installation process.^([5](footnote.xhtml#ch01fn5))
  prefs: []
  type: TYPE_NORMAL
- en: I used the `tree` command on the *private-install* directory in order to get
    a visual picture of what Autoconf installs.^([6](footnote.xhtml#ch01fn6)) There
    were 61 files installed into 11 directories within *private-install*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s install Autoconf into the default location in */usr/local/bin*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to note the use of `sudo` on this command line to run `make install`
    with root privileges. When you install software outside of your home directory,
    you’ll need higher privileges. If you set the `--prefix` directory to somewhere
    within your home directory, then you can omit the use of `sudo` in the command.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you should understand what a source archive is and how to download,
    unpack, build, test, and install it. I hope I’ve also given you the impetus to
    dig further and discover more about open source build systems. Those generated
    by the Autotools follow common patterns so pedantically that they’re reasonably
    predictable. For hints on the sorts of things you can do, try running `./configure
    --help`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other build systems out there. Most of them follow a reasonable set
    of patterns, but once in a while you’ll run into one that’s significantly different
    from all the rest. All open source build systems tend to follow some very fundamental,
    high-level concepts—the idea of a configuration process, followed by a build step,
    is one such principle. However, the nature of the configuration process as well
    as the command used to build the software might not align very closely with what
    we’ve discussed here. One of the benefits of the Autotools is the consistent nature
    of the build systems they generate.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand how all this magic works, keep reading.
  prefs: []
  type: TYPE_NORMAL
