<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="app02"><span epub:type="pagebreak" id="page_281"/><strong>B  More Debugger Attacks</strong></h2>&#13;
<h3 class="h3" id="app02_1"><strong>B.1 STM32 Clones</strong></h3>&#13;
<p class="noindent">The GD32F103 clone of the STM32F103 inherits its ancestor’s security model, in which RDP Level 1 allows for a JTAG connection but disconnects flash memory. Obermaier, Schink, and Moczek (2020) describes a clever exploit for this.</p>&#13;
<p class="indent">The authors noticed that flash memory restrictions apply when the <code>C_DEBUGEN</code> bit of the <code>DHSR</code> register is set, which occurs when the CPU debug module is enabled to halt the CPU or access the processor’s registers. The restrictions do not apply when system components such as the peripherals are accessed through JTAG. The challenge is to trigger code execution without touching the CPU registers, only the peripherals.</p>&#13;
<p class="indent">One of their exploits works like this: first a JTAG debugger takes control of the CPU to write shellcode into a region of SRAM that is not initialized by the firmware. The target is reset, which restores access to flash memory but disconnects the debugger. After reconnecting, JTAG is used to adjust the vector table offset register (VTOR) to point to shellcode in SRAM, carefully avoiding any operations that debug the CPU and enable restrictions. Because of the new VTOR value, the next interrupt that fires triggers a handler in the SRAM shellcode, that dumps all flash memory.</p>&#13;
<p class="indent">The same paper describes using JTAG to debug other peripherals of GD32F103 and CKS32F103 chips while still carefully <span epub:type="pagebreak" id="page_282"/>avoiding any debug operations against the CPU. In this case, the target is the DMA engine rather than the VTOR we saw in the last section.</p>&#13;
<p class="indent">On the CKS32F103, the DMA engine is always allowed to read from flash memory, even after the CPU’s access has been revoked, so you can simply use DMA to copy from flash memory to SRAM in memory-to-memory mode. CPU debugging is used to halt the CPU, order the DMA engine to copy from flash to SRAM, and fetch the contents of SRAM.</p>&#13;
<p class="indent">On the GD32F103, we can still use JTAG to read out the buffer but <em>cannot</em> halt the CPU with it, as that would enable flash memory restrictions for the DMA engine. Because the CPU must still be halted to prevent memory access conflicts, they use the VTOR trick from <a href="app02.xhtml#app02_1">Chapter B.1</a> to relocate the interrupt vector table to <code>0xF0000000</code>, an illegal address that causes the CPU to crash on the next non-maskable interrupt (NMI). This halts the CPU but not the DMA engine, preventing bus conflicts from ruining the reliability of the rest of memory being transferred.</p>&#13;
<p class="indent">Another attack from the paper impacts the CKS32F103 and GD32VF103, the latter of which uses a RISC-V core instead of the ARM core of the original STM32 chips and their other clones. Instead of directing the DMA peripheral to copy memory over JTAG, this attack makes use of the fact that flash memory access is not disabled when the CPU executes code from certain regions of the chip.</p>&#13;
<p class="indent">In the GD32VF103, firmware executed from flash memory or from SRAM can read flash memory, even when the chip is read-protected and the debugger cannot directly read flash memory. So to dump memory, you just write some shellcode into RAM, run it to perform a copy from flash memory, and then use your debugger to read the buffer out of RAM.</p>&#13;
<p class="indent">The CKS32F103 has a similar loophole, but only for code <span epub:type="pagebreak" id="page_283"/>running from ROM, and not for code running from RAM. One method to exploit this would be to blindly search for an appropriate gadget in code memory, as we saw for the nRF51 in <a href="ch09.xhtml#ch09">Chapter 9</a>. Obermaier takes a different approach, dumping the bootloader of an unlocked chip to find gadgets that exist at reliable addresses for all CKS32F103 devices.</p>&#13;
<h3 class="h3" id="app02_2"><strong>B.2 GD32 GigaVulnerability</strong></h3>&#13;
<p class="noindent">Kovrizhnykh (2023) presents three new vulnerabilities for GD32 microcontrollers by expanding the work of Obermaier, Schink, and Moczek (2020). These vulnerabilities impact different devices; see <a href="app02.xhtml#chBtab1">Table B.1</a> to find the one that works for your chip of interest.</p>&#13;
<p class="indent">In these chips, protection levels are roughly same as in a real STM32. RDP Level 0 is unprotected, Level 1 allows debugging at the cost of disabling flash memory, and Level 2 ought to prohibit all debugging. The debugging protocol here is SWD, not JTAG.</p>&#13;
<p class="indent">Each of these attacks depends upon an odd observation that SWD debugging is possible while the chip is held in reset. SRAM and flash memory always read as zero. Peripherals can be read, but only as their reset values. SWD buffers, such as the result of a read or the address that might soon be read, do not seem to be erased.</p>&#13;
<p class="indent">The first of these three vulnerabilities is that in some chips, such as the GD32L23x, GD32E23x, and GD32E50x, a read that is queued up during reset can be performed just as the chip exits reset. Kovrizhnykh found that he could leak words of SRAM this way.</p>&#13;
<p class="indent">While the !RST pin is low, he sends “<code>W AP4 0x20000008</code>” to prepare a read of SRAM. !RST is then raised, which takes the chip out of reset and begins to boot it. Just 1.45 µs later, he sends “<code>R APc</code>” to perform the read and drops the !RST pin low shortly after the read command is sent. In all, the chip is only out of reset for 55 µs. When the chip is back in reset, he sends “<code>RDBUFF</code>” and the chip happily provides <code>0x0800186c</code>, the value at the expected address.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_284"/><img id="chBfig1" src="../images/f0284-01.jpg" alt="Image" width="777" height="799"/></div>&#13;
<p class="figcap">Figure B.1: GD32F130, Lower Die</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_285"/><img id="chBtab1" src="../images/f0285-01.jpg" alt="Image" width="797" height="447"/></div>&#13;
<p class="tab-cap">Table B.1: GigaVulnerability Success Table</p>&#13;
<p class="indent">The mechanism here is a race condition. If the chip were given time to fully boot, the debugging restrictions would come online and the read would be denied. This technique does not allow flash memory to be extracted, presumably because flash takes longer than SRAM to become available after a reset.</p>&#13;
<p class="indent">The second vulnerability relies on disconnecting the debugger altogether, as the readout protection is triggered when the debug domain is enabled with <code>CDBGPWRUPREQ</code>. It is exploited by loading a dumper application into SRAM and starting the application, then clearing the debug domain bit with <code>chip.dap dpreg 0x4</code> <span epub:type="pagebreak" id="page_286"/><code>0x0</code> in OpenOCD. Memory happily falls out the UART, and not just SRAM but also flash memory can be directly extracted this way.</p>&#13;
<p class="indent">Most of the tested devices are vulnerable to this attack, but the GD32F3x0 is a stubborn exception, vulnerable to neither the first nor the second methods.</p>&#13;
<p class="indent">A third variant involves a race condition in the power-on reset sequence of the F-series chips in this family. SWD will not work after the !RST pin goes high, but you can use it by powering down the chip, pulling !RST to ground, and then powering the chip up. Power analysis showed Kovrizhnykh that the race window is much wider on this series, 1600 µs instead of the 20 µs window of the E and L series.</p>&#13;
<p class="indent">There are two more complications to this third variant. SRAM has faded out from the loss of power, so we cannot expose its contents in the way that the first variant allows. Another complication is that while SWD is allowed, debugging the CPU is not, so any reading of the flash memory will have to be performed by the peripherals. Forbidden from using the CPU, Kovrizhnykh instead configured the DMA peripheral to dump all flash memory directly to the UART.</p>&#13;
<h3 class="h3" id="app02_3"><strong>B.3 Xilinx Bitstream Decryption Oracle</strong></h3>&#13;
<p class="noindent">The 7-Series FPGAs from Xilinx internally store the bitstream in SRAM during operation, requiring them to load the configuration from either an external memory chip or a microcontroller. To provide for protection of these bitstreams without the cost of adding a nonvolatile memory, Xilinx allows the bitstream to be encrypted with AES-256 in CBC-mode, using a key that has been burned into the limited eFuse memory of the FPGA.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_287"/>Reading out the bitstream by JTAG is disabled by the encryption feature, but Ender, Moradi, and Paar (2020) describes an exploit that leaks 32 bits of the cleartext bitstream at a time. They noticed that the <code>WBSTAR</code> register is loaded with a <em>decrypted</em> word of the bitstream just before an HMAC error. They can then reset the FPGA and read out the contents of this register, as it is not cleared by the reset.</p>&#13;
<p class="indent">This attack is slow but effective, decrypting the bitstream of a Kintex-7 XC7K160T in three hours and 42 minutes. The Virtex 6 family is also vulnerable to this attack, with the limitation that two bits of each 32-bit word are corrupted and lost during the reset.</p>&#13;
<h3 class="h3" id="app02_4"><strong>B.4 CC2510, CC1110</strong></h3>&#13;
<p class="noindent">The CC2510 and CC1110 from Texas Instruments were some of the first chips to combine nonvolatile memory, a radio transceiver, and a microcontroller into a single package. This generation uses an 8051 as the MCU.</p>&#13;
<p class="indent">Devreker (2023) describes a voltage glitching attack for dumping firmware from these chips, inspired by their use in an eInk price tag with an as-yet-unknown radio protocol. Devreker began by implementing the debugging interface with a Raspberry Pi Pico, then added glitching support to it through an IRLML6246 MOSFET on the DCOUPL pin, a more or less direct tap of the internal 1.8V line intended for attaching a decoupling capacitor. His code is freely available.<sup><a id="app2fn_1" href="footnotes.xhtml#app2fn1">1</a></sup></p>&#13;
<p class="indent">He notes a number of handy tricks in his article. Over-clocking the Pi Pico to 250MHz from the default 125MHz doubles the glitching precision. This chip has multiple cores, and running the glitch on a separate core from the USB stack keeps USB interrupts from influencing timing. Increasing the drive strength of the glitching pin gives it a faster slew rate than the default, so that the glitch has sharper edges. Powering the CC2510 directly from GPIO pins of the Pi Pico makes it easy to power cycle the target after a failure. These little tricks might not all be strictly necessary, but they add some portability to his paper and make for good reading even if you’re working against a very different target.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_288"/><img id="chBfig2" src="../images/f0288-01.jpg" alt="Image" width="777" height="976"/></div>&#13;
<p class="figcap">Figure B.2: Texas Instruments CC2510</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_289"/>As for the glitch itself, attacking the state machine of a debugging protocol can be quite different from attacking the software parser of a bootloader. The lock status of the chip is checked whenever the debugger orders the chip to execute an instruction. This can be bypassed with a glitch just after the <code>DEBUG_INSTR</code> debugging command, but it takes a minimum of two instructions to first <code>MOV</code> a 16-bit address into <code>DPTR</code> and then <code>MOVX</code> the byte at <code>@DPTR</code> into the accumulator. Both glitches must be successful to read one byte.</p>&#13;
<p class="indent">With this requirement for a double glitch, Devreker’s exploit is quite slow. He reports a success rate of roughly 5% on each glitch, for a combined success rate of 0.25% on the double glitch. This gets him a single byte every twenty seconds, or the full 32kB firmware image in four days.<span epub:type="pagebreak" id="page_290"/></p>&#13;
</div>
</div>
</body></html>