- en: '**17'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**17**'
- en: HOW UEFI SECURE BOOT WORKS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI安全启动如何工作**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: In previous chapters, we talked about the introduction of the Kernel-Mode Code
    Signing Policy, which encouraged malware developers to shift from using rootkits
    to using bootkits, moving the attack vector from the OS kernel to unprotected
    boot components. This kind of malware executes before the OS loads, so it’s able
    to bypass or disable OS security mechanisms. In order to enforce security and
    ensure safety, then, the OS must be able to boot into a trusted environment whose
    components have not been tampered with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了内核模式代码签名策略的引入，它鼓励恶意软件开发者从使用根套件转向使用引导套件，将攻击向量从操作系统内核转移到未受保护的引导组件。这种恶意软件在操作系统加载之前执行，因此能够绕过或禁用操作系统的安全机制。为了强制执行安全性并确保安全性，操作系统必须能够启动到一个受信任的环境中，其中的组件未被篡改。
- en: This is where UEFI Secure Boot technology, the subject of this chapter, comes
    into play. Aimed primarily at protecting the platform’s boot components against
    modification and ensuring that only trusted modules are loaded and executed at
    bootup, UEFI Secure Boot can be an effective solution to bootkit threats—as long
    as it covers all angles of attack.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是UEFI安全启动技术发挥作用的地方，本章的主题。UEFI安全启动主要旨在保护平台的引导组件免受修改，并确保只有受信任的模块在启动时加载和执行。只要它覆盖所有攻击角度，UEFI安全启动可以有效应对引导套件威胁。
- en: However, the protections offered by UEFI Secure Boot are vulnerable to *firmware
    rootkits*, the newest and fastest-growing malware technology. As a result, you
    need another layer of security to cover the entire boot process from the very
    beginning. You can achieve this with an implementation of Secure Boot called *Verified
    and Measured Boot*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，UEFI安全启动提供的保护容易受到*固件根套件*的威胁，后者是最新且增长最快的恶意软件技术。因此，你需要额外的安全层来覆盖整个引导过程的开始。你可以通过一种名为*验证和测量启动*的安全启动实现来做到这一点。
- en: This chapter introduces you to the core of this security technology, first describing
    how it can protect against firmware rootkits when anchored into hardware and then
    discussing its implementation details and how it protects victims against bootkits.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍这项安全技术的核心，首先描述它如何在嵌入到硬件中时保护免受固件根套件的攻击，然后讨论其实现细节以及它如何保护受害者免受引导套件的攻击。
- en: As often happens in the security industry, though, very few security solutions
    can provide an ultimate protection against attacks; the attackers and defenders
    are locked in an eternal arms race. We’ll close the chapter by discussing the
    flaws of UEFI Secure Boot, ways to bypass it, and how to protect it using two
    versions of Verified and Measured Boot from Intel and ARM.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如安全行业中常见的那样，极少有安全解决方案能够提供对攻击的终极保护；攻击者和防御者在一场永恒的军备竞赛中相互博弈。我们将在本章结束时讨论UEFI安全启动的缺陷、绕过方法以及如何使用英特尔和ARM的两个版本的验证和测量启动来保护它。
- en: '**What Is Secure Boot?**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是安全启动？**'
- en: The main purpose of Secure Boot is to prevent anyone from executing unauthorized
    code in the preboot environment; thus, only code that meets the platform’s integrity
    policy is allowed to execute. This technology is very important for high-assurance
    platforms, and it’s also frequently used on embedded devices and mobile platforms,
    as it allows vendors to restrict platforms to vendor-approved software, such as
    iOS on iPhones or the Windows 10 S operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动的主要目的是防止任何人在引导环境中执行未经授权的代码；因此，只有符合平台完整性策略的代码才能执行。这项技术对高安全保障平台非常重要，也常用于嵌入式设备和移动平台，因为它允许供应商限制平台只能运行经过供应商批准的软件，例如iPhone上的iOS或Windows
    10 S操作系统。
- en: 'Secure Boot comes in three forms, which depend on the level of the boot process
    hierarchy at which it’s enforced:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动有三种形式，具体取决于在哪个引导过程层次上执行：
- en: '**OS Secure Boot** Implemented at the level of the OS bootloader. This verifies
    components loaded by the OS bootloader, such as the OS kernel and boot-start drivers.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统安全启动** 在操作系统引导加载程序层面实现。它验证操作系统引导加载程序加载的组件，例如操作系统内核和引导启动驱动程序。'
- en: '**UEFI Secure Boot** Implemented in UEFI firmware. This verifies UEFI DXE drivers
    and applications, Option ROMs, and OS bootloaders.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**UEFI安全启动** 实现于UEFI固件中。它验证UEFI DXE驱动程序和应用程序、选项ROM以及操作系统引导加载程序。'
- en: '**Platform Secure Boot (Verified and Measured Secure Boot)** Anchored in the
    hardware. This verifies platform initialization firmware.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台安全启动（验证和测量安全启动）** 锚定在硬件中。它验证平台初始化固件。'
- en: We discussed OS Secure Boot in [Chapter 6](ch06.xhtml#ch06), so in this chapter
    we focus on UEFI Secure Boot and Verified and Measured Boot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](ch06.xhtml#ch06)中讨论了操作系统安全启动，因此在本章中我们将重点讨论UEFI安全启动以及验证启动和度量启动。
- en: '**UEFI Secure Boot Implementation Details**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**UEFI安全启动实现细节**'
- en: We’ll start this discussion with how UEFI Secure Boot works. First, it’s important
    to note that UEFI Secure Boot is a part of the UEFI specification, which you can
    find at *[http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf](http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf)*.
    We’ll be referring to the specification—in other words, the description of how
    UEFI Secure Boot is *supposed* to work—though different platform manufacturers
    may have different implementation details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从UEFI安全启动的工作原理开始讨论。首先，重要的是要注意，UEFI安全启动是UEFI规范的一部分，你可以在*[http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf](http://www.uefi.org/sites/default/files/resources/UEFI_Spec_2_7.pdf)*找到这份规范。我们将参考该规范——换句话说，描述UEFI安全启动*应该*如何工作的内容——尽管不同的平台制造商可能有不同的实现细节。
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When we refer to “Secure Boot” from now on in this section, we’re talking
    about UEFI Secure Boot unless otherwise mentioned.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们在本节中提到“安全启动”时，除非另有说明，我们指的是UEFI安全启动。*'
- en: We’ll begin by looking at the boot sequence to see where Secure Boot comes into
    play. Then, we’ll look at how Secure Boot authenticates executables and discuss
    the databases involved.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看启动序列，了解“安全启动”在其中的作用。然后，我们将讨论“安全启动”如何认证可执行文件，并讨论涉及的数据库。
- en: '***The Boot Sequence***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动序列***'
- en: Let’s quickly review the UEFI boot sequence described in [Chapter 14](ch14.xhtml#ch14)
    to see where Secure Boot comes into the process. If you skipped that chapter,
    it’s worth visiting it now.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下在[第14章](ch14.xhtml#ch14)中描述的UEFI启动序列，看看“安全启动”在这个过程中出现的位置。如果你跳过了这一章，现在回去看看是值得的。
- en: 'If you refer back to “[How UEFI Firmware Works](ch14.xhtml#ch14lev1sec4)” on
    [page 242](ch14.xhtml#page_242), you’ll see that the first piece of code executed
    when a system comes out of reset is the platform initialization (PI) firmware,
    which performs basic initialization of the platform hardware. When the PI is executed,
    the chipset and memory controller are still in an uninitialized state: no DRAM
    is available for the firmware yet, and peripheral devices on the PCIe bus have
    not yet been enumerated. (The *PCIe bus* is a high-speed serial bus standard used
    on virtually all modern PCs; we’ll discuss it more in later chapters.) At this
    point, Secure Boot isn’t yet active, meaning the PI part of the system’s firmware
    isn’t protected at this point.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到[第242页](ch14.xhtml#page_242)的“[UEFI固件如何工作](ch14.xhtml#ch14lev1sec4)”一节，你会看到系统从复位状态启动时，执行的第一段代码是平台初始化（PI）固件，它执行平台硬件的基本初始化。当PI执行时，芯片组和内存控制器仍处于未初始化状态：此时固件还无法访问DRAM，PCIe总线上的外设设备尚未被枚举。（*PCIe总线*是一种高速串行总线标准，几乎用于所有现代PC；我们将在后续章节中进一步讨论。）此时，“安全启动”尚未激活，这意味着系统固件的PI部分在此时并没有受到保护。
- en: Once the PI firmware discovers and configures RAM and performs the basic platform
    initialization, it proceeds to load the DXE drivers and UEFI applications, which
    in turn continue to initialize the platform hardware. This is when Secure Boot
    comes into play. Anchored in the PI firmware, Secure Boot is used to authenticate
    the UEFI modules loaded from the SPI (Serial Peripheral Interface) flash or Option
    ROMs of peripheral devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PI固件发现并配置了RAM，并完成了平台硬件的基本初始化，它将继续加载DXE驱动程序和UEFI应用程序，后者继续初始化平台硬件。这时，“安全启动”开始发挥作用。作为PI固件的一部分，“安全启动”用于验证从SPI（串行外设接口）闪存或外设设备的选项ROM中加载的UEFI模块。
- en: The authentication mechanism used in Secure Boot is, in essence, a digital signature
    verification process. Only properly authenticated images are allowed to execute.
    Secure Boot relies on a *public key infrastructure (PKI)* to manage signature
    verification keys.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “安全启动”中使用的认证机制本质上是一个数字签名验证过程。只有经过正确认证的映像才被允许执行。“安全启动”依赖于*公钥基础设施（PKI）*来管理签名验证密钥。
- en: Explained simply, a Secure Boot implementation contains a public key that is
    used to verify the digital signature of executable images loaded at boot. The
    images should have an embedded digital signature, although, as you’ll see later
    in this chapter, there are some exceptions to this rule. If an image passes verification,
    it is loaded and eventually executed. If an image does not have a signature and
    verification fails, it will trigger remediation behavior—actions executed in cases
    when Secure Boot fails. Depending on the policy, the system can continue booting
    normally or abort the boot process and display an error message to the user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，安全启动实现包含一个公钥，用于验证启动时加载的可执行映像的数字签名。映像应该包含嵌入的数字签名，尽管正如你将在本章稍后看到的那样，某些情况下此规则有例外。如果映像通过验证，它将被加载并最终执行。如果映像没有签名并且验证失败，则会触发修复行为——当安全启动失败时执行的操作。根据策略，系统可以继续正常启动，也可以中止启动过程并向用户显示错误信息。
- en: Actual implementations of Secure Boot are a bit more complicated than we’ve
    described here. To properly establish trust in the code that’s executed during
    boot, Secure Boot uses different types of signature databases, keys, and policies.
    Let’s take a look at these factors one by one and dig into the details.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动的实际实现比我们在这里描述的要复杂一些。为了正确建立启动过程中执行的代码的信任，安全启动使用不同类型的签名数据库、密钥和策略。让我们逐一看一下这些因素，并深入了解其细节。
- en: '**REAL-WORLD IMPLEMENTATIONS: TRADEOFFS**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**实际世界的实现：权衡**'
- en: In real implementations of UEFI firmware, platform manufacturers often compromise
    between security and performance. Checking the digital signature of every UEFI
    image requesting execution takes time. On an average modern platform, there may
    be a few hundred UEFI images trying to load, so verifying the digital signature
    of every single executable would prolong the boot process. At the same time, manufacturers
    are under pressure to reduce boot time, especially in embedded systems and in
    the automotive industry. Instead of verifying every UEFI image, firmware vendors
    often choose to verify UEFI images with hashes to increase performance. The set
    of hashes for allowed images is located in a storage solution, the integrity and
    authenticity of which is ensured only once, via digital signature, when the storage
    is accessed. We’ll discuss these hashes in more detail later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的UEFI固件实现中，平台制造商通常在安全性和性能之间做出妥协。检查每个请求执行的UEFI映像的数字签名需要时间。在现代平台上，可能有几百个UEFI映像试图加载，因此验证每个可执行文件的数字签名会延长启动过程。同时，制造商面临着缩短启动时间的压力，特别是在嵌入式系统和汽车行业中。固件供应商通常选择通过哈希值来验证UEFI映像，以提高性能，而不是验证每个UEFI映像。允许的映像的哈希集存储在一个存储解决方案中，该存储解决方案的完整性和真实性仅在访问存储时通过数字签名确保。我们将在本章稍后详细讨论这些哈希值。
- en: '***Executable Authentication with Digital Signatures***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用数字签名进行可执行文件认证***'
- en: As a first step toward understanding Secure Boot, let’s take a look at how UEFI
    executables are actually signed—that is, where the digital signature is located
    in an executable file and what kinds of signatures Secure Boot supports.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为理解安全启动的第一步，让我们看看UEFI可执行文件是如何被签名的——即数字签名位于可执行文件的哪个位置，以及安全启动支持哪些类型的签名。
- en: For UEFI executable files that are Portable Executable (PE) images, the digital
    signatures are contained in special data structures called *signature certificates*.
    The location of these certificates in the binary is determined by a special field
    of the PE header data structure called the *Certificate Table Data Directory*,
    illustrated in [Figure 17-1](ch17.xhtml#ch17fig01). It’s worth mentioning that
    there may be multiple digital signatures for a single file, generated using different
    signing keys for different purposes. By looking at this field, the UEFI firmware
    can locate the signature information used to authenticate the executable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为可移植可执行（PE）映像的UEFI可执行文件，数字签名包含在一种特殊的数据结构中，称为*签名证书*。这些证书在二进制文件中的位置由PE头数据结构中的一个特殊字段确定，称为*证书表数据目录*，如[图17-1](ch17.xhtml#ch17fig01)所示。值得一提的是，单个文件可能有多个数字签名，这些签名使用不同的签名密钥生成，目的是用于不同的用途。通过查看这个字段，UEFI固件可以找到用于验证可执行文件的签名信息。
- en: '![image](../images/17fig01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig01.jpg)'
- en: '*Figure 17-1: Location of digital signatures in UEFI images*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-1：UEFI映像中数字签名的位置*'
- en: Other types of UEFI executable images, such as *Terse Executable (TE)* images,
    don’t have embedded digital signatures due to the specifics of their executable
    format. The TE image format was derived from the PE/COFF format in an attempt
    to reduce the TE’s size so that it would take up less space. Thus, TE images contain
    only the fields of the PE format that are necessary to execute an image in a PI
    environment, which means they don’t contain fields like the Certificate Table
    Data Directory. As a result, UEFI firmware can’t directly authenticate such images
    by verifying their digital signature. However, Secure Boot provides capabilities
    for authenticating these images using cryptographic hashes, a mechanism that is
    described in more detail in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的 UEFI 可执行镜像，如 *简洁可执行文件（TE）* 镜像，由于其可执行格式的特点，未嵌入数字签名。TE 镜像格式源自 PE/COFF 格式，旨在减少
    TE 的大小，使其占用更少的空间。因此，TE 镜像仅包含 PE 格式中执行镜像所需的字段，这意味着它们不包含诸如证书表数据目录之类的字段。因此，UEFI 固件无法通过验证数字签名直接对这些镜像进行认证。然而，安全启动提供了通过加密散列来认证这些镜像的功能，下一节将详细描述这一机制。
- en: The layout of an embedded signature certificate depends on its type. We won’t
    get into layout specifics here, but you can learn more in “[Location of Driver
    Signatures](ch06.xhtml#ch06lev2sec4)” on [page 73](ch06.xhtml#page_73).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式签名证书的布局取决于其类型。我们在此不深入讨论布局的具体细节，但你可以在[第73页](ch06.xhtml#page_73)的“[驱动程序签名的位置](ch06.xhtml#ch06lev2sec4)”中了解更多。
- en: 'Every type of signature certificate used in Secure Boot contains the following
    at a minimum: information on the cryptographic algorithms used for signature generation
    and verification (for instance, cryptographic hash functions and digital signature
    algorithm identifiers), a cryptographic hash of the executable in question, the
    actual digital signature, and the public key used to verify the digital signature.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每种用于安全启动的签名证书至少包含以下内容：用于签名生成和验证的加密算法信息（例如，密码散列函数和数字签名算法标识符）、目标可执行文件的加密散列、实际的数字签名，以及用于验证数字签名的公钥。
- en: This information is sufficient for Secure Boot to verify the authenticity of
    an executable image. To do this, the UEFI firmware locates and reads a signature
    certificate from the executable, computes the hash of the executable according
    to a specified algorithm, and then compares the hash with the one provided in
    the signature certificate. If they match, the UEFI firmware verifies the digital
    signature of the hash using the key provided in the signature certificate. If
    the signature verification succeeds, then the UEFI firmware accepts the signature.
    In any other case (like a hash mismatch or signature verification failure), the
    UEFI firmware fails to authenticate the image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息足以让安全启动验证可执行镜像的真实性。为此，UEFI 固件会定位并读取可执行文件中的签名证书，按照指定的算法计算可执行文件的散列值，然后将该散列值与签名证书中提供的散列值进行比较。如果匹配，UEFI
    固件将使用签名证书中提供的密钥验证该散列的数字签名。如果签名验证成功，则 UEFI 固件接受该签名。在任何其他情况下（如散列不匹配或签名验证失败），UEFI
    固件将无法认证该镜像。
- en: However, simply verifying that the signature matches isn’t enough to establish
    trust in a UEFI executable. UEFI firmware must also ensure that the executable
    was signed with an authorized key. Otherwise, there’s nothing to prevent anyone
    from generating a custom signing key and signing a malicious image with it to
    pass Secure Boot validation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅验证签名是否匹配不足以建立对 UEFI 可执行文件的信任。UEFI 固件还必须确保该可执行文件是用授权密钥签名的。否则，任何人都可以生成自定义签名密钥，并使用该密钥签署恶意镜像以通过安全启动验证。
- en: That’s why the public key used for signature validation should be matched with
    a trusted private key. The UEFI firmware explicitly trusts these private keys,
    so they may be used to establish trust in an image. A list of the trusted public
    keys is stored in the `db` database, which we’ll explore next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么用于签名验证的公钥应该与受信任的私钥匹配的原因。UEFI 固件显式信任这些私钥，因此它们可以用于建立对镜像的信任。受信任公钥的列表存储在`db`数据库中，接下来我们将进行探索。
- en: '***The db Database***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***db 数据库***'
- en: The `db` database holds a list of trusted public key certificates authorized
    to authenticate signatures. Whenever Secure Boot performs signature verification
    on an executable, it checks the signature public key against the list of keys
    in the `db` database to determine whether or not it can trust the key. Only code
    signed with private keys that correspond to these certificates will be executed
    on the platform during the boot process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`db`数据库保存了一个受信任的公钥证书列表，这些证书被授权用来验证签名。每当安全启动执行可执行文件的签名验证时，它会将签名的公钥与`db`数据库中的密钥列表进行比对，以判断是否可以信任该密钥。只有使用与这些证书对应的私钥签名的代码，才能在启动过程中在平台上执行。'
- en: In addition to the list of trusted public key certificates, the `db` database
    contains hashes of individual executables that are allowed to execute on the platform,
    regardless of whether or not they’re digitally signed. This mechanism can be used
    to authenticate TE files that don’t have embedded digital signatures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了受信任的公钥证书列表外，`db`数据库还包含允许在平台上执行的单个可执行文件的哈希值，无论这些文件是否有数字签名。这个机制可以用来验证没有嵌入数字签名的TE文件。
- en: According to the UEFI specification, the signatures database is stored in a
    nonvolatile RAM (NVRAM) variable that persists across reboots of the system. The
    implementation of NVRAM variables is platform specific, and different original
    equipment manufacturers (OEMs) may implement it in different ways. Most commonly,
    these variables are stored in the same SPI flash that contains platform firmware,
    such as the BIOS. As you’ll see in “[Modifying the UEFI Variables to Bypass Security
    Checks](ch17.xhtml#ch17lev2sec11)” on [page 337](ch17.xhtml#page_337), this leads
    to vulnerabilities that you can use to bypass Secure Boot.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据UEFI规范，签名数据库存储在一个非易失性RAM（NVRAM）变量中，该变量在系统重启后依然保留。NVRAM变量的实现方式是平台特定的，不同的原始设备制造商（OEM）可能会以不同的方式实现它。最常见的是，这些变量存储在与平台固件（如BIOS）相同的SPI闪存中。正如你将在[《修改UEFI变量以绕过安全检查》](ch17.xhtml#ch17lev2sec11)中看到的，在[第337页](ch17.xhtml#page_337)，这会导致一些漏洞，你可以利用这些漏洞绕过安全启动。
- en: Let’s check out the contents of the `db` database on your own system by dumping
    the contents of the NVRAM variable that holds the database. We’ll be using the
    Lenovo Thinkpad T540p platform as our example, but you should use whatever platform
    you’re working with. We’ll dump the contents of the NVRAM variable using the Chipsec
    open source toolset, which you encountered in [Chapter 15](ch15.xhtml#ch15). This
    toolset has rich functionality useful for forensic analysis, and we’ll discuss
    it in more detail in [Chapter 19](ch19.xhtml#ch19).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过转储保存数据库的NVRAM变量的内容，来查看你自己系统上`db`数据库的内容。我们将以联想Thinkpad T540p平台为例，但你应该使用你所工作的平台。我们将使用Chipsec开源工具集来转储NVRAM变量的内容，这个工具集你在[第15章](ch15.xhtml#ch15)中已经接触过。这个工具集具有丰富的功能，适用于取证分析，我们将在[第19章](ch19.xhtml#ch19)中更详细地讨论它。
- en: 'Download the Chipsec tool from GitHub at *[https://github.com/chipsec/chipsec/](https://github.com/chipsec/chipsec/)*.
    The tool depends on `winpy` (Python for Windows Extensions), which you’ll need
    to download and install before running Chipsec. Once you have both, open Command
    Prompt or another command line interpreter and navigate into the directory holding
    the downloaded Chipsec tool. Then enter the following command to get a list of
    your UEFI variables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub下载Chipsec工具，地址是*[https://github.com/chipsec/chipsec/](https://github.com/chipsec/chipsec/)*。该工具依赖于`winpy`（Windows平台的Python扩展），你需要先下载并安装`winpy`，然后才能运行Chipsec。安装完毕后，打开命令提示符或其他命令行解释器，进入存放下载的Chipsec工具的目录。然后输入以下命令，获取你的UEFI变量列表：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command dumps all the UEFI variables from your current directory into the
    subdirectory *efi_variables.dir* and decodes the contents of some of them (Chipsec
    decodes only the contents of known variables). Navigate to the directory, and
    you should see something similar to [Figure 17-2](ch17.xhtml#ch17fig02).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将从当前目录转储所有UEFI变量到子目录*efi_variables.dir*中，并解码其中的一些内容（Chipsec只解码已知变量的内容）。进入该目录，你应该会看到类似[图17-2](ch17.xhtml#ch17fig02)的内容。
- en: '![image](../images/17fig02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig02.jpg)'
- en: '*Figure 17-2: UEFI variables dumped by Chipsec*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-2：Chipsec转储的UEFI变量*'
- en: Every entry in this directory corresponds to a separate UEFI NVRAM variable.
    These variable names have the structure VarName`_`VarGUID`_`VarAttributes`.bin`,
    where VarName is the name of the variable, VarGUID is the variable’s 16-byte global
    unique identifier (GUID), and VarAttributes is a list of the variable’s attributes
    in short form. Based on the UEFI specification, here are some of the attributes
    of the entries in [Figure 17-2](ch17.xhtml#ch17fig02).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录中的每个条目对应一个单独的 UEFI NVRAM 变量。这些变量名的结构为 VarName`_`VarGUID`_`VarAttributes`.bin，其中
    VarName 是变量的名称，VarGUID 是变量的 16 字节全局唯一标识符（GUID），VarAttributes 是该变量属性的简短列表。根据 UEFI
    规范，以下是 [图 17-2](ch17.xhtml#ch17fig02) 中条目的部分属性。
- en: NV Nonvolatile, meaning the variable’s content persists across reboot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NV 非易失性，意味着变量的内容在重启后仍然存在。
- en: BS Can be accessed by UEFI boot services. UEFI boot services are generally available
    during boot time before the OS loader is executed. Once the OS loader is launched,
    the UEFI boot services are no longer available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: BS 可以通过 UEFI 启动服务访问。UEFI 启动服务通常在启动时可用，即操作系统加载器执行之前。一旦操作系统加载器启动，UEFI 启动服务将不再可用。
- en: RT Can be accessed by UEFI runtime services. Unlike UEFI boot services, the
    runtime services persist throughout the loading of the OS and during the OS runtime.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RT 可以通过 UEFI 运行时服务访问。与 UEFI 启动服务不同，运行时服务在操作系统加载和运行期间持续有效。
- en: AWS Count-based authenticated variable, meaning that any new variable content
    needs to be signed with an authorized key so the variable can be written to. The
    variable’s signed data includes a counter to protect against rollback attacks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 基于计数的认证变量，意味着任何新的变量内容需要用授权密钥进行签名，以便该变量能够被写入。该变量的签名数据包括一个计数器，用于防止回滚攻击。
- en: TBAWS Time-based authenticated variable, meaning any new variable content needs
    to be signed with an authorized key in order for the variable to be written to.
    The timestamp in the signature reflects the time when the data was signed. It’s
    used to confirm that the signature was created before the corresponding signing
    key expired. We provide more information on time-based authentication in the next
    section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TBAWS 基于时间的认证变量，意味着任何新的变量内容需要用授权密钥进行签名，以便该变量能够被写入。签名中的时间戳反映了数据签名的时间。它用于确认签名是在相应的签名密钥过期之前创建的。我们将在下一节提供有关基于时间认证的更多信息。
- en: If Secure Boot is configured and the `db` variable exists on the platform, you
    should find a subfolder in this directory with a name starting with *db_D719B2CB-3D3A-4596-A3BC-DAD00E67656F*.
    When Chipsec dumps the `db` UEFI variable, it automatically decodes the variable’s
    contents into this subfolder, which contains files corresponding to public key
    certificates and hashes of UEFI images authorized for execution. In our case,
    we have five files—four certificates and one SHA256 hash, as shown in [Figure
    17-3](ch17.xhtml#ch17fig03).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置了安全启动并且平台上存在 `db` 变量，你应该在该目录中找到一个以 *db_D719B2CB-3D3A-4596-A3BC-DAD00E67656F*
    开头的子文件夹。当 Chipsec 转储 `db` UEFI 变量时，它会自动将变量的内容解码到该子文件夹中，该子文件夹包含与公钥证书和授权执行的 UEFI
    镜像的哈希值对应的文件。在我们的例子中，我们有五个文件——四个证书和一个 SHA256 哈希，如 [图 17-3](ch17.xhtml#ch17fig03)
    所示。
- en: '![image](../images/17fig03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig03.jpg)'
- en: '*Figure 17-3: The contents of a signature database UEFI variable*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-3：签名数据库 UEFI 变量的内容*'
- en: 'These certificates are encoded with X.509, a cryptographic standard that defines
    the format of public key certificates. We can decode these certificates to get
    information about the issuer, which will tell us whose signature will pass Secure
    Boot verification. For this, we’ll use the `openssl` toolkit, described in the
    box “The OpenSSL Toolkit.” Install the tool from *[https://github.com/openssl/openssl/](https://github.com/openssl/openssl/)*,
    and then run it with the following command, replacing certificate_file_path with
    the directory on your computer that contains `openssl`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些证书采用 X.509 编码，X.509 是一种定义公钥证书格式的加密标准。我们可以解码这些证书，获取有关发行者的信息，这将告诉我们谁的签名能够通过安全启动验证。为此，我们将使用
    `openssl` 工具包，工具包的描述见框中“OpenSSL 工具包”。从 *[https://github.com/openssl/openssl/](https://github.com/openssl/openssl/)*
    安装该工具包，然后使用以下命令运行它，替换 `certificate_file_path` 为包含 `openssl` 的目录路径：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On a Windows operating system, simply change the extension of the X.509 certificate
    file from *bin* to *crt* and open the file with Explorer to see the results of
    the decoding. [Table 17-1](ch17.xhtml#ch17tab01) shows our results, with the issuers
    and subjects of the certificates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统上，只需将 X.509 证书文件的扩展名从*bin*更改为*crt*，然后使用资源管理器打开该文件，即可查看解码结果。[表17-1](ch17.xhtml#ch17tab01)展示了我们的结果，其中列出了证书的颁发者和主题。
- en: '**Table 17-1:** The Decoded Certificates and Hashes from the UEFI Variable'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表17-1：** 从 UEFI 变量中解码的证书和哈希值'
- en: '| **Filename** | **Issued to** | **Issued by** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **文件名** | **颁发给** | **颁发者** |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-03.bin* | Thinkpad Product CA
    2012 | Lenovo Ltd. Root CA 2012 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-03.bin* | Thinkpad 产品 CA 2012
    | 联想有限公司根证书 CA 2012 |'
- en: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-04.bin* | Lenovo UEFI CA 2014
    | Lenovo UEFI CA 2014 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-04.bin* | 联想 UEFI CA 2014 | 联想
    UEFI CA 2014 |'
- en: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | Microsoft Corporation
    UEFI CA 2011 | Microsoft Corporation Third-Party Marketplace Root |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | 微软公司 UEFI CA 2011 |
    微软公司第三方市场根证书 |'
- en: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-02.bin* | Microsoft Windows Production
    PCA 2011 | Microsoft Root Certificate Authority 2010 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-02.bin* | 微软 Windows 生产 PCA 2011
    | 微软根证书颁发机构 2010 |'
- en: From the table, you can see that only UEFI images signed by Lenovo and Microsoft
    will pass the UEFI Secure Boot code integrity checks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中可以看到，只有由联想和微软签名的 UEFI 镜像才能通过 UEFI 安全启动的代码完整性检查。
- en: '**THE OPENSSL TOOLKIT**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**OPENSSL 工具包**'
- en: OpenSSL is an open source software library that implements the Secure Socket
    Layer and Transport Layer Security protocols, as well as general-purpose cryptography
    primitives. Licensed under an Apache-style license, OpenSSL is frequently used
    in commercial and noncommercial applications. The library offers rich functionality
    for working with X.509 certificates, whether you’re parsing existing certificates
    or generating new ones. You can find information on the project at *[https://www.openssl.org/](https://www.openssl.org/)*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSL 是一个开源软件库，实现了安全套接字层（SSL）和传输层安全性（TLS）协议，以及通用的加密原语。OpenSSL 在 Apache 风格的许可证下发布，广泛应用于商业和非商业应用程序。该库提供了丰富的功能，供用户操作
    X.509 证书，无论是解析现有证书还是生成新证书。你可以在*[https://www.openssl.org/](https://www.openssl.org/)*找到有关该项目的信息。
- en: '***The dbx Database***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***dbx 数据库***'
- en: In contrast to `db`, the `dbx` database contains certificates of public keys
    and hashes of UEFI executables that are *prohibited* from executing at boot time.
    This database is also referred to as the *Revoked Signature Database*, and it
    explicitly lists images that will fail Secure Boot verification, preventing execution
    of a module with a known vulnerability that may compromise the security of the
    whole platform.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与`db`数据库不同，`dbx`数据库包含公钥证书和 UEFI 可执行文件的哈希值，这些文件在启动时被*禁止*执行。这个数据库也被称为*撤销签名数据库*，它明确列出了将无法通过安全启动验证的镜像，防止已知漏洞的模块执行，从而保护整个平台的安全。
- en: We’ll explore the contents of the `dbx` database the same way we did for the
    `db` signature database. Among the folders generated when you run the Chipsec
    tool, you’ll find the folder *efi_variables.dir*, which should contain a subfolder
    with a name beginning *dbx_D719B2CB-3D3A-4596-A3BC-DAD00E67656f*. This folder
    contains certificates and hashes of forbidden UEFI images. In our case, the folder
    contains only 78 hashes and no certificates, as shown in [Figure 17-4](ch17.xhtml#ch17fig04).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与`db`签名数据库相同的方式探讨`dbx`数据库的内容。当你运行 Chipsec 工具时，会生成一些文件夹，在这些文件夹中，你会找到名为*efi_variables.dir*的文件夹，该文件夹下应该包含一个以*dbx_D719B2CB-3D3A-4596-A3BC-DAD00E67656f*开头的子文件夹。这个文件夹包含被禁止的
    UEFI 镜像的证书和哈希值。在我们的案例中，文件夹仅包含 78 个哈希值，而没有证书，如[图17-4](ch17.xhtml#ch17fig04)所示。
- en: '![image](../images/17fig04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig04.jpg)'
- en: '*Figure 17-4: Contents of the `dbx` database (the revoked signature database)
    UEFI variable*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-4：`dbx`数据库（撤销签名数据库）UEFI 变量的内容*'
- en: '[Figure 17-5](ch17.xhtml#ch17fig05) shows the image signature verification
    algorithm using both the `db` and `dbx` databases.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17-5](ch17.xhtml#ch17fig05)展示了使用`db`和`dbx`数据库的镜像签名验证算法。'
- en: '![image](../images/17fig05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig05.jpg)'
- en: '*Figure 17-5: The UEFI Secure Boot image verification algorithm*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-5：UEFI 安全启动镜像验证算法*'
- en: From this figure, you can see that an UEFI executable passes authentication
    only when its hash or signature certificate is trusted per the `db` database and
    when it is not listed in the `dbx` database. Otherwise, the image fails the Secure
    Boot integrity check.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图中，你可以看到，只有当 UEFI 可执行文件的哈希或签名证书在`db`数据库中被信任且未列在`dbx`数据库中时，它才会通过认证。否则，该映像将无法通过
    Secure Boot 的完整性检查。
- en: '***Time-Based Authentication***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于时间的认证***'
- en: In addition to the `db` and `dbx` databases, Secure Boot uses two other databases,
    called `dbt` and `dbr`. The first, `dbr`, contains public key certificates used
    to verify the signatures of the OS recovery loader. We won’t discuss it much.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`db`和`dbx`数据库，Secure Boot 还使用另外两个数据库，分别叫做`dbt`和`dbr`。第一个，`dbr`，包含用于验证操作系统恢复加载程序签名的公钥证书，我们不再深入讨论。
- en: The second, `dbt`, contains timestamping certificates used to validate the timestamp
    of a UEFI executable’s digital signature, enabling time-based authentication (TBAWS)
    in Secure Boot. (You saw TBAWS earlier in this chapter when we looked at the attributes
    of UEFI variables.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`dbt`，包含用于验证 UEFI 可执行文件数字签名时间戳的时间戳证书，从而实现 Secure Boot 中的基于时间的认证（TBAWS）。(你在本章早些时候查看
    UEFI 变量的属性时，已经见过 TBAWS。)
- en: The digital signature of a UEFI executable sometimes contains a timestamp issued
    by the *Time Stamping Authority (TSA)* service. The signature’s timestamp reflects
    the time at which the signature was generated. By comparing the signature timestamp
    and the expiration timestamp of the signing key, Secure Boot determines whether
    the signature was generated before or after the signing key expired. Generally,
    the expiration date of the signing key is the date after which the signing key
    is considered compromised. As a result, the timestamp of the signature allows
    Secure Boot to verify that the signature was generated at a moment when the signing
    key wasn’t compromised, ensuring that the signature is legitimate. In this way,
    time-based authentication reduces the complexity of PKI when it comes to Secure
    Boot `db` certificates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 可执行文件的数字签名有时包含由*时间戳认证机构（TSA）*服务颁发的时间戳。该签名的时间戳反映了签名生成的时间。通过比较签名时间戳与签名密钥的过期时间戳，Secure
    Boot 可以确定签名是生成在签名密钥过期之前还是之后。通常，签名密钥的过期日期是指签名密钥被认为已被泄露的日期。因此，签名的时间戳使得 Secure Boot
    能够验证签名是在签名密钥未被泄露的时刻生成的，从而确保签名的合法性。通过这种方式，基于时间的认证减少了 PKI 在 Secure Boot `db` 证书中的复杂性。
- en: Time-based authentication also allows you to avoid re-signing the same UEFI
    images. The timestamp of the signature proves to Secure Boot that a UEFI image
    was signed before the corresponding signing key expired or was revoked. As a result,
    the signature remains valid even after the signing key is expired, since it was
    created when the signing key was still valid and not compromised.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于时间的认证还允许你避免重新签名相同的 UEFI 映像。签名的时间戳向 Secure Boot 证明，某个 UEFI 映像是在相应签名密钥过期或被撤销之前签署的。因此，即使签名密钥过期，签名仍然有效，因为它是在签名密钥仍然有效且未被泄露时创建的。
- en: '***Secure Boot Keys***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Secure Boot 密钥***'
- en: Now that you’ve seen where Secure Boot obtains information on trusted and revoked
    public key certificates, let’s talk about how these databases are stored and protected
    from unauthorized modification. After all, by modifying the `db` database, an
    attacker could easily bypass Secure Boot checks by injecting a malicious certificate
    and replacing the OS bootloader with a rogue bootloader signed with a private
    key corresponding to the malicious certificate. Since the malicious certificate
    is in the `db` signature database, Secure Boot would allow the rogue bootloader
    to run.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Secure Boot 如何获取受信任和撤销的公钥证书信息，让我们来谈谈这些数据库是如何存储并防止未经授权的修改的。毕竟，通过修改`db`数据库，攻击者可以轻松绕过
    Secure Boot 检查，注入恶意证书，并用与恶意证书对应的私钥签名的流氓引导程序替换操作系统引导加载程序。由于恶意证书已经存在于`db`签名数据库中，Secure
    Boot 将允许流氓引导程序运行。
- en: So, to protect the `db` and `dbx` databases from unauthorized modification,
    the platform or OS system vendor must sign the databases. When the UEFI firmware
    goes to read the content of these databases, it first authenticates them by verifying
    their digital signature with a public key called the *key exchange key (KEK)*.
    It then authenticates each KEK with a second key called the *platform key (PK)*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了防止 `db` 和 `dbx` 数据库遭受未经授权的修改，平台或操作系统供应商必须对这些数据库进行签名。当 UEFI 固件读取这些数据库的内容时，它首先通过验证数字签名来认证它们，验证的过程使用了一个称为
    *密钥交换密钥（KEK）* 的公钥。然后，它使用第二个密钥，称为 *平台密钥（PK）*，来认证每个 KEK。
- en: '**Key Exchange Keys**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密钥交换密钥**'
- en: As with the `db` and `dbx` databases, the list of public KEKs is stored in an
    NVRAM UEFI variable. We’ll explore the content of the `KEK` variable using the
    results of our previous execution of the `chipsec` command. Open the directory
    containing the results, and you should see a subfolder labeled something like
    *KEK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C*, which contains certificates of public
    KEKs ([Figure 17-6](ch17.xhtml#ch17fig06)). This UEFI variable is authenticated
    as well, as you’ll see next.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `db` 和 `dbx` 数据库一样，公钥 KEK 的列表也存储在 NVRAM UEFI 变量中。我们将使用之前执行的 `chipsec` 命令的结果来探索
    `KEK` 变量的内容。打开包含结果的目录，你应该会看到一个名为 *KEK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C* 的子文件夹，里面包含公钥
    KEK 的证书（见 [图 17-6](ch17.xhtml#ch17fig06)）。这个 UEFI 变量也需要进行认证，正如你接下来会看到的那样。
- en: '![image](../images/17fig06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig06.jpg)'
- en: '*Figure 17-6: Contents of the `KEK` UEFI variable*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-6：`KEK` UEFI 变量的内容*'
- en: Only the owner of the private key corresponding to any of these certificates
    can modify the contents of the `db` and `dbx` databases. In this example, we have
    only two KEK certificates, by Microsoft and Lenovo, as indicated in [Table 17-2](ch17.xhtml#ch17tab02).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有对应这些证书中任何一个的私钥所有者才能修改 `db` 和 `dbx` 数据库的内容。在这个例子中，我们只有两个 KEK 证书，分别来自 Microsoft
    和 Lenovo，如 [表 17-2](ch17.xhtml#ch17tab02) 所示。
- en: '**Table 17-2:** Certificates in the KEK UEFI Variable'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 17-2：KEK UEFI 变量中的证书**'
- en: '| **Filename** | **Issued to** | **Issued by** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **文件名** | **发放给** | **由...发放** |'
- en: '| --- | --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-00.bin* | Lenovo Ltd. KEK CA 2012
    | Lenovo Ltd. KEK CA 2012 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| *X509-7FACC7B6-127F-4E9C-9C5D-080F98994345-00.bin* | 联想有限公司 KEK CA 2012 |
    联想有限公司 KEK CA 2012 |'
- en: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | Microsoft Corporation
    KEK CA 2011 | Microsoft Corporation Third-Party Marketplace Root |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| *X509-77FA9ABD-0359-4D32-BD60-28F4E78F784B-01.bin* | 微软公司 KEK CA 2011 | 微软公司第三方市场根证书
    |'
- en: You can discover the owners of the private keys corresponding to your system’s
    KEK certificates by dumping the `KEK` variable and executing the `openssl` command
    we used earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过转储 `KEK` 变量并执行我们之前使用的 `openssl` 命令，来发现与你系统的 KEK 证书相对应的私钥所有者。
- en: '**Platform Key**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**平台密钥**'
- en: The PK is the last signing key in the PKI key hierarchy of Secure Boot. As you
    might have guessed, this key is used to authenticate KEKs by signing the `KEK`
    UEFI variable. According to the UEFI specification, each platform has a single
    PK. Usually, this key corresponds to the platform manufacturer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PK 是安全启动中 PKI 密钥层级的最后一个签名密钥。正如你可能已经猜到的，这个密钥用于通过签名 `KEK` UEFI 变量来认证 KEK。根据 UEFI
    规范，每个平台都有一个唯一的 PK。通常，这个密钥对应于平台的制造商。
- en: Return to the *PK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C* subfolder of *efi_variables.dir*
    that was created when you executed `chipsec`. There, you can find the certificate
    of the public PK. Your certificate will correspond to your platform. So, since
    we used the Lenovo Thinkpad T540p platform, we would expect our PK certificate
    to correspond to Lenovo (see [Figure 17-7](ch17.xhtml#ch17fig07)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到你执行 `chipsec` 时创建的 *efi_variables.dir* 文件夹中的 *PK_8BE4DF61-93CA-11D2-AA0D-00E098032B8C*
    子文件夹。在那里，你可以找到公钥 PK 的证书。你的证书将对应于你的平台。因此，既然我们使用了 Lenovo Thinkpad T540p 平台，我们可以预期我们的
    PK 证书会对应于 Lenovo（见 [图 17-7](ch17.xhtml#ch17fig07)）。
- en: '![image](../images/17fig07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig07.jpg)'
- en: '*Figure 17-7: The PK certificate*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 17-7：PK 证书*'
- en: You can see that ours was indeed issued by Lenovo. The `PK` UEFI variable is
    also authenticated, and every update of the variable should be signed with the
    corresponding private key. In other words, if the platform owner (or the platform
    manufacturer, in UEFI terminology) wants to update the `PK` variable with a new
    certificate, the buffer with the new certificate should be signed with the private
    key that corresponds to the current certificate stored in the `PK` variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '***UEFI Secure Boot: The Complete Picture***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’ve explored the complete hierarchy of the PKI infrastructure used
    in UEFI Secure Boot, let’s put everything together to see the whole picture, shown
    in [Figure 17-8](ch17.xhtml#ch17fig08).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-8: UEFI Secure Boot verification flow*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the figure, you can see that the root of trust (the components
    that UEFI Secure Boot inherently trusts, upon which it bases all of its future
    verification) is the platform initialization firmware and the platform key. The
    platform initialization firmware is the very first piece of code executed when
    the CPU comes out of a reset, and the UEFI Secure Boot implicitly trusts this
    code. If an attacker compromises the PI firmware, the whole chain of trust enforced
    by Secure Boot is broken. In that case, the attacker can patch any UEFI module
    that implements the Secure Boot image verification routines so it always returns
    a success and, as a result, allows every UEFI image supplied to pass authentication.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: That’s why the Secure Boot trust model assumes you’ve correctly implemented
    the Firmware Secure Update mechanism, which requires every update of the firmware
    to be signed with the proper signing key (which must be different from the PK).
    That way, only authorized updates of PI firmware take place, and the root of trust
    remains uncompromised.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to see that this trust model does not protect against physical attackers,
    who can physically reprogram the SPI flash with a malicious firmware image and
    compromise the PI firmware. We’ll talk about protecting firmware against physical
    attacks in “[Protecting Secure Boot with Verified and Measured Boot](ch17.xhtml#ch17lev1sec4)”
    on [page 338](ch17.xhtml#page_338).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: At the top of [Figure 17-8](ch17.xhtml#ch17fig08), you can see the platform
    key provided by the platform manufacturer has the same level of inherent trust
    as PI firmware. This key is used to establish trust between the PI firmware and
    the platform manufacturer. Once the platform key is provided, the platform firmware
    allows the manufacturer to update the KEKs and, as a result, control which images
    pass Secure Boot checks and which don’t.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: One level below, you see the KEKs that establish trust between the PI firmware
    and the OS running on the platform. Once the platform KEK is provisioned in the
    UEFI variable, the OS is able to specify which images can pass Secure Boot check.
    For example, the OS vendor can use the KEK to allow the UEFI firmware to execute
    the OS loader.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一级，你可以看到用于建立平台上 PI 固件与操作系统之间信任的 KEK。一旦平台的 KEK 被写入 UEFI 变量中，操作系统就能够指定哪些镜像可以通过
    Secure Boot 检查。例如，操作系统厂商可以使用 KEK 来允许 UEFI 固件执行操作系统加载程序。
- en: At the bottom of the trust model, you see the `db` and `dbx` databases signed
    with KEKs, which contain hashes of images and public key certificates that are
    used directly in integrity checks of executables enforced by Secure Boot.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在信任模型的底层，你可以看到使用 KEK 签名的 `db` 和 `dbx` 数据库，这些数据库包含镜像的哈希值和公钥证书，它们直接用于 Secure Boot
    强制执行的可执行文件完整性检查。
- en: '***Secure Boot Policy***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Secure Boot 策略***'
- en: By itself, Secure Boot uses the `PK`, `KEK`, `db`, `dbx`, and `dbt` variables
    to tell the platform whether or not an executable image is trusted, as you’ve
    seen. However, the way in which the result of Secure Boot verification is interpreted
    (in other words, whether or not to execute an image) largely depends on the policy
    in place.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，Secure Boot 使用 `PK`、`KEK`、`db`、`dbx` 和 `dbt` 变量来告诉平台一个可执行镜像是否可信，如你所见。然而，Secure
    Boot 验证结果的解释方式（换句话说，是否执行镜像）在很大程度上取决于所实施的策略。
- en: We’ve already mentioned Secure Boot policies a few times in this chapter without
    getting into the details of what one actually is. So, let’s take a closer look
    at this concept.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中多次提到 Secure Boot 策略，但尚未深入探讨它究竟是什么。所以，让我们更详细地了解这个概念。
- en: In essence, a Secure Boot policy dictates which actions the platform firmware
    should take after it performs image authentication. The firmware might execute
    the image, deny image execution, defer image execution, or ask a user to make
    the decision.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，Secure Boot 策略决定了平台固件在执行镜像认证后应该采取的行动。固件可能会执行该镜像、拒绝镜像执行、推迟镜像执行，或要求用户做出决定。
- en: Secure Boot policy isn’t rigorously defined in the UEFI specification and, therefore,
    is specific to each implementation. In particular, policies can vary between implementations
    of UEFI firmware by different vendors. In this section, we’ll explore some Secure
    Boot policy elements implemented in Intel’s EDK2 source code, which we used in
    [Chapter 15](ch15.xhtml#ch15). Download or clone the EDK2 source code now from
    the repository at *[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*
    if you haven’t already.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Secure Boot 策略在 UEFI 规范中并没有严格定义，因此它是特定于每个实现的。特别是，不同厂商的 UEFI 固件实现之间的策略可能有所不同。在本节中，我们将探讨一些在英特尔
    EDK2 源代码中实现的 Secure Boot 策略元素，这些源代码在 [第15章](ch15.xhtml#ch15) 中已经使用。如果你还没有下载或克隆
    EDK2 源代码，请立即从 *[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*
    仓库中获取。
- en: One of the elements that Secure Boot, as implemented in EDK2, takes into account
    is the origin of the executable images being authenticated. The images could come
    from different storage devices, some of which may be inherently trusted. For instance,
    if the image is loaded from the SPI flash, meaning it’s located on the same storage
    device as the rest of UEFI firmware, then the platform might trust it automatically.
    (However, if an attacker is able to alter the image on SPI flash, they could also
    tamper with the rest of the firmware and disable Secure Boot completely. We’ll
    discuss this attack later in “[Patching PI Firmware to Disable Secure Boot](ch17.xhtml#ch17lev2sec10)”
    on [page 335](ch17.xhtml#page_335).) On the other hand, if the image is loaded
    from an external PCI device—for example, an Option ROM, special firmware loaded
    from external peripheral devices in the preboot environment—then it would be treated
    as untrusted and subject to a Secure Boot check.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EDK2 中实现的 Secure Boot 考虑的因素之一是被认证的可执行镜像的来源。这些镜像可能来自不同的存储设备，其中一些设备可能本身就被信任。例如，如果镜像是从
    SPI 闪存加载的，即它与其余的 UEFI 固件位于同一存储设备上，那么平台可能会自动信任它。（然而，如果攻击者能够修改 SPI 闪存上的镜像，他们也可能篡改其他固件并完全禁用
    Secure Boot。我们将在 “[修补 PI 固件以禁用 Secure Boot](ch17.xhtml#ch17lev2sec10)” [第335页](ch17.xhtml#page_335)
    中讨论这一攻击。）另一方面，如果镜像是从外部 PCI 设备加载的——例如，Option ROM 或从外部外设设备加载的特殊固件——则它会被视为不可信，并需经过
    Secure Boot 检查。
- en: Here, we outline the definitions of some of the policies that determine how
    to process images with respect to their origin. You can find these policies in
    the *SecurityPkg\SecurityPkg.dec* file located in the EDK2 repository. Each policy
    assigns a default value to the images that meet the criteria.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们概述了一些决定如何处理与其来源相关的图像的策略定义。你可以在EDK2代码库中的*SecurityPkg\SecurityPkg.dec*文件中找到这些策略。每个策略都会为符合条件的图像分配一个默认值。
- en: 'PcdOptionRomImageVerificationPolicy Defines the verification policy for images
    loaded as Option ROMs, like those from PCI devices (default value: 0x00000004).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PcdOptionRomImageVerificationPolicy 定义了作为选项ROM加载的图像的验证策略，例如来自PCI设备的图像（默认值：0x00000004）。
- en: 'PcdRemovableMediaImageVerificationPolicy Defines the verification policy for
    images located on removable media, which includes CD-ROM, USB, and network (default
    value: 0x00000004).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PcdRemovableMediaImageVerificationPolicy 定义了位于可移动介质上的图像的验证策略，包括CD-ROM、USB和网络（默认值：0x00000004）。
- en: 'PcdFixedMediaImageVerificationPolicy Defines the verification policy for images
    located on fixed media devices, such as hard disks (default value: 0x00000004).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PcdFixedMediaImageVerificationPolicy 定义了位于固定介质设备（如硬盘）上的图像的验证策略（默认值：0x00000004）。
- en: 'In addition to these policies, there are two more policies that aren’t explicitly
    defined in the *SecurityPkg\SecurityPkg.dec* file but are used in EDK2 Secure
    Boot implementation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些策略外，还有两种策略并未在*SecurityPkg\SecurityPkg.dec*文件中明确定义，但在EDK2 Secure Boot实现中使用：
- en: '**SPI flash ROM policy** Defines the verification policy for images located
    on SPI flash (default value: 0x00000000).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPI闪存ROM策略** 定义了位于SPI闪存上的图像的验证策略（默认值：0x00000000）。'
- en: '**Other origin** Defines the verification policy for any images located on
    devices other than those just described (default value: 0x00000004).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他来源** 定义了对于位于除前述设备外的任何设备上的图像的验证策略（默认值：0x00000004）。'
- en: '**NOTE**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Keep in mind that this isn’t a comprehensive list of Secure Boot policies
    used for image authentication. Different firmware vendors can modify or extend
    this list with their custom policies.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，这并不是用于图像认证的Secure Boot策略的完整列表。不同的固件厂商可以修改或扩展此列表，加入他们的自定义策略。*'
- en: 'Here are the descriptions of the default policy values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是默认策略值的描述：
- en: '**0x00000000** Always trust the image regardless of whether or not it’s signed
    and regardless of whether its hash is in the `db` or `dbx` database.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000000** 始终信任该图像，无论其是否已签名，也无论其哈希是否在`db`或`dbx`数据库中。'
- en: '**0x00000001** Never trust the image. Even images with valid signatures will
    be rejected.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000001** 永远不信任该图像。即使图像有有效签名，也会被拒绝。'
- en: '**0x00000002** Allow execution when there is a security violation. The image
    will be executed even if the signature cannot be verified or if its hash is blacklisted
    in the `dbx` database.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000002** 允许在存在安全违规时执行。当签名无法验证或其哈希在`dbx`数据库中被列入黑名单时，仍然会执行该图像。'
- en: '**0x00000003** Defer execution when there is a security violation. In this
    case, the image isn’t rejected immediately and is loaded in memory. However, its
    execution is postponed until its authentication status is reevaluated.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000003** 在存在安全违规时推迟执行。在这种情况下，图像不会立即被拒绝，而是被加载到内存中。然而，直到重新评估其认证状态后，其执行才会被推迟。'
- en: '**0x00000004** Deny execution when Secure Boot fails to authenticate the image
    using the `db` and `dbx` databases.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000004** 在Secure Boot无法使用`db`和`dbx`数据库验证图像时拒绝执行。'
- en: '**0x00000005** Query the user when there is a security violation. In this case,
    if Secure Boot fails to authenticate the image, an authorized user may make a
    decision about whether to trust the image. For example, the user may be shown
    a message prompt at boot time.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x00000005** 在存在安全违规时询问用户。在这种情况下，如果Secure Boot无法验证图像，授权用户可以决定是否信任该图像。例如，用户在启动时可能会看到一个提示消息。'
- en: From the Secure Boot policy definitions, you can see that all the images loaded
    from SPI flash are inherently trusted and aren’t subject to digital signature
    verification at all. In all other cases, the default value of 0x000000004 enforces
    signature verification and prohibits the execution of any unauthenticated code
    that comes as Option ROM or that is located on removable, fixed, or any other
    media.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从Secure Boot策略定义中，你可以看到，从SPI闪存加载的所有图像天生是可信的，根本不需要进行数字签名验证。在所有其他情况下，默认值0x000000004
    强制执行签名验证，并禁止执行任何未经认证的代码，无论该代码是作为选项ROM加载的，还是位于可移动、固定或任何其他介质上。
- en: '***Protection Against Bootkits Using Secure Boot***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Secure Boot防止Bootkit***'
- en: Now that you’ve seen how Secure Boot works, let’s take a look at a specific
    example of how it protects against bootkits that target the OS boot flow. We won’t
    discuss bootkits that target the MBR and VBR, since, as [Chapter 14](ch14.xhtml#ch14)
    explained, UEFI firmware no longer uses objects like the MBR and VBR (except in
    the UEFI compatibility mode), so traditional bootkits cannot compromise UEFI-based
    systems.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了安全启动（Secure Boot）的工作原理，我们来看看一个具体的例子，了解它如何保护操作系统启动流程免受启动病毒（bootkit）的攻击。我们不会讨论针对MBR和VBR的启动病毒，因为正如[第14章](ch14.xhtml#ch14)所解释的那样，UEFI固件不再使用像MBR和VBR这样的对象（除非在UEFI兼容模式下），因此传统的启动病毒无法危害基于UEFI的系统。
- en: 'As mentioned in [Chapter 15](ch15.xhtml#ch15), the DreamBoot bootkit was the
    first public proof-of-concept bootkit targeting UEFI-based systems. On a UEFI
    system without Secure Boot in place, this bootkit works as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第15章](ch15.xhtml#ch15)所提到的，DreamBoot启动病毒是第一个公开的、针对UEFI系统的启动病毒概念验证。对于没有启用安全启动的UEFI系统，该启动病毒的工作方式如下：
- en: The author of the bootkit replaces the original UEFI Windows bootloader, *bootmgfw.efi*,
    with the malicious bootloader, *bootx64.efi*, on the boot partition.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动病毒的作者将原始的UEFI Windows启动加载器 *bootmgfw.efi* 替换为恶意启动加载器 *bootx64.efi*，并将其放置在启动分区中。
- en: The malicious bootloader loads the original *bootmgfw.efi*, patches it to get
    control of the Windows loader *winload.efi*, and executes it, as demonstrated
    in [Figure 17-9](ch17.xhtml#ch17fig09).![image](../images/17fig09.jpg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意启动加载器会加载原始的 *bootmgfw.efi*，并对其进行修补以控制Windows加载程序 *winload.efi*，然后执行它，正如在[图17-9](ch17.xhtml#ch17fig09)中所展示的那样。![image](../images/17fig09.jpg)
- en: '*Figure 17-9: The flow of the DreamBoot attack against the OS bootloader*'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图17-9：DreamBoot攻击操作系统启动加载器的流程*'
- en: The malicious code continues patching the system modules until it reaches the
    kernel of the operating system, bypassing the kernel protection mechanisms (such
    as the Kernel-Mode Code Signing Policy) intended to prevent unauthorized kernel-mode
    code execution.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恶意代码会继续修补系统模块，直到它达到操作系统的内核，绕过了旨在防止未授权内核模式代码执行的内核保护机制（例如内核模式代码签名策略）。
- en: This kind of attack is possible because, by default, the OS bootloader is not
    authenticated in the UEFI boot process. UEFI firmware obtains the location of
    the OS bootloader from a UEFI variable, which for Microsoft Windows platforms
    is located at *\EFI\Microsoft\Boot\bootmgfw.efi* on the boot partition. An attacker
    with system privileges can easily replace or alter the bootloader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击之所以可能发生，是因为默认情况下，操作系统启动加载器在UEFI启动过程中没有经过身份验证。UEFI固件通过UEFI变量获取操作系统启动加载器的位置，对于Microsoft
    Windows平台来说，它位于启动分区的 *\EFI\Microsoft\Boot\bootmgfw.efi*。具有系统权限的攻击者可以轻松地替换或篡改启动加载器。
- en: However, when Secure Boot is enabled, this attack is no longer possible. Since
    Secure Boot verifies the integrity of UEFI images executed at boot time, and the
    OS bootloader is one of the executables verified during boot, Secure Boot will
    check the bootloader’s signature against the `db` and `dbx` databases. The malicious
    bootloader isn’t signed with a proper signing key, so it will potentially fail
    the checks and will not execute (depending on the boot policy). This is one way
    in which Secure Boot protects against bootkits.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当启用安全启动时，这种攻击就不再可能。由于安全启动会验证启动时执行的UEFI镜像的完整性，而操作系统启动加载器是启动时验证的可执行文件之一，安全启动将会检查启动加载器的签名是否符合
    `db` 和 `dbx` 数据库中的记录。恶意启动加载器没有使用正确的签名密钥，因此它可能会在检查时失败并无法执行（这取决于启动策略）。这是安全启动防止启动病毒的一种方式。
- en: '**Attacking Secure Boot**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击安全启动**'
- en: Now let’s look at some attacks that can succeed against UEFI Secure Boot. Because
    Secure Boot relies on PI firmware and PKs as the root of trust, if either one
    of these components is compromised, the whole chain of Secure Boot checks becomes
    useless. We’ll look at both bootkits and rootkits capable of undermining Secure
    Boot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些能够成功攻击UEFI安全启动的攻击方式。由于安全启动依赖PI固件和PK作为信任的根源，如果其中任何一个组件被破坏，整个安全启动检查链就会失效。我们将研究一些能够破坏安全启动的启动病毒和根病毒（rootkit）。
- en: The class of bootkits we’ll look at here relies predominantly on modifications
    of SPI flash content. In modern computer systems, SPI flash is often used as primary
    firmware storage. Almost every laptop and desktop computer will store UEFI firmware
    in flash memory that is accessed through an SPI controller.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论的启动病毒主要依赖于对SPI闪存内容的修改。在现代计算机系统中，SPI闪存通常用作主要固件存储几乎每台笔记本电脑和台式计算机都会将UEFI固件存储在通过SPI控制器访问的闪存中。
- en: In [Chapter 15](ch15.xhtml#ch15), we presented various attacks that install
    persistent UEFI rootkits on flash firmware, so we won’t go into those details
    again here, though those same attacks (SMI handler issues, S3 boot script, BIOS
    write protection, and so on) may be leveraged against Secure Boot. For the attacks
    in this section, we’ll assume the attacker is already able to modify the contents
    of flash memory containing UEFI firmware. Let’s see what they can do next!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch15.xhtml#ch15)，我们介绍了各种将持久性UEFI rootkit安装到闪存固件中的攻击，因此在这里我们不再详细讨论这些内容，尽管相同的攻击（SMI处理程序问题、S3启动脚本、BIOS写保护等）可能会被用于攻击安全启动。本节中的攻击假设攻击者已经能够修改包含UEFI固件的闪存内容。接下来我们来看看他们可以做些什么！
- en: '***Patching PI Firmware to Disable Secure Boot***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***修补PI固件以禁用安全启动***'
- en: Once an attacker is able to modify the contents of SPI flash, they can easily
    disable Secure Boot by patching the PI firmware. You saw in [Figure 17-8](ch17.xhtml#ch17fig08)
    that UEFI Secure Boot is anchored in the PI firmware, so if we alter the modules
    of the PI firmware that implement Secure Boot, we can effectively disable its
    functionality.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者能够修改SPI闪存的内容，他们可以通过修补PI固件轻松禁用安全启动。你在[图17-8](ch17.xhtml#ch17fig08)中看到，UEFI安全启动是基于PI固件的，因此如果我们修改实现安全启动的PI固件模块，就能有效地禁用其功能。
- en: To explore this process, we’ll once again use Intel’s EDK2 source code (*[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)*)
    as an example implementation of UEFI. You’ll find out where the Secure Boot verification
    functionality is implemented and how you might corrupt it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个过程，我们将再次使用Intel的EDK2源代码（*[https://github.com/tianocore/edk2/](https://github.com/tianocore/edk2/)）作为UEFI实现的示例。你将了解安全启动验证功能的实现位置，以及如何可能会破坏它。
- en: Inside the *SecurityPkg/Library/DxeImageVerificationLib* folder in the repository,
    you’ll find the *DxeImageVerificationLib.c* source code file that implements the
    code integrity verification functionality. Specifically, this file implements
    the `DxeImageVerificationHandler` routine, which decides whether a UEFI executable
    is trusted and should be executed or whether it fails verification. [Listing 17-1](ch17.xhtml#ch17list01)
    shows the prototype of the routine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中的*SecurityPkg/Library/DxeImageVerificationLib*文件夹内，你会找到实现代码完整性验证功能的*DxeImageVerificationLib.c*源代码文件。具体来说，这个文件实现了`DxeImageVerificationHandler`例程，用于决定一个UEFI可执行文件是否被信任并应该被执行，或者它是否未通过验证。[列表17-1](ch17.xhtml#ch17list01)展示了该例程的原型。
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 17-1: Definition of the `DxeImageVerificationHandler` routine*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-1：`DxeImageVerificationHandler`例程的定义*'
- en: As a first parameter, the routine receives the `AuthenticationStatus` variable
    ➊, which indicates whether or not the image is signed. The `File` argument ➋ is
    a pointer to the device path of the file being dispatched. The `FileBuffer` ➌
    and `FileSize` ➍ arguments provide a pointer to the UEFI image and its size for
    verification.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个参数，例程接收`AuthenticationStatus`变量 ➊，它指示镜像是否已签名。`File`参数 ➋是指向正在分派的文件的设备路径的指针。`FileBuffer`
    ➌ 和 `FileSize` ➍ 参数提供指向UEFI镜像及其大小的指针，以便进行验证。
- en: Finally, `BootPolicy` ➎ is a parameter indicating whether the request to load
    the image being authenticated came from the UEFI boot manager and is a boot selection
    (meaning the image is a selected OS bootloader). We discussed the UEFI boot manager
    in more detail in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`BootPolicy` ➎是一个参数，指示请求加载正在认证的镜像是否来自UEFI引导管理器，并且是一个启动选择（意味着该镜像是选定的操作系统引导加载程序）。我们在[第14章](ch14.xhtml#ch14)中更详细地讨论了UEFI引导管理器。
- en: 'Upon completion of the verification, this routine returns one of the following
    values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证完成后，该例程返回以下值之一：
- en: EFI_SUCCESS Authentication has successfully passed and the image will be executed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_SUCCESS 认证成功，镜像将被执行。
- en: EFI_ACCESS_DENIED The image is not authenticated because the platform policy
    has dictated that the firmware may not use this image file. This may happen if
    the firmware attempts to load an image from a removable medium and the platform
    policy prohibits execution from removable media at boot time, regardless of whether
    or not they are signed. In this case, this routine will immediately return `EFI_ACCESS_DENIED`
    without any signature verification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: EFI_ACCESS_DENIED 该镜像未通过认证，因为平台策略已规定固件不能使用该镜像文件。如果固件尝试从可移动介质加载镜像，而平台策略禁止在启动时从可移动介质执行，无论这些镜像是否已签名，都可能会发生这种情况。在这种情况下，该例程将立即返回`EFI_ACCESS_DENIED`，而不会进行任何签名验证。
- en: EFI_SECURITY_VIOLATION Authentication failed either because Secure Boot was
    unable to verify the image’s digital signature or because a hash value of the
    executable was found in the database of prohibited images (`dbx`). This return
    value indicates that the image is not trusted and the platform should follow the
    Secure Boot policy to determine whether the image may be executed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: EFI_OUT_RESOURCE An error occurred during the verification process due to a
    lack of system resources (usually, not enough memory) to perform image authentication.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To bypass Secure Boot checks, an attacker with write access to the SPI flash
    can patch this routine to always return the `EFI_SUCCESS` value for whatever executable
    it takes as input. As a result, all the UEFI images will pass authentication regardless
    of whether they are signed or not.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***Modifying the UEFI Variables to Bypass Security Checks***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to attack the Secure Boot implementation is to modify the UEFI NVRAM
    variables. As we discussed earlier in this chapter, Secure Boot uses certain variables
    to store its configuration parameters, details like whether Secure Boot is enabled,
    the PKs and KEKs, the signature databases, and the platform policies. If an attacker
    can modify these variables, they can disable or bypass Secure Boot verification
    checks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, most implementations of Secure Boot will store UEFI NVRAM variables
    in SPI flash memory alongside the system firmware. Even though these variables
    are authenticated, and changing their values from the kernel mode by using the
    UEFI API requires a corresponding private key, an attacker capable of writing
    to SPI flash could change their content.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Once an attacker has access to the UEFI NVRAM variables, they could, for example,
    tamper with `PK`, `KEK`, `db`, and `dbx` to add custom malicious certificates,
    which would allow a malicious module to bypass security checks. Another option
    would be to add the hash of the malicious file to the `db` database and remove
    it from the `dbx` database (in the case that the hash was originally in the `dbx`
    database). As shown in [Figure 17-10](ch17.xhtml#ch17fig10), by changing the `PK`
    variable to include the attacker’s public key certificate, the attacker is able
    to add and remove KEKs from the `KEK` UEFI variable, which, in turn, gives them
    control over the `db` and `dbx` signature databases, breaking Secure Boot protection.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig10.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-10: Attack against the UEFI Secure Boot chain of trust*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As a third option, instead of changing the PK and compromising the underlying
    PKI hierarchy, an attacker could simply corrupt the PK in the UEFI variable. In
    order to work, Secure Boot requires a valid PK enrolled into the platform firmware;
    otherwise, protection is disabled.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in learning more about these attacks, the following conference
    papers contain comprehensive analyses of UEFI Secure Boot technology:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Corey Kallenberg et al., “Setup for Failure: Defeating Secure Boot,” LegbaCore,
    *[https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf](https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf)*.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Corey Kallenberg 等人，"Setup for Failure: Defeating Secure Boot"，LegbaCore，*
    [https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf](https://papers.put.as/papers/firmware/2014/SetupForFailure-syscan-v4.pdf)*。'
- en: Yuriy Bulygin et al., “Summary of Attacks Against BIOS and Secure Boot,” Intel
    Security, *[http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf](http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf)*.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yuriy Bulygin 等人，"Summary of Attacks Against BIOS and Secure Boot"，英特尔安全，* [http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf](http://www.c7zero.info/stuff/DEFCON22-BIOSAttacks.pdf)*。
- en: '**Protecting Secure Boot with Verified and Measured Boot**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过验证启动和度量启动保护安全启动**'
- en: As we’ve just discussed, Secure Boot alone is not capable of protecting against
    attacks that involve changes in platform firmware. So is there any protection
    for Secure Boot technology itself? The answer is yes. In this section, we’ll focus
    on security technologies intended to protect system firmware against unauthorized
    modifications—namely, Verified and Measured Boot. *Verified Boot* checks that
    the platform firmware hasn’t been altered or modified, while *Measured Boot* computes
    cryptographic hashes of certain components involved in the boot process and stores
    them in Trusted Platform Module Platform Configuration Registers, or TPM PCRs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的，单靠安全启动无法防范涉及平台固件变化的攻击。那么，是否有任何保护措施来保护安全启动技术本身呢？答案是肯定的。在本节中，我们将重点介绍旨在保护系统固件免受未经授权修改的安全技术——即验证启动和度量启动。*验证启动*检查平台固件是否未被篡改或修改，而*度量启动*计算启动过程中涉及的某些组件的加密哈希，并将其存储在受信任平台模块平台配置寄存器（TPM
    PCR）中。
- en: Verified Boot and Measured Boot function independently, and it’s possible to
    have platforms with only one of them enabled, or with both. However, both Verified
    Boot and Measured Boot are part of the same chain of trust (as shown in [Figure
    17-11](ch17.xhtml#ch17fig11)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 验证启动和度量启动是独立运作的，因此有可能只启用其中一个，或同时启用两者。然而，验证启动和度量启动都属于同一信任链的一部分（如[图17-11](ch17.xhtml#ch17fig11)所示）。
- en: '![image](../images/17fig11.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/17fig11.jpg)'
- en: '*Figure 17-11: Verified and Measured Boot flow*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图17-11：验证启动和度量启动流程*'
- en: As you saw in [Figure 17-8](ch17.xhtml#ch17fig08), the PI firmware is the very
    first piece of code executed after the CPU comes out of reset. UEFI Secure Boot
    unconditionally trusts the PI firmware, so it makes sense that current attacks
    against Secure Boot rely on unauthorized modifications of it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图17-8](ch17.xhtml#ch17fig08)所示，PI固件是在CPU复位后执行的第一段代码。UEFI安全启动无条件信任PI固件，因此当前对安全启动的攻击依赖于对其的未经授权的修改，这一点是可以理解的。
- en: In order to protect against such attacks, the system needs a root of trust *outside*
    the PI firmware. This is where Verified and Measured Boot come into play. These
    processes execute protection mechanisms whose root of trust is anchored in the
    hardware. Moreover, they execute before the system firmware, which means they
    are able to both authenticate *and* measure it. We’ll discuss what measurement
    means in this context in a moment.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防范此类攻击，系统需要一个位于PI固件*之外*的信任根。这就是验证启动（Verified Boot）和度量启动（Measured Boot）发挥作用的地方。这些过程执行的保护机制，其信任根被锚定在硬件中。而且，它们在系统固件之前执行，这意味着它们既能认证*又能*度量系统固件。稍后我们将讨论在这个背景下“度量”意味着什么。
- en: '***Verified Boot***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***验证启动***'
- en: When a system with Verified Boot is powered on, the hardware logic launches
    the boot verification functionality that’s implemented in a boot ROM or microcode
    within the CPU. This logic is *immutable*, which means software can’t change it.
    Usually, Verified Boot executes a module to verify the integrity of the system,
    ensuring that the system will execute the authentic firmware without malicious
    modifications. To verify the firmware, Verified Boot relies on public key cryptography;
    like UEFI Secure Boot, it checks the digital signature of the platform firmware
    to ensure its authenticity. After it’s been successfully authenticated, the platform
    firmware is executed and proceeds to verify other firmware components (for example,
    the Option ROMs, DXE drivers, and OS bootloaders) to maintain the proper chain
    of trust. That’s the Verified portion of Verified and Measured Boot. Now for the
    Measured part.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '***Measured Boot***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Measured Boot works by measuring the platform firmware and OS bootloaders. This
    means it computes the cryptographic hashes of the components involved in the boot
    process. The hashes are stored in a set of TPM PCRs. The hash values themselves
    don’t tell you if the measured components are benign or malicious, but they do
    tell you whether the configuration and boot components have been changed at some
    point. If a boot component has been modified, its hash value will differ from
    the one computed over the original version of the boot component. Thus, Measured
    Boot will notice any modification of the boot component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Later, the system software can use the hashes in these TPM PCRs to ensure the
    system is running in a known good state without any malicious modifications. The
    system might also use these hashes for *remote attestation*, which is when a system
    tries to prove to another system that it’s in a trusted state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how Verified and Measured Boot work in general, let’s take
    a look at a couple implementations of it, starting with Intel BootGuard.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Intel BootGuard**'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intel BootGuard is Intel’s Verified and Measured Boot technology. [Figure 17-12](ch17.xhtml#ch17fig12)
    shows the boot flow on a platform with Intel BootGuard enabled.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig12.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-12: The Intel BootGuard flow*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: During initialization, before the CPU starts executing the first code located
    at the reset vector, it executes code from the boot ROM. This code performs the
    necessary initialization of the CPU state, then loads and executes the BootGuard
    *Authenticated Code Module (ACM)*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The ACM is a special type of module for performing security-sensitive operations
    and must be signed by Intel. Thus, the boot ROM code that loads the ACM performs
    mandatory signature verification to keep the module from running unless it’s signed
    by Intel. After successful signature verification, the ACM is executed in an isolated
    environment in order to prevent any malicious software from interfering with its
    execution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The BootGuard ACM implements Verified and Measured Boot functionality. This
    module loads the first-stage firmware loader, called the initial boot block (IBB),
    into memory and, depending on the boot policy in effect, verifies and/or measures
    it. The IBB is part of the firmware that contains code executed at the reset vector.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, at this point in the boot process there is no RAM. The memory
    controller hasn’t yet been initialized, and RAM isn’t accessible. However, the
    CPU configures its last-level cache so that it can be used as RAM by putting it
    in Cache-as-RAM mode until the point in the boot process when the BIOS memory
    reference code can configure the memory controller and discover RAM.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'The ACM transfers control to the IBB once the IBB is successfully verified
    and/or measured. If the IBB fails verification, the ACM behaves according to whatever
    boot policy is in effect: the system may be shut down immediately or allow firmware
    recovery after a certain timeout.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The IBB then loads the rest of the UEFI firmware from SPI flash and verifies
    and/or measures it. Once the IBB receives control, Intel BootGuard is no longer
    responsible for maintaining the proper chain of trust, since its purpose is simply
    to verify and measure the IBB. The IBB is responsible for continuing the chain
    of trust up the point when UEFI Secure Boot takes over the verification and measuring
    of firmware images.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding the ACM***'
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at the implementation details of Intel BootGuard technology for
    desktop platforms, starting with the ACM. Since the ACM is one of the first Intel
    BootGuard components executed when the system is powered up, the first question
    is: how does the CPU find the ACM when it is powered on?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The exact location of the ACM is provided in a special data structure called
    the *Firmware Interface Table (FIT)*, stored in the firmware image. The FIT is
    organized as an array of FIT entries, each describing the location of a specific
    object in the firmware, such as the ACM or microcode update files. [Figure 17-13](ch17.xhtml#ch17fig13)
    shows the layout of a FIT in system memory after reset.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig13.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-13: The FIT’s location in memory*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: When the CPU is powered on, it reads the address of the FIT from the memory
    location 0xFFFFFFC0 ➊. Since there’s no RAM yet, when the CPU posts a read memory
    transaction for the physical address 0xFFFFFFC0, the internal chipset logic recognizes
    that this address belongs to a special address range and, instead of sending this
    transaction to the memory controller, decodes it. Read memory transactions for
    the FIT table are forwarded to the SPI flash controller, which reads FIT from
    flash memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a closer look at this process by returning to the EDK2 repository.
    In the *IntelSiliconPkg/Include/IndustryStandard/* directory, you’ll find the
    *FirmwareInterfaceTable.h* header file, which contains some code definitions related
    to the FIT structure. The layout of FIT entries is shown in [Listing 17-2](ch17.xhtml#ch17list02).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 17-2: Layout of FIT entries*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, each FIT entry describes a certain object in the firmware image.
    The nature of each object is encoded in the FIT’s `Type` field. These objects
    could be microcode update files, a BootGuard’s ACM, or a BootGuard policy, for
    instance. The `Address` field ➊ and `Size` field ➋ provide the location of the
    object in memory: `Address` contains the physical address of the object, and `Size`
    defines the size expressed in `dword`s (4-byte values). The `C_V` field ➎ is the
    checksum valid field; if it’s set to `1`, the `Chksum` field ➏ contains a valid
    checksum of the object. The sum of all the bytes in the component modulo 0xFF
    and the value in the `Chksum` field must be zero. The `Version` field ➌ contains
    the version number of the component in binary-coded decimal format. For the FIT
    header entry, the value in this field will indicate the revision number of the
    FIT data structure.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The header *FirmwareInterfaceTable.h* contains values that the `Type` field
    ➍ can take. These type values are mostly undocumented, with little information
    available, but the definitions of FIT entry types are quite verbose, and you can
    deduce their meanings from the context. Here are the types relevant to BootGuard:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The `FIT_TYPE_00_HEADER` entry provides the total number of FIT entries in the
    FIT table in its `Size` field. Its address field contains a special 8-byte signature,
    `'_FIT_'` (there are three spaces after `_FIT_`).
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entry of type `FIT_TYPE_02_STARTUP_ACM` provides the location of the BootGuard
    ACM, which the boot ROM code parses to locate the ACM in system memory.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entries of types `FIT_TYPE_0C_BOOT_POLICY_MANIFEST` (BootGuard boot policy
    manifest) and `FIT_TYPE_0B_KEY_MANIFEST` (BootGuard key manifest) provide BootGuard
    with the boot policy that’s in effect and the configuration information, which
    we’ll discuss shortly in “[Configuring Intel BootGuard](ch17.xhtml#ch17lev2sec16)”
    on [page 343](ch17.xhtml#page_343).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that the Intel BootGuard boot policy and the UEFI Secure Boot policy
    are two different things. The first term refers to the boot policy used for the
    Verified and Measured Boot procedures. That is, Intel BootGuard boot policy is
    enforced by ACM and chipset logic, and it includes parameters like whether BootGuard
    should perform Verified and Measured Boot and what BootGuard should do in cases
    when it fails to authenticate the IBB. The second term refers to UEFI Secure Boot,
    discussed earlier in this chapter, and is entirely enforced by UEFI firmware.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploring FIT***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can explore some FIT entries in the firmware image using UEFITool, which
    we introduced in [Chapter 15](ch15.xhtml#ch15) (and which we’ll discuss more in
    [Chapter 19](ch19.xhtml#ch19)), and extract the ACM from the image, along with
    the boot policy and key manifests, for further analysis. This can be useful because
    the ACM can be used to hide malicious code. In the following example, we use a
    firmware image obtained from a system with Intel BootGuard technology enabled.
    ([Chapter 19](ch19.xhtml#ch19) provides information on how to acquire a firmware
    from the platform.)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: First, load the firmware image in UEFITool by selecting **File**▸**Open Image
    File**. After specifying the firmware image file to load, you’ll see a window
    like the one shown in [Figure 17-14](ch17.xhtml#ch17fig14).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig14.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-14: Browsing FIT in UEFITool*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In the lower half of the window, you can see the FIT tab that lists the entries.
    The `Type` column of the FIT tab displays the type of FIT entries. We are looking
    for FIT entries for the types BIOS ACM, BootGuard key manifest, and BootGuard
    Boot Policy. Using that information, we can locate the Intel BootGuard components
    in the firmware image and extract them for further analysis. In this particular
    example, FIT entry #6 indicates the location of the BIOS ACM; it starts at the
    address 0xfffc0000\. FIT entries #7 and #8 indicate the locations of the key and
    boot policy manifests; they start at the addresses 0xfffc9180 and 0xfffc8100,
    respectively.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '***Configuring Intel BootGuard***'
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Upon execution, the BootGuard BIOS ACM consumes the BootGuard key, while the
    boot policy locates the IBB in the system memory to obtain the correct public
    key to verify the IBB’s signature.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The BootGuard key manifest contains the hash of the boot policy manifest (BPM),
    the OEM root public key, the digital signature of the preceding fields (with the
    exception of the root public key, which isn’t included in the signed data), and
    the security version number (a counter that is incremented with every security
    update, intended to prevent rollback attacks).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The BPM itself contains the security version number, location, and hash of
    the IBB; the BPM public key; and digital signatures for the BPM fields just listed—again,
    with the exception of the root public key, which may be validated with the BPM
    public key. The location of the IBB provides the layout of the IBB in memory.
    This may not be in a contiguous memory block; it could consist instead of a few
    nonadjacent memory regions. The IBB hash contains the cumulative hash value of
    all the memory regions occupied by the IBB. Thus, the whole process of verifying
    the IBB’s signature is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: BootGuard locates the key manifest (KM) using FIT and obtains the boot policy
    manifest hash value and the OEM root key, which we’ll call key 1\. BootGuard verifies
    the digital signature in the KM using key 1 to ensure the integrity of the BPM
    hash value. If the verification fails, BootGuard reports an error and triggers
    remediation actions.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the verification succeeds, BootGuard locates the BPM using FIT, computes
    a hash value of the BPM, and compares it with the BPM hash in the KM. If the values
    aren’t equal, BootGuard reports an error and triggers remediation actions; otherwise,
    it obtains the IBB hash value and location from the BPM.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BootGuard locates the IBB in memory, computes its cumulative hash, and compares
    it with the IBB hash value in the BPM. If the hashes aren’t equal, BootGuard reports
    an error and triggers remediation actions.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, BootGuard reports that the verification succeeded. If Measured Boot
    is enabled, BootGuard also measures the IBB by calculating its hash and stores
    the measurement in the TPM. Then BootGuard transfers control to the IBB.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The KM is an essential structure, as it contains the OEM root public key used
    to verify the integrity of the IBB. You might be asking, “If BootGuard’s KM is
    stored in unprotected SPI flash along with firmware image, doesn’t that mean attackers
    can modify it in flash to provide BootGuard with a fake verification key?” To
    prevent an attack like this, the hash of the OEM root public key is instead stored
    in the chipset’s *field-programmable fuses*. These fuses can be programmed only
    once, at the point when the BootGuard boot policy is provisioned. Once the fuses
    are written, it’s impossible to override them. This is how the BootGuard verification
    key is anchored in the hardware, making the hardware the immutable root of trust.
    (The BootGuard boot policy is stored in chipset fuses as well, making it impossible
    to alter the policy after the fact.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: If an attacker changes the BootGuard key manifest, the ACM will spot the key
    alteration by computing its hash and comparing it with the “golden” value fused
    into the chipset. Mismatched hashes trigger an error report and remediation behavior.
    [Figure 17-15](ch17.xhtml#ch17fig15) demonstrates the chain of trust enforced
    by BootGuard.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-15: The Intel BootGuard chain of trust*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Once the IBB is successfully verified and, if necessary, measured, it executes
    and performs some basic chipset initialization, then loads the UEFI firmware.
    At this point, it is the IBB’s responsibility to authenticate the UEFI firmware
    before loading and executing it. Otherwise, the chain of trust will be broken.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-16](ch17.xhtml#ch17fig16) concludes this section by representing
    the boundaries of responsibility for Secure Boot implementations.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig16.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-16: The boundaries of responsibility for Secure Boot implementation*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**ARM Trusted Boot Board**'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ARM has its own implementation of Verified and Measured Boot technology, called
    the *Trusted Boot Board (TBB)*, or simply *Trusted Boot*. In this section, we’ll
    look at Trusted Boot’s design. ARM has a very particular setup, known as *Trust
    Zone* security technology, that divides the execution environment into two parts.
    Before we go into the Verified and Measured Boot process with ARM, we need to
    describe how Trust Zone works.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '***ARM Trust Zone***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Trust Zone security technology is a hardware-implemented security feature that
    separates the ARM execution environment into two *worlds*: the secure world and
    the normal (or nonsecure) world, which coexist on the same physical core, as shown
    in [Figure 17-17](ch17.xhtml#ch17fig17). The logic implemented in the processor’s
    hardware and firmware ensures that the secure world’s resources are properly isolated
    and protected from software running in the nonsecure world.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig17.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-17: The ARM Trust Zone*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Both worlds have their own dedicated and distinct firmware and software stacks:
    the normal world executes user applications and an OS, while the secure world
    executes a secure OS and trusted services. The firmware of these worlds consists
    of different bootloaders responsible for initializing the world and loading the
    OS, which we’ll talk about in a moment. For this reason, the secure and normal
    worlds have different firmware images.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Within the processor, software running in the normal world cannot access code
    and data in the secure world directly. The access control logic that prevents
    this is implemented in the hardware, usually in the System on Chip hardware. However,
    software running in the normal world can transfer control to the software located
    in the secure world (for instance, to execute a trusted service in the secure
    world) using particular software called Secure Monitor (in ARM Cortex-A) or core
    logic (in ARM Cortex-M). This mechanism ensures that switches between worlds don’t
    violate the security of the system.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Together, the Trusted Boot technology and Trust Zone create the Trusted Execution
    Environment, used to run software with high privileges and provide an environment
    for security technologies like digital rights management, cryptography and authentication
    primitives, and other security-sensitive applications. In this way, an isolated,
    protected environment may house the most sensitive software.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '***ARM Boot Loaders***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because the secure and normal worlds are kept separate, each world needs its
    own set of bootloaders. Also, the boot process for each world consists of multiple
    stages, which means a number of bootloaders must execute at different points in
    the boot process. Here, we’ll describe the Trusted Boot flow for ARM application
    processors in general terms, beginning with the following list of bootloaders
    involved in Trusted Boot. We showed these back in [Figure 17-17](ch17.xhtml#ch17fig17):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**BL1** First-stage bootloader, located in boot ROM and executed in the secure
    world.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '**BL2** Second-stage bootloader, located in flash memory, loaded and executed
    by BL1 in the secure world.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '**BL31** Secure-world runtime firmware, loaded and executed by BL2.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**BL32** Optional secure-world third-stage bootloader, loaded by BL2.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**BL33** Normal-world runtime firmware, loaded and executed by BL2.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: This list isn’t a complete and accurate list of all the ARM implementations
    in the real world, as some manufacturers introduce additional bootloaders or remove
    some of the existing ones. In some cases, BL1 may not be the very first code executed
    on the application processor when the system comes out of reset.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: To verify the integrity of these boot components, Trusted Boot relies on X.509
    public key certificates (remember that the files in UEFI Secure Boot’s `db` database
    were encoded with X.509). It’s worth mentioning that all certificates are self-signed.
    There is no need for a certificate authority, because the chain of trust is not
    established by the validity of a certificate’s issuer but rather by the content
    of the certificate extensions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Trusted Boot uses two types of certificates: *key* and *content* certificates.
    It uses key certificates first to verify the public keys that are used to sign
    content certificates. Then it uses the content certificates to store the hashes
    of boot loader images. This relationship is illustrated in [Figure 17-18](ch17.xhtml#ch17fig18).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig18.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-18: Trusted Boot key and content certificates*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Boot authenticates an image by calculating its hash and matching the
    result with the hash extracted from the content certificate.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '***Trusted Boot Flow***'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’re familiar with the foundational concepts of Trusted Boot, let’s
    take a look at the Trusted Boot flow for an application processor, shown in [Figure
    17-19](ch17.xhtml#ch17fig19). This will give you the full picture of how Verified
    Boot is implemented in ARM processors and how it protects platforms from the execution
    of untrusted code, including firmware rootkits.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 17-19](ch17.xhtml#ch17fig19), solid arrows denote the transfer of
    execution flow, and dashed arrows denote the trust relationship; in other words,
    each element trusts the element its dotted arrow points to.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Once the CPU is released from reset, the first piece of the code executed is
    bootloader 1 (BL1) ➊. BL1 is loaded from the read-only boot ROM, which means it
    can’t be tampered with while it’s stored there. BL1 reads the bootloader 2 (BL2)
    content certificate ➒ from flash memory and checks its issuer key. BL1 then computes
    the hash of the BL2 content certificate issuer and compares it with the “golden”
    values stored in the secure *root of trust public key register (ROTPK)* register
    ➓ in the hardware. The ROTPK register and boot ROM are the roots of trust, anchored
    in hardware for Trusted Boot. If the hashes aren’t equal or verification of the
    BL2 content certificate signature fails, the system panics.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Once the BL2 content certificate is verified against the ROTPK, BL1 loads the
    BL2 image from flash ➋, computes its cryptographic hash, and compares this hash
    value with the value obtained from the BL2 content certificate ➎.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Once authenticated, BL1 transfers control to BL2, which, in turn, reads its
    trusted key certificate ➏ from flash memory. This trusted key certificate contains
    public keys for the verification of the firmware for both the secure world ➐ and
    the normal world ➑. The key that issued the trusted key certificate is checked
    against the ROTPK register ➓.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Next, BL2 authenticates BL31 ➌, which is the runtime firmware for the secure
    world. To authenticate the BL31 image, BL2 uses the key certificate and content
    certificate for BL31 ➍. BL2 verifies these key certificates by using the secure
    world public key obtained from the trusted key certificate. The BL31 key certificate
    contains the BL31 content certificate public key used to verify the signature
    of the BL32 content certificate.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/17fig19.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: '*Figure 17-19: Trusted Boot flow*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Once the BL31 content certificate is verified, the hash value of the BL31 image
    stored within this BL31 certificate is used to check the integrity of the BL3
    image. Again, any failures result in a system panic.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, BL2 checks the integrity of the optional secure-world BL32 image
    using the BL32 key and content certificates.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The integrity of the BL33 firmware image (executed in the normal world) is checked
    with the BL33 key and BL33 content certificates. The BL33 key certificate is verified
    with the normal world public key obtained from the trusted key certificate.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: If all the checks pass successfully, the system proceeds by executing the authenticated
    firmware for both the secure and normal worlds.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**AMD HARDWARE VALIDATED BOOT**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Although not discussed in this chapter, AMD has its own implementation of Verified
    and Measured Boot called Hardware Validated Boot (HVB). This technology implements
    functionality similar to Intel BootGuard. Based on AMD Platform Security Processor
    technology, it has a microcontroller devoted to security-related computations
    that runs independently of the system’s main core.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Verified Boot vs. Firmware Rootkits**'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all of this knowledge in hand, let’s finally see whether Verified Boot
    can protect against firmware rootkits.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We know that Verified Boot takes place before any firmware is executed in the
    boot process. This means that when Verified Boot starts verifying firmware, any
    infecting firmware rootkit won’t yet be active, so the malware can’t counteract
    the verification process. Verified Boot will detect any malicious modification
    of firmware and prevent its execution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the root of trust for Verified Boot is anchored in the hardware, so
    attackers can’t tamper with it. Intel BootGuard’s OEM root public key is fused
    into the chipset, and ARM’s root of trust key is stored in secure registers. In
    both cases, the boot code that triggers Verified Boot is loaded from read-only
    memory, so malware can’t patch or modify it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: So, we can conclude that Verified Boot can withstand attacks from firmware rootkits.
    However, as you might have observed, the whole technology is quite complex; it
    has many dependencies, so it could easily be implemented incorrectly. This technology
    is only as secure as its weakest component; a single flaw in the chain of trust
    makes it possible to bypass. That means there’s a good chance attackers could
    find vulnerabilities in an implementation of Verified Boot to exploit and install
    firmware rootkits.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we explored three Secure Boot technologies: UEFI Secure Boot,
    Intel BootGuard, and ARM Trusted Boot. These technologies rely on a chain of trust—enforced
    from the very beginning of the boot process to the execution of user applications—and
    involve an enormous number of boot modules. When correctly configured and implemented,
    they provide protection against the ever-growing number of UEFI firmware rootkits.
    That’s why high-assurance systems must use Secure Boot, and why, these days, many
    consumer systems enable Secure Boot by default. In the next chapter, we’ll focus
    on forensic approaches for analyzing firmware rootkits.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
