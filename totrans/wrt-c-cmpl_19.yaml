- en: '![](../images/pg456.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg456.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-41.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-41.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SUPPORTING
    DYNAMIC MEMORY ALLOCATION</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">支持动态内存分配</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: 'Over the course of [Part II](part2.xhtml), you’ve compiled programs that call
    an increasingly wide range of standard library functions. At the end of [Part
    I](part1.xhtml), your compiler supported only functions with parameters and return
    values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>. Now you can compile
    programs that call floating-point math functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">fmax</samp>
    and string processing functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>.
    In this chapter, you’ll implement the remaining features you need to call a particularly
    important part of the standard library: the memory management functions. These
    include <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_alloc</samp>,
    which allocate memory dynamically; <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>,
    which deallocates dynamically allocated memory; and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    which deallocates one block of memory and reallocates another with the same contents.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二部分](part2.xhtml)中，你已经编译了调用越来越多标准库函数的程序。在[第一部分](part1.xhtml)的结尾时，你的编译器只支持那些参数和返回值类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>的函数，如<samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>。现在，你可以编译调用像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fmax</samp>这样的浮点数学函数和像<samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>这样的字符串处理函数的程序。在本章中，你将实现调用标准库中一个非常重要部分——内存管理函数所需的剩余功能。这些函数包括动态分配内存的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aligned</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_alloc</samp>；用于释放动态分配内存的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp>；以及释放一个内存块并重新分配另一个相同内容的内存块的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>。
- en: To compile programs that declare and call these functions, you’ll need to implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. Up until now,
    we’ve used the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword
    only to specify an empty parameter list; now we’ll treat it as a proper type specifier.
    In C, <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> represents the
    address of a chunk of memory with no particular type; the standard library functions
    that allocate memory all return this type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type on its own is also useful. For instance, you can use it to declare functions
    that don’t return a value, like <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>.
    In addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, we’ll
    implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which gets the size of a type or object. C programs often use <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to figure out how many bytes of memory to allocate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译声明并调用这些函数的程序，你需要实现<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>类型。直到现在，我们只用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>关键字来指定空的参数列表；现在我们将其作为一个合适的类型说明符来处理。在C语言中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>表示一个没有特定类型的内存块的地址；所有分配内存的标准库函数都返回这种类型。单独的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>类型也非常有用。例如，你可以用它来声明那些不返回值的函数，像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">free</samp>。除了<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>外，我们还将实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>运算符，它用来获取类型或对象的大小。C程序常常使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>来计算需要分配多少字节的内存。
- en: This chapter’s not-so-secret agenda is to get you ready to implement structure
    types in [Chapter 18](chapter18.xhtml). Real-life C programs frequently store
    structures in dynamically allocated memory, and so do many of that chapter’s tests.
    The changes we make to the type checker will also come in handy in [Chapter 18](chapter18.xhtml)
    because some of the typing rules that apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    will apply to structure types too.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的非秘密议程是让你为[第18章](chapter18.xhtml)中实现结构体类型做准备。现实中的C程序通常将结构体存储在动态分配的内存中，这也是该章节许多测试的做法。我们对类型检查器所做的更改，在[第18章](chapter18.xhtml)中也会派上用场，因为一些适用于<code>void</code>的类型规则也适用于结构体类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The void Type</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">void类型</samp>
- en: 'The C standard (section 6.2.5, paragraph 19) gives the following rather mysterious
    definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>: “The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type comprises an empty
    set of values; it is an incomplete object type that cannot be completed.” We’ll
    talk more about what “incomplete object type” means in a moment. For now, the
    main idea is that <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> is
    a type with no values. You can’t do a whole lot with this type, but it does have
    a few uses.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C标准（第6.2.5节，第19段）给出了以下相当神秘的<code>void</code>定义：“<code>void</code>类型包含一个空的值集合；它是一个不完整的对象类型，无法完成。”我们稍后会详细讨论“不可完成的对象类型”是什么意思。现在，主要的观点是<code>void</code>是一种没有值的类型。你不能用这个类型做太多事情，但它确实有一些用处。
- en: You can give a function a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type if it doesn’t return anything. To leave a function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with no expression, like in [Listing 17-1](chapter17.xhtml#list17-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数不返回任何值，你可以给它指定一个<code>void</code>返回类型。为了让函数具有<code>void</code>返回类型，你可以使用一个没有表达式的<code>return</code>语句，像[示例17-1](chapter17.xhtml#list17-1)中那样。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-1: A function with
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return
    type</samp>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例17-1：一个具有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">返回类型的函数</samp>
- en: As [Listing 17-2](chapter17.xhtml#list17-2) demonstrates, you can also leave
    out the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    entirely. In that case, the function will return once you reach the end of the
    function body.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[示例17-2](chapter17.xhtml#list17-2)所示，你还可以完全省略<code>return</code>语句。在这种情况下，当你到达函数体的末尾时，函数将返回。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-2: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例17-2：一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">没有</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">return语句的</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void函数</samp>
- en: 'A *void expression* is an expression whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>;
    it has no value, but you can evaluate it for its side effects. There are three
    ways to produce a void expression. First, you can call a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function. Second, you can evaluate a conditional expression whose branches are
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*void表达式*是一个类型为<code>void</code>的表达式；它没有值，但你可以评估它的副作用。产生void表达式的方式有三种。首先，你可以调用一个<code>void</code>函数。其次，你可以评估一个条件表达式，其两个分支都是<code>void</code>类型：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Third, you can cast a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可以将一个值转换为<code>void</code>类型：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    has no effect on program execution; its only purpose is to tell the compiler,
    and human readers, that the value of the expression should be discarded. This
    is a common way to silence compiler warnings about unused values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，强制转换为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>` 对程序执行没有影响；它的唯一目的是告诉编译器和程序员，表达式的值应该被丢弃。这是消除编译器关于未使用值警告的常见方法。
- en: If you’re particularly zealous about following C’s typing rules, you might also
    cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in code like
    that in [Listing 17-3](chapter17.xhtml#list17-3) to get the types of two conditional
    branches to agree.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你特别热衷于遵循 C 语言的类型规则，你也可以像在[示例 17-3](chapter17.xhtml#list17-3)中那样，对代码进行强制转换为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>`，以使两个条件分支的类型一致。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-3: A conditional
    expression with type</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 17-3：类型为</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
- en: If we left out the cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in this conditional expression, one branch would have type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    and the other would have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This would be illegal, although most compilers won’t complain about it unless
    you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag
    to enable extra warnings. Our compiler will reject conditional expressions with
    one <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> branch, because
    it’s pedantic all the time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个条件表达式中省略了对 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>`
    的强制转换，一个分支将是 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>` 类型，另一个将是
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>` 类型。这将是非法的，尽管大多数编译器不会对此发出警告，除非你使用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp>` 标志启用额外的警告。我们的编译器会拒绝带有
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>` 分支的条件表达式，因为它一直是严格的。
- en: 'There are four places where you can use a void expression. First, it can appear
    as a clause in a conditional expression, as in [Listing 17-3](chapter17.xhtml#list17-3).
    Second, you can use it as a stand-alone expression:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个地方可以使用 `void` 表达式。首先，它可以作为条件表达式中的一个子句出现，如[示例 17-3](chapter17.xhtml#list17-3)。其次，你可以将其作为独立的表达式使用：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Third, it can appear as the first or third clause of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop header, like in [Listing 17-4](chapter17.xhtml#list17-4).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，它可以作为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>` 循环头部的第一个或第三个子句出现，如[示例
    17-4](chapter17.xhtml#list17-4)。
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-4: Using void expressions
    in a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    header</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 17-4：在</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">循环头部中使用 void 表达式</samp>
- en: 'And fourth, you can cast a void expression to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第四，你可以将 `void` 表达式强制转换为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That last one isn’t particularly useful, but it is legal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条并不特别有用，但它是合法的。
- en: As you already know, you can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword to specify an empty parameter list in a function declaration. This is
    a special case, since it doesn’t actually specify an expression, object, or return
    value with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. Even
    once we extend the compiler to fully support the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type, we’ll handle this particular case exactly the same way as before.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你还可以使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>` 关键字在函数声明中指定一个空的参数列表。这是一个特殊情况，因为它实际上并没有指定一个表达式、对象或返回值的类型为
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>`。即使我们扩展编译器以完全支持 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>` 类型，我们仍将像以前一样处理这个特殊情况。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory Management with void *</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 void * 进行内存管理</samp>
- en: 'Now let’s look at how the memory management functions use <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> to represent allocated memory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function has the following signature:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看内存管理函数如何使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>`
    来表示分配的内存。`<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>` 函数具有以下签名：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument specifies
    the number of bytes to allocate. Its type, <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>,
    is an implementation-defined unsigned integer type. Under the System V x64 ABI,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> is an alias for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. Because we don’t
    support type aliases, our test programs and examples use this declaration instead:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> 参数指定要分配的字节数。它的类型 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> 是一个实现定义的无符号整数类型。在 System
    V x64 ABI 下，<samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> 是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 的别名。由于我们不支持类型别名，我们的测试程序和示例使用以下声明：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates
    a chunk of memory and returns its address. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    doesn’t know what type of object will be stored in this chunk of memory, it would
    be misleading to return a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, or any of the other
    types we’ve seen so far. Instead, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>. You can’t read or write memory through a <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> pointer, though. So, before you can access the memory that you allocated
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, you need to
    specify what type of object it should contain by converting its address from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to a different pointer type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc` 函数分配一块内存并返回其地址。由于 `malloc` 并不知道这块内存将存储什么类型的对象，因此返回一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp> 或我们到目前为止看到的其他类型的指针会产生误导。相反，它返回
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>。不过，你不能通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 指针来读写内存。因此，在你可以访问通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    分配的内存之前，你需要通过将其地址从 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    转换为其他指针类型来指定它应包含的对象类型。'
- en: 'You can convert other pointer types to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> without an explicit cast. For example, you might use <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to allocate an array of 100 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    elements:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不显式转换的情况下将其他指针类型转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>，反之亦然。例如，你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 分配一个包含 100 个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 元素的数组：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you assign the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>, it’s implicitly
    converted from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Then, you can subscript
    <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> like any other
    pointer into an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的结果赋值给 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> 时，它会隐式地将 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>。然后，你可以像访问其他
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 数组一样访问 <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function accepts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> argument that designates
    the chunk of memory to deallocate:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`free` 函数接受一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 参数，指定要释放的内存块：'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This pointer must be the same value that was returned earlier by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    or one of the other memory allocation functions. Here’s how you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to deallocate the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>
    points to:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指针必须是之前由 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 或其他内存分配函数返回的相同值。以下是如何使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> 来释放 <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>
    指向的内存：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function call implicitly converts the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> back to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, resulting in the same pointer
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returned in the
    first place.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用隐式地将 <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> 的值从
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> 转换回 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>，结果是与最初 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 返回的指针相同。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    functions provide slightly different ways to allocate memory; like <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    they return pointers to the allocated space with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function
    accepts a size and a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    pointer to previously allocated storage that should now be freed, and it returns
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointer to a newly
    allocated block of storage with the new size and the original contents. For our
    purposes, the details of these functions aren’t important; the key idea is that
    they all use <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointers
    to identify the blocks of memory they allocate and deallocate.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    函数提供了稍有不同的内存分配方式；与 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    类似，它们返回指向分配空间的指针，类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> 函数接受一个大小和一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 指针，指向之前分配的内存，这块内存应该被释放，它返回一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 指针，指向一个新分配的内存块，大小为新的指定值，并保留原有内容。就我们的目的而言，这些函数的细节并不重要；关键概念是它们都使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 指针来标识它们分配和释放的内存块。
- en: 'These blocks of memory are objects that we can read and write, much like variables,
    but their lifetimes are managed differently. As we know, variables have either
    automatic storage duration (their lifetime lasts through the execution of a single
    block) or static storage duration (their lifetime lasts for the whole program).
    A block of allocated memory has *allocated storage duration*: its lifetime starts
    when it’s allocated and ends when it’s deallocated.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内存块是我们可以读取和写入的对象，类似于变量，但它们的生命周期管理方式不同。如我们所知，变量有自动存储持续时间（生命周期持续整个代码块执行期间）或静态存储持续时间（生命周期持续整个程序）。一块已分配的内存具有
    *分配存储持续时间*：其生命周期从分配开始，直到释放为止。
- en: The compiler has to keep track of all the variables with static or automatic
    storage duration, record details about their size and lifetime in the symbol table,
    and reserve space for them in the data section or on the stack. But the compiler
    doesn’t need to know anything about objects with allocated storage duration, because
    the programmer and the memory management library are responsible for keeping track
    of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须跟踪所有具有静态或自动存储持续时间的变量，记录它们的大小和生命周期的详细信息，并在数据段或栈上为它们保留空间。但编译器不需要知道任何关于具有分配存储持续时间的对象的信息，因为这些对象的跟踪是由程序员和内存管理库负责的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Complete and Incomplete Types</samp>
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">完整类型和不完整类型</samp>
- en: An object type is *complete* if we know its size and *incomplete* if we don’t.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is the first
    incomplete type we’ve seen. We don’t know its size because it doesn’t *have* a
    size. In the next chapter, we’ll encounter incomplete structure types, whose size
    and members aren’t visible to the compiler. Incomplete structure types can be
    completed later in the program if the compiler learns more about them. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type, on the other hand, can’t
    be completed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道一个对象的大小，那么它的类型是 *完整的*；如果我们不知道它的大小，那么它的类型是 *不完整的*。<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    类型是我们见过的第一个不完整类型。我们不知道它的大小，因为它没有 *大小*。在下一章中，我们将遇到不完整的结构类型，这些类型的大小和成员对编译器不可见。不完整的结构类型可以在程序后续部分通过编译器了解到更多信息后得到完成。而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型则无法被完成。
- en: The C standard states that “an incomplete type can only be used when the size
    of an object of that type is not needed” (section 6.7.2.3, footnote 132). For
    example, you can’t define a variable with an incomplete type, because you don’t
    know how much space to allocate for it. And you can’t assign to an object with
    an incomplete type or use its value, since you would need to know how many bytes
    to read or write. With a few exceptions, other incomplete types are subject to
    the same restrictions as <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    and the type checker will handle them the same way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C标准规定，“只有在不需要知道该类型对象的大小时，才能使用不完整类型”（第6.7.2.3节，脚注132）。例如，你不能定义一个不完整类型的变量，因为你不知道需要为它分配多少空间。而且，你不能给一个不完整类型的对象赋值或使用它的值，因为你需要知道读写多少字节。除了少数几个例外，其他不完整类型受与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>相同的限制，类型检查器会以相同方式处理它们。
- en: All pointers are complete types, even if the types they point to are incomplete;
    we know that the size of a pointer is always 8 bytes. That’s why you can declare
    variables and parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> values
    from functions, convert them to other pointer types, and so on. As you’ll see
    in the next chapter, you can use pointers to incomplete structure types in the
    same way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有指针都是完整类型，即使它们指向的类型是不完整的；我们知道指针的大小始终是8字节。这就是为什么你可以声明类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>的变量和参数，从函数返回<samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>类型的值，将它们转换为其他指针类型，等等。正如你将在下一章看到的那样，你可以以相同的方式使用指向不完整结构类型的指针。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The sizeof Operator</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">sizeof操作符</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator accepts
    either an expression or the name of a type. When it takes a type name, it returns
    the size of that type in bytes. When it takes an expression, it returns the size
    of the expression’s type. [Listing 17-5](chapter17.xhtml#list17-5) illustrates
    both cases.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>操作符接受表达式或类型名称。当它接受类型名称时，它返回该类型的字节大小。当它接受表达式时，它返回该表达式类型的大小。[清单17-5](chapter17.xhtml#list17-5)展示了这两种情况。
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-5: The two uses
    of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单17-5：sizeof的两种用法</samp>
- en: Both of these <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions
    evaluate to 8 because the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> types are both
    8 bytes. Note that type names in <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions must be parenthesized, but expressions don’t need to be.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>表达式的值都是8，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型的大小都是8字节。请注意，在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>表达式中，类型名称必须用括号括起来，但表达式不需要。
- en: When you use an array in a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expression, it doesn’t decay to a pointer. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expression in [Listing 17-6](chapter17.xhtml#list17-6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>表达式中使用数组时，它不会退化为指针。请参见[清单17-6](chapter17.xhtml#list17-6)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>表达式。
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-6: Getting the size
    of an array</samp>'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单17-6：获取数组的大小</samp>
- en: This code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>, which
    is the size of a three-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    array, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>, the
    size of a pointer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回<samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>，即一个包含三个<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>元素的数组的大小，而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">8</samp>，即指针的大小。
- en: You can always determine an expression’s type—and therefore its size—without
    evaluating it. In fact, the C standard requires that we *don’t* evaluate the operand
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression. Instead,
    we infer the operand’s type and evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    at compile time. This implies that a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expression won’t produce side effects. For example, the statement
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以在不评估表达式的情况下确定其类型——因此也能确定其大小。事实上，C 标准要求我们*不要*评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    表达式的操作数。相反，我们推断操作数的类型，并在编译时评估 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>。这意味着
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式不会产生副作用。例如，语句
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>. It will
    just return <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> because the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function’s return type
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不会调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>。它将直接返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    函数的返回类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。
- en: You can also apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to expressions that would typically produce runtime errors, as [Listing 17-7](chapter17.xhtml#list17-7)
    demonstrates.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 应用于通常会产生运行时错误的表达式，正如
    [第17-7节](chapter17.xhtml#list17-7) 所演示的那样。
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-7: Getting the size
    of an expression without evaluating it</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">第17-7节：在不评估表达式的情况下获取其大小</samp>
- en: Normally, dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp>
    would lead to undefined behavior. But this example is well defined, because it
    will never evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp>.
    Instead, it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>,
    because the compiler can determine that the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，解引用 <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp> 会导致未定义行为。但是这个例子是明确定义的，因为它永远不会评估
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp>。相反，它将返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>，因为编译器可以确定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp> 的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。
- en: Variable-length arrays are the one exception to this rule. The size of a variable-length
    array isn’t known at compile time, so it has to be evaluated at runtime. Because
    we don’t support variable-length arrays, we can ignore this case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可变长度数组是这一规则的唯一例外。可变长度数组的大小在编译时无法得知，因此必须在运行时进行评估。由于我们不支持可变长度数组，所以可以忽略这一情况。
- en: Now that we know how C programs use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>,
    let’s work on the compiler. As usual, we’ll start by updating the lexer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 C 程序如何使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>，接下来让我们开始处理编译器。像往常一样，我们将从更新词法分析器开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add one new keyword in this chapter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引入一个新关键字：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sizeof</samp>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sizeof</samp>
- en: You don’t need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword; the lexer already recognizes it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 关键字；词法分析器已经识别它了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: '[Listing 17-8](chapter17.xhtml#list17-8) shows this chapter’s changes to the
    AST.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17-8节](chapter17.xhtml#list17-8)展示了本章对 AST 的修改。'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-8: The abstract
    syntax tree with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements with no return value</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-8：带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">，</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">，和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">没有返回值的 return 语句</samp>
- en: We’ve made four small changes here. First, we added a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type. Second, the expression in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    statement is now optional so that it can represent <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements with and without return values. Finally, there are two new expressions
    to represent the two ways you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了四个小修改。首先，我们添加了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    类型。其次，<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 语句中的表达式现在是可选的，因此它可以表示有返回值和没有返回值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句。最后，有两个新的表达式，表示你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 操作符的两种方式。
- en: 'Next, we’ll make the corresponding changes to the grammar. The one wrinkle
    here is that we can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to a cast expression unless that expression is parenthesized. For example, this
    is a syntax error:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对语法进行相应的修改。这里唯一的难点是，除非类型转换表达式被括号括起来，否则我们不能对类型转换表达式应用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>。例如，这是一个语法错误：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wrapping the cast expression in parentheses fixes the error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型转换表达式用括号括起来可以修复这个错误：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This restriction makes it easier for the parser to distinguish between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operations on type names
    and on expressions. To capture this restriction in the grammar, we need to break
    out cast expressions into a separate symbol from other unary expressions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制使得解析器更容易区分 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 操作是作用于类型名还是作用于表达式。为了在语法中捕捉到这个限制，我们需要将类型转换表达式与其他一元表达式分开。
- en: 'Let’s start by refactoring type names into a symbol that we can use in both
    cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从重构类型名开始，创建一个符号，以便我们能在类型转换和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    表达式中都能使用：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we’ll define the new <samp class="SANS_TheSansMonoCd_W5Regular_11"><cast-exp></samp>
    symbol, which includes one rule for cast expressions and another for all the other
    unary expressions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义新的 <samp class="SANS_TheSansMonoCd_W5Regular_11"><cast-exp></samp>
    符号，包含一个类型转换表达式规则和另一个用于所有其他一元表达式的规则：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll then update <samp class="SANS_TheSansMonoCd_W5Regular_11"><unary-exp></samp>
    to include every unary expression except for casts:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新 <samp class="SANS_TheSansMonoCd_W5Regular_11"><unary-exp></samp> 以包含所有一元表达式，除了类型转换：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The rule for unary operations like <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> allows cast expressions
    as operands ❶, while the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    doesn’t ❷.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作符规则，比如 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    允许类型转换表达式作为操作数 ❶，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    的规则则不允许 ❷。
- en: 'Finally, we’ll use the new <samp class="SANS_TheSansMonoCd_W5Regular_11"><cast-exp></samp>
    symbol, instead of the more restrictive <samp class="SANS_TheSansMonoCd_W5Regular_11"><unary-exp></samp>,
    to represent a single term in a binary or ternary expression:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用新的 <samp class="SANS_TheSansMonoCd_W5Regular_11"><cast-exp></samp> 符号，而不是更具限制性的
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><unary-exp></samp>，来表示二元或三元表达式中的单个项：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Listing 17-9](chapter17.xhtml#list17-9) gives the complete grammar for this
    chapter.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-9](chapter17.xhtml#list17-9) 给出了本章的完整语法。'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-9: The grammar with</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    and optional return values</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 17-9：带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">、</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11"> 和可选返回值的语法</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> helper function,
    which converts a list of type specifiers into a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node, should reject any declarations where the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    specifier appears alongside other type specifiers, like <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. Otherwise, the
    parser should treat <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    like any other type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type can be modified by pointer, array, and function declarators; pointers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and functions returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> are both perfectly legal,
    while other ways of using <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    are syntactically valid but semantically illegal. For example, it’s a semantic
    error to declare an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    elements, define a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> variable,
    or declare a function with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    parameters. The parser won’t catch these semantic errors, but the type checker
    will.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> 辅助函数，它将类型说明符列表转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp> AST 节点，应当拒绝任何 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 说明符与其他类型说明符（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>）一起出现的声明。否则，解析器应像处理其他类型一样处理
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    类型可以通过指针、数组和函数声明符进行修饰；指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的指针和返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的函数都是完全合法的，而其他使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的方式在语法上是有效的，但在语义上是非法的。例如，声明一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 元素的数组，定义一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    变量，或声明一个带有 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 参数的函数，都是语义错误。解析器不会捕捉这些语义错误，但类型检查器会。
- en: You may need to change your parsing logic for <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>,
    even though the grammar rule itself hasn’t changed. If the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>is
    followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword,
    you’ll need to look ahead one more token. If the next token is), the parameter
    list is empty. Otherwise, the list is not empty, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword is the start of a parameter declaration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 即使语法规则本身没有改变，您可能仍需要更改对 <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>
    的解析逻辑。如果开头的 <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp> 后面跟着 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 关键字，您需要再看下一个符号。如果下一个符号是），则参数列表为空。否则，列表不为空，且
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 关键字表示一个参数声明的开始。
- en: Note that when a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword
    indicates an empty parameter list, we do *not* translate it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp>
    type in the AST. For example, given the function declaration
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 关键字表示空参数列表时，我们*不会*将其翻译为
    AST 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp> 类型。例如，给定函数声明
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'the resulting AST node will have this type:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 AST 节点将具有此类型：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> list is empty,
    just like in prior chapters; it doesn’t contain <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp>.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> 列表为空，就像在前面的章节中一样；它不包含
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp>。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">类型检查器</samp>
- en: Now let’s figure out how to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>.
    We’ll begin with implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and the other pointer types. These are permitted in a few cases, even
    though most implicit conversions between pointer types are not. Next, we’ll detect
    all of the new and exciting type errors that <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    can trigger. We’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator last.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们弄清楚如何进行 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    的类型检查。我们将从 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 与其他指针类型之间的隐式转换开始。尽管大多数指针类型之间的隐式转换是不可行的，但在几种情况下，这种转换是被允许的。接下来，我们将检测
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 可能引发的所有新的和令人兴奋的类型错误。最后，我们将处理
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 操作符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conversions to and
    from void *</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转换到和从 void *</samp>
- en: 'Implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and the other pointer types are legal in three cases. First, you can
    compare a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    with another pointer type using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>与其他指针类型之间的隐式转换在三种情况下是合法的。首先，你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>
    比较 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 类型的值和另一个指针类型：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Second, in a conditional expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>,
    one clause can have type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    and the other clause can have another pointer type:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，在形如 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>
    的条件表达式中，一个子句可以是 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 类型，另一个子句可以是其他指针类型：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In both of these cases, the non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    pointer is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，非<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型的指针会被转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>。
- en: 'Third, you can implicitly convert to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> during assignment. You can assign a value with any pointer type to an
    object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，你可以在赋值时隐式地进行 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    与其他指针类型之间的转换。你可以将任何指针类型的值赋给 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 类型的对象：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And along the same lines, you can assign a value with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> to an object with another pointer type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你也可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 类型的值赋给另一个指针类型的对象。
- en: 'This last case doesn’t just include simple assignment; it covers all the conversions
    “as if by assignment” that we talked about in [Chapter 14](chapter14.xhtml). For
    example, it’s legal to pass <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> arguments to a function that expects parameters of some other pointer
    type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况不仅包括简单的赋值操作；它涵盖了我们在[第14章](chapter14.xhtml)中讨论的所有“类似于赋值”的转换。例如，传递 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 类型的参数给期望其他指针类型的函数是合法的：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Not coincidentally, these are the same three cases where you can implicitly
    convert a null pointer constant to some other pointer type. To support implicit
    conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>,
    we’ll extend two helper functions we defined back in [Chapter 14](chapter14.xhtml):
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 并非巧合，这恰好是可以隐式地将空指针常量转换为其他指针类型的三种情况。为了支持 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> 的隐式转换，我们将扩展在 [第 14 章](chapter14.xhtml) 中定义的两个辅助函数：<samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>。
- en: Let’s revisit [Listing 14-14](chapter14.xhtml#list14-14), which defined <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>. It’s reproduced
    here as [Listing 17-10](chapter17.xhtml#list17-10), with this chapter’s changes
    bolded.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视 [列表 14-14](chapter14.xhtml#list14-14)，该列表定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>。它在此处复制为
    [列表 17-10](chapter17.xhtml#list17-10)，并已加粗本章的更改部分。
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-10: Getting the
    common type of two expressions, where at least one has pointer type</samp>'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-10：获取两个表达式的公共类型，其中至少一个具有指针类型</samp>
- en: The bolded code permits implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and other pointer types but not between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and arithmetic types, array types, or <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Next, we’ll take another look at [Listing 14-16](chapter14.xhtml#list14-16), reproduced
    here as [Listing 17-11](chapter17.xhtml#list17-11), with changes bolded.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分的代码允许在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 和其他指针类型之间进行隐式转换，但不允许在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> 和算术类型、数组类型或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 之间进行隐式转换。接下来，我们将再次查看 [列表 14-16](chapter14.xhtml#list14-16)，并将其复制到
    [列表 17-11](chapter17.xhtml#list17-11) 中，修改部分已加粗。
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-11: Converting an
    expression to a target type as if by assignment</samp>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-11：将表达式转换为目标类型，如同通过赋值操作一样</samp>
- en: The bolded additions permit us to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> to other pointer types, and vice versa, during assignment. Note that
    nothing in this listing would prevent us from assigning a void expression to a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> target type. However,
    we’ll introduce other restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    elsewhere in the type checker that will ensure that we never call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    with a target type of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    For instance, we’ll never try to convert a function argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    because we’ll reject function declarations with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    parameters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分的修改使我们可以在赋值过程中将 <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    转换为其他指针类型，反之亦然。请注意，本列表中的内容不会阻止我们将 void 表达式赋值给 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    目标类型。然而，我们将在类型检查器的其他地方引入对 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的其他限制，以确保我们永远不会将目标类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp> 函数调用。例如，我们永远不会尝试将函数参数转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，因为我们会拒绝包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    参数的函数声明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with void
    Return Types</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回类型为 void 的函数</samp>
- en: 'Next, we’ll type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements with and without expressions. Which <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement you should use depends on the function’s return type. A function with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type must not
    return an expression. A function with any other return type must include an expression
    when it returns. Therefore, these two function definitions are legal:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对带有和不带有表达式的 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句进行类型检查。应该使用哪种 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句取决于函数的返回类型。返回类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的函数不能返回表达式。任何其他返回类型的函数在返回时必须包含表达式。因此，以下两个函数定义是合法的：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And these are both illegal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种都是非法的：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can’t even return a void expression from a function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type, which makes the following example illegal too:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不能从返回类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>的函数中返回一个void表达式，这也使得以下示例非法：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both GCC and Clang accept this program, but they’ll warn if you include the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag. You can handle
    this edge case however you like; the test suite doesn’t cover it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GCC和Clang都接受这个程序，但如果你使用`-pedantic`标志，它们会发出警告。你可以根据需要处理这种边缘情况；测试套件不会覆盖它。
- en: I’ll skip the pseudocode for this section, since it’s a pretty straightforward
    extension to our existing logic to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我会跳过本节的伪代码，因为这只是我们现有逻辑的一种直接扩展，用于类型检查<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scalar and Non-scalar
    Types</samp>
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标量和非标量类型</samp>
- en: Several C constructs require scalar expressions, including the operands of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> expressions; the first
    operand of a conditional expression; and the controlling conditions in loops and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The common
    thread is that all of these language constructs compare the value of the expression
    to zero. Comparing a pointer or arithmetic value to zero makes sense; comparing
    a non-scalar value to zero does not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C语言构造要求使用标量表达式，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">||</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>表达式的操作数；条件表达式的第一个操作数；以及循环和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp>语句中的控制条件。共同点是，所有这些语言构造都将表达式的值与零进行比较。将指针或算术值与零进行比较是有意义的，但将非标量值与零进行比较则没有意义。
- en: In earlier chapters, there was no way to write a program that violated these
    type constraints. Arrays were our only non-scalar type, and they decay to pointers
    wherever scalar expressions are required. But once we throw <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    into the mix, we need to enforce these constraints explicitly. (Although <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> isn’t an aggregate type, it
    isn’t scalar, either. A scalar expression has a single value, but a void expression
    has *no* value.) [Listing 17-12](chapter17.xhtml#list17-12) defines a tiny helper
    function to tell us whether a type is scalar.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，没有办法编写一个违反这些类型约束的程序。数组是我们唯一的非标量类型，而且在需要标量表达式的地方，数组会退化为指针。但是一旦我们把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>加入其中，就需要明确执行这些约束。（尽管<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>不是一个聚合类型，它也不是标量类型。标量表达式有一个单一的值，而void表达式则*没有*值。）[清单
    17-12](chapter17.xhtml#list17-12)定义了一个小的辅助函数来告诉我们一个类型是否为标量。
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-12: Checking whether
    a type is scalar</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-12：检查类型是否为标量</samp>
- en: We can use this helper function to validate controlling conditions and logical
    operands. For example, [Listing 17-13](chapter17.xhtml#list17-13) illustrates
    how to validate the operand of a logical <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>
    expression.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个辅助函数来验证控制条件和逻辑操作数。例如，[清单 17-13](chapter17.xhtml#list17-13)演示了如何验证逻辑<samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp>表达式的操作数。
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-13: Validating that
    a logical operand is scalar</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-13：验证逻辑操作数是否为标量</samp>
- en: Cast expressions are a bit different. Except for casts between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and pointers, which we already prohibit, you can cast a scalar expression to any
    scalar type. You can also cast any type to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    [Listing 17-14](chapter17.xhtml#list17-14) shows how to type check cast expressions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换表达式略有不同。除了我们已经禁止的`double`与指针之间的转换外，你可以将标量表达式转换为任何标量类型。你还可以将任何类型转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>。 [清单 17-14](chapter17.xhtml#list17-14)展示了如何进行类型检查类型转换表达式。
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-14: Type checking
    cast expressions</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-14：类型检查类型转换表达式</samp>
- en: First, we explicitly reject casts between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and pointers. That check is snipped out of [Listing 17-14](chapter17.xhtml#list17-14),
    since it’s the same as in previous chapters. Then, we check whether the target
    type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> ❶. If it is,
    we record that the type of the whole expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Otherwise, we validate that both the target type ❷ and the inner expression ❸
    are scalar. This rejects casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    to any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. It
    also forbids casts to array and function types, which we already know are illegal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们明确拒绝 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和指针之间的转换。这项检查在
    [清单 17-14](chapter17.xhtml#list17-14) 中被省略，因为它与前几章相同。接着，我们检查目标类型是否为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    ❶。如果是，我们记录下整个表达式的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>。否则，我们验证目标类型
    ❷ 和内层表达式 ❸ 是否都是标量类型。这将拒绝从 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    到任何非 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型的转换，也禁止转换到数组和函数类型，这些我们已经知道是不合法的。
- en: The type checking logic in [Listings 17-13](chapter17.xhtml#list17-13) and [17-14](chapter17.xhtml#list17-14)
    will also apply to structures, which we’ll implement in the next chapter. Structures
    are aggregate types, but they don’t decay to pointers like arrays do. We’ll therefore
    need to validate that programs don’t use structures where scalar types are required.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-13](chapter17.xhtml#list17-13) 和 [17-14](chapter17.xhtml#list17-14)
    中的类型检查逻辑也适用于结构体，我们将在下一章实现它们。结构体是聚合类型，但它们不像数组那样会衰退为指针。因此，我们需要验证程序中是否在需要标量类型的地方使用了结构体。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restrictions on Incomplete
    Types</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不完整类型的限制</samp>
- en: A program will run into type errors if it uses an incomplete type where a complete
    type is required. For now, we’ll require complete types in three cases. First,
    you can’t add, subtract, or subscript pointers to incomplete types, since you
    can’t determine the sizes of the array elements they point to. Second, you can’t
    apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to an incomplete
    type, since its size is unknown. Third, whenever you specify an array type, its
    element type must be complete.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序在需要完整类型的地方使用不完整类型，将会遇到类型错误。目前，我们将在三种情况下要求完整类型。首先，不能对指向不完整类型的指针进行加法、减法或下标操作，因为无法确定它们指向的数组元素的大小。其次，不能对不完整类型应用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>，因为它的大小未知。第三，每当你指定数组类型时，其元素类型必须是完整类型。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*As a language extension, Clang and GCC permit pointer arithmetic with void
    pointers and sizeof operations on void. These expressions are implemented as if
    the size of void were 1.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为语言扩展，Clang 和 GCC 允许对 void 指针进行指针运算，并对 void 执行 sizeof 操作。这些表达式的实现假定 void
    的大小为 1。*'
- en: '[Listing 17-15](chapter17.xhtml#list17-15) defines a couple of helper functions
    to support this validation.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 17-15](chapter17.xhtml#list17-15) 定义了一些辅助函数来支持这种验证。'
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-15: Checking for
    incomplete types and pointers to incomplete types</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-15：检查不完整类型和指向不完整类型的指针</samp>
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> whenever
    we need to check for a complete type. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">is_pointer_to_complete</samp>
    when we need to check for a pointer to a complete type—specifically, when we type
    check pointer addition, subtraction, and subscripting. For example, [Listing 17-16](chapter17.xhtml#list17-16)
    demonstrates how to type check pointer addition. It reproduces [Listing 15-21](chapter15.xhtml#list15-21),
    with this chapter’s changes bolded and some unchanged code omitted.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在需要检查完整类型时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>。在需要检查指向完整类型的指针时，我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_pointer_to_complete</samp>，特别是在我们进行指针加法、减法和下标操作时。例如，[清单
    17-16](chapter17.xhtml#list17-16) 演示了如何进行指针加法的类型检查。它复制了 [清单 15-21](chapter15.xhtml#list15-21)，并将本章的更改加粗，同时省略了一些未更改的代码。
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-16: Type checking
    pointer addition, with extra validation that the pointer’s referenced type is
    complete</samp>'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-16：类型检查指针加法，额外验证指针引用的类型是否完整</samp>
- en: In the next chapter, we’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>
    to distinguish between complete and incomplete structure types too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将扩展<samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>，以区分完整类型和不完整类型的结构体类型。
- en: 'We won’t worry about <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    just yet; we’ll type check it a little later, in “<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    Expressions” on [page 477](#pg_477). That means we just have to handle our third
    case, by making sure that every array element type is complete. This applies to
    arrays nested in larger types too. The following declaration, for example, is
    invalid:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不考虑<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>；我们将在稍后的“<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式”部分对其进行类型检查，[见第477页](#pg_477)。这意味着我们只需要处理第三种情况，确保每个数组元素的类型是完整的。这同样适用于嵌套在更大类型中的数组。例如，以下声明是无效的：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Even though every pointer is a complete type, it’s illegal to declare a pointer
    to an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements.
    In [Listing 17-17](chapter17.xhtml#list17-17), we define one more helper function
    to catch these invalid type specifiers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使每个指针都是完整类型，声明指向<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>元素数组的指针也是非法的。在[Listing
    17-17](chapter17.xhtml#list17-17)中，我们定义了一个额外的辅助函数来捕捉这些无效的类型说明符。
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-17: Validating type
    specifiers</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-17: 验证类型说明符</samp>'
- en: 'When we see an array type, we’ll make sure that its element type is complete
    ❶ and then validate that element type recursively. This ensures that we’ll reject
    nested arrays of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements,
    arrays of pointers to arrays of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    elements, and so on. To handle another derived type, we’ll recursively validate
    any types it refers to ❷. Non-derived types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    itself, are all valid ❸. We’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_type_specifier</samp>
    to validate type specifiers everywhere they appear: in variable declarations,
    function declarations, <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions, and cast expressions.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到一个数组类型时，我们会确保它的元素类型是完整的❶，然后递归验证该元素类型。这确保我们会拒绝包含<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>元素的嵌套数组、指向包含<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>元素的数组的指针数组，等等。为了处理另一个派生类型，我们将递归验证它所引用的任何类型❷。非派生类型，包括<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>本身，都是有效的❸。我们将在所有出现类型说明符的地方调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">validate_type_specifier</samp>来验证类型说明符：在变量声明、函数声明、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>表达式和类型转换表达式中。
- en: We’ll introduce more restrictions on incomplete types in the next chapter. For
    example, it’s illegal to use incomplete types besides <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in the branches of conditional expressions. It’s also illegal to assign to an
    lvalue with an incomplete type, but we can ignore this rule for now because there
    are no <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> lvalues, thanks
    to the rules we’ll implement next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章引入更多对不完整类型的限制。例如，除了<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>之外，在条件表达式的分支中使用不完整类型是非法的。将值赋给具有不完整类型的左值也是非法的，但由于我们将在接下来实现的规则，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>左值是不存在的，所以现在可以忽略这条规则。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extra Restrictions
    on void</samp>
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">对void的额外限制</samp>
- en: 'On top of the restrictions on all incomplete types that we just implemented,
    we’ll enforce two extra restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in particular: you can’t declare <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    variables or parameters, and you can’t dereference pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    (Both of these uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    are legal gray areas; see the box [“When void Is Valid: An Excessively Detailed
    Discussion”](#box-57) for the gory details.)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚实现的所有不完整类型的限制之外，我们还将对<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>施加两个额外的限制：你不能声明<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>变量或参数，也不能解引用指向<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>的指针。（这两种使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>的方式是合法的灰色地带；详细内容请参见框[“void何时有效：过于详细的讨论”](#box-57)。）
- en: These restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    don’t apply to other incomplete types. In the next chapter, you’ll see that you
    can declare—but not define—a variable with an incomplete structure type. You can
    then define the variable at a different point in the program, once the type is
    completed. Similarly, you can declare a function that uses an incomplete structure
    type as a parameter or return type, as long as you complete the type before you
    call or define that function. Finally, it’s legal to dereference a pointer to
    an incomplete structure type, although this isn’t terribly useful; the only thing
    you’re allowed to do with the result of the dereference is take its address, which
    just gives back the pointer you started with.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>的限制不适用于其他不完整类型。在下一章中，你将看到你可以声明——但不能定义——一个不完整结构体类型的变量。然后，你可以在程序的不同位置定义该变量，一旦该类型被完成。同样，你可以声明一个使用不完整结构体类型作为参数或返回类型的函数，只要在调用或定义该函数之前完成该类型。最后，解引用指向不完整结构体类型的指针是合法的，尽管这不是特别有用；你唯一能对解引用结果做的事情就是获取其地址，这只会返回你最初的指针。
- en: 'We’re fudging one corner case here. Strictly speaking, it’s legal to take the
    address of *any* dereferenced pointer, whether it’s a pointer to a complete type,
    an incomplete structure type, or <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    As we saw back in [Chapter 14](chapter14.xhtml), taking the address of a dereferenced
    pointer is a special case; the two operations cancel each other out and the result
    is well defined, even if the dereference expression by itself would be undefined.
    That means this code fragment is legal:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里稍微妥协了一下一个边缘情况。严格来说，获取*任何*解引用指针的地址都是合法的，无论它是指向完整类型、未完类型结构体类型还是<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>。正如我们在[第14章](chapter14.xhtml)中看到的，获取解引用指针的地址是一个特殊情况；这两个操作会互相抵消，结果是明确的，即使解引用表达式本身是未定义的。这意味着这段代码是合法的：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our compiler will reject all dereference operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> operands, even in this edge case. But we’re not alone here: GCC issues
    a warning about this code fragment and MSVC rejects it entirely. (Of course, you
    can handle this edge case correctly if you want; our test suite doesn’t cover
    it.)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编译器将拒绝对<samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>操作数的所有解引用操作，即使在这种边缘情况下也是如此。但我们并不孤单：GCC会对这段代码发出警告，MSVC则完全拒绝它。（当然，如果你想，你可以正确处理这个边缘情况；我们的测试套件没有涵盖它。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Expressions
    with void Operands</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">具有 void 操作数的条件表达式</samp>
- en: We’ll explicitly allow <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    operands in conditional expressions, as [Listing 17-18](chapter17.xhtml#list17-18)
    illustrates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将明确允许在条件表达式中使用<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>操作数，正如[清单
    17-18](chapter17.xhtml#list17-18)所示。
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-18: Type checking
    a conditional expression</samp>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 17-18：条件表达式的类型检查</samp>
- en: 'To type check a conditional expression, we first validate that its controlling
    condition is scalar ❶. Then, we consider the types of both clauses. If they’re
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, the result is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> too ❷. Otherwise, we
    find the result type as before: by applying the usual arithmetic conversions if
    both operands are arithmetic or finding their common pointer type if either is
    a pointer. If none of these cases applies—for example, because one operand is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and the other is a pointer
    or arithmetic value—we throw an error.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行条件表达式的类型检查，我们首先验证其控制条件是否为标量❶。然后，我们考虑两个子句的类型。如果它们都是<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，则结果也是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> ❷。否则，我们按照之前的方法确定结果类型：如果两个操作数都是算术类型，则应用常规的算术转换；如果其中一个是指针，则找到它们的公共指针类型。如果这些情况都不适用——例如，因为一个操作数是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>，而另一个是指针或算术值——我们将抛出错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Existing Validation
    for Arithmetic Expressions and Comparisons</samp>
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">现有的算术表达式和比较验证</samp>
- en: Next, we’ll make sure that our existing logic to type check arithmetic operations
    and comparisons works even with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in the mix. Earlier, we could assume that every expression had either arithmetic
    or pointer type. Now we can’t rely on that assumption. For example, let’s revisit
    [Listing 14-15](chapter14.xhtml#list14-15), which demonstrated how to type check
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> expressions. [Listing
    17-19](chapter17.xhtml#list17-19) reproduces that code with the extra validation
    logic that we need to add.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将确保现有的逻辑在进行算术运算和比较时，即使混入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    类型，仍能正常进行类型检查。之前，我们可以假设每个表达式要么是算术类型，要么是指针类型。但现在我们不能再依赖这个假设。例如，我们可以重新查看 [Listing
    14-15](chapter14.xhtml#list14-15)，该示例展示了如何进行 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>
    表达式的类型检查。[Listing 17-19](chapter17.xhtml#list17-19) 复现了这段代码，并加入了我们需要添加的额外验证逻辑。
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-19: Type checking
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression,
    with extra validation</samp>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-19: 带有额外验证的</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">表达式的类型检查</samp>'
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*If you compare this code to [Listing 14-15](chapter14.xhtml#list14-15), you’ll
    notice that we’ve replaced the recursive calls to typecheck_exp with typecheck_and_convert.
    We made that change back in [Chapter 15](chapter15.xhtml), so it’s not bolded
    here.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你将这段代码与 [Listing 14-15](chapter14.xhtml#list14-15) 进行比较，你会注意到我们已经将递归调用 typecheck_exp
    替换为 typecheck_and_convert。我们在 [第15章](chapter15.xhtml)中做了这个更改，因此在这里没有加粗。*'
- en: In [Chapter 14](chapter14.xhtml), if neither <samp class="SANS_TheSansMonoCd_W5Regular_11">t1</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">t2</samp> was a pointer type,
    we knew they were both arithmetic types, so we could go ahead and perform the
    usual arithmetic conversions. Now we’ll explicitly check that they’re either pointer
    or arithmetic types; if they’re anything else, we’ll fail.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第14章](chapter14.xhtml)中，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">t1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">t2</samp> 都不是指针类型，我们知道它们都是算术类型，因此可以继续执行通常的算术类型转换。现在我们将明确检查它们是否是指针类型或算术类型；如果是其他类型，则会失败。
- en: More broadly, we should type check each expression’s operands by accepting valid
    types instead of rejecting invalid ones. For example, we should validate that
    the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp> *are* arithmetic
    values, instead of making sure they *aren’t* pointers. Take a moment to look over
    your type checking logic for all the relational and arithmetic operations, tightening
    up any validation that’s too permissive.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛来说，我们应该通过接受有效类型而不是拒绝无效类型来进行每个表达式操作数的类型检查。例如，我们应该验证 <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp> 的操作数 *是* 算术值，而不是确保它们
    *不是* 指针。花点时间回顾一下你对所有关系运算和算术运算的类型检查逻辑，收紧任何过于宽松的验证。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof Expressions</samp>
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof 表达式</samp>
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>; in our implementation,
    that’s just <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.
    To type check <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, we
    first validate its operand and then record <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> as the result type, as [Listing 17-20](chapter17.xhtml#list17-20)
    demonstrates.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式的类型是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>；在我们的实现中，它就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>。为了进行 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 的类型检查，我们首先验证其操作数，然后将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 记录为结果类型，正如
    [Listing 17-20](chapter17.xhtml#list17-20) 所示。
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-20: Type checking</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-20: 类型检查</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp>'
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operates on
    a type, we enforce two rules about incomplete types that we discussed in “Restrictions
    on Incomplete Types” on [page 471](#pg_471): you can never specify an array with
    an incomplete element type ❶, and you can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to an incomplete type ❷. (You can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to a function type either, but we already catch that error in the parser.)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 操作的是一个类型，我们会强制执行两个关于不完整类型的规则，这些规则在“关于不完整类型的限制”中已经讨论过（见
    [第471页](#pg_471)）：你不能指定一个具有不完整元素类型的数组 ❶，而且不能对不完整类型应用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    ❷。（你也不能对函数类型应用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>，但我们已经在解析器中捕获了这个错误。）
- en: If the operand is an expression, we first infer that expression’s type ❸. To
    avoid converting arrays to pointers, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>.
    Once we’ve determined the expression’s type, we make sure that type is complete
    ❹.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数是一个表达式，我们首先推断该表达式的类型 ❸。为了避免将数组转换为指针，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>。一旦我们确定了表达式的类型，我们确保该类型是完整的
    ❹。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: Next, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    and void expressions to TACKY. We’ll need to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instructions
    to account for functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type. We’ll also process casts and conditional expressions of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> slightly differently from
    their non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> counterparts;
    in particular, we won’t create any <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    temporary variables. We’ll evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions during this pass as well, replacing them with integer constants. We
    won’t need to change anything to support pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 和 void 表达式转换为
    TACKY。我们需要更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> 指令，以适应返回类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的函数。我们还将稍微不同地处理类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的类型转换和条件表达式，与其非
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 对应类型相比；特别是，我们不会创建任何
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 临时变量。我们将在此步骤中评估 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 表达式，并将它们替换为整数常量。我们无需为指向
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的指针做任何更改。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with
    void Return Types</samp>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回类型为 void
    的函数</samp>'
- en: 'We’ll make two changes to the TACKY IR so that we can call and return from
    functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return
    type. First, we’ll make the destination of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction optional:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对 TACKY IR 做两项更改，以便能够调用并从返回类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的函数返回。首先，我们将使 <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> 指令的目标变为可选：
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> functions,
    we’ll leave <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> empty. For
    calls to any other function, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    will be the temporary variable that holds the return value, like it is now. We’ll
    make a similar change to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 函数的情况，我们将保持 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 为空。对于调用其他函数的情况，<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    将是一个临时变量，用于保存返回值，就像现在这样。我们将对 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令进行类似的修改：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, we’ll translate each <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with no expression to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction without a value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把每个没有表达式的 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句转换为一个没有值的 TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令。
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> function might not
    use an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement;
    in this case, it returns once control reaches the end of the function. We already
    handle this case correctly by adding a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction to the end of every TACKY function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 函数可能不会使用显式的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句；在这种情况下，当控制流到达函数末尾时，它会自动返回。我们通过在每个
    TACKY 函数的末尾添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> 指令，已经正确处理了这种情况。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Casts to void</samp>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">转换为void</samp>
- en: '[Listing 17-21](chapter17.xhtml#list17-21) shows how to handle a cast to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>: just process the inner expression
    without emitting any other instructions.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-21](chapter17.xhtml#list17-21) 显示了如何处理转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    的类型：只需处理内部表达式，而不发出其他任何指令。'
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-21: Converting a
    cast to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">to TACKY</samp>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-21：将转换为</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为 TACKY</samp>
- en: You can return whatever operand you want here; the caller won’t use it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里返回任何你想要的操作数；调用者不会使用它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Expressions
    with void Operands</samp>
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">带有 void 操作数的条件表达式</samp>
- en: '[Listing 17-22](chapter17.xhtml#list17-22) demonstrates how we currently convert
    conditional expressions to TACKY.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 17-22](chapter17.xhtml#list17-22) 演示了我们当前如何将条件表达式转换为 TACKY。'
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-22: Converting a
    non-void conditional expression to TACKY</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-22：将非 void 条件表达式转换为 TACKY</samp>
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>
    are void expressions, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions ❶❷ are problematic. We shouldn’t create a <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    temporary variable with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    and we definitely shouldn’t copy anything into it. To handle void expressions
    in conditionals, we’ll stick with the basic approach from [Listing 17-22](chapter17.xhtml#list17-22),
    but without generating <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    or emitting either <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    [Listing 17-23](chapter17.xhtml#list17-23) shows the updated pseudocode to handle
    void conditional expressions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>
    是 void 表达式，<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令 ❶❷ 就会变得有问题。我们不应该创建类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 的临时变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>，并且我们绝对不应该将任何东西复制到它里面。为了处理条件中的
    void 表达式，我们将沿用 [列表 17-22](chapter17.xhtml#list17-22) 中的基本方法，但不生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    或发出任何 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令。[列表 17-23](chapter17.xhtml#list17-23)
    显示了更新后的伪代码，用于处理 void 条件表达式。
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-23: Converting a
    conditional expression with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">result to TACKY</samp>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 17-23：将带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">结果的条件表达式转换为 TACKY</samp>
- en: Since we don’t create the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    we need to return some other operand to the caller. We can return a dummy value
    ❶ because we know the caller won’t use it. To handle non-void expressions, we’ll
    generate the same instructions as before, so I’ve omitted the pseudocode for that
    case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不创建临时变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>，我们需要将某个其他操作数返回给调用者。我们可以返回一个虚拟值
    ❶，因为我们知道调用者不会使用它。为了处理非 void 表达式，我们将生成与之前相同的指令，因此我已省略了处理该情况的伪代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof Expressions</samp>
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof 表达式</samp>
- en: We’ll evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions
    during TACKY generation and represent the results as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> constants, as [Listing 17-24](chapter17.xhtml#list17-24) illustrates.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在TACKY生成期间评估<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>表达式，并将结果表示为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>常量，正如[示例 17-24](chapter17.xhtml#list17-24)所示。
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-24: Evaluating</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">during
    TACKY generation</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 17-24: 在TACKY生成期间评估</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的过程</samp>'
- en: Since we don’t convert the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to TACKY, it won’t be evaluated at runtime.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有将<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>的操作数转换为TACKY，因此它不会在运行时被评估。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Latest and Greatest
    TACKY IR</samp>
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">最新且最强大的TACKY IR</samp>
- en: '[Listing 17-25](chapter17.xhtml#list17-25) defines the current TACKY IR, with
    this chapter’s two changes bolded.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-25](chapter17.xhtml#list17-25)定义了当前的TACKY中间表示（IR），本章中的两个更改已加粗。'
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-25: Adding support
    for functions with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">return types to the TACKY IR</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 17-25: 向TACKY IR添加对返回类型为</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的函数的支持</samp>'
- en: Most of the changes in this section—to support void casts, void conditional
    expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>—didn’t
    impact the TACKY IR. We’ll process the two instructions that did change in the
    next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的大部分更改—为了支持void类型转换、void条件表达式和<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>—没有影响TACKY
    IR。我们将在下一节处理这两条有所更改的指令。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>'
- en: To finish off the chapter, we’ll generate assembly for <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions with no value and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instructions with no destination. We can handle both instructions with minor changes
    to the assembly generation pass.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾，我们将生成没有返回值的<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令和没有目标的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>指令。我们可以通过对汇编生成过程进行一些小的修改来处理这两条指令。
- en: 'Normally, an instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp>
    is converted to the following assembly:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，形式为<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp>的指令会转换为以下汇编：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the return value is absent, we’ll skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction and just generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction. Along the same lines, [Listing 17-26](chapter17.xhtml#list17-26)
    summarizes how we usually convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction to assembly.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回值缺失，我们将跳过<samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令，只生成<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>指令。类似地，[示例 17-26](chapter17.xhtml#list17-26)总结了我们通常如何将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>指令转换为汇编。
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-26: Converting</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">FunCall</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    assembly when the function returns a value</samp>'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 17-26: 当函数返回一个值时，将</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">FunCall</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为汇编</samp>'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is absent, we won’t
    generate the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    ❶, but everything else will remain the same. [Table 17-1](chapter17.xhtml#tab17-1)
    summarizes the latest updates to the conversion from TACKY to assembly, with these
    two small changes bolded.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>缺失，我们将不会生成最后的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>指令❶，但其他部分将保持不变。[表 17-1](chapter17.xhtml#tab17-1)总结了从TACKY到汇编的最新更新，其中这两个小更改已加粗。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 17-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 17-1：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Integer</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><val type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    val, Reg(AX)) Ret</samp> |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Book_11">整数</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><val type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    val, Reg(AX)) Ret</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Double,
    val, Reg(XMM0)) Ret</samp> |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Double,
    val, Reg(XMM0)) Ret</samp> |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">void</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Ret</samp>
    |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">void</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Ret</samp>
    |'
- en: '|'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is
    present</samp> |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">存在</samp>
    |'
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is
    absent</samp> |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst</samp> <samp class="SANS_Futura_Std_Heavy_B_11">缺失</samp>
    |'
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Because the assembly AST didn’t change, we won’t touch the rest of the backend.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于汇编 AST 没有改变，我们将不再修改后端的其余部分。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you implemented the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator.
    You learned about the difference between complete and incomplete types and the
    ways that C programs can use void expressions. Then, you extended the type checker
    to detect invalid uses of incomplete and non-scalar types, modified the TACKY
    generation stage to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operators without evaluating their operands, and tweaked the backend to support
    functions that don’t return a value. Next, we’ll finish up [Part II](part2.xhtml)
    by adding structure types. Structures are the very last language feature you’ll
    implement in the book, and perhaps the most challenging. Luckily, you’re well
    prepared to take on this challenge, thanks to the skills you learned and the groundwork
    you laid in previous chapters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> 类型和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符。你学习了完整类型与不完整类型之间的差异，以及
    C 程序如何使用 void 表达式。接着，你扩展了类型检查器，检测不完整类型和非标量类型的无效使用，修改了 TACKY 生成阶段，以在不求值其操作数的情况下评估
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> 运算符，并调整了后端以支持不返回值的函数。接下来，我们将通过添加结构体类型来完成
    [第二部分](part2.xhtml)，结构体是你将在本书中实现的最后一种语言特性，也许是最具挑战性的。幸运的是，得益于你在之前章节中学到的技能和打下的基础，你已经为迎接这个挑战做好了充分准备。
