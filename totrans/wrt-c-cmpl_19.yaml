- en: '![](../images/pg456.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-41.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SUPPORTING
    DYNAMIC MEMORY ALLOCATION</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Over the course of [Part II](part2.xhtml), you’ve compiled programs that call
    an increasingly wide range of standard library functions. At the end of [Part
    I](part1.xhtml), your compiler supported only functions with parameters and return
    values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>. Now you can compile
    programs that call floating-point math functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">fmax</samp>
    and string processing functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>.
    In this chapter, you’ll implement the remaining features you need to call a particularly
    important part of the standard library: the memory management functions. These
    include <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">_alloc</samp>,
    which allocate memory dynamically; <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>,
    which deallocates dynamically allocated memory; and <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp>,
    which deallocates one block of memory and reallocates another with the same contents.'
  prefs: []
  type: TYPE_NORMAL
- en: To compile programs that declare and call these functions, you’ll need to implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. Up until now,
    we’ve used the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword
    only to specify an empty parameter list; now we’ll treat it as a proper type specifier.
    In C, <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> represents the
    address of a chunk of memory with no particular type; the standard library functions
    that allocate memory all return this type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type on its own is also useful. For instance, you can use it to declare functions
    that don’t return a value, like <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>.
    In addition to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, we’ll
    implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator,
    which gets the size of a type or object. C programs often use <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to figure out how many bytes of memory to allocate.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter’s not-so-secret agenda is to get you ready to implement structure
    types in [Chapter 18](chapter18.xhtml). Real-life C programs frequently store
    structures in dynamically allocated memory, and so do many of that chapter’s tests.
    The changes we make to the type checker will also come in handy in [Chapter 18](chapter18.xhtml)
    because some of the typing rules that apply to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    will apply to structure types too.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The void Type</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C standard (section 6.2.5, paragraph 19) gives the following rather mysterious
    definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>: “The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type comprises an empty
    set of values; it is an incomplete object type that cannot be completed.” We’ll
    talk more about what “incomplete object type” means in a moment. For now, the
    main idea is that <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> is
    a type with no values. You can’t do a whole lot with this type, but it does have
    a few uses.'
  prefs: []
  type: TYPE_NORMAL
- en: You can give a function a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type if it doesn’t return anything. To leave a function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with no expression, like in [Listing 17-1](chapter17.xhtml#list17-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-1: A function with
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return
    type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As [Listing 17-2](chapter17.xhtml#list17-2) demonstrates, you can also leave
    out the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    entirely. In that case, the function will return once you reach the end of the
    function body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-2: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *void expression* is an expression whose type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>;
    it has no value, but you can evaluate it for its side effects. There are three
    ways to produce a void expression. First, you can call a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    function. Second, you can evaluate a conditional expression whose branches are
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, you can cast a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    has no effect on program execution; its only purpose is to tell the compiler,
    and human readers, that the value of the expression should be discarded. This
    is a common way to silence compiler warnings about unused values.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re particularly zealous about following C’s typing rules, you might also
    cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> in code like
    that in [Listing 17-3](chapter17.xhtml#list17-3) to get the types of two conditional
    branches to agree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-3: A conditional
    expression with type</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we left out the cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in this conditional expression, one branch would have type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    and the other would have type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    This would be illegal, although most compilers won’t complain about it unless
    you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag
    to enable extra warnings. Our compiler will reject conditional expressions with
    one <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> branch, because
    it’s pedantic all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four places where you can use a void expression. First, it can appear
    as a clause in a conditional expression, as in [Listing 17-3](chapter17.xhtml#list17-3).
    Second, you can use it as a stand-alone expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Third, it can appear as the first or third clause of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop header, like in [Listing 17-4](chapter17.xhtml#list17-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-4: Using void expressions
    in a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop
    header</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'And fourth, you can cast a void expression to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That last one isn’t particularly useful, but it is legal.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, you can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword to specify an empty parameter list in a function declaration. This is
    a special case, since it doesn’t actually specify an expression, object, or return
    value with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. Even
    once we extend the compiler to fully support the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type, we’ll handle this particular case exactly the same way as before.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Memory Management with void *</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s look at how the memory management functions use <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> to represent allocated memory. The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument specifies
    the number of bytes to allocate. Its type, <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>,
    is an implementation-defined unsigned integer type. Under the System V x64 ABI,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp> is an alias for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. Because we don’t
    support type aliases, our test programs and examples use this declaration instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> function allocates
    a chunk of memory and returns its address. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    doesn’t know what type of object will be stored in this chunk of memory, it would
    be misleading to return a pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, or any of the other
    types we’ve seen so far. Instead, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>. You can’t read or write memory through a <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> pointer, though. So, before you can access the memory that you allocated
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, you need to
    specify what type of object it should contain by converting its address from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to a different pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert other pointer types to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> without an explicit cast. For example, you might use <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to allocate an array of 100 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you assign the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>, it’s implicitly
    converted from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp>. Then, you can subscript
    <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp> like any other
    pointer into an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp> function accepts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> argument that designates
    the chunk of memory to deallocate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This pointer must be the same value that was returned earlier by <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    or one of the other memory allocation functions. Here’s how you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">free</samp>
    to deallocate the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>
    points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function call implicitly converts the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">many_ints</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">int *</samp> back to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, resulting in the same pointer
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> returned in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">calloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">aligned_alloc</samp>
    functions provide slightly different ways to allocate memory; like <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>,
    they return pointers to the allocated space with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">realloc</samp> function
    accepts a size and a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    pointer to previously allocated storage that should now be freed, and it returns
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointer to a newly
    allocated block of storage with the new size and the original contents. For our
    purposes, the details of these functions aren’t important; the key idea is that
    they all use <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> pointers
    to identify the blocks of memory they allocate and deallocate.
  prefs: []
  type: TYPE_NORMAL
- en: 'These blocks of memory are objects that we can read and write, much like variables,
    but their lifetimes are managed differently. As we know, variables have either
    automatic storage duration (their lifetime lasts through the execution of a single
    block) or static storage duration (their lifetime lasts for the whole program).
    A block of allocated memory has *allocated storage duration*: its lifetime starts
    when it’s allocated and ends when it’s deallocated.'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler has to keep track of all the variables with static or automatic
    storage duration, record details about their size and lifetime in the symbol table,
    and reserve space for them in the data section or on the stack. But the compiler
    doesn’t need to know anything about objects with allocated storage duration, because
    the programmer and the memory management library are responsible for keeping track
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Complete and Incomplete Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An object type is *complete* if we know its size and *incomplete* if we don’t.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type is the first
    incomplete type we’ve seen. We don’t know its size because it doesn’t *have* a
    size. In the next chapter, we’ll encounter incomplete structure types, whose size
    and members aren’t visible to the compiler. Incomplete structure types can be
    completed later in the program if the compiler learns more about them. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type, on the other hand, can’t
    be completed.
  prefs: []
  type: TYPE_NORMAL
- en: The C standard states that “an incomplete type can only be used when the size
    of an object of that type is not needed” (section 6.7.2.3, footnote 132). For
    example, you can’t define a variable with an incomplete type, because you don’t
    know how much space to allocate for it. And you can’t assign to an object with
    an incomplete type or use its value, since you would need to know how many bytes
    to read or write. With a few exceptions, other incomplete types are subject to
    the same restrictions as <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    and the type checker will handle them the same way.
  prefs: []
  type: TYPE_NORMAL
- en: All pointers are complete types, even if the types they point to are incomplete;
    we know that the size of a pointer is always 8 bytes. That’s why you can declare
    variables and parameters of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp>, return <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp> values
    from functions, convert them to other pointer types, and so on. As you’ll see
    in the next chapter, you can use pointers to incomplete structure types in the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The sizeof Operator</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator accepts
    either an expression or the name of a type. When it takes a type name, it returns
    the size of that type in bytes. When it takes an expression, it returns the size
    of the expression’s type. [Listing 17-5](chapter17.xhtml#list17-5) illustrates
    both cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-5: The two uses
    of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions
    evaluate to 8 because the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> types are both
    8 bytes. Note that type names in <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions must be parenthesized, but expressions don’t need to be.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an array in a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expression, it doesn’t decay to a pointer. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expression in [Listing 17-6](chapter17.xhtml#list17-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-6: Getting the size
    of an array</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>, which
    is the size of a three-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    array, rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>, the
    size of a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: You can always determine an expression’s type—and therefore its size—without
    evaluating it. In fact, the C standard requires that we *don’t* evaluate the operand
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression. Instead,
    we infer the operand’s type and evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    at compile time. This implies that a <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expression won’t produce side effects. For example, the statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: won’t call <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>. It will
    just return <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> because the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function’s return type
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can also apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to expressions that would typically produce runtime errors, as [Listing 17-7](chapter17.xhtml#list17-7)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-7: Getting the size
    of an expression without evaluating it</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, dereferencing <samp class="SANS_TheSansMonoCd_W5Regular_11">null_ptr</samp>
    would lead to undefined behavior. But this example is well defined, because it
    will never evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp>.
    Instead, it will return <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>,
    because the compiler can determine that the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">*null_ptr</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Variable-length arrays are the one exception to this rule. The size of a variable-length
    array isn’t known at compile time, so it has to be evaluated at runtime. Because
    we don’t support variable-length arrays, we can ignore this case.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how C programs use <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>,
    let’s work on the compiler. As usual, we’ll start by updating the lexer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add one new keyword in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sizeof</samp>
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword; the lexer already recognizes it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 17-8](chapter17.xhtml#list17-8) shows this chapter’s changes to the
    AST.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-8: The abstract
    syntax tree with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements with no return value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve made four small changes here. First, we added a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type. Second, the expression in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    statement is now optional so that it can represent <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements with and without return values. Finally, there are two new expressions
    to represent the two ways you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll make the corresponding changes to the grammar. The one wrinkle
    here is that we can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to a cast expression unless that expression is parenthesized. For example, this
    is a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapping the cast expression in parentheses fixes the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This restriction makes it easier for the parser to distinguish between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operations on type names
    and on expressions. To capture this restriction in the grammar, we need to break
    out cast expressions into a separate symbol from other unary expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by refactoring type names into a symbol that we can use in both
    cast and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll define the new <samp class="SANS_TheSansMonoCd_W5Regular_11"><cast-exp></samp>
    symbol, which includes one rule for cast expressions and another for all the other
    unary expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll then update <samp class="SANS_TheSansMonoCd_W5Regular_11"><unary-exp></samp>
    to include every unary expression except for casts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The rule for unary operations like <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp> allows cast expressions
    as operands ❶, while the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    doesn’t ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll use the new <samp class="SANS_TheSansMonoCd_W5Regular_11"><cast-exp></samp>
    symbol, instead of the more restrictive <samp class="SANS_TheSansMonoCd_W5Regular_11"><unary-exp></samp>,
    to represent a single term in a binary or ternary expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 17-9](chapter17.xhtml#list17-9) gives the complete grammar for this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-9: The grammar with</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    and optional return values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_type</samp> helper function,
    which converts a list of type specifiers into a <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    AST node, should reject any declarations where the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    specifier appears alongside other type specifiers, like <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. Otherwise, the
    parser should treat <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    like any other type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type can be modified by pointer, array, and function declarators; pointers to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and functions returning
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> are both perfectly legal,
    while other ways of using <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    are syntactically valid but semantically illegal. For example, it’s a semantic
    error to declare an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    elements, define a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> variable,
    or declare a function with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    parameters. The parser won’t catch these semantic errors, but the type checker
    will.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to change your parsing logic for <samp class="SANS_TheSansMonoCd_W5Regular_11"><param-list></samp>,
    even though the grammar rule itself hasn’t changed. If the opening <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>is
    followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword,
    you’ll need to look ahead one more token. If the next token is), the parameter
    list is empty. Otherwise, the list is not empty, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    keyword is the start of a parameter declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword
    indicates an empty parameter list, we do *not* translate it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp>
    type in the AST. For example, given the function declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'the resulting AST node will have this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">params</samp> list is empty,
    just like in prior chapters; it doesn’t contain <samp class="SANS_TheSansMonoCd_W5Regular_11">Void</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s figure out how to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>.
    We’ll begin with implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and the other pointer types. These are permitted in a few cases, even
    though most implicit conversions between pointer types are not. Next, we’ll detect
    all of the new and exciting type errors that <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    can trigger. We’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operator last.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conversions to and
    from void *</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and the other pointer types are legal in three cases. First, you can
    compare a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    with another pointer type using <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, in a conditional expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><cond></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause1></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><clause2></samp>,
    one clause can have type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>
    and the other clause can have another pointer type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In both of these cases, the non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    pointer is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, you can implicitly convert to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> during assignment. You can assign a value with any pointer type to an
    object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And along the same lines, you can assign a value with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> to an object with another pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last case doesn’t just include simple assignment; it covers all the conversions
    “as if by assignment” that we talked about in [Chapter 14](chapter14.xhtml). For
    example, it’s legal to pass <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> arguments to a function that expects parameters of some other pointer
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Not coincidentally, these are the same three cases where you can implicitly
    convert a null pointer constant to some other pointer type. To support implicit
    conversions to and from <samp class="SANS_TheSansMonoCd_W5Regular_11">void *</samp>,
    we’ll extend two helper functions we defined back in [Chapter 14](chapter14.xhtml):
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit [Listing 14-14](chapter14.xhtml#list14-14), which defined <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_common_pointer_type</samp>. It’s reproduced
    here as [Listing 17-10](chapter17.xhtml#list17-10), with this chapter’s changes
    bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-10: Getting the
    common type of two expressions, where at least one has pointer type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The bolded code permits implicit conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and other pointer types but not between <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> and arithmetic types, array types, or <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Next, we’ll take another look at [Listing 14-16](chapter14.xhtml#list14-16), reproduced
    here as [Listing 17-11](chapter17.xhtml#list17-11), with changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-11: Converting an
    expression to a target type as if by assignment</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The bolded additions permit us to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> to other pointer types, and vice versa, during assignment. Note that
    nothing in this listing would prevent us from assigning a void expression to a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> target type. However,
    we’ll introduce other restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    elsewhere in the type checker that will ensure that we never call <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_by_assignment</samp>
    with a target type of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    For instance, we’ll never try to convert a function argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    because we’ll reject function declarations with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with void
    Return Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we’ll type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements with and without expressions. Which <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement you should use depends on the function’s return type. A function with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return type must not
    return an expression. A function with any other return type must include an expression
    when it returns. Therefore, these two function definitions are legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And these are both illegal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t even return a void expression from a function with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type, which makes the following example illegal too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Both GCC and Clang accept this program, but they’ll warn if you include the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag. You can handle
    this edge case however you like; the test suite doesn’t cover it.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll skip the pseudocode for this section, since it’s a pretty straightforward
    extension to our existing logic to type check <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Scalar and Non-scalar
    Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several C constructs require scalar expressions, including the operands of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> expressions; the first
    operand of a conditional expression; and the controlling conditions in loops and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The common
    thread is that all of these language constructs compare the value of the expression
    to zero. Comparing a pointer or arithmetic value to zero makes sense; comparing
    a non-scalar value to zero does not.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier chapters, there was no way to write a program that violated these
    type constraints. Arrays were our only non-scalar type, and they decay to pointers
    wherever scalar expressions are required. But once we throw <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    into the mix, we need to enforce these constraints explicitly. (Although <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> isn’t an aggregate type, it
    isn’t scalar, either. A scalar expression has a single value, but a void expression
    has *no* value.) [Listing 17-12](chapter17.xhtml#list17-12) defines a tiny helper
    function to tell us whether a type is scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-12: Checking whether
    a type is scalar</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can use this helper function to validate controlling conditions and logical
    operands. For example, [Listing 17-13](chapter17.xhtml#list17-13) illustrates
    how to validate the operand of a logical <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-13: Validating that
    a logical operand is scalar</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Cast expressions are a bit different. Except for casts between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and pointers, which we already prohibit, you can cast a scalar expression to any
    scalar type. You can also cast any type to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    [Listing 17-14](chapter17.xhtml#list17-14) shows how to type check cast expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-14: Type checking
    cast expressions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we explicitly reject casts between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and pointers. That check is snipped out of [Listing 17-14](chapter17.xhtml#list17-14),
    since it’s the same as in previous chapters. Then, we check whether the target
    type is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> ❶. If it is,
    we record that the type of the whole expression is <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    Otherwise, we validate that both the target type ❷ and the inner expression ❸
    are scalar. This rejects casts from <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    to any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> type. It
    also forbids casts to array and function types, which we already know are illegal.
  prefs: []
  type: TYPE_NORMAL
- en: The type checking logic in [Listings 17-13](chapter17.xhtml#list17-13) and [17-14](chapter17.xhtml#list17-14)
    will also apply to structures, which we’ll implement in the next chapter. Structures
    are aggregate types, but they don’t decay to pointers like arrays do. We’ll therefore
    need to validate that programs don’t use structures where scalar types are required.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restrictions on Incomplete
    Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A program will run into type errors if it uses an incomplete type where a complete
    type is required. For now, we’ll require complete types in three cases. First,
    you can’t add, subtract, or subscript pointers to incomplete types, since you
    can’t determine the sizes of the array elements they point to. Second, you can’t
    apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> to an incomplete
    type, since its size is unknown. Third, whenever you specify an array type, its
    element type must be complete.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As a language extension, Clang and GCC permit pointer arithmetic with void
    pointers and sizeof operations on void. These expressions are implemented as if
    the size of void were 1.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-15](chapter17.xhtml#list17-15) defines a couple of helper functions
    to support this validation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-15: Checking for
    incomplete types and pointers to incomplete types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp> whenever
    we need to check for a complete type. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">is_pointer_to_complete</samp>
    when we need to check for a pointer to a complete type—specifically, when we type
    check pointer addition, subtraction, and subscripting. For example, [Listing 17-16](chapter17.xhtml#list17-16)
    demonstrates how to type check pointer addition. It reproduces [Listing 15-21](chapter15.xhtml#list15-21),
    with this chapter’s changes bolded and some unchanged code omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-16: Type checking
    pointer addition, with extra validation that the pointer’s referenced type is
    complete</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll extend <samp class="SANS_TheSansMonoCd_W5Regular_11">is_complete</samp>
    to distinguish between complete and incomplete structure types too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t worry about <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    just yet; we’ll type check it a little later, in “<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    Expressions” on [page 477](#pg_477). That means we just have to handle our third
    case, by making sure that every array element type is complete. This applies to
    arrays nested in larger types too. The following declaration, for example, is
    invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Even though every pointer is a complete type, it’s illegal to declare a pointer
    to an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements.
    In [Listing 17-17](chapter17.xhtml#list17-17), we define one more helper function
    to catch these invalid type specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-17: Validating type
    specifiers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we see an array type, we’ll make sure that its element type is complete
    ❶ and then validate that element type recursively. This ensures that we’ll reject
    nested arrays of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> elements,
    arrays of pointers to arrays of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    elements, and so on. To handle another derived type, we’ll recursively validate
    any types it refers to ❷. Non-derived types, including <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    itself, are all valid ❸. We’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">validate_type_specifier</samp>
    to validate type specifiers everywhere they appear: in variable declarations,
    function declarations, <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions, and cast expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll introduce more restrictions on incomplete types in the next chapter. For
    example, it’s illegal to use incomplete types besides <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in the branches of conditional expressions. It’s also illegal to assign to an
    lvalue with an incomplete type, but we can ignore this rule for now because there
    are no <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> lvalues, thanks
    to the rules we’ll implement next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extra Restrictions
    on void</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On top of the restrictions on all incomplete types that we just implemented,
    we’ll enforce two extra restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in particular: you can’t declare <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    variables or parameters, and you can’t dereference pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    (Both of these uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    are legal gray areas; see the box [“When void Is Valid: An Excessively Detailed
    Discussion”](#box-57) for the gory details.)'
  prefs: []
  type: TYPE_NORMAL
- en: These restrictions on <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    don’t apply to other incomplete types. In the next chapter, you’ll see that you
    can declare—but not define—a variable with an incomplete structure type. You can
    then define the variable at a different point in the program, once the type is
    completed. Similarly, you can declare a function that uses an incomplete structure
    type as a parameter or return type, as long as you complete the type before you
    call or define that function. Finally, it’s legal to dereference a pointer to
    an incomplete structure type, although this isn’t terribly useful; the only thing
    you’re allowed to do with the result of the dereference is take its address, which
    just gives back the pointer you started with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re fudging one corner case here. Strictly speaking, it’s legal to take the
    address of *any* dereferenced pointer, whether it’s a pointer to a complete type,
    an incomplete structure type, or <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
    As we saw back in [Chapter 14](chapter14.xhtml), taking the address of a dereferenced
    pointer is a special case; the two operations cancel each other out and the result
    is well defined, even if the dereference expression by itself would be undefined.
    That means this code fragment is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Our compiler will reject all dereference operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    *</samp> operands, even in this edge case. But we’re not alone here: GCC issues
    a warning about this code fragment and MSVC rejects it entirely. (Of course, you
    can handle this edge case correctly if you want; our test suite doesn’t cover
    it.)'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Expressions
    with void Operands</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll explicitly allow <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    operands in conditional expressions, as [Listing 17-18](chapter17.xhtml#list17-18)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-18: Type checking
    a conditional expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To type check a conditional expression, we first validate that its controlling
    condition is scalar ❶. Then, we consider the types of both clauses. If they’re
    both <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, the result is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> too ❷. Otherwise, we
    find the result type as before: by applying the usual arithmetic conversions if
    both operands are arithmetic or finding their common pointer type if either is
    a pointer. If none of these cases applies—for example, because one operand is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> and the other is a pointer
    or arithmetic value—we throw an error.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Existing Validation
    for Arithmetic Expressions and Comparisons</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll make sure that our existing logic to type check arithmetic operations
    and comparisons works even with <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    in the mix. Earlier, we could assume that every expression had either arithmetic
    or pointer type. Now we can’t rely on that assumption. For example, let’s revisit
    [Listing 14-15](chapter14.xhtml#list14-15), which demonstrated how to type check
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp> expressions. [Listing
    17-19](chapter17.xhtml#list17-19) reproduces that code with the extra validation
    logic that we need to add.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-19: Type checking
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Equal</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expression,
    with extra validation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you compare this code to [Listing 14-15](chapter14.xhtml#list14-15), you’ll
    notice that we’ve replaced the recursive calls to typecheck_exp with typecheck_and_convert.
    We made that change back in [Chapter 15](chapter15.xhtml), so it’s not bolded
    here.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 14](chapter14.xhtml), if neither <samp class="SANS_TheSansMonoCd_W5Regular_11">t1</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">t2</samp> was a pointer type,
    we knew they were both arithmetic types, so we could go ahead and perform the
    usual arithmetic conversions. Now we’ll explicitly check that they’re either pointer
    or arithmetic types; if they’re anything else, we’ll fail.
  prefs: []
  type: TYPE_NORMAL
- en: More broadly, we should type check each expression’s operands by accepting valid
    types instead of rejecting invalid ones. For example, we should validate that
    the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp> *are* arithmetic
    values, instead of making sure they *aren’t* pointers. Take a moment to look over
    your type checking logic for all the relational and arithmetic operations, tightening
    up any validation that’s too permissive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expression has
    type <samp class="SANS_TheSansMonoCd_W5Regular_11">size_t</samp>; in our implementation,
    that’s just <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.
    To type check <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>, we
    first validate its operand and then record <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> as the result type, as [Listing 17-20](chapter17.xhtml#list17-20)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-20: Type checking</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operates on
    a type, we enforce two rules about incomplete types that we discussed in “Restrictions
    on Incomplete Types” on [page 471](#pg_471): you can never specify an array with
    an incomplete element type ❶, and you can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to an incomplete type ❷. (You can’t apply <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to a function type either, but we already catch that error in the parser.)'
  prefs: []
  type: TYPE_NORMAL
- en: If the operand is an expression, we first infer that expression’s type ❸. To
    avoid converting arrays to pointers, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_and_convert</samp>.
    Once we’ve determined the expression’s type, we make sure that type is complete
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    and void expressions to TACKY. We’ll need to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instructions
    to account for functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    return type. We’ll also process casts and conditional expressions of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp> slightly differently from
    their non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> counterparts;
    in particular, we won’t create any <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    temporary variables. We’ll evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    expressions during this pass as well, replacing them with integer constants. We
    won’t need to change anything to support pointers to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with
    void Return Types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll make two changes to the TACKY IR so that we can call and return from
    functions with a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> return
    type. First, we’ll make the destination of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> functions,
    we’ll leave <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> empty. For
    calls to any other function, <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    will be the temporary variable that holds the return value, like it is now. We’ll
    make a similar change to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Then, we’ll translate each <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement with no expression to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction without a value.
  prefs: []
  type: TYPE_NORMAL
- en: A <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> function might not
    use an explicit <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement;
    in this case, it returns once control reaches the end of the function. We already
    handle this case correctly by adding a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction to the end of every TACKY function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Casts to void</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 17-21](chapter17.xhtml#list17-21) shows how to handle a cast to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>: just process the inner expression
    without emitting any other instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-21: Converting a
    cast to</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can return whatever operand you want here; the caller won’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conditional Expressions
    with void Operands</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 17-22](chapter17.xhtml#list17-22) demonstrates how we currently convert
    conditional expressions to TACKY.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-22: Converting a
    non-void conditional expression to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">e1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp>
    are void expressions, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions ❶❷ are problematic. We shouldn’t create a <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    temporary variable with type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    and we definitely shouldn’t copy anything into it. To handle void expressions
    in conditionals, we’ll stick with the basic approach from [Listing 17-22](chapter17.xhtml#list17-22),
    but without generating <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    or emitting either <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction.
    [Listing 17-23](chapter17.xhtml#list17-23) shows the updated pseudocode to handle
    void conditional expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-23: Converting a
    conditional expression with a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">result to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t create the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>,
    we need to return some other operand to the caller. We can return a dummy value
    ❶ because we know the caller won’t use it. To handle non-void expressions, we’ll
    generate the same instructions as before, so I’ve omitted the pseudocode for that
    case.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">sizeof Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> expressions
    during TACKY generation and represent the results as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> constants, as [Listing 17-24](chapter17.xhtml#list17-24) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-24: Evaluating</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">sizeof</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">during
    TACKY generation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t convert the operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    to TACKY, it won’t be evaluated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Latest and Greatest
    TACKY IR</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 17-25](chapter17.xhtml#list17-25) defines the current TACKY IR, with
    this chapter’s two changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-25: Adding support
    for functions with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">void</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">return types to the TACKY IR</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the changes in this section—to support void casts, void conditional
    expressions, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>—didn’t
    impact the TACKY IR. We’ll process the two instructions that did change in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To finish off the chapter, we’ll generate assembly for <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instructions with no value and <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instructions with no destination. We can handle both instructions with minor changes
    to the assembly generation pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, an instruction of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp>
    is converted to the following assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the return value is absent, we’ll skip the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction and just generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>
    instruction. Along the same lines, [Listing 17-26](chapter17.xhtml#list17-26)
    summarizes how we usually convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction to assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 17-26: Converting</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">FunCall</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    assembly when the function returns a value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is absent, we won’t
    generate the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    ❶, but everything else will remain the same. [Table 17-1](chapter17.xhtml#tab17-1)
    summarizes the latest updates to the conversion from TACKY to assembly, with these
    two small changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 17-1:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Integer</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><val type></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,
    val, Reg(AX)) Ret</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(Double,
    val, Reg(XMM0)) Ret</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">void</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Ret</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_Futura_Std_Book_11">is
    present</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">dst</samp> <samp class="SANS_Futura_Std_Heavy_B_11">is
    absent</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Because the assembly AST didn’t change, we won’t touch the rest of the backend.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you implemented the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>
    type and the <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp> operator.
    You learned about the difference between complete and incomplete types and the
    ways that C programs can use void expressions. Then, you extended the type checker
    to detect invalid uses of incomplete and non-scalar types, modified the TACKY
    generation stage to evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof</samp>
    operators without evaluating their operands, and tweaked the backend to support
    functions that don’t return a value. Next, we’ll finish up [Part II](part2.xhtml)
    by adding structure types. Structures are the very last language feature you’ll
    implement in the book, and perhaps the most challenging. Luckily, you’re well
    prepared to take on this challenge, thanks to the skills you learned and the groundwork
    you laid in previous chapters.
  prefs: []
  type: TYPE_NORMAL
