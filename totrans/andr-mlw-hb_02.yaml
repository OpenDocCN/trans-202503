- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE BASICS OF ANDROID SECURITY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To understand Android malware, one has to understand the Android operating system’s
    security model. In particular, one must recognize the malware specimens that operate
    within the boundaries of this model and those that try to break out of it. This
    chapter introduces the basic concepts of Android security and malware that make
    this possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Android Security Model**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Long before the first malware was uploaded to Google Play, the Android operating
    system and security teams made several design decisions to help protect users
    from malware. For example, they reused the Linux user account system to isolate
    Android applications from each other, a choice that made it very hard for applications
    to maliciously interact with other apps or steal their data from the filesystem.
    Any malware that wanted to do so had to degrade device security using rooting
    exploits or other privilege escalation techniques of similar rarity. Likewise,
    the introduction of the app permission system proved a big step up from older
    operating systems, as it gave users more fine-grained control over what sensitive
    data and functionality applications were allowed to access.
  prefs: []
  type: TYPE_NORMAL
- en: When the first malware was found on Google Play, the threat landscape changed.
    Android was so popular by that point that malware developers were making money
    via abusive Android applications, and those who might previously have developed
    malware for other platforms started taking a serious look at Android.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to these new threats, the Android Security team focused on a defense-in-depth
    approach. Google developed critical pieces of the Android ecosystem—notably Google
    Play, the operating system, and the phone hardware (the Nexus and Pixel devices)—putting
    it in a strong defensive position. As new attacks appeared, the Android Security
    team was able to counter them by hardening the Android platform, reforming the
    rules of Google Play, and improving the application scanner that finds malicious
    functionality in the apps uploaded by Android developers.
  prefs: []
  type: TYPE_NORMAL
- en: Google built an *Android security model* that gets updated with each Android
    version, using a multilayered approach where each layer of defense tries to stop
    an attack. Even if one layer cannot completely stop an attack, the malware developer
    will have to find ways to circumvent one or more additional protection layers,
    which increases the cost and reduces the likelihood of abuse. The following sections
    explain these layers and their interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Application Isolation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first layer of the Android security model is *application isolation*. We
    mentioned that, since the very first version of Android, the operating system
    has used the Linux user account system to isolate apps and processes from each
    other. Each app is assigned a new Linux user ID (UID) without access to the private
    data or process memory of other apps.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, Google enhanced this sandboxing model with other technologies. Android
    4.3 (Jelly Bean) was the first to use Security-Enhanced Linux, more commonly known
    as SELinux. *SELinux* is a Linux kernel module used to configure access control
    security policies for different parts of the system. Although notoriously difficult
    to deploy and rarely enabled by default in other versions of Linux, it turns out
    that SELinux is uniquely powerful, making its implementation one of the most important
    Android security features protecting against privilege escalation malware. Even
    malware that uses rooting exploits to gain elevated privileges is bound by its
    access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Process isolation was improved over time, too. For example, Android 10 introduced
    *scoped storage*. Previously, all apps on an Android device shared access to the
    device’s external storage, so a file written by one app could be read by any other
    app on the device. If an app wanted to store sensitive information, it was supposed
    to use the internal storage system, where every app had its own protected space.
    Of course, many apps misbehaved and stored sensitive information in external storage.
    Spyware could easily access this information, and other apps could accidentally
    read, write, or delete it. To protect app data, scoped storage introduced access
    mechanisms similar to those used for internal storage, and now every app can safely
    store sensitive data in external storage without risking data theft or manipulation
    by other apps.
  prefs: []
  type: TYPE_NORMAL
- en: Android 11 introduced additional features to isolate apps from each other. Prior
    to Android 11, an app on a device could find information about other installed
    apps. This allowed the app to make assumptions about a user’s personal life. Android
    11 severely restricted this ability, known as *package visibility*, in the hopes
    that apps would no longer be able to identify potentially sensitive details about
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Attack Surface Reduction***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Application isolation doesn’t work against attacks that can break out of the
    Linux user space or bypass SELinux. The second layer of the Android security model
    is *attack surface reduction*, or the practice of minimizing a potential attacker’s
    access to code, APIs, services, or other parts of an app.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to reduce one’s attack surface. The most obvious is to remove
    unnecessary code, system modules, open ports, or APIs exposed to hackers; it’s
    easier to secure a system that has a small number of exposed components than one
    that has many. Similarly, reducing code complexity and size is a good secure software
    development practice. Complexity makes code hard to understand, difficult to secure,
    and easy to exploit, as the number of edge cases that a programmer has to consider
    becomes unwieldy. Less code means fewer opportunities for programming errors and
    fewer potential attack points.
  prefs: []
  type: TYPE_NORMAL
- en: If reducing complexity is not possible, making code inaccessible to exploits
    is nearly as good a strategy and is an approach the Android team has taken many
    times over the years. For example, in response to a series of vulnerabilities
    collectively known as Stagefright, the Android Security team completely refactored
    the vulnerable `mediaserver` component in Android 7.0 (Nougat) to minimize the
    number of exposed APIs. Additionally, risky code was moved into stronger custom
    sandboxes, and functionality that was not needed, like *execmem*, a dangerous
    SELinux permission to mark memory pages as executable, was removed. The 2016 Android
    Security blog post “Hardening the Media Stack” provides more details.
  prefs: []
  type: TYPE_NORMAL
- en: Another attack surface reduction technology that the Android Security team added
    was *seccomp*, introduced in Android 8.0 (Oreo). Short for *secure computing mode*,
    seccomp is a Linux technology that acts as a firewall between user-level processes
    and the kernel. Using filter rules written in Berkeley Packet Filter (BPF), it
    can block attempts by a user-level process to execute certain system calls and
    can also terminate user-level processes. Having seccomp enabled in Android removes
    system calls that would otherwise be available to apps during a privilege escalation
    attempt.
  prefs: []
  type: TYPE_NORMAL
- en: Android 9.0 (Pie) significantly reduced the potential attack surface for malicious
    apps yet again by disallowing apps from accessing internal Android API methods
    through reflection or native code. Going forward, only methods belonging to the
    public Android API remained accessible to apps. Besides improving app compatibility
    across Android versions by forcing apps to go through official APIs, this change
    was also important for security. Before this limitation was introduced, Android
    app developers were occasionally able to find ways to invoke internal APIs through
    private methods that bypassed the permission system and other restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Attack surface reduction can also take a completely different form. For example,
    according to statistics compiled by the Android Security team, the most exploited
    Android vulnerabilities to date have relied on memory corruption. Recent versions
    of Android have started shipping components written in Rust, a memory-safe programming
    language that will hopefully reduce the number of memory corruption bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Exploit Mitigation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Android is a complex, general-purpose operating system with millions of lines
    of code. No matter how much of it is deleted, made inaccessible, or sandboxed,
    there will always be opportunities for vulnerabilities to appear. Thus, many security
    teams operate under the assumption that every attacker will get lucky once; getting
    lucky twice, however, is less likely. That’s a simplified justification for Android’s
    many *exploit mitigations*, which attempt to make it harder (or impossible) for
    an attack to successfully compromise a system. The official Android Security website
    maintains a detailed list of the security enhancements introduced since Android
    1.5 at [*https://source.android.com/security/enhancements*](https://source.android.com/security/enhancements).
  prefs: []
  type: TYPE_NORMAL
- en: Early versions of Android focused on adding exploit mitigation techniques as
    a way to catch up with existing defenses in other operating systems. Before Android
    4.0 (Ice Cream Sandwich), they added defenses like address space layout randomization
    (ASLR), hardware-based No eXecute (NX), and hardening techniques for memory allocation
    and deallocation.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of these mitigation techniques meant that writing traditional exploit
    shellcode intended to run in a controlled part of memory became very difficult.
    Android’s memory layout became unpredictable, and finding executable sections
    of memory became rarer. To overcome that, attackers started chaining exploits
    that bypassed these defenses one at a time. On modern Android, such exploit chains
    are complex and often take months to develop.
  prefs: []
  type: TYPE_NORMAL
- en: '***Device Integrity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Device integrity* tries to ensure that a device is in its original intended
    state. In particular, it aims to guarantee that attackers have not planted backdoors
    or other harmful code in critical parts of the device, like its operating system.
    After a hacker bypasses all the defenses in the previous layers, they would often
    like to gain a permanent foothold in the system. Over the years, Android has made
    this harder and harder.'
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.4 (KitKat) added a technology called Verified Boot to stop malicious
    actors from modifying the bootloader. At its core, Verified Boot makes sure that
    each component of the device boot process has its integrity verified before it
    is executed. If any part of the boot process fails to verify, users are warned
    that their device has been manipulated and its security can’t be assured.
  prefs: []
  type: TYPE_NORMAL
- en: Full-disk encryption was enabled as an option in Android 5.0 (Lollipop) and
    became mandatory in Android 6.0 (Marshmallow). Android 7.0 (Nougat) additionally
    introduced file-based encryption, an improvement over full-disk encryption that
    allows different files on disk to be encrypted with different keys. File-based
    encryption became a requirement in Android 10\. While not defenses against exploits
    running on a device, full-disk encryption and file-based encryption do help protect
    against attackers that have physical access to the device and try to read data
    from or manipulate data on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: '***Permissions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fifth layer of the Android security model is *permissions*, Android’s user-facing
    consent model for controlling access to sensitive system resources and data. For
    every sensitive operation, an app has to ask the user for consent before the Android
    operating system allows the operation to proceed. For example, if an app wants
    to read information from the contact list or send a text, it needs to get the
    user’s permission first.
  prefs: []
  type: TYPE_NORMAL
- en: In early versions of Android, all permissions an app wanted to use had to be
    granted before installing the app. Users who didn’t want to grant all the requested
    permissions were unable to install the app, which was inconvenient and a common
    source of abuse and user complaints. Starting in Android 6.0 (Marshmallow), Android
    implemented a runtime permission system, where apps asked for permissions while
    they were running. This change improved app control, as users could now grant
    or deny individual, more granular permissions for sensitive operations. For example,
    if a user was comfortable with an app sending texts but not with it accessing
    their contact list, they could grant the text permission while denying the contact
    list permission.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime model also allowed apps to ask for permissions only when needed.
    If a user never tried to use an app for a sensitive operation, a well-written
    app would never ask for the related permissions. That improved user trust in well-developed
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Some permissions available to Android apps are particularly sensitive and cannot
    be granted through the default permission dialogs. For example, if an app wants
    to install other apps, the user must first go to the device settings and grant
    the app this permission. Likewise, if an app wants to use the Accessibility API,
    an API that changes parts of Android’s security model to better support users
    with disabilities, the user has to navigate through a series of warning dialogs
    first.
  prefs: []
  type: TYPE_NORMAL
- en: '***Security Updates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Android security model includes regular *security updates*. The faster these
    updates are shipped to devices and installed by users, the less time attackers
    have to exploit any discovered vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Early versions of Android were tedious to update, no matter how small a security
    update was. Updating processes and infrastructure were not yet mature, causing
    long delays between when the code was patched and when fixes were actually deployed
    to devices. Early updates were also not user-friendly. During the update process,
    users were often unable to use their phones for 10 minutes or more, lowering their
    willingness to install security updates.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, the Android operating system has made system updates much more pleasant
    for both users and device manufacturers. Updates now happen in the background
    during regular device use, and users have to reboot their devices only to complete
    the process. The architecture of the update process has also been refined. Many
    critical components that used to be updated through the system update process
    have been rewritten as standalone apps that can be updated through the normal
    Google Play app update process. One of the most important examples is the default
    WebView component used to parse and render HTML content. The code complexity of
    the parsing and rendering process makes WebView a prime attack target for hackers.
    Nowadays, if a WebView vulnerability is reported to the Android Security team
    or if an exploit is discovered in the wild, updating the Web-View component can
    happen in days rather than months.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change in architecture to allow independent updates of core components
    also made its way to the core Android operating system. In Android 8.0 (Oreo),
    Google announced Project Treble, which introduced an abstraction-layer mechanism
    to separate the operating system from modifications and extensions added by device
    manufacturers. The goal of Treble was to deliver updates for the core operating
    system faster by removing device manufacturers from the update process: manufacturers
    would be responsible for updating their additions and modifications separately,
    at their own pace.'
  prefs: []
  type: TYPE_NORMAL
- en: Android 9.0 (Pie) and Android 10 further helped original equipment manufacturers
    update more efficiently through Generic System Images, or GSIs, which sped up
    the testing of new Android versions, and Project Mainline, which allowed manufacturers
    to distribute system updates through Google Play. These changes combined made
    Android 10 the fastest deployed Android version in history, with adoption rates
    about twice that of Android 9.0 (Pie) and four times that of Android 8.0 (Oreo).
  prefs: []
  type: TYPE_NORMAL
- en: '***Add-on Security and Safety Services***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The seventh layer of the Android security model involves the add-on security
    and safety services that run on Google’s infrastructure. Depending on the service,
    these are available to either app developers or users.
  prefs: []
  type: TYPE_NORMAL
- en: The Android malware scanner that powers Google Play Protect, Google’s on-device
    malware detection and warning system, is one of these services. This scanner is
    continuously fed with app signals and decisions produced by humans and machines
    to proactively identify and block application-level threats on the device and
    on Google Play. Users can see the results of malware scans on their devices through
    the Google Play app or through the device’s security settings.
  prefs: []
  type: TYPE_NORMAL
- en: Services for developers take the form of APIs like Safe Browsing and SafetyNet.
    The Safe Browsing API protects users from malicious websites in Chrome, Firefox,
    and other browsers that have an integration with Safe Browsing technology. The
    SafetyNet API allows any application to check many integrity aspects of the device
    before executing sensitive operations like collecting user credentials or payment
    information. As these services depend on access to Google’s backend infrastructure,
    they are only available on Android-certified devices that ship with Google Play
    and the Google Play Services module.
  prefs: []
  type: TYPE_NORMAL
- en: '***Collaboration Across Google***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to improving the security and privacy posture of the Android operating
    system over the years, the Android Security team has worked with other teams at
    Google to make the platform safer to use.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Android Security has collaborated with the team responsible for
    rolling out new Google Play policies, many of which aim to make it harder for
    abusive apps to get into Google Play. In May 2017, the team clarified that an
    app must not download additional code from sources other than Google Play, as
    this technique continues to be a key malware tactic to bypass the Google Play
    malware scanners.
  prefs: []
  type: TYPE_NORMAL
- en: To give a few other examples, in August 2019 Google Play banned network proxying
    behavior for non-proxy apps in response to proxy tools selling access to user
    device resources and networks without user consent. In April 2020, Google Play
    took a stronger stance on stalkerware by mandating minimum steps that surveillance
    apps must take to limit their abuse potential. The Google Play Policy team maintains
    a website at [*https://support.google.com/googleplay/android-developer/answer/9934569*](https://support.google.com/googleplay/android-developer/answer/9934569)
    that lists changes to the Google Play policy since 2016.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sideloaded and Preloaded Malware Protection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even as the Android Security team worked to remove malware from Google Play,
    it realized that application *sideloading*, or the installation of applications
    from sources other than Google Play, was much more dangerous. According to the
    annually published *Android Security Year in Review* reports, malware is approximately
    7 to 15 times more common outside of Google Play, so focusing on Google Play is
    not enough to protect the whole Android ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: To defend against sideloaded malware, the Android Security team developed and
    launched the SafetyNet malware protection system in 2012\. This technology, which
    we mentioned previously, eventually turned into Google Play Protect. SafetyNet
    ran silently in the background on all Android devices that had the Google Play
    app. The only interaction users had with SafetyNet was when it detected malware
    on the device. Because most Android devices never have any malware installed,
    most users never interacted with SafetyNet.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Android Security team built systems to secure preloaded apps in response
    to the discovery of malware that had been preloaded on devices by various manufacturers.
    In particular, the team launched Build Test Suite (BTS) in 2018\. BTS scans the
    system image of all Android-branded devices that come with the usual bundle of
    Google apps, like Gmail, Google Play, and Google Maps. This scan is done for all
    manufacturers, regardless of how popular they are. On average, a new device ships
    with about 400 preloaded apps, and many companies are involved in building, maintaining,
    and distributing them to the manufacturers. With such a model, and without controls,
    the users of some new Android devices might be intentionally or unintentionally
    exposed to problematic apps.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Android Package**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Despite the many security enhancements Google has implemented over the years,
    malware continues to evolve, affecting many users around the globe. Today, there
    are millions of Android applications available for download from Google Play,
    websites, and other app stores. They all use a common file format, namely the
    *Android Package (APK)*, and most are written in Java.
  prefs: []
  type: TYPE_NORMAL
- en: An APK is essentially a ZIP-compressed archive file that stores the app’s code.
    Because application class files cannot be executed directly by the Android device’s
    central processing unit (CPU), they need to be compiled into Android-specific
    bytecode for execution in the Android Runtime (ART) virtual machine or its predecessor,
    Dalvik. These virtual machines exist for different hardware architectures, enabling
    applications to be run on a wide range of devices, including phones, tablets,
    laptops, watches, home appliances, TVs, car consoles, and more. The APK contains
    *.dex* files for ART or Dalvik, as well as *.so* libraries with code that is compiled
    to native assembly for specific hardware. It also includes metadata describing
    the application in a file called *AndroidManifest.xml* and the app’s electronic
    certificate, as well as other resources, such as XML code or *.png* images.
  prefs: []
  type: TYPE_NORMAL
- en: Thousands of developers, from individuals to large corporations (including Google),
    create new APKs daily to update apps with new features, patches, and services.
    Unfortunately, not all developers play by the rules. Some build applications that
    can be harmful and abuse Android’s rich API, system resources, permissions, and
    unpatched vulnerabilities to commit fraud, get access to user data, or steal user
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '**Categories of Android Malware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android Security team at Google has tracked many malware categories over
    the years. An application that exhibits the behavior of at least one of the following
    categories is considered malware, regardless of whether the developer meant to
    include harmful code in the app, and will be flagged as such by Android Security
    team members and the malware detection platform. It is important to mention that
    an application can in practice present multiple harmful or malicious behaviors
    and therefore be classified in more than one category.
  prefs: []
  type: TYPE_NORMAL
- en: Many malware categories share common characteristics. We can say that, in general,
    malware will often try to (1) avoid detection by hiding its malicious functionality
    from scanners and security analysts, (2) remain installed and avoid removal by
    the user or by security software, and (3) make money directly or indirectly, for
    example by collecting and selling user data, installing other apps, artificially
    generating clicks on ads, and abusing systems or networks reachable from the device.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe malware categories that have an impact on the
    Android ecosystem and its users.
  prefs: []
  type: TYPE_NORMAL
- en: '***Denial of Service***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Denial of service (DoS)* refers to a compromise of the availability of a device,
    system, or service. A DoS attack can be launched, for example, by exploiting a
    system integrity issue, like a stack or heap memory corruption bug, that makes
    the system crash or by overwhelming the system with a large number of requests
    than it has the resources to handle. In an attempt to process the requests, it
    might shut down or at least become unresponsive to new requests for some time.'
  prefs: []
  type: TYPE_NORMAL
- en: The consequences of a DoS attack can be severe. For example, in the case of
    systems that receive online orders or payments, any downtime might directly affect
    the business’s bottom line. Recovery from a DoS attack might also be costly, as
    it could require system upgrades, patching, new protection features and tools,
    additional capacity, and so on. For critical infrastructure like hospitals, the
    food supply chain, and utilities, a DoS attack might not only cause economic damage
    but also large-scale public safety issues.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Android, the primary DoS concern is the possibility that a
    large number of devices could become an abuse vehicle for targets selected by
    an attacker. Some DoS attacks are carried out without a user’s knowledge; in many
    cases, the user’s device is added to a *botnet*, or a set of devices under the
    control of a particular hacker, whose goal is to execute a *distributed denial-of-service
    (DDoS)* attack. In such an attack, a large number of devices that have the same
    malicious app installed might each send a high volume of HTTP requests over the
    network to a target web server. The volume of traffic is so high that the server
    is ultimately unable to process the excessive load, which ends up flooding the
    intake queue and other internal data structures. As a result, the server starts
    dropping or rejecting new requests, including legitimate ones, which practically
    takes it offline.
  prefs: []
  type: TYPE_NORMAL
- en: DDoS attacks can take various forms. In some cases, the DDoS attack is executed
    by code that comes with the app at install time. In other cases, the code containing
    the DDoS logic is dynamically fetched from a command-and-control server at execution
    time, along with data such as the target IP address, start date and time, and
    attack duration. The Android Security team has also encountered applications installed
    on many devices that use WebViews to continuously fetch and load the same resource
    over and over again, such as image files from a web server, resulting in rapid
    performance degradation and incapacity to respond. In other cases, a malicious
    app supports a variety of abuse functions that it can perform upon request by
    a remote command-and-control server. The server sends specific execution parameters
    to all devices that have the app installed.
  prefs: []
  type: TYPE_NORMAL
- en: Such attacks from mobile botnets have been very rare so far, and security companies
    have publicly documented just a few of them. However, as mobile connections across
    the world become more stable and powerful, we expect this to change. Additionally,
    *unintentional* DDoS attacks are underreported. These happen when developers hardcode
    timed connections to a web server. When an app with a timed connection becomes
    popular, each device with the app may connect to the web server at the same time.
    A smaller web server suddenly facing a million requests at midnight will easily
    run into trouble. About half of the DDoS cases identified in the past few years
    involved a mediation by the Android Security team between clumsy app developers
    and unhappy web server owners, who were unable to resolve the overwhelming number
    of connections suddenly coming from Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: '***Backdoors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *backdoor* app opens an unexpected communication channel to a command-and-control
    server, which instructs the application to execute unwanted, remote-controlled
    operations on a device. Such operations may include behavior that would otherwise
    place the app into one of the other malware categories (for example, spyware,
    phishing, or DoS).
  prefs: []
  type: TYPE_NORMAL
- en: 'Backdoor apps perform a broad range of operations, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing apps downloaded from an attacker-controlled server using elevated
    system application privileges, such as those granted to preinstalled apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rooting the device to be able to write freely to the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harvesting user information from the device, such as contact lists, device location
    data, text messages, the user’s phone number and call history, or package names
    of installed apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending text messages to premium SMS numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing sensitive data, including credentials, and asking the user to fill
    out a web form that sends the data to a fraudster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching and displaying ads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication that backdoor applications establish with command-and-control
    servers is often hidden, indirect, or protected with obfuscation or encryption
    methods. For example, some malware families use common encryption algorithms like
    AES and 3DES for encrypting data or code, Base64 or XOR for encoding, and code
    compression for obfuscation. They might evade detection through TCP port hopping
    and the use of covert channels with platforms like IRC chats, Firebase, and X
    (formerly Twitter). If the user blocks the communication channel between the command-and-control
    server and the app, the infected device can no longer be managed, so many malware
    authors make an effort to protect it as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Some backdoor applications have been known to aggressively try to achieve persistence
    on the device so that users or malware scanners cannot easily disable them. One
    approach is to rely on preinstalled applications that have backdoor logic in them.
    A more common approach, though, is to use the system privileges of a relatively
    simple preinstalled application to install a backdoor app later on and to reinstall
    the app if it detects that the backdoor has been removed. Other techniques for
    protecting the presence of malware on the device include hiding the app’s icon
    from the main screen, creating a shortcut to substitute the app’s icon, disabling
    antivirus software, and moving the application to a read-only location (such as
    */system/app*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Rooting***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Android, a *rooting* app is an unprivileged application that exploits vulnerabilities
    in the Android operating system or manufacturer-specific device components to
    gain code execution and administrator-level privileges, or status as *root*: the
    most privileged user on the system, identified by user identifier (UID) 0\. Because
    Android employs a number of controls to isolate application and operating system
    resources, including Linux filesystem permissions, process execution under separate
    UIDs, and SELinux access control policies, an unprivileged application that wishes
    to execute privileged operations must find a security hole to bypass those controls.'
  prefs: []
  type: TYPE_NORMAL
- en: Rooting applications usually rely on known Android vulnerabilities that have
    been publicly disclosed and assigned a Common Vulnerabilities and Exposures (CVE)
    ID. When left unpatched on the device, they may enable privilege escalation to
    root. The case of apps that exploit new, previously unknown vulnerabilities (that
    is, zero-day vulnerabilities), however, has become increasingly rare. Nowadays,
    they are nearly exclusively the domain of the state-sponsored actors behind a
    number of so-called advanced persistent threats (APTs).
  prefs: []
  type: TYPE_NORMAL
- en: These vulnerabilities are often memory corruption issues in Linux kernel components
    and device drivers that serve as interfaces between system services and peripherals
    and unprivileged applications. Once these components are compromised—for instance,
    through stack corruption or code injection—the attacker may be able to execute
    their code in the context of these privileged processes. When the malicious app
    gains root privileges, it may execute additional operations to achieve persistence,
    read sensitive data, or download and install other apps. For instance, the app
    may read user data from a different application’s directory; make system configuration
    changes, such as enabling app installation from third-party sources or disabling
    Google Play Protect; read authentication tokens to gain access to the user’s account;
    or inject malicious code into system runtime libraries to enable them to keep
    executing even after a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining root privileges via a malware app on the device does not automatically
    mean gaining full access to system resources. In some cases, depending on the
    Android operating system version and the device’s SELinux configuration, even
    apps running as root lack access to some of these post-rooting techniques. Even
    so, because the configuration of each device differs and may change over time,
    some rooting apps still succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Some rooting malware comes with a battery of exploits that are selectively executed
    based on certain parameters, such as the Android version running on the compromised
    device and the presence of certain device drivers. In other cases, the application
    may execute all exploits sequentially, one at a time, until one of them succeeds.
    Also, as with other malware families, the application can try to dynamically load
    malicious code at a later stage. For example, it is quite common for a rooting
    app to collect fingerprinting information about the device on which it is running
    and send it to a remote server, which responds with a device-specific exploit
    module. This keeps the rooting app adaptable to new device types. At the same
    time, the exploit developer does not have to show their hand by giving away all
    the exploits in their library.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there is a difference between nonmalicious and
    malicious rooting apps. Nonmalicious rooting apps explicitly advertise themselves
    as tools for rooting the device, and they do not execute other harmful actions
    in the background. Malicious rooting, on the other hand, occurs when the application
    does not disclose its purpose and executes rooting attempts without user consent.
    In both cases, the Android Security team will flag these apps as malware due to
    their impact on the security of the system. However, even though the execution
    of a nonmalicious rooting app may leave the system in a vulnerable state, users
    can still choose to install the app and ignore any warnings from Google Play Protect
    or other malware scanners. The Android ecosystem gives the user that flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: '***Trojans***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Trojan* apps appear to be benign (for example, they may impersonate a popular
    app) but contain hidden functionality that performs undesirable actions. These
    apps have an innocuous component used to gain user trust by giving them some useful
    features. In addition to this benign component, however, they include malicious
    logic that is invisible to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: One very common technique that the creators of trojans and other malware have
    used to evade detection is to first publish a clean APK that passes all Google
    Play checks to reach user devices. Then, some days or weeks later, they create
    and publish a new version of the APK, this time including malware functionality
    that the user will install as part of an app update. The advantage of this technique
    is that it allows a malicious app to build an installation base without fearing
    removal from Google Play or user devices. If the harmful update successfully clears
    Google Play scanning, potentially thousands of devices will install the new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious apps, including trojans, have also abused a feature available in Android
    that allows Java code to call non-Java code compiled for the device’s hardware.
    This *Java Native Interface (JNI)* lets an app load libraries usually stored in
    *.so* files, which are bundled inside the APK and may include malicious code.
    If a malware scanner inspects only Java bytecode or decompiled Java code, it may
    be blind to the malicious logic present in these hardware-specific libraries.
    In fact, we have seen malware samples that obviously use native code for no particular
    reason beyond hiding from malware scanners. For example, some malware is written
    exclusively in Java except for a minimal decryption feature written in native
    code, or even just a small native code function that does nothing but return the
    encryption key used by Java code. Static analysis engines that do not support
    cross-architecture control and data flow analysis will be stumped by such simple
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Trojan apps can perform a wide range of hidden operations. Some banking trojans,
    for example, target mobile banking users by impersonating popular apps that offer
    money transfers, check deposits, and other account services. If the user is tricked
    into downloading the fake app, they may end up giving fraudsters their account
    credentials. Other applications may wait for users to execute a legitimate banking
    app, then try to intercept usernames and passwords by using overlays on top of
    the legitimate app to display input forms that capture the user data. During authentication,
    the banking app might send a one-time password (OTP) to the user’s device; a trojan
    app might try to read those text messages.
  prefs: []
  type: TYPE_NORMAL
- en: Other trojan families manipulate online user reviews, fetching fake review text
    from a command-and-control server and then publishing it on a variety of platforms
    to artificially inflate ratings. This type of abuse also involves the creation
    of large numbers of fake user accounts to give the impression that real humans
    posted the ratings.
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years, some proxy network apps have been flagged for malware
    behavior. These proxy services allow paying customers to anonymously access online
    resources that would otherwise be protected by firewalls and IP address restrictions.
    For example, they might allow a user in country A to access a resource in country
    B. The problem with these apps is that they often fail to tell the user that their
    device will become an exit node on a proxy network or that their system’s resources
    will transport traffic (potentially connected to illegal activities) on behalf
    of others.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another type of trojan that appeared some years ago is cryptomining malware.
    These apps infect a large number of devices and use system resources, however
    limited they might be, to mine cryptocurrency in the background. In many cases,
    the mining occurs without any disclosure to the user, abusing the device’s battery
    life and processing power without their consent. In cases in which the user is
    actually aware of the mining, the financial benefit they may get is very limited.
  prefs: []
  type: TYPE_NORMAL
- en: Some trojan apps allow the attacker to manage the target device remotely. These
    share some characteristics with backdoor apps and are commonly referred to as
    *remote access trojans (RATs)*. RAT malware hides its purpose by pretending to
    be benign and often uses keyloggers, rooting, and other techniques to install
    apps, execute commands, and steal user data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Spyware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The goal of *spyware* is to find, collect, and transmit personal data without
    the consent of the user. This data can be sold to a third party or used to understand
    the user’s behavior, perhaps to offer them applications in which they might be
    interested. In the most severe spyware cases, the application may effectively
    spy on the user by accessing their physical location (whether by reading GPS data
    or through other means), photos, browsing history, search history, list of installed
    applications, text messages, and call history. Some spyware will go as far as
    activating the camera or microphone in an attempt to identify the user, observe
    their actions, or listen to their conversations.
  prefs: []
  type: TYPE_NORMAL
- en: Some spyware families target social media accounts and related application data
    stored on the device. If the data managed by an app is not encrypted at the application
    level (meaning the filesystem may be encrypted, but any application with the proper
    permissions can read the data), a spyware application might be able to siphon
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Spyware has also abused the Accessibility API, which supports powerful functions
    including launching an app, performing automated clicks, and reading text to the
    user. Some malware families have used these privileges to read WhatsApp messages
    and execute configuration changes on the system without user consent.
  prefs: []
  type: TYPE_NORMAL
- en: '***Stalkerware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Android Security team’s definition of spyware is focused on data collection
    in which the identity of the victim doesn’t matter; the collected data is resold
    in bulk or otherwise monetized without care for the affected individuals. Malware
    that is used to spy on particular, known individuals is called *stalkerware*,
    or sometimes commercial spyware or spouseware.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile applications advertised as a tool to track someone can, of course, be
    used with full consent of all involved parties. However, some of these applications
    lack proper controls and have been misused to become a staple of abusive relationships
    and can be found on millions of phones. If someone wants to keep track of their
    partner’s location or see what text messages they send and receive, a quick internet
    search for “spying on your girlfriend/boyfriend/husband/wife” reveals a thriving
    industry in which one can pay around $50 for this kind of surveillance software.
  prefs: []
  type: TYPE_NORMAL
- en: Stalkerware applications, whether free or for pay, fail to prominently notify
    the device’s owner of their presence. For example, certain apps may advertise
    themselves as parental control tools that enable family members to check on others
    and, in some cases, manage their mobile devices (for example, seeing what applications
    are installed and what URLs have been visited). But if not designed correctly,
    these applications may allow a user to spy on others surreptitiously.
  prefs: []
  type: TYPE_NORMAL
- en: Stalkers usually install stalkerware applications on the victim’s device when
    the device is left unattended. During setup, the stalker will configure the app
    using their email address or a phone number. Many commercial stalkerware products
    even offer a web-based interface. The stalkers can then take full control of the
    device from the comfort of that web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there may be legitimate use cases for some of the functionality
    offered by these apps (for instance, knowing where one’s children are), the Android
    Security team regards any app that can be used covertly to track another person
    without their knowledge or permission as malware.
  prefs: []
  type: TYPE_NORMAL
- en: '***Phishing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Phishing* applications try to steal user credentials or payment information
    by either asking the user for it or capturing the data when it is transmitted.
    They often target credit card numbers, bank account numbers, cryptocurrency wallet
    credentials, usernames, passwords, personal identification numbers (PINs), and
    other authentication factors, such as OTPs. Once the application has captured
    the data, it sends it over the network to a system under the control of a third
    party. In some cases, if captured credentials enable access to a private system
    or network, the impact might extend beyond the individual and result in large-scale
    hacking, espionage, or theft of confidential information, such as intellectual
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: Applications employ various phishing techniques. For instance, certain phishing
    apps have impersonated popular email, social network, or financial services apps
    by using similar package names, logos, and app layouts. Once launched, the application
    may immediately ask the user to enter their credentials, then tell them that there
    was an error during the login process and redirect them to the correct site. At
    that point, the damage is already done; the app will send the credentials to a
    server that centralizes the collection of stolen data, where it might get sold
    on the dark web or other underground forums. This technique has also been used
    by malware campaigns that target crypto wallet apps and phish for the user’s wallet
    credentials. These can allow the attacker to transfer funds to their own accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging and communication apps can also enable phishing. Links embedded in
    a message can put users at risk if they point to phishing or app download sites.
    Using social engineering, an attacker might convince users to follow a link, which
    is how they can end up downloading a malicious app or disclosing sensitive information
    to a fraudulent site.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that intercept credentials in transit (instead of receiving them
    directly from users) also fall within the phishing malware category. For example,
    past malware has abused a service that allows mobile carriers to send traffic
    routing configurations to mobile phones by inserting a proxy between the device
    and the carrier. An app installed on the device first extracts the device’s *International
    Mobile Subscriber Identity (IMSI)* using the Android permission `READ_PHONE_STATE`
    and communicates it to a command-and-control server. The server then sends this
    device a text with Open Mobile Alliance Client Provisioning (OMA CP) settings
    requesting that the user install a new configuration with data packet routing
    changes. As a result, the traffic generated by applications on the device—including
    email and web traffic, which may include authentication credentials, payments
    data, or other user information—will go to a proxy server controlled by a third
    party.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hostile Downloaders***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If an app is downloaded frequently, opportunities to monetize it often arise.
    This incentive has resulted in the creation of a large number of apps whose primary
    job is to install other apps. The developers of benign apps sometimes pay these
    installer apps to improve their metrics. Unfortunately, some malware developers
    use these same services. An app that does nothing harmful except download malware
    applications is considered a *hostile downloader*. This type of app has been the
    starting point of numerous malware campaigns over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Some hostile downloaders install the same set of apps every time. In other cases,
    the type and number of apps they install changes. In all cases, determining if
    an application should be considered a hostile downloader requires data about the
    type of apps installed and the number of installs. For example, some applications
    install a very small number of harmful applications, whereas others mainly distribute
    malware. The Android Security team uses different criteria to define the line
    between benign and hostile downloaders, and when an application crosses it, it
    is flagged as malware. For example, at the time of writing, if at least 5 percent
    of the app’s downloads include malware and the application has downloaded a minimum
    of 500 apps (benign or otherwise), it will be considered a hostile downloader.
    Major browsers and file sharing apps are not considered hostile downloaders, as
    long as a download requires user interaction and any malware download is initiated
    directly by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hostile downloaders typically make use of two available permissions to install
    other apps: `INSTALL_PACKAGES` and `REQUEST_INSTALL_PACKAGES`. Of these, `INSTALL_PACKAGES`
    is more powerful, because it allows an application to install other apps without
    involving the user. Given the risk of abuse, only pre-installed apps can use this
    permission.'
  prefs: []
  type: TYPE_NORMAL
- en: The more benign permission, `REQUEST_INSTALL_PACKAGES`, was introduced in Android
    8.0 (Oreo) and is available to all Android apps. This permission allows an app
    to request the installation of other apps, for instance, after the original app
    has been successfully installed. When declared in the app’s manifest file, `REQUEST_INSTALL_PACKAGES`
    will ask the user for confirmation before an `ACTION_INSTALL_PACKAGE` intent can
    be used to install an APK. This permission makes it more difficult for hostile
    downloader developers to force app installs, as it requires user intervention.
    Before Android 8.0 (Oreo) all apps had the option to start a user-consented app
    installation flow. The introduction of this new permission makes explicit to users
    which apps can be installers of other apps.
  prefs: []
  type: TYPE_NORMAL
- en: Malware developers have found ways to include apps with hostile downloader functionality
    in the system images that phone carriers and device manufacturers put in their
    products. Thus, many hostile downloaders come preinstalled on some devices. In
    addition to having special permissions and access to system resources, these preinstalled
    applications cannot be easily uninstalled. This privileged position allows a hostile
    downloader to fetch and install APKs without user intervention. One additional
    challenge with these applications is that the apps that they’ve installed may
    not be known to the manufacturer or the company responsible for building the system
    image. As a result, the user of a brand-new device may end up with a number of
    unwanted or even harmful applications.
  prefs: []
  type: TYPE_NORMAL
- en: Hostile downloaders that do not have permission to install other apps may find
    alternative ways to do it. For instance, they may try to root the device in order
    to access the filesystem and copy APKs. Then, they may try to abuse the `PackageManager`
    in some Android versions to actually install apps. Recent Android versions prevent
    the direct copying of files using absolute paths, which is what some hostile downloaders
    used to do, and require the app to use `FileProvider`, which is a more secure
    way to handle files. In some cases, if the app cannot be fetched and installed
    quickly, the hostile downloader may first download the *.apk* file using the `INTERNET`
    permission and then write it to the SD card (for example, to the *Downloads* folder)
    using `WRITE_EXTERNAL_STORAGE`. Later, in a second step, the downloader will try
    to gain the `INSTALL_PACKAGES` permission and install the files it previously
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Some hostile downloader developers may be aware of the Android Security team’s
    detection thresholds and try to stay below those levels. In some cases, to maintain
    a high number of app downloads, they might install multiple hostile downloaders
    on the same device. When that’s the case, detection methods can be adjusted to
    account for that mutation in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '***Privilege Escalation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *privilege escalation* malware category covers applications that try to
    elevate their permissions by abusing the system or exploiting vulnerabilities.
    This category covers all privilege escalation cases except rooting, which, due
    to its impact on the integrity of the system, has its own category (discussed
    previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'Four malware behaviors characterize this malware category, not all of which
    would be considered privilege escalation in other contexts. It includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications that are able to access (read, write, or execute) resources they
    originally didn’t have the privileges to access, thereby breaking the Android
    app sandbox
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications that manage to find ways to bypass permissions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications that disable security and safety features on the device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications that prevent the user from managing their device
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applications that disable security features or that modify the system’s configuration
    in a way that leaves the device in a vulnerable state are flagged as privilege
    escalation apps. An example is preinstalled applications that abuse system privileges
    (for example, the `WRITE_SECURE_SETTINGS` permission or the `Settings.Global`
    and `Settings.Secure` methods) to turn off Google Play Protect’s malware scanning
    before they self-update or download and install other malware. Other privilege
    escalation applications in the past have accomplished the same objective of disabling
    security settings by executing shell commands instead of using Android APIs, and
    a third group manipulated security settings by modifying the `package_verifier_enable`
    setting, which modifies the malware scanning behavior on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature that malware has targeted is SELinux, which complements the
    filesystem permissions model by defining policies that prevent access to sensitive
    resources regardless of the permissions a file may have. When SELinux is enabled,
    some exploits may fail, as the resulting privileges may be insufficient to access
    the resources it wants. For example, some license cracking applications that patch
    the code of gaming apps in a way that bypasses license checks and purchase verification
    need write access to the filesystem in order to create patched versions of the
    app. When the appropriate SELinux policy is enabled, such modifications are prevented,
    and malware must try to disable it as one of its first steps. It might do this,
    for instance, by running a `setenforce 0` command to turn SELinux from so-called
    *enforcing* mode to *permissive* mode. It’s worth noting that, on modern devices
    running at least Android 5.0 (Lollipop), permissive mode is supported only in
    *userdebug* and *eng* builds, which are special Android device configurations
    usually reserved for development and testing. It should not be possible to turn
    off SELinux on regular end user devices.
  prefs: []
  type: TYPE_NORMAL
- en: Some apps modify the `install_non_market_apps` setting for the purposes of privilege
    escalation. Android devices give the user the ability to install applications
    from any source. This setting, however, prevents applications from installing
    additional applications from sources other than Google Play, given that these
    sources have a higher risk of distributing malware. When an app automatically
    modifies this setting without user consent, the app will be flagged as malware,
    as it may leave the device in a vulnerable state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malware authors have also abused the device manager APIs (implemented in classes
    like `DevicePolicyManager` or `DeviceAdminReceiver`), which enable device management
    operations through a set of policies, especially for enterprise deployments, including
    resetting and expiring passwords, wiping user data partitions through factory
    reset, and requiring encryption of stored data. Malware developers have used the
    device manager APIs to prevent their apps from being removed. For example, some
    malware families observed in the wild call `resetPassword` and `lockNow` to lock
    a device when a user action triggers an `onDisableRequested` callback that will
    try to remove device admin privileges from the potentially harmful app. In other
    cases, the app may monitor user access to system settings and trigger the same
    behavior: locking the owner out.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Android 9.0 (Pie), the device manager APIs have been phased out (deprecated),
    partially in response to malware abuse, as a number of past privilege escalation
    apps used them as a vector to exercise device control without user consent. Prior
    to this, these APIs went through changes that lessened their potential for abuse.
    For example, as of Android 7.0 (Nougat) the method `resetPassword` can only be
    used to set new device passwords, not to change already existing passwords. This
    prevents users with existing device passwords from being locked out of their devices.
  prefs: []
  type: TYPE_NORMAL
- en: One final setting worth mentioning is `upload_apk_enable`. This setting controls
    whether the device shares APK samples with Google Play Protect to help identify
    malware. Malware authors may try to disable it as a means to slow down the detection
    of their apps.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that some applications rely on other applications
    to weaken the security posture of the device before executing. For instance, some
    malware families include a rooting component whose job is to weaken the security
    of the execution environment and filesystem in preparation for other applications
    actually accessing the data made available by the rooting component. Some of these
    secondary applications take advantage of the vulnerable state of the system to
    access, for instance, the *accounts.db* file, which contains tokens that allow
    the device to access a number of services. These apps might read and then send
    Google OAuth master tokens and ClientLogin tokens for Google Play. In other cases,
    file attributes are manipulated to make modification or removal more difficult,
    for example by declaring files read-only, moving them to privileged partitions,
    or making files more difficult to remove by using the `chattr` shell command to
    set `+ia` attributes on them. A file with these attributes can only be opened
    in append mode for writing; it cannot be deleted or renamed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ransomware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An app is considered *ransomware* if it takes control of the user’s data or
    device and makes demands to release this control. These demands may include the
    payment of a ransom or a request for the user to perform an action against their
    will. The two primary ransomware methods observed in the Android ecosystem are
    preventing access to the user’s data by encrypting it on the device with a key
    that the attacker controls and locking users out of their devices, either through
    the actual screen locking mechanism or by making the GUI unusable for anything
    besides the ransomware app.
  prefs: []
  type: TYPE_NORMAL
- en: Ransomware apps that encrypt user data first need to get permission to write
    to the filesystem (for example, through the `WRITE_EXTERNAL_STORAGE` permission).
    Then they can explore the filesystem, checking the status of specific files and
    directories via `getExternalStorageState`. In some cases, the app will read all
    files from external storage and write them back in encrypted form using the `java.io.File.*`
    methods and an encryption key. In other cases, only images and messages are encrypted,
    but not other file formats. In all situations, the app displays a notification
    to the user explaining how to send the payment, often requesting cryptocurrency
    to hide the perpetrator’s identity. The message also describes how the user will
    receive the decryption key and recover their files.
  prefs: []
  type: TYPE_NORMAL
- en: These applications often use standard encryption algorithms, such as AES for
    data encryption and RSA for key protection. With this approach, the AES symmetric
    key used to encrypt the files is encrypted under the attacker’s RSA public key
    and sent to a command-and-control server so that the attacker can later decrypt
    it and then send it to the user if the payment is received.
  prefs: []
  type: TYPE_NORMAL
- en: Other applications do not encrypt any data but instead block access to the device
    by displaying a ransomware note that covers the entire screen and that the user
    cannot remove. Even after a reboot, the note remains. This type of attack prevents
    the user from accessing the device’s interface, including performing actions like
    making calls or reading messages. Some apps use the `SYSTEM_ALERT_WINDOW` permission
    to display such an overlay window. First, they identify the processes running
    on the device by calling `getRunningServices`, checking process IDs on */proc*
    using the command line, or identifying the top activity via `getRunningTasks`.
    Next, they call `startActivity` to draw over other apps that are executing.
  prefs: []
  type: TYPE_NORMAL
- en: A ransomware application can also use the `BIND_DEVICE_ADMIN` permission available
    in some Android versions and then use `DevicePolicyManager` methods, like `resetPassword`
    and `lockNow`, to change the device’s password.
  prefs: []
  type: TYPE_NORMAL
- en: '***SMS Fraud***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some applications cause direct financial harm to the user. That is the case
    for malware that uses text messages to commit fraud. The *SMS fraud* category
    is composed of applications that send SMS or MMS messages to special numbers,
    called *short codes*. These are typically three- to eight-digit-long codes, such
    as 1234, that charge the user a premium when they send SMS messages to these numbers.
    Such premium messages were created for legitimate purposes, such as allowing users
    to send donations to people affected by disasters, vote for a performer on a TV
    show, or subscribe to information services delivered via text (for example, daily
    news, jokes, the weather forecast, or horoscopes). Even though carriers support
    them, the actual services may be delivered by third parties.
  prefs: []
  type: TYPE_NORMAL
- en: SMS fraud apps send text messages in an intentionally deceptive way. They abuse
    the `SEND_SMS` permission by calling APIs such as `sendTextMessage`, `sendMultimediaMessage`,
    or `sendMultipartTextMessage` without the user’s involvement and actively suppress
    any notifications to prevent detection. In some cases, it is only when the user
    reviews their phone bill that they learn about the fraudulent charges made to
    their account.
  prefs: []
  type: TYPE_NORMAL
- en: Even in cases where the destination is a regular number but there is no disclosure
    to the user of the text messages being sent, an application may be suspended for
    violating Google Play policies that protect users from SMS use without consent.
    However, when the number is a short code for premium services, the application
    will be flagged as malware, as these SMS messages directly incur a cost to users.
    Android warns the user when a premium SMS is being sent. However, this warning
    does not represent a disclosure; the application sending the message must disclose
    such activity within the app in a clear and prominent way.
  prefs: []
  type: TYPE_NORMAL
- en: SMS fraud apps sometimes come loaded with a list of premium numbers to use.
    They then check the device’s country and mobile carrier to select a specific number
    from the list. In other cases, the destination number is dynamically loaded from
    a command-and-control server, which offers the fraudster flexibility and gives
    them the ability to add new numbers.
  prefs: []
  type: TYPE_NORMAL
- en: These applications may also disguise premium SMS subscriptions by hiding disclosure
    agreements or messages from the mobile operator that notify the user of charges
    or new subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Toll Fraud***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Toll fraud* applications are those that trick users into subscribing to services
    or purchasing content via charges to their phone bill. It excludes charges generated
    by premium text messages, which have their own category (discussed in the previous
    section).'
  prefs: []
  type: TYPE_NORMAL
- en: Many payment and billing technologies allow users to buy products and subscribe
    to services by simply charging payments to their mobile phone bill, which is a
    useful solution in countries where credit or debit card usage is not widespread.
    These include direct carrier billing (DCB), Wireless Application Protocol (WAP),
    and mobile airtime transfer (MAT), which track the user’s data and airtime balance,
    their activity, and their purchases. Because they manage charges, and because
    purchases can be made relatively silently (in some cases with one click or by
    simply confirming the phone number to charge), these systems are an inviting target
    for fraudsters.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things toll fraud applications do to engage in carrier billing
    is disable the Wi-Fi connection. When the device is using a Wi-Fi network, it
    won’t use the mobile data connection managed by the carrier, such as LTE, 3G,
    or 4G. Any traffic generated by the device will flow through the user’s Wi-Fi
    access point and internet service provider (ISP) instead. Apps can disable Wi-Fi
    by, for example, using the `setWifiEnabled` API, and enable mobile data using
    the `setMobileDataEnabled` API. Once this is done, the app may open a service
    subscription web page using a WebView with JavaScript enabled, then inject JavaScript
    to auto-click buttons that complete the subscription. The service may send text
    messages to the mobile device confirming the subscription, but the toll fraud
    app will intercept those and delete them, preventing the user from becoming aware
    of the fraudulent actions.
  prefs: []
  type: TYPE_NORMAL
- en: The permissions often abused by toll fraud apps include `CHANGE_WIFI` `_STATE`,
    which is needed to switch to mobile data; `RECEIVE_SMS` or `READ_SMS`, to read
    confirmation codes or subscription alerts; and `READ_PHONE_STATE`, to obtain the
    phone number or other device identifiers needed to subscribe the user to a service.
    Recently, toll fraud apps have started to abuse the `BIND` `_NOTIFICATION_LISTENER_SERVICE`
    permission to access incoming texts after a Google Play policy change that cracked
    down on apps using texts.
  prefs: []
  type: TYPE_NORMAL
- en: The malicious code that implements the fraudulent functionality is often obfuscated
    (for example, Base64 encoded) or dynamically fetched after install to avoid detection.
  prefs: []
  type: TYPE_NORMAL
- en: '***Call Fraud***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *call fraud* malware category is composed of applications that generate
    charges on the user’s phone bill by placing phone calls to premium numbers without
    the user’s consent or knowledge. As with SMS fraud, this type of abuse relies
    on a convenient feature that many phone carriers offer: the ability to buy products
    and subscribe to services over the phone by adding them to the user’s phone bill
    for future payment. In some cases, the billing account may be linked to automated
    payments via a credit card or a bank account. When that’s the case, the user may
    not realize that they are being charged for phone calls to toll numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to hide the calls, fraudulent apps may rely on the `CALL_PHONE` permission
    to initiate them without using the Dialer user interface on the device, as this
    would visually alert the user. Still, the user could potentially hear the call.
    In order to silence the audio, some malware uses the `setStreamVolume` method
    in the `AudioManager` class, which controls the volume level of audio streams,
    to set the volume to its lowest level.
  prefs: []
  type: TYPE_NORMAL
- en: Other signs of call fraud malware include the use of permissions like `PROCESS_OUTGOING_CALLS`,
    which allows the application to retrieve the phone number being dialed, redirect
    the call, or terminate it, so that the application can close the call a few seconds
    after successfully establishing the connection and incurring the toll charge.
    They might also include the use of *call intents*, requests to the operating system
    to make phone calls, to actually perform a call based on predefined toll phone
    numbers or phone numbers dynamically received from a command-and-control server.
  prefs: []
  type: TYPE_NORMAL
- en: '***Spam***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Spam* applications send unsolicited messages to users or use the device as
    an email spam relay, often to advertise products or services.'
  prefs: []
  type: TYPE_NORMAL
- en: The list of targets to spam may come from the user’s phone directory or the
    contact lists of social networking apps like Facebook and WhatsApp. They can also
    be dynamically provided by a command-and-control server or fetched from a web
    server. Once the app has collected the list of targets, it starts sending messages
    to them silently. In some cases, this may happen via text. In other cases, the
    application may try to send messages using an API (such as the Facebook API),
    although that requires the user to be logged in. Spam malware is rare nowadays.
    We include it here for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ad Fraud***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many Android apps have the ability to fetch ads from an ad network and display
    them to the user. When an app displays an ad, a publisher and network get credit
    for that ad, a metric called an *impression*. When a user actually clicks an ad,
    advertisers generally compensate publishers for the clicks they helped produce.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where there’s a money flow, there’s the possibility of abuse. The *ad fraud*
    category includes applications that maliciously manipulate mobile ad platforms
    for financial gain. There are two main classes of ad fraud: click fraud and attribution
    fraud.'
  prefs: []
  type: TYPE_NORMAL
- en: In *click fraud*, the application fetches ads from an ad network and generates
    automated clicks without user intervention or notification. These could be in-app
    clicks simulated through Java APIs, for example, or clicks triggered via JavaScript
    code loaded into a WebView. In some cases, the app hides the ads, making them
    difficult for the user to detect, by using minimum dimensions, like 1×1 pixels.
    In other cases, the user can see the ad but does not realize that the app is producing
    click events in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic from click fraud applications ends up artificially inflating the number
    of clicks linked to an ad. The network tracks this number and communicates it
    to the advertiser, which in turn pays for these clicks, despite the fact that
    they were not driven by actual user interest. This type of malware defrauds advertisers,
    whose ad budgets and conversion rates may take a hit, eroding their trust in the
    ecosystem. Users might also be affected by click fraud when significant fake ad
    traffic wastes their mobile plan’s data budget and battery charge and irrelevant
    ads are presented to them.
  prefs: []
  type: TYPE_NORMAL
- en: The second class of ad fraud is *attribution fraud*, which occurs when an app
    tries to change the data used to attribute an ad impression or an app install
    to a referrer or publisher. For example, if an ad displayed by the app is linked
    to a referrer identifier, the ad network will track that identifier to ensure
    that the appropriate referrer is compensated. However, an attribution fraud app
    may listen for broadcast intents that include referrer identifiers and then send
    spoofed traffic to the ad network that changes the identifier. As a consequence,
    someone else will be compensated for the impressions. In some cases, the code
    that implements attribution fraud is part of a *software development kit (SDK)*,
    a set of tools that application developers may include in their apps without knowing
    that it contains code that will try to divert ad or app install credits.
  prefs: []
  type: TYPE_NORMAL
- en: Additional schemes may fit the definition of ad fraud. For example, for advertising
    networks that pay per impression, *impression fraud*, or manipulating how many
    ads are displayed and how often, can be used to drum up ad income. We have also
    seen more sophisticated schemes, such as ad networks that spy on their competitors’
    impression and click information, or ad networks that collect all the necessary
    pieces of information to perpetrate a fraud, send it to their servers, and then
    carry out the actual fraud server-side on simulated Android devices. None of these
    are covered in this book, however, as the ad fraud space is huge and, for some
    reason, the historically important ad fraud malware families on Android have all
    used click fraud or attribution fraud.
  prefs: []
  type: TYPE_NORMAL
- en: '***Non-Android Threats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Android Security team defines one last malware category: *non-Android threats*.
    These applications contain some kind of malicious behavior but cannot directly
    harm Android users. In most cases, this category is used to flag Android apps
    that contain Windows malware, nearly always because the application developer’s
    computer was infected with Windows malware at build time. The use of this category
    mainly benefits app developers, as it lets them realize that something is wrong
    with their app. Actual Android users won’t be harmed by the app’s malicious components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Up Next**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve introduced the Android security model and the malware categories
    tracked by Android Security, the next chapter will review 10 years of Android
    malware. We’ll provide examples of actual malware families and explain why the
    popularity of a malware category changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  prefs: []
  type: TYPE_NORMAL
