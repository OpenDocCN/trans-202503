- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: THE BASICS OF ANDROID SECURITY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ANDROID安全基础**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: To understand Android malware, one has to understand the Android operating system’s
    security model. In particular, one must recognize the malware specimens that operate
    within the boundaries of this model and those that try to break out of it. This
    chapter introduces the basic concepts of Android security and malware that make
    this possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Android恶意软件，必须理解Android操作系统的安全模型。特别是，必须识别在此模型边界内运行的恶意软件样本以及试图突破其限制的样本。本章介绍了使此成为可能的Android安全和恶意软件的基本概念。
- en: '**The Android Security Model**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Android安全模型**'
- en: Long before the first malware was uploaded to Google Play, the Android operating
    system and security teams made several design decisions to help protect users
    from malware. For example, they reused the Linux user account system to isolate
    Android applications from each other, a choice that made it very hard for applications
    to maliciously interact with other apps or steal their data from the filesystem.
    Any malware that wanted to do so had to degrade device security using rooting
    exploits or other privilege escalation techniques of similar rarity. Likewise,
    the introduction of the app permission system proved a big step up from older
    operating systems, as it gave users more fine-grained control over what sensitive
    data and functionality applications were allowed to access.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，第一个恶意软件上传到Google Play之前，Android操作系统和安全团队做出了几项设计决策，以帮助保护用户免受恶意软件侵害。例如，他们重用Linux用户账户系统来隔离Android应用程序，这一选择使得应用程序之间几乎无法恶意互动或从文件系统中窃取数据。任何想要这样做的恶意软件都必须使用获取root权限的漏洞利用或其他类似稀缺的特权升级技术来降低设备安全性。同样，应用权限系统的引入比旧操作系统是一大进步，因为它给予用户更精细的控制，决定哪些敏感数据和功能应用程序允许访问。
- en: When the first malware was found on Google Play, the threat landscape changed.
    Android was so popular by that point that malware developers were making money
    via abusive Android applications, and those who might previously have developed
    malware for other platforms started taking a serious look at Android.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个恶意软件在Google Play上被发现时，威胁局势发生了变化。Android已经如此流行，以至于恶意软件开发者通过滥用Android应用程序赚钱，之前可能会为其他平台开发恶意软件的人开始认真看待Android。
- en: Responding to these new threats, the Android Security team focused on a defense-in-depth
    approach. Google developed critical pieces of the Android ecosystem—notably Google
    Play, the operating system, and the phone hardware (the Nexus and Pixel devices)—putting
    it in a strong defensive position. As new attacks appeared, the Android Security
    team was able to counter them by hardening the Android platform, reforming the
    rules of Google Play, and improving the application scanner that finds malicious
    functionality in the apps uploaded by Android developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这些新威胁，Android安全团队专注于深度防御方法。Google开发了Android生态系统的关键部分，尤其是Google Play、操作系统和手机硬件（Nexus和Pixel设备），使其处于强大的防御位置。随着新攻击的出现，Android安全团队能够通过加固Android平台、改革Google
    Play的规则以及改进应用程序扫描器来发现Android开发者上传的应用程序中的恶意功能来对抗它们。
- en: Google built an *Android security model* that gets updated with each Android
    version, using a multilayered approach where each layer of defense tries to stop
    an attack. Even if one layer cannot completely stop an attack, the malware developer
    will have to find ways to circumvent one or more additional protection layers,
    which increases the cost and reduces the likelihood of abuse. The following sections
    explain these layers and their interactions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Google构建了一个*Android安全模型*，随着每个Android版本的更新而更新，采用多层防御方法，其中每一层防御都试图阻止攻击。即使一层不能完全阻止攻击，恶意软件开发者也必须找到绕过一个或多个额外保护层的方法，这增加了成本并降低了滥用的可能性。以下各节详细解释了这些层次及其互动。
- en: '***Application Isolation***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用隔离***'
- en: The first layer of the Android security model is *application isolation*. We
    mentioned that, since the very first version of Android, the operating system
    has used the Linux user account system to isolate apps and processes from each
    other. Each app is assigned a new Linux user ID (UID) without access to the private
    data or process memory of other apps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android安全模型的第一层是*应用隔离*。我们提到，从Android的第一个版本开始，操作系统就使用Linux用户账户系统来隔离应用程序和进程。每个应用程序被分配一个新的Linux用户ID（UID），无法访问其他应用程序的私有数据或进程内存。
- en: Over time, Google enhanced this sandboxing model with other technologies. Android
    4.3 (Jelly Bean) was the first to use Security-Enhanced Linux, more commonly known
    as SELinux. *SELinux* is a Linux kernel module used to configure access control
    security policies for different parts of the system. Although notoriously difficult
    to deploy and rarely enabled by default in other versions of Linux, it turns out
    that SELinux is uniquely powerful, making its implementation one of the most important
    Android security features protecting against privilege escalation malware. Even
    malware that uses rooting exploits to gain elevated privileges is bound by its
    access controls.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Google 使用其他技术增强了这种沙盒模型。Android 4.3（Jelly Bean）是第一个使用增强安全的 Linux（Security-Enhanced
    Linux，简称 SELinux）的版本。*SELinux* 是一个 Linux 内核模块，用于配置系统不同部分的访问控制安全策略。尽管它以难以部署而著称，且在其他版本的
    Linux 中默认情况下很少启用，但事实证明，SELinux 是非常强大的，它的实现成为了保护 Android 免受特权提升恶意软件攻击的重要安全特性之一。即使是利用
    root 权限漏洞获取提升特权的恶意软件，也会受到其访问控制的限制。
- en: Process isolation was improved over time, too. For example, Android 10 introduced
    *scoped storage*. Previously, all apps on an Android device shared access to the
    device’s external storage, so a file written by one app could be read by any other
    app on the device. If an app wanted to store sensitive information, it was supposed
    to use the internal storage system, where every app had its own protected space.
    Of course, many apps misbehaved and stored sensitive information in external storage.
    Spyware could easily access this information, and other apps could accidentally
    read, write, or delete it. To protect app data, scoped storage introduced access
    mechanisms similar to those used for internal storage, and now every app can safely
    store sensitive data in external storage without risking data theft or manipulation
    by other apps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进程隔离技术也随着时间的推移得到了改进。例如，Android 10 引入了*范围存储*。以前，所有 Android 设备上的应用都共享访问设备外部存储的权限，因此一个应用写入的文件可以被设备上任何其他应用读取。如果一个应用想存储敏感信息，它应该使用内部存储系统，在那里每个应用都有自己的受保护空间。当然，许多应用行为不端，将敏感信息存储在外部存储中。间谍软件很容易访问这些信息，其他应用也可能无意中读取、写入或删除这些数据。为了保护应用数据，范围存储引入了类似内部存储使用的访问机制，现在每个应用都可以安全地在外部存储中存储敏感数据，而不会被其他应用盗取或篡改。
- en: Android 11 introduced additional features to isolate apps from each other. Prior
    to Android 11, an app on a device could find information about other installed
    apps. This allowed the app to make assumptions about a user’s personal life. Android
    11 severely restricted this ability, known as *package visibility*, in the hopes
    that apps would no longer be able to identify potentially sensitive details about
    the user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android 11 引入了额外的功能来隔离应用之间的相互访问。在 Android 11 之前，设备上的应用程序可以查找其他已安装应用的信息。这使得应用程序能够对用户的个人生活做出假设。Android
    11 严格限制了这种能力，这被称为*包可见性*，希望通过这种方式，应用程序不再能够识别用户的潜在敏感信息。
- en: '***Attack Surface Reduction***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***攻击面减少***'
- en: Application isolation doesn’t work against attacks that can break out of the
    Linux user space or bypass SELinux. The second layer of the Android security model
    is *attack surface reduction*, or the practice of minimizing a potential attacker’s
    access to code, APIs, services, or other parts of an app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用隔离无法防止那些能够突破 Linux 用户空间或绕过 SELinux 的攻击。Android 安全模型的第二层是*攻击面减少*，即最大限度地减少潜在攻击者访问代码、API、服务或应用其他部分的做法。
- en: There are many ways to reduce one’s attack surface. The most obvious is to remove
    unnecessary code, system modules, open ports, or APIs exposed to hackers; it’s
    easier to secure a system that has a small number of exposed components than one
    that has many. Similarly, reducing code complexity and size is a good secure software
    development practice. Complexity makes code hard to understand, difficult to secure,
    and easy to exploit, as the number of edge cases that a programmer has to consider
    becomes unwieldy. Less code means fewer opportunities for programming errors and
    fewer potential attack points.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 减少攻击面有很多方法。最明显的做法是移除不必要的代码、系统模块、开放端口或暴露给黑客的 API；系统中暴露的组件越少，安全性就越容易提高。类似地，减少代码的复杂性和大小也是一种良好的安全软件开发实践。复杂性使得代码难以理解，难以保护，也容易被利用，因为程序员必须考虑的边缘情况变得难以控制。代码越少，编程错误的机会越少，潜在的攻击点也越少。
- en: If reducing complexity is not possible, making code inaccessible to exploits
    is nearly as good a strategy and is an approach the Android team has taken many
    times over the years. For example, in response to a series of vulnerabilities
    collectively known as Stagefright, the Android Security team completely refactored
    the vulnerable `mediaserver` component in Android 7.0 (Nougat) to minimize the
    number of exposed APIs. Additionally, risky code was moved into stronger custom
    sandboxes, and functionality that was not needed, like *execmem*, a dangerous
    SELinux permission to mark memory pages as executable, was removed. The 2016 Android
    Security blog post “Hardening the Media Stack” provides more details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法减少复杂性，使代码对漏洞利用不可访问几乎是同样有效的策略，也是 Android 团队多年来采取的做法。例如，为了应对一系列统称为 Stagefright
    的漏洞，Android 安全团队在 Android 7.0（Nougat）中彻底重构了脆弱的 `mediaserver` 组件，尽量减少暴露的 API 数量。此外，风险代码被移入更强的自定义沙箱中，且不需要的功能，如
    *execmem*（一种危险的 SELinux 权限，用于将内存页面标记为可执行）被移除。2016 年的 Android 安全博客文章《加固媒体栈》提供了更多细节。
- en: Another attack surface reduction technology that the Android Security team added
    was *seccomp*, introduced in Android 8.0 (Oreo). Short for *secure computing mode*,
    seccomp is a Linux technology that acts as a firewall between user-level processes
    and the kernel. Using filter rules written in Berkeley Packet Filter (BPF), it
    can block attempts by a user-level process to execute certain system calls and
    can also terminate user-level processes. Having seccomp enabled in Android removes
    system calls that would otherwise be available to apps during a privilege escalation
    attempt.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安全团队添加的另一项攻击面减少技术是 *seccomp*，该技术在 Android 8.0（Oreo）中引入。*seccomp* 是 *安全计算模式*
    的缩写，是一种 Linux 技术，充当用户级进程和内核之间的防火墙。通过使用伯克利数据包过滤器（BPF）编写的过滤规则，它可以阻止用户级进程执行某些系统调用，并且还可以终止用户级进程。在
    Android 中启用 seccomp 可以移除那些在权限提升尝试中本可供应用使用的系统调用。
- en: Android 9.0 (Pie) significantly reduced the potential attack surface for malicious
    apps yet again by disallowing apps from accessing internal Android API methods
    through reflection or native code. Going forward, only methods belonging to the
    public Android API remained accessible to apps. Besides improving app compatibility
    across Android versions by forcing apps to go through official APIs, this change
    was also important for security. Before this limitation was introduced, Android
    app developers were occasionally able to find ways to invoke internal APIs through
    private methods that bypassed the permission system and other restrictions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Android 9.0（Pie）通过禁止应用程序通过反射或本地代码访问内部 Android API 方法，再次显著减少了恶意应用的潜在攻击面。从此以后，只有属于公共
    Android API 的方法才能被应用程序访问。除了通过强制应用程序使用官方 API 来改善跨 Android 版本的应用兼容性外，这一变化对安全性也至关重要。在引入这一限制之前，Android
    应用开发者偶尔能够找到通过私有方法调用内部 API 的方式，这些方法绕过了权限系统和其他限制。
- en: Attack surface reduction can also take a completely different form. For example,
    according to statistics compiled by the Android Security team, the most exploited
    Android vulnerabilities to date have relied on memory corruption. Recent versions
    of Android have started shipping components written in Rust, a memory-safe programming
    language that will hopefully reduce the number of memory corruption bugs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击面减少也可以采取完全不同的形式。例如，根据 Android 安全团队汇总的统计数据，迄今为止被最广泛利用的 Android 漏洞依赖于内存损坏。近期版本的
    Android 开始引入使用 Rust 编写的组件，Rust 是一种内存安全的编程语言，预计能减少内存损坏漏洞的数量。
- en: '***Exploit Mitigation***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***漏洞利用缓解***'
- en: Android is a complex, general-purpose operating system with millions of lines
    of code. No matter how much of it is deleted, made inaccessible, or sandboxed,
    there will always be opportunities for vulnerabilities to appear. Thus, many security
    teams operate under the assumption that every attacker will get lucky once; getting
    lucky twice, however, is less likely. That’s a simplified justification for Android’s
    many *exploit mitigations*, which attempt to make it harder (or impossible) for
    an attack to successfully compromise a system. The official Android Security website
    maintains a detailed list of the security enhancements introduced since Android
    1.5 at [*https://source.android.com/security/enhancements*](https://source.android.com/security/enhancements).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Android 是一个复杂的通用操作系统，包含了数百万行代码。无论删除、使其无法访问还是将其沙盒化，总会有机会让漏洞出现。因此，许多安全团队假设每个攻击者都可能有一次运气好的机会；然而，运气好两次的可能性较小。这为
    Android 众多的*漏洞缓解措施*提供了一个简化的正当理由，这些措施旨在让攻击者更难（甚至无法）成功攻陷系统。官方的 Android 安全网站维护了自
    Android 1.5 以来引入的安全增强功能的详细列表，网址是 [*https://source.android.com/security/enhancements*](https://source.android.com/security/enhancements)。
- en: Early versions of Android focused on adding exploit mitigation techniques as
    a way to catch up with existing defenses in other operating systems. Before Android
    4.0 (Ice Cream Sandwich), they added defenses like address space layout randomization
    (ASLR), hardware-based No eXecute (NX), and hardening techniques for memory allocation
    and deallocation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的早期版本专注于添加漏洞缓解技术，以赶上其他操作系统中的现有防御措施。在 Android 4.0（Ice Cream Sandwich）之前，它们加入了地址空间布局随机化（ASLR）、基于硬件的不可执行（NX）以及内存分配和释放的加固技术等防御措施。
- en: The addition of these mitigation techniques meant that writing traditional exploit
    shellcode intended to run in a controlled part of memory became very difficult.
    Android’s memory layout became unpredictable, and finding executable sections
    of memory became rarer. To overcome that, attackers started chaining exploits
    that bypassed these defenses one at a time. On modern Android, such exploit chains
    are complex and often take months to develop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缓解技术的加入意味着，编写传统的利用 shellcode（旨在运行在受控内存区域中的恶意代码）变得非常困难。Android 的内存布局变得不可预测，找到可执行的内存区域变得更加稀少。为了应对这一点，攻击者开始串联利用漏洞，逐个绕过这些防御。在现代
    Android 系统中，这样的漏洞链条非常复杂，通常需要几个月的时间来开发。
- en: '***Device Integrity***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设备完整性***'
- en: '*Device integrity* tries to ensure that a device is in its original intended
    state. In particular, it aims to guarantee that attackers have not planted backdoors
    or other harmful code in critical parts of the device, like its operating system.
    After a hacker bypasses all the defenses in the previous layers, they would often
    like to gain a permanent foothold in the system. Over the years, Android has made
    this harder and harder.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*设备完整性*尝试确保设备处于其原始预定状态。特别是，它旨在确保攻击者没有在设备的关键部分（如操作系统）植入后门或其他有害代码。当黑客绕过了前面各层的所有防御后，他们通常希望在系统中获得一个永久的立足点。多年来，Android
    一直在让这一过程变得越来越困难。'
- en: Android 4.4 (KitKat) added a technology called Verified Boot to stop malicious
    actors from modifying the bootloader. At its core, Verified Boot makes sure that
    each component of the device boot process has its integrity verified before it
    is executed. If any part of the boot process fails to verify, users are warned
    that their device has been manipulated and its security can’t be assured.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.4（KitKat）引入了一项名为“验证启动”（Verified Boot）的技术，旨在阻止恶意行为者修改启动加载程序。验证启动的核心原理是，在执行设备启动过程的每个组件之前，都要确保其完整性已得到验证。如果启动过程中的任何部分未能通过验证，用户会收到警告，提示设备已被篡改，安全性无法得到保障。
- en: Full-disk encryption was enabled as an option in Android 5.0 (Lollipop) and
    became mandatory in Android 6.0 (Marshmallow). Android 7.0 (Nougat) additionally
    introduced file-based encryption, an improvement over full-disk encryption that
    allows different files on disk to be encrypted with different keys. File-based
    encryption became a requirement in Android 10\. While not defenses against exploits
    running on a device, full-disk encryption and file-based encryption do help protect
    against attackers that have physical access to the device and try to read data
    from or manipulate data on the disk.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 全磁盘加密在 Android 5.0（Lollipop）中作为选项启用，并在 Android 6.0（Marshmallow）中成为强制性要求。Android
    7.0（Nougat）进一步引入了基于文件的加密，这是对全磁盘加密的改进，允许磁盘上的不同文件使用不同的密钥进行加密。基于文件的加密在 Android 10
    中成为强制要求。虽然它们不是防止设备上运行的漏洞攻击的防御手段，但全磁盘加密和基于文件的加密确实有助于防止攻击者在物理访问设备的情况下试图读取磁盘上的数据或篡改数据。
- en: '***Permissions***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***权限***'
- en: The fifth layer of the Android security model is *permissions*, Android’s user-facing
    consent model for controlling access to sensitive system resources and data. For
    every sensitive operation, an app has to ask the user for consent before the Android
    operating system allows the operation to proceed. For example, if an app wants
    to read information from the contact list or send a text, it needs to get the
    user’s permission first.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安全模型的第五层是*权限*，它是 Android 用于控制访问敏感系统资源和数据的用户同意模型。对于每个敏感操作，应用必须在 Android
    操作系统允许操作继续进行之前请求用户同意。例如，如果一个应用想要读取联系人列表的信息或发送短信，它需要首先获得用户的许可。
- en: In early versions of Android, all permissions an app wanted to use had to be
    granted before installing the app. Users who didn’t want to grant all the requested
    permissions were unable to install the app, which was inconvenient and a common
    source of abuse and user complaints. Starting in Android 6.0 (Marshmallow), Android
    implemented a runtime permission system, where apps asked for permissions while
    they were running. This change improved app control, as users could now grant
    or deny individual, more granular permissions for sensitive operations. For example,
    if a user was comfortable with an app sending texts but not with it accessing
    their contact list, they could grant the text permission while denying the contact
    list permission.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的 Android 中，应用想要使用的所有权限必须在安装应用之前授予。那些不想授予所有请求权限的用户无法安装应用，这既不方便，也是滥用和用户投诉的常见来源。从
    Android 6.0（Marshmallow）开始，Android 实现了运行时权限系统，应用在运行时请求权限。这一变化提高了应用控制，因为用户现在可以为敏感操作授予或拒绝单个、更细粒度的权限。例如，如果用户愿意让应用发送短信，但不希望其访问联系人列表，他们可以授予短信权限，同时拒绝联系人列表权限。
- en: The runtime model also allowed apps to ask for permissions only when needed.
    If a user never tried to use an app for a sensitive operation, a well-written
    app would never ask for the related permissions. That improved user trust in well-developed
    apps.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时模型还允许应用仅在需要时请求权限。如果用户从未尝试使用某个应用进行敏感操作，一个编写良好的应用将永远不会请求相关权限。这提高了用户对开发良好的应用的信任。
- en: Some permissions available to Android apps are particularly sensitive and cannot
    be granted through the default permission dialogs. For example, if an app wants
    to install other apps, the user must first go to the device settings and grant
    the app this permission. Likewise, if an app wants to use the Accessibility API,
    an API that changes parts of Android’s security model to better support users
    with disabilities, the user has to navigate through a series of warning dialogs
    first.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Android 应用可用的权限尤其敏感，无法通过默认的权限对话框授予。例如，如果一个应用想要安装其他应用，用户必须首先进入设备设置并授予该应用此权限。同样，如果一个应用想要使用无障碍
    API，该 API 会改变 Android 安全模型的某些部分，以更好地支持残障用户，用户必须首先通过一系列警告对话框。
- en: '***Security Updates***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全更新***'
- en: The Android security model includes regular *security updates*. The faster these
    updates are shipped to devices and installed by users, the less time attackers
    have to exploit any discovered vulnerabilities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安全模型包括常规的*安全更新*。这些更新越快地推送到设备并被用户安装，攻击者利用已发现漏洞的时间就越少。
- en: Early versions of Android were tedious to update, no matter how small a security
    update was. Updating processes and infrastructure were not yet mature, causing
    long delays between when the code was patched and when fixes were actually deployed
    to devices. Early updates were also not user-friendly. During the update process,
    users were often unable to use their phones for 10 minutes or more, lowering their
    willingness to install security updates.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的早期版本在更新时非常繁琐，无论安全更新多么小。更新流程和基础设施尚未成熟，导致从修补代码到实际部署到设备之间存在长时间的延迟。早期的更新也不够用户友好。在更新过程中，用户往往无法使用手机超过
    10 分钟，降低了他们安装安全更新的意愿。
- en: Over time, the Android operating system has made system updates much more pleasant
    for both users and device manufacturers. Updates now happen in the background
    during regular device use, and users have to reboot their devices only to complete
    the process. The architecture of the update process has also been refined. Many
    critical components that used to be updated through the system update process
    have been rewritten as standalone apps that can be updated through the normal
    Google Play app update process. One of the most important examples is the default
    WebView component used to parse and render HTML content. The code complexity of
    the parsing and rendering process makes WebView a prime attack target for hackers.
    Nowadays, if a WebView vulnerability is reported to the Android Security team
    or if an exploit is discovered in the wild, updating the Web-View component can
    happen in days rather than months.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Android 操作系统使系统更新变得更加便捷，不仅用户体验更好，设备制造商也受益。更新现在可以在设备正常使用时在后台进行，用户只需重启设备来完成更新过程。更新流程的架构也得到了精细化改进。许多以前通过系统更新流程更新的关键组件，现在已经被重写成独立的应用程序，可以通过正常的
    Google Play 应用更新流程进行更新。一个重要的例子就是默认的 WebView 组件，它用于解析和渲染 HTML 内容。解析和渲染过程的代码复杂性使得
    WebView 成为黑客攻击的重点目标。如今，如果 WebView 漏洞被报告给 Android 安全团队，或者在网络中发现了漏洞，更新 WebView 组件的时间可以从几个月缩短到几天。
- en: 'This change in architecture to allow independent updates of core components
    also made its way to the core Android operating system. In Android 8.0 (Oreo),
    Google announced Project Treble, which introduced an abstraction-layer mechanism
    to separate the operating system from modifications and extensions added by device
    manufacturers. The goal of Treble was to deliver updates for the core operating
    system faster by removing device manufacturers from the update process: manufacturers
    would be responsible for updating their additions and modifications separately,
    at their own pace.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 允许核心组件独立更新的架构变化同样影响到了核心 Android 操作系统。在 Android 8.0 (Oreo) 中，Google 宣布了 Project
    Treble，它引入了一种抽象层机制，将操作系统与设备制造商添加的修改和扩展分离。Treble 的目标是通过将设备制造商从更新流程中移除，使核心操作系统能够更快地进行更新：制造商将负责独立更新其自定义的部分，并按自己的节奏进行。
- en: Android 9.0 (Pie) and Android 10 further helped original equipment manufacturers
    update more efficiently through Generic System Images, or GSIs, which sped up
    the testing of new Android versions, and Project Mainline, which allowed manufacturers
    to distribute system updates through Google Play. These changes combined made
    Android 10 the fastest deployed Android version in history, with adoption rates
    about twice that of Android 9.0 (Pie) and four times that of Android 8.0 (Oreo).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Android 9.0 (Pie) 和 Android 10 通过通用系统映像（Generic System Images，简称 GSI）进一步帮助原始设备制造商更高效地更新系统，这加快了新
    Android 版本的测试进程；同时，Project Mainline 使得制造商可以通过 Google Play 分发系统更新。这些变化使得 Android
    10 成为历史上部署最快的 Android 版本，其采用率约是 Android 9.0 (Pie) 的两倍，Android 8.0 (Oreo) 的四倍。
- en: '***Add-on Security and Safety Services***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***附加安全和安全服务***'
- en: The seventh layer of the Android security model involves the add-on security
    and safety services that run on Google’s infrastructure. Depending on the service,
    these are available to either app developers or users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安全模型的第七层涉及运行在 Google 基础设施上的附加安全和安全服务。根据服务的不同，这些服务可供应用开发者或用户使用。
- en: The Android malware scanner that powers Google Play Protect, Google’s on-device
    malware detection and warning system, is one of these services. This scanner is
    continuously fed with app signals and decisions produced by humans and machines
    to proactively identify and block application-level threats on the device and
    on Google Play. Users can see the results of malware scans on their devices through
    the Google Play app or through the device’s security settings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为Google Play Protect提供支持的Android恶意软件扫描器是这些服务之一。Google Play Protect是Google的设备端恶意软件检测和警告系统，该扫描器会持续接收来自人类和机器的应用信号和决策，以主动识别并阻止设备和Google
    Play上的应用级威胁。用户可以通过Google Play应用或设备的安全设置查看恶意软件扫描的结果。
- en: Services for developers take the form of APIs like Safe Browsing and SafetyNet.
    The Safe Browsing API protects users from malicious websites in Chrome, Firefox,
    and other browsers that have an integration with Safe Browsing technology. The
    SafetyNet API allows any application to check many integrity aspects of the device
    before executing sensitive operations like collecting user credentials or payment
    information. As these services depend on access to Google’s backend infrastructure,
    they are only available on Android-certified devices that ship with Google Play
    and the Google Play Services module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 面向开发者的服务包括像“安全浏览”和“SafetyNet”这样的API。安全浏览API可以保护用户免受Chrome、Firefox以及其他集成了安全浏览技术的浏览器中恶意网站的侵害。SafetyNet
    API允许任何应用在执行敏感操作（如收集用户凭证或支付信息）之前，检查设备的多个完整性方面。由于这些服务依赖于访问Google的后台基础设施，因此它们仅在配备了Google
    Play和Google Play服务模块的Android认证设备上可用。
- en: '***Collaboration Across Google***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跨Google的合作***'
- en: In addition to improving the security and privacy posture of the Android operating
    system over the years, the Android Security team has worked with other teams at
    Google to make the platform safer to use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了多年来不断提升Android操作系统的安全性和隐私保护外，Android安全团队还与Google的其他团队合作，致力于使平台使用起来更安全。
- en: For example, Android Security has collaborated with the team responsible for
    rolling out new Google Play policies, many of which aim to make it harder for
    abusive apps to get into Google Play. In May 2017, the team clarified that an
    app must not download additional code from sources other than Google Play, as
    this technique continues to be a key malware tactic to bypass the Google Play
    malware scanners.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Android安全团队与负责推出新Google Play政策的团队进行合作，许多政策旨在让恶意应用更难进入Google Play。2017年5月，团队明确表示，应用不得从Google
    Play以外的来源下载额外的代码，因为这种技术仍然是绕过Google Play恶意软件扫描器的关键恶意软件手段。
- en: To give a few other examples, in August 2019 Google Play banned network proxying
    behavior for non-proxy apps in response to proxy tools selling access to user
    device resources and networks without user consent. In April 2020, Google Play
    took a stronger stance on stalkerware by mandating minimum steps that surveillance
    apps must take to limit their abuse potential. The Google Play Policy team maintains
    a website at [*https://support.google.com/googleplay/android-developer/answer/9934569*](https://support.google.com/googleplay/android-developer/answer/9934569)
    that lists changes to the Google Play policy since 2016.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 举几个其他例子，2019年8月，Google Play禁止了非代理应用的网络代理行为，以应对代理工具在未经用户同意的情况下销售访问用户设备资源和网络的行为。2020年4月，Google
    Play在应对跟踪软件时采取了更为严格的立场，要求监控应用必须采取最低步骤以限制其滥用潜力。Google Play政策团队维护着一个网站，[*https://support.google.com/googleplay/android-developer/answer/9934569*](https://support.google.com/googleplay/android-developer/answer/9934569)，该网站列出了自2016年以来Google
    Play政策的变更。
- en: '***Sideloaded and Preloaded Malware Protection***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***旁加载和预加载恶意软件保护***'
- en: Even as the Android Security team worked to remove malware from Google Play,
    it realized that application *sideloading*, or the installation of applications
    from sources other than Google Play, was much more dangerous. According to the
    annually published *Android Security Year in Review* reports, malware is approximately
    7 to 15 times more common outside of Google Play, so focusing on Google Play is
    not enough to protect the whole Android ecosystem.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Android安全团队致力于清除Google Play中的恶意软件，它也意识到应用*旁加载*，即从Google Play以外的来源安装应用，远比恶意软件更具危险性。根据每年发布的*Android安全年度回顾*报告，恶意软件在Google
    Play外的出现频率约为Google Play的7到15倍，因此仅仅专注于Google Play不足以保护整个Android生态系统。
- en: To defend against sideloaded malware, the Android Security team developed and
    launched the SafetyNet malware protection system in 2012\. This technology, which
    we mentioned previously, eventually turned into Google Play Protect. SafetyNet
    ran silently in the background on all Android devices that had the Google Play
    app. The only interaction users had with SafetyNet was when it detected malware
    on the device. Because most Android devices never have any malware installed,
    most users never interacted with SafetyNet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '为了防御侧载恶意软件，Android 安全团队在 2012 年开发并推出了 SafetyNet 恶意软件防护系统。我们之前提到过的这项技术最终演变成了
    Google Play Protect。SafetyNet 在所有安装了 Google Play 应用的 Android 设备上默默运行。用户与 SafetyNet
    唯一的互动就是当它检测到设备上的恶意软件时。因为大多数 Android 设备从未安装过恶意软件，所以大多数用户从未与 SafetyNet 互动过。  '
- en: Next, the Android Security team built systems to secure preloaded apps in response
    to the discovery of malware that had been preloaded on devices by various manufacturers.
    In particular, the team launched Build Test Suite (BTS) in 2018\. BTS scans the
    system image of all Android-branded devices that come with the usual bundle of
    Google apps, like Gmail, Google Play, and Google Maps. This scan is done for all
    manufacturers, regardless of how popular they are. On average, a new device ships
    with about 400 preloaded apps, and many companies are involved in building, maintaining,
    and distributing them to the manufacturers. With such a model, and without controls,
    the users of some new Android devices might be intentionally or unintentionally
    exposed to problematic apps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，Android 安全团队建立了保护预装应用的系统，以应对一些厂商在设备上预装恶意软件的发现。特别是，团队在 2018 年推出了 Build Test
    Suite（BTS）。BTS 会扫描所有预装了常见 Google 应用（如 Gmail、Google Play 和 Google Maps）的 Android
    品牌设备的系统映像。这项扫描适用于所有厂商，无论其受欢迎程度如何。平均而言，一款新设备会预装约 400 个应用，许多公司参与了这些应用的构建、维护和分发。采用这种模式且没有适当控制的情况下，一些新
    Android 设备的用户可能会有意或无意地接触到问题应用。  '
- en: '**The Android Package**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Android 包**  '
- en: Despite the many security enhancements Google has implemented over the years,
    malware continues to evolve, affecting many users around the globe. Today, there
    are millions of Android applications available for download from Google Play,
    websites, and other app stores. They all use a common file format, namely the
    *Android Package (APK)*, and most are written in Java.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Google 多年来实施了许多安全增强措施，恶意软件仍在不断演变，影响着全球众多用户。如今，有数百万个 Android 应用可以从 Google
    Play、网站和其他应用商店下载。它们都使用一种通用的文件格式，即 *Android 包（APK）*，而且大多数是用 Java 编写的。
- en: An APK is essentially a ZIP-compressed archive file that stores the app’s code.
    Because application class files cannot be executed directly by the Android device’s
    central processing unit (CPU), they need to be compiled into Android-specific
    bytecode for execution in the Android Runtime (ART) virtual machine or its predecessor,
    Dalvik. These virtual machines exist for different hardware architectures, enabling
    applications to be run on a wide range of devices, including phones, tablets,
    laptops, watches, home appliances, TVs, car consoles, and more. The APK contains
    *.dex* files for ART or Dalvik, as well as *.so* libraries with code that is compiled
    to native assembly for specific hardware. It also includes metadata describing
    the application in a file called *AndroidManifest.xml* and the app’s electronic
    certificate, as well as other resources, such as XML code or *.png* images.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'APK 本质上是一个 ZIP 压缩的归档文件，存储着应用的代码。由于应用的类文件不能直接由 Android 设备的中央处理器（CPU）执行，它们需要被编译成
    Android 特定的字节码，以便在 Android 运行时（ART）虚拟机或其前身 Dalvik 中执行。这些虚拟机为不同的硬件架构存在，使得应用能够在各种设备上运行，包括手机、平板、笔记本电脑、手表、家用电器、电视、车载控制台等。APK
    包含供 ART 或 Dalvik 使用的 *.dex* 文件，还包含将代码编译成针对特定硬件的本地汇编语言的 *.so* 库文件。它还包括一个名为 *AndroidManifest.xml*
    的文件，描述应用的元数据，以及应用的电子证书和其他资源，如 XML 代码或 *.png* 图像。  '
- en: Thousands of developers, from individuals to large corporations (including Google),
    create new APKs daily to update apps with new features, patches, and services.
    Unfortunately, not all developers play by the rules. Some build applications that
    can be harmful and abuse Android’s rich API, system resources, permissions, and
    unpatched vulnerabilities to commit fraud, get access to user data, or steal user
    credentials.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 成千上万的开发者，从个人到大型企业（包括谷歌），每天都会创建新的APK来更新应用，增加新功能、修复漏洞和提供新服务。不幸的是，并非所有开发者都遵守规则。有些开发者构建的应用可能会有害，滥用安卓的丰富API、系统资源、权限和未修补的漏洞，从事欺诈行为、获取用户数据或窃取用户凭证。
- en: '**Categories of Android Malware**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**安卓恶意软件的分类**'
- en: The Android Security team at Google has tracked many malware categories over
    the years. An application that exhibits the behavior of at least one of the following
    categories is considered malware, regardless of whether the developer meant to
    include harmful code in the app, and will be flagged as such by Android Security
    team members and the malware detection platform. It is important to mention that
    an application can in practice present multiple harmful or malicious behaviors
    and therefore be classified in more than one category.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的安卓安全团队多年来跟踪了许多恶意软件类别。任何表现出至少一种以下行为的应用程序都被视为恶意软件，无论开发者是否故意在应用中包含有害代码，并将被安卓安全团队成员和恶意软件检测平台标记为恶意软件。需要指出的是，实际应用程序可能呈现多种有害或恶意行为，因此可能会被归类为多个类别。
- en: Many malware categories share common characteristics. We can say that, in general,
    malware will often try to (1) avoid detection by hiding its malicious functionality
    from scanners and security analysts, (2) remain installed and avoid removal by
    the user or by security software, and (3) make money directly or indirectly, for
    example by collecting and selling user data, installing other apps, artificially
    generating clicks on ads, and abusing systems or networks reachable from the device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多恶意软件类别有共同特征。一般来说，恶意软件通常会尝试（1）通过隐藏其恶意功能来避免被扫描器和安全分析师发现，（2）保持安装状态并避免用户或安全软件删除，（3）直接或间接地赚钱，例如通过收集和出售用户数据、安装其他应用、虚假点击广告以及滥用设备能够访问的系统或网络。
- en: The following sections describe malware categories that have an impact on the
    Android ecosystem and its users.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了对安卓生态系统及其用户有影响的恶意软件类别。
- en: '***Denial of Service***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拒绝服务***'
- en: '*Denial of service (DoS)* refers to a compromise of the availability of a device,
    system, or service. A DoS attack can be launched, for example, by exploiting a
    system integrity issue, like a stack or heap memory corruption bug, that makes
    the system crash or by overwhelming the system with a large number of requests
    than it has the resources to handle. In an attempt to process the requests, it
    might shut down or at least become unresponsive to new requests for some time.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*拒绝服务（DoS）*指的是设备、系统或服务的可用性受到破坏。例如，可以通过利用系统完整性问题（如堆栈或堆内存损坏漏洞）发起DoS攻击，这会导致系统崩溃，或者通过发送大量超出系统处理能力的请求来使系统崩溃。在尝试处理这些请求时，系统可能会关闭，或者至少在一段时间内对新请求没有响应。'
- en: The consequences of a DoS attack can be severe. For example, in the case of
    systems that receive online orders or payments, any downtime might directly affect
    the business’s bottom line. Recovery from a DoS attack might also be costly, as
    it could require system upgrades, patching, new protection features and tools,
    additional capacity, and so on. For critical infrastructure like hospitals, the
    food supply chain, and utilities, a DoS attack might not only cause economic damage
    but also large-scale public safety issues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DoS攻击的后果可能非常严重。例如，对于接收在线订单或支付的系统，任何停机时间都可能直接影响到业务的盈利。恢复DoS攻击可能也需要高昂的成本，因为可能需要系统升级、修补漏洞、新的防护功能和工具、额外的容量等。对于像医院、食品供应链和公共事业等关键基础设施，DoS攻击不仅可能造成经济损失，还可能引发大规模的公共安全问题。
- en: When it comes to Android, the primary DoS concern is the possibility that a
    large number of devices could become an abuse vehicle for targets selected by
    an attacker. Some DoS attacks are carried out without a user’s knowledge; in many
    cases, the user’s device is added to a *botnet*, or a set of devices under the
    control of a particular hacker, whose goal is to execute a *distributed denial-of-service
    (DDoS)* attack. In such an attack, a large number of devices that have the same
    malicious app installed might each send a high volume of HTTP requests over the
    network to a target web server. The volume of traffic is so high that the server
    is ultimately unable to process the excessive load, which ends up flooding the
    intake queue and other internal data structures. As a result, the server starts
    dropping or rejecting new requests, including legitimate ones, which practically
    takes it offline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 提到 Android 时，主要的拒绝服务（DoS）问题是大量设备可能成为攻击者选择目标的滥用工具。一些 DoS 攻击是在用户不知情的情况下进行的；在许多情况下，用户的设备会被加入到一个*僵尸网络*中，僵尸网络是由特定黑客控制的一组设备，黑客的目标是执行*分布式拒绝服务（DDoS）*攻击。在这种攻击中，安装了相同恶意应用的大量设备可能每个都通过网络向目标
    Web 服务器发送大量 HTTP 请求。流量量大到服务器最终无法处理过多的负载，这会导致服务器的接收队列和其他内部数据结构被淹没。结果，服务器开始丢弃或拒绝新的请求，包括合法的请求，这几乎让它脱机。
- en: DDoS attacks can take various forms. In some cases, the DDoS attack is executed
    by code that comes with the app at install time. In other cases, the code containing
    the DDoS logic is dynamically fetched from a command-and-control server at execution
    time, along with data such as the target IP address, start date and time, and
    attack duration. The Android Security team has also encountered applications installed
    on many devices that use WebViews to continuously fetch and load the same resource
    over and over again, such as image files from a web server, resulting in rapid
    performance degradation and incapacity to respond. In other cases, a malicious
    app supports a variety of abuse functions that it can perform upon request by
    a remote command-and-control server. The server sends specific execution parameters
    to all devices that have the app installed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: DDoS 攻击可以采取各种形式。在某些情况下，DDoS 攻击是由安装时随应用一起提供的代码执行的。在其他情况下，包含 DDoS 逻辑的代码会在执行时动态从指挥与控制服务器获取，同时获取目标
    IP 地址、开始日期和时间、攻击持续时间等数据。Android 安全团队还遇到过安装在许多设备上的应用程序，这些应用使用 WebView 持续地一次又一次地获取和加载相同的资源，例如来自
    Web 服务器的图像文件，从而导致性能急剧下降并无法响应。在其他情况下，一个恶意应用程序支持各种滥用功能，可以在远程指挥与控制服务器的请求下执行。服务器向所有安装了该应用的设备发送特定的执行参数。
- en: Such attacks from mobile botnets have been very rare so far, and security companies
    have publicly documented just a few of them. However, as mobile connections across
    the world become more stable and powerful, we expect this to change. Additionally,
    *unintentional* DDoS attacks are underreported. These happen when developers hardcode
    timed connections to a web server. When an app with a timed connection becomes
    popular, each device with the app may connect to the web server at the same time.
    A smaller web server suddenly facing a million requests at midnight will easily
    run into trouble. About half of the DDoS cases identified in the past few years
    involved a mediation by the Android Security team between clumsy app developers
    and unhappy web server owners, who were unable to resolve the overwhelming number
    of connections suddenly coming from Android devices.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 来自移动僵尸网络的攻击到目前为止非常罕见，安全公司仅公开记录了其中几起。然而，随着全球移动连接变得更加稳定和强大，我们预计这一现状会发生变化。此外，*无意*的
    DDoS 攻击被报告的较少。这种攻击发生在开发者将定时连接硬编码到 Web 服务器时。当带有定时连接的应用程序变得流行时，每个安装该应用的设备可能会在同一时间连接到
    Web 服务器。一个较小的 Web 服务器在午夜突然面对百万个请求时，很容易遇到问题。在过去几年中，约一半的 DDoS 案例涉及到 Android 安全团队调解笨拙的应用开发者与不满的
    Web 服务器所有者之间的纠纷，后者无法解决来自 Android 设备的大量连接问题。
- en: '***Backdoors***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***后门***'
- en: A *backdoor* app opens an unexpected communication channel to a command-and-control
    server, which instructs the application to execute unwanted, remote-controlled
    operations on a device. Such operations may include behavior that would otherwise
    place the app into one of the other malware categories (for example, spyware,
    phishing, or DoS).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*后门*应用会打开一个意外的通信通道，连接到一个指挥与控制服务器，服务器指示应用执行不需要的远程控制操作。这些操作可能包括其他恶意行为，这些行为本应将应用归入其他恶意软件类别（例如间谍软件、钓鱼或
    DoS）。
- en: 'Backdoor apps perform a broad range of operations, including:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 后门应用执行广泛的操作，包括：
- en: Installing apps downloaded from an attacker-controlled server using elevated
    system application privileges, such as those granted to preinstalled apps
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提升的系统应用权限（例如授予预安装应用的权限）从攻击者控制的服务器安装下载的应用
- en: Rooting the device to be able to write freely to the filesystem
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根植设备，以便能够自由地对文件系统进行写操作
- en: Harvesting user information from the device, such as contact lists, device location
    data, text messages, the user’s phone number and call history, or package names
    of installed apps
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备中收集用户信息，例如联系人列表、设备位置数据、短信、用户的电话号码和通话历史，或已安装应用程序的包名
- en: Sending text messages to premium SMS numbers
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向高收费短信号码发送短信
- en: Capturing sensitive data, including credentials, and asking the user to fill
    out a web form that sends the data to a fraudster
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获敏感数据，包括凭据，并要求用户填写发送数据给欺诈者的网页表单
- en: Fetching and displaying ads
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取并展示广告
- en: The communication that backdoor applications establish with command-and-control
    servers is often hidden, indirect, or protected with obfuscation or encryption
    methods. For example, some malware families use common encryption algorithms like
    AES and 3DES for encrypting data or code, Base64 or XOR for encoding, and code
    compression for obfuscation. They might evade detection through TCP port hopping
    and the use of covert channels with platforms like IRC chats, Firebase, and X
    (formerly Twitter). If the user blocks the communication channel between the command-and-control
    server and the app, the infected device can no longer be managed, so many malware
    authors make an effort to protect it as much as possible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 后门应用与命令控制服务器之间的通信通常是隐藏的、间接的，或通过混淆或加密方法进行保护。例如，一些恶意软件家族使用常见的加密算法（如AES和3DES）加密数据或代码，使用Base64或XOR进行编码，使用代码压缩进行混淆。它们可能通过TCP端口跳跃以及使用IRC聊天、Firebase和X（前身为Twitter）等平台的隐蔽通道来规避检测。如果用户阻止了命令控制服务器与应用之间的通信通道，感染的设备将无法再被管理，因此许多恶意软件作者会尽力保护这一点。
- en: Some backdoor applications have been known to aggressively try to achieve persistence
    on the device so that users or malware scanners cannot easily disable them. One
    approach is to rely on preinstalled applications that have backdoor logic in them.
    A more common approach, though, is to use the system privileges of a relatively
    simple preinstalled application to install a backdoor app later on and to reinstall
    the app if it detects that the backdoor has been removed. Other techniques for
    protecting the presence of malware on the device include hiding the app’s icon
    from the main screen, creating a shortcut to substitute the app’s icon, disabling
    antivirus software, and moving the application to a read-only location (such as
    */system/app*).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些后门应用已知会积极尝试在设备上实现持久性，使用户或恶意软件扫描程序无法轻易禁用它们。一种方法是依赖于内置的应用程序，这些应用程序包含后门逻辑。然而，更常见的方法是使用相对简单的预安装应用的系统权限，稍后安装后门应用，并在检测到后门已被删除时重新安装该应用。其他保护恶意软件在设备上存在的技术包括将应用图标从主屏幕上隐藏，创建一个快捷方式来替代应用图标，禁用杀毒软件，以及将应用程序移动到只读位置（如*/system/app*）。
- en: '***Rooting***'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Rooting***'
- en: 'In Android, a *rooting* app is an unprivileged application that exploits vulnerabilities
    in the Android operating system or manufacturer-specific device components to
    gain code execution and administrator-level privileges, or status as *root*: the
    most privileged user on the system, identified by user identifier (UID) 0\. Because
    Android employs a number of controls to isolate application and operating system
    resources, including Linux filesystem permissions, process execution under separate
    UIDs, and SELinux access control policies, an unprivileged application that wishes
    to execute privileged operations must find a security hole to bypass those controls.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，*rooting*应用是一个无特权应用，通过利用Android操作系统或制造商特定设备组件中的漏洞，获得代码执行和管理员级别的权限，或者获得作为*root*的身份：系统中最特权的用户，标识为用户标识符（UID）0。由于Android采用了多种控制措施来隔离应用和操作系统资源，包括Linux文件系统权限、在不同UID下执行的进程以及SELinux访问控制策略，想要执行特权操作的无特权应用必须找到一个安全漏洞来绕过这些控制。
- en: Rooting applications usually rely on known Android vulnerabilities that have
    been publicly disclosed and assigned a Common Vulnerabilities and Exposures (CVE)
    ID. When left unpatched on the device, they may enable privilege escalation to
    root. The case of apps that exploit new, previously unknown vulnerabilities (that
    is, zero-day vulnerabilities), however, has become increasingly rare. Nowadays,
    they are nearly exclusively the domain of the state-sponsored actors behind a
    number of so-called advanced persistent threats (APTs).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Root 应用通常依赖于已公开披露并分配了公共漏洞与曝光（CVE）ID 的已知 Android 漏洞。当设备上未打补丁时，这些漏洞可能会导致特权提升到
    root。然而，利用新漏洞（即零日漏洞）的应用程序已经变得越来越罕见。如今，它们几乎完全是由一些国家支持的行为体所控制，这些行为体背后通常是所谓的高级持续性威胁（APT）。
- en: These vulnerabilities are often memory corruption issues in Linux kernel components
    and device drivers that serve as interfaces between system services and peripherals
    and unprivileged applications. Once these components are compromised—for instance,
    through stack corruption or code injection—the attacker may be able to execute
    their code in the context of these privileged processes. When the malicious app
    gains root privileges, it may execute additional operations to achieve persistence,
    read sensitive data, or download and install other apps. For instance, the app
    may read user data from a different application’s directory; make system configuration
    changes, such as enabling app installation from third-party sources or disabling
    Google Play Protect; read authentication tokens to gain access to the user’s account;
    or inject malicious code into system runtime libraries to enable them to keep
    executing even after a reboot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些漏洞通常是 Linux 内核组件和设备驱动程序中的内存损坏问题，这些驱动程序作为系统服务与外设和无特权应用程序之间的接口。一旦这些组件被攻破——例如，通过栈溢出或代码注入——攻击者可能能够在这些特权进程的上下文中执行他们的代码。当恶意应用获得
    root 权限时，它可能会执行额外的操作以实现持久化、读取敏感数据或下载和安装其他应用。例如，应用可能会从另一个应用的目录中读取用户数据；进行系统配置更改，例如启用来自第三方来源的应用安装或禁用
    Google Play Protect；读取身份验证令牌以访问用户账户；或将恶意代码注入系统运行时库中，以便即使在重启后它们仍然能继续执行。
- en: Gaining root privileges via a malware app on the device does not automatically
    mean gaining full access to system resources. In some cases, depending on the
    Android operating system version and the device’s SELinux configuration, even
    apps running as root lack access to some of these post-rooting techniques. Even
    so, because the configuration of each device differs and may change over time,
    some rooting apps still succeed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设备上的恶意应用获取 root 权限并不意味着自动获得对系统资源的完全访问权限。在某些情况下，取决于 Android 操作系统版本和设备的 SELinux
    配置，即使是以 root 身份运行的应用也无法访问某些后续的 root 技术。即便如此，由于每个设备的配置不同且可能随时间变化，仍然有一些 root 应用能够成功。
- en: Some rooting malware comes with a battery of exploits that are selectively executed
    based on certain parameters, such as the Android version running on the compromised
    device and the presence of certain device drivers. In other cases, the application
    may execute all exploits sequentially, one at a time, until one of them succeeds.
    Also, as with other malware families, the application can try to dynamically load
    malicious code at a later stage. For example, it is quite common for a rooting
    app to collect fingerprinting information about the device on which it is running
    and send it to a remote server, which responds with a device-specific exploit
    module. This keeps the rooting app adaptable to new device types. At the same
    time, the exploit developer does not have to show their hand by giving away all
    the exploits in their library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 root 恶意软件配备了一系列漏洞，这些漏洞会根据某些参数（如运行在受影响设备上的 Android 版本和特定设备驱动程序的存在）选择性地执行。在其他情况下，应用可能会顺序执行所有漏洞，一次一个，直到其中一个成功。此外，与其他恶意软件家族一样，该应用还可能在后期尝试动态加载恶意代码。例如，root
    应用常常会收集其运行设备的指纹信息并将其发送到远程服务器，服务器会返回一个特定设备的漏洞模块。这使得 root 应用能够适应新类型的设备。与此同时，漏洞开发者不必通过公开所有漏洞来暴露自己。
- en: It is important to note that there is a difference between nonmalicious and
    malicious rooting apps. Nonmalicious rooting apps explicitly advertise themselves
    as tools for rooting the device, and they do not execute other harmful actions
    in the background. Malicious rooting, on the other hand, occurs when the application
    does not disclose its purpose and executes rooting attempts without user consent.
    In both cases, the Android Security team will flag these apps as malware due to
    their impact on the security of the system. However, even though the execution
    of a nonmalicious rooting app may leave the system in a vulnerable state, users
    can still choose to install the app and ignore any warnings from Google Play Protect
    or other malware scanners. The Android ecosystem gives the user that flexibility.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，非恶意和恶意的root应用程序之间是有区别的。非恶意root应用明确宣传自己是用于root设备的工具，并且不会在后台执行其他有害操作。而恶意root则发生在应用未披露其目的并且未经用户同意执行root操作时。在这两种情况下，Android安全团队会将这些应用标记为恶意软件，因为它们对系统安全的影响。然而，即使非恶意的root应用可能会让系统处于一个脆弱的状态，用户仍然可以选择安装该应用，并忽略来自Google
    Play Protect或其他恶意软件扫描器的警告。Android生态系统赋予用户这种灵活性。
- en: '***Trojans***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特洛伊木马***'
- en: '*Trojan* apps appear to be benign (for example, they may impersonate a popular
    app) but contain hidden functionality that performs undesirable actions. These
    apps have an innocuous component used to gain user trust by giving them some useful
    features. In addition to this benign component, however, they include malicious
    logic that is invisible to the user.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*特洛伊木马*应用看似是良性的（例如，它们可能伪装成一个流行的应用），但却包含隐藏的功能，执行不良的操作。这些应用有一个无害的组件，用来通过提供一些有用的功能来获取用户的信任。然而，除了这个无害的组件，它们还包含对用户不可见的恶意逻辑。'
- en: One very common technique that the creators of trojans and other malware have
    used to evade detection is to first publish a clean APK that passes all Google
    Play checks to reach user devices. Then, some days or weeks later, they create
    and publish a new version of the APK, this time including malware functionality
    that the user will install as part of an app update. The advantage of this technique
    is that it allows a malicious app to build an installation base without fearing
    removal from Google Play or user devices. If the harmful update successfully clears
    Google Play scanning, potentially thousands of devices will install the new functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 特洛伊木马和其他恶意软件的创作者常用的一种技术是，首先发布一个通过所有Google Play检查的干净APK文件，以便到达用户设备。然后，几天或几周后，他们会创建并发布一个新版本的APK，这次包含恶意功能，用户会将其作为应用更新安装。这种技术的优势在于，它允许恶意应用在不担心从Google
    Play或用户设备中被移除的情况下建立安装基础。如果恶意更新成功通过Google Play扫描，可能有成千上万的设备会安装这个新功能。
- en: Malicious apps, including trojans, have also abused a feature available in Android
    that allows Java code to call non-Java code compiled for the device’s hardware.
    This *Java Native Interface (JNI)* lets an app load libraries usually stored in
    *.so* files, which are bundled inside the APK and may include malicious code.
    If a malware scanner inspects only Java bytecode or decompiled Java code, it may
    be blind to the malicious logic present in these hardware-specific libraries.
    In fact, we have seen malware samples that obviously use native code for no particular
    reason beyond hiding from malware scanners. For example, some malware is written
    exclusively in Java except for a minimal decryption feature written in native
    code, or even just a small native code function that does nothing but return the
    encryption key used by Java code. Static analysis engines that do not support
    cross-architecture control and data flow analysis will be stumped by such simple
    techniques.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意应用，包括特洛伊木马，也滥用了Android系统中的一个特性，允许Java代码调用为设备硬件编译的非Java代码。这个*Java本地接口（JNI）*
    让应用加载通常存储在*.so*文件中的库，这些文件捆绑在APK中，可能包含恶意代码。如果恶意软件扫描器只检查Java字节码或反编译后的Java代码，可能无法察觉这些硬件特定库中存在的恶意逻辑。事实上，我们已经看到一些恶意软件样本明显使用本地代码，目的只是为了躲避恶意软件扫描器。例如，某些恶意软件完全使用Java编写，只有一个最小的解密功能是用本地代码编写的，或者甚至只是一个小的本地代码函数，什么也不做，只是返回Java代码使用的加密密钥。不支持跨架构控制和数据流分析的静态分析引擎将被这种简单的技术难住。
- en: Trojan apps can perform a wide range of hidden operations. Some banking trojans,
    for example, target mobile banking users by impersonating popular apps that offer
    money transfers, check deposits, and other account services. If the user is tricked
    into downloading the fake app, they may end up giving fraudsters their account
    credentials. Other applications may wait for users to execute a legitimate banking
    app, then try to intercept usernames and passwords by using overlays on top of
    the legitimate app to display input forms that capture the user data. During authentication,
    the banking app might send a one-time password (OTP) to the user’s device; a trojan
    app might try to read those text messages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 木马应用程序可以执行各种隐藏操作。例如，一些银行木马通过伪装成流行的应用程序，针对移动银行用户，这些应用程序提供转账、支票存款和其他账户服务。如果用户被欺骗下载了假冒应用程序，他们可能最终会将自己的账户凭证交给诈骗者。其他应用程序可能会等待用户执行合法的银行应用程序，然后通过在合法应用程序上覆盖显示输入表单来拦截用户名和密码，从而捕获用户数据。在身份验证过程中，银行应用程序可能会向用户的设备发送一次性密码（OTP）；木马应用程序可能会尝试读取这些短信。
- en: Other trojan families manipulate online user reviews, fetching fake review text
    from a command-and-control server and then publishing it on a variety of platforms
    to artificially inflate ratings. This type of abuse also involves the creation
    of large numbers of fake user accounts to give the impression that real humans
    posted the ratings.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他木马家族操控在线用户评论，从指挥和控制服务器获取虚假评论文本，然后将其发布在各种平台上，以人为地抬高评分。这种滥用行为还涉及创建大量虚假用户帐户，以给人一种真实用户发布评分的假象。
- en: Over the last few years, some proxy network apps have been flagged for malware
    behavior. These proxy services allow paying customers to anonymously access online
    resources that would otherwise be protected by firewalls and IP address restrictions.
    For example, they might allow a user in country A to access a resource in country
    B. The problem with these apps is that they often fail to tell the user that their
    device will become an exit node on a proxy network or that their system’s resources
    will transport traffic (potentially connected to illegal activities) on behalf
    of others.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，一些代理网络应用程序因恶意软件行为而被标记。这些代理服务允许付费用户匿名访问在线资源，否则这些资源会受到防火墙和IP地址限制的保护。例如，它们可能允许国家A的用户访问国家B的资源。这些应用程序的问题在于，它们常常未告知用户，他们的设备将成为代理网络的出口节点，或者他们的系统资源将代表他人传输流量（可能与非法活动相关）。
- en: Yet another type of trojan that appeared some years ago is cryptomining malware.
    These apps infect a large number of devices and use system resources, however
    limited they might be, to mine cryptocurrency in the background. In many cases,
    the mining occurs without any disclosure to the user, abusing the device’s battery
    life and processing power without their consent. In cases in which the user is
    actually aware of the mining, the financial benefit they may get is very limited.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种几年前出现的木马类型是加密货币挖矿恶意软件。这些应用程序感染大量设备，并使用系统资源（无论它们多么有限）在后台挖掘加密货币。在许多情况下，挖矿过程对用户没有任何披露，未经用户同意，恶意软件滥用设备的电池寿命和处理能力。如果用户意识到挖矿行为，他们所能获得的财务收益也非常有限。
- en: Some trojan apps allow the attacker to manage the target device remotely. These
    share some characteristics with backdoor apps and are commonly referred to as
    *remote access trojans (RATs)*. RAT malware hides its purpose by pretending to
    be benign and often uses keyloggers, rooting, and other techniques to install
    apps, execute commands, and steal user data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些木马应用程序允许攻击者远程管理目标设备。这些应用程序与后门应用程序有一些相似之处，通常被称为*远程访问木马（RATs）*。RAT恶意软件通过伪装成无害程序来隐藏其目的，通常使用键盘记录器、root权限和其他技术来安装应用程序、执行命令以及窃取用户数据。
- en: '***Spyware***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***间谍软件***'
- en: The goal of *spyware* is to find, collect, and transmit personal data without
    the consent of the user. This data can be sold to a third party or used to understand
    the user’s behavior, perhaps to offer them applications in which they might be
    interested. In the most severe spyware cases, the application may effectively
    spy on the user by accessing their physical location (whether by reading GPS data
    or through other means), photos, browsing history, search history, list of installed
    applications, text messages, and call history. Some spyware will go as far as
    activating the camera or microphone in an attempt to identify the user, observe
    their actions, or listen to their conversations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*间谍软件*的目标是找到、收集并传输个人数据，而未经用户同意。这些数据可以被卖给第三方，或用于了解用户的行为，或许可以为他们提供可能感兴趣的应用程序。在最严重的间谍软件案例中，应用程序可能通过访问用户的实际位置（无论是通过读取
    GPS 数据还是通过其他方式）、照片、浏览历史、搜索历史、已安装的应用列表、短信和通话历史来有效地监视用户。有些间谍软件甚至会激活摄像头或麦克风，试图识别用户、观察他们的行为或监听他们的对话。'
- en: Some spyware families target social media accounts and related application data
    stored on the device. If the data managed by an app is not encrypted at the application
    level (meaning the filesystem may be encrypted, but any application with the proper
    permissions can read the data), a spyware application might be able to siphon
    the data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一些间谍软件家族针对社交媒体账户和存储在设备上的相关应用数据。如果一个应用管理的数据没有在应用层进行加密（意味着文件系统可能被加密，但任何具有适当权限的应用都能读取数据），间谍软件应用可能能够窃取这些数据。
- en: Spyware has also abused the Accessibility API, which supports powerful functions
    including launching an app, performing automated clicks, and reading text to the
    user. Some malware families have used these privileges to read WhatsApp messages
    and execute configuration changes on the system without user consent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍软件也滥用了无障碍 API，该 API 支持包括启动应用程序、执行自动点击和读取用户文本等强大功能。一些恶意软件家族利用这些权限读取 WhatsApp
    消息并在未经用户同意的情况下执行系统配置更改。
- en: '***Stalkerware***'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***跟踪软件***'
- en: The Android Security team’s definition of spyware is focused on data collection
    in which the identity of the victim doesn’t matter; the collected data is resold
    in bulk or otherwise monetized without care for the affected individuals. Malware
    that is used to spy on particular, known individuals is called *stalkerware*,
    or sometimes commercial spyware or spouseware.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安全团队对间谍软件的定义集中在数据收集上，其中受害者的身份无关紧要；收集的数据会被批量转售或以其他方式变现，而不考虑受影响的个人。用于监视特定已知个人的恶意软件被称为*跟踪软件*，有时也叫做商业间谍软件或配偶软件。
- en: Mobile applications advertised as a tool to track someone can, of course, be
    used with full consent of all involved parties. However, some of these applications
    lack proper controls and have been misused to become a staple of abusive relationships
    and can be found on millions of phones. If someone wants to keep track of their
    partner’s location or see what text messages they send and receive, a quick internet
    search for “spying on your girlfriend/boyfriend/husband/wife” reveals a thriving
    industry in which one can pay around $50 for this kind of surveillance software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 宣传为跟踪某人的工具的移动应用程序，当然可以在所有相关方完全同意的情况下使用。然而，某些应用缺乏适当的控制，已被滥用，成为虐待关系中的常见工具，并且可以在数百万部手机中找到。如果有人想追踪伴侣的位置，或查看他们发送和接收的短信，快速搜索“间谍软件追踪你的女友/男友/丈夫/妻子”便会发现一个蓬勃发展的行业，在这个行业中，您可以支付约
    50 美元购买这种监控软件。
- en: Stalkerware applications, whether free or for pay, fail to prominently notify
    the device’s owner of their presence. For example, certain apps may advertise
    themselves as parental control tools that enable family members to check on others
    and, in some cases, manage their mobile devices (for example, seeing what applications
    are installed and what URLs have been visited). But if not designed correctly,
    these applications may allow a user to spy on others surreptitiously.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪软件应用程序，无论是免费的还是付费的，都未能显著通知设备的拥有者其存在。例如，某些应用可能将自己宣传为父母控制工具，允许家庭成员检查其他人的情况，并在某些情况下管理他们的移动设备（例如，查看已安装的应用程序和访问过的网址）。但是，如果设计不当，这些应用程序可能会允许用户偷偷地监视他人。
- en: Stalkers usually install stalkerware applications on the victim’s device when
    the device is left unattended. During setup, the stalker will configure the app
    using their email address or a phone number. Many commercial stalkerware products
    even offer a web-based interface. The stalkers can then take full control of the
    device from the comfort of that web interface.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪者通常在受害者设备无人看管时安装跟踪软件应用。在设置过程中，跟踪者会使用自己的电子邮件地址或电话号码来配置该应用。许多商业化的跟踪软件产品甚至提供基于网页的界面。跟踪者可以通过这个网页界面轻松地完全控制设备。
- en: Even though there may be legitimate use cases for some of the functionality
    offered by these apps (for instance, knowing where one’s children are), the Android
    Security team regards any app that can be used covertly to track another person
    without their knowledge or permission as malware.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管某些应用程序提供的功能可能有合法的用途（例如，了解孩子的位置），但安卓安全团队认为，任何可以在未经他人知情或允许的情况下隐秘地追踪他人的应用都属于恶意软件。
- en: '***Phishing***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***钓鱼***'
- en: '*Phishing* applications try to steal user credentials or payment information
    by either asking the user for it or capturing the data when it is transmitted.
    They often target credit card numbers, bank account numbers, cryptocurrency wallet
    credentials, usernames, passwords, personal identification numbers (PINs), and
    other authentication factors, such as OTPs. Once the application has captured
    the data, it sends it over the network to a system under the control of a third
    party. In some cases, if captured credentials enable access to a private system
    or network, the impact might extend beyond the individual and result in large-scale
    hacking, espionage, or theft of confidential information, such as intellectual
    property.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*钓鱼* 应用试图通过要求用户提供凭证或在数据传输时捕获数据来窃取用户凭证或支付信息。它们通常针对信用卡号、银行账户号、加密货币钱包凭证、用户名、密码、个人识别码（PIN）和其他身份验证因素，例如一次性密码（OTP）。一旦应用捕获到数据，它会通过网络将数据发送到第三方控制的系统。在某些情况下，如果被捕获的凭证能够访问私人系统或网络，影响可能超出个人层面，导致大规模的黑客攻击、间谍活动或机密信息盗窃，如知识产权。'
- en: Applications employ various phishing techniques. For instance, certain phishing
    apps have impersonated popular email, social network, or financial services apps
    by using similar package names, logos, and app layouts. Once launched, the application
    may immediately ask the user to enter their credentials, then tell them that there
    was an error during the login process and redirect them to the correct site. At
    that point, the damage is already done; the app will send the credentials to a
    server that centralizes the collection of stolen data, where it might get sold
    on the dark web or other underground forums. This technique has also been used
    by malware campaigns that target crypto wallet apps and phish for the user’s wallet
    credentials. These can allow the attacker to transfer funds to their own accounts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用各种钓鱼技巧。例如，某些钓鱼应用通过使用相似的包名、标志和应用布局来伪装成流行的电子邮件、社交网络或金融服务应用。一旦启动，应用可能会立即要求用户输入凭证，然后告诉他们登录过程中发生了错误，并将他们重定向到正确的站点。此时，损害已经发生；应用会将凭证发送到一个集中收集被盗数据的服务器，这些数据可能会被出售到暗网或其他地下论坛。此技巧也被用于针对加密钱包应用的恶意软件攻击，钓取用户的钱包凭证。这些凭证可以使攻击者将资金转移到他们自己的账户。
- en: Messaging and communication apps can also enable phishing. Links embedded in
    a message can put users at risk if they point to phishing or app download sites.
    Using social engineering, an attacker might convince users to follow a link, which
    is how they can end up downloading a malicious app or disclosing sensitive information
    to a fraudulent site.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 消息和通信应用也可能成为钓鱼攻击的工具。如果消息中嵌入的链接指向钓鱼网站或应用下载站点，用户可能会面临风险。利用社交工程，攻击者可能会说服用户点击链接，这样他们就可能下载恶意应用或将敏感信息泄露给欺诈网站。
- en: Applications that intercept credentials in transit (instead of receiving them
    directly from users) also fall within the phishing malware category. For example,
    past malware has abused a service that allows mobile carriers to send traffic
    routing configurations to mobile phones by inserting a proxy between the device
    and the carrier. An app installed on the device first extracts the device’s *International
    Mobile Subscriber Identity (IMSI)* using the Android permission `READ_PHONE_STATE`
    and communicates it to a command-and-control server. The server then sends this
    device a text with Open Mobile Alliance Client Provisioning (OMA CP) settings
    requesting that the user install a new configuration with data packet routing
    changes. As a result, the traffic generated by applications on the device—including
    email and web traffic, which may include authentication credentials, payments
    data, or other user information—will go to a proxy server controlled by a third
    party.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截传输中的凭证（而不是直接从用户接收凭证）的应用程序也属于钓鱼恶意软件类别。例如，过去的恶意软件曾滥用一个服务，该服务允许移动运营商通过在设备和运营商之间插入代理来向手机发送流量路由配置。安装在设备上的应用程序首先通过Android权限`READ_PHONE_STATE`提取设备的*国际移动用户身份(IMSI)*，并将其发送到指挥控制服务器。然后，服务器向该设备发送一条短信，包含开放移动联盟客户端配置（OMA
    CP）设置，要求用户安装一个具有数据包路由更改的新配置。结果，设备上的应用程序生成的流量——包括电子邮件和网页流量，可能包含身份验证凭证、支付数据或其他用户信息——将发送到第三方控制的代理服务器。
- en: '***Hostile Downloaders***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***恶意下载器***'
- en: If an app is downloaded frequently, opportunities to monetize it often arise.
    This incentive has resulted in the creation of a large number of apps whose primary
    job is to install other apps. The developers of benign apps sometimes pay these
    installer apps to improve their metrics. Unfortunately, some malware developers
    use these same services. An app that does nothing harmful except download malware
    applications is considered a *hostile downloader*. This type of app has been the
    starting point of numerous malware campaigns over the years.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序被频繁下载，通常会出现将其货币化的机会。这个激励导致了大量应用程序的诞生，这些应用程序的主要任务就是安装其他应用程序。良性应用程序的开发人员有时会支付这些安装器应用程序来改善他们的指标。不幸的是，一些恶意软件开发人员也使用这些相同的服务。一个除了下载恶意软件应用程序外没有做任何有害事情的应用程序被视为*恶意下载器*。这种类型的应用程序多年来一直是许多恶意软件攻击的起点。
- en: Some hostile downloaders install the same set of apps every time. In other cases,
    the type and number of apps they install changes. In all cases, determining if
    an application should be considered a hostile downloader requires data about the
    type of apps installed and the number of installs. For example, some applications
    install a very small number of harmful applications, whereas others mainly distribute
    malware. The Android Security team uses different criteria to define the line
    between benign and hostile downloaders, and when an application crosses it, it
    is flagged as malware. For example, at the time of writing, if at least 5 percent
    of the app’s downloads include malware and the application has downloaded a minimum
    of 500 apps (benign or otherwise), it will be considered a hostile downloader.
    Major browsers and file sharing apps are not considered hostile downloaders, as
    long as a download requires user interaction and any malware download is initiated
    directly by the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意下载器每次都会安装相同的一组应用程序。在其他情况下，它们安装的应用程序类型和数量会有所变化。在所有情况下，判断一个应用程序是否应被视为恶意下载器需要关于已安装应用程序类型和安装次数的数据。例如，一些应用程序只安装很少的有害应用程序，而另一些则主要分发恶意软件。Android安全团队使用不同的标准来定义良性下载器和恶意下载器之间的界限，当应用程序跨越这一界限时，它将被标记为恶意软件。例如，在撰写本文时，如果该应用程序的下载中至少有5％包含恶意软件，并且该应用程序已经下载了至少500个应用程序（无论是良性应用还是其他），则它将被视为恶意下载器。主要浏览器和文件共享应用程序不被视为恶意下载器，只要下载需要用户交互，且任何恶意软件下载都是由用户直接发起的。
- en: 'Hostile downloaders typically make use of two available permissions to install
    other apps: `INSTALL_PACKAGES` and `REQUEST_INSTALL_PACKAGES`. Of these, `INSTALL_PACKAGES`
    is more powerful, because it allows an application to install other apps without
    involving the user. Given the risk of abuse, only pre-installed apps can use this
    permission.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意下载器通常利用两种可用权限来安装其他应用程序：`INSTALL_PACKAGES`和`REQUEST_INSTALL_PACKAGES`。其中，`INSTALL_PACKAGES`更为强大，因为它允许应用程序在不涉及用户的情况下安装其他应用程序。由于滥用的风险，只有预装的应用程序才能使用此权限。
- en: The more benign permission, `REQUEST_INSTALL_PACKAGES`, was introduced in Android
    8.0 (Oreo) and is available to all Android apps. This permission allows an app
    to request the installation of other apps, for instance, after the original app
    has been successfully installed. When declared in the app’s manifest file, `REQUEST_INSTALL_PACKAGES`
    will ask the user for confirmation before an `ACTION_INSTALL_PACKAGE` intent can
    be used to install an APK. This permission makes it more difficult for hostile
    downloader developers to force app installs, as it requires user intervention.
    Before Android 8.0 (Oreo) all apps had the option to start a user-consented app
    installation flow. The introduction of this new permission makes explicit to users
    which apps can be installers of other apps.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更为温和的权限`REQUEST_INSTALL_PACKAGES`是在Android 8.0（Oreo）中引入的，并且所有Android应用程序都可以使用该权限。此权限允许应用程序请求安装其他应用程序，例如，在原始应用程序成功安装后。当在应用的清单文件中声明`REQUEST_INSTALL_PACKAGES`时，用户将被要求确认，才能使用`ACTION_INSTALL_PACKAGE`意图来安装APK文件。这个权限使得恶意下载器开发者更难强制安装应用程序，因为它需要用户干预。在Android
    8.0（Oreo）之前，所有应用程序都有启动用户同意的应用程序安装流程的选项。这个新权限的引入明确了哪些应用程序可以作为其他应用程序的安装程序。
- en: Malware developers have found ways to include apps with hostile downloader functionality
    in the system images that phone carriers and device manufacturers put in their
    products. Thus, many hostile downloaders come preinstalled on some devices. In
    addition to having special permissions and access to system resources, these preinstalled
    applications cannot be easily uninstalled. This privileged position allows a hostile
    downloader to fetch and install APKs without user intervention. One additional
    challenge with these applications is that the apps that they’ve installed may
    not be known to the manufacturer or the company responsible for building the system
    image. As a result, the user of a brand-new device may end up with a number of
    unwanted or even harmful applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件开发者已经找到方法，将带有恶意下载功能的应用程序包含在手机运营商和设备制造商放入其产品中的系统镜像中。因此，一些设备上会预装许多恶意下载器。除了具有特殊权限和访问系统资源的权限外，这些预装应用程序还不能轻易卸载。这个特权地位使得恶意下载器能够在没有用户干预的情况下获取并安装APK文件。另一个挑战是，这些恶意下载器安装的应用程序可能对制造商或负责构建系统镜像的公司来说并不为人知。因此，用户可能会在全新设备上发现许多不需要的甚至有害的应用程序。
- en: Hostile downloaders that do not have permission to install other apps may find
    alternative ways to do it. For instance, they may try to root the device in order
    to access the filesystem and copy APKs. Then, they may try to abuse the `PackageManager`
    in some Android versions to actually install apps. Recent Android versions prevent
    the direct copying of files using absolute paths, which is what some hostile downloaders
    used to do, and require the app to use `FileProvider`, which is a more secure
    way to handle files. In some cases, if the app cannot be fetched and installed
    quickly, the hostile downloader may first download the *.apk* file using the `INTERNET`
    permission and then write it to the SD card (for example, to the *Downloads* folder)
    using `WRITE_EXTERNAL_STORAGE`. Later, in a second step, the downloader will try
    to gain the `INSTALL_PACKAGES` permission and install the files it previously
    downloaded.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 没有安装其他应用程序权限的恶意下载器可能会找到替代的方法来实现这一点。例如，它们可能会尝试获取设备的root权限，以便访问文件系统并复制APK文件。接着，它们可能会尝试在某些Android版本中滥用`PackageManager`来实际安装应用程序。最近的Android版本阻止了通过绝对路径直接复制文件，这正是一些恶意下载器曾经使用的方法，并且要求应用程序使用`FileProvider`，这是一种更安全的文件处理方式。在某些情况下，如果应用程序无法快速获取并安装，恶意下载器可能首先使用`INTERNET`权限下载*.apk*文件，然后使用`WRITE_EXTERNAL_STORAGE`将其写入SD卡（例如，写入*Downloads*文件夹）。稍后，在第二步中，下载器将尝试获取`INSTALL_PACKAGES`权限并安装它之前下载的文件。
- en: Some hostile downloader developers may be aware of the Android Security team’s
    detection thresholds and try to stay below those levels. In some cases, to maintain
    a high number of app downloads, they might install multiple hostile downloaders
    on the same device. When that’s the case, detection methods can be adjusted to
    account for that mutation in behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意下载器开发者可能了解Android安全团队的检测阈值，并试图保持在这些水平以下。在某些情况下，为了保持较高的应用下载量，他们可能会在同一设备上安装多个恶意下载器。当发生这种情况时，可以调整检测方法来应对这种行为的变化。
- en: '***Privilege Escalation***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特权提升***'
- en: The *privilege escalation* malware category covers applications that try to
    elevate their permissions by abusing the system or exploiting vulnerabilities.
    This category covers all privilege escalation cases except rooting, which, due
    to its impact on the integrity of the system, has its own category (discussed
    previously).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*权限提升* 恶意软件类别涵盖了通过滥用系统或利用漏洞来提升权限的应用程序。该类别包括所有权限提升的情况，除了 root 操作，由于它对系统完整性的影响，已经有了独立的类别（如前所述）。'
- en: 'Four malware behaviors characterize this malware category, not all of which
    would be considered privilege escalation in other contexts. It includes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类恶意软件的四种行为特征，并不是所有的行为在其他上下文中都被认为是权限提升。它包括：
- en: Applications that are able to access (read, write, or execute) resources they
    originally didn’t have the privileges to access, thereby breaking the Android
    app sandbox
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能够访问（读取、写入或执行）它们原本没有权限访问的资源，从而突破 Android 应用沙箱的应用程序
- en: Applications that manage to find ways to bypass permissions
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功找到绕过权限的方法的应用程序
- en: Applications that disable security and safety features on the device
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用设备上的安全和保护功能的应用程序
- en: Applications that prevent the user from managing their device
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阻止用户管理其设备的应用程序
- en: Applications that disable security features or that modify the system’s configuration
    in a way that leaves the device in a vulnerable state are flagged as privilege
    escalation apps. An example is preinstalled applications that abuse system privileges
    (for example, the `WRITE_SECURE_SETTINGS` permission or the `Settings.Global`
    and `Settings.Secure` methods) to turn off Google Play Protect’s malware scanning
    before they self-update or download and install other malware. Other privilege
    escalation applications in the past have accomplished the same objective of disabling
    security settings by executing shell commands instead of using Android APIs, and
    a third group manipulated security settings by modifying the `package_verifier_enable`
    setting, which modifies the malware scanning behavior on the device.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用安全功能或以修改系统配置的方式使设备处于脆弱状态的应用程序会被标记为权限提升应用程序。一个例子是预装的应用程序滥用系统权限（例如，`WRITE_SECURE_SETTINGS`
    权限或 `Settings.Global` 和 `Settings.Secure` 方法）在自我更新或下载并安装其他恶意软件之前关闭 Google Play
    Protect 的恶意软件扫描。过去，其他权限提升的应用程序也通过执行 shell 命令而不是使用 Android API 来实现禁用安全设置的同样目标，第三类恶意软件则通过修改
    `package_verifier_enable` 设置来操控安全设置，该设置修改了设备上的恶意软件扫描行为。
- en: Another feature that malware has targeted is SELinux, which complements the
    filesystem permissions model by defining policies that prevent access to sensitive
    resources regardless of the permissions a file may have. When SELinux is enabled,
    some exploits may fail, as the resulting privileges may be insufficient to access
    the resources it wants. For example, some license cracking applications that patch
    the code of gaming apps in a way that bypasses license checks and purchase verification
    need write access to the filesystem in order to create patched versions of the
    app. When the appropriate SELinux policy is enabled, such modifications are prevented,
    and malware must try to disable it as one of its first steps. It might do this,
    for instance, by running a `setenforce 0` command to turn SELinux from so-called
    *enforcing* mode to *permissive* mode. It’s worth noting that, on modern devices
    running at least Android 5.0 (Lollipop), permissive mode is supported only in
    *userdebug* and *eng* builds, which are special Android device configurations
    usually reserved for development and testing. It should not be possible to turn
    off SELinux on regular end user devices.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件攻击的另一个特性是 SELinux，它通过定义策略来补充文件系统权限模型，防止访问敏感资源，无论文件是否拥有相关权限。当启用 SELinux 时，一些漏洞可能会失败，因为获得的权限可能不足以访问它们想要的资源。例如，一些破解许可证的应用程序通过修改游戏应用程序的代码来绕过许可证检查和购买验证，这需要对文件系统的写入权限，以便创建修补过的应用版本。当启用相应的
    SELinux 策略时，这类修改会被阻止，恶意软件必须在其首要步骤中尝试禁用 SELinux。它可能会通过运行 `setenforce 0` 命令将 SELinux
    从所谓的 *强制执行* 模式切换到 *宽松* 模式。值得注意的是，在运行至少 Android 5.0（Lollipop）版本的现代设备上，宽松模式仅在 *userdebug*
    和 *eng* 构建中支持，这些是通常用于开发和测试的特殊 Android 设备配置。普通终端用户设备不应当能够关闭 SELinux。
- en: Some apps modify the `install_non_market_apps` setting for the purposes of privilege
    escalation. Android devices give the user the ability to install applications
    from any source. This setting, however, prevents applications from installing
    additional applications from sources other than Google Play, given that these
    sources have a higher risk of distributing malware. When an app automatically
    modifies this setting without user consent, the app will be flagged as malware,
    as it may leave the device in a vulnerable state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用为了提升权限，会修改`install_non_market_apps`设置。安卓设备允许用户从任何来源安装应用。然而，这个设置可以阻止应用从Google
    Play以外的来源安装额外的应用，因为这些来源有更高的分发恶意软件的风险。当应用未经用户同意自动修改此设置时，应用将被标记为恶意软件，因为它可能会让设备处于易受攻击的状态。
- en: 'Malware authors have also abused the device manager APIs (implemented in classes
    like `DevicePolicyManager` or `DeviceAdminReceiver`), which enable device management
    operations through a set of policies, especially for enterprise deployments, including
    resetting and expiring passwords, wiping user data partitions through factory
    reset, and requiring encryption of stored data. Malware developers have used the
    device manager APIs to prevent their apps from being removed. For example, some
    malware families observed in the wild call `resetPassword` and `lockNow` to lock
    a device when a user action triggers an `onDisableRequested` callback that will
    try to remove device admin privileges from the potentially harmful app. In other
    cases, the app may monitor user access to system settings and trigger the same
    behavior: locking the owner out.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者还滥用了设备管理器API（如`DevicePolicyManager`或`DeviceAdminReceiver`类中实现的API），这些API通过一系列策略启用设备管理操作，特别是在企业部署中，包括重置和过期密码、通过恢复出厂设置擦除用户数据分区，以及要求加密存储数据。恶意软件开发者利用设备管理器API阻止其应用被删除。例如，某些在野外发现的恶意软件家族会调用`resetPassword`和`lockNow`来锁定设备，当用户操作触发`onDisableRequested`回调时，后者会尝试从潜在有害应用中移除设备管理员权限。在其他情况下，应用可能会监视用户对系统设置的访问，并触发相同的行为：将设备锁定，阻止所有者访问。
- en: Since Android 9.0 (Pie), the device manager APIs have been phased out (deprecated),
    partially in response to malware abuse, as a number of past privilege escalation
    apps used them as a vector to exercise device control without user consent. Prior
    to this, these APIs went through changes that lessened their potential for abuse.
    For example, as of Android 7.0 (Nougat) the method `resetPassword` can only be
    used to set new device passwords, not to change already existing passwords. This
    prevents users with existing device passwords from being locked out of their devices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 9.0（Pie）以来，设备管理器API已逐步淘汰（不推荐使用），部分原因是响应恶意软件的滥用，因为许多过去的权限提升应用曾使用这些API作为无用户同意的设备控制手段。在此之前，这些API经历了一些变化，减少了其被滥用的潜力。例如，从Android
    7.0（Nougat）开始，`resetPassword`方法只能用于设置新的设备密码，而不能更改已存在的密码。这可以防止拥有现有设备密码的用户被锁定在设备外。
- en: One final setting worth mentioning is `upload_apk_enable`. This setting controls
    whether the device shares APK samples with Google Play Protect to help identify
    malware. Malware authors may try to disable it as a means to slow down the detection
    of their apps.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得提到的设置是`upload_apk_enable`。该设置控制设备是否与Google Play Protect共享APK样本，以帮助识别恶意软件。恶意软件作者可能会尝试禁用该设置，以减缓其应用的检测速度。
- en: It is also worth mentioning that some applications rely on other applications
    to weaken the security posture of the device before executing. For instance, some
    malware families include a rooting component whose job is to weaken the security
    of the execution environment and filesystem in preparation for other applications
    actually accessing the data made available by the rooting component. Some of these
    secondary applications take advantage of the vulnerable state of the system to
    access, for instance, the *accounts.db* file, which contains tokens that allow
    the device to access a number of services. These apps might read and then send
    Google OAuth master tokens and ClientLogin tokens for Google Play. In other cases,
    file attributes are manipulated to make modification or removal more difficult,
    for example by declaring files read-only, moving them to privileged partitions,
    or making files more difficult to remove by using the `chattr` shell command to
    set `+ia` attributes on them. A file with these attributes can only be opened
    in append mode for writing; it cannot be deleted or renamed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，一些应用依赖于其他应用在执行之前削弱设备的安全性。例如，一些恶意软件家族包含一个root组件，其任务是削弱执行环境和文件系统的安全性，为其他应用实际访问由root组件提供的数据做好准备。这些二级应用程序利用系统的脆弱状态来访问，例如*accounts.db*文件，其中包含令牌，允许设备访问多个服务。这些应用可能读取并发送Google
    OAuth主令牌和Google Play的ClientLogin令牌。在其他情况下，文件属性被修改，使得修改或删除更加困难，例如通过将文件声明为只读、将其移动到特权分区，或通过使用`chattr`命令为文件设置`+ia`属性，使得文件更加难以删除。具有这些属性的文件只能以附加模式打开进行写入；它不能被删除或重命名。
- en: '***Ransomware***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***勒索软件***'
- en: An app is considered *ransomware* if it takes control of the user’s data or
    device and makes demands to release this control. These demands may include the
    payment of a ransom or a request for the user to perform an action against their
    will. The two primary ransomware methods observed in the Android ecosystem are
    preventing access to the user’s data by encrypting it on the device with a key
    that the attacker controls and locking users out of their devices, either through
    the actual screen locking mechanism or by making the GUI unusable for anything
    besides the ransomware app.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用控制了用户的数据或设备并要求释放这种控制，它就被认为是*勒索软件*。这些要求可能包括支付赎金，或要求用户执行违背其意愿的操作。在Android生态系统中观察到的两种主要勒索软件方法是：通过用攻击者控制的密钥加密设备上的数据来阻止用户访问数据，或者通过实际的屏幕锁定机制或使GUI无法用于除勒索软件应用之外的任何操作来锁定用户的设备。
- en: Ransomware apps that encrypt user data first need to get permission to write
    to the filesystem (for example, through the `WRITE_EXTERNAL_STORAGE` permission).
    Then they can explore the filesystem, checking the status of specific files and
    directories via `getExternalStorageState`. In some cases, the app will read all
    files from external storage and write them back in encrypted form using the `java.io.File.*`
    methods and an encryption key. In other cases, only images and messages are encrypted,
    but not other file formats. In all situations, the app displays a notification
    to the user explaining how to send the payment, often requesting cryptocurrency
    to hide the perpetrator’s identity. The message also describes how the user will
    receive the decryption key and recover their files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 加密用户数据的勒索软件应用首先需要获得写入文件系统的权限（例如，通过`WRITE_EXTERNAL_STORAGE`权限）。然后它们可以探索文件系统，通过`getExternalStorageState`检查特定文件和目录的状态。在某些情况下，应用会读取外部存储中的所有文件，并使用`java.io.File.*`方法和加密密钥将其重新写回加密的形式。在其他情况下，只有图像和消息会被加密，而其他文件格式则不会。在所有情况下，应用会向用户显示通知，说明如何进行支付，通常要求使用加密货币来隐藏攻击者的身份。该消息还描述了用户如何接收解密密钥并恢复其文件。
- en: These applications often use standard encryption algorithms, such as AES for
    data encryption and RSA for key protection. With this approach, the AES symmetric
    key used to encrypt the files is encrypted under the attacker’s RSA public key
    and sent to a command-and-control server so that the attacker can later decrypt
    it and then send it to the user if the payment is received.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序通常使用标准的加密算法，例如用于数据加密的AES和用于密钥保护的RSA。采用这种方法时，用于加密文件的AES对称密钥会被用攻击者的RSA公钥加密，并发送到指挥与控制服务器，这样攻击者可以在收到付款后解密密钥并发送给用户。
- en: Other applications do not encrypt any data but instead block access to the device
    by displaying a ransomware note that covers the entire screen and that the user
    cannot remove. Even after a reboot, the note remains. This type of attack prevents
    the user from accessing the device’s interface, including performing actions like
    making calls or reading messages. Some apps use the `SYSTEM_ALERT_WINDOW` permission
    to display such an overlay window. First, they identify the processes running
    on the device by calling `getRunningServices`, checking process IDs on */proc*
    using the command line, or identifying the top activity via `getRunningTasks`.
    Next, they call `startActivity` to draw over other apps that are executing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应用则不会加密任何数据，而是通过显示一个勒索软件提示，覆盖整个屏幕，用户无法移除。即使重启后，提示仍然存在。这种攻击类型阻止用户访问设备的界面，包括执行拨打电话或读取消息等操作。一些应用使用`SYSTEM_ALERT_WINDOW`权限来显示这样的覆盖窗口。首先，它们通过调用`getRunningServices`、使用命令行检查`/proc`中的进程ID，或者通过`getRunningTasks`识别顶层活动来识别设备上运行的进程。接着，它们调用`startActivity`来覆盖正在执行的其他应用。
- en: A ransomware application can also use the `BIND_DEVICE_ADMIN` permission available
    in some Android versions and then use `DevicePolicyManager` methods, like `resetPassword`
    and `lockNow`, to change the device’s password.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 勒索软件应用还可以使用某些Android版本中可用的`BIND_DEVICE_ADMIN`权限，然后使用`DevicePolicyManager`方法，如`resetPassword`和`lockNow`，来更改设备的密码。
- en: '***SMS Fraud***'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***短信欺诈***'
- en: Some applications cause direct financial harm to the user. That is the case
    for malware that uses text messages to commit fraud. The *SMS fraud* category
    is composed of applications that send SMS or MMS messages to special numbers,
    called *short codes*. These are typically three- to eight-digit-long codes, such
    as 1234, that charge the user a premium when they send SMS messages to these numbers.
    Such premium messages were created for legitimate purposes, such as allowing users
    to send donations to people affected by disasters, vote for a performer on a TV
    show, or subscribe to information services delivered via text (for example, daily
    news, jokes, the weather forecast, or horoscopes). Even though carriers support
    them, the actual services may be delivered by third parties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用会对用户造成直接的财务损失。例如，使用短信进行欺诈的恶意软件就是一种情况。*短信欺诈*类别包括向特殊号码发送短信或彩信的应用，这些号码被称为*短号*。这些短号通常是三到八位的数字代码，如1234，当用户发送短信到这些号码时，会收取额外费用。这样的收费短信最初是为了合法目的而创建的，例如让用户向灾区捐款、在电视节目中为表演者投票，或订阅通过短信提供的信息服务（例如每日新闻、笑话、天气预报或星座运势）。尽管运营商支持这些服务，但实际的服务可能由第三方提供。
- en: SMS fraud apps send text messages in an intentionally deceptive way. They abuse
    the `SEND_SMS` permission by calling APIs such as `sendTextMessage`, `sendMultimediaMessage`,
    or `sendMultipartTextMessage` without the user’s involvement and actively suppress
    any notifications to prevent detection. In some cases, it is only when the user
    reviews their phone bill that they learn about the fraudulent charges made to
    their account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 短信欺诈应用以故意欺骗的方式发送短信。它们通过调用如`sendTextMessage`、`sendMultimediaMessage`或`sendMultipartTextMessage`等API，滥用`SEND_SMS`权限，在没有用户参与的情况下发送短信，并主动抑制任何通知以防被检测到。在某些情况下，只有当用户查看手机账单时，才会发现账户上出现了欺诈性收费。
- en: Even in cases where the destination is a regular number but there is no disclosure
    to the user of the text messages being sent, an application may be suspended for
    violating Google Play policies that protect users from SMS use without consent.
    However, when the number is a short code for premium services, the application
    will be flagged as malware, as these SMS messages directly incur a cost to users.
    Android warns the user when a premium SMS is being sent. However, this warning
    does not represent a disclosure; the application sending the message must disclose
    such activity within the app in a clear and prominent way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 即使目的地是普通号码，但如果没有向用户披露发送短信的行为，应用仍可能因违反Google Play的政策而被暂停，这些政策旨在保护用户不被未经同意的短信使用所困扰。然而，当号码是用于收费服务的短号时，应用将被标记为恶意软件，因为这些短信直接向用户收取费用。Android会在发送收费短信时提醒用户。然而，这个警告并不等于披露；发送短信的应用必须在应用内以清晰且显眼的方式披露这种行为。
- en: SMS fraud apps sometimes come loaded with a list of premium numbers to use.
    They then check the device’s country and mobile carrier to select a specific number
    from the list. In other cases, the destination number is dynamically loaded from
    a command-and-control server, which offers the fraudster flexibility and gives
    them the ability to add new numbers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 短信欺诈应用有时会预装一份付费号码的列表。然后，它们会检查设备所在的国家和移动运营商，从列表中选择一个特定的号码。在其他情况下，目标号码是动态加载的，来自指挥控制服务器，这样可以给欺诈者更大的灵活性，允许他们添加新的号码。
- en: These applications may also disguise premium SMS subscriptions by hiding disclosure
    agreements or messages from the mobile operator that notify the user of charges
    or new subscriptions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序还可能通过隐藏披露协议或来自移动运营商的收费或新订阅通知消息，来伪装付费短信订阅。
- en: '***Toll Fraud***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***话费欺诈***'
- en: '*Toll fraud* applications are those that trick users into subscribing to services
    or purchasing content via charges to their phone bill. It excludes charges generated
    by premium text messages, which have their own category (discussed in the previous
    section).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*话费欺诈*应用程序是指通过向用户的电话账单收费，诱使用户订阅服务或购买内容的应用程序。它不包括通过付费短信产生的费用，后者有自己的分类（在前一部分中讨论过）。'
- en: Many payment and billing technologies allow users to buy products and subscribe
    to services by simply charging payments to their mobile phone bill, which is a
    useful solution in countries where credit or debit card usage is not widespread.
    These include direct carrier billing (DCB), Wireless Application Protocol (WAP),
    and mobile airtime transfer (MAT), which track the user’s data and airtime balance,
    their activity, and their purchases. Because they manage charges, and because
    purchases can be made relatively silently (in some cases with one click or by
    simply confirming the phone number to charge), these systems are an inviting target
    for fraudsters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多支付和计费技术允许用户通过简单地将支付费用计入手机账单来购买产品和订阅服务，这在信用卡或借记卡使用不普及的国家是一种有用的解决方案。这些技术包括直接运营商计费（DCB）、无线应用协议（WAP）和移动话费转移（MAT），它们会跟踪用户的数据和话费余额、活动和购买情况。因为它们管理费用，而且购买可以相对默默进行（在某些情况下，只需点击一次或简单确认要收费的电话号码），这些系统成为了欺诈者的诱人目标。
- en: One of the first things toll fraud applications do to engage in carrier billing
    is disable the Wi-Fi connection. When the device is using a Wi-Fi network, it
    won’t use the mobile data connection managed by the carrier, such as LTE, 3G,
    or 4G. Any traffic generated by the device will flow through the user’s Wi-Fi
    access point and internet service provider (ISP) instead. Apps can disable Wi-Fi
    by, for example, using the `setWifiEnabled` API, and enable mobile data using
    the `setMobileDataEnabled` API. Once this is done, the app may open a service
    subscription web page using a WebView with JavaScript enabled, then inject JavaScript
    to auto-click buttons that complete the subscription. The service may send text
    messages to the mobile device confirming the subscription, but the toll fraud
    app will intercept those and delete them, preventing the user from becoming aware
    of the fraudulent actions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 话费欺诈应用最先做的事情之一就是禁用Wi-Fi连接。当设备使用Wi-Fi网络时，它就不会使用由运营商管理的移动数据连接，如LTE、3G或4G。设备生成的任何流量将通过用户的Wi-Fi接入点和互联网服务提供商（ISP）进行，而不是通过移动网络。应用程序可以通过例如使用`setWifiEnabled`
    API禁用Wi-Fi，并使用`setMobileDataEnabled` API启用移动数据。一旦完成，应用程序可能会使用启用了JavaScript的WebView打开一个服务订阅网页，然后注入JavaScript自动点击按钮完成订阅。服务可能会向移动设备发送短信确认订阅，但话费欺诈应用会拦截并删除这些短信，防止用户察觉到欺诈行为。
- en: The permissions often abused by toll fraud apps include `CHANGE_WIFI` `_STATE`,
    which is needed to switch to mobile data; `RECEIVE_SMS` or `READ_SMS`, to read
    confirmation codes or subscription alerts; and `READ_PHONE_STATE`, to obtain the
    phone number or other device identifiers needed to subscribe the user to a service.
    Recently, toll fraud apps have started to abuse the `BIND` `_NOTIFICATION_LISTENER_SERVICE`
    permission to access incoming texts after a Google Play policy change that cracked
    down on apps using texts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常被话费欺诈应用滥用的权限包括`CHANGE_WIFI` `_STATE`，用于切换到移动数据；`RECEIVE_SMS`或`READ_SMS`，用于读取确认码或订阅提醒；以及`READ_PHONE_STATE`，用于获取用户的电话号码或其他设备标识符，以便将用户订阅到服务。最近，话费欺诈应用开始滥用`BIND`
    `_NOTIFICATION_LISTENER_SERVICE`权限，以在Google Play政策更改后访问接收到的短信，防止应用滥用短信。
- en: The malicious code that implements the fraudulent functionality is often obfuscated
    (for example, Base64 encoded) or dynamically fetched after install to avoid detection.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现欺诈功能的恶意代码通常会被混淆（例如，Base64编码）或在安装后动态获取，以避免被检测到。
- en: '***Call Fraud***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***电话欺诈***'
- en: 'The *call fraud* malware category is composed of applications that generate
    charges on the user’s phone bill by placing phone calls to premium numbers without
    the user’s consent or knowledge. As with SMS fraud, this type of abuse relies
    on a convenient feature that many phone carriers offer: the ability to buy products
    and subscribe to services over the phone by adding them to the user’s phone bill
    for future payment. In some cases, the billing account may be linked to automated
    payments via a credit card or a bank account. When that’s the case, the user may
    not realize that they are being charged for phone calls to toll numbers.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*电话欺诈*恶意软件类别包括通过拨打高费电话号、未经用户同意或知情，向用户电话账单中产生费用的应用程序。与短信欺诈类似，这种滥用行为依赖于许多电话运营商提供的便捷功能：通过将购买的产品或订阅的服务添加到用户的电话账单上，来通过电话支付未来费用。在某些情况下，账单账户可能会与信用卡或银行账户的自动支付挂钩。当这种情况发生时，用户可能未意识到他们正在为拨打收费电话支付费用。'
- en: In order to hide the calls, fraudulent apps may rely on the `CALL_PHONE` permission
    to initiate them without using the Dialer user interface on the device, as this
    would visually alert the user. Still, the user could potentially hear the call.
    In order to silence the audio, some malware uses the `setStreamVolume` method
    in the `AudioManager` class, which controls the volume level of audio streams,
    to set the volume to its lowest level.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏调用，欺诈应用可能依赖`CALL_PHONE`权限在不使用设备拨号界面的情况下发起电话呼叫，以避免引起用户的视觉警觉。然而，用户仍然可能听到电话铃声。为了静音，一些恶意软件使用`AudioManager`类中的`setStreamVolume`方法来控制音频流的音量，将其设置为最低音量。
- en: Other signs of call fraud malware include the use of permissions like `PROCESS_OUTGOING_CALLS`,
    which allows the application to retrieve the phone number being dialed, redirect
    the call, or terminate it, so that the application can close the call a few seconds
    after successfully establishing the connection and incurring the toll charge.
    They might also include the use of *call intents*, requests to the operating system
    to make phone calls, to actually perform a call based on predefined toll phone
    numbers or phone numbers dynamically received from a command-and-control server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其他电话欺诈恶意软件的迹象包括使用如`PROCESS_OUTGOING_CALLS`等权限，这使应用程序能够获取拨打的电话号码、重定向电话或终止电话，以便应用程序能够在成功建立连接并产生通话费用几秒钟后关闭电话。它们还可能使用*电话意图*，即向操作系统发出请求以拨打电话，实际进行基于预定收费电话号码或从指挥与控制服务器动态接收到的电话号码的电话。
- en: '***Spam***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***垃圾邮件***'
- en: '*Spam* applications send unsolicited messages to users or use the device as
    an email spam relay, often to advertise products or services.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*垃圾邮件*应用程序向用户发送未经请求的消息，或将设备用作电子邮件垃圾邮件中继，通常用于推广产品或服务。'
- en: The list of targets to spam may come from the user’s phone directory or the
    contact lists of social networking apps like Facebook and WhatsApp. They can also
    be dynamically provided by a command-and-control server or fetched from a web
    server. Once the app has collected the list of targets, it starts sending messages
    to them silently. In some cases, this may happen via text. In other cases, the
    application may try to send messages using an API (such as the Facebook API),
    although that requires the user to be logged in. Spam malware is rare nowadays.
    We include it here for completeness.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾邮件的目标列表可能来自用户的电话通讯录或社交网络应用（如Facebook和WhatsApp）的联系人列表。它们也可以通过指挥与控制服务器动态提供或从网络服务器获取。一旦应用程序收集到目标列表，就会开始静默地向这些目标发送信息。在某些情况下，这可能是通过文本消息进行的。在其他情况下，应用程序可能会尝试通过API（例如Facebook
    API）发送消息，尽管这需要用户登录。如今，垃圾邮件恶意软件已经很少见，我们在这里列出它是为了完整性。
- en: '***Ad Fraud***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***广告欺诈***'
- en: Many Android apps have the ability to fetch ads from an ad network and display
    them to the user. When an app displays an ad, a publisher and network get credit
    for that ad, a metric called an *impression*. When a user actually clicks an ad,
    advertisers generally compensate publishers for the clicks they helped produce.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安卓应用程序能够从广告网络获取广告并将其展示给用户。当一个应用展示广告时，发布者和网络会因该广告而获得积分，这一指标被称为*曝光*。当用户实际点击广告时，广告商通常会因用户的点击行为而对发布者进行补偿。
- en: 'Where there’s a money flow, there’s the possibility of abuse. The *ad fraud*
    category includes applications that maliciously manipulate mobile ad platforms
    for financial gain. There are two main classes of ad fraud: click fraud and attribution
    fraud.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有资金流动，就有滥用的可能。*广告欺诈*类别包括那些恶意操控移动广告平台以谋取经济利益的应用程序。广告欺诈有两个主要类别：点击欺诈和归因欺诈。
- en: In *click fraud*, the application fetches ads from an ad network and generates
    automated clicks without user intervention or notification. These could be in-app
    clicks simulated through Java APIs, for example, or clicks triggered via JavaScript
    code loaded into a WebView. In some cases, the app hides the ads, making them
    difficult for the user to detect, by using minimum dimensions, like 1×1 pixels.
    In other cases, the user can see the ad but does not realize that the app is producing
    click events in the background.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*点击欺诈*中，应用从广告网络获取广告，并生成自动点击，无需用户干预或通知。例如，这些点击可能是通过Java API模拟的应用内点击，或者是通过加载到WebView中的JavaScript代码触发的点击。在某些情况下，应用通过使用最小尺寸（如1×1像素）隐藏广告，使用户难以察觉。其他情况下，用户可以看到广告，但并没有意识到应用在后台产生点击事件。
- en: Traffic from click fraud applications ends up artificially inflating the number
    of clicks linked to an ad. The network tracks this number and communicates it
    to the advertiser, which in turn pays for these clicks, despite the fact that
    they were not driven by actual user interest. This type of malware defrauds advertisers,
    whose ad budgets and conversion rates may take a hit, eroding their trust in the
    ecosystem. Users might also be affected by click fraud when significant fake ad
    traffic wastes their mobile plan’s data budget and battery charge and irrelevant
    ads are presented to them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 来自点击欺诈应用的流量最终会人为地增加与广告相关联的点击数量。网络追踪这个数量并将其传达给广告主，广告主随后会为这些点击付费，尽管这些点击并非由实际的用户兴趣驱动。这类恶意软件欺诈了广告主，可能会影响他们的广告预算和转化率，侵蚀他们对生态系统的信任。用户也可能会受到点击欺诈的影响，当大量虚假广告流量浪费了他们移动套餐的数据预算和电池电量，并向他们展示了不相关的广告时。
- en: The second class of ad fraud is *attribution fraud*, which occurs when an app
    tries to change the data used to attribute an ad impression or an app install
    to a referrer or publisher. For example, if an ad displayed by the app is linked
    to a referrer identifier, the ad network will track that identifier to ensure
    that the appropriate referrer is compensated. However, an attribution fraud app
    may listen for broadcast intents that include referrer identifiers and then send
    spoofed traffic to the ad network that changes the identifier. As a consequence,
    someone else will be compensated for the impressions. In some cases, the code
    that implements attribution fraud is part of a *software development kit (SDK)*,
    a set of tools that application developers may include in their apps without knowing
    that it contains code that will try to divert ad or app install credits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类广告欺诈是*归因欺诈*，它发生在应用尝试改变用于归因广告展示或应用安装的原始数据，以将这些展示或安装归因于某个推荐人或发布者时。例如，如果广告由应用展示，并且广告与推荐人标识符相关联，广告网络将追踪该标识符，以确保适当的推荐人得到报酬。然而，一个进行归因欺诈的应用可能会监听包含推荐人标识符的广播意图，然后向广告网络发送伪造的流量，改变标识符。结果，其他人将因这些展示获得报酬。在某些情况下，实施归因欺诈的代码可能是*软件开发工具包（SDK）*的一部分，SDK是应用开发者可能会在他们的应用中包含的工具集，而他们并不知道其中包含了会尝试转移广告或应用安装积分的代码。
- en: Additional schemes may fit the definition of ad fraud. For example, for advertising
    networks that pay per impression, *impression fraud*, or manipulating how many
    ads are displayed and how often, can be used to drum up ad income. We have also
    seen more sophisticated schemes, such as ad networks that spy on their competitors’
    impression and click information, or ad networks that collect all the necessary
    pieces of information to perpetrate a fraud, send it to their servers, and then
    carry out the actual fraud server-side on simulated Android devices. None of these
    are covered in this book, however, as the ad fraud space is huge and, for some
    reason, the historically important ad fraud malware families on Android have all
    used click fraud or attribution fraud.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方案也可能符合广告欺诈的定义。例如，对于按展示付费的广告网络，*展示欺诈*，即操控广告展示数量和频率，可能被用来提高广告收入。我们还看到了一些更复杂的方案，比如广告网络监视其竞争对手的展示和点击信息，或者广告网络收集所有必要的信息来实施欺诈，发送到他们的服务器，然后在模拟的
    Android 设备上服务器端执行实际的欺诈。然而，这些内容并未在本书中涉及，因为广告欺诈领域非常庞大，并且出于某种原因，历史上重要的 Android 广告欺诈恶意软件家族都使用了点击欺诈或归因欺诈。
- en: '***Non-Android Threats***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非 Android 威胁***'
- en: 'The Android Security team defines one last malware category: *non-Android threats*.
    These applications contain some kind of malicious behavior but cannot directly
    harm Android users. In most cases, this category is used to flag Android apps
    that contain Windows malware, nearly always because the application developer’s
    computer was infected with Windows malware at build time. The use of this category
    mainly benefits app developers, as it lets them realize that something is wrong
    with their app. Actual Android users won’t be harmed by the app’s malicious components.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安全团队定义了最后一种恶意软件类别：*非 Android 威胁*。这些应用包含某种恶意行为，但无法直接危害 Android 用户。在大多数情况下，这一类别用于标记包含
    Windows 恶意软件的 Android 应用，几乎总是因为应用开发者的计算机在构建时感染了 Windows 恶意软件。使用这一类别主要有助于应用开发者，因为它让他们意识到应用存在问题。实际上，Android
    用户不会受到该应用恶意组件的影响。
- en: '**Up Next**'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接下来**'
- en: Now that we’ve introduced the Android security model and the malware categories
    tracked by Android Security, the next chapter will review 10 years of Android
    malware. We’ll provide examples of actual malware families and explain why the
    popularity of a malware category changes over time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 Android 安全模型和 Android 安全所追踪的恶意软件类别后，接下来的章节将回顾 10 年的 Android 恶意软件。我们将提供实际恶意软件家族的例子，并解释为什么某个恶意软件类别的流行度会随时间变化。
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[*OceanofPDF.com*](https://oceanofpdf.com)'
