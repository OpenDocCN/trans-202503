<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Advanced Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="advanced_ruby"/>Chapter 7. Advanced Ruby</h1></div></div></div><p><a class="indexterm" id="iddle1831"/><a class="indexterm" id="iddle1855"/><a class="indexterm" id="iddle2039"/><a class="indexterm" id="iddle2123"/>You learned the fundamentals of Ruby back in <a class="xref" href="ch01.html" title="Chapter 1. Ruby Fundamentals">Chapter 1</a>. This chapter covers some of the language’s advanced features, including modules,
        the Ruby object model, introspection, and a bit of metaprogramming.</p><p>Modules are used frequently in Rails applications to group similar functionality and
        share behavior between classes. The Ruby object model determines how methods are found and
        called in a hierarchy of inherited classes and shared code from modules. Introspection
        supports polymorphism by allowing you to look inside a class to see which methods it
        understands. Metaprogramming lets your classes respond to methods that don’t exist by
        defining methods at runtime.</p><p>Open a terminal window and launch IRB to get started. Several of the examples in this
        chapter are longer than normal. You may find it easier to type the example into your editor,
        save it as a file with the extension <span class="emphasis"><em>rb</em></span>, and then run the example in
        your terminal by entering <code class="literal">ruby</code>
        <span class="emphasis"><em><code class="literal">filename.rb</code></em></span>. Or you can simply copy and paste the
        code from your editor into IRB.</p><div class="sect1" title="Modules"><div class="titlepage"><div><div><h1 class="title"><a id="modules"/>Modules</h1></div></div></div><p><a class="indexterm" id="iddle1109"/><a class="indexterm" id="iddle1197"/><a class="indexterm" id="iddle1540"/><a class="indexterm" id="iddle1853"/><a class="indexterm" id="iddle1856"/><a class="indexterm" id="iddle1864"/>As you saw in <a class="xref" href="ch01.html" title="Chapter 1. Ruby Fundamentals">Chapter 1</a>, a module is a collection of
          methods and constants that cannot be instantiated. You define modules in basically the
          same way you define classes. Module definitions begin with the word
            <code class="literal">module</code>, followed by an uppercase name, and continue to the word
            <code class="literal">end</code>.</p><p>To demonstrate using modules, we first need a class definition. Let’s define a
          simple <code class="literal">Person</code> class:</p><a id="pro_id00194"/><pre class="programlisting">   class Person
➊    attr_accessor :name

➋    def initialize(name)
       @name = name
     end
   end</pre><p>This class uses <code class="literal">attr_accessor</code> ➊ to define getters and
          setters for the instance variable <code class="literal">@name</code>, and sets the value of
            <code class="literal">@name</code> when created ➋.</p><p>Class names are usually nouns because they represent objects. Module names are usually
          adjectives because they represent behavior. Many Ruby modules take this convention a step
          further and use adjective names ending with <span class="emphasis"><em>able</em></span>, such as
            <code class="literal">Comparable</code> and <code class="literal">Forwardable</code>.</p><p>Here’s a silly example, just to show how it’s done:</p><a id="pro_id00195"/><pre class="programlisting">module Distractable
  def distract
    puts "Ooh, kittens!"
  end
end</pre><p>Enter this module in IRB, include it in the <code class="literal">Person</code> class you
          created earlier in this chapter, and see if you can distract someone:</p><a id="pro_id00196"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>class Person</strong></span>
irb(main):002:1&gt; <span class="strong"><strong>include Distractable</strong></span>
irb(main):003:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; Person
irb(main):004:0&gt; <span class="strong"><strong>p = Person.new("Tony")</strong></span>
 =&gt; #&lt;Person:0x007fceb1163de8 @name="Tony"&gt;
irb(main):005:0&gt; <span class="strong"><strong>p.distract</strong></span>
Ooh, kittens!
=&gt; nil</pre><p>In <a class="xref" href="ch05.html" title="Chapter 5. Views">Chapter 5</a>, you also defined a module method while working with Rails
          helpers. <code class="literal">ApplicationHelper</code> is a module that is automatically mixed into
          all controllers by Rails.</p><p><a class="indexterm" id="iddle1010"/><a class="indexterm" id="iddle1513"/><a class="indexterm" id="iddle1718"/><a class="indexterm" id="iddle1729"/><a class="indexterm" id="iddle1821"/><a class="indexterm" id="iddle1836"/><a class="indexterm" id="iddle1845"/><a class="indexterm" id="iddle1857"/><a class="indexterm" id="iddle1858"/><a class="indexterm" id="iddle1867"/>Modules serve two purposes in Ruby:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Modules are used to group related methods and prevent name conflicts.</p></li><li class="listitem"><p>Modules define methods that can be mixed in to classes to provide additional
              behavior.</p></li></ul></div><p>Organizing your code becomes more important as your application grows. By providing
          namespaces and making it easy to share code between classes, modules help you break your
          code into manageable pieces. Let’s look at both of these purposes.</p><div class="sect2" title="Modules as Namespaces"><div class="titlepage"><div><div><h2 class="title"><a id="modules_as_namespaces"/>Modules as Namespaces</h2></div></div></div><p>A Ruby module can be used as a <span class="emphasis"><em>namespace,</em></span> a container for code
            such as constants or methods with related functionality.</p><p>The <code class="literal">Math</code> module is an example of a built-in Ruby module used as a
            namespace. It defines the constants <code class="literal">E</code> and <code class="literal">PI</code> as
            well as many common trigonometric and transcendental methods. The double-colon operator
              (<code class="literal">::</code>) is used to access constants in Ruby. The following example
            accesses the constant <code class="literal">PI</code> in the <code class="literal">Math</code>
            module:</p><a id="pro_id00197"/><pre class="programlisting">irb(main):006:0&gt; <span class="strong"><strong>Math::PI</strong></span>
 =&gt; 3.141592653589793</pre><p>Methods defined in a module are accessed with a dot (<code class="literal">.</code>), just
            like methods in a class:</p><a id="pro_id00198"/><pre class="programlisting">irb(main):007:0&gt; <span class="strong"><strong>Math.sin(0)</strong></span>
 =&gt; 0.0</pre></div><div class="sect2" title="Modules as Mixins"><div class="titlepage"><div><div><h2 class="title"><a id="modules_as_mixins"/>Modules as Mixins</h2></div></div></div><p>A Ruby module can also be used as a <span class="emphasis"><em>mixin</em></span> to provide additional
            functionality to a class. Ruby only supports single inheritance; that is, a class can
            only inherit from a single parent class. Modules allow you to implement something
            similar to multiple inheritance: a class can include several modules, adding each
            module’s methods to its own.</p><p>You can add a module’s methods to a class in three ways, using
              <code class="literal">include</code>, <code class="literal">prepend</code>, or <code class="literal">extend</code>.
            I discuss the effect of each of these keywords next.</p><div class="sect3" title="include"><div class="titlepage"><div><div><h3 class="title"><a id="include"/>include</h3></div></div></div><p>The <code class="literal">include</code> statement adds the methods from a module to a class
              as instance methods and is the most common way of mixing a module into a class.</p><p><a class="indexterm" id="iddle1019"/><a class="indexterm" id="iddle1234"/><a class="indexterm" id="iddle1352"/><a class="indexterm" id="iddle1827"/><a class="indexterm" id="iddle1993"/>The <code class="literal">Comparable</code> module, included in Ruby, is commonly
              used as a mixin. It adds comparison operators and the <code class="literal">between?</code>
              method to classes when included. The class only needs to implement the
                <code class="literal">&lt;=&gt;</code> operator. This operator compares two objects and
              returns <code class="literal">–1</code>, <code class="literal">0</code>, or <code class="literal">1</code>,
              depending on whether the receiver is less than, equal to, or greater than the other
              object.</p><p>To use this module as a mixin, add it <code class="literal">Person</code> class you created
              previously:</p><a id="pro_id00199"/><pre class="programlisting">   class Person
➊    include Comparable

➋    def &lt;=&gt;(other)
       name &lt;=&gt; other.name
     end
   end</pre><p>This class now includes the <code class="literal">Comparable</code> module ➊ and
              defines the <code class="literal">&lt;=&gt;</code> operator ➋ to compare the name of this
              object with the name of another object.</p><p>After entering this in IRB, create a few people and see if they can be
              compared:</p><a id="pro_id00200"/><pre class="programlisting">irb(main):008:0&gt; <span class="strong"><strong>p1 = Person.new("Tony")</strong></span>
 =&gt; #&lt;Person:0x007f91b40140a8 @name="Tony"&gt;
irb(main):009:0&gt; <span class="strong"><strong>p2 = Person.new("Matt")</strong></span>
 =&gt; #&lt;Person:0x007f91b285fea8 @name="Matt"&gt;
irb(main):010:0&gt; <span class="strong"><strong>p3 = Person.new("Wyatt")</strong></span>
 =&gt; #&lt;Person:0x007f91b401fb88 @name="Wyatt"&gt;
irb(main):011:0&gt; <span class="strong"><strong>p1 &gt; p2</strong></span>
 =&gt; true</pre><p>Here <code class="literal">p1</code> is greater then <code class="literal">p2</code> because
                <span class="emphasis"><em>T</em></span> is greater than <span class="emphasis"><em>M</em></span> alphabetically. The
                <code class="literal">between?</code> method tells you whether an object falls between two
              others:</p><a id="pro_id00201"/><pre class="programlisting">irb(main):012:0&gt; <span class="strong"><strong>p1.between? p2, p3</strong></span>
 =&gt; true</pre><p>In this case, <code class="literal">between?</code> returns <code class="literal">true</code> since
                <span class="emphasis"><em>T</em></span> is between <span class="emphasis"><em>M</em></span> and <span class="emphasis"><em>W</em></span>
              alphabetically, which means it works as expected.</p></div><div class="sect3" title="prepend"><div class="titlepage"><div><div><h3 class="title"><a id="prepend"/>prepend</h3></div></div></div><p>The <code class="literal">prepend</code> statement also adds a module’s methods to a
              class, but <code class="literal">prepend</code> inserts the module’s methods
                <span class="emphasis"><em>before</em></span> the class’s methods. This means if the module
              defines a method with the same name as the class, the module’s method will be
              executed instead of the class’s method. Using <code class="literal">prepend</code>, you
              can override a method in the class by writing a method in the module with the same
              name.</p><p>One practical use for <code class="literal">prepend</code> is memoization.
                <span class="emphasis"><em>Memoization</em></span> is an optimization technique in which a program
              stores the result of a calculation to avoid repeating the same calculation multiple
              times.</p><p><a class="indexterm" id="iddle1288"/><a class="indexterm" id="iddle1562"/><a class="indexterm" id="iddle1828"/>For example, imagine you wanted to implement the Fibonacci sequence in
              Ruby. The first two numbers in the Fibonacci sequence are zero and one. Each
              subsequent number is the sum of the previous two. Here is a method to calculate the
                <span class="emphasis"><em>n</em></span>th value of the Fibonacci sequence in Ruby:</p><a id="pro_id00202"/><pre class="programlisting">  class Fibonacci
    def calc(n)
      return n if n &lt; 2
➊     return calc(n - 1) + calc(n - 2)
    end
  end</pre><p>Notice that the <code class="literal">calc</code> method is recursive. Every call to
                <code class="literal">calc</code> with a value of <code class="literal">n</code> greater than 1 results
              in two more calls to itself ➊. Try creating an instance of this class and
              calculating some small values of <code class="literal">n</code>:</p><a id="pro_id00203"/><pre class="programlisting">irb(main):013:0&gt; <span class="strong"><strong>f = Fibonacci.new</strong></span>
 =&gt; #&lt;Fibonacci:0x007fd8d3269518&gt;
irb(main):014:0&gt; <span class="strong"><strong>f.calc 10</strong></span>
 =&gt; 55
irb(main):015:0&gt; <span class="strong"><strong>f.calc 30</strong></span>
 =&gt; 832040</pre><p>As you call the method with larger values of <code class="literal">n</code>, the method
              takes noticeably longer to run. For values of <code class="literal">n</code> around 40, the
              method takes several seconds to return an answer.</p><p>The Fibonacci <code class="literal">calc</code> method is slow because it repeats the same
              calculations many times. But if you define a module to implement memoization, the
              calculations should take significantly less time. Let’s do that now:</p><a id="pro_id00204"/><pre class="programlisting">   module Memoize
     def calc(n)
➊      @@memo ||= {}
➋      @@memo[n] ||= super
     end
   end</pre><p>The <code class="literal">Memoize</code> module also defines a <code class="literal">calc</code>
              method. This method has a couple of interesting features. First, it initializes a
              class variable named <code class="literal">@@memo</code> ➊ with an empty hash if it is
              not already initialized. This hash stores the result of the <code class="literal">calc</code>
              method for each value of <code class="literal">n</code>. Next, it assigns the return value of
                <code class="literal">super</code> to <code class="literal">@@memo</code> at key <code class="literal">n</code>
              ➋ if that value is not already assigned. Because we are using
                <code class="literal">prepend</code> to add this module into <code class="literal">Fibonacci</code>,
                <code class="literal">super</code> calls the original <code class="literal">calc</code> method defined
              by the class.</p><p>Each time the <code class="literal">calc</code> method is called, <code class="literal">@@memo</code>
              stores the Fibonacci number for the value <code class="literal">n</code>. For example, after
              calling <code class="literal">calc(3)</code>, the <code class="literal">@@memo</code> hash holds these
              keys and values:</p><a id="pro_id00205"/><pre class="programlisting">{
  0 =&gt; 0,
  1 =&gt; 1,
  2 =&gt; 1,
  3 =&gt; 2
}</pre><p><a class="indexterm" id="iddle1318"/><a class="indexterm" id="iddle1473"/><a class="indexterm" id="iddle1558"/><a class="indexterm" id="iddle1593"/>On each line, the key (the first number) is the value of
                <code class="literal">n</code> and the value (the second number) is the corresponding
              Fibonacci number. The Fibonacci number for 0 is 0, 1 is 1, 2 is 1, and 3 is 2. By
              storing these intermediate values, the <code class="literal">calc</code> method never needs to
              perform the same calculation more than once. Use <code class="literal">prepend Memoize</code> to
              add the <code class="literal">Memoize</code> module to the <code class="literal">Fibonacci</code> class
              and try it for yourself:</p><a id="pro_id00206"/><pre class="programlisting">irb(main):016:0&gt; <span class="strong"><strong>class Fibonacci</strong></span>
irb(main):017:1&gt; <span class="strong"><strong>prepend Memoize</strong></span>
irb(main):018:1&gt; <span class="strong"><strong>end</strong></span>
 =&gt; Fibonacci
irb(main):019:0&gt; <span class="strong"><strong>f.calc 40</strong></span>
 =&gt; 102334155</pre><p>Now that the values of <code class="literal">calc</code> are being memoized, you should be
              able to call <code class="literal">calc</code> for greater values of <code class="literal">n</code> and
              get an answer almost instantly. Try it with <code class="literal">n</code> = 100 or even
                <code class="literal">n</code> = 1000. Note that you didn’t have to restart IRB or
              instantiate a new Fibonacci object. Method lookup in Ruby is dynamic.</p></div><div class="sect3" title="extend"><div class="titlepage"><div><div><h3 class="title"><a id="extend"/>extend</h3></div></div></div><p>When you use <code class="literal">include</code> or <code class="literal">prepend</code> to add a
              module to a class, the module’s methods are added to the class as instance
              methods. In <a class="xref" href="ch01.html" title="Chapter 1. Ruby Fundamentals">Chapter 1</a>, you learned that there are also class
              methods that are called on the class itself instead of on an instance of the class.
              The <code class="literal">extend</code> statement adds the methods from a module as class
              methods. Use <code class="literal">extend</code> to add behavior to the class itself instead of
              instances of the class.</p><p>The Ruby standard library includes a module named <code class="literal">Forwardable</code>,
              which you can use to extend a class. The <code class="literal">Forwardable</code> module
              contains methods useful for delegation. <span class="emphasis"><em>Delegation</em></span> means relying
              on another object to handle a set of method calls. Delegation is a way to reuse code
              by assigning the responsibility of certain method calls to another class.</p><p>For example, imagine a class named <code class="literal">Library</code> that manages a
              collection of books. We store the books in an array named
              <code class="literal">@books</code>:</p><a id="pro_id00207"/><pre class="programlisting">class Library
  def initialize(books)
    @books = books
  end
end</pre><p>We can store our books, but we can’t do anything with them yet. We could use
                <code class="literal">attr_accessor</code> to make the <code class="literal">@books</code> array
              available outside of the class, but that would make all of the array’s methods
              available to users of our class. A user could then call methods such as
                <code class="literal">clear</code> or <code class="literal">reject</code> to remove all of the books
              from our library.</p><p><a class="indexterm" id="iddle1054"/><a class="indexterm" id="iddle1317"/><a class="indexterm" id="iddle1470"/><a class="indexterm" id="iddle2018"/><a class="indexterm" id="iddle2124"/><a class="indexterm" id="iddle2169"/>Instead, let’s delegate a few methods to the
                <code class="literal">@books</code> array to provide the functionality we need—a way to
              get the size of the library and add a book.</p><a id="pro_id00208"/><pre class="programlisting">1 require 'forwardable'
  class Library
2   extend Forwardable
3   def_delegators :@books, :size, :push

    def initialize(books)
      @books = books
    end
  end</pre><p>The <code class="literal">Forwardable</code> module is in the Ruby Standard Library, not the
              Ruby core, so we first need to <code class="literal">require</code> it ➊. Next, we use
                <code class="literal">extend</code> to add the <code class="literal">Forwardable</code> methods to our
              class as class methods ➋. Finally, we can call the
                <code class="literal">def_delegators</code> method ➌. The first argument to this method
              is a symbol representing the instance variable to which we’re delegating
              methods.</p><p>In this case, the instance variable is <code class="literal">@books</code>. The rest of the
              arguments are symbols representing the methods we want to delegate. The
                <code class="literal">size</code> method returns the number of elements in the array. The
                <code class="literal">push</code> method appends a new element to the end of an array.</p><p>In the following example, <code class="literal">lib.size</code> initially prints 2 because
              we have two books in our library. After adding a book, the size updates to 3.</p><a id="pro_id00209"/><pre class="programlisting">irb(main):020:0&gt; <span class="strong"><strong>lib = Library.new ["Neuromancer", "Snow Crash"]</strong></span>
 =&gt; #&lt;Library:0x007fe6c91854e0 @books=["Neuromancer", "Snow Crash"]&gt;
irb(main):021:0&gt; <span class="strong"><strong>lib.size</strong></span>
 =&gt; 2
irb(main):022:0&gt; <span class="strong"><strong>lib.push "The Hobbit"</strong></span>
 =&gt; ["Neuromancer", "Snow Crash", "The Hobbit"]
irb(main):023:0&gt; <span class="strong"><strong>lib.size</strong></span>
 =&gt; 3</pre></div></div></div><div class="sect1" title="Ruby Object Model"><div class="titlepage"><div><div><h1 class="title"><a id="ruby_object_model"/>Ruby Object Model</h1></div></div></div><p>The <span class="emphasis"><em>Ruby object model</em></span> explains how Ruby locates a method when it
          is called. With inheritance and modules, you may find yourself wondering exactly where a
          particular method is defined or, in the case of multiple methods with the same name, which
          one is actually invoked by a particular call.</p><div class="sect2" title="Ancestors"><div class="titlepage"><div><div><h2 class="title"><a id="ancestors"/>Ancestors</h2></div></div></div><p>Continuing with the simple <code class="literal">Person</code> class defined previously, we
            can find out a lot about this class in IRB. First, let’s see which classes and
            modules define methods for the <code class="literal">Person</code> class:</p><a id="pro_id00210"/><pre class="programlisting">irb(main):024:0&gt; <span class="strong"><strong>Person.ancestors</strong></span>
 =&gt; [Person, Distractable, Comparable, Object, Kernel, BasicObject]</pre><p><a class="indexterm" id="iddle1219"/><a class="indexterm" id="iddle1320"/><a class="indexterm" id="iddle1321"/><a class="indexterm" id="iddle1748"/><a class="indexterm" id="iddle1786"/><a class="indexterm" id="iddle1835"/><a class="indexterm" id="iddle1887"/><a class="indexterm" id="iddle1901"/>The class method <code class="literal">ancestors</code> returns a list of classes that
              <code class="literal">Person</code> inherits from and the modules it includes. In this example,
              <code class="literal">Person</code>, <code class="literal">Object</code>, and
              <code class="literal">BasicObject</code> are classes, whereas <code class="literal">Distractable</code>,
              <code class="literal">Comparable,</code> and <code class="literal">Kernel</code> are modules. You can find
            out which of these are classes and which are modules by calling the
              <code class="literal">class</code> method as explained in the <span class="emphasis"><em>Class</em></span> section
            below.</p><p><code class="literal">Object</code> is the default root of all Ruby objects. Object inherits
            from BasicObject and mixes in the Kernel module. BasicObject is the parent class of all
            classes in Ruby. You can think of it as a blank class that all other classes build on.
            Kernel defines many of the Ruby methods that are called without a receiver, such as puts
            and exit. Every time you call puts, you’re actually calling the instance method
            puts in the Kernel module.</p><p>The order of this list indicates the order in which Ruby searches for a called
            method. Ruby first looks for a method definition in the class <code class="literal">Person</code>
            and then continues looking through the list until the method is found. If Ruby
            doesn’t find the method, it raises a <code class="literal">NoMethodError</code>
            exception.</p></div><div class="sect2" title="Methods"><div class="titlepage"><div><div><h2 class="title"><a id="methods-id00015"/>Methods</h2></div></div></div><p>You can see a list of the class methods and instance methods defined by a class by
            calling <code class="literal">methods</code> and <code class="literal">instance_methods</code>,
            respectively. These lists include methods defined by all parent classes by default. Pass
            the parameter <code class="literal">false</code> to leave out only these:</p><a id="pro_id00211"/><pre class="programlisting">irb(main):025:0&gt; <span class="strong"><strong>Person.methods</strong></span>
 =&gt; [:allocate, :new, :superclass, :freeze, :===, :==, ... ]
irb(main):026:0&gt; <span class="strong"><strong>Person.methods(false)</strong></span>
 =&gt; []
irb(main):027:0&gt; <span class="strong"><strong>Person.instance_methods(false)</strong></span>
 =&gt; [:name, :name=, :&lt;=&gt;]</pre><p>The <code class="literal">Person</code> class contains almost 100 different class methods from
            its ancestors, but it defines none of its own, so the call to
              <code class="literal">methods(false)</code> returns an empty array. The call to
              <code class="literal">instance_methods</code> returns the <code class="literal">name</code> and
              <code class="literal">name=</code> methods defined by <code class="literal">attr_accessor</code> and the
              <code class="literal">&lt;=&gt;</code> method that we defined in the body of the class.</p></div><div class="sect2" title="Class"><div class="titlepage"><div><div><h2 class="title"><a id="class"/>Class</h2></div></div></div><p>The last piece of the object model concerns the <code class="literal">Person</code> class
            itself. Everything in Ruby is an object, that is, an instance of a class. Therefore, the
              <code class="literal">Person</code> class must be an instance of some class.</p><a id="pro_id00212"/><pre class="programlisting">irb(main):028:0&gt; <span class="strong"><strong>Person.class</strong></span>
 =&gt; Class</pre><p>All Ruby classes are instances of the class <code class="literal">Class</code>. Defining a
            class, such as <code class="literal">Person</code>, creates an instance of the class
              <code class="literal">Class</code> and assigns it to a global constant, in this case
              <code class="literal">Person</code>. The most important method in <code class="literal">Class</code> is
              <code class="literal">new</code>, which is responsible for allocating memory for a new object
            and calling the <code class="literal">initialize</code> method.</p><p><a class="indexterm" id="iddle1749"/><a class="indexterm" id="iddle1757"/><a class="indexterm" id="iddle1760"/><a class="indexterm" id="iddle2079"/><code class="literal">Class</code> has its own set of ancestors:</p><a id="pro_id00213"/><pre class="programlisting">irb(main):029:0&gt; <span class="strong"><strong>Class.ancestors</strong></span>
 =&gt; [Class, Module, Object, Kernel, BasicObject]</pre><p>Class inherits from the class <code class="literal">Module</code>, which inherits from
              <code class="literal">Object</code> as before. The <code class="literal">Module</code> class contains
            definitions of several of the methods used in this section such as
              <code class="literal">ancestors</code> and <code class="literal">instance_methods</code>.</p></div></div><div class="sect1" title="Introspection"><div class="titlepage"><div><div><h1 class="title"><a id="introspection"/>Introspection</h1></div></div></div><p><span class="emphasis"><em>Introspection</em></span>, also known as <span class="emphasis"><em>reflection</em></span>, is
          the ability to examine an object’s type and other properties as a program is
          running. You’ve already seen how to determine an object’s type by calling
            <code class="literal">class</code> and how to get a list of methods defined by an object by
          calling <code class="literal">methods</code> and <code class="literal">instance_methods</code>, but
          Ruby’s <code class="literal">Object</code> class defines several more methods just for
          introspecting objects. For example, given an object, you may want to determine if it
          belongs to a particular class:</p><a id="pro_id00214"/><pre class="programlisting">irb(main):030:0&gt; <span class="strong"><strong>p = Person.new("Tony")</strong></span>
 =&gt; #&lt;Person:0x007fc0ca1a6278 @name="Tony"&gt;
irb(main):031:0&gt; <span class="strong"><strong>p.is_a? Person</strong></span>
 =&gt; true</pre><p>The <code class="literal">is_a?</code> method returns <code class="literal">true</code> if the given class
          is the class of the receiving object. In this case, it returns <code class="literal">true</code>
          because the object <code class="literal">p</code> is a <code class="literal">Person</code>.</p><a id="pro_id00215"/><pre class="programlisting">irb(main):032:0&gt; <span class="strong"><strong>p.is_a? Object</strong></span>
 =&gt; true</pre><p>It also returns <code class="literal">true</code> if the given class or module is an ancestor of
          the receiving object. In this case, <code class="literal">Object</code> is an ancestor of
            <code class="literal">Person</code>, so <code class="literal">is_a?</code> returns
          <code class="literal">true</code>.</p><p>Use the <code class="literal">instance_of?</code> method if you need to determine exactly which
          class was used to create an object:</p><a id="pro_id00216"/><pre class="programlisting">irb(main):033:0&gt; <span class="strong"><strong>p.instance_of? Person</strong></span>
 =&gt; true
irb(main):034:0&gt; <span class="strong"><strong>p.instance_of? Object</strong></span>
 =&gt; false</pre><p>The <code class="literal">instance_of?</code> method returns <code class="literal">true</code> only if the
          receiving object is an instance of the given class. This method returns
            <code class="literal">false</code> for ancestors and classes inheriting from the given class. This
          type of introspection is helpful in some situations, but generally you don’t need to
          know the exact class used to create an object—just the object’s
          capabilities.</p></div><div class="sect1" title="Duck Typing"><div class="titlepage"><div><div><h1 class="title"><a id="duck_typing"/>Duck Typing</h1></div></div></div><p><a class="indexterm" id="iddle1516"/><a class="indexterm" id="iddle1888"/><a class="indexterm" id="iddle2105"/>In <span class="emphasis"><em>duck typing,</em></span> you only need to know whether an object
          accepts the methods you need to call. If the object responds to the needed methods, you
          don’t have to worry about class names or inheritance. The name duck typing comes
          from the phrase, “If it walks like a duck and quacks like a duck, call it a
          duck.”</p><p>In Ruby, you can use the <code class="literal">respond_to?</code> method to see if an object
          responds to a particular method. If <code class="literal">respond_to?</code> returns
            <code class="literal">false</code>, then calling the method raises a
            <code class="literal">NoMethodError</code> exception as explained earlier.</p><p>For example, imagine a simple method to print some information to a file with a
          timestamp:</p><a id="pro_id00217"/><pre class="programlisting">def write_with_time(file, info)
  file.puts "#{Time.now} - #{info}"
end</pre><p>You can try this method in IRB.</p><a id="pro_id00218"/><pre class="programlisting">➊ irb(main):001:0&gt; <span class="strong"><strong>f = File.open("temp.txt", "w")</strong></span>
   =&gt; #&lt;File:temp.txt&gt;
➋ irb(main):002:0&gt; <span class="strong"><strong>write_with_time(f, "Hello, World!")</strong></span>
   =&gt; nil
➌ irb(main):003:0&gt; <span class="strong"><strong>f.close</strong></span>
   =&gt; nil</pre><p>First, open a <code class="literal">File</code> named <span class="emphasis"><em>temp.txt</em></span> in the
          current directory and store the <code class="literal">File</code> instance in the variable
            <code class="literal">f</code> ➊. Then pass <code class="literal">f</code> and the message
            <code class="literal">"Hello, World!"</code> to the <code class="literal">write_with_time</code> method
          ➋. Finally, close the <code class="literal">File</code> with <code class="literal">f.close</code>
          ➌.</p><p>The file <span class="emphasis"><em>temp.txt</em></span> in the current directory now contains a single
          line similar to the one here:</p><a id="pro_id00219"/><pre class="programlisting">2014-05-21 16:52:07 -0500 - Hello, World!</pre><p>This method works great until someone accidentally passes a value to it that
          isn’t a file, such as <code class="literal">nil</code>. Here’s a possible fix for that
          bug:</p><a id="pro_id00220"/><pre class="programlisting">  def write_with_time(file, info)
➊  if file.instance_of? File
      file.puts "#{Time.now} - #{info}"
    else
      raise ArgumentError
    end
  end</pre><p>This fix solves the problem by checking to see if <code class="literal">file</code> is an
          instance of the <code class="literal">File</code> class ➊, but it also limits the usefulness
          of this method. Now it <span class="emphasis"><em>only</em></span> works with files. What if you want to
          write over the network using a <code class="literal">Socket</code> or write to the console using
            <code class="literal">STDOUT</code>?</p><p><a class="indexterm" id="iddle1471"/><a class="indexterm" id="iddle1560"/><a class="indexterm" id="iddle1832"/><a class="indexterm" id="iddle2340"/>Instead of testing the <span class="emphasis"><em>type</em></span> of <code class="literal">file</code>,
          let’s test its <span class="emphasis"><em>capabilities</em></span>:</p><a id="pro_id00221"/><pre class="programlisting">  def write_with_time(file, info)
➊   if file.respond_to?(:puts)
      file.puts "#{Time.now} - #{info}"
    else
      raise ArgumentError
    end
  end</pre><p>You know that the <code class="literal">write_with_time</code> method calls the method
            <code class="literal">puts</code>, so check to see if <code class="literal">file</code> responds to the
            <code class="literal">puts</code> method ➊. Now, <code class="literal">write_with_time</code> works
          with any data type that responds to the <code class="literal">puts</code> method.</p><p>Using duck typing leads to code that can be easily reused. Look for more opportunities
          to apply duck typing as you build applications.</p></div><div class="sect1" title="Metaprogramming"><div class="titlepage"><div><div><h1 class="title"><a id="metaprogramming"/>Metaprogramming</h1></div></div></div><p><span class="emphasis"><em>Metaprogramming</em></span> is the practice of writing code that works with
          code instead of data. With Ruby, you can write code that defines new behavior at runtime.
          The techniques in this section can save you time and remove duplication from your code by
          allowing Ruby to generate methods when your program is loaded or as it runs.</p><p>This section covers two different ways of dynamically defining methods:
            <code class="literal">define_method</code> and <code class="literal">class_eval</code>. It also covers
            <code class="literal">method_missing</code>, so you can respond to methods that haven’t been
          defined.</p><div class="sect2" title="define_method"><div class="titlepage"><div><div><h2 class="title"><a id="defineunderscoremethod"/>define_method</h2></div></div></div><p>Let’s say we have an application with a list of features that can be enabled
            for users. The <code class="literal">User</code> class stores these features in a hash named
              <code class="literal">@features</code>. If a user has access to a feature, the corresponding
            hash value will be <code class="literal">true</code>.</p><p>We want to add methods of the form <code class="literal">can_</code>
            <span class="emphasis"><em><code class="literal">feature</code></em></span><code class="literal">!</code> and
              <code class="literal">can_</code>
            <span class="emphasis"><em><code class="literal">feature</code></em></span><code class="literal">?</code> to enable a feature
            and check if a feature is enabled, respectively. Rather than write several mostly
            identical methods, we can iterate over the list of available features and use
              <code class="literal">define_method</code>, as shown here, to define the individual
            methods:</p><a id="pro_id00222"/><pre class="programlisting">  class User
➊   FEATURES = ['create', 'update', 'delete']

    FEATURES.each do |f|
➋     define_method "can_#{f}!" do
        @features[f] = true
      end

➌     define_method "can_#{f}?" do
➍        !!@features[f]
       end
     end
     def initialize
       @features = {}
     end
   end</pre><p><a class="indexterm" id="iddle1198"/><a class="indexterm" id="iddle1322"/><a class="indexterm" id="iddle1894"/>The <code class="literal">User</code> class first creates a constant array ➊ of
            available features named <code class="literal">FEATURES</code>. It then iterates over
              <code class="literal">FEATURES</code> using <code class="literal">each</code> and calls
              <code class="literal">define_method</code> to create a method of the form
              <code class="literal">can_</code>
            <span class="emphasis"><em><code class="literal">feature</code></em></span><code class="literal">!</code> ➋ to allow a
            user access to a feature. Still inside the <code class="literal">each</code> block, the class also
            defines a method of the form <code class="literal">can_</code>
            <span class="emphasis"><em><code class="literal">feature</code></em></span><code class="literal">?</code> ➌ that
            determines whether a user has access to the feature. This method converts the value
              <code class="literal">@features[f]</code> to either <code class="literal">true</code> or
              <code class="literal">false</code> by using two NOT operators ➍.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>Using two NOT operators isn’t strictly necessary because the
                  <code class="literal">@features</code> hash returns <code class="literal">nil</code> for keys without
                values and Ruby treats <code class="literal">nil</code> as <code class="literal">false</code>, but this
                technique is commonly used.</em></span></p></div><p>Now let’s create a new <code class="literal">User</code> and try the dynamically defined
            methods:</p><a id="pro_id00223"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>user = User.new</strong></span>
 =&gt; #&lt;User:0x007fc01b95abe0 @features={}&gt;
irb(main):002:0&gt; <span class="strong"><strong>user.can_create!</strong></span>
 =&gt; true
irb(main):003:0&gt; <span class="strong"><strong>user.can_create?</strong></span>
 =&gt; true
irb(main):004:0&gt; <span class="strong"><strong>user.can_update?</strong></span>
 =&gt; false
irb(main):005:0&gt; <span class="strong"><strong>user.can_delete?</strong></span>
 =&gt; false</pre><p>If you want more practice with <code class="literal">define_method</code>, see if you can add
            methods of the form
              <code class="literal">cannot_</code><span class="emphasis"><em><code class="literal">feature</code></em></span><code class="literal">!</code>,
            which disables a feature for the user. More details are provided in Exercise 3 at the
            end of this chapter.</p></div><div class="sect2" title="class_eval"><div class="titlepage"><div><div><h2 class="title"><a id="classunderscoreeval"/>class_eval</h2></div></div></div><p>The <code class="literal">class_eval</code> method evaluates a string of code as if it were
            typed directly into the class definition. Using <code class="literal">class_eval</code> is an easy
            way to add instance methods to a class at runtime.</p><p>When I discussed <code class="literal">attr_accessor</code> in <a class="xref" href="ch01.html" title="Chapter 1. Ruby Fundamentals">Chapter 1</a>, you learned that it defines getter and setter methods
            for instance variables in a class, but I didn’t discuss exactly how those methods
            were defined. The <code class="literal">attr_accessor</code> method is built in to Ruby. You
            don’t need to define it yourself, but you can learn about
              <code class="literal">class_eval</code> by implementing your own version of
              <code class="literal">attr_accessor</code>.</p><a id="pro_id00224"/><pre class="programlisting">➊ class Accessor
➋   def self.accessor(attr)
      class_eval "
➌       def #{attr}
          @#{attr}
          end

➍         def #{attr}=(val)
            @#{attr} = val
          end
         "
       end
     end</pre><p><a class="indexterm" id="iddle1032"/>Here, you define a class named <code class="literal">Accessor</code> ➊ with a
            single class method named <code class="literal">accessor</code> ➋. This method works like
            the built-in <code class="literal">attr_accessor</code>. It accepts a single parameter
            representing the attribute for which you’re creating getter and setter methods.
            Pass the string to <code class="literal">class_eval</code>, which uses string interpolation to
            insert the value of <code class="literal">attr</code> as needed to define two methods. The first
            method has the same name as the attribute and returns the value of the attribute
            ➌. The second method is the attribute name followed by an equal sign. It sets the
            attribute to a specified value <code class="literal">val</code> ➍.</p><p>For example, if <code class="literal">attr</code> is <code class="literal">:name</code>, then
              <code class="literal">accessor</code> defines the methods <code class="literal">name</code> and
              <code class="literal">name=</code> by replacing <code class="literal">attr</code> with
              <span class="emphasis"><em>name</em></span> in the specified places. This is a little hard to follow
            without an example. The following code uses the <code class="literal">accessor</code> method in a
            class:</p><a id="pro_id00225"/><pre class="programlisting">➊ class Element &lt; Accessor
➋   accessor :name

    def initialize(name)
      @name = name
    end
  end</pre><p>First, you have the <code class="literal">Element</code> class inherit from the
              <code class="literal">Accessor</code> class ➊ so the <code class="literal">accessor</code> method
            is available. Then, you pass the name of the instance variable to
              <code class="literal">accessor</code> ➋. Here, you pass the symbol
              <code class="literal">:name</code>. When the program runs, the call to
              <code class="literal">class_eval</code> automatically generates this code inside the
              <code class="literal">Element</code> class:</p><a id="pro_id00226"/><pre class="programlisting">➊ def name
    @name
  end

➋ def name=(val)
    @name = val
  end</pre><p>The <code class="literal">name</code> method returns the current value of the instance
            variable <code class="literal">@name</code> ➊. The <code class="literal">name=</code> method accepts
            a value and assigns it to <code class="literal">@name</code> ➋. Test this by creating an
            instance of the <code class="literal">Element</code> class and trying to get and set the value of
              <code class="literal">name</code>:</p><a id="pro_id00227"/><pre class="programlisting">➊ irb(main):001:0&gt; <span class="strong"><strong>e = Element.new "lead"</strong></span>
   =&gt; #&lt;Element:0x007fc01b840110 @name="lead"&gt;
➋ irb(main):002:0&gt; <span class="strong"><strong>e.name = "gold"</strong></span>
   =&gt; "gold"
➌ irb(main):003:0&gt; <span class="strong"><strong>puts e.name</strong></span>
  gold
   =&gt; nil</pre><p><a class="indexterm" id="iddle1833"/><a class="indexterm" id="iddle1889"/><a class="indexterm" id="iddle2023"/>First, create a new <code class="literal">Element</code> and initialize its name with
              <code class="literal">"lead"</code> ➊. Next, use the <code class="literal">name=</code> method to
            assign the new name <code class="literal">"gold"</code> ➋. Finally, use the
              <code class="literal">name</code> method to display the value of <code class="literal">@name</code>
            ➌. There you have it. With a bit of metaprogramming magic, you turned lead into
            gold.</p></div><div class="sect2" title="method_missing"><div class="titlepage"><div><div><h2 class="title"><a id="methodunderscoremissing"/>method_missing</h2></div></div></div><p>Whenever Ruby can’t find a method, it calls <code class="literal">method_missing</code>
            on the receiver. This method receives the original method name as a symbol, an array of
            arguments, and any block passed to the method call.</p><p>By default, <code class="literal">method_missing</code> calls <code class="literal">super</code>, which
            passes the method up the ancestor chain until it finds an ancestor class containing the
            method. If the method reaches the <code class="literal">BasicObject</code> class, it raises a
              <code class="literal">NoMethodError</code> exception. You can override
              <code class="literal">method_missing</code> by defining your own implementation in a class to
            intercept these method calls and add your own behavior.</p><p>Let’s start with a simple example so you can see how it works. This class
            echoes any unknown method calls back to you three times:</p><a id="pro_id00228"/><pre class="programlisting">class Echo
  def method_missing(name, *args, &amp;block)
    word = name
    puts "#{word}, #{word}, #{word}"
  end
end</pre><p>Now that <code class="literal">method_missing</code> is overridden, if you try to call a
            nonexistent method on an instance of this class, you’ll just see that
            method’s “echo” in the terminal:</p><a id="pro_id00229"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>echo = Echo.new</strong></span>
 =&gt; #&lt;Echo:0x007fa8131c9590&gt;
irb(main):002:0&gt; <span class="strong"><strong>echo.hello</strong></span>
 =&gt; hello, hello, hello</pre><p>A real-world use for <code class="literal">method_missing</code> is the Rails dynamic finder.
            Using dynamic finders, you can write Active Record queries like
              <code class="literal">Post.find_by_title("First Post")</code> instead of
              <code class="literal">Post.where(title: "First Post").first</code>.</p><p>Dynamic finders can be implemented using <code class="literal">method_missing</code>.
            Let’s define our own version of dynamic finders. Instead of method names like
              <code class="literal">find_by_</code><span class="emphasis"><em><code class="literal">attribute</code></em></span>,
            we’ll use
              <code class="literal">query_by_</code><span class="emphasis"><em><code class="literal">attribute</code></em></span> so we
            can avoid conflicts with the built-in methods.</p><p><a class="indexterm" id="iddle2080"/><a class="indexterm" id="iddle2106"/><a class="indexterm" id="iddle2336"/>Open the <code class="literal">Post</code> model at
              <span class="emphasis"><em>app/models/post.rb</em></span> in your blog directory to follow along with
            this example:</p><a id="pro_id00230"/><pre class="programlisting">  class Post &lt; ActiveRecord::Base
    validates :title, :presence =&gt; true
    has_many :comments

➊   <span class="strong"><strong>def self.method_missing(name, *args, &amp;block)</strong></span>
➋     <span class="strong"><strong>if name =~ /\Aquery_by_(.+)\z/</strong></span>
➌       <span class="strong"><strong>where($1 =&gt; args[0]).first</strong></span>
      <span class="strong"><strong>else</strong></span>
➍       <span class="strong"><strong>super</strong></span>
      <span class="strong"><strong>end</strong></span>
    <span class="strong"><strong>end</strong></span>
 end</pre><p>First, define the <code class="literal">method_missing</code> class method ➊ because
            our <code class="literal">query_by_</code><span class="emphasis"><em><code class="literal">attribute</code></em></span> method
            will be called on the <code class="literal">Post</code> class. Next, test the name against a
            regular expression ➋.</p><p>Finally, call the built-in <code class="literal">where</code> method ➌ using the string
            captured by the regular expression and the first argument passed to the method. Be sure
            to call <code class="literal">super</code> ➍ if the string doesn’t match; this
            ensures that unknown methods will be sent to the parent class.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note02"/>Note</h3><p><span class="emphasis"><em>The regular expression <code class="literal">/\Aquery_by_(.+)\z/</code> matches
                strings that start with “query_by_” and then captures the rest of the
                string using parenthesis. A full discussion of regular expressions is beyond the
                scope of this book. The website</em></span>
              <a class="ulink" href="http://rubular.com/">http://rubular.com/</a>
              <span class="emphasis"><em>is a great way to edit and test regular expressions
              online.</em></span></p></div><p>The real dynamic finders also check to make sure the captured string matches an
            attribute of the model. If you try to call our
                <code class="literal">query_by_</code><span class="emphasis"><em><code class="literal">attribute</code></em></span> method
            with nonexistent column, it raises a <code class="literal">SQLException</code>.</p><a id="pro_id00231"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>Post.query_by_title "First Post"</strong></span>
 =&gt; #&lt;Post id: 1, ...&gt;</pre><p>Our implementation of
                <code class="literal">query_by_</code><span class="emphasis"><em><code class="literal">attribute</code></em></span> has
            one more problem:</p><a id="pro_id00232"/><pre class="programlisting">irb(main):002:0&gt; <span class="strong"><strong>Post.respond_to? :query_by_title</strong></span>
 =&gt; false</pre><p>Because we’re overriding <code class="literal">method_missing</code> to call this
            method, Ruby doesn’t know that the <code class="literal">Post</code> class can respond to
            it. To fix this, we need to also override the <code class="literal">respond_to_missing?</code>
            method in the <code class="literal">Post</code> model at
            <span class="emphasis"><em>app/models/post.rb</em></span>.</p><a id="pro_id00233"/><pre class="programlisting">   class Post &lt; ActiveRecord::Base
     --<span class="emphasis"><em>snip</em></span>--

     <span class="strong"><strong>def self.respond_to_missing?(name, include_all=false)</strong></span>
➊      <span class="strong"><strong>name.to_s.start_with?("query_by_") || super</strong></span>
    <span class="strong"><strong>end</strong></span>
  end</pre><p>Instead of the regular expression used in <code class="literal">method_missing</code>, we just
            check if the method name starts with <code class="literal">"query_by_"</code> ➊. If it
            does, this method returns <code class="literal">true</code>. Otherwise, <code class="literal">super</code>
            is called. Now restart the Rails console and try again:</p><a id="pro_id00234"/><pre class="programlisting">irb(main):001:0&gt; <span class="strong"><strong>Post.respond_to? :query_by_title</strong></span>
 =&gt; true</pre><p>With this change in place, <code class="literal">respond_to?</code> returns
              <code class="literal">true</code> as expected. Remember to always override
              <code class="literal">respond_to_missing?</code> when using <code class="literal">method_missing</code>.
            Otherwise, users of your class have no way of knowing which methods it accepts, and the
            duck typing techniques covered earlier will fail.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00016"/>Summary</h1></div></div></div><p>If you write enough Ruby, then you will eventually see all of the techniques covered
          in this chapter used in real-world programs. When that time comes, you can be confident
          that you’ll understand what the code does, instead of just assuming that
          metaprogramming is some kind of magic.</p><p>In the next chapter, you’ll start building a new Rails application from scratch.
          Along the way I’ll cover some advanced data-modeling techniques and you’ll
          learn even more about Active Record.</p><p>For now, try these exercises.</p></div><div class="sect1" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="exercises-id00017"/>Exercises</h1></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a id="ch07qa1"/><table border="0" summary="Q and A Set" width="100%"><col align="left" width="1%"/><col/><tbody><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe1"/><a id="ch07qa1q1"/><p>Q:</p></td><td align="left" valign="top"><p>1. The Rails framework makes extensive use of modules both as namespaces and to
                add behavior to classes. Open a Rails console inside your <span class="emphasis"><em>blog</em></span>
                directory and look at the ancestors of <code class="literal">Post</code>. How many ancestors
                does it have? Based on their names, can you tell what some of them do?</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe2"/><a id="ch07qa1q2"/><p>Q:</p></td><td align="left" valign="top"><p>2. Update the <code class="literal">define_method</code> sample by adding a
                  <code class="literal">cannot_</code>
                <span class="emphasis"><em><code class="literal">feature</code></em></span><code class="literal">!</code> method. This
                method should set the value corresponding to the correct key in the
                  <code class="literal">@features</code> hash to <code class="literal">false</code>.</p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a id="ch07qa1qe3"/><a id="ch07qa1q3"/><p>Q:</p></td><td align="left" valign="top"><p>3. Verify that <code class="literal">class_eval</code> created the instance methods you
                expected inside the <code class="literal">Element</code> class by calling
                  <code class="literal">Element.instance_methods(false)</code>. Then reopen the
                  <code class="literal">Element</code> class and call <code class="literal">accessor :symbol</code> to
                add two more methods for an instance variable named
                <code class="literal">@symbol</code>.</p></td></tr></tbody></table></div></div></div></body></html>