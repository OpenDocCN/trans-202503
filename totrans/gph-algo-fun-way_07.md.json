["```\ndef breadth_first_search(g: Graph, start: int) -> list: \n    seen: list = [False] * g.num_nodes\n    last: list = [-1] * g.num_nodes\n    pending: queue.Queue = queue.Queue() ❶ pending.put(start)\n    seen[start] = True\n\n    while not pending.empty():\n        index: int = pending.get()\n        current: Node = g.nodes[index]\n\n        for edge in current.get_edge_list():\n            neighbor: int = edge.to_node\n          ❷ if not seen[neighbor]:\n                pending.put(neighbor)\n                seen[neighbor] = True\n                last[neighbor] = index\n\n    return last \n```", "```\ndef make_grid_graph(width: int, height: int) -> Graph: \n    num_nodes: int = width * height\n\n    g: Graph = Graph(num_nodes, undirected=True)\n    for r in range(height):\n        for c in range(width):\n          ❶ index: int = r * width + c\n\n          ❷ if (c < width - 1):\n                g.insert_edge(index, index + 1, 1.0)\n          ❸ if (r < height - 1):\n                g.insert_edge(index, index + width, 1.0)\n    return g \n```", "```\ndef make_grid_with_obstacles(width: int, height: int,\n                             obstacles: set) -> Graph: \n    num_nodes: int = width * height\n\n    g: Graph = Graph(num_nodes, undirected=True)\n    for r in range(height):\n        for c in range(width):\n          ❶ if (r, c) not in obstacles:\n                index: int = r * width + c\n              ❷ if (c < width - 1) and (r, c + 1) not in obstacles:\n                    g.insert_edge(index, index + 1, 1.0)\n              ❸ if (r < height - 1) and (r + 1, c) not in obstacles:\n                    g.insert_edge(index, index + width, 1.0)\n    return g \n```"]