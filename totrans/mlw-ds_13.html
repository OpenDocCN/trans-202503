<html><head></head><body>
<h2 class="h2" id="appendix"><span epub:type="pagebreak" id="page_221"/>AN OVERVIEW OF DATASETS AND TOOLS</h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent">All data and code for this book are available for download at <em><a href="http://www.malwaredatascience.com/">http://www.malwaredatascience.com/</a></em>. Be warned: there is Windows malware in the data. If you unzip the data on a machine with an antivirus engine running on it, many of the malware examples will likely get deleted or quarantined.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>We have modified a few bytes in each malware executable so as to disable it from executing. That being said, you can’t be too careful about where you store it. We recommend storing it on a non-Windows machine that’s isolated from your home or business network.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_222"/>Ideally, you should only experiment with the code and data within an isolated virtual machine. For convenience, we’ve provided a VirtualBox Ubuntu instance at <em><a href="http://www.malwaredatascience.com/">http://www.malwaredatascience.com/</a></em> that has the data and code preloaded onto it, along with all the necessary open source libraries.</p>
<h3 class="h3" id="lev204"><strong>Overview of Datasets</strong></h3>
<p class="noindent">Now let’s walk through the datasets that accompany each chapter of this book.</p>
<h4 class="h4" id="lev205"><strong><em>Chapter 1: Basic Static Malware Analysis</em></strong></h4>
<p class="noindent">Recall that in <a href="ch01.xhtml#ch01">Chapter 1</a> we walk through basic static analysis of a malware binary called <em>ircbot.exe</em>. This malware is an <em>implant</em>, meaning it hides on users’ systems and waits for commands from an attacker, allowing the attacker to collect private data from a victim’s computer or achieve malicious ends like erasing the victim’s hard drive. This binary is available in the data accompanying this book at <em>ch1/ircbot.exe</em>.</p>
<p class="indent">We also use an example of <em>fakepdfmalware.exe</em> in this chapter (located at <em>ch1/fakepdfmalware.exe</em>). This is a malware program that has an Adobe Acrobat/PDF desktop icon to trick users into thinking they’re opening a PDF document when they’re actually running the malicious program and infecting their systems.</p>
<h4 class="h4" id="lev206"><strong><em>Chapter 2: Beyond Basic Static Analysis: x86 Disassembly</em></strong></h4>
<p class="noindent">In this chapter we explore a deeper topic in malware reverse engineering: analyzing x86 disassembly. We reuse the <em>ircbot.exe</em> example from <a href="ch01.xhtml#ch01">Chapter 1</a> in this chapter.</p>
<h4 class="h4" id="lev207"><strong><em>Chapter 3: A Brief Introduction to Dynamic Analysis</em></strong></h4>
<p class="noindent">For our discussion of dynamic malware analysis in <a href="ch03.xhtml#ch03">Chapter 3</a>, we experiment with a ransomware example stored in the path <em>ch3/d676d9dfab6a4242258362b8ff579cfe6e5e6db3f0cdd3e0069ace50f80af1c5</em> in the data accompanying this book. The filename corresponds to the file’s SHA256 cryptographic hash. There’s nothing particularly special about this ransomware, which we got by searching <em><a href="http://VirusTotal.com">VirusTotal.com</a></em>’s malware database for examples of ransomware.</p>
<h4 class="h4" id="lev208"><strong><em>Chapter 4: Identifying Attack Campaigns Using Malware Networks</em></strong></h4>
<p class="noindent"><a href="ch04.xhtml#ch04">Chapter 4</a> introduces the application of network analysis and visualization to malware. To demonstrate these techniques, we use a set of high-quality malware samples used in high-profile attacks, focusing our analysis on a set of malware samples likely produced by a group within the Chinese military known to the security community as <em>Advanced Persistent Threat 1</em> (or <em>APT1</em> for short).</p>
<p class="indent"><span epub:type="pagebreak" id="page_223"/>These samples and the APT1 group that generated them were discovered and made public by cybersecurity firm Mandiant. In its report (excerpted here) titled “APT1: Exposing One of China’s Cyber Espionage Units” (<em><a href="https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf">https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf</a></em>), Mandiant found the following:</p>
<ul>
<li class="noindent">Since 2006, Mandiant has observed APT1 compromise 141 companies spanning 20 major industries.</li>
<li class="noindent">APT1 has a well-defined attack methodology, honed over years and designed to steal large volumes of valuable intellectual property.</li>
<li class="noindent">Once APT1 has established access, they periodically revisit the victim’s network over several months or years and steal broad categories of intellectual property, including technology blueprints, proprietary manufacturing processes, test results, business plans, pricing documents, partnership agreements, and emails and contact lists from victim organizations’ leadership.</li>
<li class="noindent">APT1 uses some tools and techniques that we have not yet observed being used by other groups including two utilities designed to steal email: GETMAIL and MAPIGET.</li>
<li class="noindent">APT1 maintained access to victim networks for an average of 356 days.</li>
<li class="noindent">The longest time period APT1 maintained access to a victim’s network was 1,764 days, or four years and ten months.</li>
<li class="noindent">Among other large-scale thefts of intellectual property, we have observed APT1 stealing 6.5TB of compressed data from a single organization over a ten-month time period.</li>
<li class="noindent">In the first month of 2011, APT1 successfully compromised at least 17 new victims operating in 10 different industries.</li>
</ul>
<p class="indent">As this excerpt of the report shows, the APT1 samples were used for high-stakes, nation state–level espionage. These samples are available in the data accompanying this book at <em>ch4/data/APT1_MALWARE_FAMILIES</em>.</p>
<h4 class="h4" id="lev209"><strong><em>Chapter 5: Shared Code Analysis</em></strong></h4>
<p class="noindent"><a href="ch05.xhtml#ch05">Chapter 5</a> reuses the APT1 samples used in <a href="ch04.xhtml#ch04">Chapter 4</a>. For convenience, these samples are also located in the <a href="ch05.xhtml#ch05">Chapter 5</a> directory, at <em>ch5/data/APT1_MALWARE_FAMILIES</em>.</p>
<h4 class="h4" id="lev210"><strong><em>Chapter 6: Understanding Machine Learning–Based Malware Detectors and Chapter 7: Evaluating Malware Detection Systems</em></strong></h4>
<p class="noindent">These conceptual chapters don’t require any sample data.</p>
<h4 class="h4" id="lev211"><span epub:type="pagebreak" id="page_224"/><strong><em>Chapter 8: Building Machine Learning Detectors</em></strong></h4>
<p class="noindent"><a href="ch08.xhtml#ch08">Chapter 8</a> explores building machine learning–based malware detectors and uses 1,419 sample binaries as a sample dataset for training your own machine learning detection system. These binaries are located at <em>ch8/data/benignware</em> for the benign samples and <em>ch8/data/malware</em> for the malware samples.</p>
<p class="indent">The dataset contains 991 benignware samples and 428 malware samples, and we got this data from <em><a href="http://VirusTotal.com">VirusTotal.com</a></em>. These samples are representative, in the malware case, of the kind of malware observed on the internet in 2017 and, in the benignware case, of the kind of binaries users uploaded to <em><a href="http://VirusTotal.com">VirusTotal.com</a></em> in 2017.</p>
<h4 class="h4" id="lev212"><strong><em>Chapter 9: Visualizing Malware Trends</em></strong></h4>
<p class="noindent"><a href="ch09.xhtml#ch09">Chapter 9</a> explores data visualization and uses the sample data in the file <em>ch9/code/malware_data.csv</em>. Of the 37,511 data rows in the file, each row shows a record of an individual malware file, when it was first seen, how many antivirus products detected it, and what kind of malware it is (for example, Trojan horse, ransomware, and so on). This data was collected from <em><a href="http://VirusTotal.com">VirusTotal.com</a></em>.</p>
<h4 class="h4" id="lev213"><strong><em>Chapter 10: Deep Learning Basics</em></strong></h4>
<p class="noindent">This chapter introduces deep neural networks and doesn’t use any sample data.</p>
<h4 class="h4" id="lev214"><strong><em>Chapter 11: Building a Neural Network Malware Detector with Keras</em></strong></h4>
<p class="noindent">This chapter walks through building a neural network malware detector for detecting malicious and benign HTML files. Benign HTML files are from legitimate web pages, and the malicious web pages are from websites that attempt to infect victims via their web browsers. We got both of these datasets from <em><a href="http://VirusTotal.com">VirusTotal.com</a></em> using a paid subscription that allows access to millions of sample malicious and benign HTML pages.</p>
<p class="indent">All the data is stored at the root directory <em>ch11/data/html</em>. The benignware is stored at <em>ch11/data/html/benign_files</em>, and the malware is stored at <em>ch11/data/html/malicious_files</em>. Additionally, within each of these directories are the subdirectories <em>training</em> and <em>validation</em>. The <em>training</em> directories contain the files we train the neural network on in the chapter, and the <em>validation</em> directories contain the files we test the neural network on to assess its accuracy.</p>
<h4 class="h4" id="lev215"><strong><em>Chapter 12: Becoming a Data Scientist</em></strong></h4>
<p class="noindent"><a href="ch12.xhtml#ch12">Chapter 12</a> discusses how to become a data scientist and doesn’t use any sample data.</p>
<h3 class="h3" id="lev216"><span epub:type="pagebreak" id="page_225"/><strong>Tool Implementation Guide</strong></h3>
<p class="noindent">Although all the code in this book is <em>sample code</em>, intended to demonstrate the ideas in the book and not be taken whole cloth and used in the real world, some of the code we provide can be used as a tool in your own malware analysis work, particularly if you’re willing to extend it for your own purposes.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Intended as examples and starting places for full-fledged malware data science tools, these tools are not robustly implemented. They have been tested on Ubuntu 17 and are expected to work on this platform, but with a bit of work around installing the right requirements, you should be able to get the tools to work on other platforms like macOS and other flavors of Linux fairly easily.</em></p>
</div>
<p class="indent">In this section, we walk through the nascent tools provided in this book in the order in which they appear.</p>
<h4 class="h4" id="lev217"><strong><em>Shared Hostname Network Visualization</em></strong></h4>
<p class="noindent">A shared hostname network visualization tool is given in <a href="ch04.xhtml#ch04">Chapter 4</a> and is located at <em>ch4/code/listing-4-8.py</em>. This tool extracts hostnames from target malware files and then shows connections between the files based on common hostnames contained in them.</p>
<p class="indent">The tool takes a directory of malware as its input and then outputs three GraphViz files that you can then visualize. To install the requirements for this tool, run the command <span class="literal">run bash install_requirements.sh</span> in the <em>ch4/code</em> directory. <a href="appendix.xhtml#applist1">Listing A-1</a> shows the “help” output from the tool, after which we discuss what the parameters mean.</p>
<p class="programs">usage: Visualize shared hostnames between a directory of malware samples<br/>       [-h] target_path output_file malware_projection hostname_projection<br/><br/>positional arguments:<br/><span class="ent">➊</span> target_path          directory with malware samples<br/><span class="ent">➋</span> output_file          file to write DOT file to<br/><span class="ent">➌</span> malware_projection   file to write DOT file to<br/><span class="ent">➍</span> hostname_projection  file to write DOT file to<br/><br/>optional arguments:<br/>  -h, --help           show this help message and exit</p>
<p class="listing" id="applist1"><em>Listing A-1: Help output from the shared hostname network visualization tool given in <a href="ch04.xhtml#ch04">Chapter 4</a></em></p>
<p class="indent">As shown in <a href="appendix.xhtml#applist1">Listing A-1</a>, the shared hostname visualization tool requires four command line arguments: <span class="literal">target_path</span> <span class="ent">➊</span>, <span class="literal">output_file</span> <span class="ent">➋</span>, <span class="literal">malware_projection</span> <span class="ent">➌</span>, and <span class="literal">hostname_projection</span> <span class="ent">➍</span>. The parameter <span class="literal">target_path</span> is the path to the directory of malware samples you’d like to analyze. The <span class="literal">output_file</span> parameter is a path to the file where the program will write a GraphViz <em>.dot</em> file representing the network that links malware samples to the hostnames they contain.</p>
<p class="indent"><span epub:type="pagebreak" id="page_226"/>The <span class="literal">malware_projection</span> and <span class="literal">hostname_projection</span> parameters are also file paths and specify the locations where the program will write <em>.dot</em> files that represent these derived networks (for more on network projections, see <a href="ch04.xhtml#ch04">Chapter 4</a>). Once you’ve run the program, you can use the GraphViz suite discussed in <a href="ch04.xhtml#ch04">Chapters 4</a> and <a href="ch05.xhtml#ch05">5</a> to visualize the networks. For example, you could use the command <span class="literal">fdp malware_projection.dot -Tpng -o malware_</span><span class="literal">projection</span><span class="literal">.png</span> to generate a file like the <em>.png</em> file rendered in <a href="appendix.xhtml#appfig1">Figure A-1</a> on your own malware datasets.</p>
<div class="image"><a id="appfig1"/><img alt="image" src="../images/f0226-01.jpg"/></div>
<p class="figcap"><em>Figure A-1: Sample output from the shared hostname visualization tool given in <a href="ch04.xhtml#ch04">Chapter 4</a></em></p>
<h4 class="h4" id="lev218"><strong><em>Shared Image Network Visualization</em></strong></h4>
<p class="noindent">We present a shared image network visualization tool in <a href="ch04.xhtml#ch04">Chapter 4</a>, which is located at <em>ch4/code/listing-4-12.py</em>. This program shows network relationships between malware samples based on embedded images they share.</p>
<p class="indent">The tool takes a directory of malware as its input and then outputs three GraphViz files that you can then visualize. To install the requirements for this tool, run the command <span class="literal">run bash install_requirements.sh</span> in the <em>ch4/code</em> directory. Let’s discuss the parameters in the “help” output from the tool (see <a href="appendix.xhtml#applist2">Listing A-2</a>).</p>
<p class="programs"><span epub:type="pagebreak" id="page_227"/>usage: Visualize shared image relationships between a directory of malware samples<br/>       [-h] target_path output_file malware_projection resource_projection<br/><br/>positional arguments:<br/><span class="ent">➊</span> target_path          directory with malware samples<br/><span class="ent">➋</span> output_file          file to write DOT file to<br/><span class="ent">➌</span> malware_projection   file to write DOT file to<br/><span class="ent">➍</span> resource_projection  file to write DOT file to<br/><br/>optional arguments:<br/>  -h, --help           show this help message and exit</p>
<p class="listing" id="applist2"><em>Listing A-2: Help output from the shared resource network visualization tool given in <a href="ch04.xhtml#ch04">Chapter 4</a></em></p>
<p class="indent">As shown in <a href="appendix.xhtml#applist2">Listing A-2</a>, the shared image relationships visualization tool requires four command line arguments: <span class="literal">target_path</span> <span class="ent">➊</span>, <span class="literal">output_file</span> <span class="ent">➋</span>, <span class="literal">malware_projection</span> <span class="ent">➌</span>, and <span class="literal">resource_projection</span> <span class="ent">➍</span>. Much like in the shared hostname program, here <span class="literal">target_path</span> is the path to the directory of malware samples you’d like to analyze, and <span class="literal">output_file</span> is a path to the file where the program will write a GraphViz <em>.dot</em> file representing the bipartite graph that links malware samples to the images they contain (bipartite graphs are discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>). The <span class="literal">malware_projection</span> and <span class="literal">resource_projection</span> parameters are also file paths and specify the locations where the program will write <em>.dot</em> files that represent these networks.</p>
<p class="indent">As with the shared hostname program, once you’ve run the program, you can use the GraphViz suite to visualize the networks. For example, you could use the command <span class="literal">fdp resource_projection.dot -Tpng -o resource_</span><span class="literal">projection</span><span class="literal">.png</span> on your own malware datasets to generate a file like the <em>.png</em> file rendered in <a href="ch04.xhtml#ch04fig12">Figure 4-12</a> on <a href="ch04.xhtml#page_55">page 55</a>.</p>
<h4 class="h4" id="lev219"><strong><em>Malware Similarity Visualization</em></strong></h4>
<p class="noindent">In <a href="ch05.xhtml#ch05">Chapter 5</a>, we discuss malware similarity and shared code analysis and visualization. The first sample tool we provide is given in <em>ch5/code/listing_5_1.py</em>. This tool takes a directory containing malware as its input and then visualizes shared code relationships between the malware samples in the directory. To install the requirements for this tool, run the command <span class="literal">run bash install_requirements.sh</span> in the <em>ch5/code</em> directory. <a href="appendix.xhtml#applist3">Listing A-3</a> shows the help output for the tool.</p>
<p class="programs">usage: listing_5_1.py [-h] [--jaccard_index_threshold THRESHOLD]<br/>                      target_directory output_dot_file<br/><br/>Identify similarities between malware samples and build similarity graph<br/><br/>positional arguments:<br/><span class="ent">➊</span> target_directory      Directory containing malware<br/><span class="ent">➋</span> output_dot_file       Where to save the output graph DOT file<br/><br/><span epub:type="pagebreak" id="page_228"/>optional arguments:<br/>  -h, --help            show this help message and exit<br/><span class="ent">➌</span> --jaccard_index_threshold THRESHOLD, -j THRESHOLD<br/>                        Threshold above which to create an 'edge' between<br/>                        samples</p>
<p class="listing" id="applist3"><em>Listing A-3: Help output from the malware similarity visualization tool given in <a href="ch05.xhtml#ch05">Chapter 5</a></em></p>
<p class="indent">When you run this shared code analysis tool from the command line, you need to pass in two command line arguments: <span class="literal">target_directory</span> <span class="ent">➊</span> and <span class="literal">output_dot_file</span> <span class="ent">➋</span>. You can use the optional argument, <span class="literal">jaccard_index_threshold</span> <span class="ent">➌</span>, to set the threshold the program uses with the Jaccard index similarity between two samples to determine whether or not to create an edge between those samples. The Jaccard index is discussed in detail in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>
<p class="indent"><a href="appendix.xhtml#appfig2">Figure A-2</a> shows sample output from this tool once you’ve rendered the <span class="literal">output_dot_file</span> with the command <span class="literal">fdp output_dot_file.dot -Tpng -o similarity_network.png</span>. This is the shared code network inferred by the tool for the APT1 malware samples we just described.</p>
<div class="image"><a id="appfig2"/><img alt="image" src="../images/f0228-01.jpg"/></div>
<p class="figcap"><em>Figure A-2: Sample output from the malware similarity analysis tool given in <a href="ch05.xhtml#ch05">Chapter 5</a></em></p>
<h4 class="h4" id="lev220"><span epub:type="pagebreak" id="page_229"/><strong><em>Malware Similarity Search System</em></strong></h4>
<p class="noindent">The second code-sharing estimation tool we provide in <a href="ch05.xhtml#ch05">Chapter 5</a> is given in <em>ch5/code/listing_5_2.py</em>. This tool allows you to index thousands of samples in a database and then perform a similarity search on them with a query malware sample, which lets you find malware samples that likely share code with that sample. To install the requirements for this tool, run the command <span class="literal">run bash install_requirements.sh</span> in the <em>ch5/code</em> directory. <a href="appendix.xhtml#applist4">Listing A-4</a> shows the help output for the tool.</p>
<p class="programs">usage: listing_5_2.py [-h] [-l LOAD] [-s SEARCH] [-c COMMENT] [-w]<br/><br/>Simple code-sharing search system which allows you to build up a database of<br/>malware samples (indexed by file paths) and then search for similar samples<br/>given some new sample<br/><br/>optional arguments:<br/>  -h, --help            show this help message and exit<br/><span class="ent">➊</span> -l LOAD, --load LOAD Path to directory containing malware, or individual<br/>                        malware file, to store in database<br/><span class="ent">➋</span> -s SEARCH, --search SEARCH<br/>                        Individual malware file to perform similarity search<br/>                        on<br/><span class="ent">➌</span> -c COMMENT, --comment COMMENT<br/>                        Comment on a malware sample path<br/><span class="ent">➍</span> -w, --wipe           Wipe sample database</p>
<p class="listing" id="applist4"><em>Listing A-4: Help output from the malware similarity search system given in <a href="ch05.xhtml#ch05">Chapter 5</a></em></p>
<p class="indent">This tool has four modes in which it can be run. The first mode, <span class="literal">LOAD</span> <span class="ent">➊</span>, loads malware into the similarity search database and takes a path as its parameter, which should point to a directory with malware in it. You can run <span class="literal">LOAD</span> multiple times and add new malware to the database each time.</p>
<p class="indent">The second mode, <span class="literal">SEARCH</span> <span class="ent">➋</span>, takes the path to an individual malware file as its parameter and then searches for similar samples in the database. The third mode, <span class="literal">COMMENT</span> <span class="ent">➌</span>, takes a malware sample path as its argument and then prompts you to enter a short textual comment about that sample. The advantage of using the <span class="literal">COMMENT</span> feature is that when you search for samples similar to a query malware sample, you see the comments corresponding to the similar sample, thus enriching your knowledge of the query sample.</p>
<p class="indent">The fourth mode, <span class="literal">wipe</span> <span class="ent">➍</span>, deletes all the data in the similarity search database, in case you want to start over and index a different malware dataset. <a href="appendix.xhtml#applist5">Listing A-5</a> shows some sample output from a <span class="literal">SEARCH</span> query, giving you a flavor for what the output from this tool looks like. Here we’ve indexed the APT1 samples described previously using the <span class="literal">LOAD</span> command and have subsequently searched the database for samples similar to one of the APT1 samples.</p>
<p class="programs"><span epub:type="pagebreak" id="page_230"/>Showing samples similar to WEBC2-GREENCAT_sample_E54CE5F0112C9FDFE86DB17E85A5E2C5<br/>Sample name                                                      Shared code<br/>[*] WEBC2-GREENCAT_sample_55FB1409170C91740359D1D96364F17B       0.9921875<br/>[*] GREENCAT_sample_55FB1409170C91740359D1D96364F17B             0.9921875<br/>[*] WEBC2-GREENCAT_sample_E83F60FB0E0396EA309FAF0AED64E53F       0.984375<br/>    [comment] This sample was determined to definitely have come from the advanced persistent<br/>              threat group observed last July on our West Coast network<br/>[*] GREENCAT_sample_E83F60FB0E0396EA309FAF0AED64E53F             0.984375</p>
<p class="listing" id="applist5"><em>Listing A-5: Sample output for the malware similarity search system given in <a href="ch05.xhtml#ch05">Chapter 5</a></em></p>
<h4 class="h4" id="lev221"><strong><em>Machine Learning Malware Detection System</em></strong></h4>
<p class="noindent">The final tool you can use in your own malware analysis work is the machine learning malware detector used in <a href="ch08.xhtml#ch08">Chapter 8</a>, which can be found at <em>ch8/code/complete_detector.py</em>. This tool allows you to train a malware detection system on malware and benignware and then use this system to detect whether a new sample is malicious or benign. You can install the requirements for this tool by running the command <span class="literal">bash install.sh</span> in the <em>ch8/code</em> directory. <a href="appendix.xhtml#applist6">Listing A-6</a> shows the help output for this tool.</p>
<p class="programs">usage: Machine learning malware detection system [-h]<br/>                                         [--malware_paths MALWARE_PATHS]<br/>                                         [--benignware_paths BENIGNWARE_PATHS]<br/>                                         [--scan_file_path SCAN_FILE_PATH]<br/>                                         [--evaluate]<br/><br/>optional arguments:<br/>  -h, --help            show this help message and exit<br/><span class="ent">➊</span> --malware_paths MALWARE_PATHS<br/>                        Path to malware training files<br/><span class="ent">➋</span> --benignware_paths BENIGNWARE_PATHS<br/>                        Path to benignware training files<br/><span class="ent">➌</span> --scan_file_path SCAN_FILE_PATH<br/>                        File to scan<br/><span class="ent">➍</span> --evaluate           Perform cross-validation</p>
<p class="listing" id="applist6"><em>Listing A-6: Help output for the machine learning malware detection tool given in <a href="ch08.xhtml#ch08">Chapter 8</a></em></p>
<p class="indent">This tool has three modes in which it can be run. The <span class="literal">evaluate</span> mode <span class="ent">➍</span>, tests the accuracy of the system on the data you select for training and evaluating the system. You can invoke this mode by running <span class="literal">python complete_</span><span class="literal">detector.py –malware_paths &lt;path to directory with malware in it&gt; --</span><span class="literal">benignware</span><span class="literal">_paths &lt;path to directory with benignware in it&gt; --evaluate</span>. This command will invoke a <span class="literal">matplotlib</span> window showing your detector’s ROC curve (ROC curves are discussed in <a href="ch07.xhtml#ch07">Chapter 7</a>). <a href="appendix.xhtml#appfig3">Figure A-3</a> shows some sample output from <span class="literal">evaluate</span> mode.</p>
<div class="image"><span epub:type="pagebreak" id="page_231"/><a id="appfig3"/><img alt="image" src="../images/f0231-01.jpg"/></div>
<p class="figcap"><em>Figure A-3: Sample output from the malware detection tool provided in <a href="ch08.xhtml#ch08">Chapter 8</a>, run in</em> <span class="codeitalic">evaluate</span> <em>mode</em></p>
<p class="indent">Training mode trains a malware detection model and saves it to disk. You can invoke this mode by running <span class="literal">python complete_detector.py –malware_paths</span> <span class="ent">➊</span> <span class="literal">&lt;path to directory with malware in it&gt; --benignware_paths</span> <span class="ent">➋</span> <span class="literal">&lt;path to directory with benignware in it&gt;</span>. Note that the only difference between this command invocation and the invocation of <span class="literal">evaluate</span> mode is that we’ve left off the <span class="literal">--evaluate</span> flag. The result of this command is that it generates a model that it saves to a file called <em>saved_detector.pkl</em>, which is saved in your current working directory.</p>
<p class="indent">The third mode, <span class="literal">scan</span> <span class="ent">➌</span>, loads <em>saved_detector.pkl</em> and then scans a target file, predicting whether it’s malicious or not. Make sure you have run training mode before running a scan. You can run a scan by running <span class="literal">python complete_detector.py –scan_file_path &lt;PE EXE file&gt;</span> in the directory where you trained the system. The output will be a probability that the target file is malicious.<span epub:type="pagebreak" id="page_232"/></p>
</body></html>