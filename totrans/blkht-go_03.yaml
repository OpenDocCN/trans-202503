- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: HTTP CLIENTS AND REMOTE INTERACTION WITH TOOLS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端与工具的远程交互
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: In [Chapter 2](ch02.xhtml#ch2), you learned how to harness the power of TCP
    with various techniques for creating usable clients and servers. This is the first
    in a series of chapters that explores a variety of protocols on higher layers
    of the OSI model. Because of its prevalence on networks, its affiliation with
    relaxed egress controls, and its general flexibility, let’s begin with HTTP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.xhtml#ch2)中，你学会了如何利用 TCP 的强大功能，使用各种技术来创建可用的客户端和服务器。这是一个系列章节的第一章，探讨了
    OSI 模型更高层次的各种协议。由于其在网络上的普及、与放宽出口控制的关联以及其通用的灵活性，我们从 HTTP 开始。
- en: This chapter focuses on the client side. It will first introduce you to the
    basics of building and customizing HTTP requests and receiving their responses.
    Then you’ll learn how to parse structured response data so the client can interrogate
    the information to determine actionable or relevant data. Finally, you’ll learn
    how to apply these fundamentals by building HTTP clients that interact with a
    variety of security tools and resources. The clients you develop will query and
    consume the APIs of Shodan, Bing, and Metasploit and will search and parse document
    metadata in a manner similar to the metadata search tool FOCA.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍客户端部分。它将首先向你介绍构建和自定义 HTTP 请求以及接收响应的基础知识。然后，你将学习如何解析结构化的响应数据，以便客户端可以查询信息，确定可操作或相关的数据。最后，你将学习如何通过构建与各种安全工具和资源互动的
    HTTP 客户端来应用这些基础知识。你开发的客户端将查询和使用 Shodan、Bing 和 Metasploit 的 API，并以类似 FOCA 元数据搜索工具的方式搜索和解析文档元数据。
- en: HTTP Fundamentals with Go
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 学习 HTTP 基础
- en: Although you don’t need a comprehensive understanding of HTTP, you should know
    some fundamentals before you get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不需要对 HTTP 有全面的了解，但在开始之前，你应该知道一些基本的概念。
- en: 'First, HTTP is a *stateless protocol*: the server doesn’t inherently maintain
    state and status for each request. Instead, state is tracked through a variety
    of means, which may include session identifiers, cookies, HTTP headers, and more.
    The client and servers have a responsibility to properly negotiate and validate
    this state.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，HTTP 是一个*无状态协议*：服务器不会固有地为每个请求维护状态和状态信息。相反，状态是通过各种手段跟踪的，包括会话标识符、cookies、HTTP
    头部等。客户端和服务器有责任正确地协商和验证这一状态。
- en: Second, communications between clients and servers can occur either synchronously
    or asynchronously, but they operate on a request/response cycle. You can include
    several options and headers in the request in order to influence the behavior
    of the server and to create usable web applications. Most commonly, servers host
    files that a web browser renders to produce a graphical, organized, and stylish
    representation of the data. But the endpoint can serve arbitrary data types. APIs
    commonly communicate via more structured data encoding, such as XML, JSON, or
    MSGRPC. In some cases, the data retrieved may be in binary format, representing
    an arbitrary file type for download.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，客户端和服务器之间的通信可以是同步的，也可以是异步的，但它们都基于请求/响应周期。你可以在请求中包含多个选项和头部信息，以影响服务器的行为并创建可用的
    Web 应用程序。最常见的是，服务器托管文件，Web 浏览器渲染这些文件，从而呈现出数据的图形化、有组织的和富有设计感的表现。但端点也可以提供任意数据类型的服务。API
    通常通过更结构化的数据编码进行通信，如 XML、JSON 或 MSGRPC。在某些情况下，检索到的数据可能是二进制格式，表示供下载的任意文件类型。
- en: Finally, Go contains convenience functions so you can quickly and easily build
    and send HTTP requests to a server and subsequently retrieve and process the response.
    Through some of the mechanisms you’ve learned in previous chapters, you’ll find
    that the conventions for handling structured data prove extremely convenient when
    interacting with HTTP APIs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Go 提供了便捷的函数，可以让你快速轻松地构建并发送 HTTP 请求到服务器，并随后检索和处理响应。通过你在前面章节中学到的一些机制，你会发现，处理结构化数据的惯例在与
    HTTP API 互动时非常方便。
- en: Calling HTTP APIs
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用 HTTP API
- en: 'Let’s begin the HTTP discussion by examining basic requests. Go’s `net/http`
    standard package contains several convenience functions to quickly and easily
    send POST, GET, and HEAD requests, which are arguably the most common HTTP verbs
    you’ll use. These functions take the following forms:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查基本请求来开始 HTTP 的讨论。Go 的 `net/http` 标准包包含几个便捷函数，可以快速轻松地发送 POST、GET 和 HEAD
    请求，这些请求无疑是你将使用的最常见的 HTTP 动词。这些函数的形式如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each function takes—as a parameter—the URL as a string value and uses it for
    the request’s destination. The `Post()` function is slightly more complex than
    the `Get()` and `Head()` functions. `Post()` takes two additional parameters:
    `bodyType`, which is a string value that you use for the Content-Type HTTP header
    (commonly `application/x-www-form-urlencoded`) of the request body, and an `io.Reader`,
    which you learned about in [Chapter 2](ch02.xhtml#ch2).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都将 URL 作为字符串值作为参数，并将其用作请求的目标。`Post()` 函数比 `Get()` 和 `Head()` 函数稍微复杂一些。`Post()`
    需要两个额外的参数：`bodyType`，它是一个字符串值，用于请求体的 Content-Type HTTP 头（通常为 `application/x-www-form-urlencoded`），以及
    `io.Reader`，你可以在 [第 2 章](ch02.xhtml#ch2)中了解它。
- en: You can see a sample implementation of each of these functions in [Listing 3-1](ch03.xhtml#ch3list1).
    (All the code listings at the root location of / exist under the provided github
    repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
    Note that the POST request creates the request body from form values and sets
    the Content-Type header. In each case, you must close the response body after
    you’re done reading data from it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [列表 3-1](ch03.xhtml#ch3list1) 中看到这些函数的示例实现。（所有位于根目录位置的代码列表都存在于提供的 GitHub
    仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    中。）请注意，POST 请求从表单值创建请求体，并设置 Content-Type 头。在每种情况下，在读取数据后，必须关闭响应体。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-1: Sample implementations of the `Get()`, `Head()`, and `Post()`
    functions (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：`Get()`、`Head()` 和 `Post()` 函数的示例实现 (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
- en: The POST function call ❶ follows the fairly common pattern of setting the Content-Type
    to `application/x-www-form-urlencoded` ❷, while URL-encoding form data ❸.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: POST 函数调用 ❶ 遵循了一个相当常见的模式，即将 Content-Type 设置为 `application/x-www-form-urlencoded`
    ❷，同时对表单数据进行 URL 编码 ❸。
- en: 'Go has an additional POST request convenience function, called `PostForm()`,
    which removes the tediousness of setting those values and manually encoding every
    request; you can see its syntax here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还有一个额外的 POST 请求便利函数，名为 `PostForm()`，它消除了手动设置那些值并编码每个请求的繁琐；你可以在此查看其语法：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you want to substitute the `PostForm()` function for the `Post()` implementation
    in [Listing 3-1](ch03.xhtml#ch3list1), you use something like the bold code in
    [Listing 3-2](ch03.xhtml#ch3list2).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用 `PostForm()` 函数替代 [列表 3-1](ch03.xhtml#ch3list1) 中的 `Post()` 实现，可以使用类似
    [列表 3-2](ch03.xhtml#ch3list2) 中的加粗代码。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-2: Using the `PostForm()` function instead of `Post()` (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：使用 `PostForm()` 函数代替 `Post()` (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
- en: Unfortunately, no convenience functions exist for other HTTP verbs, such as
    PATCH, PUT, or DELETE. You’ll use these verbs mostly to interact with RESTful
    APIs, which employ general guidelines on how and why a server should use them;
    but nothing is set in stone, and HTTP is like the Old West when it comes to verbs.
    In fact, we’ve often toyed with the idea of creating a new web framework that
    exclusively uses DELETE for everything. we’d call it *DELETE.js*, and it would
    be a top hit on Hacker News for sure. By reading this, you’re agreeing not to
    steal this idea!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，其他 HTTP 动词（如 PATCH、PUT 或 DELETE）没有方便的函数可用。你主要会使用这些动词与 RESTful API 进行交互，RESTful
    API 使用一些通用的指南来说明服务器应该如何以及为什么使用这些动词；但并没有一成不变的规定，HTTP 就像是西部拓荒时代一样。在实际上，我们常常开玩笑说要创建一个只使用
    DELETE 的全新 Web 框架。我们会称它为 *DELETE.js*，并且它一定会成为 Hacker News 上的热门话题。阅读本文后，你同意不窃取这个主意！
- en: Generating a Request
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成请求
- en: 'To generate a request with one of these verbs, you can use the `NewRequest()`
    function to create the `Request` struct, which you’ll subsequently send using
    the `Client` function’s `Do()` method. We promise that it’s simpler than it sounds.
    The function prototype for `http.NewRequest()` is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些动词之一生成请求，可以使用 `NewRequest()` 函数创建 `Request` 结构体，随后使用 `Client` 函数的 `Do()`
    方法发送请求。我们保证这比听起来要简单。`http.NewRequest()` 函数原型如下：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You need to supply the HTTP verb ❶ and destination URL ❷ to `NewRequest()` as
    the first two string parameters. Much like the first POST example in [Listing
    3-1](ch03.xhtml#ch3list1), you can optionally supply the request body by passing
    in an `io.Reader` as the third and final parameter ❸.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将 HTTP 动词 ❶ 和目标 URL ❷ 提供给 `NewRequest()` 作为前两个字符串参数。就像 [列表 3-1](ch03.xhtml#ch3list1)
    中的第一个 POST 示例一样，你可以选择性地通过传递一个 `io.Reader` 作为第三个也是最后一个参数 ❸ 来提供请求体。
- en: '[Listing 3-3](ch03.xhtml#ch3list3) shows a call without an HTTP body—a DELETE
    request.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-3](ch03.xhtml#ch3list3) 显示了一个没有 HTTP 请求体的调用——一个 DELETE 请求。'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-3: Sending a DELETE request (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-3：发送 DELETE 请求 (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
- en: Now, [Listing 3-4](ch03.xhtml#ch3list4) shows a PUT request with an `io.Reader`
    body (a PATCH request looks similar).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[列表 3-4](ch03.xhtml#ch3list4) 显示了一个带有 `io.Reader` 请求体的 PUT 请求（PATCH 请求也类似）。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-4: Sending a PUT request (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：发送 PUT 请求 (*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)*)*'
- en: The standard Go `net/http` library contains several functions that you can use
    to manipulate the request before it’s sent to the server. You’ll learn some of
    the more relevant and applicable variants as you work through practical examples
    throughout this chapter. But first, we’ll show you how to do something meaningful
    with the HTTP response that the server receives.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 Go 的 `net/http` 库包含几个可以在请求发送到服务器之前用来操作请求的函数。你将在本章的实际示例中学到一些更相关和实用的变种。但首先，我们将向你展示如何处理服务器接收到的
    HTTP 响应。
- en: Using Structured Response Parsing
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用结构化响应解析
- en: In the previous section, you learned the mechanisms for building and sending
    HTTP requests in Go. Each of those examples glossed over response handling, essentially
    ignoring it for the time being. But inspecting various components of the HTTP
    response is a crucial aspect of any HTTP-related task, like reading the response
    body, accessing cookies and headers, or simply inspecting the HTTP status code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了在 Go 中构建和发送 HTTP 请求的机制。那些例子大多忽略了响应处理，基本上暂时忽略了它。但检查 HTTP 响应的各个组件是任何与
    HTTP 相关任务的关键方面，比如读取响应体、访问 cookies 和头部，或者仅仅检查 HTTP 状态码。
- en: '[Listing 3-5](ch03.xhtml#ch3list5) refines the GET request in [Listing 3-1](ch03.xhtml#ch3list1)
    to display the status code and response body—in this case, Google’s *robots.txt*
    file. It uses the `ioutil.ReadAll()` function to read data from the response body,
    does some error checking, and prints the HTTP status code and response body to
    stdout.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-5](ch03.xhtml#ch3list5) 细化了 [列表 3-1](ch03.xhtml#ch3list1) 中的 GET 请求，以显示状态码和响应体——在这个例子中，是
    Google 的 *robots.txt* 文件。它使用 `ioutil.ReadAll()` 函数从响应体中读取数据，进行错误检查，并将 HTTP 状态码和响应体打印到标准输出。'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-5: Processing the HTTP response body ([/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go))*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：处理 HTTP 响应体（*[/ch-3/basic/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic/main.go)）*'
- en: Once you receive your response, named `resp` ❶ in the above code, you can retrieve
    the status string (for example, `200 OK`) by accessing the exported `Status` parameter
    ❷; not shown in our example, there is a similar `StatusCode` parameter that accesses
    only the integer portion of the status string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你接收到响应，在上面的代码中命名为 `resp` ❶，你可以通过访问导出的 `Status` 参数 ❷ 来检索状态字符串（例如，`200 OK`）；我们示例中没有显示，还有一个类似的
    `StatusCode` 参数，仅访问状态字符串中的整数部分。
- en: The `Response` type contains an exported `Body` parameter ❸, which is of type
    `io.ReadCloser`. An `io.ReadCloser` is an interface that acts as an `io.Reader`
    as well as an `io.Closer`, or an interface that requires the implementation of
    a `Close()` function to close the reader and perform any cleanup. The details
    are somewhat inconsequential; just know that after reading the data from an `io.ReadCloser`,
    you’ll need to call the `Close()` function ❹ on the response body. Using `defer`
    to close the response body is a common practice; this will ensure that the body
    is closed before you return it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 类型包含一个导出的 `Body` 参数 ❸，其类型为 `io.ReadCloser`。`io.ReadCloser` 是一个接口，既作为
    `io.Reader`，又作为 `io.Closer`，即一个需要实现 `Close()` 函数来关闭读取器并执行清理操作的接口。细节部分并不重要；只需知道在从
    `io.ReadCloser` 中读取数据后，你需要在响应体上调用 `Close()` 函数 ❹。使用 `defer` 来关闭响应体是一种常见做法；这将确保在你返回之前关闭该体。'
- en: 'Now, run the script to see the error status and response body:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行脚本以查看错误状态和响应体：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you encounter a need to parse more structured data—and it’s likely that
    you will—you can read the response body and decode it by using the conventions
    presented in [Chapter 2](ch02.xhtml#ch2). For example, imagine you’re interacting
    with an API that communicates using JSON, and one endpoint—say, `/ping`—returns
    the following response indicating the server state:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到需要解析更多结构化数据的情况——这很可能会发生——你可以按照 [第 2 章](ch02.xhtml#ch2) 中介绍的约定来读取响应正文并解码它。例如，假设你正在与一个使用
    JSON 通信的 API 进行交互，其中一个端点——比如`/ping`——返回以下响应，表示服务器状态：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can interact with this endpoint and decode the JSON message by using the
    program in [Listing 3-6](ch03.xhtml#ch3list6).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [Listing 3-6](ch03.xhtml#ch3list6) 中的程序与此端点交互并解码 JSON 消息。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-6: Decoding a JSON response body (*[/ch-3/basic-parsing/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic-parsing/main.go)*)*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-6: 解码 JSON 响应正文 (*[/ch-3/basic-parsing/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/basic-parsing/main.go)*)*'
- en: The code begins by defining a struct called `Status` ❶, which contains the expected
    elements from the server response. The `main()` function first sends the POST
    request ❷ and then decodes the response body ❸. After doing so, you can query
    the `Status` struct as you normally would—by accessing exported data types `Status`
    ❹ and `Message` ❺.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了一个名为`Status`的结构体❶，它包含了服务器响应中预期的元素。`main()`函数首先发送 POST 请求❷，然后解码响应正文❸。完成后，你可以像平常一样查询`Status`结构体——通过访问导出的数据类型`Status`❹和`Message`❺。
- en: This process of parsing structured data types is consistent across other encoding
    formats, like XML or even binary representations. You begin the process by defining
    a struct to represent the expected response data and then decoding the data into
    that struct. The details and actual implementation of parsing other formats will
    be left up to you to determine.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解析结构化数据类型的过程在其他编码格式中也是一致的，例如 XML 或甚至二进制表示。你可以通过定义一个结构体来表示预期的响应数据，然后将数据解码为该结构体。其他格式解析的具体细节和实现将由你来决定。
- en: The next sections will apply these fundamental concepts to assist you in building
    tools to interact with third-party APIs for the purpose of enhancing adversarial
    techniques and reconnaissance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将应用这些基本概念，帮助你构建工具以与第三方 API 交互，从而增强对抗性技术和侦察工作。
- en: Building an HTTP Client That Interacts with Shodan
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个与 Shodan 交互的 HTTP 客户端
- en: Prior to performing any authorized adversarial activities against an organization,
    any good attacker begins with reconnaissance. Typically, this starts with passive
    techniques that don’t send packets to the target; that way, detection of the activity
    is next to impossible. Attackers use a variety of sources and services—including
    social networks, public records, and search engines—to gain potentially useful
    information about the target.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在对一个组织进行任何授权的对抗性活动之前，任何优秀的攻击者都会从侦察开始。通常，这从不会向目标发送数据包的被动技术开始；这样，活动几乎不可能被发现。攻击者会利用各种来源和服务——包括社交网络、公共记录和搜索引擎——来获取关于目标的潜在有用信息。
- en: It’s absolutely incredible how seemingly benign information becomes critical
    when environmental context is applied during a chained attack scenario. For example,
    a web application that discloses verbose error messages may, alone, be considered
    low severity. However, if the error messages disclose the enterprise username
    format, and if the organization uses single-factor authentication for its VPN,
    those error messages could increase the likelihood of an internal network compromise
    through password-guessing attacks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当环境上下文在链式攻击场景中应用时，看似无害的信息变得至关重要，这真是令人难以置信。例如，一个披露冗长错误信息的 Web 应用程序，单独来看可能被认为是低严重性。然而，如果错误信息透露了企业用户名格式，而且如果该组织为其
    VPN 使用单因素身份验证，那么这些错误信息可能会增加通过密码猜测攻击导致内部网络泄露的可能性。
- en: Maintaining a low profile while gathering the information ensures that the target’s
    awareness and security posture remains neutral, increasing the likelihood that
    your attack will be successful.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集信息时保持低调，确保目标的意识和安全姿态保持中立，这样可以增加攻击成功的可能性。
- en: '*Shodan* (*[https://www.shodan.io/](https://www.shodan.io/)*), self-described
    as “the world’s first search engine for internet-connected devices,” facilitates
    passive reconnaissance by maintaining a searchable database of networked devices
    and services, including metadata such as product names, versions, locale, and
    more. Think of Shodan as a repository of scan data, even if it does much, much
    more.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shodan* (*[https://www.shodan.io/](https://www.shodan.io/)*), 自我描述为“世界上第一个面向互联网连接设备的搜索引擎”，通过维护一个可搜索的网络设备和服务数据库，方便被动侦察，其中包括产品名称、版本、本地化等元数据。把Shodan看作是扫描数据的一个存储库，即使它的功能远不止于此。'
- en: Reviewing the Steps for Building an API Client
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查构建API客户端的步骤
- en: In the next few sections, you’ll build an HTTP client that interacts with the
    Shodan API, parsing the results and displaying relevant information. First, you’ll
    need a Shodan API key, which you get after you register on Shodan’s website. At
    the time of this writing, the fee is fairly nominal for the lowest tier, which
    offers adequate credits for individual use, so go sign up for that. Shodan occasionally
    offers discounted pricing, so monitor it closely if you want to save a few bucks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，你将构建一个与Shodan API交互的HTTP客户端，解析结果并显示相关信息。首先，你需要一个Shodan API密钥，可以在注册Shodan网站后获得。写这篇文章时，最低等级的费用相对较低，足够个人使用，因此可以去注册这个账户。Shodan偶尔会提供折扣价格，所以如果你想省点钱，可以密切关注。
- en: Now, get your API key from the site and set it as an environment variable. The
    following examples will work as-is only if you save your API key as the variable
    `SHODAN_API_KEY`. Refer to your operating system’s user manual, or better yet,
    look at [Chapter 1](ch01.xhtml#ch1) if you need help setting the variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从网站获取你的API密钥并将其设置为环境变量。以下示例仅在你将API密钥保存为`SHODAN_API_KEY`变量时才能正常工作。如果你需要帮助设置该变量，可以参考操作系统的用户手册，或者最好查看[第1章](ch01.xhtml#ch1)。
- en: Before working through the code, understand that this section demonstrates how
    to create a bare-bones implementation of a client—not a fully featured, comprehensive
    implementation. However, the basic scaffolding you’ll build now will allow you
    to easily extend the demonstrated code to implement other API calls as you may
    need.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理代码之前，要明白这一部分展示的是如何创建一个简化版的客户端——而不是一个功能齐全、全面的实现。然而，你现在构建的基本框架将使你能够轻松扩展展示的代码，以实现其他API调用，根据需要进行扩展。
- en: 'The client you build will implement two API calls: one to query subscription
    credit information and the other to search for hosts that contain a certain string.
    You use the latter call for identifying hosts; for example, ports or operating
    systems matching a certain product.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的客户端将实现两个API调用：一个是查询订阅信用信息，另一个是搜索包含特定字符串的主机。你将使用后者来识别主机；例如，查找匹配某个产品的端口或操作系统。
- en: 'Luckily, the Shodan API is straightforward, producing nicely structured JSON
    responses. This makes it a good starting point for learning API interaction. Here
    is a high-level overview of the typical steps for preparing and building an API
    client:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Shodan的API非常直接，生成结构良好的JSON响应。这使它成为学习API交互的良好起点。以下是准备和构建API客户端的典型步骤概述：
- en: Review the service’s API documentation.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看服务的API文档。
- en: Design a logical structure for the code in order to reduce complexity and repetition.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计代码的逻辑结构，以减少复杂性和重复性。
- en: Define request or response types, as necessary, in Go.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要在Go中定义请求或响应类型。
- en: Create helper functions and types to facilitate simple initialization, authentication,
    and communication to reduce verbose or repetitive logic.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建辅助函数和类型，以简化初始化、身份验证和通信，减少冗长或重复的逻辑。
- en: Build the client that interacts with the API consumer functions and types.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建与API消费者函数和类型交互的客户端。
- en: We won’t explicitly call out each step in this section, but you should use this
    list as a map to guide your development. Start by quickly reviewing the API documentation
    on Shodan’s website. The documentation is minimal but produces everything needed
    to create a client program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这一节明确列出每个步骤，但你应该使用这个列表作为开发的指南图。首先快速浏览一下Shodan网站上的API文档。文档简洁，但提供了创建客户端程序所需的一切内容。
- en: Designing the Project Structure
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计项目结构
- en: 'When building an API client, you should structure it so that the function calls
    and logic stand alone. This allows you to reuse the implementation as a library
    in other projects. That way, you won’t have to reinvent the wheel in the future.
    Building for reusability slightly changes a project’s structure. For the Shodan
    example, here’s the project structure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 API 客户端时，应该将其结构化，使得函数调用和逻辑能够独立运行。这允许你在其他项目中作为库重复使用实现。这样，你将来就不需要重新发明轮子。为重用性而构建稍微改变了项目的结构。对于
    Shodan 示例，以下是项目结构：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The *main.go* file defines `package main` and is used primarily as a consumer
    of the API you’ll build; in this case, you use it primarily to interact with your
    client implementation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*main.go* 文件定义了 `package main`，并主要用作你将要构建的 API 的消费者；在这个案例中，你主要用它来与客户端实现进行交互。'
- en: The files in the *shodan* directory—*api.go*, *host.go*, and *shodan.go*—define
    `package shodan`, which contains the types and functions necessary for communication
    to and from Shodan. This package will become your stand-alone library that you
    can import into various projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*shodan* 目录中的文件——*api.go*、*host.go* 和 *shodan.go*——定义了 `package shodan`，该包包含与
    Shodan 进行通信所需的类型和函数。这个包将成为你可以导入到各种项目中的独立库。'
- en: Cleaning Up API Calls
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理 API 调用
- en: 'When you perused the Shodan API documentation, you may have noticed that every
    exposed function requires you to send your API key. Although you certainly can
    pass that value around to each consumer function you create, that repetitive task
    becomes tedious. The same can be said for either hardcoding or handling the base
    URL (*https://api.shodan.io/*). For example, defining your API functions, as in
    the following snippet, requires you to pass in the token and URL to each function,
    which isn’t very elegant:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览 Shodan API 文档时，可能已经注意到每个暴露的函数都需要你发送 API 密钥。虽然你当然可以将该值传递给每个你创建的消费函数，但这种重复的任务会变得非常乏味。同样，硬编码或处理基础
    URL（*https://api.shodan.io/*）也可以说是类似的情况。例如，定义 API 函数，如以下代码片段所示，要求你将 token 和 URL
    传递给每个函数，这并不是很优雅：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead, opt for a more idiomatic solution that allows you to save keystrokes
    while arguably making your code more readable. To do this, create a *shodan.go*
    file and enter the code in [Listing 3-7](ch03.xhtml#ch3list7).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，选择一个更符合惯用法的解决方案，它能节省你的敲击次数，同时无可争议地让你的代码更加可读。为此，创建一个 *shodan.go* 文件，并在 [列出
    3-7](ch03.xhtml#ch3list7) 中输入代码。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 3-7: Shodan `Client` definition (*/[ch-3/shodan/shodan/shodan.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/shodan.go)*)*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 3-7：Shodan `Client` 定义（*/[ch-3/shodan/shodan/shodan.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/shodan.go)*)*'
- en: 'The Shodan URL is defined as a constant value ❶; that way, you can easily access
    and reuse it within your implementing functions. If Shodan ever changes the URL
    of its API, you’ll have to make the change at only this one location in order
    to correct your entire codebase. Next, you define a `Client` struct, used for
    maintaining your API token across requests ❷. Finally, the code defines a `New()`
    helper function, taking the API token as input and creating and returning an initialized
    `Client` instance ❸. Now, rather than creating your API code as arbitrary functions,
    you create them as *methods* on the `Client` struct, which allows you to interrogate
    the instance directly rather than relying on overly verbose function parameters.
    You can change your API function calls, which we’ll discuss momentarily, to the
    following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Shodan URL 被定义为常量值 ❶；这样，你可以轻松访问并在实现函数中重用它。如果 Shodan 以后更改了其 API 的 URL，你只需在这个位置进行修改，就能修正整个代码库。接下来，你定义了一个
    `Client` 结构体，用于在请求中维护你的 API token ❷。最后，代码定义了一个 `New()` 辅助函数，接受 API token 作为输入，并创建并返回一个初始化的
    `Client` 实例 ❸。现在，与你的 API 代码作为任意函数的情况不同，你将它们作为 `Client` 结构体上的 *方法* 来创建，这样你可以直接查询实例，而不依赖过于冗长的函数参数。你可以将
    API 函数调用修改为以下形式：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since these are methods on the `Client` struct, you can retrieve the API key
    through `s.apiKey` and retrieve the URL through `BaseURL`. The only prerequisite
    to calling the methods is that you create an instance of the `Client` struct first.
    You can do this with the `New()` helper function in *shodan.go*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是 `Client` 结构体上的方法，你可以通过 `s.apiKey` 获取 API 密钥，并通过 `BaseURL` 获取 URL。调用这些方法的唯一前提是你首先创建一个
    `Client` 结构体的实例。你可以通过 *shodan.go* 中的 `New()` 辅助函数来实现这一点。
- en: Querying Your Shodan Subscription
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询你的 Shodan 订阅
- en: 'Now you’ll start the interaction with Shodan. Per the Shodan API documentation,
    the call to query your subscription plan information is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将开始与 Shodan 进行交互。根据 Shodan API 文档，查询你的订阅计划信息的调用如下：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The response returned resembles the following structure. Obviously, the values
    will differ based on your plan details and remaining subscription credits.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的响应类似于以下结构。显然，具体值会根据你的计划细节和剩余的订阅积分有所不同。
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, in *api.go*, you’ll need to define a type that can be used to unmarshal
    the JSON response to a Go struct. Without it, you won’t be able to process or
    interrogate the response body. In this example, name the type `APIInfo`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *api.go* 中，你需要定义一个类型，用来将 JSON 响应解组到 Go 结构体中。如果没有它，你将无法处理或查询响应体。在这个示例中，将类型命名为
    `APIInfo`：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The awesomeness that is Go makes that structure and JSON alignment a joy. As
    shown in [Chapter 1](ch01.xhtml#ch1), you can use some great tooling to “automagically”
    parse JSON—populating the fields for you. For each exported type on the struct,
    you explicitly define the JSON element name with struct tags so you can ensure
    that data is mapped and parsed properly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的强大之处在于它使得结构体和 JSON 对齐变得轻松愉快。正如[第 1 章](ch01.xhtml#ch1)所示，你可以使用一些强大的工具来“自动”解析
    JSON——并为你填充字段。对于结构体中的每个导出类型，你都明确地使用结构体标签定义 JSON 元素名称，以确保数据能够正确映射和解析。
- en: 'Next you need to implement the function in [Listing 3-8](ch03.xhtml#ch3list8),
    which makes an HTTP GET request to Shodan and decodes the response into your `APIInfo`
    struct:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在[清单 3-8](ch03.xhtml#ch3list8)中实现一个函数，该函数向 Shodan 发出 HTTP GET 请求并将响应解码到你的
    `APIInfo` 结构体中：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-8: Making an HTTP GET request and decoding the response (*[/ch-3/shodan/shodan/api.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/api.go)*)*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-8：发起 HTTP GET 请求并解码响应 (*[/ch-3/shodan/shodan/api.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/api.go)*)*'
- en: The implementation is short and sweet. You first issue an HTTP GET request to
    the `/api-info` resource ❶. The full URL is built using the `BaseURL` global constant
    and `s.apiKey`. You then decode the response into your `APIInfo` struct ❷ and
    return it to the caller.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常简洁。你首先向 `/api-info` 资源发出 HTTP GET 请求❶。完整的 URL 是通过 `BaseURL` 全局常量和 `s.apiKey`
    构建的。然后，你将响应解码到 `APIInfo` 结构体❷中，并返回给调用者。
- en: 'Before writing code that utilizes this shiny new logic, build out a second,
    more useful API call—the host search—which you’ll add to *host.go*. The request
    and response, according to the API documentation, is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写利用这些新逻辑的代码之前，先构建一个第二个、更有用的 API 调用——主机搜索——并将其添加到 *host.go* 中。根据 API 文档，请求和响应如下：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compared to the initial API call you implemented, this one is significantly
    more complex. Not only does the request take multiple parameters, but the JSON
    response contains nested data and arrays. For the following implementation, you’ll
    ignore the `facets` option and data, and instead focus on performing a string-based
    host search to process only the `matches` element of the response.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与你实现的初始 API 调用相比，这个调用明显更为复杂。请求不仅需要多个参数，而且 JSON 响应包含了嵌套的数据和数组。在接下来的实现中，你将忽略 `facets`
    选项和数据，而是专注于执行基于字符串的主机搜索，只处理响应中的 `matches` 元素。
- en: As you did before, start by building the Go structs to handle the response data;
    enter the types in [Listing 3-9](ch03.xhtml#ch3list9) into your *host.go* file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样，首先构建 Go 结构体来处理响应数据；将 [清单 3-9](ch03.xhtml#ch3list9) 中的类型输入到你的 *host.go*
    文件中。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-9: Host search response data types (*[/ch-3/shodan/shodan/host.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/host.go)*)*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-9：主机搜索响应数据类型 (*[/ch-3/shodan/shodan/host.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/host.go)*)*'
- en: 'The code defines three types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了三种类型：
- en: '**HostSearch** Used for parsing the `matches` array'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**HostSearch** 用于解析 `matches` 数组'
- en: '**Host** Represents a single `matches` element'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**Host** 表示单个 `matches` 元素'
- en: '**HostLocation** Represents the `location` element within the host'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**HostLocation** 表示主机中的 `location` 元素'
- en: Notice that the types may not define all response fields. Go handles this elegantly,
    allowing you to define structures with only the JSON fields you care about. Therefore,
    our code will parse the JSON just fine, while reducing the length of your code
    by including only the fields that are most relevant to the example. To initialize
    and populate the struct, you’ll define the function in [Listing 3-10](ch03.xhtml#ch3list10),
    which is similar to the `APIInfo()` method you created in [Listing 3-8](ch03.xhtml#ch3list8).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类型可能没有定义所有响应字段。Go优雅地处理了这个问题，允许你仅定义关心的JSON字段的结构。因此，我们的代码可以很好地解析JSON，同时通过只包含与示例最相关的字段来减少代码长度。为了初始化和填充结构体，你将在[清单
    3-10](ch03.xhtml#ch3list10)中定义函数，这与在[清单 3-8](ch03.xhtml#ch3list8)中创建的`APIInfo()`方法类似。
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-10: Decoding the host search response body (*[/ch-3/shodan/shodan/host.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/host.go)*)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-10：解码主机搜索响应体（*[/ch-3/shodan/shodan/host.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/shodan/host.go)*)*'
- en: The flow and logic is exactly like the `APIInfo()` method, except that you take
    the search query string as a parameter ❶, issue the call to the `/shodan/host/search`
    endpoint while passing the search term ❷, and decode the response into the `HostSearch`
    struct ❸.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 流程和逻辑与`APIInfo()`方法完全相同，不同之处在于你将搜索查询字符串作为参数❶，调用`/shodan/host/search`端点并传递搜索词❷，然后将响应解码为`HostSearch`结构体❸。
- en: 'You repeat this process of structure definition and function implementation
    for each API service you want to interact with. Rather than wasting precious pages
    here, we’ll jump ahead and show you the last step of the process: creating the
    client that uses your API code.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个你希望交互的API服务，你都需要重复进行结构定义和函数实现的过程。为了不浪费宝贵的篇幅，我们将跳过中间过程，直接展示最后一步：创建一个使用你的API代码的客户端。
- en: Creating a Client
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'You’ll use a minimalistic approach to create your client: take a search term
    as a command line argument and then call the `APIInfo()` and `HostSearch()` methods,
    as in [Listing 3-11](ch03.xhtml#ch3list11).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你将采用简洁的方法来创建你的客户端：将搜索词作为命令行参数，然后像[清单 3-11](ch03.xhtml#ch3list11)中那样调用`APIInfo()`和`HostSearch()`方法。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-11: Consuming and using the `shodan` package (*[/ch-3/shodan/cmd/shodan/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/cmd/shodan/main.go)*)*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-11：使用`shodan`包（*[/ch-3/shodan/cmd/shodan/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/shodan/cmd/shodan/main.go)*)*'
- en: 'Start by reading your API key from the `SHODAN_API_KEY` environment variable
    ❶. Then use that value to initialize a new `Client` struct ❷, `s`, subsequently
    using it to call your `APIInfo()` method ❸. Call the `HostSearch()` method, passing
    in a search string captured as a command line argument ❹. Finally, loop through
    the results to display the IP and port values for those services matching the
    query string ❺. The following output shows a sample run, searching for the string
    `tomcat`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从`SHODAN_API_KEY`环境变量❶中读取API密钥。然后使用该值初始化一个新的`Client`结构体❷，并用它调用`APIInfo()`方法❸。接着调用`HostSearch()`方法，传入作为命令行参数捕获的搜索字符串❹。最后，循环遍历结果并显示与查询字符串匹配的服务的IP和端口值❺。以下输出展示了一个示例运行，搜索字符串为`tomcat`：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You’ll want to add error handling and data validation to this project, but it
    serves as a good example for fetching and displaying Shodan data with your new
    API. You now have a working codebase that can be easily extended to support and
    test the other Shodan functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这个项目添加错误处理和数据验证，但它作为一个获取和展示Shodan数据的好例子，配合你的新API已经可以工作了。你现在有一个可以轻松扩展的代码库，能够支持和测试其他Shodan函数。
- en: Interacting with Metasploit
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Metasploit交互
- en: '*Metasploit* is a framework used to perform a variety of adversarial techniques,
    including reconnaissance, exploitation, command and control, persistence, lateral
    network movement, payload creation and delivery, privilege escalation, and more.
    Even better, the community version of the product is free, runs on Linux and macOS,
    and is actively maintained. Essential for any adversarial engagement, Metasploit
    is a fundamental tool used by penetration testers, and it exposes a *remote procedure
    call* *(RPC)* API to allow remote interaction with its functionality.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*Metasploit*是一个框架，用于执行多种对抗技术，包括侦察、利用、命令与控制、持久化、横向网络移动、有效载荷创建与投递、特权提升等。更好的是，产品的社区版是免费的，可以在Linux和macOS上运行，并且在积极维护中。作为任何对抗行动的必备工具，Metasploit是渗透测试员使用的基本工具，它暴露了一个*远程过程调用*（*RPC*）API，允许远程交互其功能。'
- en: In this section, you’ll build a client that interacts with a remote Metasploit
    instance. Much like the Shodan code you built, the Metasploit client you develop
    won’t cover a comprehensive implementation of all available functionality. Rather,
    it will be the foundation upon which you can extend additional functionality as
    needed. We think you’ll find the implementation more complex than the Shodan example,
    making the Metasploit interaction a more challenging progression.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将构建一个与远程 Metasploit 实例交互的客户端。和你之前构建的 Shodan 代码类似，你开发的 Metasploit 客户端不会覆盖所有可用功能的全面实现。而是，它将成为你在需要时可以扩展更多功能的基础。我们认为你会发现这一实现比
    Shodan 示例更复杂，使得与 Metasploit 的交互成为更具挑战性的进展。
- en: Setting Up Your Environment
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置你的环境
- en: Before you proceed with this section, download and install the Metasploit community
    edition if you don’t already have it. Start the Metasploit console as well as
    the RPC listener through the `msgrpc` module in Metasploit. Then set the server
    host—the IP on which the RPC server will listen—and a password, as shown in [Listing
    3-12](ch03.xhtml#ch3list12).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本节内容之前，如果你尚未安装 Metasploit，请下载并安装 Metasploit 社区版。启动 Metasploit 控制台以及通过 `msgrpc`
    模块在 Metasploit 中启动 RPC 监听器。然后设置服务器主机—RPC 服务器监听的 IP 地址，以及密码，如 [Listing 3-12](ch03.xhtml#ch3list12)
    所示。
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 3-12: Starting Metasploit and the msgrpc server*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-12: 启动 Metasploit 和 msgrpc 服务器*'
- en: To make the code more portable and avoid hardcoding values, set the following
    environment variables to the values you defined for your RPC instance. This is
    similar to what you did for the Shodan API key used to interact with Shodan in
    “Creating a Client” on [page 58](ch03.xhtml#page_58).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更具可移植性并避免硬编码值，请将以下环境变量设置为你为 RPC 实例定义的值。这与在 [第 58 页](ch03.xhtml#page_58)中“创建客户端”部分用于与
    Shodan 交互的 Shodan API 密钥设置类似。
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You should now have Metasploit and the RPC server running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经运行了 Metasploit 和 RPC 服务器。
- en: Because the details on exploitation and Metasploit use are beyond the scope
    of this book,^([1](footnote.xhtml#ch3fn1)) let’s assume that through pure cunning
    and trickery you’ve already compromised a remote Windows system and you’ve leveraged
    Metasploit’s Meterpreter payload for advanced post-exploitation activities. Here,
    your efforts will instead focus on how you can remotely communicate with Metasploit
    to list and interact with established Meterpreter sessions. As we mentioned before,
    this code is a bit more cumbersome, so we’ll purposely pare it back to the bare
    minimum—just enough for you to take the code and extend it for your specific needs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关于利用和 Metasploit 使用的详细内容超出了本书的范围，^([1](footnote.xhtml#ch3fn1)) 让我们假设通过纯粹的诡计和欺骗，你已经攻破了远程
    Windows 系统，并且你已经利用了 Metasploit 的 Meterpreter 载荷进行高级的后期利用活动。在这里，你的努力将集中在如何通过远程通信与
    Metasploit 交互，列出并操作已建立的 Meterpreter 会话。正如我们之前提到的，这段代码稍显繁琐，因此我们将故意将其简化到最基本的部分—仅足够让你可以将代码拿来并根据具体需求扩展它。
- en: 'Follow the same project roadmap as the Shodan example: review the Metasploit
    API, lay out the project in library format, define data types, implement client
    API functions, and, finally, build a test rig that uses the library.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 按照与 Shodan 示例相同的项目路线图进行操作：查看 Metasploit API，按库格式布局项目，定义数据类型，实现客户端 API 函数，最后，构建一个使用该库的测试设备。
- en: 'First, review the Metasploit API developer documentation at Rapid7’s official
    website (*[https://metasploit.help.rapid7.com/docs/rpc-api/](https://metasploit.help.rapid7.com/docs/rpc-api/)*).
    The functionality exposed is extensive, allowing you to do just about anything
    remotely that you could through local interaction. Unlike Shodan, which uses JSON,
    Metasploit communicates using MessagePack, a compact and efficient binary format.
    Because Go doesn’t contain a standard MessagePack package, you’ll use a full-featured
    community implementation. Install it by executing the following from the command
    line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看 Rapid7 官方网站上的 Metasploit API 开发者文档 (*[https://metasploit.help.rapid7.com/docs/rpc-api/](https://metasploit.help.rapid7.com/docs/rpc-api/)*)。公开的功能非常丰富，几乎可以远程执行任何本地交互能够实现的操作。与使用
    JSON 的 Shodan 不同，Metasploit 使用 MessagePack，一种紧凑高效的二进制格式进行通信。由于 Go 没有标准的 MessagePack
    包，你将使用一个功能完善的社区实现。通过在命令行中执行以下操作进行安装：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the code, you’ll refer to the implementation as `msgpack`. Don’t worry too
    much about the details of the MessagePack spec. You’ll see shortly that you’ll
    need to know very little about MessagePack itself to build a working client. Go
    is great because it hides a lot of these details, allowing you to instead focus
    on business logic. What you need to know are the basics of annotating your type
    definitions in order to make them “MessagePack-friendly.” Beyond that, the code
    to initiate encoding and decoding is identical to other formats, such as JSON
    and XML.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，您将实现称为 `msgpack`。不用太担心 MessagePack 规范的细节。您很快会发现，为了构建一个有效的客户端，您几乎不需要了解 MessagePack
    本身。Go 很棒，因为它隐藏了许多这些细节，允许您专注于业务逻辑。您需要了解的是如何注解您的类型定义，以使其“兼容 MessagePack”。除此之外，初始化编码和解码的代码与其他格式（如
    JSON 和 XML）完全相同。
- en: 'Next, create your directory structure. For this example, you use only two Go
    files:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建您的目录结构。对于这个示例，您只需要使用两个 Go 文件：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The *msf.go* file resides within the `rpc` package, and you’ll use *client/main.go*
    to implement and test the library you build.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*msf.go* 文件位于 `rpc` 包中，您将使用 *client/main.go* 来实现并测试您构建的库。'
- en: Defining Your Objective
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义您的目标
- en: 'Now, you need to define your objective. For the sake of brevity, implement
    the code to interact and issue an RPC call that retrieves a listing of current
    Meterpreter sessions—that is, the `session.list` method from the Metasploit developer
    documentation. The request format is defined as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要定义目标。为了简洁起见，实现与 RPC 调用交互并检索当前 Meterpreter 会话列表的代码——即 Metasploit 开发文档中的
    `session.list` 方法。请求格式定义如下：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is minimal; it expects to receive the name of the method to implement
    and a token. The token value is a placeholder. If you read through the documentation,
    you’ll find that this is an authentication token, issued upon successful login
    to the RPC server. The response returned from Metasploit for the `session.list`
    method follows this format:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简化的，它期望接收方法名和一个令牌。令牌值是占位符。如果您阅读文档，您会发现这是一个身份验证令牌，在成功登录 RPC 服务器后发放。Metasploit
    对 `session.list` 方法返回的响应格式如下：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This response is returned as a map: the Meterpreter session identifiers are
    the keys, and the session detail is the value.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应作为一个映射返回：Meterpreter 会话标识符是键，会话详细信息是值。
- en: Let’s build the Go types to handle both the request and response data. [Listing
    3-13](ch03.xhtml#ch3list13) defines the `sessionListReq` and `SessionListRes`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建 Go 类型来处理请求和响应数据。[清单 3-13](ch03.xhtml#ch3list13) 定义了 `sessionListReq` 和
    `SessionListRes`。
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-13: Metasploit session list type definitions (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-13：Metasploit 会话列表类型定义（*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)）*'
- en: You use the request type, `sessionListReq` ❶, to serialize structured data to
    the MessagePack format in a manner consistent with what the Metasploit RPC server
    expects—specifically, with a method name and token value. Notice that there aren’t
    any descriptors for those fields. The data is passed as an array, not a map, so
    rather than expecting data in key/value format, the RPC interface expects the
    data as a positional array of values. This is why you omit annotations for those
    properties—no need to define the key names. However, by default, a structure will
    be encoded as a map with the key names deduced from the property names. To disable
    this and force the encoding as a positional array, you add a special field named
    _`msgpack` that utilizes the `asArray` descriptor ❷, to explicitly instruct an
    encoder/decoder to treat the data as an array.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用请求类型 `sessionListReq` ❶ 将结构化数据序列化为 MessagePack 格式，以符合 Metasploit RPC 服务器的期望——具体来说，就是方法名称和令牌值。请注意，这些字段没有描述符。数据是作为数组传递的，而不是映射，因此
    RPC 接口期望以位置数组的形式传递数据，而不是以键值对的形式。因此，您省略了这些属性的注释——无需定义键名。然而，默认情况下，结构会被编码为一个映射，其键名是从属性名推断出来的。为了禁用这种行为并强制编码为位置数组，您可以添加一个名为
    _`msgpack` 的特殊字段，使用 `asArray` 描述符 ❷，明确指示编码器/解码器将数据视为数组。
- en: The `SessionListRes` type ❸ contains a one-to-one mapping between response field
    and struct properties. The data, as shown in the preceding example response, is
    essentially a nested map. The outer map is the session identifier to session details,
    while the inner map is the session details, represented as key/value pairs. Unlike
    the request, the response isn’t structured as a positional array, but each of
    the struct properties uses descriptors to explicitly name and map the data to
    and from Metasploit’s representation. The code includes the session identifier
    as a property on the struct. However, because the actual value of the identifier
    is the key value, this will be populated in a slightly different manner, so you
    include the `omitempty` descriptor ❹ to make the data optional so that it doesn’t
    impact encoding or decoding. This flattens the data so you don’t have to work
    with nested maps.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionListRes`类型❸包含响应字段与结构体属性之间的一一映射。数据，如前面的响应示例所示，本质上是一个嵌套的映射。外层映射是会话标识符到会话详情的映射，而内层映射是会话详情，以键/值对的形式表示。与请求不同，响应不是按位置数组结构化的，而是每个结构体属性都使用描述符显式命名并将数据与Metasploit的表示进行映射。代码中将会话标识符作为结构体上的一个属性。然而，由于标识符的实际值是键值，这将在稍微不同的方式下填充，因此你需要包含`omitempty`描述符❹，使数据可选，以避免影响编码或解码。这会扁平化数据，使你不必处理嵌套的映射。'
- en: Retrieving a Valid Token
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取有效令牌
- en: 'Now, you have only one thing outstanding. You have to retrieve a valid token
    value to use for that request. To do so, you’ll issue a login request for the
    `auth.login()` API method, which expects the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只有一件事情需要处理。你需要获取一个有效的令牌值来执行该请求。为此，你需要发出`auth.login()` API 方法的登录请求，要求如下：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You need to replace the username and password values with what you used when
    loading the `msfrpc` module in Metasploit during initial setup (recall that you
    set them as environment variables). Assuming authentication is successful, the
    server responds with the following message, which contains an authentication token
    you can use for subsequent requests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将用户名和密码的值替换为你在初始设置时加载`msfrpc`模块时使用的值（记得你将它们作为环境变量设置）。假设认证成功，服务器会返回以下消息，其中包含一个你可以用于后续请求的认证令牌。
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An authentication failure produces the following response:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 认证失败会产生以下响应：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For good measure, let’s also create functionality to expire the token by logging
    out. The request takes the method name, the authentication token, and a third
    optional parameter that you’ll ignore because it’s unnecessary for this scenario:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保万无一失，我们还需要创建登出时使令牌过期的功能。请求包含方法名称、认证令牌以及一个第三个可选参数，你可以忽略它，因为在这个场景中不需要使用：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A successful response looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的响应看起来是这样的：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Defining Request and Response Methods
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义请求和响应方法
- en: 'Much as you structured the Go types for the `session.list()` method’s request
    and response, you need to do the same for both `auth.login()` and `auth.logout()`
    (see [Listing 3-14](ch03.xhtml#ch3list14)). The same reasoning applies as before,
    using descriptors to force requests to be serialized as arrays and for the responses
    to be treated as maps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你为`session.list()`方法的请求和响应定义Go类型一样，你需要为`auth.login()`和`auth.logout()`做同样的处理（参见[示例
    3-14](ch03.xhtml#ch3list14)）。应用相同的理由，使用描述符来强制将请求序列化为数组，并将响应处理为映射：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 3-14: Login and logout Metasploit type definition (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-14：登录和登出 Metasploit 类型定义 (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
- en: It’s worth noting that Go dynamically serializes the login response, populating
    only the fields present, which means you can represent both successful and failed
    logins by using a single struct format.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Go会动态地序列化登录响应，仅填充存在的字段，这意味着你可以使用单一的结构体格式表示成功和失败的登录。
- en: Creating a Configuration Struct and an RPC Method
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建配置结构体和RPC方法
- en: In [Listing 3-15](ch03.xhtml#ch3list15), you take the defined types and actually
    use them, creating the necessary methods to issue RPC commands to Metasploit.
    Much as in the Shodan example, you also define an arbitrary type for maintaining
    pertinent configuration and authentication information. That way, you won’t have
    to explicitly and repeatedly pass in common elements such as host, port, and authentication
    token. Instead, you’ll use the type and build methods on it so that data is implicitly
    available.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 3-15](ch03.xhtml#ch3list15)中，您使用已定义的类型，实际应用它们，创建必要的方法以向Metasploit发出RPC命令。与Shodan示例类似，您还为维护相关的配置和身份验证信息定义了一个任意类型。这样，您就不需要显式地重复传递诸如主机、端口和身份验证令牌等常见元素。相反，您将使用该类型，并在其上构建方法，从而使数据隐式地可用。
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 3-15: Metasploit client definition (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-15：Metasploit 客户端定义 (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
- en: Now you have a struct and, for convenience, a function named `New()` that initializes
    and returns a new struct.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有了一个结构体，并且为了方便，定义了一个名为`New()`的函数，用于初始化并返回一个新的结构体。
- en: Performing Remote Calls
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行远程调用
- en: You can now build methods on your `Metasploit` type in order to perform the
    remote calls. To prevent extensive code duplication, in [Listing 3-16](ch03.xhtml#ch3list16),
    you start by building a method that performs the serialization, deserialization,
    and HTTP communication logic. Then you won’t have to include this logic in every
    RPC function you build.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在`Metasploit`类型上构建方法，以执行远程调用。为了防止大量代码重复，在[清单 3-16](ch03.xhtml#ch3list16)中，您首先构建了一个执行序列化、反序列化和HTTP通信逻辑的方法。这样，您就不需要在每个RPC函数中都包括这部分逻辑。
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 3-16: Generic `send()` method with reusable serialization and deserialization
    (*/[ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-16：通用`send()`方法，具有可重用的序列化和反序列化功能 (*/[ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
- en: The `send()` method receives request and response parameters of type `interface{}`
    ❶. Using this interface type allows you to pass any request struct into the method,
    and subsequently serialize and send the request to the server. Rather than explicitly
    returning the response, you’ll use the `res interface{}` parameter to populate
    its data by writing a decoded HTTP response to its location in memory.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`方法接收类型为`interface{}`的请求和响应参数❶。使用此接口类型，您可以将任何请求结构体传递给该方法，并随后将请求序列化并发送到服务器。与显式返回响应不同，您将使用`res
    interface{}`参数，通过将解码后的HTTP响应写入其内存位置来填充数据。'
- en: 'Next, use the `msgpack` library to encode the request ❷. The logic to do this
    matches that of other standard, structured data types: first create an encoder
    via `NewEncoder()` and then call the `Encode()` method. This populates the `buf`
    variable with MessagePack-encoded representation of the request struct. Following
    the encoding, you build the destination URL by using the data within the `Metasploit`
    receiver, `msf` ❸. You use that URL and issue a POST request, explicitly setting
    the content type to `binary/message-pack` and setting the body to the serialized
    data ❹. Finally, you decode the response body ❺. As alluded to earlier, the decoded
    data is written to the memory location of the response interface that was passed
    into the method. The encoding and decoding of data is done without ever needing
    to explicitly know the request or response struct types, making this a flexible,
    reusable method.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`msgpack`库对请求进行编码❷。执行此操作的逻辑与其他标准结构化数据类型相同：首先通过`NewEncoder()`创建编码器，然后调用`Encode()`方法。这将用MessagePack编码后的请求结构体填充`buf`变量。在编码完成后，您通过使用`Metasploit`接收器中的数据，构建目标URL，即`msf`❸。您使用该URL发出POST请求，明确设置内容类型为`binary/message-pack`，并将请求体设置为序列化后的数据❹。最后，您解码响应体❺。如前所述，解码后的数据被写入传递到方法中的响应接口的内存位置。数据的编码和解码是无需显式了解请求或响应结构体类型的，这使得该方法具有灵活性和可重用性。
- en: In [Listing 3-17](ch03.xhtml#ch3list17), you can see the meat of the logic in
    all its glory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 3-17](ch03.xhtml#ch3list17)中，您可以看到逻辑的核心部分，尽显光彩。
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 3-17: Metasploit API calls implementation (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-17：Metasploit API 调用实现 (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
- en: 'You define three methods: `Login()` ❶, `Logout()` ❸, and `SessionList()` ❺.
    Each method uses the same general flow: create and initialize a request struct,
    create the response struct, and call the helper function ❷❹❼ to send the request
    and receive the decoded response. The `Login()` and `Logout()` methods manipulate
    the `token` property. The only significant difference between method logic appears
    in the `SessionList()` method, where you define the response as a `map[uint32]SessionListRes`
    ❻ and loop over that response to flatten the map ❽, setting the `ID` property
    on the struct rather than maintaining a map of maps.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义了三个方法：`Login()` ❶、`Logout()` ❸ 和 `SessionList()` ❺。每个方法使用相同的一般流程：创建并初始化请求结构体，创建响应结构体，并调用帮助函数
    ❷❹❼ 来发送请求并接收解码后的响应。`Login()` 和 `Logout()` 方法操作 `token` 属性。方法逻辑中唯一显著的不同出现在 `SessionList()`
    方法中，在那里您将响应定义为 `map[uint32]SessionListRes` ❻，并遍历该响应来展平映射 ❽，在结构体上设置 `ID` 属性，而不是保持映射的映射。
- en: Remember that the `session.list()` RPC function requires a valid authentication
    token, meaning you have to log in before the `SessionList()` method call will
    succeed. [Listing 3-18](ch03.xhtml#ch3list18) uses the `Metasploit` receiver struct
    to access a token, which isn’t a valid value yet—it’s an empty string. Since the
    code you’re developing here isn’t fully featured, you could just explicitly include
    a call to your `Login()` method from within the `SessionList()` method, but for
    each additional authenticated method you implement, you’d have to check for the
    existence of a valid authentication token and make an explicit call to `Login()`.
    This isn’t great coding practice because you’d spend a lot of time repeating logic
    that you could write, say, as part of a bootstrapping process.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`session.list()` RPC 函数需要有效的身份验证令牌，这意味着您必须先登录才能使 `SessionList()` 方法调用成功。[列表
    3-18](ch03.xhtml#ch3list18) 使用 `Metasploit` 接收器结构体来访问令牌，但它还不是有效的值——它是一个空字符串。由于您在这里开发的代码还不是完整功能，您可以在
    `SessionList()` 方法中显式包含对 `Login()` 方法的调用，但对于每个额外的已认证方法，您都必须检查是否存在有效的身份验证令牌，并显式调用
    `Login()`。这不是一个很好的编码实践，因为您将花费大量时间重复可以作为引导过程的一部分编写的逻辑。
- en: You’ve already implemented a function, `New()`, designed to be used for bootstrapping,
    so patch up that function to see what a new implementation looks like when including
    authentication as part of the process (see [Listing 3-18](ch03.xhtml#ch3list18)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经实现了一个函数 `New()`，它旨在用于引导，因此修补这个函数，看看当将身份验证作为过程的一部分时，新实现会是什么样子（参见 [列表 3-18](ch03.xhtml#ch3list18)）。
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 3-18: Initializing the client with embedding Metasploit login (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-18：使用嵌入式 Metasploit 登录初始化客户端 (*[/ch-3/metasploit-minimal/rpc/msf.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/rpc/msf.go)*)*'
- en: The patched-up code now includes an `error` as part of the return value set
    ❶. This is to alert on possible authentication failures. Also, added to the logic
    is an explicit call to the `Login()` method ❷. As long as the `Metasploit` struct
    is instantiated using this `New()` function, your authenticated method calls will
    now have access to a valid authentication token.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 修补后的代码现在将 `error` 作为返回值的一部分 ❶。这是为了提醒可能的身份验证失败。此外，逻辑中还显式调用了 `Login()` 方法 ❷。只要通过这个
    `New()` 函数实例化 `Metasploit` 结构体，您的身份验证方法调用现在就可以访问有效的身份验证令牌。
- en: Creating a Utility Program
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个实用程序程序
- en: Nearing the end of this example, your last effort is to create the utility program
    that implements your shiny new library. Enter the code in [Listing 3-19](ch03.xhtml#ch3list19)
    into *client/main.go*, run it, and watch the magic happen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接近本示例的结束时，您最后的工作是创建实现您崭新的库的实用程序程序。将 [列表 3-19](ch03.xhtml#ch3list19) 中的代码输入到
    *client/main.go*，运行它，观看魔法发生。
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 3-19: Consuming our `msfrpc` package (*[/ch-3/metasploit-minimal/client/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/client/main.go)*)*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-19：使用我们的 `msfrpc` 包 (*[/ch-3/metasploit-minimal/client/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/metasploit-minimal/client/main.go)*)*'
- en: First, bootstrap the RPC client and initialize a new `Metasploit` struct ❶.
    Remember, you just updated this function to perform authentication during initialization.
    Next, ensure you do proper cleanup by issuing a deferred call to the `Logout()`
    method ❷. This will run when the `main` function returns or exits. You then issue
    a call to the `SessionList()` method ❸ and iterate over that response to list
    out the available Meterpreter sessions ❹.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，引导启动 RPC 客户端并初始化一个新的 `Metasploit` 结构体 ❶。记住，你刚刚更新了这个函数，使其在初始化时执行身份验证。接下来，通过发出延迟调用
    `Logout()` 方法 ❷ 来确保进行适当的清理。此方法将在 `main` 函数返回或退出时执行。然后，你调用 `SessionList()` 方法 ❸
    并遍历该响应，以列出可用的 Meterpreter 会话 ❹。
- en: 'That was a lot of code, but fortunately, implementing other API calls should
    be substantially less work since you’ll just be defining request and response
    types and building the library method to issue the remote call. Here’s sample
    output produced directly from our client utility, showing one established Meterpreter
    session:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码量很大，但幸运的是，执行其他 API 调用的工作量应该会少得多，因为你只需定义请求和响应类型，并构建库方法来发起远程调用。以下是直接从我们的客户端工具生成的示例输出，展示了一个已建立的
    Meterpreter 会话：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There you have it. You’ve successfully created a library and client utility
    to interact with a remote Metasploit instance to retrieve the available Meterpreter
    sessions. Next, you’ll venture into search engine response scraping and document
    metadata parsing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你已经成功创建了一个库和客户端工具，用于与远程 Metasploit 实例交互，以检索可用的 Meterpreter 会话。接下来，你将进入搜索引擎响应抓取和文档元数据解析的部分。
- en: Parsing Document Metadata with Bing Scraping
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Bing 抓取解析文档元数据
- en: As we stressed in the Shodan section, relatively benign information—when viewed
    in the correct context—can prove to be critical, increasing the likelihood that
    your attack against an organization succeeds. Information such as employee names,
    phone numbers, email addresses, and client software versions are often the most
    highly regarded because they provide concrete or actionable information that attackers
    can directly exploit or use to craft attacks that are more effective and highly
    targeted. One such source of information, popularized by a tool named FOCA, is
    document metadata.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Shodan 部分强调的那样，相对无害的信息——当置于正确的背景下观看时——可以证明至关重要，从而增加你对一个组织发起攻击成功的可能性。诸如员工姓名、电话号码、电子邮件地址和客户端软件版本等信息，往往是最受重视的，因为它们提供了攻击者可以直接利用的具体或可操作的信息，或者可以用来设计更有效、更有针对性的攻击。一个由名为
    FOCA 的工具普及的这种信息源便是文档元数据。
- en: Applications store arbitrary information within the structure of a file saved
    to disk. In some cases, this can include geographical coordinates, application
    versions, operating system information, and usernames. Better yet, search engines
    contain advanced query filters that allow you to retrieve specific files for an
    organization. The remainder of this chapter focuses on building a tool that *scrapes*—or
    as my lawyer calls it, *indexes*—Bing search results to retrieve a target organization’s
    Microsoft Office documents, subsequently extracting relevant metadata.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在保存到磁盘的文件结构中存储任意信息。在某些情况下，这些信息可能包括地理坐标、应用程序版本、操作系统信息和用户名。更妙的是，搜索引擎包含了高级查询过滤器，允许你为一个组织检索特定的文件。本章的其余部分将专注于构建一个工具，它通过*抓取*——或者我律师称之为*索引*——Bing
    搜索结果，来获取目标组织的 Microsoft Office 文档，并随后提取相关的元数据。
- en: Setting Up the Environment and Planning
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置环境和规划
- en: Before diving into the specifics, we’ll start by stating the objectives. First,
    you’ll focus solely on Office Open XML documents—those ending in *xlsx*, *docx*,
    *pptx*, and so on. Although you could certainly include legacy Office data types,
    the binary formats make them exponentially more complicated, increasing code complexity
    and reducing readability. The same can be said for working with PDF files. Also,
    the code you develop won’t handle Bing pagination, instead only parsing initial
    page search results. We encourage you to build this into your working example
    and explore file types beyond Open XML.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入具体内容之前，我们先声明一下目标。首先，你将仅关注 Office Open XML 文档——那些以 *xlsx*、*docx*、*pptx* 等结尾的文件。尽管你当然可以包括旧版
    Office 数据类型，但二进制格式使它们变得更加复杂，增加了代码的复杂性并降低了可读性。处理 PDF 文件时也是如此。此外，你开发的代码不会处理 Bing
    分页，只会解析初始页面的搜索结果。我们鼓励你将这一点构建到你的工作示例中，并探索 Open XML 之外的文件类型。
- en: 'Why not just use the Bing Search APIs for building this, rather than doing
    HTML scraping? Because you already know how to build clients that interact with
    structured APIs. There are practical use cases for scraping HTML pages, particularly
    when no API exists. Rather than rehashing what you already know, we’ll take this
    as an opportunity to introduce a new method of extracting data. You’ll use an
    excellent package, `goquery`, which mimics the functionality of `jQuery`, a JavaScript
    library that includes an intuitive syntax to traverse HTML documents and select
    data within. Start by installing `goquery`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接使用 Bing 搜索 API 来构建这个，而是进行 HTML 抓取呢？因为你已经知道如何构建与结构化 API 交互的客户端。抓取 HTML
    页面的实际应用场景存在，特别是在没有 API 的情况下。与其重复你已经掌握的知识，我们将借此机会介绍一种新的数据提取方法。你将使用一个优秀的包 `goquery`，它模仿了
    `jQuery` 的功能，这是一个 JavaScript 库，提供了直观的语法来遍历 HTML 文档并选择其中的数据。首先安装 `goquery`：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Fortunately, that’s the only prerequisite software needed to complete the development.
    You’ll use standard Go packages to interact with Open XML files. These files,
    despite their file type suffix, are ZIP archives that, when extracted, contain
    XML files. The metadata is stored in two files within the `docProps` directory
    of the archive:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这就是完成开发所需的唯一前提软件。你将使用标准的 Go 包与 Open XML 文件交互。尽管这些文件的文件类型后缀不同，它们实际上是 ZIP
    压缩文件，解压后包含 XML 文件。元数据存储在归档文件中的 `docProps` 目录下的两个文件中：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The *core.xml* file contains the author information as well as modification
    details. It’s structured as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*core.xml* 文件包含了作者信息以及修改细节。其结构如下：'
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `creator` ❶ and `lastModifiedBy` ❷ elements are of primary interest. These
    fields contain employee or usernames that you can use in a social-engineering
    or password-guessing campaign.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`creator` ❶ 和 `lastModifiedBy` ❷ 元素是主要关注的内容。这些字段包含员工或用户名，你可以在社交工程攻击或密码猜测活动中使用它们。'
- en: 'The *app.xml* file contains details about the application type and version
    used to create the Open XML document. Here’s its structure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*app.xml* 文件包含了创建 Open XML 文档时使用的应用类型和版本的详细信息。其结构如下：'
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You’re primarily interested in just a few of those elements: `Application`
    ❶, `Company` ❷, and `AppVersion` ❸. The version itself doesn’t obviously correlate
    to the Office version name, such as Office 2013, Office 2016, and so on, but a
    logical mapping does exist between that field and the more readable, commonly
    known alternative. The code you develop will maintain this mapping.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你主要关注的只有几个元素：`Application` ❶、`Company` ❷ 和 `AppVersion` ❸。版本本身与 Office 版本名称（如
    Office 2013、Office 2016 等）没有明显的对应关系，但该字段与更易理解的、常见的替代版本之间确实存在逻辑映射。你开发的代码将保持这个映射关系。
- en: Defining the metadata Package
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义元数据包
- en: In [Listing 3-20](ch03.xhtml#ch3list20), define the Go types that correspond
    to these XML datasets in a new package named *metadata* and put the code in a
    file named *openxml.go*—one type for each XML file you wish to parse. Then add
    a data mapping and convenience function for determining the recognizable Office
    version that corresponds to the `AppVersion`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 3-20](ch03.xhtml#ch3list20) 中，定义与这些 XML 数据集对应的 Go 类型，在一个名为 *metadata*
    的新包中，并将代码放在名为 *openxml.go* 的文件里——每个你希望解析的 XML 文件定义一个类型。然后，添加一个数据映射和便捷函数，用于确定与
    `AppVersion` 对应的可识别的 Office 版本。
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 3-20: Open XML type definition and version mapping (*[/ch-3/bing-metadata/metadata/openxml.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/metadata/openxml.go)*)*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 3-20: Open XML 类型定义与版本映射 (*[/ch-3/bing-metadata/metadata/openxml.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/metadata/openxml.go)*)*'
- en: After you define the `OfficeCoreProperty` and `OfficeAppProperty` types, define
    a map, `OfficeVersions`, that maintains a relationship of major version numbers
    to recognizable release years ❶. To use this map, define a method, `GetMajorVersion()`,
    on the `OfficeAppProperty` type ❷. The method splits the XML data’s `AppVersion`
    value to retrieve the major version number ❸, subsequently using that value and
    the `OfficeVersions` map to retrieve the release year ❹.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `OfficeCoreProperty` 和 `OfficeAppProperty` 类型后，定义一个映射 `OfficeVersions`，它维护主版本号与可识别的发布年份之间的关系
    ❶。为了使用这个映射，定义一个方法 `GetMajorVersion()`，它属于 `OfficeAppProperty` 类型 ❷。该方法将 XML 数据的
    `AppVersion` 值进行拆分，以提取主版本号 ❸，然后使用该值和 `OfficeVersions` 映射来获取发布年份 ❹。
- en: Mapping the Data to Structs
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将数据映射到结构体
- en: Now that you’ve built the logic and types to work with and inspect the XML data
    of interest, you can create the code that reads the appropriate files and assigns
    the contents to your structs. To do this, define `NewProperties()` and `process()`
    functions, as shown in [Listing 3-21](ch03.xhtml#ch3list21).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经构建了与 XML 数据交互和检查的逻辑及类型，你可以创建代码来读取相应的文件并将内容分配给你的结构体。为此，定义 `NewProperties()`
    和 `process()` 函数，如 [列表 3-21](ch03.xhtml#ch3list21) 所示。
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*Listing 3-21: Processing Open XML archives and embedded XML documents (*[/ch-3/bing-metadata/metadata/openxml.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/metadata/openxml.go)*)*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-21：处理 Open XML 存档和嵌入的 XML 文档 (*[/ch-3/bing-metadata/metadata/openxml.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/metadata/openxml.go)*)*'
- en: The `NewProperties()` function accepts a `*zip.Reader`, which represents an
    `io.Reader` for ZIP archives ❶. Using the `zip.Reader` instance, iterate through
    all the files in the archive ❷, checking the filenames ❸. If a filename matches
    one of the two property filenames, call the `process()` function ❹❺, passing in
    the file and the arbitrary structure type you wish to populate—either `OfficeCoreProperty`
    or `OfficeAppProperty`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewProperties()` 函数接受一个 `*zip.Reader`，它表示一个 `io.Reader`，用于 ZIP 存档 ❶。使用 `zip.Reader`
    实例，遍历存档中的所有文件 ❷，检查文件名 ❸。如果文件名与两个属性文件名之一匹配，调用 `process()` 函数 ❹❺，传入文件和你希望填充的任意结构类型——`OfficeCoreProperty`
    或 `OfficeAppProperty`。'
- en: 'The `process()` function accepts two parameters: a `*zip.File` and an `interface{}`
    ❻. Similar to the Metasploit tool you developed, this code accepts a generic `interface{}`
    type to allow for the file contents to be assigned into any data type. This increases
    code reuse because there’s nothing type-specific within the `process()` function.
    Within the function, the code reads the contents of the file and unmarshals the
    XML data into the struct ❼.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()` 函数接受两个参数：一个 `*zip.File` 和一个 `interface{}` ❻。与您开发的 Metasploit 工具类似，这段代码接受一个通用的
    `interface{}` 类型，以允许将文件内容分配给任何数据类型。这增加了代码的重用性，因为 `process()` 函数中没有特定类型的限制。在该函数中，代码读取文件内容并将
    XML 数据解组到结构体 ❼ 中。'
- en: Searching and Receiving Files with Bing
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Bing 搜索和接收文件。
- en: 'You now have all the code necessary to open, read, parse, and extract Office
    Open XML documents, and you know what you need to do with the file. Now, you need
    to figure out how to search for and retrieve files by using Bing. Here’s the plan
    of action you should follow:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有了打开、读取、解析并提取 Office Open XML 文档所需的所有代码，你也知道如何处理文件。接下来，你需要弄清楚如何使用 Bing 搜索和检索文件。以下是你应该遵循的行动计划：
- en: Submit a search request to Bing with proper filters to retrieve targeted results.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交一个带有适当筛选器的搜索请求到 Bing，以检索目标结果。
- en: Scrape the HTML response, extracting the HREF (link) data to obtain direct URLs
    for documents.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抓取 HTML 响应，提取 HREF（链接）数据，以获取文档的直接 URL。
- en: Submit an HTTP request for each direct document URL
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交每个直接文档 URL 的 HTTP 请求。
- en: Parse the response body to create a `zip.Reader`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析响应体以创建 `zip.Reader`。
- en: Pass the `zip.Reader` into the code you already developed to extract metadata.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `zip.Reader` 传入你已经开发的代码中，以提取元数据。
- en: The following sections discuss each of these steps in order.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分依次讨论每一个步骤。
- en: 'The first order of business is to build a search query template. Much like
    Google, Bing contains advanced query parameters that you can use to filter search
    results on numerous variables. Most of these filters are submitted in a filter_type:
    value format. Without explaining all the available filter types, let’s instead
    focus on what helps you achieve your goal. The following list contains the three
    filters you’ll need. Note that you could use additional filters, but at the time
    of this writing, they behave somewhat unpredictably.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '第一件事是构建一个搜索查询模板。像 Google 一样，Bing 包含高级查询参数，你可以用它来根据多个变量筛选搜索结果。这些筛选器大多数是以 filter_type:
    value 的格式提交的。在不解释所有可用筛选器类型的情况下，让我们关注那些有助于你实现目标的筛选器。以下列表包含了你需要的三个筛选器。请注意，你可以使用其他筛选器，但在本文写作时，它们的行为有些不可预测。'
- en: site Used to filter the results to a specific domain
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: site 用于将结果筛选到特定的域。
- en: filetype Used to filter the results based off resource file type
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: filetype 用于根据资源文件类型筛选结果。
- en: instreamset Used to filter the results to include only certain file extensions
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: instreamset 用于将结果筛选为仅包含某些文件扩展名。
- en: 'An example query to retrieve *docx* files from *[nytimes.com](http://nytimes.com)*
    would look like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 检索 *[nytimes.com](http://nytimes.com)* 上 *docx* 文件的示例查询如下：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After submitting that query, take a peek at the resulting URL in your browser.
    It should resemble [Figure 3-1](ch03.xhtml#ch3fig1). Additional parameters may
    appear after this, but they’re inconsequential for this example, so you can ignore
    them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 提交查询后，看看浏览器中生成的 URL。它应该类似于[图 3-1](ch03.xhtml#ch3fig1)。查询后可能会出现额外的参数，但对于本例来说，它们并不重要，因此可以忽略。
- en: Now that you know the URL and parameter format, you can see the HTML response,
    but first you need to determine where in the Document Object Model (DOM) the document
    links reside. You can do this by viewing the source code directly, or limit the
    guesswork and just use your browser’s developer tools. The following image shows
    the full HTML element path to the desired HREF. You can use the element inspector,
    as in [Figure 3-1](ch03.xhtml#ch3fig1), to quickly select the link to reveal its
    full path.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了 URL 和参数格式，你可以查看 HTML 响应，但首先你需要确定文档链接在文档对象模型（DOM）中的位置。你可以通过直接查看源代码来实现，或者减少猜测的工作，只需使用浏览器的开发者工具。下图展示了到达目标
    HREF 的完整 HTML 元素路径。你可以使用元素检查器，正如在[图 3-1](ch03.xhtml#ch3fig1)中所示，快速选择链接以显示其完整路径。
- en: '![Image](Images/03fig01.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/03fig01.jpg)'
- en: '*Figure 3-1: A browser developer tool showing the full element path*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：浏览器开发者工具显示完整的元素路径*'
- en: 'With that path information, you can use `goquery` to systematically pull all
    data elements that match an HTML path. Enough talk! [Listing 3-22](ch03.xhtml#ch3list22)
    puts it all together: retrieving, scraping, parsing, and extracting. Save this
    code to *main.go*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些路径信息，你可以使用`goquery`系统地提取所有匹配 HTML 路径的数据元素。说得够多了！[清单 3-22](ch03.xhtml#ch3list22)将一切整合在一起：获取、抓取、解析和提取。将这段代码保存到*main.go*。
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 3-22: Scraping Bing results and parsing document metadata (*[/ch-3/bing-metadata/client/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/client/main.go)*)*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-22：抓取 Bing 结果并解析文档元数据（*[/ch-3/bing-metadata/client/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-3/bing-metadata/client/main.go)）*'
- en: You create two functions. The first, `handler()`, accepts a `goquery.Selection`
    instance ❶ (in this case, it will be populated with an anchor HTML element) and
    finds and extracts the `href` attribute ❷. This attribute contains a direct link
    to the document returned from the Bing search. Using that URL, the code then issues
    a GET request to retrieve the document ❸. Assuming no errors occur, you then read
    the response body ❹, leveraging it to create a `zip.Reader` ❺. Recall that the
    function you created earlier in your `metadata` package, `NewProperties()`, expects
    a `zip.Reader`. Now that you have the appropriate data type, pass it to that function
    ❻, and properties are populated from the file and printed to your screen.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了两个函数。第一个，`handler()`，接受一个`goquery.Selection`实例❶（在本例中，它将填充一个锚点 HTML 元素）并找到并提取`href`属性❷。该属性包含一个指向从
    Bing 搜索返回的文档的直接链接。利用该 URL，代码接着发出 GET 请求以获取文档❸。假设没有发生错误，你会读取响应体❹，并利用它创建一个`zip.Reader`❺。回想一下，你之前在`metadata`包中创建的函数`NewProperties()`需要一个`zip.Reader`。现在你有了适当的数据类型，将它传递给该函数❻，属性将从文件中填充并打印到屏幕上。
- en: The `main()` function bootstraps and controls the whole process; you pass it
    the domain and file type as command line arguments. The function then uses this
    input data to build the Bing query with the appropriate filters ❼. The filter
    string is encoded and used to build the full Bing search URL ❽. The search request
    is sent using the `goquery.NewDocument()` function, which implicitly makes an
    HTTP GET request and returns a `goquery`-friendly representation of the HTML response
    document ❾. This document can be inspected with `goquery`. Finally, use the HTML
    element selector string you identified with your browser developer tools to find
    and iterate over matching HTML elements ❿. For each matching element, a call is
    made to your `handler()` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数引导并控制整个过程；你将域名和文件类型作为命令行参数传递给它。然后，函数使用这些输入数据构建带有适当过滤器的 Bing 查询❼。过滤器字符串被编码，并用于构建完整的
    Bing 搜索 URL❽。使用`goquery.NewDocument()`函数发送搜索请求，该函数隐式发出 HTTP GET 请求并返回一个`goquery`友好的
    HTML 响应文档❾。可以使用`goquery`检查此文档。最后，使用通过浏览器开发者工具确定的 HTML 元素选择器字符串，查找并遍历匹配的 HTML 元素❿。对于每个匹配的元素，都会调用你的`handler()`函数。'
- en: 'A sample run of the code produces output similar to the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的示例运行会产生类似于以下的输出：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can now search for and extract document metadata for all Open XML files
    while targeting a specific domain. I encourage you to expand on this example to
    include logic to navigate multipage Bing search results, to include other file
    types beyond Open XML, and to enhance the code to concurrently download the identified
    files.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以搜索并提取所有 Open XML 文件的文档元数据，同时可以针对特定域进行操作。我鼓励您在此示例的基础上进行扩展，加入逻辑以便导航多页 Bing
    搜索结果，支持更多文件类型（不仅限于 Open XML），并提升代码以并发下载识别出的文件。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced to you fundamental HTTP concepts in Go, which you used
    to create usable tools that interacted with remote APIs, as well as to scrape
    arbitrary HTML data. In the next chapter, you’ll continue with the HTTP theme
    by learning to create servers rather than clients.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Go 中的基本 HTTP 概念，您可以利用这些概念创建与远程 API 交互的实用工具，以及抓取任意 HTML 数据。在下一章中，您将继续学习
    HTTP 主题，重点转向创建服务器，而非客户端。
