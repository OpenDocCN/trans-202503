<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_469" aria-label="469"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch18">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">18</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">IMMUTABILITY AND FUNCTIONAL DATA STRUCTURES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">We’ve now considered several abstract data types (ADTs), data structures, and algorithms. Let’s finish the book by considering an aspect that’s not only relevant to functional programming but also to the everyday usage of libraries such as Redux for React web page developers. How do we work with data structures and not make changes to them, but instead produce new ones, in a true functional style? To do this, we’ll need to consider a new concept: <i>persistent</i> (or <i>functional</i>) <i>data structures</i> that we can update without needing to clone everything for high performance and that also allow us to view the “history” of previous states and roll back changes if needed.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_470" aria-label="470"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-99"/><span class="SANS_Futura_Std_Bold_B_11">Functional Data Structures</span></h3>&#13;
<p class="TNI1">Let’s start with a couple of definitions. <i>Persistent data structures</i> have the interesting property that you can update them while keeping previous versions intact, without changes. This property automatically implies that these structures are ideal for purely functional programming languages, which do not allow for side effects, as mentioned in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>. It means they are also <i>functional data structures</i>: if you don’t modify a data structure but produce a new one instead, you’ll have both the previous and the new versions available.</p>&#13;
<p class="TX">Let’s analyze several data structures, most of which we already covered in the book, to see whether we can make them functional.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-187"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Arrays (and Hash Tables)</span></h4>&#13;
<p class="TNI1">We’ll start with bad news first. Arrays are essentially mutable data structures, and there’s no simple way to implement a functional equivalent with the same level of performance, which is namely <i>O</i>(1) for accessing and updating array elements. Arrays support destructive updates, and such updates can’t be reversed. Once you modify some position in an array, there’s no way to retrieve the previous value. Arrays are the opposite of a persistent data structure, in fact.</p>&#13;
<p class="TX">To get around this limitation, a common technique is to use a balanced binary search tree, with indices as keys, but doing so requires <i>O</i>(log <i>n</i>) time instead. Other far more complex techniques have been explored, but the performance is still not the same as for straightforward arrays. If you’d like to learn more about it, do an online search for Melissa O’Neill and F. Warren Burton’s method (it won’t be an easy read).</p>&#13;
<p class="TX">A related conclusion from this result for arrays is that you won’t have a good equivalent for hash tables, or their many variants, making them another structure that you’ll have to replace with a potentially slower one.</p>&#13;
<p class="TX">This beginning of our study of functional data structures may seem depressing, but rest assured that we’ll be able to find equivalences for many of the structures previously considered in this book.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-188"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Functional Lists</span></h4>&#13;
<p class="TNI1">Now consider the simplest structure, linked lists, from <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. Some types of lists are quite amenable to the functional style of work. Others (like queues) require a “conversion” to make them functional, and some lists have no functional equivalent.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h5 class="H3" id="sec4"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Common Lists</span></h5>&#13;
<p class="TNI1">When we defined lists (see the section “<span class="Xref">Basic Lists</span>” on page <span class="Xref">178</span>), given a position, you wanted to be able to either add a new value at that spot or remove whatever was there. Consider the first operation. You can achieve that by replicating the initial part of the list. <a href="chapter18.xhtml#fig18-1">Figure 18-1</a> shows a list you looked at in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, and then the same list where you add an 80 value <span role="doc-pagebreak" epub:type="pagebreak" id="pg_471" aria-label="471"/>at position 3. (Remember, position 0 is first, as with arrays.) The operation involves adding a node and modifying a pointer in an already existing node.</p>&#13;
<figure class="IMG"><img class="img7" id="fig18-1" src="../images/Figure18-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-1: Inserting a node in a list requires that you change an original node, namely the one pointing to the new node.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">With functional structures in mind, <a href="chapter18.xhtml#fig18-2">Figure 18-2</a> shows the way to do it.</p>&#13;
<figure class="IMG"><img class="img7" id="fig18-2" src="../images/Figure18-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-2: Doing an insertion functionally replicates some nodes but leaves the original ones unchanged.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In addition to the new node with the 80 value, you have some nodes that duplicate values in the previous list, but you keep part of the list unchanged. You didn’t have to redo the whole list. New nodes and links have bolder lines, and discarded nodes are shown in faded gray.</p>&#13;
<p class="TX">The code to work in this way uses recursion:</p>&#13;
<pre id="pre-356"><code>const isEmpty = (list) =&gt; list === null;&#13;
&#13;
const add = (list, position, value) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list) || position === 0) {&#13;
   return {value, next: list};&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else {&#13;
   return {value: list.value, next: add(list.next, position - 1, value)};&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If adding an element at the first position <span class="CodeAnnotation" aria-label="annotation1">❶</span>, return a node that has the new value and points to the previous list. This also works if the list was originally empty. Otherwise, when the list isn’t empty and you want to add the value at a position other than zero, create a new node <span class="CodeAnnotation" aria-label="annotation2">❷</span> with the same value at the head of the list and a link to the result of adding the new value to the tail of the original list.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_472" aria-label="472"/>Now, consider removing elements from a list. Going back to the initial list, say you want to remove the 60 at position 2. <a href="chapter18.xhtml#fig18-3">Figure 18-3</a> shows the before and after lists.</p>&#13;
<figure class="IMG"><img class="img7" id="fig18-3" src="../images/Figure18-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-3: Removing a node from a list also implies modifying some original node.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To work in a functional way, replicate the initial part of the list, as shown in <a href="chapter18.xhtml#fig18-4">Figure 18-4</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig18-4" src="../images/Figure18-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-4: The same kind of solution used for insertions helps deal with deletions in a functional way.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As with list additions, some nodes (in faded gray) are no longer included. Part of the list is formed by new nodes (with bold lines), and part of the list remains as it was, without re-creating the whole structure. Consider the following implementation:</p>&#13;
<pre id="pre-357"><code>const remove = (list, position) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(list)) {&#13;
   return list;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (position === 0) {&#13;
   return list.next;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   return {value: list.value, next: remove(list.next, position - 1)};&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">Using recursion makes the logic clear. If you want to remove an element from an empty list <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you can’t do anything; return the null list as is. If the list isn’t empty and you want to remove its first element <span class="CodeAnnotation" aria-label="annotation2">❷</span>, the new list is the one that starts with the element just after the first. Finally, if the list is not empty and you want to remove some element other than the first one, construct a new list <span class="CodeAnnotation" aria-label="annotation3">❸</span> that has the same value as the head of the list and points to the result of removing the value from the rest of the list.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_473" aria-label="473"/>As for performance, we again find that all operations are <i>O</i>(<i>n</i>), although the additional creation of nodes probably implies a slower implementation. Also, given that we still have plain lists, other methods that we saw earlier (like finding the value at a position or calculating the list’s size) work exactly as before. In order to implement a functional version of common linked lists, you just had to change the two methods that actually modify the list.</p>&#13;
<p class="TX">Let’s move on to more specialized versions of lists used for other ADTs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Stacks</span></h5>&#13;
<p class="TNI1">The first variation of lists that we considered were stacks, which have the restriction that all additions (“pushes”) and removals (“pops”) occur at an extremity of the list, at its “top.” It will be a nice surprise to realize that our earlier implementation already made a functional data structure. Review the diagrams from <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. When pushing a value, you had the situation shown in <a href="chapter18.xhtml#fig18-5">Figure 18-5</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-5" src="../images/Figure18-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-5: Stacks already do pushes in functional ways ...</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The updated stack shares most of the structure; the only difference is the new top element. Popping the top value has a similar behavior, as shown in <a href="chapter18.xhtml#fig18-6">Figure 18-6</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_474" aria-label="474"/>&#13;
<figure class="IMG"><img class="img5" id="fig18-6" src="../images/Figure18-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-6: ... and that also goes for pops.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As with pushing, you updated the stack without modifying any values or pointers in it. The original implementation already was fully functional. The performance of both operations is still <i>O</i>(1), so it can’t be enhanced. However, we won’t always be so lucky.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Queues</span></h5>&#13;
<p class="TNI1">Queues pose a challenge. They also restrict operations to the extremities of a list: you <i>enqueued</i> (entered) values at one extreme (the “back” of the queue) and <i>dequeued</i> (exited) them from the other extreme (the “front” of the queue). You also used a linked list as the basis for the queue, as shown in <a href="chapter18.xhtml#fig18-7">Figure 18-7</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig18-7" src="../images/Figure18-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-7: You can dequeue a node functionally, the same way you pop a stack.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Dequeueing the front element (22) is exactly the same as popping a value from a stack, so that would work. The updated queue would just have its front element removed, and its first element now becomes what originally was the second (09).</p>&#13;
<p class="TX">However, enqueueing a new value in this example causes a problem. You have to modify the node with the 56, and that requires modifying the node with the 04, and so on, so you end up creating a whole copy of the queue. (This would be equivalent to adding a value at the end of a simple list, as described earlier in the section “<span class="Xref">Common Lists”</span> on <span class="Xref"><a href="chapter18.xhtml#pg_470">page 470</a></span>.) Can we do better? The answer is yes, but we’ll need an ingenious trick: use a pair of stacks to represent a queue.</p>&#13;
<p class="TX">Consider how a queue with five values, A (first) through E (last), might look at a certain moment, as shown in <a href="chapter18.xhtml#fig18-8">Figure 18-8</a>. (See also question 18.1.)</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_475" aria-label="475"/>&#13;
<figure class="IMG"><img class="img5" id="fig18-8" src="../images/Figure18-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-8: You can do functional queues, but you’ll need two stacks for that: “back” and “front.”</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The queue is split in two stacks. Consider how you could have gotten here. You enter the queue by pushing into the “back” of the stack and exit by popping the “front” stack. For example, if F were to enter the queue, you’d get the situation shown in <a href="chapter18.xhtml#fig18-9">Figure 18-9</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-9" src="../images/Figure18-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-9: New nodes are queued by pushing them to the “back” stack.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can push into a stack functionally, as you saw previously, so everything’s fine. If a value were to leave the queue, you’d pop it and get the status shown in <a href="chapter18.xhtml#fig18-10">Figure 18-10</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-10" src="../images/Figure18-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-10: Dequeueing a node means popping from the “front” stack, so that’s also functional.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_476" aria-label="476"/>Popping a stack is also done functionally, so everything is still fine. After doing another exit, you’d have the situation in <a href="chapter18.xhtml#fig18-11">Figure 18-11</a>, and there’s the problem—the front stack is empty.</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-11" src="../images/Figure18-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-11: How do you dequeue a node if the “front” stack is empty?</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">How would we handle the next exit, now that the front stack is empty? The key to this representation for queues is as follows: if you need to exit the queue and the front queue is empty, pop all the values off the back queue and push them into the front queue (see <a href="chapter18.xhtml#fig18-12">Figure 18-12</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-12" src="../images/Figure18-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-12: Pop everything from the “back” stack onto the “front” stack.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After this procedure (which reverses the back stack), you’ll be able to keep exiting the queue, and all operations will be done in the correct order. It seems like a bit of trickery, but it works, and since all of the involved operations are done in a functional way, the result is a functional data structure for representing queues.</p>&#13;
<p class="TX">We’re representing queues with two stacks, so the basic methods to build a queue and check whether it’s empty are as follows:</p>&#13;
<pre id="pre-358"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const newQueue = () =&gt; ({backPart: null, frontPart: null});&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> const isEmpty = (queue) =&gt;&#13;
  queue.backPart === null &amp;&amp; queue.frontPart === null;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_477" aria-label="477"/>A new queue <span class="CodeAnnotation" aria-label="annotation1">❶</span> consists of two empty stacks, and testing whether it’s empty <span class="CodeAnnotation" aria-label="annotation2">❷</span> simply requires verifying whether the two tops of the stack are null.</p>&#13;
<p class="TX">You can enter a new value at the back end of the queue by pushing into that list, which you already know how to do:</p>&#13;
<pre id="pre-359"><code>const enter = (queue, value) =&gt; ({&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> backPart: {value, next: queue.backPart},&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> frontPart: queue.frontPart&#13;
});</code></pre>&#13;
<p class="TX">You return a new queue, with the new value pushed onto the back end of the stack <span class="CodeAnnotation" aria-label="annotation1">❶</span> and an unchanged frontend <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Things get a bit more hairy when exiting the queue. As described, if the front part isn’t empty, just pop its first element, but if the list is empty, push the whole back part, element by element, into the front:</p>&#13;
<pre id="pre-360"><code>const exit = (queue) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation1">❶</span> if (isEmpty(queue)) {&#13;
    return queue;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span>} else {&#13;
    let newfrontPart = queue.frontPart;&#13;
    let oldbackPart = queue.backPart;&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span> if (newfrontPart === null) {&#13;
    <span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span> while (oldbackPart !== null) {&#13;
        newfrontPart = {value: oldbackPart.value, next: newfrontPart};&#13;
        oldbackPart = oldbackPart.next;&#13;
      }&#13;
    }&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span> return {backPart: oldbackPart, frontPart: newfrontPart.next};&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">Start by checking whether the queue is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, because in that case there’s nothing to do; you’ll return the very same unchanged queue. If it’s not empty <span class="CodeAnnotation" aria-label="annotation2">❷</span>, check whether the front stack is empty. If it is <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you need to do a loop <span class="CodeAnnotation" aria-label="annotation4">❹</span>, popping values from the back stack and pushing them onto the front stack. At the end, now knowing that the frontend isn’t empty <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you just return a new queue with the (possibly emptied) back part and the result of popping the top element off the front part.</p>&#13;
<p class="TX">How’s the performance of this stack-based queue? Entering the queue is always <i>O</i>(1), but exiting the queue may be either <i>O</i>(1) or <i>O</i>(<i>n</i>). However, in amortized terms, you can see that each item will be pushed once (at the back), popped once (from the back), pushed once again (at the front), and eventually popped once again (from the front), which are four constant-time operations. Over the history of many operations, the amortized performance is <i>O</i>(1), because each value will pass through four <i>O</i>(1) operations. The <i>O</i>(<i>n</i>) cost of popping from the back and pushing to the front is “diluted” because after once pushing <i>n</i> values to an empty front, the next <i>n</i> exits will be <i>O</i>(1). The final average is <i>O</i>(1).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_478" aria-label="478"/>There was an extra operation, <span class="SANS_TheSansMonoCd_W5Regular_11">front(...)</span>, to access the value at the front of the queue; see question 18.2.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Other Lists</span></h5>&#13;
<p class="TNI1">We’ve considered several kinds of lists, but what about the rest? We’ll have no functional equivalent for deques (or, more generally, doubly linked lists) or circular lists because modifying a single node implies that at least one other node must be modified, and that again implies other nodes must change, and so on. Trying to update those structures in a functional way ends with creating a complete copy, which isn’t very efficient.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-189"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Functional Trees</span></h4>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter12.xhtml">Chapters 12</a></span> through <span class="Xref"><a href="chapter16.xhtml">16</a></span> we explored varieties of trees: binary search trees, general trees, heaps of several styles, and so on. Some of these (not all, alas) allow for working in functional ways.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Binary Search Trees</span></h5>&#13;
<p class="TNI1">How can we manage to make binary search trees behave in a functional way? In general, we apply the exact same type of solution that we used for lists and create some new nodes wherever necessary. Start by considering how to add a new value to a tree from <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> (see <a href="chapter18.xhtml#fig18-13">Figure 18-13</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-13" src="../images/Figure18-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-13: A binary search tree that you want to maintain in a functional way</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> you added a new 34 value, which became the right child of the 24 node. You can do the same here without modifying the existing tree. The solution lies in adding a few new nodes, as shown in <a href="chapter18.xhtml#fig18-14">Figure 18-14</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-14" src="../images/Figure18-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-14: Adding a new value implies creating a few new nodes.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There’s a new root, and you also have new nodes all the way to the added node itself, but otherwise, the rest of the tree remains the same. There also are some nodes (shown in gray) that are no longer part of the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_479" aria-label="479"/>tree, as they were duplicated by new ones. Accessing the tree through its new root, you find the newly added 34 value, whereas accessing the tree through its old root results in the very same structure as before. You’ve managed to create a new tree, with the additional value, but without modifying the original structure.</p>&#13;
<p class="TX">Adding a new value in this functional way requires little code:</p>&#13;
<pre id="pre-361"><code>const add = (tree, keyToAdd) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   return newNode(keyToAdd);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (keyToAdd &lt;= tree.key) {&#13;
   return newNode(tree.key, add(tree.left, keyToAdd), tree.right);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   return newNode(tree.key, tree.left, add(tree.right, keyToAdd));&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">If you want to add a value to an empty tree <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you just need a new node with the value. (As a reminder, see the following <span class="SANS_TheSansMonoCd_W5Regular_11">newNode(...)</span> function.) If you want to add a key that goes in the left subtree <span class="CodeAnnotation" aria-label="annotation2">❷</span>, return a new tree that has the same value as the current root, a recursively updated left subtree, and the same right subtree as before. If the new value has to go into the right subtree <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the result is similar: you’ll return a new tree with the same value and the same left subtree as the current node and an updated right subtree:</p>&#13;
<pre id="pre-362"><code>const newNode = (key, left = null, right = null) =&gt; ({key, left, right});</code></pre>&#13;
<p class="TX">Now, you’ll turn to removing nodes and consider the most complex case: removing a node that has two children (you can work out the simpler cases). <a href="chapter18.xhtml#fig18-15">Figure 18-15</a> shows the original tree (the same one used to show adding a node).</p>&#13;
<figure class="IMG"><img class="img5" id="fig18-15" src="../images/Figure18-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-15: Removing a node is a bit trickier if a node (such as 9) has two children.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To remove node 9, you have to find the next greater key (10, in this case) and change its place. It needs to be removed from its current position and take the place of the 9. Working in functional terms, you again create some new nodes, as shown in <a href="chapter18.xhtml#fig18-16">Figure 18-16</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_480" aria-label="480"/>&#13;
<figure class="IMG"><img class="img5" id="fig18-16" src="../images/Figure18-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-16: Removing a node with two children requires re-creating nodes from the root.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You have a new root, and you also re-created nodes in the path to the node that you eliminate. To remove the 10 from its tree, you also applied a functional method, so in that subtree (the one with root 11), you had to create some new nodes too. The code for removing nodes has several cases:</p>&#13;
<pre id="pre-363"><code>const remove = (tree, keyToRemove) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (isEmpty(tree)) {&#13;
   return tree;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (keyToRemove &lt; tree.key) {&#13;
   return newNode(tree.key, remove(tree.left, keyToRemove), tree.right);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else if (keyToRemove &gt; tree.key) {&#13;
   return newNode(tree.key, tree.left, remove(tree.right, keyToRemove));&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (isEmpty(tree.left) &amp;&amp; isEmpty(tree.right)) {&#13;
   return null;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>} else if (isEmpty(tree.left)) {&#13;
   return tree.right;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span>} else if (isEmpty(tree.right)) {&#13;
   return tree.left;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span>} else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> const rightMin = minKey(tree.right);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation9">❾</span> return newNode(rightMin, tree.left, remove(tree.right, rightMin));&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The code tightly parallels what you saw in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, but you always return new trees instead of modifying nodes. If the tree is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>, return it as is. If the value to remove is less than the current node’s value <span class="CodeAnnotation" aria-label="annotation2">❷</span>, return a new tree with the node’s value and right child, but with its left child pointing at a new tree, which is the result of deleting the value in the left subtree. Similarly, if the value to remove is greater than the current node’s value <span class="CodeAnnotation" aria-label="annotation3">❸</span>, proceed symmetrically: return a new tree with the node’s value and left child, but with a right child pointing at the result of deleting the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_481" aria-label="481"/>value in the right subtree. When you’ve found the node to delete and it’s a leaf <span class="CodeAnnotation" aria-label="annotation4">❹</span>, just return an empty tree. If it isn’t a leaf but it has only one child (if a right child <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and if a left one <span class="CodeAnnotation" aria-label="annotation6">❻</span>), return a tree that consists of only the nonempty child, omitting the removed node. Finally, in the most difficult case, if you have to remove a node with two non-null subtrees <span class="CodeAnnotation" aria-label="annotation7">❼</span>, find the minimum value in its right subtree <span class="CodeAnnotation" aria-label="annotation8">❽</span> and return a tree built with that value at the root, the original node’s left subtree on the left, and the result of removing the minimum value from the original node’s right subtree on the right <span class="CodeAnnotation" aria-label="annotation9">❾</span>.</p>&#13;
<p class="TX">You have already seen an implementation of <span class="SANS_TheSansMonoCd_W5Regular_11">minKey(...)</span>, the function that finds the minimum value in a binary search tree, but consider a new version, just for the sake of variety (plus a one-liner is hard to resist):</p>&#13;
<pre id="pre-364"><code>const minKey = (tree) =&gt; (isEmpty(tree.left) ? tree.key : minKey(tree.left));</code></pre>&#13;
<p class="TX">For all the varieties of trees that we’ve seen (AVL trees, red-black trees, splay trees, and so on), you can apply some variant of the methods shown in the previous removal code. After adding or removing a key, the new tree will end with a new root and several new nodes, but many parts of it remain the same, with no changes. The order of the performance of the processes will also be the same as before, so at the cost of some added complexity, we can have functional versions of all those trees.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Other Trees</span></h5>&#13;
<p class="TNI1">We also considered other kinds of trees; in particular, <span class="Xref"><a href="chapter14.xhtml">Chapters 14</a></span> and <span class="Xref"><a href="chapter15.xhtml">15</a></span> were devoted to heaps, which are basically binary trees or variations thereof. A simple version was built upon arrays, so we’re stuck there with no easy solution. For other heaps (treaps, skew heaps, Fibonacci heaps, and so on) that are based on dynamic memory using pointers, we can apply the same kind of solution as for objects and binary trees.</p>&#13;
<p class="TX">What about digital trees, including tries, object-based tries, radix trees, and ternary trees? Tries had arrays in each node, with pointers to all the children of the node, but in essence, it’s the same as binary trees having two pointers. The same kind of solution we saw for binary trees will work, and when updating a trie, you’ll end with a new structure that has some new nodes but shares most of the previous ones. <a href="chapter18.xhtml#fig18-17">Figure 18-17</a> shows this solution with a trie that you saw in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_482" aria-label="482"/>&#13;
<figure class="IMG"><img class="img1" id="fig18-17" src="../images/Figure18-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-17: You can also maintain a trie in a functional way.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>, we showed how the trie would be modified if we added an ABE word. Working functionally, you’d have a new root and some new nodes elsewhere. <a href="chapter18.xhtml#fig18-18">Figure 18-18</a> shows the result.</p>&#13;
<p class="TX">You have a new root, a couple of new nodes (with a darker border), and some new links, but most of the structure is still as before. Two old nodes (in gray) are no longer part of it, in the same way as with binary trees, but that’s it. The basic procedure is the same, and it also works for radix trees and ternary trees, but you won’t see it here. It’s always the same kind of solution.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_483" aria-label="483"/>&#13;
<figure class="IMG"><img class="img1" id="fig18-18" src="../images/Figure18-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-18: Adding a new word requires creating some new nodes, but it keeps most of the trie unchanged.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Finally, for object-based tries that were based on JavaScript objects, you can simply apply the same ideas that were described for lists and trees earlier in this chapter. In <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> you considered an example of an object-based trie; <a href="chapter18.xhtml#fig18-19">Figure 18-19</a> revisits it.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_484" aria-label="484"/>&#13;
<figure class="IMG"><img class="img1" id="fig18-19" src="../images/Figure18-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-19: You can also update an object-based trie in a functional way.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> we saw, among other examples, how to add the word ABE to the trie. You did this by modifying several objects; now you’ll do it functionally by adding a few new ones and keeping most of the old structure unchanged, as shown in <a href="chapter18.xhtml#fig18-20">Figure 18-20</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig18-20" src="../images/Figure18-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 18-20: Adding a new word and re-creating some objects</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As with the previous trie example, new nodes have darker borders, and borders of the dropped nodes are a lighter gray. Most of the trie didn’t need to change at all. Thus, you’re able to implement several varieties (although not all) of heaps and all sorts of digital trees by varying the update algorithms a bit, but always along the same lines that we already applied.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_485" aria-label="485"/>&#13;
<h3 class="H1" id="sec11"><span id="h1-100"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter, we’ve finished our overview of data structures and algorithms by considering functional data structures, which may be updated without side effects and produce new versions in an efficient way.</p>&#13;
<p class="TX">Working with functional data structures represents a possibly difficult balance. On one hand, there are advantages in terms of clarity and maintainability, because it’s clear when and where data structures are changed. On the other hand, however, we may find some operations that originally had great performance are now replaced by slower ones.</p>&#13;
<p class="TX">Is there a way to avoid those problems? Unfortunately, not easily. As mentioned previously, the aim is to apply functional programming in a pragmatic way, so we’ll use functional data structures when possible but accept “common” modifiable structures when needed. For instance, working with arrays is quite often necessary, and a lower-performing solution could have a great impact on performance. You must be flexible and know when and what to choose.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h1-101"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>18.1  Getting Here</b></p>&#13;
<p class="ListPlainFirst">What’s the minimum sequence of operations entering and exiting the queue that would produce the diagram shown in <a href="chapter18.xhtml#fig18-7">Figure 18-7</a>?</p>&#13;
<p class="ListHead"><b>18.2  With Apologies to Abbott and Costello, Who’s on Front?</b></p>&#13;
<p class="ListPlainFirst">Can you implement the <span class="SANS_TheSansMonoCd_W5Regular_11">front(q)</span> method that will produce the front value of a functional-style <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> queue?</p>&#13;
<p class="ListHead"><b>18.3  No Change Needed</b></p>&#13;
<p class="ListPlainFirst">When removing a key from a binary search tree, the algorithm will produce a new tree even if the required key didn’t exist. Can you modify it so that it returns the original unchanged tree in that case?</p>&#13;
<p class="ListHead"><b>18.4  A New Minimum</b></p>&#13;
<p class="ListPlainFirst">Can you explain how the new version of <span class="SANS_TheSansMonoCd_W5Regular_11">minKey(...)</span> in the section “<span class="listplain_Xref">Binary Search Trees</span>” on page <span class="listplain_Xref">478</span> works?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>