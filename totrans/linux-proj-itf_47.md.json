["```\n$ `./svsem_demo 0`\nSemaphore ID = 98307                    *ID of new semaphore set*\n```", "```\n$ `./svsem_demo 98307 -2 &`\n23338: about to semop at  10:19:42\n[1] 23338\n```", "```\n$ `./svsem_demo 98307 +3`\n23339: about to semop at  10:19:55\n23339: semop completed at 10:19:55\n23338: semop completed at 10:19:55\n[1]+  Done              ./svsem_demo 98307 -2\n```", "```\n`svsem/svsem_demo.c`\n#include <sys/types.h>\n#include <sys/sem.h>\n#include <sys/stat.h>\n#include \"curr_time.h\"                  /* Declaration of currTime() */\n#include \"semun.h\"                      /* Definition of semun union */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int semid;\n\n    if (argc < 2 || argc > 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s init-value\\n\"\n                 \"   or: %s semid operation\\n\", argv[0], argv[0]);\n\n    if (argc == 2) {            /* Create and initialize semaphore */\n        union semun arg;\n\n        semid = semget(IPC_PRIVATE, 1, S_IRUSR | S_IWUSR);\n        if (semid == -1)\n            errExit(\"semid\");\n\n        arg.val = getInt(argv[1], 0, \"init-value\");\n        if (semctl(semid, /* semnum= */ 0, SETVAL, arg) == -1)\n            errExit(\"semctl\");\n\n        printf(\"Semaphore ID = %d\\n\", semid);\n\n    } else {                    /* Perform an operation on first semaphore */\n\n        struct sembuf sop;              /* Structure defining operation */\n\n        semid = getInt(argv[1], 0, \"semid\");\n\n        sop.sem_num = 0;                /* Specifies first semaphore in set */\n        sop.sem_op = getInt(argv[2], 0, \"operation\");\n                                        /* Add, subtract, or wait for 0 */\n        sop.sem_flg = 0;                /* No special options for operation */\n\n        printf(\"%ld: about to semop at  %s\\n\", (long) getpid(), currTime(\"%T\"));\n        if (semop(semid, &sop, 1) == -1)\n            errExit(\"semop\");\n\n        printf(\"%ld: semop completed at %s\\n\", (long) getpid(), currTime(\"%T\"));\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `svsem/svsem_demo.c`\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/sem.h>\n\nint `semget`(key_t *key*, int *nsems*, int *semflg*);\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/sem.h>\n\nint `semctl`(int *semid*, int *semnum*, int *cmd*, ... /* union semun *arg* */);\n```", "```\n`svsem/semun.h`\n#ifndef SEMUN_H\n#define SEMUN_H                 /* Prevent accidental double inclusion */\n\n#include <sys/types.h>          /* For portability */\n#include <sys/sem.h>\n\nunion semun {                   /* Used in calls to semctl() */\n    int                 val;\n    struct semid_ds *   buf;\n    unsigned short *    array;\n#if defined(__linux__)\n    struct seminfo *    __buf;\n#endif\n};\n\n#endif\n      `svsem/semun.h`\n```", "```\nint semctl(int semid, int semnum, int cmd, union semun arg);\n```", "```\nstruct semid_ds {\n    struct ipc_perm sem_perm;       /* Ownership and permissions */\n    time_t          sem_otime;      /* Time of last semop() */\n    time_t          sem_ctime;      /* Time of last change */\n    unsigned long   sem_nsems;      /* Number of semaphores in set */\n};\n```", "```\n`svsem/svsem_mon.c`\n#include <sys/types.h>\n#include <sys/sem.h>\n#include <time.h>\n#include \"semun.h\"                      /* Definition of semun union */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct semid_ds ds;\n    union semun arg, dummy;             /* Fourth argument for semctl() */\n    int semid, j;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s semid\\n\", argv[0]);\n\n    semid = getInt(argv[1], 0, \"semid\");\n\n    arg.buf = &ds;\n    if (semctl(semid, 0, IPC_STAT, arg) == -1)\n        errExit(\"semctl\");\n\n    printf(\"Semaphore changed: %s\", ctime(&ds.sem_ctime));\n    printf(\"Last semop():      %s\", ctime(&ds.sem_otime));\n\n    /* Display per-semaphore information */\n\n    arg.array = calloc(ds.sem_nsems, sizeof(arg.array[0]));\n    if (arg.array == NULL)\n        errExit(\"calloc\");\n    if (semctl(semid, 0, GETALL, arg) == -1)\n        errExit(\"semctl-GETALL\");\n\n    printf(\"Sem #  Value  SEMPID  SEMNCNT  SEMZCNT\\n\");\n\n    for (j = 0; j < ds.sem_nsems; j++)\n        printf(\"%3d   %5d   %5d  %5d    %5d\\n\", j, arg.array[j],\n                semctl(semid, j, GETPID, dummy),\n                semctl(semid, j, GETNCNT, dummy),\n                semctl(semid, j, GETZCNT, dummy));\n\n    exit(EXIT_SUCCESS);\n}\n      `svsem/svsem_mon.c`\n```", "```\n`svsem/svsem_setall.c`\n#include <sys/types.h>\n#include <sys/sem.h>\n#include \"semun.h\"                      /* Definition of semun union */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct semid_ds ds;\n    union semun arg;                    /* Fourth argument for semctl() */\n    int j, semid;\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s semid val...\\n\", argv[0]);\n\n    semid = getInt(argv[1], 0, \"semid\");\n\n    /* Obtain size of semaphore set */\n\n    arg.buf = &ds;\n    if (semctl(semid, 0, IPC_STAT, arg) == -1)\n        errExit(\"semctl\");\n\n    if (ds.sem_nsems != argc - 2)\n        cmdLineErr(\"Set contains %ld semaphores, but %d values were supplied\\n\",\n                (long) ds.sem_nsems, argc - 2);\n\n    /* Set up array of values; perform semaphore initialization */\n\n    arg.array = calloc(ds.sem_nsems, sizeof(arg.array[0]));\n    if (arg.array == NULL)\n        errExit(\"calloc\");\n\n    for (j = 2; j < argc; j++)\n        arg.array[j - 2] = getInt(argv[j], 0, \"val\");\n\n    if (semctl(semid, 0, SETALL, arg) == -1)\n        errExit(\"semctl-SETALL\");\n    printf(\"Semaphore values changed (PID=%ld)\\n\", (long) getpid());\n\n    exit(EXIT_SUCCESS);\n}\n     `svsem/svsem_setall.c`\n```", "```\n*from* `svsem/svsem_bad_init.c`\n    /* Create a set containing 1 semaphore */\n\n    semid = semget(key, 1, IPC_CREAT | IPC_EXCL | perms);\n\n    if (semid != -1) {                  /* Successfully created the semaphore */\n        union semun arg;\n\n        /* XXXX */\n\n        arg.val = 0;                    /* Initialize semaphore */\n        if (semctl(semid, 0, SETVAL, arg) == -1)\n            errExit(\"semctl\");\n\n    } else {                            /* We didn't create the semaphore */\n        if (errno != EEXIST) {          /* Unexpected error from semget() */\n            errExit(\"semget\");\n\n        semid = semget(key, 1, perms);  /* Retrieve ID of existing set */\n        if (semid == -1)\n           errExit(\"semget\");\n    }\n\n    /* Now perform some operation on the semaphore */\n\n    sops[0].sem_op = 1;                 /* Add 1... */\n    sops[0].sem_num = 0;                /* to semaphore 0 */\n    sops[0].sem_flg = 0;\n    if (semop(semid, sops, 1) == -1)\n        errExit(\"semop\");\n      *from* `svsem/svsem_bad_init.c`\n```", "```\n*from* `svsem/svsem_good_init.c`\n    semid = semget(key, 1, IPC_CREAT | IPC_EXCL | perms);\n\n    if (semid != -1) {                  /* Successfully created the semaphore */\n        union semun arg;\n        struct sembuf sop;\n\n        arg.val = 0;                    /* So initialize it to 0 */\n        if (semctl(semid, 0, SETVAL, arg) == -1)\n            errExit(\"semctl\");\n\n        /* Perform a \"no-op\" semaphore operation - changes sem_otime\n           so other processes can see we've initialized the set. */\n\n        sop.sem_num = 0;                /* Operate on semaphore 0 */\n        sop.sem_op = 0;                 /* Wait for value to equal 0 */\n        sop.sem_flg = 0;\n        if (semop(semid, &sop, 1) == -1)\n            errExit(\"semop\");\n\n    } else {                            /* We didn't create the semaphore set */\n        const int MAX_TRIES = 10;\n        int j;\n        union semun arg;\n        struct semid_ds ds;\n\n        if (errno != EEXIST) {          /* Unexpected error from semget() */\n            errExit(\"semget\");\n\n        semid = semget(key, 1, perms);  /* Retrieve ID of existing set */\n        if (semid == -1)\n            errExit(\"semget\");\n\n        /* Wait until another process has called semop() */\n\n        arg.buf = &ds;\n        for (j = 0; j < MAX_TRIES; j++) {\n            if (semctl(semid, 0, IPC_STAT, arg) == -1)\n                errExit(\"semctl\");\n            if (ds.sem_otime != 0)      /* semop() performed? */\n                break;                  /* Yes, quit loop */\n            sleep(1);                   /* If not, wait and retry */\n        }\n\n        if (ds.sem_otime == 0)          /* Loop ran to completion! */\n            fatal(\"Existing semaphore not initialized\");\n    }\n\n    /* Now perform some operation on the semaphore */\n      *from* `svsem/svsem_good_init.c`\n```", "```\n#include <sys/types.h>        /* For portability */\n#include <sys/sem.h>\n\nint `semop`(int *semid*, struct sembuf **sops*, unsigned int *nsops*);\n```", "```\nstruct sembuf {\n    unsigned short sem_num;     /* Semaphore number */\n    short          sem_op;      /* Operation to be performed */\n    short          sem_flg;     /* Operation flags (IPC_NOWAIT and SEM_UNDO) */\n};\n```", "```\n#define _GNU_SOURCE\n#include <sys/types.h>        /* For portability */\n#include <sys/sem.h>\n\nint `semtimedop`(int *semid*, struct sembuf **sops*, unsigned int *nsops*,\n               struct timespec **timeout*);\n```", "```\nstruct sembuf sops[3];\n\n   sops[0].sem_num = 0;                 /* Subtract 1 from semaphore 0 */\n   sops[0].sem_op = -1;\n   sops[0].sem_flg = 0;\n\n   sops[1].sem_num = 1;                 /* Add 2 to semaphore 1 */\n   sops[1].sem_op = 2;\n   sops[1].sem_flg = 0;\n\n   sops[2].sem_num = 2;                 /* Wait for semaphore 2 to equal 0 */\n   sops[2].sem_op = 0;\n   sops[2].sem_flg = IPC_NOWAIT;        /* But don't block if operation\n                                           can't be performed immediately */\n   if (semop(semid, sops, 3) == -1) {\n       if (errno == EAGAIN)             /* Semaphore 2 would have blocked */\n           printf(\"Operation would have blocked\\n\");\n       else\n           errExit(\"semop\");            /* Some other error */\n   }\n```", "```\n$ `./svsem_op 0 0=0 0-1,1-2n`\n```", "```\n`svsem/svsem_op.c`\n#include <sys/types.h>\n#include <sys/sem.h>\n#include <ctype.h>\n#include \"curr_time.h\"          /* Declaration of currTime() */\n#include \"tlpi_hdr.h\"\n\n#define MAX_SEMOPS 1000         /* Maximum operations that we permit for\n                                   a single semop() */\n\nstatic void\nusageError(const char *progName)\n{\n    fprintf(stderr, \"Usage: %s semid op[,op...] ...\\n\\n\", progName);\n    fprintf(stderr, \"'op' is either: <sem#>{+|-}<value>[n][u]\\n\");\n    fprintf(stderr, \"            or: <sem#>=0[n]\\n\");\n    fprintf(stderr, \"       \\\"n\\\" means include IPC_NOWAIT in 'op'\\n\");\n    fprintf(stderr, \"       \\\"u\\\" means include SEM_UNDO in 'op'\\n\\n\");\n    fprintf(stderr, \"The operations in each argument are \"\n                    \"performed in a single semop() call\\n\\n\");\n    fprintf(stderr, \"e.g.: %s 12345 0+1,1-2un\\n\", progName);\n    fprintf(stderr, \"      %s 12345 0=0n 1+1,2-1u 1=0\\n\", progName);\n    exit(EXIT_FAILURE);\n}\n\n/* Parse comma-delimited operations in 'arg', returning them in the\n   array 'sops'. Return number of operations as function result. */\n\nstatic int\nparseOps(char *arg, struct sembuf sops[])\n{\n    char *comma, *sign, *remaining, *flags;\n    int numOps;                 /* Number of operations in 'arg' */\n\n    for (numOps = 0, remaining = arg; ; numOps++) {\n        if (numOps >= MAX_SEMOPS)\n            cmdLineErr(\"Too many operations (maximum=%d): \\\"%s\\\"\\n\",\n                        MAX_SEMOPS, arg);\n\n        if (*remaining == '\\0')\n            fatal(\"Trailing comma or empty argument: \\\"%s\\\"\", arg);\n        if (!isdigit((unsigned char) *remaining))\n            cmdLineErr(\"Expected initial digit: \\\"%s\\\"\\n\", arg);\n\n        sops[numOps].sem_num = strtol(remaining, &sign, 10);\n\n        if (*sign == '\\0' || strchr(\"+-=\", *sign) == NULL)\n            cmdLineErr(\"Expected '+', '-', or '=' in \\\"%s\\\"\\n\", arg);\n        if (!isdigit((unsigned char) *(sign + 1)))\n            cmdLineErr(\"Expected digit after '%c' in \\\"%s\\\"\\n\", *sign, arg);\n\n        sops[numOps].sem_op = strtol(sign + 1, &flags, 10);\n\n        if (*sign == '-')                       /* Reverse sign of operation */\n            sops[numOps].sem_op = - sops[numOps].sem_op;\n        else if (*sign == '=')                  /* Should be '=0' */\n            if (sops[numOps].sem_op != 0)\n                cmdLineErr(\"Expected \\\"=0\\\" in \\\"%s\\\"\\n\", arg);\n\n        sops[numOps].sem_flg = 0;\n        for (;; flags++) {\n            if (*flags == 'n')\n                sops[numOps].sem_flg |= IPC_NOWAIT;\n            else if (*flags == 'u')\n                sops[numOps].sem_flg |= SEM_UNDO;\n            else\n                break;\n        }\n\n        if (*flags != ',' && *flags != '\\0')\n            cmdLineErr(\"Bad trailing character (%c) in \\\"%s\\\"\\n\", *flags, arg);\n\n        comma = strchr(remaining, ',');\n        if (comma == NULL)\n            break;                              /* No comma --> no more ops */\n        else\n            remaining = comma + 1;\n    }\n\n    return numOps + 1;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct sembuf sops[MAX_SEMOPS];\n    int ind, nsops;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageError(argv[0]);\n\n    for (ind = 2; argv[ind] != NULL; ind++) {\n        nsops = parseOps(argv[ind], sops);\n\n        printf(\"%5ld, %s: about to semop()  [%s]\\n\", (long) getpid(),\n                currTime(\"%T\"), argv[ind]);\n\n        if (semop(getInt(argv[1], 0, \"semid\"), sops, nsops) == -1)\n            errExit(\"semop (PID=%ld)\", (long) getpid());\n\n        printf(\"%5ld, %s: semop() completed [%s]\\n\", (long) getpid(),\n                currTime(\"%T\"), argv[ind]);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `svsem/svsem_op.c`\n```", "```\n$ `./svsem_create -p 2`\n32769                                               *ID of semaphore set*\n$ `./svsem_setall 32769 1 0`\nSemaphore values changed (PID=3658)\n```", "```\n$ `./svsem_op 32769 0-1,1-1 &`                        *Operation 1*\n 3659, 16:02:05: about to semop()  [0-1,1-1]\n[1] 3659\n```", "```\n$ `./svsem_op 32769 1-1 &`                            *Operation 2*\n 3660, 16:02:22: about to semop()  [1-1]\n[2] 3660\n```", "```\n$ `./svsem_op 32769 0=0 &`                            *Operation 3*\n 3661, 16:02:27: about to semop()  [0=0]\n[3] 3661\n```", "```\n$ `./svsem_mon 32769`\nSemaphore changed: Sun Jul 25 16:01:53 2010\nLast semop():      Thu Jan  1 01:00:00 1970\nSem #  Value  SEMPID  SEMNCNT  SEMZCNT\n  0       1       0      1        1\n  1       0       0      2        0\n```", "```\n$ `./svsem_op 32769 0=0n`                             *Operation 4*\n 3673, 16:03:13: about to semop()  [0=0n]\nERROR [EAGAIN/EWOULDBLOCK Resource temporarily unavailable] semop (PID=3673)\n```", "```\n$ `./svsem_op 32769 1+1`                              *Operation 5*\n 3674, 16:03:29: about to semop()  [1+1]\n 3659, 16:03:29: semop() completed [0-1,1-1]        *Operation 1 completes*\n 3661, 16:03:29: semop() completed [0=0]            *Operation 3 completes*\n 3674, 16:03:29: semop() completed [1+1]            *Operation 5 completes*\n[1]   Done              ./svsem_op 32769 0-1,1-1\n[3]+  Done              ./svsem_op 32769 0=0\n```", "```\n$ `./svsem_mon 32769`\nSemaphore changed: Sun Jul 25 16:01:53 2010\nLast semop():      Sun Jul 25 16:03:29 2010\nSem #  Value  SEMPID  SEMNCNT  SEMZCNT\n  0       0    3661      0        0\n  1       0    3659      1        0\n```", "```\n$ `./svsem_rm 32769`\nERROR [EIDRM Identifier removed] semop (PID=3660)\n```", "```\n$ `./svsem_create -p 2`\n131073\n```", "```\n$ `./svsem_op 131073 0+1u 1+1`\n 2248, 06:41:56: about to semop()\n 2248, 06:41:56: semop() completed\n```", "```\n$ `./svsem_mon 131073`\nSemaphore changed: Sun Jul 25 06:41:34 2010\nLast semop():      Sun Jul 25 06:41:56 2010\nSem #  Value  SEMPID  SEMNCNT  SEMZCNT\n  0       0    2248      0        0\n  1       1    2248      0        0\n```", "```\n`svsem/binary_sems.h`\n#ifndef BINARY_SEMS_H           /* Prevent accidental double inclusion */\n#define BINARY_SEMS_H\n\n#include \"tlpi_hdr.h\"\n\n/* Variables controlling operation of functions below */\n\nextern Boolean bsUseSemUndo;            /* Use SEM_UNDO during semop()? */\nextern Boolean bsRetryOnEintr;          /* Retry if semop() interrupted by\n                                           signal handler? */\n\nint initSemAvailable(int semId, int semNum);\n\nint initSemInUse(int semId, int semNum);\n\nint reserveSem(int semId, int semNum);\n\nint releaseSem(int semId, int semNum);\n\n#endif\n     `svsem/binary_sems.h`\n```", "```\n`svsem/binary_sems.c`\n#include <sys/types.h>\n#include <sys/sem.h>\n#include \"semun.h\"                      /* Definition of semun union */\n#include \"binary_sems.h\"\n\nBoolean bsUseSemUndo = FALSE;\nBoolean bsRetryOnEintr = TRUE;\n\nint                     /* Initialize semaphore to 1 (i.e., \"available\") */\ninitSemAvailable(int semId, int semNum)\n{\n    union semun arg;\n\n    arg.val = 1;\n    return semctl(semId, semNum, SETVAL, arg);\n}\n\nint                     /* Initialize semaphore to 0 (i.e., \"in use\") */\ninitSemInUse(int semId, int semNum)\n{\n    union semun arg;\n\n    arg.val = 0;\n    return semctl(semId, semNum, SETVAL, arg);\n}\n\n/* Reserve semaphore (blocking), return 0 on success, or -1 with 'errno'\n   set to EINTR if operation was interrupted by a signal handler */\n\nint                     /* Reserve semaphore - decrement it by 1 */\nreserveSem(int semId, int semNum)\n{\n    struct sembuf sops;\n\n    sops.sem_num = semNum;\n    sops.sem_op = -1;\n    sops.sem_flg = bsUseSemUndo ? SEM_UNDO : 0;\n\n    while (semop(semId, &sops, 1) == -1)\n        if (errno != EINTR || !bsRetryOnEintr)\n            return -1;\n\n    return 0;\n}\n\nint                     /* Release semaphore - increment it by 1 */\nreleaseSem(int semId, int semNum)\n{\n    struct sembuf sops;\n\n    sops.sem_num = semNum;\n    sops.sem_op = 1;\n    sops.sem_flg = bsUseSemUndo ? SEM_UNDO : 0;\n\n    return semop(semId, &sops, 1);\n}\n     `svsem/binary_sems.c`\n```", "```\n$ `cd /proc/sys/kernel`\n$ `cat sem`\n250     32000   32      128\n```", "```\nunion semun arg;\nstruct seminfo buf;\n\narg.__buf = &buf;\nsemctl(0, 0, IPC_INFO, arg);\n```"]