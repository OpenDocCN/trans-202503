- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TUPLES AND TYPE CONSTRUCTORS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A tuple is an ordered collection of values. There are tuples for ordered pairs,
    ordered triples, ordered quadruples, and so on. The types of the values in a tuple
    are generally different, but they could be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll discuss tuples and their generalization: the type constructor.
    Function types, list types, and tuple types are all examples of type constructors.
    We’ll present a unified way to think about these type constructors, which on the
    surface appear different, but all share essential features. Finally, we’ll revisit
    numerical integration to show how tuples, in conjunction with iteration, give
    a way to perform numerical integration that we will later generalize to solve
    differential equations.'
  prefs: []
  type: TYPE_NORMAL
- en: Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest tuple is the pair. A pair type is specified by giving an ordered
    pair `(a,b)` of types `a` and `b`, separated by a comma and enclosed in parentheses.
    If `x :: a` and `y :: b`, then `(x,y) :: (a,b)`. The value `(x,y)` has the type
    `(a,b)`. The comma and parentheses have two uses: they form the type `(a,b)` and
    they form the value `(x,y)` of that type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a pair composed of a `String` describing a person’s name
    and an `Int` representing the person’s score on an exam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the pair type is `(String,Int)` and the pair value is `("Albert`
    `Einstein", 79)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get some experience with tuples, let’s write a function `pythag` that computes
    the hypotenuse of a right triangle from the lengths of its two sides. We’ll pass
    the two side lengths to the function using a pair. Here is one way to write this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This type signature shows us that `pythag` expects a pair of two `R`s as input
    and produces an `R` as output. The fact that in the second line we call the input
    `(x,y)` (rather than a simple variable like `p`) means that this definition uses
    pattern matching on the input. This is similar to the pattern matching we saw
    earlier for `Bool` and for lists. Pattern matching for pairs is simple because
    there is only one pattern: every pair has the form `(x,y)`. Recall that `Bool`
    has two patterns (`True` and `False`) and that lists have two patterns (the empty
    list `[]` and the cons of an element and a list `x:xs`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of Prelude functions deal with pairs. The `fst` function takes a pair
    as input and returns the first component of the pair as output. The `snd` function
    takes a pair as input and returns the second component of the pair as output.
    We can test this behavior in GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The types of functions `fst` and `snd` are given entirely in terms of type variables,
    indicating that these functions care nothing for the type of the payload.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In general, there are two ways to get data out of a type like a pair that contains
    multiple pieces of data. One way is pattern matching, and the other is using functions
    like `fst` and `snd`, generally called *eliminators*. While it is theoretically
    possible to write code that uses only pattern matching and never uses eliminators,
    eliminators are sometimes simpler, so it is nice to have access to both. The eliminators
    `fst` and `snd` are particularly useful if you process some data that results
    in a pair and you just want one part of it. An example is the function `integral'`
    in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Currying a Function of Two Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.xhtml), we talked about currying as a way to think of a
    function as accepting more than one argument. Using a higher-order function, we
    can write our hypotenuse function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples offer an alternative way to write a function of two variables. Although
    `pythag` and `pythagCurried` are different Haskell functions with different types,
    they’re doing the same thing mathematically: they are both expressing the mathematical
    function that finds the hypotenuse. Let’s call `pythag` the *tuple form* of the
    hypotenuse function and `pythagCurried` the *curried form* of the hypotenuse function.'
  prefs: []
  type: TYPE_NORMAL
- en: These two ways of encoding a function of two variables are mutually exclusive.
    You need to pick one or the other for a particular function; you can’t use both.
    Notice that the tuple form `pythag` requires the use of parentheses and a comma
    around the two arguments. That’s because you need to have a tuple as input! Notice
    that the curried form `pythagCurried` has no parentheses and no comma. It’s not
    that the comma is optional; no comma can be present.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you might use one form but realize later on that you wish you had
    used the other. Haskell provides two functions to let you convert between forms.
    To convert from tuple form to curried form, Haskell provides the function `curry`.
    The function `curry pythag` is exactly the same function as `pythagCurried` we
    defined earlier. The function `uncurry pythagCurried` is the same as the function
    `pythag`. However, it does not make sense to write `curry pythagCurried` or `uncurry
    pythag`; these constructions will produce type errors when the compiler tries
    to read them.
  prefs: []
  type: TYPE_NORMAL
- en: If we load these functions into GHCi (code files are available at [*https://lpfp.io*](https://lpfp.io)),
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'we can see that the types of `pythagCurried` and `curry pythag` are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see that the types of `pythag` and `uncurry pythagCurried` are
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the types for `curry` and `uncurry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-1](ch09.xhtml#ch9fig1) attempts to explain these complex types. The
    two types shown in the figure are alternative ways to encode a function of two
    variables. The higher-order functions `curry` and `uncurry` transform one two-variable
    function type into the other.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/116fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Two types for a function of two variables. The higher-order functions
    curry and uncurry transform a two-variable function of one type into the other
    type.*'
  prefs: []
  type: TYPE_NORMAL
- en: Triples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to pairs, you can make triples, or tuples with even more components.
    However, the functions `fst` and `snd` work only with pairs. To access elements
    of triples and larger tuples, the standard method is to use pattern matching.
    For example, functions that pick out the components of triples can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The definitions of `fst3`, `snd3`, and `thd3` use pattern matching to assign
    names to the items in the triple. These names can then be used on the right-hand
    side of the definition to indicate the value we want the function to return. In
    the function `fst3`, the values `y` and `z` are not used. Because they are not
    used, it is in some sense superfluous to give them names. In the definition of
    `snd3`, the `_` (underscore) character is used as a placeholder to represent a
    quantity that doesn’t get used in the expression that follows. In the definition
    of `snd3`, we use underscores in the first and third slots of the triple. This
    signals that it is superfluous to give these items names since the names are not
    used in the definition. In the definition of `thd3`, we show an alternate use
    of underscores. Here we start the variable name with an underscore, indicating
    it won’t be used, but we give it a name for our own use, perhaps to remind us
    of the purpose of that variable. Using underscores for quantities that aren’t
    used is a best practice, because the compiler will generate warnings about unused
    variables, which are often errors. To distinguish these genuine errors (frequently
    misspellings) from items you don’t want to use, employ the underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Lists and Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tuple is different from a list in that every element of a list must have the
    same type. On the other hand, unlike a list, the type of a tuple says exactly
    how many elements the tuple has. If an expression has type `[Int]`, for example,
    it can be a list of zero, one, two, or more `Int`s. However, if an expression
    has type `(String,Int)`, it is a pair consisting of exactly one `String` and exactly
    one `Int`. If you want to combine exactly two things or exactly three things,
    a tuple is what you want. Beyond three items, tuples rapidly become unwieldy.
    Lists, on the other hand, are often very long. A list can happily contain thousands
    of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss lists of pairs, we’ll take a short detour to look at a class
    of types that will be helpful for that discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw in [Chapter 5](ch05.xhtml) that for any type `a` there is another type
    `[a]` consisting of lists of elements that each have type `a`. Such a list may
    have zero, one, two, or more elements of type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, for any type `a` there is another type `Maybe a` consisting of zero
    or one element of type `a`. To motivate this new data type, imagine that we are
    writing a function `findFirst` that will search through a list for the first element
    that meets some criterion. We might want such a function to have the following
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The type indicates our intent to have the function `findFirst` accept a predicate
    and a list of elements of type `b` as input and provide a single element of type
    `b` as output. But what if the list contains no element that meets our criterion?
    In that case, there is a problem because the function `findFirst` has no way to
    come up with an element of type `b`, but the type *demands* that the function
    return an element of type `b`. One possibility is for `findFirst` to use the `error`
    function if no suitable element is found, but this is an extreme measure and will
    halt the program so that no later recovery is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to use a different type signature, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If `findFirstMaybe` finds an element `x :: b` that meets the criterion, it
    will return `Just x`. If it finds no element of type `b` that meets the criterion,
    `find` `FirstMaybe` will return `Nothing`. Let’s see what the function definition
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The expression `dropWhile (not . p) xs` is what remains of the list `xs` after
    the longest possible sequence of elements that do *not* satisfy the predicate
    are removed from the front of the list. The `case` construction allows us to do
    pattern matching on the expression `dropWhile (not . p) xs`, asking which of the
    two list patterns the expression matches and returning an appropriate result in
    each case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type `Maybe a` has two patterns. (Recall that `Bool` has two patterns,
    lists have two patterns, and tuples have one pattern.) A value of `Maybe a` is
    either `Nothing` or `Just x` for some `x :: a`. The value `Nothing` is the way
    of specifying zero elements of type `a`, and the value `Just x` is the way of
    specifying one element of type `a` (namely `x`). [Table 9-1](ch09.xhtml#ch9tab1)
    shows some expressions involving `Maybe` and their types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Expressions Involving Maybe and Their Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Nothing` | `::` | `Maybe a` |'
  prefs: []
  type: TYPE_TB
- en: '| `Just "me"` | `::` | `Maybe [Char]` |'
  prefs: []
  type: TYPE_TB
- en: '| `Just ''X''` | `::` | `Maybe Char` |'
  prefs: []
  type: TYPE_TB
- en: '| `Just False` | `::` | `Maybe Bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `Just 4` | `::` | `Num a => Maybe a` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 9-2](ch09.xhtml#ch9tab2) shows a comparison of expressions having `Maybe`
    types with expressions having the underlying type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Comparison of Maybe Type and Underlying Type Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Expressions with this type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Bool` | `False`, `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe Bool` | `Just False`, `Just True`, `Nothing` |'
  prefs: []
  type: TYPE_TB
- en: '| `Char` | `''h''`, `''7''` |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe Char` | `Just ''h''`, `Just ''7''`, `Nothing` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `"Monday"`, `"Tuesday"` |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe String` | `Just "Monday"`, `Just "Tuesday"`, `Nothing` |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` | `3`, `7`, `-13` |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe Int` | `Just 3`, `Just 7`, `Just (-13)`, `Nothing` |'
  prefs: []
  type: TYPE_TB
- en: '[Table 9-2](ch09.xhtml#ch9tab2) shows four things: for each type `a` there
    is a type `Maybe a`; an expression of type `Maybe String`, unless it is `Nothing`,
    holds a value of type `String`; an expression of type `String` can be made into
    an expression of type `Maybe String` by prefixing the expression with the constructor
    `Just`; and these observations about the `String` type are also valid for `Bool`,
    `Char`, or any other type.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the `Maybe` type under our belt, let’s take a look at lists
    of pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Lists of Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as we can form lists of lists, we can make pairs of pairs, lists of pairs,
    pairs of lists, and more complicated things. The list of pairs is probably the
    most useful of these (although lists of lists are very useful), for reasons we
    will see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To form a list of pairs, we can use the Prelude function `zip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `zip` function takes two lists and pairs their first elements, their second
    elements, and so on until the end of the shorter list. [Table 9-3](ch09.xhtml#ch9tab3)
    shows some examples of how to use `zip`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-3:** Examples of `zip` and `zipWith`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `zip [1,2,3] [4,5,6]` | ⇝ | `[(1,4),(2,5),(3,6)]` |'
  prefs: []
  type: TYPE_TB
- en: '| `zip [1,2] [4,5,6]` | ⇝ | `[(1,4),(2,5)]` |'
  prefs: []
  type: TYPE_TB
- en: '| `zip [5..7] "who"` | ⇝ | `[(5,''w''),(6,''h''),(7,''o'')]` |'
  prefs: []
  type: TYPE_TB
- en: '| `zipWith (+) [1,2,3] [4,5,6]` | ⇝ | `[5,7,9]` |'
  prefs: []
  type: TYPE_TB
- en: '| `zipWith (-) [1,2,3] [4,5,6]` | ⇝ | `[-3,-3,-3]` |'
  prefs: []
  type: TYPE_TB
- en: '| `zipWith (*) [1,2,3] [4,5,6]` | ⇝ | `[4,10,18]` |'
  prefs: []
  type: TYPE_TB
- en: The Prelude function `zipWith` is a high-power relative of `zip` that goes one
    step further and applies a function to each pair of values that `zip` would have
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `zipWith` is a higher-order function that describes what
    to do with an element of type `a` (from the first list) and an element of type
    `b` (from the second list). The second argument to `zipWith` is the first list,
    and the third argument to `zipWith` is the second list.
  prefs: []
  type: TYPE_NORMAL
- en: The Prelude function `unzip` takes a lists of pairs and turns it into a pair
    of lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One use for a list of pairs is a lookup table. In a lookup table, the first
    item of each pair serves as a *key* and the second item of each pair serves as
    a *value*. Such a pair is referred to as a *key-value pair*. The following list
    of pairs is a lookup table containing the final numeric grade for the History
    of Western Civilization course taken by three famous scientists. The name of each
    person acts as the key, and the grade is the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Prelude function `lookup` takes a key and a lookup table and returns the
    corresponding value, if there is one. The function `lookup` returns a `Maybe`
    type to allow for the possibility that the key is not found in the lookup table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tuples and List Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Later, we’ll want to have a way to use list comprehensions to form lists of
    pairs (*x*,*y*) we want to plot. In [Chapter 11](ch11.xhtml), for example, we’ll
    meet a plotting function called `plotPath` that takes a list of pairs of numbers
    as input, usually `[(R,R)]`, and produces a plot. We can use list comprehensions
    to transform our data into a form suitable for plotting. If we wanted to plot
    position as a function of time, we could form a list of time-position pairs as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The same list of pairs can be formed with `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Besides mapping, a list comprehension can filter data based on a Boolean expression.
    Let’s continue our example of forming a list of time-position pairs with `yRock30`.
    Suppose we want to only have pairs in our list while the rock is in the air (*y*
    > 0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After we give the list that the values of `t` come from, we add a comma and
    then the Boolean expression to use for filtering. The computer will form a list,
    as before, but now only keep values for which the Boolean expression returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve the same effect with a combination of `map` and `filter`. We
    can do the filtering first,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'or we can do the mapping first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The application operator `$` from [Table 1-2](ch01.xhtml#ch1tab2) has a precedence
    of 0, so the expressions on each side of it are evaluated before they are combined.
    In this way, the application operator serves as a kind of one-symbol parentheses.
    The same effect could have been produced by enclosing the entire `map` line above
    in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `_` (underscore) character in the anonymous function just
    shown. Since the conditional expression only depends on the second item in the
    pair, there is no need to give a name to the first item in the pair.
  prefs: []
  type: TYPE_NORMAL
- en: The type of a pair is formed from two existing types. The type of a triple is
    formed from three existing types. The idea of a *type constructor*, which we explore
    in the next section, provides a unifying framework for constructing new types
    from old.
  prefs: []
  type: TYPE_NORMAL
- en: Type Constructors and Kinds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Maybe Int` is a type, `Maybe Bool` is a type, and `Maybe R` is a type, but
    `Maybe` itself is not a type. It’s what’s called a *type constructor*. A type
    constructor is an object that takes zero or more types as input and produces a
    type as output. `Maybe` is a one-place type constructor, taking the type `Int`
    as input and producing the type `Maybe Int` as output. In other words, `Maybe`
    is a function at the type level. A zero-place type constructor is the same as
    a type. To keep track of this complexity, Haskell assigns a *kind* to each type
    and type constructor. A type, such as `R`, has the kind `*`. GHCi has the command
    :kind (or `:k` for short) to ask about the kind of something.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A one-place type constructor, such as `Maybe`, has the kind `* -> *`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we apply `Maybe` to `R`, the resulting `Maybe R` is once again a type,
    with the kind `*`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Types have the kind `*`, one-place type constructors have the kind `* -> *`,
    and there are objects with more complicated kinds as well. It is interesting to
    note that you can ask GHCi for the kind of a type class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This kind means that, when provided with a type, the type class `Num` produces
    a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Function types, list types, and tuple types are all special cases of types constructed
    with a type constructor. Haskell provides special syntax for function types, list
    types, and tuple types, so it may aid our understanding to give regular names
    to the type constructors that produce functions, lists, and tuples. The `type`
    keyword, which was introduced in [Chapter 4](ch04.xhtml) to make `R` a synonym
    for `Double`, can also be used for parameterized types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`List`, like `Maybe`, is a one-place type constructor. It takes one type as
    input and produces a type as output. `Function` and `Pair` are two-place type
    constructors. They take two types as input and produce a type as output. `Triple`
    is a three-place type constructor. It takes three types as input and produces
    a type as output.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-4](ch09.xhtml#ch9tab4) shows the kinds of some type constructors and
    type classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-4:** Kinds of Several Type Constructors and Type Classes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type constructor/class** |  | **Kind** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Integer` | `::` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `R -> R` | `::` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `[String]` | `::` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `(Int,String)` | `::` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe Int` | `::` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | `::` | `*` |'
  prefs: []
  type: TYPE_TB
- en: '| `List` | `::` | `* -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | `::` | `* -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `Maybe` | `::` | `* -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `IO` | `::` | `* -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `Function` | `::` | `* -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `(->)` | `::` | `* -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `Pair` | `::` | `* -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `(,)` | `::` | `* -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `Either` | `::` | `* -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `Triple` | `::` | `* -> * -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `(,,)` | `::` | `* -> * -> * -> *` |'
  prefs: []
  type: TYPE_TB
- en: '| `Num` | `::` | `* -> Constraint` |'
  prefs: []
  type: TYPE_TB
- en: '| `Foldable` | `::` | `(* -> *) -> Constraint` |'
  prefs: []
  type: TYPE_TB
- en: Basic types, function types, list types, tuple types, `Maybe` types, and the
    unit type all have the kind `*`. One-place type constructors, such as `List`,
    `Maybe`, and `IO`, have the kind `* -> *`, which indicates that they take a type
    as input and produce a type as output. Note that the symbol `[]`, which is the
    empty list and hence is a data constructor for the list type, serves double duty
    as a type constructor for the list type. In this role it does the same thing as
    the `List` type constructor we defined above. `IO` is a type constructor that
    turns a pure type into a type with side effects; we’ll discuss it in [Chapter
    11](ch11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Two-place type constructors, such as `Function`, `Pair`, and `Either` have the
    kind `* -> * -> *` to indicate that they take two types as input and produce a
    type as output. The symbol `(->)` is the same as the `Function` type constructor
    we defined above and `(,)` is the same as `Pair`. A three-place type constructor,
    such as `Triple`, has the kind `* -> * -> * -> *` to indicate that it takes three
    types as input and produces a type as output. The symbol `(,,)` is the same as
    `Triple`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-5](ch09.xhtml#ch9tab5) shows the meanings of various kinds in Haskell.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-5:** Meanings of Kinds'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Kind** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Type |'
  prefs: []
  type: TYPE_TB
- en: '| `* -> *` | One-place type constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `* -> * -> *` | Two-place type constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `* -> * -> * -> *` | Three-place type constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `* -> Constraint` | Type class for types |'
  prefs: []
  type: TYPE_TB
- en: '| `(* -> *) -> Constraint` | Type class for type constructors |'
  prefs: []
  type: TYPE_TB
- en: Each type class also has a kind. A type class takes a type or type constructor
    as input and produces a constraint as output. The basic type classes we discussed
    in [Chapter 8](ch08.xhtml) have the kind `* -> Constraint`, meaning they take
    a type as input and produce a type-class constraint as output. The type class
    `Foldable` has the kind `(* -> *) -> Constraint`, meaning that it takes a type
    constructor (such as `List` or `Maybe`) as input and produces a type-class constraint
    as output. `List` and `Maybe` are instances of `Foldable`, but `IO` is not.
  prefs: []
  type: TYPE_NORMAL
- en: Our final use of tuples in this chapter is in numerical integration. By using
    a tuple together with `iterate`, we get a method for numerical integration that
    we can later generalize to a method for solving a differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Integration Redux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We looked at numerical integration in [Chapter 6](ch06.xhtml), where we used
    a list comprehension to sum the areas of rectangles under a curve. Now that we
    have tuples, we can present an alternative method for numerical integration that
    comes closer to the method we’ll later use to solve differential equations. The
    idea is that if we pair up the current value of the integration variable (let’s
    call it time) with the accumulating value of the integral, we can proceed step
    by step to get the entire integral. To take one step forward, we increment the
    time by the time step and increment the running total that will ultimately be
    our integral by the area of one rectangle under the curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that advances one step looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The function `oneStep` names the incoming time step `dt`, the function to be
    integrated `f`, the current value of the integration variable `t`, and the current
    accumulating value of the integral `y`. It then returns a pair with the integration
    variable increased by the time step and the current value of the integral increased
    by the area f t * dt of one rectangle under the function `f`.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the integral, we iterate the single step as long as the independent
    variable is less than the upper limit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `oneStep dt f :: (R,R) -> (R,R)` is a function that updates
    the current time-integral pair by one time step. Since this function has the type
    `a -> a`, it can be iterated with `iterate`. The expression iterate (oneStep dt
    f) (a + dt/2,0) produces an infinite list of time-integral pairs, starting with
    the time a + dt/2, which is in the middle of the first time interval, and an initial
    value of 0 for the value of the integral that will accumulate as we iterate.'
  prefs: []
  type: TYPE_NORMAL
- en: By acting on the infinite list with `dropWhile (\(t,_) -> t < b)`, we drop the
    initial pairs whose times are less than the upper limit `b` to obtain an infinite
    list whose first pair has a time very close to the upper limit `b`. Acting on
    this infinite list with `head` returns the pair whose time is very close to the
    upper limit. Finally, acting on this pair with `snd` returns the value of the
    integral.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, here is the `Integration` type from [Chapter 6](ch06.xhtml)
    that we used earlier in the type signature of `integral''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced tuples, a way to combine two or more values into a single
    value. We then looked at type constructors, functions at the type level that form
    an output type from an input type. We ended the chapter by using tuples to introduce
    an alternative way to achieve numerical integration using `iterate`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll return to physics, look at kinematics in three dimensions,
    and develop the data type we’ll use for vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 9.1.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: that takes as input polar coordinates (*r*, *θ*), with *θ* in radians, and returns
    as output a pair (x, y) of Cartesian coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.2.** Explain in words the meaning of the types of `curry` and
    `uncurry`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.3.** The Prelude function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: is slightly problematic in that it causes a runtime error if it is passed an
    empty list. Write a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: that returns `Nothing` if passed the empty list and `Just x` otherwise, where
    `x` is the first element (the head) of the given list. Replace the undefined with
    your own code. (You can use undefined in your own functions as a placeholder if
    you want your code to load before you are finished writing it.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.4.** We mentioned earlier that the type `Maybe a` is a bit like
    the type `[a]`, except that elements of `Maybe a` are constrained to have zero
    or one element. To make this analogy precise, write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: that makes a list out of a `Maybe` type. What list should `Nothing` map to?
    What list should `Just x` map to?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.5.** Find out and explain what happens when `zip` is used with
    two lists that don’t have the same length.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.6.** Define a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'that turns a pair of lists into a list of pairs. (Hint: consider using `curry`
    or `uncurry`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.7.** The dot operator (`.`) is for function composition. If we
    do `unzip` followed by `zip''`, we have a function with the following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Is this the identity function? (In other words, does it always return the expression
    it was given?) If so, how do you know? If not, give a counterexample.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do `zip''` followed by `unzip`, we have a function with the following
    type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Is this the identity function?
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.8.** Using the `grades` lookup table from earlier, show how to
    use the `lookup` function to produce the value `Just 89`. Also show how to use
    the `lookup` function to produce the value `Nothing`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.9.** Translate the following mathematical function into Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*(*r*, *θ*, *ϕ*) = *r* sin *θ* cos *ϕ*'
  prefs: []
  type: TYPE_NORMAL
- en: Use a triple for the input to the function `x`. Give a type signature as well
    as a function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.10.** A car starts from rest and accelerates at 5 m/s² along a
    straight, level highway. We want to make an infinite list `tvPairs` of time-velocity
    pairs for this car, one every second. Here is our code for `tvPairs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Write a type signature and function definition for `tvUpdate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The list `tvPairs` should look like [(0,0),(1,5),(2,10),(3,15),...]. After you
    write the function `tvUpdate`, use the `take` function to see the first several
    elements of `tvPairs`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.11.** A Fibonacci sequence is one in which each term is the sum
    of the previous two terms. The first several terms are 1, 1, 2, 3, 5, 8, 13, 21,
    34, 55\. Write a sequence'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: for the (infinite) list of Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: As a suggestion, write a helping sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: using the function `iterate`. The first several terms of fibHelper should be
    [(0,1),(1,1),(1,2),(2,3),(3,5),...]. Then write the sequence `fibonacci` using
    `fibHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.12.** The factorial function takes a non-negative integer and
    returns the product of all positive integers up to and including the given integer.
    It is usually denoted with an exclamation point. For example, 5! = 5 × 4 × 3 ×
    2 × 1 = 120\. We define 0! = 1\. The purpose of this exercise is to write a factorial
    function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'using `iterate`. The suggestion in Exercise 9.11 is useful here as well (write
    a sequence `factHelper :: [(Int,Int)]` using `iterate` and then define `fact`
    to get its values from this sequence using the `!!` operator).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.13.** Write the following function using a list comprehension
    rather than a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 9.14.** Suppose we throw a rock straight up in the air at 15 m/s.
    Use a list comprehension to make a list of (time, position, velocity) triples
    (type `[(R,R,R)]`) for an interval of time while the rock is in the air. Your
    list should have enough triples to let the data make a reasonably smooth graph
    if plotted.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 9.15.** Tuples can be nested, like `((3,4),5)`. Although this pair
    contains three numbers, it is not the same as a triple. Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: that converts a pair whose first component is a pair into a triple.
  prefs: []
  type: TYPE_NORMAL
