<html><head></head><body>
<span epub:type="pagebreak" id="page_91"/>&#13;
<h2 class="h2"><strong><span class="big">6</span><br/>MEMORY AND CLOCK SIGNALS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">In the previous chapters we saw how digital logic gates can be combined to produce useful combinational logic circuits where the output is a function of the inputs. In this chapter, we look at sequential logic circuits. These circuits have memory, the ability to store a record of the past. We cover some specific kinds of memory devices: latches and flip-flops. We also learn about clock signals, which are a way to synchronize multiple circuit components.</p>&#13;
<h3 class="h3" id="lev1_36"><strong>Sequential Logic Circuits and Memory</strong></h3>&#13;
<p class="noindent">Let’s now examine a type of digital circuit known as a <em>sequential logic circuit</em>. A sequential logic circuit’s output depends not only on its present set of inputs, but also on past inputs to the circuit. In other words, a sequential <span epub:type="pagebreak" id="page_92"/>logic circuit has some knowledge of its own previous history or state. Digital devices store a record of past state in what is known as <em>memory</em>, a component that allows for storage and retrieval of binary data.</p>&#13;
<p class="indent">Let’s consider a simple example of sequential logic: a coin-operated vending machine. A vending machine has at least two inputs: a coin slot and a vend button. For simplicity, let’s assume that the vending machine only vends one type of item and that item costs one coin. The vend button doesn’t do anything unless a coin has been inserted. If the vending machine were based on <em>combinational logic</em>, where the state is determined by present inputs only, then a coin would have to be inserted at the same instant that the vend button is pressed.</p>&#13;
<p class="indent">Fortunately, that’s not how vending machines work! They have memory that tracks whether a coin has been inserted. When we press the vend button, the sequential logic in the vending machine checks its memory to see if a coin was previously inserted. If so, the machine dispenses an item. We’ll build on this sequential logic example later in the chapter.</p>&#13;
<p class="indent">Sequential logic is possible because of memory. Memory stores binary data, and its capacity for storage is measured in bits or bytes. Modern computing devices such as smartphones usually have at least 1GB of memory. That’s over 8 billion bits! Let’s begin with something a little simpler: a memory device with 1 bit of memory.</p>&#13;
<h3 class="h3" id="lev1_37"><strong>The SR Latch</strong></h3>&#13;
<p class="noindent">A <em>latch</em> is a type of memory device that remembers one bit. The <em>SR latch</em> has two inputs: S (for set) and R (for reset), and an output called Q, the single bit that’s “remembered.” When S is set to 1, output Q becomes 1 too. When S goes to 0, Q remains equal to 1, because the latch remembers this previous input. This is the essence of memory—the component remembers a previous input, even if that input changes. When R is set to 1, this is an indicator to reset/clear the memory bit, so output Q becomes 0. Q will remain 0 even if R goes back to 0.</p>&#13;
<p class="indent">We summarize the behavior of an SR latch in <a href="ch06.xhtml#ch6tab1">Table 6-1</a>.</p>&#13;
<p class="tabcap" id="ch6tab1"><strong>Table 6-1:</strong> Operation of an SR Latch</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>S</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>R</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Q (output)</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Operation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Maintain previous value</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Hold</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Reset</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Set</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">X</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Invalid</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">By design, setting S to 1 and R to 1 at the same time is an invalid input, and the value of Q in this scenario is undefined. In practice, attempting this causes Q to go to 1 or 0, but we can’t reliably say which. Besides, it doesn’t make sense to try to set and reset the latch at the same time. The circuit diagram symbol for an SR latch is shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>.</p>&#13;
<span epub:type="pagebreak" id="page_93"/>&#13;
<div class="image" id="ch6fig1"><img src="../images/fig6-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-1: The circuit diagram symbol for an SR latch</em></p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch6fig1">Figure 6-1</a> there’s an additional output: <span class="bar">Q</span>. Read this as “complement of Q,” “NOT Q,” or “inversion of Q.” It’s simply the opposite of Q. When Q is 1, <span class="bar">Q</span> is 0, and vice-versa. It can be useful to have both Q and <span class="bar">Q</span> available, and as you’ll see, the design of such a circuit lends itself to including this output without extra effort.</p>&#13;
<p class="indent">We can implement an SR latch fairly simply using only two NOR gates and some wires. That said, understanding how the design works takes some thought. Consider the circuit shown in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>, which is an implementation of an SR latch.</p>&#13;
<div class="image" id="ch6fig2"><img src="../images/fig6-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-2: SR latch implemented with cross-coupled NOR gates</em></p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>, we have two NOR gates in what is known as a <em>cross-coupled configuration</em>. As a reminder, a NOR gate only outputs a 1 if both inputs are 0; otherwise, it outputs a 0. The output from N1 feeds into N2’s input, and the output from N2 feeds into N1’s input. The inputs are S and R. The outputs are Q and <span class="bar">Q</span>. Let’s examine how the circuit works by activating and clearing various inputs, examining the outputs as we go. Assume that initially S is 0, and R is 1.</p>&#13;
<div class="image" id="ch6fig3"><img src="../images/fig6-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-3: SR latch, initial state</em></p>&#13;
<p class="noindent"><strong>Initial state (S = 0, R = 1)</strong></p>&#13;
<ol>&#13;
<li class="noindent">R = 1, so the output of N2 is 0.</li>&#13;
<li class="noindent">The output of N2 is fed into N1.</li>&#13;
<li class="noindent">S = 0, so the output of N1 is 1.</li>&#13;
<li class="noindent">Initially Q = 0.</li>&#13;
</ol>&#13;
<p class="block">Summary: when R goes high, the output goes low (see <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>).</p>&#13;
<div class="image" id="ch6fig4"><img src="../images/fig6-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-4: SR latch, inputs low</em></p>&#13;
<span epub:type="pagebreak" id="page_94"/>&#13;
<p class="noindent"><strong>Next, clear all inputs (S = 0, R = 0)</strong></p>&#13;
<ol>&#13;
<li class="noindent">R goes to 0.</li>&#13;
<li class="noindent">The other input to N2 is still 1, so the output of N2 is still 0.</li>&#13;
<li class="noindent">Therefore, Q still equals 0.</li>&#13;
</ol>&#13;
<p class="block">Summary: the circuit remembered the previous output state (see <a href="ch06.xhtml#ch6fig4">Figure 6-4</a>).</p>&#13;
<div class="image" id="ch6fig5"><img src="../images/fig6-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-5: SR latch, S goes high</em></p>&#13;
<p class="noindent"><strong>Next, activate the S input (S = 1, R = 0)</strong></p>&#13;
<ol>&#13;
<li class="noindent">S goes to 1.</li>&#13;
<li class="noindent">This causes the output of N1 to go to 0.</li>&#13;
<li class="noindent">The inputs to N2 are now 0 and 0, so the output of N2 is 1.</li>&#13;
<li class="noindent">Therefore, Q now equals 1.</li>&#13;
</ol>&#13;
<p class="block">Summary: setting S high causes the output to go high (see <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>).</p>&#13;
<div class="image" id="ch6fig6"><img src="../images/fig6-6.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-6: SR latch, S goes low</em></p>&#13;
<p class="noindent"><strong>Finally, clear all inputs again (S = 0, R = 0)</strong></p>&#13;
<ol>&#13;
<li class="noindent">S goes to 0.</li>&#13;
<li class="noindent">The other input to N1 is still 1, so the output of N1 is still 0.</li>&#13;
<li class="noindent">The inputs to N2 are unchanged.</li>&#13;
<li class="noindent">Therefore, Q still equals 1.</li>&#13;
</ol>&#13;
<p class="block">Summary: the circuit remembered the previous output state (see <a href="ch06.xhtml#ch6fig6">Figure 6-6</a>).</p>&#13;
<p class="indent">Putting all of that together, we’ve just described the desired behavior of an SR latch, as previously summarized in <a href="ch06.xhtml#ch6tab1">Table 6-1</a>. When S (set) is 1, the output, Q, goes to 1 and stays at 1 even when S goes back to 0. When R (reset) is 1, the output, Q, goes to 0 and stays at 0 even when R goes back to 0. In this way, the circuit remembers either a 1 or 0, so we have a device with 1 bit of memory! Even though there are two outputs (Q and <span class="bar">Q</span>), both are just different representations of the same saved bit. Remember, setting both S = 1 and R = 1 at the same time is an invalid input.</p>&#13;
<p class="indent">To understand the behavior of the SR latch, we’ve looked at how the circuit behaves when the inputs are held high and then set low. However, S and R typically just need to be “pulsed.” When the circuit is at rest, both S and R are low. When we want to change its state, we have no reason to hold S or R high for long; we just need to quickly set it high and then back to low—a simple pulse of the input.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>UNIVERSAL LOGIC GATES</strong></p>&#13;
<p class="exercise-para">We just demonstrated how an SR latch can be constructed with NOR gates. In fact, NOR gates can be used to create any other logic circuit, not just the SR latch. The NOR gate is known as a <em>universal logic gate</em>; it can be used to implement any logical function. The same is true of NAND.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_95"/>&#13;
<p class="indent">Now that we’ve investigated the internal design of an SR latch, we can optionally go back to using the symbol in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a> to represent an SR latch. When we do this, we no longer need to concern ourselves with the internals of a latch. This is another example of encapsulation! We take a design and put it in a “black box,” which makes it easier to use that design without worrying about the internal details. I find it helpful to think of the SR latch in simple terms: it’s a 1-bit memory device that has a state Q of either 1 or 0. The S input sets Q to 1, and the R input resets Q to 0.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch06.xhtml#proj6">Project #6</a> on <a href="ch06.xhtml#page_104">page 104</a>, where you can build an SR latch</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_38"><strong>Using the SR Latch in a Circuit</strong></h3>&#13;
<p class="noindent">Now that we have a basic memory device, the SR latch, let’s use it in an example circuit. Let’s return to our vending machine example and design a vending machine circuit that uses a latch. The circuit has the following requirements:</p>&#13;
<ul>&#13;
<li class="noindent">The circuit has two inputs: a COIN button and a VEND button. Pressing COIN represents inserting a coin. Pressing VEND causes the machine to vend an item (the circuit will just turn on an LED to represent vending an item).</li>&#13;
<li class="noindent">The circuit has two LED outputs: COIN LED and VEND LED. COIN LED lights when a coin has been inserted. VEND LED lights to indicate that an item is being vended.</li>&#13;
<li class="noindent">The machine won’t vend an item unless a coin has been first inserted.</li>&#13;
<li class="noindent">For simplicity, assume only one coin can be inserted. Inserting additional coins does not change the state of the circuit.</li>&#13;
<li class="noindent">Normally after a vending operation occurs, we’d expect the circuit to reset itself and go back to the “no coin” state. However, for simplicity of design, we’ll skip the automatic reset in favor of a manual reset.</li>&#13;
</ul>&#13;
<p class="indent">At a conceptual level, our vending circuit will be implemented as shown in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>.</p>&#13;
<span epub:type="pagebreak" id="page_96"/>&#13;
<div class="image" id="ch6fig7"><img src="../images/fig6-7.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-7: Conceptual vending machine circuit with manual reset</em></p>&#13;
<p class="indent">Let’s walk through <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>. When you press the COIN button, the COIN memory device (an SR latch) stores the fact that a coin was inserted. The memory device then outputs a 1, indicating that a coin has been inserted, and the COIN LED lights up. When you press the VEND button, if a coin was previously inserted, the AND gate outputs 1, and the VEND LED lights. On the other hand, if you press the VEND button without previously inserting a coin, nothing happens. To clear the COIN LED and reset the device, you must manually set the Reset input to 1.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch06.xhtml#proj7">Project #7</a> on <a href="ch06.xhtml#page_105">page 105</a>, where you can build the vending machine circuit just described</em>.</p>&#13;
</div>&#13;
<p class="indent">This basic vending machine circuit demonstrates a practical use of memory in a circuit. Since our circuit design includes a memory element, the VEND button can behave differently based on whether a coin was inserted in the past. However, once the COIN bit is set in memory, it stays set until the circuit is manually reset. That’s not ideal, so let’s update our circuit so that it resets automatically after a vend operation occurs.</p>&#13;
<p class="indent">Once the machine vends an item, we expect the COIN bit to be set back to 0, since the action of vending “uses” the coin. In other words, vending should also cause the coin memory to reset. To implement this logic, we can connect the output of the AND gate to the memory reset, as shown in <a href="ch06.xhtml#ch6fig8">Figure 6-8</a>. That way, when the VEND LED turns on, the COIN memory resets.</p>&#13;
<div class="image" id="ch6fig8"><img src="../images/fig6-8.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-8: Conceptual vending machine circuit with automatic reset</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>The system shown in <a href="ch06.xhtml#ch6fig8">Figure 6-8</a> will reset the circuit during vending, but there’s a problem with this design. Can you spot it? The problem may not be obvious. If you completed the last project, you may want to try this type of reset on the circuit you just built. Connect a wire from the output of the AND gate to the R input in the SR latch, press COIN, then press VEND. Spoilers ahead, so don’t read on until you’ve given this a try, either mentally or on a breadboard!</p>&#13;
<p class="indent">The problem is that although the reset works as expected, it happens so quickly that the VEND LED immediately turns off, or more likely, the VEND LED never comes on. Here we have an example of a design that technically works but works so quickly that the user of the device can’t see what happened. This is a fairly common problem in user interface design. The devices and programs we build often operate so quickly that we must deliberately slow things down a bit so that the user can keep up. In this case, a solution would be to introduce a delay on the reset line so that the VEND LED has time to light up for a second or two before the reset occurs. This is shown in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>.</p>&#13;
<div class="image" id="ch6fig9"><img src="../images/fig6-9.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-9: Conceptual vending machine circuit with automatic delayed reset</em></p>&#13;
<p class="indent">How can we go about adding a delay? One approach is to use a capacitor. A <em>capacitor</em> is an electrical component that stores energy. It has two terminals. When current flows to the capacitor, the capacitor charges. The measure of a capacitor’s ability to store electric charge is called <em>capacitance</em>, which is measured in <em>farads</em>. One farad is a very large value, so we typically rate capacitors in <em>microfarads</em>, abbreviated <em>μF</em>.</p>&#13;
<p class="indent">When the capacitor is not charged, it acts like a short circuit. Once the capacitor is charged, it acts like an open circuit. The time it takes to charge or discharge a capacitor is controlled by the capacitor’s capacitance value and resistance in the circuit. Larger capacitance and resistance values result in a capacitor taking longer to charge. So we can use a capacitor and resistor to introduce a delay in our circuit caused by the time it takes the capacitor to charge.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch06.xhtml#proj8">Project #8</a> on <a href="ch06.xhtml#page_107">page 107</a>, where you can add a delayed reset to your vending machine circuit</em>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>So far in this chapter we’ve restricted our exploration of memory to single-bit devices. Although 1 bit of memory has limited applicability, in <a href="ch07.xhtml">Chapter 7</a> we’ll see how we can use sets of single-bit memory cells together to represent larger amounts of data.</p>&#13;
<h3 class="h3" id="lev1_39"><strong>Clock Signals</strong></h3>&#13;
<p class="noindent">As circuits become more complex, we often need to keep the various elements synchronized so that they all change state at the same time. We may have to do this for circuits with multiple memory devices, where we’d like to ensure that all the stored bits can be set at the same time. This is especially true when we need to consider sets of bits together. We can synchronize multiple circuit components with a clock signal. A <em>clock signal</em>, or just a <em>clock</em>, alternates its voltage level between high and low. Typically, the signal alternates on a regular cadence, where the signal is high half the time and low the other half. We call this type of signal a <em>square wave</em>. <a href="ch06.xhtml#ch6fig10">Figure 6-10</a> shows a 5V square wave clock signal graphed over time.</p>&#13;
<div class="image" id="ch6fig10"><img src="../images/fig6-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-10: A 5V square wave clock signal</em></p>&#13;
<p class="indent">A single iteration of the voltage rising and falling is a <em>pulse</em>. A complete oscillation from low to high and back to low (or the reverse) is a <em>cycle</em>. We measure the <em>frequency</em> of the clock signal in cycles per second, or <em>hertz (Hz)</em>. In <a href="ch06.xhtml#ch6fig11">Figure 6-11</a>, the frequency of the clock signal shown is 2Hz, because the signal completes two full oscillations in one second.</p>&#13;
<div class="image" id="ch6fig11"><img src="../images/fig6-11.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-11: A 2Hz clock signal</em></p>&#13;
<p class="indent">When a circuit uses a clock, all components that need to be synchronized are connected to the clock. Each component is designed to allow state changes only when a clock pulse occurs. Clock-driven components <span epub:type="pagebreak" id="page_99"/>typically trigger state changes on either the rising edge or the falling edge of the pulse. A component that changes state on the rising pulse edge is known as <em>positive edge–triggered</em>, and a component that changes state on the falling pulse edge is known as <em>negative edge–triggered</em>. <a href="ch06.xhtml#ch6fig12">Figure 6-12</a> provides an example of a rising and falling edge.</p>&#13;
<div class="image" id="ch6fig12"><img src="../images/fig6-12.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-12: Pulse edges illustrated</em></p>&#13;
<p class="indent">The graphics in this book illustrate pulse edges as vertical lines; this implies an instantaneous change from low to high or vice versa. In practice, however, it takes time to change states, but for the purposes of our discussion, let’s imagine the state change happening instantaneously.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch06.xhtml#proj9">Project #9</a> on <a href="ch06.xhtml#page_109">page 109</a>, where you can use your SR latch as a manual clock</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_40"><strong>JK Flip-Flops</strong></h3>&#13;
<p class="noindent">A 1-bit memory device that uses a clock is a <em>flip-flop</em>. There’s some overlap in usage of the terms <em>latch</em> and <em>flip-flop</em>, but here we use <em>latch</em> to mean memory devices without a clock, and <em>flip-flop</em> to mean clocked memory devices. You may see the terms used interchangeably or with different connotations elsewhere.</p>&#13;
<p class="indent">Let’s examine a specific clocked memory device, the <em>JK flip-flop</em>. The JK flip-flop is a conceptual extension of the SR latch, so let’s compare the two. The SR latch has input S to set the memory bit and input R to reset the memory bit; similarly, the JK flip-flop has input J to set and input K to reset. The SR latch immediately changes state when S or R is set high, but the JK flip-flop only changes state on a clock pulse. The JK flip-flop also adds an additional feature: when both J and K are set high, the output toggles a single time from low to high or high to low. This is summarized in <a href="ch06.xhtml#ch6tab2">Table 6-2</a>.</p>&#13;
<p class="tabcap" id="ch6tab2"><strong>Table 6-2:</strong> Comparison of SR Latch and JK Flip-Flop</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong> </strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>SR latch</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>JK flip-flop</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Changes state</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Immediately when S or R goes high</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Only on clock pulse if J or K are high</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Set</strong></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">S = 1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">J = 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Reset</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">R = 1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">K = 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Toggle</strong></p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Not applicable</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">J = 1 and K = 1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>When representing a JK flip-flop in a diagram, the symbols shown in <a href="ch06.xhtml#ch6fig13">Figure 6-13</a> can be used.</p>&#13;
<div class="image" id="ch6fig13"><img src="../images/fig6-13.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-13: JK flip-flops, positive edge–triggered (left), negative edge–triggered (right)</em></p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6fig13">Figure 6-13</a> shows two versions of the JK flip-flop. The one on the left is positive edge–triggered, meaning it changes state on the rising edge of the clock pulse. On the right, we have the symbol for a negative edge–triggered JK flip-flop (note the circle on the CLK input); it changes state on the falling edge of the clock pulse. The two devices behave identically otherwise.</p>&#13;
<p class="indent">So a JK flip-flop is a 1-bit memory device that only changes state when it receives a clock pulse. It’s quite similar to an SR latch, except that a clock controls its state changes, and it has the ability to toggle its value. <a href="ch06.xhtml#ch6tab3">Table 6-3</a> summarizes the behavior of the JK flip-flop.</p>&#13;
<p class="tabcap" id="ch6tab3"><strong>Table 6-3:</strong> Summary of the Functionality of a JK Flip-Flop</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>J</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>K</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Clock</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Q (output)</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Operation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Pulse</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Maintain previous value</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Hold</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Pulse</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Reset</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Pulse</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Set</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Pulse</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Inverse of previous value</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Toggle</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We won’t go through a step-by-step walkthrough of the JK flip-flop as we did for the SR latch. Instead, the best way to understand a JK flip-flop is to work with one directly.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch06.xhtml#proj10">Project #10</a> on <a href="ch06.xhtml#page_111">page 111</a>, where you can go hands-on with a JK flip-flop</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_41"><strong>T Flip-Flops</strong></h3>&#13;
<p class="noindent">Connecting J and K and treating them as a single input creates a flip-flop that only does one of two things on a clock pulse: it either toggles or maintains its value. To see why this is the case, review <a href="ch06.xhtml#ch6tab3">Table 6-3</a> and note the behavior when both J and K are 0 or both J and K are 1. Connecting J and K is a commonly used technique, and a flip-flop that behaves in this way is a <em>T flip-flop</em>. <a href="ch06.xhtml#ch6fig14">Figure 6-14</a> shows the symbol for a T flip-flop on the right.</p>&#13;
<span epub:type="pagebreak" id="page_101"/>&#13;
<div class="image" id="ch6fig14"><img src="../images/fig6-14.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-14: A JK flip-flop with J and K connected is known as a T flip-flop</em>.</p>&#13;
<p class="indent">So a T flip-flop simply toggles its value on clock pulse, when T is 1. <a href="ch06.xhtml#ch6tab4">Table 6-4</a> summarizes the behavior of the T flip-flop.</p>&#13;
<p class="tabcap" id="ch6tab4"><strong>Table 6-4:</strong> Summary of the Functionality of a T Flip-Flop</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>T</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Clock</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Q</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Operation</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Pulse</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Maintain previous value</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">Hold</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Pulse</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Inverse of previous value</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">Toggle</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="lev1_42"><strong>Using a Clock in a 3-Bit Counter</strong></h3>&#13;
<p class="noindent">To illustrate the use of a clock in a circuit, let’s build a 3-bit counter—a circuit that counts from 0 to 7 in binary. This circuit has three memory elements, each representing one bit of a 3-bit number. The circuit takes a clock input, and when a clock pulse occurs, the 3-bit number increments (increases by 1). Since all the bits represent a single number, it’s important that we synchronize their state changes with a clock. Let’s use T flip-flops to accomplish this.</p>&#13;
<p class="indent">First, see <a href="ch06.xhtml#ch6tab5">Table 6-5</a> as a review of counting in binary using a 3-bit number.</p>&#13;
<p class="tabcap" id="ch6tab5"><strong>Table 6-5:</strong> Counting in Binary with 3 Bits</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Binary</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Decimal</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">010</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">100</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">110</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/><a href="ch06.xhtml#ch6tab5">Table 6-5</a> presents our 3-bit number as a single value on each row. Let’s now assign each of the bits to memory elements labeled Q0, Q1, and Q2. Q0 is the least significant bit and Q2 is the most significant bit, as shown in <a href="ch06.xhtml#ch6tab6">Table 6-6</a>.</p>&#13;
<p class="tabcap" id="ch6tab6"><strong>Table 6-6:</strong> Counting in Binary, Each Bit Assigned to a Separate Memory Element</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>All 3 bits</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Q2</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Q1</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Q0</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Decimal</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">010</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">100</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">110</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">If we look at the Q columns in <a href="ch06.xhtml#ch6tab6">Table 6-6</a> individually, we can see a pattern emerge. As we count, Q0 toggles every time. Q1 toggles when Q0 was previously 1. Q2 toggles when both Q1 and Q0 were previously 1. In other words, apart from Q0, each bit toggles on the next count when all the preceding bits are 1. T flip-flops are perfect for implementing this counter, since toggling is what they do! Let’s look at how we can build a circuit to do this, shown in <a href="ch06.xhtml#ch6fig15">Figure 6-15</a>.</p>&#13;
<div class="image" id="ch6fig15"><img src="../images/fig6-15.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-15: A 3-bit counter built from T flip-flops</em></p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch6fig15">Figure 6-15</a>, all three T flip-flops use the same clock signal, so they are synchronized. T0 is connected to 5V, so Q0 toggles every time the clock pulses. T1 is connected to Q0, so a clock pulse causes Q1 to toggle only when Q0 is high. T2 is connected to Q0 AND Q1, so Q2 only toggles on a clock pulse when Q0 and Q1 are both high.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch06.xhtml#proj11">Project #11</a> on <a href="ch06.xhtml#page_113">page 113</a>, where you can build your very own 3-bit counter</em>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_103"/>Consider how we might use such a counter in conjunction with the vending machine circuit we designed earlier. Instead of simply tracking whether a coin is inserted or not, we can track the count of coins inserted, at least up to seven coins! For a vending machine counter to be useful, it also needs to be able to count down, since vending an item should decrease the coin count. I won’t cover the specifics of how to add a counter to the vending circuit here, but feel free to experiment on your own. Designs for counter circuits that count up and down are available online, or you can use an up/down counter IC like the 74191.</p>&#13;
<p class="indent">We’ve constructed a counter from T flip-flops, which was built from JK flip-flops, which are digital logic circuits based on transistors! This again demonstrates how encapsulation allows us to build complex systems, hiding the details along the way.</p>&#13;
<h3 class="h3" id="lev1_43"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we covered sequential logic circuits and clock signals. You learned that unlike combinational logic circuits, sequential circuits have memory, a record of past state. You learned about the SR latch, a simple single-bit memory device. We saw how synchronizing multiple circuit components, including memory devices, can be accomplished with a clock signal, an electrical signal that alternates its voltage level between high and low. A clocked single-bit memory device is known as a flip-flop, which allows for state changes to only occur in synchronization with the clock signal. You learned how JK flip-flops work, how T flip-flops can be constructed from JK flip-flops, and finally how a clock and T flip-flops can be used together to create a 3-bit counter.</p>&#13;
<p class="indent">Memory and clocks are key components of modern computing devices, and in the next chapter, we’ll see how they play a role in today’s computers. There you’ll learn about computer hardware—memory, processor, and I/O.</p>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_104"/>&#13;
<p class="exercise" id="proj6"><strong><span class="black1">PROJECT #6: CONSTRUCT AN SR LATCH USING NOR GATES</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll build an SR latch on a breadboard. You’ll connect output Q to an LED to easily observe the state. You should test setting S and R high and low and observe the output.</p>&#13;
<p class="exercise-parai">For this project, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">Breadboard</li>&#13;
<li class="noindent_sidebar">LED</li>&#13;
<li class="noindent_sidebar">Current-limiting resistor to use with your LED (approximately 220Ω)</li>&#13;
<li class="noindent_sidebar">Jumper wires</li>&#13;
<li class="noindent_sidebar">7402 IC (contains four NOR gates)</li>&#13;
<li class="noindent_sidebar">5-volt power supply</li>&#13;
<li class="noindent_sidebar">Two 470Ω resistors</li>&#13;
<li class="noindent_sidebar">Two switches or pushbuttons that fit a breadboard</li>&#13;
<li class="noindent_sidebar">Optional: An additional 220Ω resistor and another LED</li>&#13;
</ul>&#13;
<p class="exercise-parai">As a reminder, see the sections “Buying Electronic Components” on <a href="appb.xhtml#page_333">page 333</a> and “Powering Digital Circuits” on <a href="appb.xhtml#page_336">page 336</a> if you need help on those topics. Also, review <a href="ch04.xhtml#proj4">Project #4</a> on <a href="ch04.xhtml#page_68">page 68</a> for a reminder about how to use buttons/switches with pull-down resistors. Connect your components as shown in <a href="ch06.xhtml#ch6fig16">Figure 6-16</a> to build an SR latch. Note that the NOR gates are arranged differently within the 7402 IC as compared to the layout of gates in other ICs like the 7408 (AND gates) and the 7432 (OR gates), so be sure to use the right pins for inputs and outputs.</p>&#13;
<div class="image" id="ch6fig16"><img src="../images/fig6-16.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-16: Wiring diagram for an SR latch built from a 7402 IC</em></p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_105"/>Once you’ve constructed the SR latch circuit as shown in <a href="ch06.xhtml#ch6fig16">Figure 6-16</a>, connect S and R to buttons (or switches) with pull-down resistors, as shown in <a href="ch06.xhtml#ch6fig17">Figure 6-17</a>. This allows you to easily set the value of S or R just by pressing a button.</p>&#13;
<div class="image" id="ch6fig17"><img src="../images/fig6-17.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-17: Using buttons and pull-down resistors to control inputs S and R</em></p>&#13;
<p class="exercise-parai">Once you have connected your buttons to the SR latch, try setting S or R to high or low by pressing and releasing the button. Observe the results. Does Q turn on when you press S and stay on even after you release S? Does Q turn off when you press R and stay off even after you release R? If you want to also see the value of <span class="bar">Q</span>, which should always be the opposite of Q, just connect another 220Ω resistor and another LED to pins 1 and 6 of the IC.</p>&#13;
<p class="exercise-parai">When you initially apply power, the output will be in an unpredictable state. That is, the circuit may start up with either Q = 0 or Q = 1. Or maybe your circuit reliably starts up with Q as a certain value. The reason for this unpredictability is that this design leads to a <em>race condition</em>. If S = 0 and R = 0 when power is applied, both N1 and N2 try to output a 1. One of them does this slightly faster (thus, a <em>race</em>). If N1 outputs a 1 first, N2 goes low and Q is 0. If N2 outputs a 1 first, N1 goes low and Q is 1. This can be addressed by holding the R button down during startup (to force Q = 0) and then releasing the R button after startup.</p>&#13;
<p class="exercise-parai">Keep this circuit around, we’ll use it in the next project.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj7"><strong><span class="black1">PROJECT #7: CONSTRUCT A BASIC VENDING MACHINE CIRCUIT</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll build the vending machine circuit described earlier in this chapter. You can reuse your SR latch from the last project as the memory unit. Be sure to use current limiting resistors on your LEDs and pull-down resistors for your button inputs. Test the circuit to make sure it works as expected. To reset the circuit, press the R button on the SR latch.</p>&#13;
<p class="exercise-parai">For this project, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">The 7402 SR latch on a breadboard you constructed in <a href="ch06.xhtml#proj6">Project #6</a></li>&#13;
<li class="noindent_sidebar">An additional LED</li>&#13;
<li class="noindent_sidebar"><span epub:type="pagebreak" id="page_106"/>An additional current-limiting resistor to use with your LED (approximately 220Ω)</li>&#13;
<li class="noindent_sidebar">Jumper wires</li>&#13;
<li class="noindent_sidebar">7408 IC (contains four AND gates)</li>&#13;
<li class="noindent_sidebar">An additional pushbutton or switch that will fit a breadboard</li>&#13;
<li class="noindent_sidebar">An additional pull-down resistor to use with your button (approximately 470Ω)</li>&#13;
</ul>&#13;
<p class="exercise-parai">As a reminder, see the sections “Buying Electronic Components” on <a href="appb.xhtml#page_333">page 333</a> and “Powering Digital Circuits” on <a href="appb.xhtml#page_336">page 336</a> if you need help on these topics.</p>&#13;
<p class="exercise-parai">In the circuit diagram shown in <a href="ch06.xhtml#ch6fig18">Figure 6-18</a>, the IC pin numbers are indicated in boxes. Although they are not shown in the diagram, be sure to connect both the 7402 and the 7408 chips to 5V and ground (pins 14 and 7, respectively).</p>&#13;
<div class="image" id="ch6fig18"><img src="../images/fig6-18.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-18: Wiring diagram for a basic vending machine circuit</em></p>&#13;
<p class="exercise-parai">The bottom portion of <a href="ch06.xhtml#ch6fig18">Figure 6-18</a> is the circuit you built in the previous project. The only difference is that now the S button represents the COIN button and the output Q LED now represents the COIN indicator LED. To build the full circuit, you only need to add the top portion of the circuit and connect the two parts together as shown.</p>&#13;
<p class="exercise-parai">Once your circuit is built, you should see that when you press the COIN button, the COIN LED lights. Pressing the VEND button should cause the VEND button to light, but only if the COIN LED is already lit. Press the RESET button to reset the circuit.</p>&#13;
<p class="exercise-parai">Keep this circuit around, we’ll use it in the next project.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_107"/>&#13;
<p class="exercise" id="proj8"><strong><span class="black1">PROJECT #8: ADD A DELAYED RESET TO THE VENDING MACHINE CIRCUIT</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll add a delayed reset to the vending machine circuit from <a href="ch06.xhtml#proj7">Project #7</a>. You’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">The vending machine circuit you constructed in <a href="ch06.xhtml#proj7">Project #7</a></li>&#13;
<li class="noindent_sidebar">4.7kΩ resistor</li>&#13;
<li class="noindent_sidebar">220μF electrolytic capacitor</li>&#13;
<li class="noindent_sidebar">Jumper wires</li>&#13;
</ul>&#13;
<p class="exercise-parai">There are multiple types of capacitors; a discussion of the various types is outside the scope of this book. For this project, you’ll use an <em>electrolytic capacitor</em> (<a href="ch06.xhtml#ch6fig19">Figure 6-19</a>). When connecting your capacitor, note that electrolytic capacitors are polarized, meaning one pin is negative and one is positive. Look for a negative sign or arrow indicating the negative terminal. Sometimes the negative terminal is shorter. In <a href="ch06.xhtml#ch6fig21">Figure 6-21</a>, the negative terminal should connect to ground.</p>&#13;
<div class="image" id="ch6fig19"><img src="../images/fig6-19.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-19: An electrolytic capacitor. The shorter pin with a stripe/arrow is the negative pin.</em></p>&#13;
<p class="exercise-parai"><a href="ch06.xhtml#ch6fig20">Figure 6-20</a> shows circuit diagram symbols for capacitors. On the left is the symbol for a nonpolarized capacitor. In the middle and on the right are symbols used to represent polarized capacitors. Both polarized symbols provide a means of identifying the positive and negative terminals of the capacitor.</p>&#13;
<div class="image" id="ch6fig20"><img src="../images/fig6-20.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-20: Circuit diagram symbols for capacitors</em></p>&#13;
<p class="exercise-parai"><a href="ch06.xhtml#ch6fig21">Figure 6-21</a> shows how you can add the capacitor-based delayed reset to the vending machine circuit, replacing the manual reset. Keep reading past the figure for more details on how to build this circuit.</p>&#13;
<span epub:type="pagebreak" id="page_108"/>&#13;
<div class="image" id="ch6fig21"><img src="../images/fig6-21.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-21: Wiring diagram for a vending machine circuit with delayed reset</em></p>&#13;
<p class="exercise-parai">If you still have a manual reset switch or button connected to R (pin 5 on the 7402 chip), be sure to disconnect it, as its presence will interfere with the delayed reset operation. In <a href="ch06.xhtml#ch6fig21">Figure 6-21</a>, note how the VEND output of our circuit (pin 3 on the 7408 chip), which goes high when vending occurs, is connected to the latch’s reset input through a new delay component. This new component consists of a resistor and capacitor that, together, introduce a delay of about 1 second to the reset. Let’s walk through what happens here:</p>&#13;
<ol>&#13;
<li class="noindent_sidebar">When a vend operation occurs, the output from the 7408 AND gate goes high.</li>&#13;
<li class="noindent_sidebar">The uncharged capacitor initially acts like a short circuit to ground, and the reset R to the latch is kept low, so no reset occurs at first.</li>&#13;
<li class="noindent_sidebar">Since no reset has happened yet, the VEND LED has an opportunity to light.</li>&#13;
<li class="noindent_sidebar">If the VEND button is held down, the AND output stays high, and the capacitor begins to charge.</li>&#13;
<li class="noindent_sidebar">After about 1 second, the capacitor is sufficiently charged and acts like an open circuit, effectively removing the connection to ground.</li>&#13;
<li class="noindent_sidebar">The reset input R to the latch goes high, and a reset occurs.</li>&#13;
</ol>&#13;
<p class="exercise-parai">A few things to note about this design:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">The VEND button must be held down to give the capacitor time to charge.</li>&#13;
<li class="noindent_sidebar">The circuit still may start with the COIN LED already on. Just hold VEND to reset. This could be addressed with a power-on reset circuit, but that’s outside the scope of this project.</li>&#13;
<li class="noindent_sidebar"><span epub:type="pagebreak" id="page_109"/>If adding the reset component causes the entire vending circuit to do nothing, the R input is likely stuck at a high voltage. Check the voltage on pin 5 of the 7402 to see if it is high (anything above 0.8V) when it should be low. If you run into this problem, double-check the values of the 4.7kΩ resistor and the 220μF capacitor. Also check your wiring; a loose connection or a jumper wire in the wrong row can throw things off.</li>&#13;
<li class="noindent_sidebar">I chose the capacitance and resistance values because they produce a delay of about 1 second. You could use other values. However, changing these values runs the risk of causing the voltage at the R input to be too high when it should be low, as just noted.</li>&#13;
</ul>&#13;
<p class="exercise-parai">Your completed circuit should look something like the circuit shown in <a href="ch06.xhtml#ch6fig22">Figure 6-22</a>, although your specific layout will probably vary.</p>&#13;
<div class="image" id="ch6fig22"><img src="../images/fig6-22.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-22: Vending machine circuit with delayed reset on a breadboard</em></p>&#13;
<p class="exercise-parai">I recommend that you keep the SR latch part of your circuit intact, as you’ll use it again in the following projects. You can remove the other components from the board, but keep the portion from <a href="ch06.xhtml#proj6">Project #6</a>. Or you can just build another SR latch when you need to.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj9"><strong><span class="black1">PROJECT #9: USING A LATCH AS A MANUAL CLOCK</span></strong></p>&#13;
<p class="exercise-para">You’re going to need a clock signal for the projects later in the chapter. In this project, you’ll configure your previously constructed SR latch as a manual clock.</p>&#13;
<p class="exercise-parai">As you learned earlier, a clock input needs to alternate between high voltage and low voltage. You could try to implement a clock by moving a wire between ground and 5V. That would certainly cause the voltage to alternate, but not in the way you want. When you were moving the wire, some of the time the wire wouldn’t be connected to anything. During those moments, the voltage on the input clock pin would “float,” and you’d get unpredictable behavior in your circuit. That’s not a good option.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_110"/>Or you could add an oscillator that would automatically generate pulses on a regular cadence, say one pulse every second. That’s how clocks typically work in the real world. A common IC is designed for this purpose: the 555 timer. However, for the upcoming exercises you need to be able to carefully observe state changes in your circuits, so what you really need is a <em>manual</em> clock, that is, a clock that only goes high or low when you tell it to. In a sense, such a manual clock isn’t even really a clock, because it won’t alternate states on a regular cadence. That said, whether it’s technically a clock or not isn’t terribly relevant—we need a device you can use to manually trigger state changes.</p>&#13;
<p class="exercise-parai">You may be tempted to try using a regular pushbutton and a pull-down resistor as a clock, as shown in <a href="ch06.xhtml#ch6fig23">Figure 6-23</a>. After all, pressing the button makes the voltage go high, and releasing the button makes the voltage go low.</p>&#13;
<div class="image" id="ch6fig23"><img src="../images/fig6-23.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-23: Simple switch with pull-down resistor as a CLK input (this won't work very well)</em></p>&#13;
<p class="exercise-parai">Unfortunately, the design in <a href="ch06.xhtml#ch6fig23">Figure 6-23</a> actually makes a very poor manual clock. The problem is that mechanical buttons and switches tend to “bounce.” Internally the switch has metal contacts that connect when the switch is closed. The act of closing the switch results in an initial connection between the contacts, but then the contacts separate and come back together, sometimes multiple times, before the switch finally settles into a closed state. The same thing happens when the switch is opened, except in reverse. A simple button press or flip of a switch results in the voltage jumping high and low multiple times. This is called <em>switch bounce</em>, illustrated in <a href="ch06.xhtml#ch6fig24">Figure 6-24</a>.</p>&#13;
<div class="image" id="ch6fig24"><img src="../images/fig6-24.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-24: Switch bounce, not what we want in a clock</em></p>&#13;
<p class="exercise-parai"><em>Debounce circuits</em> are hardware options for removing bounce. One such debounce circuit is based on an SR latch, which conveniently, you have already constructed! If you connect S and R to switches, those inputs to the latch still bounce, but the output of the latch (Q) holds its value, as shown in <a href="ch06.xhtml#ch6fig25">Figure 6-25</a>. This is an effective way of removing switch bounce.</p>&#13;
<span epub:type="pagebreak" id="page_111"/>&#13;
<div class="image" id="ch6fig25"><img src="../images/fig6-25.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-25: An SR latch produces a clean output even when its inputs bounce.</em></p>&#13;
<p class="exercise-parai">To use an SR latch as a clock, press S to set the clock signal high, and then press R to set the clock signal low. Just don’t press both buttons at the same time! You can use the SR latch you constructed in <a href="ch06.xhtml#proj6">Project #6</a> as a clock. If you previously removed the reset button/switch from pin 5 as part of <a href="ch06.xhtml#proj8">Project #8</a>, connect it again. The complete SR latch as a manual clock should be wired as shown in <a href="ch06.xhtml#ch6fig26">Figure 6-26</a>.</p>&#13;
<div class="image" id="ch6fig26"><img src="../images/fig6-26.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-26: A debounced manual clock created from two buttons/switches and an SR latch</em></p>&#13;
<p class="exercise-parai">Press S to set the clock pulse high, and press R to set the clock pulse low. Now you have a manual clock you can use in the following projects.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj10"><strong><span class="black1">PROJECT #10: TEST A JK FLIP-FLOP</span></strong></p>&#13;
<p class="exercise-para">Although you could build a JK flip-flop from other gates, it is conveniently sold as an integrated circuit, so you can save yourself some trouble. The 7473 chip contains two negative edge–triggered JK flip-flops. In this project, you’ll use this integrated circuit to test the functionality of a single JK flip-flop. You’ll try setting J and K either high or low, and then send a clock pulse through the circuit. Connect an LED to the output Q to easily see the state change.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_112"/>For this project, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">The SR latch configured as a clock (discussed in <a href="ch06.xhtml#proj9">Project #9</a>)</li>&#13;
<li class="noindent_sidebar">7473 IC (contains two JK flip-flops)</li>&#13;
<li class="noindent_sidebar">Jumper wires</li>&#13;
<li class="noindent_sidebar">LED</li>&#13;
<li class="noindent_sidebar">Current-limiting resistor to use with your LED (approximately 220Ω)</li>&#13;
</ul>&#13;
<p class="exercise-parai">As a reminder, see “Buying Electronic Components” on <a href="appb.xhtml#page_333">page 333</a> and “Powering Digital Circuits” on <a href="appb.xhtml#page_336">page 336</a> if you need help on those topics. <a href="ch06.xhtml#ch6fig27">Figure 6-27</a> shows the pinout diagram for the 7473 IC.</p>&#13;
<div class="image" id="ch6fig27"><img src="../images/fig6-27.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-27: Pinout for the 7473 IC</em></p>&#13;
<p class="exercise-parai">The 7473 IC contains two JK flip-flops as shown in <a href="ch06.xhtml#ch6fig27">Figure 6-27</a>. Note that the voltage and ground connections aren’t in the “usual” locations and instead are pins 4 and 11, respectively. Also, note that the CLK (clock) inputs are marked with a circle, indicating that this circuit is negative edge–triggered; you should expect the state to change when the clock pulse falls. Since you’re using an SR latch for your manual clock, this means you’ll see the JK state change when you press the SR latch’s R input button.</p>&#13;
<p class="exercise-parai">An additional input for each JK flip-flop wasn’t mentioned in the chapter: <span class="bar">CLR</span>. When this pin is set low, the flip-flop clears the saved bit (Q = 0). <span class="bar">CLR</span> is asynchronous, meaning it doesn’t wait on the clock pulse. The line shown above <span class="bar">CLR</span> means it is <em>active low</em>, meaning the saved bit is cleared when the input is set low. <span class="bar">CLR</span> is also sometimes called Reset or R, not to be confused with the R input of our SR latch. Connect the JK flip-flop’s <span class="bar">CLR</span> input (pin 2) to 5V to keep your flip-flop from resetting. For testing a single flip-flop, you can connect the chip as shown in <a href="ch06.xhtml#ch6fig28">Figure 6-28</a>.</p>&#13;
<span epub:type="pagebreak" id="page_113"/>&#13;
<div class="image" id="ch6fig28"><img src="../images/fig6-28.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-28: A simple JK test circuit</em></p>&#13;
<p class="exercise-parai">Using your previously built SR latch as a clock, connect the SR latch’s output Q (pins 3 and 4 on the 7402) to the clock input of the 7473 (pin 1). Now, try setting inputs J (pin 14) and K (pin 3) on the 7473 to 5V or ground. You should see that doing so has no effect on the JK flip-flop’s output LED until the clock transitions from high to low. Reminder: pulse the SR latch clock by first pressing S and then pressing R to set the clock signal high and then low. Flip back to <a href="ch06.xhtml#ch6tab3">Table 6-3</a> to see the expected functionality of a JK flip-flop and ensure that your circuit works as expected.</p>&#13;
<p class="exercise-parai">Keep this circuit intact for the next project.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<p class="exercise" id="proj11"><strong><span class="black1">PROJECT #11: CONSTRUCT A 3-BIT COUNTER</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll build the 3-bit counter described earlier in this chapter. Connect the Q outputs to LEDs to easily observe the output.</p>&#13;
<p class="exercise-parai">For this project, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">The circuit constructed in <a href="ch06.xhtml#proj10">Project #10</a> (including the manual clock from <a href="ch06.xhtml#proj9">Project #9</a>)</li>&#13;
<li class="noindent_sidebar">An additional 7473 IC</li>&#13;
<li class="noindent_sidebar">7408 IC (contains four AND gates)</li>&#13;
<li class="noindent_sidebar"><span epub:type="pagebreak" id="page_114"/>47kΩ resistor</li>&#13;
<li class="noindent_sidebar">10μF electrolytic capacitor</li>&#13;
<li class="noindent_sidebar">An additional button or switch</li>&#13;
<li class="noindent_sidebar">Jumper wires</li>&#13;
<li class="noindent_sidebar">Two additional LEDs</li>&#13;
<li class="noindent_sidebar">Two additional current-limiting resistors to use with your LEDs (approximately 220Ω each)</li>&#13;
</ul>&#13;
<p class="exercise-parai">Connect everything as shown in <a href="ch06.xhtml#ch6fig29">Figure 6-29</a>. Pin numbers on ICs are shown in boxes.</p>&#13;
<div class="image" id="ch6fig29"><img src="../images/fig6-29.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-29: A 3-bit counter built from T flip-flops, pin numbers shown</em></p>&#13;
<p class="exercise-parai">In addition to the pin connections shown in <a href="ch06.xhtml#ch6fig29">Figure 6-29</a>, be sure to make the following connections:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">Both 7473 ICs need pins 4 and 11 connected to 5V and ground, respectively.</li>&#13;
<li class="noindent_sidebar">The 7408 should have pin 7 connected to ground and pin 14 to 5V.</li>&#13;
<li class="noindent_sidebar">Q0, Q1, and Q2 should connect to LEDs through 220Ω resistors so you can see the bits update.</li>&#13;
<li class="noindent_sidebar">The manual clock output (pins 3 and 4 on the 7402) should be connected to CLK on all three flip-flops (pins 1 and 5 on the first 7473, and pin 1 on the second 7473).</li>&#13;
</ul>&#13;
<p class="exercise-parai">This circuit starts up in an unpredictable state. You can correct this manually by resetting all three flip-flops, but that’s tedious. Instead, add a <em>power-on reset</em> circuit that ensures the flip-flops all start with their output = 0. Each flip-flop in the 7473 package has a <span class="bar">CLR</span> input, which when held low, resets the flip-flop, regardless of the state of the clock. You want <span class="bar">CLR</span> to go low on startup for a brief time and then go high and stay there. This ensures that the counter starts at zero when powered on. For good measure, you can also add a COUNTER RESET button that manually resets the counter when pressed. This reset capability is shown in <a href="ch06.xhtml#ch6fig30">Figure 6-30</a>.</p>&#13;
<span epub:type="pagebreak" id="page_115"/>&#13;
<div class="image" id="ch6fig30"><img src="../images/fig6-30.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 6-30: Power-on reset circuit for 3-bit binary counter</em></p>&#13;
<p class="exercise-parai">When power is initially applied to the circuit shown in <a href="ch06.xhtml#ch6fig30">Figure 6-30</a>, the capacitor acts like a short circuit, and <span class="bar">CLR</span> is held low, setting the circuit to its initial state. Once the capacitor is charged, it acts like an open circuit, <span class="bar">CLR</span> goes high, and the circuit is ready to use. The COUNTER RESET button or switch, when pushed, also causes <span class="bar">CLR</span> to go low and reset the circuit. This circuit needs to be connected to <span class="bar">CLR</span> inputs: pins 2 and 6 on the first 7473 chip, and pin 2 and the second 7473 chip. In <a href="ch06.xhtml#proj10">Project #10</a>, pin 2 on the first 7473 was connected to 5V; be sure to disconnect it before you hook up the power-on reset circuit. Remember to orient the terminals of your electrolytic capacitor correctly—the negative terminal should connect to ground.</p>&#13;
<p class="exercise-parai">With the power-on reset in place, the circuit should start with your counter at 000. Sending a clock pulse to the circuit should cause the counter to increment by 1 when the clock edge falls. Reminder: pulse the SR latch clock by pressing S to set the clock signal high and pressing R to set the clock signal low. Test counting from 000 to 111 and ensure the counter works as expected.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_116"/>&#13;
</body></html>