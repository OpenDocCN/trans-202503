<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_66"/><span epub:type="pagebreak" id="page_67"/><strong><span class="big">3</span><br/>REFERENCE TYPES</strong></h2>&#13;
<p class="quote"><em>Everyone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it?<br/>—Brian Kernighan</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent"><em>Reference types</em> store the memory addresses of objects. These types enable efficient programming, and many elegant design patterns feature them. In this chapter, I’ll discuss the two kinds of reference types: pointers and references. I’ll also discuss <code>this</code>, <code>const</code>, and <code>auto</code> along the way.</p>&#13;
<h3 class="h3" id="ch03lev1sec1"><strong>Pointers</strong></h3>&#13;
<p class="noindent"><em>Pointers</em> are the fundamental mechanism used to refer to memory addresses. Pointers encode both pieces of information required to interact with another object—that is, the object’s address and the object’s type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>You can declare a pointer’s type by appending an asterisk (<code>*</code>) to the pointed-to type. For example, you declare a pointer to <code>int</code> called <code>my_ptr</code> as follows:</p>&#13;
<pre>int* my_ptr;</pre>&#13;
<p class="noindent">The format specifier for a pointer is <code>%p</code>. For example, to print the value in <code>my_ptr</code>, you could use the following:</p>&#13;
<pre>printf("The value of my_ptr is %p.", my_ptr);</pre>&#13;
<p class="indent">Pointers are very low-level objects. Although they play a central role in most C programs, C++ offers higher-level, sometimes more efficient, constructs that obviate the need to deal with memory addresses directly. Nonetheless, pointers are a foundational concept that you’ll no doubt come across in your system-programming travels.</p>&#13;
<p class="indent">In this section, you’ll learn how to find the address of an object and how to assign the result to a pointer variable. You’ll also learn how to perform the opposite operation, which is called <em>dereferencing</em>: given a pointer, you can obtain the object residing at the corresponding address.</p>&#13;
<p class="indent">You’ll learn more about <em>arrays</em>, the simplest construct for managing an object collection, as well as how arrays relate to pointers. As low-level constructs, arrays and pointers are relatively dangerous. You’ll learn about what can go wrong when pointer- and array-based programs go awry.</p>&#13;
<p class="indent">This chapter introduces two special kinds of pointers: <code>void</code> pointers and <code>std::byte</code> pointers. These very useful types have some special behaviors that you’ll need to keep in mind. Additionally, you’ll learn how to encode empty pointers with <code>nullptr</code> and how to use pointers in Boolean expressions to determine whether they’re empty.</p>&#13;
<h4 class="h4" id="ch03lev2sec1"><strong><em>Addressing Variables</em></strong></h4>&#13;
<p class="noindent">You can obtain the address of a variable by prepending the <em>address-of operator</em> (<code>&amp;</code>). You might want to use this operator to initialize a pointer so it “points to” the corresponding variable. Such programming requirements arise very often in operating systems programming. For example, major operating systems, such as Windows, Linux, and FreeBSD, have interfaces that use pointers heavily.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex01">Listing 3-1</a> demonstrates how to obtain the address of an <code>int</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int gettysburg{}; <span class="ent">➊</span>&#13;
  printf("gettysburg: %d\n", gettysburg); <span class="ent">➋</span>&#13;
  int *gettysburg_address = &amp;gettysburg; <span class="ent">➌</span>&#13;
  printf("&amp;gettysburg: %p\n", gettysburg_address); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex01"/><em>Listing 3-1: A program featuring the address-of operator <code>&amp;</code> and a terrible pun</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/>First, you declare the integer <code>gettysburg</code> <span class="ent">➊</span> and print its value <span class="ent">➋</span>. Then you declare a pointer, called <code>gettysburg_address</code>, to that integer’s address <span class="ent">➌</span>; notice that the asterisk prepends the pointer and the ampersand prepends <code>gettysburg</code>. Finally, you print the pointer to the screen <span class="ent">➍</span> to reveal the <code>gettysburg</code> integer’s address.</p>&#13;
<p class="indent">If you run <a href="ch03.xhtml#ch03ex01">Listing 3-1</a> on Windows 10 (x86), you should see the following output:</p>&#13;
<pre>gettysburg: 0&#13;
&amp;gettysburg: 0053FBA8</pre>&#13;
<p class="indent">Running the same code on Windows 10 x64 yields the following output:</p>&#13;
<pre>gettysburg: 0&#13;
&amp;gettysburg: 0000007DAB53F594</pre>&#13;
<p class="indent">Your output should have an identical value for <code>gettysburg</code>, but <code>gettysburg_address</code> should be different each time. This variation is due to <em>address space layout randomization</em>, which is a security feature that scrambles the base address of important memory regions to hamper exploitation.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>Address Space Layout Randomization</strong></p>&#13;
<p class="noindent">Why does address space layout randomization hamper exploitation? When a hacker finds an exploitable condition in a program, they can sometimes cram a malicious payload into user-provided input. One of the first security features designed to prevent a hacker from getting this malicious payload to execute is to make all data sections non-executable. If the computer attempts to execute data as code, then the theory is that it knows something’s amiss and should terminate the program with an exception.</p>&#13;
<p class="indent">Some exceedingly clever hackers figured out how to repurpose executable code instructions in totally unforeseen ways by carefully crafting exploits containing so-called <em>return-oriented programs</em>. These exploits could arrange to invoke the relevant system APIs to mark their payload executable, hence defeating the non-executable-memory mitigation.</p>&#13;
<p class="indent">Address space layout randomization combats return-oriented programming by randomizing memory addresses, making it difficult to repurpose existing code because the attacker doesn’t know where it resides in memory.</p>&#13;
</div>&#13;
<p class="indent">Also note that in the outputs for <a href="ch03.xhtml#ch03ex01">Listing 3-1</a>, <code>gettysburg_address</code> contains 8 hexadecimal digits (4 bytes) for an x86 architecture and 16 hexadecimal digits (8 bytes) for an x64 architecture. This should make some sense because on modern desktop systems, the pointer size is the same as the CPU’s general-purpose register. An x86 architecture has 32-bit (4-byte) general-purpose registers, whereas an x64 architecture has 64-bit (8-byte) general-purpose registers.</p>&#13;
<h4 class="h4" id="ch03lev2sec2"><strong><em><span epub:type="pagebreak" id="page_70"/>Dereferencing Pointers</em></strong></h4>&#13;
<p class="noindent">The <em>dereference operator</em> (<code>*</code>) is a unary operator that accesses the object to which a pointer refers. This is the inverse operation of the address-of operator. Given an address, you can obtain the object residing there. Like the address-of operator, system programmers use the dereference operator very often. Many operating system APIs will return pointers, and if you want to access the referred-to object, you’ll use the dereference operator.</p>&#13;
<p class="indent">Unfortunately, the dereference operator can cause a lot of notation-based confusion for beginners because the dereference operator, the pointer declaration, and multiplication all use asterisks. Remember that you append an asterisk to the end of the pointed-to object’s type to declare a pointer; however, you prepend the dereference operator—an asterisk—to the pointer, like this:</p>&#13;
<pre>*gettysburg_address</pre>&#13;
<p class="indent">After accessing an object by prepending the dereference operator to a pointer, you can treat the result like any other object of the pointed-to type. For example, because <code>gettysburg</code> is an integer, you can write the value 17325 into <code>gettysburg</code> using <code>gettysburg_address</code>. The correct syntax is as follows:</p>&#13;
<pre>*gettysburg_address = 17325;</pre>&#13;
<p class="indent">Because the dereferenced pointer—that is, <code>*gettysburg_address</code>—appears on the left side of the equal sign, you’re writing to the address where <code>gettysburg</code> is stored.</p>&#13;
<p class="indent">If a dereferenced pointer appears anywhere except the left side of an equal sign, you’re reading from the address. To retrieve the <code>int</code> pointed to by <code>gettysburg_address</code>, you just tack on the dereference operator. For instance, the following statement will print the value stored in <code>gettysburg</code>:</p>&#13;
<pre>printf("%d", *gettysburg_address);</pre>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex02">Listing 3-2</a> uses the dereference operator to read and write.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int gettysburg{};&#13;
  int* gettysburg_address = &amp;gettysburg; <span class="ent">➊</span>&#13;
  printf("Value at gettysburg_address: %d\n", *gettysburg_address); <span class="ent">➋</span>&#13;
  printf("Gettysburg Address: %p\n", gettysburg_address); <span class="ent">➌</span>&#13;
  *gettysburg_address = 17325; <span class="ent">➍</span>&#13;
  printf("Value at gettysburg_address: %d\n", *gettysburg_address); <span class="ent">➎</span>&#13;
  printf("Gettysburg Address: %p\n", gettysburg_address); <span class="ent">➏</span>&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Value at gettysburg_address: 0 <span class="ent">➋</span></span>&#13;
<span class="color1">Gettysburg Address: 000000B9EEEFFB04 <span class="ent">➌</span></span>&#13;
<span class="color1"><span epub:type="pagebreak" id="page_71"/>Value at gettysburg_address: 17325 <span class="ent">➎</span></span>&#13;
<span class="color1">Gettysburg Address: 000000B9EEEFFB04 <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch03ex02"/><em>Listing 3-2: An example program illustrating reads and writes using a pointer (output is from a Windows 10 x64 machine)</em></p>&#13;
<p class="indent">First, you initialize <code>gettysburg</code> to zero. Then, you initialize the pointer <code>gettysburg_address</code> to the address of <code>gettysburg</code> <span class="ent">➊</span>. Next, you print the <code>int</code> pointed to by <code>gettysburg_address</code> <span class="ent">➋</span> and the value of <code>gettysburg_address</code> itself <span class="ent">➌</span>.</p>&#13;
<p class="indent">You write the value 17325 into the memory pointed to by <code>gettysburg_address</code> <span class="ent">➍</span> and then print the pointed-to value <span class="ent">➎</span> and address <span class="ent">➏</span> again.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex02">Listing 3-2</a> would be functionally identical if you assigned the value 17325 directly to <code>gettysburg</code> instead of to the <code>gettysburg_address</code> pointer, like this:</p>&#13;
<pre>  gettysburg = 17325;</pre>&#13;
<p class="indent">This example illustrates the close relationship between a pointed-to object (<code>gettysburg</code>) and a dereferenced pointer to that object (<code>*gettysburg_address)</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec3"><strong><em>The Member-of-Pointer Operator</em></strong></h4>&#13;
<p class="noindent">The <em>member-of-pointer operator</em>, or <em>arrow operator</em> (<code>-&gt;</code>), performs two simultaneous operations:</p>&#13;
<ul>&#13;
<li class="noindent">It dereferences a pointer.</li>&#13;
<li class="noindent">It accesses a member of the pointed-to object.</li>&#13;
</ul>&#13;
<p class="indent">You can use this operator to reduce <em>notational friction</em>, the resistance a programmer feels in expressing their intent in code, when you’re handling pointers to classes. You’ll need to handle pointers to classes in a variety of design patterns. For example, you might want to pass a pointer to a class as a function parameter. If the receiving function needs to interact with a member of that class, the member-of-pointer operator is the tool for the job.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex03">Listing 3-3</a> employs the arrow operator to read the <code>year</code> from a <code>ClockOfTheLongNow</code> object (which you implemented in <a href="ch02.xhtml#ch02ex22">Listing 2-22</a> on <a href="ch02.xhtml#page_58">page 58</a>).</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  ClockOfTheLongNow clock;&#13;
  ClockOfTheLongNow* clock_ptr = &amp;clock; <span class="ent">➊</span>&#13;
  clock_ptr-&gt;set_year(2020); <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_72"/>  printf("Address of clock: %p\n", clock_ptr); <span class="ent">➌</span>&#13;
  printf("Value of clock's year: %d", clock_ptr-&gt;get_year()); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Address of clock: 000000C6D3D5FBE4 <span class="ent">➌</span></span>&#13;
<span class="color1">Value of clock's year: 2020 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch03ex03"/><em>Listing 3-3: Using a pointer and the arrow operator to manipulate the <code>ClockOfTheLongNow</code> object (output is from a Windows 10 x64 machine)</em></p>&#13;
<p class="indent">You declare a <code>clock</code> and then store its address in <code>clock_ptr</code> <span class="ent">➊</span>. Next, you use the arrow operator to set the <code>year</code> member of <code>clock</code> to 2020 <span class="ent">➋</span>. Finally, you print the address of <code>clock</code> <span class="ent">➌</span> and the value of <code>year</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">You could achieve an identical result using the dereference (<code>*</code>) and member of (<code>.</code>) operators. For example, you could have written the last line of <a href="ch03.xhtml#ch03ex03">Listing 3-3</a> as follows:</p>&#13;
<pre>  printf("Value of clock's year: %d", (*clock_ptr).get_year());</pre>&#13;
<p class="indent">First, you dereference <code>clock_ptr</code>, and then you access the <code>year</code>. Although this is equivalent to invoking the pointer-to-member operator, it’s a more verbose syntax and provides no benefit over its simpler alternative.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For now, use parentheses to emphasize the order of operations. <a href="ch07.xhtml#ch07">Chapter 7</a> walks through the precedents rules for operators.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec4"><strong><em>Pointers and Arrays</em></strong></h4>&#13;
<p class="noindent">Pointers share several characteristics with arrays. Pointers encode object location. Arrays encode the location and length of contiguous objects.</p>&#13;
<p class="indent">At the slightest provocation, an array will <em>decay</em> into a pointer. A decayed array loses length information and converts to a pointer to the array’s first element. For example:</p>&#13;
<pre>int key_to_the_universe[]{ 3, 6, 9 };&#13;
int* key_ptr = key_to_the_universe; // Points to 3</pre>&#13;
<p class="indent">First, you initialize an <code>int</code> array <code>key_to_the_universe</code> with three elements. Next, you initialize the <code>int</code> pointer <code>key_ptr</code> to <code>key_to_the_universe</code>, which decays into a pointer. After initialization, <code>key_ptr</code> points to the first element of <code>key_to_the_universe</code>.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex04">Listing 3-4</a> initializes an array containing <code>College</code> objects and passes the array to a function as a pointer.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct College {&#13;
  char name[256];&#13;
};&#13;
<span epub:type="pagebreak" id="page_73"/>void print_name(College* college_ptr<span class="ent">➊</span>) {&#13;
  printf("%s College\n", college_ptr-&gt;name<span class="ent">➋</span>);&#13;
}&#13;
&#13;
int main() {&#13;
  College best_colleges[] = { "Magdalen", "Nuffield", "Kellogg" <a id="_idTextAnchor113"/><a id="_idTextAnchor114"/>};&#13;
  print_name(best_colleges);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Magdalen College <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch03ex04"/><em>Listing 3-4: A program illustrating array decay into a pointer</em></p>&#13;
<p class="indent">The <code>print_name</code> function takes a pointer-to-<code>College</code> argument <span class="ent">➊</span>, so the <code>best_colleges</code> array decays into a pointer when you call <code>print_name</code>. Because arrays decay into pointers to their first element, <code>college_ptr</code> at <span class="ent">➊</span> points to the first <code>College</code> in <code>best_colleges</code>.</p>&#13;
<p class="indent">There’s another array decay in <a href="ch03.xhtml#ch03ex04">Listing 3-4</a> <span class="ent">➋</span> as well. You use the arrow operator (<code>-&gt;</code>) to access the <code>name</code> member of the <code>College</code> pointed to by <code>college_ptr</code>, which is itself a <code>char</code> array. The <code>printf</code> format specifier <code>%s</code> expects a C-style string, which is a <code>char</code> pointer, and <code>name</code> decays into a pointer to satisfy <code>printf</code>.</p>&#13;
<h5 class="h5" id="ch03lev3sec1"><strong>Handling Decay</strong></h5>&#13;
<p class="indent">Often, you pass arrays as two arguments:</p>&#13;
<ul>&#13;
<li class="noindent">A pointer to the first array element</li>&#13;
<li class="noindent">The array’s length</li>&#13;
</ul>&#13;
<p class="indent">The mechanism that enables this pattern is square brackets (<code>[]</code>), which work with pointers just as with arrays. <a href="ch03.xhtml#ch03ex05">Listing 3-5</a> employs this technique.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct College {&#13;
  char name[256];&#13;
};&#13;
&#13;
void print_names(College* colleges<span class="ent">➊</span>, size_t n_colleges<span class="ent">➋</span>) {&#13;
  for (size_t i = 0; i &lt; n_colleges; i++) { <span class="ent">➌</span>&#13;
    printf("%s College\n", colleges[i]<span class="ent">➍</span>.name<span class="ent">➎</span>);&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  College oxford[] = { "Magdalen", "Nuffield", "Kellogg" };&#13;
  print_names(oxfor<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/>d, sizeof(oxford) / sizeof(College));&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_74"/><span class="color1">Magdalen College</span>&#13;
<span class="color1">Nuffield College</span>&#13;
<span class="color1">Kellogg College</span></pre>&#13;
<p class="listing"><a id="ch03ex05"/><em>Listing 3-5: A program illustrating a common idiom for passing arrays to functions</em></p>&#13;
<p class="indent">The <code>print_names</code> function accepts an array in two arguments: a pointer to the first <code>College</code> element <span class="ent">➊</span> and the number of elements <code>n_colleges</code> <span class="ent">➋</span>. Within <code>print_names</code>, you iterate with a <code>for</code> loop and an index <code>i</code>. The value of <code>i</code> iterates from <code>0</code> to <code>n_colleges-1</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You extract the corresponding college name by accessing the <code>i</code>th element <span class="ent">➍</span> and then get the <code>name</code> member <span class="ent">➎</span>.</p>&#13;
<p class="indent">This pointer-plus-size approach to passing arrays is ubiquitous in C-style APIs, for example, in Windows or Linux system programming.</p>&#13;
<h5 class="h5" id="ch03lev3sec2"><strong>Pointer Arithmetic</strong></h5>&#13;
<p class="noindent">To obtain the address of the <code>n</code>th element of an array, you have two options. First, you can take the direct approach of obtaining the <code>n</code>th element with square brackets (<code>[]</code>) and then use the address-of (<code>&amp;</code>) operator:</p>&#13;
<pre>College* third_college_ptr = &amp;oxford[2];</pre>&#13;
<p class="indent"><em>Pointer arithmetic</em>, the set of rules for addition and subtraction on pointers, provides an alternate approach. When you add or subtract integers to pointers, the compiler figures out the correct byte offset using the size of the pointed-to type. For example, adding 4 to a <code>uint64_t</code> pointer adds 32 bytes: a <code>uint64_t</code> takes up 8 bytes, so 4 of them take up 32 bytes. The following is therefore equivalent to the previous option of obtaining the address of the <code>n</code>th element of an array:</p>&#13;
<pre>College* third_college_ptr = oxford + 2;</pre>&#13;
<h4 class="h4" id="ch03lev2sec5"><strong><em>Pointers Are Dangerous</em></strong></h4>&#13;
<p class="noindent">It’s not possible to convert a pointer to an array, which is a good thing. You shouldn’t need to, and besides it wouldn’t be possible in general for a compiler to recover the size of the array from a pointer. But the compiler can’t save you from all the dangerous things you might try to do.</p>&#13;
<h5 class="h5" id="ch03lev3sec3"><strong>Buffer Overflows</strong></h5>&#13;
<p class="noindent">For arrays and pointers, you can access arbitrary array elements with the bracket operator (<code>[]</code>) or with pointer arithmetic. These are very powerful tools for low-level programming because you can interact with memory more or less without abstraction. This gives you exquisite control over the system, which you need in some environments (for example, in system programming contexts like implementing network protocols or with embedded <span epub:type="pagebreak" id="page_75"/>controllers). With great power comes great responsibility, however, and you must be very careful. Simple mistakes with pointers can have catastrophic and mysterious consequences.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex06">Listing 3-6</a> performs low-level manipulation on two strings.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
int main() {&#13;
  char lower[] = "abc?e";&#13;
  char upper[] = "ABC?E";&#13;
  char* upper_ptr = upper;     <span class="ent">➊</span> // Equivalent: &amp;upper[0]&#13;
&#13;
  lower[3] = 'd';              <span class="ent">➋</span> // lower now contains a b c d e \0&#13;
  upper_ptr[3] = 'D';             // upper now contains A B C D E \0&#13;
&#13;
  char letter_d = lower[3];    <span class="ent">➌</span> // letter_d equals 'd'&#13;
  char letter_D = upper_ptr[3];   // letter_D equals 'D'&#13;
&#13;
  printf("lower: %s\nupper: %s", lower, upper); <span class="ent">➍</span>&#13;
&#13;
  lower[7] = 'g';              <span class="ent">➎</span> // Super bad. You must never do this.&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">lower: abcde <span class="ent">➍</span></span>&#13;
<span class="color1">upper: ABCDE</span>&#13;
<span class="color1">The time is 2:14 a.m. Eastern time, August 29th. Skynet is now online. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch03ex06"/><em>Listing 3-6: A program containing a buffer overflow</em></p>&#13;
<p class="indent">After initializing the strings <code>lower</code> and <code>upper</code>, you initialize <code>upper_ptr</code> pointing to the first element <span class="ent">➊</span> in <code>upper</code>. You then reassign the fourth elements of both <code>lower</code> and <code>upper</code> (the question marks) to <code>d</code> and <code>D</code> <span class="ent">➋</span> <span class="ent">➌</span>. Notice that <code>lower</code> is an array and <code>upper_ptr</code> is a pointer, but the mechanism is the same. So far, so good.</p>&#13;
<p class="indent">Finally, you make a major boo-boo by writing out-of-bounds memory <span class="ent">➎</span>. By accessing the element at index <code>7</code> <span class="ent">➍</span>, you’ve gone past the storage allotted to <code>lower</code>. No bounds checking occurs; this code compiles without warning.</p>&#13;
<p class="indent">At runtime, you get <em>undefined behavior</em>. Undefined behavior means the C++ language specification doesn’t prescribe what happens, so your program might crash, open a security vulnerability, or spawn an artificial general intelligence <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch03lev3sec4"><strong>The Connection Between Brackets and Pointer Arithmetic</strong></h5>&#13;
<p class="noindent">To understand the ramifications of out-of-bounds access, you must understand the connection between bracket operators and pointer arithmetic. Consider that you could have written <a href="ch03.xhtml#ch03ex06">Listing 3-6</a> with pointer arithmetic and dereference operators rather than bracket operators, as demonstrated in <a href="ch03.xhtml#ch03ex07">Listing 3-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_76"/>  char lower[] = "abc?e";&#13;
  char upper[] = "ABC?E";&#13;
  char* upper_ptr = &amp;upper[0];&#13;
&#13;
  *(lower + 3) = 'd';&#13;
  *(upper_ptr + 3) = 'D';&#13;
&#13;
  char letter_d = *(lower + 3); // lower decays into a pointer when we add&#13;
  char letter_D = *(upper_ptr + 3);&#13;
&#13;
  printf("lower: %s\nupper: %s", lower, upper);&#13;
&#13;
  *(lower + 7) = 'g'; <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex07"/><em>Listing 3-7: An equivalent program to <a href="ch03.xhtml#ch03ex06">Listing 3-6</a> that uses pointer arithmetic</em></p>&#13;
<p class="indent">The <code>lower</code> array has length 6 (the letters <em>a</em>–<em>e</em> plus a null terminator). It should now be clear why assigning <code>lower[7]</code> <span class="ent">➊</span> is perilous. In this case, you’re writing to some memory that doesn’t belong to <code>lower</code>. This can result in access violations, program crashes, security vulnerabilities, and corrupted data. These kinds of errors can be very insidious, because the point at which the bad write occurs might be far removed from the point at which the bug manifests.</p>&#13;
<h4 class="h4" id="ch03lev2sec6"><strong><em>void Pointers and std::byte Pointers</em></strong></h4>&#13;
<p class="noindent">Sometimes the pointed-to type is irrelevant. In such situations, you use the <em>void pointer</em> <code>void*</code>. The <code>void</code> pointers have important restrictions, the principal of which is that you cannot dereference a <code>void*</code>. Because the pointed-to type has been erased, dereferencing makes no sense (recall that the set of values for <code>void</code> objects is empty). For similar reasons, C++ forbids <code>void</code> pointer arithmetic.</p>&#13;
<p class="indent">Other times, you want to interact with raw memory at the byte level. Examples include low-level operations like copying raw data between files and memory, encryption, and compression. You cannot use a <code>void</code> pointer for such purposes because bit-wise and arithmetic operations are disabled. In such situations, you can use a <code>std::byte</code> pointer.</p>&#13;
<h4 class="h4" id="ch03lev2sec7"><strong><em>nullptr and Boolean Expressions</em></strong></h4>&#13;
<p class="noindent">Pointers can have a special literal value, <code>nullptr</code>. Generally, a pointer that equals <code>nullptr</code> doesn’t point to anything. You could use <code>nullptr</code> to indicate, for example, that there’s no more memory left to allocate or that some error occurred.</p>&#13;
<p class="indent">Pointers have an implicit conversion to <code>bool</code>. Any value that is not <code>nullptr</code> converts implicitly to <code>true</code>, whereas <code>nullptr</code> converts implicitly to <code>false</code>. This is useful when a function returning a pointer ran successfully. A common idiom is that such a function returns <code>nullptr</code> in the case of failure. The canonical example is memory allocation.</p>&#13;
<h3 class="h3" id="ch03lev1sec2"><span epub:type="pagebreak" id="page_77"/><strong>References</strong></h3>&#13;
<p class="noindent"><em>References</em> are safer, more convenient versions of pointers. You declare references with the <code>&amp;</code> declarator appended to the type name. References cannot be assigned to null (easily), and they cannot be <em>reseated</em> (or reassigned). These characteristics eliminate some bugs endemic to pointers.</p>&#13;
<p class="indent">The syntax for dealing in references is much cleaner than for pointers. Rather than using the member-of-pointer and dereference operators, you use references exactly as if they’re of the pointed-to type.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex08">Listing 3-8</a> features a reference argument.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
void add_year(ClockOfTheLongNow&amp;<span class="ent">➊</span> clock) {&#13;
  clock.set_year(clock.get_year() + 1); <span class="ent">➋</span> // No deref operator needed&#13;
}&#13;
&#13;
int main() {&#13;
  ClockOfTheLongNow clock;&#13;
  printf("The year is %d.\n", clock.get_year()); <span class="ent">➌</span>&#13;
  add_year(clock); <span class="ent">➍</span> // Clock is implicitly passed by reference!&#13;
  printf("The year is %d.\n", clock.get_year()); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The year is 2019. <span class="ent">➌</span></span>&#13;
<span class="color1">The year is 2020. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch03ex08"/><em>Listing 3-8: A program using references</em></p>&#13;
<p class="indent">You declare the <code>clock</code> argument as a <code>ClockOfTheLongNow</code> reference using the ampersand rather than the asterisk <span class="ent">➊</span>. Within <code>add_year</code>, you use clock as if it were of type <code>ClockOfTheLongNow</code> <span class="ent">➋</span>: there’s no need to use clumsy dereference and pointer-to-reference operators. First, you print the value of <code>year</code> <span class="ent">➌</span>. Next, at the call site, you pass a <code>ClockOfTheLongNow</code> object directly into <code>add_year</code> <span class="ent">➍</span>: there’s no need to take its address. Finally, you print the value of <code>year</code> again to illustrate that it has incremented <span class="ent">➎</span>.</p>&#13;
<h3 class="h3" id="ch03lev1sec3"><strong>Usage of Pointers and References</strong></h3>&#13;
<p class="indent">Pointers and references are largely interchangeable, but both have trade-offs. If you must sometimes change your reference type’s value—that is, if you must change what your reference type refers to—you must use a pointer. Many data structures (including forward-linked lists, which are covered in the next section) require that you be able to change a pointer’s value. Because references cannot be reseated and they shouldn’t generally be assigned to <code>nullptr</code>, they’re sometimes not suitable.</p>&#13;
<h4 class="h4" id="ch03lev2sec8"><span epub:type="pagebreak" id="page_78"/><strong><em>Forward-Linked Lists: The Canonical Pointer-Based Data Structure</em></strong></h4>&#13;
<p class="noindent">A <em>forward-linked list</em> is a simple data structure made up of a series of elements. Each element holds a pointer to the next element. The last element in the linked list holds a <code>nullptr</code>. Inserting elements into a linked list is very efficient, and elements can be discontinuous in memory.<a href="ch03.xhtml#ch03fig01">Figure 3-1</a> illustrates their layout.</p>&#13;
<div class="image"><img src="../images/fig3_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch03fig01"><em>Figure 3-1: A linked list</em></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex09">Listing 3-9</a> demonstrates a possible implementation of a singly linked list element.</p>&#13;
<pre>struct Element {&#13;
  Element* next{}; <span class="ent">➊</span>&#13;
  void insert_after(Element* new_element) { <span class="ent">➋</span>&#13;
    new_element-&gt;next = next; <span class="ent">➌</span>&#13;
    next = new_element; <span class="ent">➍</span>&#13;
  }&#13;
  char prefix[2]; <span class="ent">➎</span>&#13;
  short operating_number; <span class="ent">➏</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex09"/><em>Listing 3-9: An implementation of a linked list <code>Element</code> with an operating number</em></p>&#13;
<p class="indent">Each <code>element</code> has a pointer to the <code>next</code> element in the linked list <span class="ent">➊</span>, which initializes to <code>nullptr</code>. You insert a new element using the <code>insert_after</code> method <span class="ent">➋</span>. It sets the <code>next</code> member of <code>new_element</code> to the <code>next</code> of <code>this</code> <span class="ent">➌</span> and then sets <code>next</code> of <code>this</code> to <code>new_element</code> <span class="ent">➍</span>.<a href="ch03.xhtml#ch03fig02">Figure 3-2</a> illustrates this insertion. You haven’t changed the memory location of any <code>Element</code> objects in this listing; you’re only modifying pointer values.</p>&#13;
<div class="image"><img src="../images/fig3_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch03fig02"><em>Figure 3-2: Inserting an element into a linked list</em></p>&#13;
<p class="indent">Each <code>Element</code> also contains a <code>prefix</code> array <span class="ent">➎</span> and an <code>operating_number</code> short <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/><a href="ch03.xhtml#ch03ex10">Listing 3-10</a> traverses a linked list of stormtroopers of type <code>Element</code>, printing their operating numbers along the way.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Element {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  Element trooper1, trooper2, trooper3; <span class="ent">➊</span>&#13;
  trooper1.prefix[0] = 'T';&#13;
  trooper1.prefix[1] = 'K';&#13;
  trooper1.operating_number = 421;&#13;
  trooper1.insert_after(&amp;trooper2); <span class="ent">➋</span>&#13;
  trooper2.prefix[0] = 'F';&#13;
  trooper2.prefix[1] = 'N';&#13;
  trooper2.operating_number = 2187;&#13;
  trooper2.insert_after(&amp;trooper3); <span class="ent">➌</span>&#13;
  trooper3.prefix[0] = 'L';&#13;
  trooper3.prefix[1] = 'S';&#13;
  trooper3.operating_number = 005; <span class="ent">➍</span>&#13;
&#13;
  for (Element *cursor = &amp;trooper1<span class="ent">➎</span>; cursor<span class="ent">➏</span>; cursor = cursor-&gt;next<span class="ent">➐</span>) {&#13;
    printf("stormtrooper %c%c-%d\n",&#13;
           cursor-&gt;prefix[0],&#13;
           cursor-&gt;prefix[1],&#13;
           cursor-&gt;operating_number); <span class="ent">➑</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">stormtrooper TK-421 <span class="ent">➑</span></span>&#13;
<span class="color1">stormtrooper FN-2187 <span class="ent">➑</span></span>&#13;
<span class="color1">stormtrooper LS-5 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch03ex10"/><em>Listing 3-10: A program illustrating a forward-linked list</em></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex10">Listing 3-10</a> initializes three stormtroopers <span class="ent">➊</span>. The element <code>trooper1</code> is assigned the operating number TK-421, and then you insert it as the next element in the list <span class="ent">➋</span>. The elements <code>trooper2</code> and <code>trooper3</code> have operating numbers FN-2187 and LS-005 and are also inserted into the list <span class="ent">➌➍</span>.</p>&#13;
<p class="indent">The <code>for</code> loop iterates through the linked list. First, you assign the cursor pointer to the address of <code>trooper1</code> <span class="ent">➎</span>. This is the beginning of the list. Before each iteration, you make sure that <code>cursor</code> is not <code>nullptr</code> <span class="ent">➏</span>. After each iteration, you set <code>cursor</code> to the <code>next</code> element <span class="ent">➐</span>. Within the loop, you print each stormtrooper’s operating number <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec9"><strong><em>Employing References</em></strong></h4>&#13;
<p class="noindent">Pointers provide a lot of flexibility, but this flexibility comes at a safety cost. If you don’t need the flexibility of reseatability and <code>nullptr</code>, references are the go-to reference type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>Let’s drive home the point that references cannot be reseated. <a href="ch03.xhtml#ch03ex11">Listing 3-11</a> initializes an <code>int</code> reference and then attempts to reseat it with a <code>new_value</code>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int original = 100;&#13;
  int&amp; original_ref = original;&#13;
  printf("Original:  %d\n", original); <span class="ent">➊</span>&#13;
  printf("Reference: %d\n", original_ref); <span class="ent">➋</span>&#13;
&#13;
  int new_value = 200;&#13;
  original_ref = new_value; <span class="ent">➌</span>&#13;
  printf("Original:  %d\n", original); <span class="ent">➍</span>&#13;
  printf("New Value: %d\n", new_value); <span class="ent">➎</span>&#13;
  printf("Reference: %d\n", original_ref); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Original:  100 <span class="ent">➊</span></span>&#13;
<span class="color1">Reference: 100 <span class="ent">➋</span></span>&#13;
<span class="color1">Original:  200 <span class="ent">➍</span></span>&#13;
<span class="color1">New Value: 200 <span class="ent">➎</span></span>&#13;
<span class="color1">Reference: 200 <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch03ex11"/><em>Listing 3-11: A program illustrating that you cannot reseat references</em></p>&#13;
<p class="indent">This program initializes an <code>int</code> called <code>original</code> to 100. Then it declares a reference to <code>original</code> called <code>original_ref</code>. From this point on, <code>original_ref</code> will <em>always</em> refer to <code>original</code>. This is illustrated by printing the value of <code>original</code> <span class="ent">➊</span> and the value referred to by <code>original_ref</code> <span class="ent">➋</span>. They’re the same.</p>&#13;
<p class="indent">Next, you initialize another <code>int</code> called <code>new_value</code> to 200 and assign it to <code>original</code> <span class="ent">➌</span>. Read that carefully: this assignment <span class="ent">➌</span> doesn’t reseat <code>original_ref</code> so that it points to <code>new_value</code>. Rather, it assigns the value of <code>new_value</code> to the object it points to (<code>original</code>).</p>&#13;
<p class="indent">The upshot is that all of these variables—<code>original</code>, <code>original_ref</code>, and <code>new_value</code>—evaluate to 200 <span class="ent">➍➎➏</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec10"><strong><em>this Pointers</em></strong></h4>&#13;
<p class="noindent">Remember that methods are associated with classes and that instances of classes are objects. When you program a method, sometimes you need to access the <em>current object</em>, which is the object that is executing the method.</p>&#13;
<p class="indent">Within method definitions, you can access the current object using the <code>this</code> pointer. Usually, <code>this</code> isn’t needed, because <code>this</code> is implicit when accessing members. But sometimes you might need to disambiguate—for example, if you declare a method parameter whose name collides with a member variable. For example, you can rewrite <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> to make explicit which <code>Element</code> you’re referring to, as demonstrated in <a href="ch03.xhtml#ch03ex12">Listing 3-12</a>.</p>&#13;
<pre>struct Element {&#13;
  Element* next{};&#13;
  void insert_after(Element* new_element) {&#13;
<span epub:type="pagebreak" id="page_81"/>    new_element-&gt;next = this-&gt;next; <span class="ent">➊</span>&#13;
    this-&gt;next <span class="ent">➋</span> = new_element;&#13;
  }&#13;
  char prefix[2];&#13;
  short operating_number;&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex12"/><em>Listing 3-12: A rewriting of <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> using the <code>this</code> pointer</em></p>&#13;
<p class="indent">Here, <code>next</code> is replaced with <code>this-&gt;next</code> <span class="ent">➊➋</span>. The listings are functionally identical.</p>&#13;
<p class="indent">Sometimes, you need <code>this</code> to resolve ambiguity between members and arguments, as demonstrated in <a href="ch03.xhtml#ch03ex13">Listing 3-13</a>.</p>&#13;
<pre>struct ClockOfTheLongNow {&#13;
  bool set_year(int year<span class="ent">➊</span>) {&#13;
    if (year &lt; 2019) return false;&#13;
    this-&gt;year = year; <span class="ent">➋</span>&#13;
    return true;&#13;
  }&#13;
--<span class="codeitalic1">snip</span>--&#13;
private:&#13;
  int year; <span class="ent">➌</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex13"/><em>Listing 3-13: A verbose <code>ClockOfTheLongNow</code> definition using <code>this</code></em></p>&#13;
<p class="indent">The <code>year</code> argument <span class="ent">➊</span> has the same name as the <code>year</code> member <span class="ent">➌</span>. Method arguments will always mask members, meaning when you type <code>year</code> within this method, it refers to the <code>year</code> argument <span class="ent">➊</span>, not the <code>year</code> member <span class="ent">➌</span>. That’s no problem: you disambiguate with <code>this</code> <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec11"><strong><em>const Correctness</em></strong></h4>&#13;
<p class="noindent">The keyword <code>const</code> (short for “constant”) roughly means “I promise not to modify.” It’s a safety mechanism that prevents unintended (and potentially catastrophic) modifications of member variables. You’ll use <code>const</code> in function and class definitions to specify that a variable (usually a reference or a pointer) won’t be modified by that function or class. If code attempts to modify a <code>const</code> variable, the compiler will emit an error. When used correctly, <code>const</code> is one of the most powerful language features in all modern programming languages because it helps you to eliminate many kinds of common programming mistakes at compile time.</p>&#13;
<p class="indent">Let’s look at a few common usages of <code>const</code>.</p>&#13;
<h5 class="h5" id="ch03lev3sec5"><strong>const Arguments</strong></h5>&#13;
<p class="noindent">Marking an argument <code>const</code> precludes its modification within a function’s scope. A <code>const</code> pointer or reference provides you with an efficient mechanism to pass an object into a function for read-only use. The function in <a href="ch03.xhtml#ch03ex14">Listing 3-14</a> takes a <code>const</code> pointer.</p>&#13;
<pre><span epub:type="pagebreak" id="page_82"/>void petruchio(const char* shrew<span class="ent">➊</span>) {&#13;
  printf("Fear not, sweet wench, they shall not touch thee, %s.", shrew<span class="ent">➋</span>);&#13;
  shrew[0] = "K"; <span class="ent">➌</span> // Compiler error! The shrew cannot be tamed.&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex14"/><em>Listing 3-14: A function taking a <code>const</code> pointer (This code doesn’t compile.)</em></p>&#13;
<p class="indent">The <code>petruchio</code> function takes a <code>shrew</code> string by <code>const</code> reference <span class="ent">➊</span>. You can read from <code>shrew</code> <span class="ent">➋</span>, but attempting to write to it results in a compiler error <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch03lev3sec6"><strong>const Methods</strong></h5>&#13;
<p class="noindent">Marking a method <code>const</code> communicates that you promise not to modify the current object’s state within the <code>const</code> method. Put another way, these are read-only methods.</p>&#13;
<p class="indent">To mark a method <code>const</code>, place the <code>const</code> keyword after the argument list but before the method body. For example, you could update the <code>ClockOfTheLongNow</code> object’s <code>get_year</code> with <code>const</code>, as demonstrated in <a href="ch03.xhtml#ch03ex15">Listing 3-15</a>.</p>&#13;
<pre>struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  int get_year() const <span class="ent">➊</span>{&#13;
      return year;&#13;
  }&#13;
private:&#13;
  int year;&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex15"/><em>Listing 3-15: Updating <code>ClockOfTheLongNow</code> with <code>const</code></em></p>&#13;
<p class="indent">All you need to do is place <code>const</code> between the argument list and the method body <span class="ent">➊</span>. Had you attempted to modify <code>year</code> within <code>get_year</code>, the compiler would have generated an error.</p>&#13;
<p class="indent">Holders of <code>const</code> references and pointers cannot invoke methods that are not <code>const</code>, because methods that are not <code>const</code> might modify an object’s state.</p>&#13;
<p class="indent">The <code>is_leap_year</code> function in <a href="ch03.xhtml#ch03ex16">Listing 3-16</a> takes a <code>const ClockOfTheLongNow</code> reference and determines whether it’s a leap year.</p>&#13;
<pre>bool is_leap_year(const ClockOfTheLongNow&amp; clock) {&#13;
  if (clock.get_year() % 4 &gt; 0) return false;&#13;
  if (clock.get_year() % 100 &gt; 0) return true;&#13;
  if (clock.get_year() % 400 &gt; 0) return false;&#13;
  return true;&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex16"/><em>Listing 3-16: A function for determining leap years</em></p>&#13;
<p class="indent">Had <code>get_year</code> not been marked a <code>const</code> method, <a href="ch03.xhtml#ch03ex16">Listing 3-16</a> would not compile because <code>clock</code> is a <code>const</code> reference and cannot be modified within <code>is_leap_year</code>.</p>&#13;
<h4 class="h4" id="ch03lev2sec12"><span epub:type="pagebreak" id="page_83"/><strong><em>const Member Variables</em></strong></h4>&#13;
<p class="noindent">You can mark member variables <code>const</code> by adding the keyword to the member’s type. The <code>const</code> member variables cannot be modified after their initialization.</p>&#13;
<p class="indent">In <a href="ch03.xhtml#ch03ex17">Listing 3-17</a>, the <code>Avout</code> class contains two member variables, one <code>const</code> and one not <code>const</code>.</p>&#13;
<pre>struct Avout {&#13;
  const<span class="ent">➊</span> char* name = "Erasmas";&#13;
  ClockOfTheLongNow apert; <span class="ent">➋</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex17"/><em>Listing 3-17: An <code>Avout</code> class with a <code>const</code> member</em></p>&#13;
<p class="indent">The <code>name</code> member is <code>const</code>, meaning the pointed-to value cannot be modified <span class="ent">➊</span>. On the other hand, <code>apert</code> is not <code>const</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Of course, a <code>const Avout</code> reference cannot be modified, so the usual rules would still apply to <code>apert</code>:</p>&#13;
<pre>void does_not_compile(const Avout&amp; avout) {&#13;
  avout.apert.add_year(); // Compiler error: avout is const&#13;
}</pre>&#13;
<p class="indent">Sometimes you want the safety of marking a member variable <code>const</code> but would also like to initialize the member with arguments passed into a constructor. For this, you employ member initializer lists.</p>&#13;
<h4 class="h4" id="ch03lev2sec13"><strong><em>Member Initializer Lists</em></strong></h4>&#13;
<p class="noindent"><em>Member initializer lists</em> are the primary mechanism for initializing class members. To declare a member initializer list, place a colon after the argument list in a constructor. Then insert one or more comma-separated <em>member initializers</em>. A member initializer is the name of the member followed by a braced initialization <code>{ }</code>. Member initializers allow you to set the value of <code>const</code> fields at runtime.</p>&#13;
<p class="indent">The example in <a href="ch03.xhtml#ch03ex18">Listing 3-18</a> improves <a href="ch03.xhtml#ch03ex17">Listing 3-17</a> by introducing a member initialization list.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct Avout {&#13;
  Avout(const char* name, long year_of_apert) <span class="ent">➊</span>&#13;
    :<span class="ent">➋</span> name<span class="ent">➌</span>{ name }<span class="ent">➍</span>, apert<span class="ent">➎</span>{ year_of_apert }<span class="ent">➏</span> {&#13;
  }&#13;
  void announce() const { <span class="ent">➐</span>&#13;
    printf("My name is %s and my next apert is %d.\n", name, apert.get_year());&#13;
  }&#13;
<span epub:type="pagebreak" id="page_84"/>  const char* name;&#13;
  ClockOf<a id="_idTextAnchor135"/><a id="_idTextAnchor136"/>TheLongNow apert;&#13;
};&#13;
&#13;
int main() {&#13;
  Avout raz{ "Erasmas", 3010 };&#13;
  Avout jad{ "Jad", 4000 };&#13;
  raz.announce();&#13;
  jad.announce();&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">My name is Erasmas and my next apert is 3010.</span>&#13;
<span class="color1">My name is Jad and my next apert is 4000.</span></pre>&#13;
<p class="listing"><a id="ch03ex18"/><em>Listing 3-18: A program declaring and announcing two <code>Avout</code> objects</em></p>&#13;
<p class="indent">The <code>Avout</code> constructor takes two arguments, a <code>name</code> and the <code>year_of_apert</code> <span class="ent">➊</span>. A member initializer list is added by inserting a colon <span class="ent">➋</span> followed by the names of each member you’re initializing <span class="ent">➌➎</span> and braced initializations <span class="ent">➍➏</span>. A <code>const</code> method <code>announce</code> is also added to print the <code>Avout</code> constructor’s status <span class="ent">➐</span>.</p>&#13;
<p class="indent">All member initializations execute before the constructor’s body. This has two advantages:</p>&#13;
<ul>&#13;
<li class="noindent">It ensures validity of all members before the constructor executes, so you can focus on initialization logic rather than member error checking.</li>&#13;
<li class="noindent">The members initialize once. If you reassign members in the constructor, you potentially do extra work.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should order the member initializers in the same order they appear in the class definition, because their constructors will be called in this order.</em></p>&#13;
</div>&#13;
<p class="indent">Speaking of eliminating extra work, it’s time to meet <code>auto</code>.</p>&#13;
<h3 class="h3" id="ch03lev1sec4"><strong>auto Type Deduction</strong></h3>&#13;
<p class="noindent">As a strongly typed language, C++ affords its compiler a lot of information. When you initialize elements or return from functions, the compiler can divine type information from context. The <code>auto</code> keyword tells the compiler to perform such a divination for you, relieving you from inputting redundant type information.</p>&#13;
<h4 class="h4" id="ch03lev2sec14"><strong><em>Initialization with auto</em></strong></h4>&#13;
<p class="noindent">In almost all situations, the compiler can determine the correct type of an object using the initialization value. This assignment contains redundant information:</p>&#13;
<pre>int answer = 42;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>The compiler knows <code>answer</code> is an <code>int</code> because 42 is an <code>int</code>.</p>&#13;
<p class="indent">You can use <code>auto</code> instead:</p>&#13;
<pre>auto the_answer { 42 };            // int&#13;
auto foot { 12L };                 // long&#13;
auto rootbeer { 5.0F };            // float&#13;
auto cheeseburger { 10.0 };        // double&#13;
auto politifact_claims { false };  // bool&#13;
auto cheese { "string" };          // char[7]</pre>&#13;
<p class="indent">This also works when you’re initializing with parentheses <code>()</code> and the lone <code>=</code>:</p>&#13;
<pre>auto the_answer = 42;&#13;
auto foot(12L);&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">Because you’ve committed to universal initialization with <code>{}</code> as much as possible, this section will say no more of these alternatives.</p>&#13;
<p class="indent">Alone, all of this simple initialization help doesn’t buy you much; however, when types become more complicated—for example, dealing with iterators from stdlib containers—it really saves quite a bit of typing. It also makes your code more resilient to refactoring.</p>&#13;
<h4 class="h4" id="ch03lev2sec15"><strong><em>auto and Reference Types</em></strong></h4>&#13;
<p class="noindent">It’s common to add modifiers like <code>&amp;</code>, <code>*</code>, and <code>const</code> to <code>auto</code>. Such modifications add the intended meanings (reference, pointer, and <code>const</code>, respectively):</p>&#13;
<pre>auto year { 2019 };              // int&#13;
auto&amp; year_ref = year;           // int&amp;&#13;
const auto&amp; year_cref = year;    // const int&amp;&#13;
auto* year_ptr = &amp;year;          // int*&#13;
const auto* year_cptr = &amp;year;   // const int*</pre>&#13;
<p class="indent">Adding modifiers to the <code>auto</code> declaration behaves just as you’d expect: if you add a modifier, the resulting type is guaranteed to have that modifier.</p>&#13;
<h4 class="h4" id="ch03lev2sec16"><strong><em>auto and Code Refactorings</em></strong></h4>&#13;
<p class="noindent">The <code>auto</code> keyword assists in making code simpler and more resilient to refactoring. Consider the example in <a href="ch03.xhtml#ch03ex19">Listing 3-19</a> with a range-based <code>for</code> loop.</p>&#13;
<pre>struct Dwarf {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Dwarf dwarves[13];&#13;
&#13;
struct Contract {&#13;
  void add(const Dwarf&amp;);&#13;
};&#13;
<span epub:type="pagebreak" id="page_86"/>&#13;
void form_company(Contract &amp;contract) {&#13;
  for (const auto&amp; dwarf : dwarves) { <span class="ent">➊</span>&#13;
    contract.add(dwarf);&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex19"/><em>Listing 3-19: An example using <code>auto</code> in a range-based <code>for</code> loop</em></p>&#13;
<p class="indent">If ever the type of <code>dwarves</code> changes, the assignment in the range-based <code>for</code> loop <span class="ent">➊</span> doesn’t need to change. The <code>dwarf</code> type will adapt to its surroundings, in much the same way that the dwarves of Middle Earth don’t.</p>&#13;
<p class="indent">As a general rule, use <code>auto</code> always.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are some corner cases to using braced initialization where you might get surprising results, but these are few, especially after C++17 fixed some pedantic nonsense behavior. Prior to C++17, using <code>auto</code> with braces <code>{}</code> specified a special object called a <code>std::initializer_list</code>, which you’ll meet in <a href="ch13.xhtml#ch13">Chapter 13</a>.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter covered the two reference types: references and pointers. Along the way, you learned about the member-of-pointer operator, how pointers and arrays interplay, and <code>void</code>/<code>byte</code> pointers. You also learned about the meaning of <code>const</code> and its basic usage, the <code>this</code> pointer, and member initializer lists. Additionally, the chapter introduced <code>auto</code> type deduction.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>3-1.</strong> Read about CVE-2001-0500, a buffer overflow in Microsoft’s Internet Information Services. (This vulnerability is commonly referred to as the Code Red worm vulnerability.)</p>&#13;
<p class="noindent"><strong>3-2.</strong> Add a <code>read_from</code> and a <code>write_to</code> function to <a href="ch03.xhtml#ch03ex06">Listing 3-6</a>. These functions should read or write to <code>upper</code> or <code>lower</code> as appropriate. Perform bounds checking to prevent buffer overflows.</p>&#13;
<p class="noindent"><strong>3-3.</strong> Add an <code>Element* previous</code> to <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> to make a <em>doubly linked list</em>. Add an <code>insert_before</code> method to <code>Element</code>. Traverse the list from front to back, then from back to front, using two separate <code>for</code> loops. Print the <code>operating_number</code> inside each loop.</p>&#13;
<p class="noindent"><strong>3-4.</strong> Reimplement <a href="ch03.xhtml#ch03ex11">Listing 3-11</a> using no explicit types. (Hint: use <code>auto</code>.)</p>&#13;
<p class="noindent"><strong>3-5.</strong> Scan the listings in <a href="ch02.xhtml#ch02">Chapter 2</a>. Which methods could be marked <code>const</code>? Where could you use <code>auto</code> ?</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_87"/><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li>&#13;
<li class="noindent">“C++ Core Guidelines” by Bjarne Stroustrup and Herb Sutter (<em><a href="https://github.com/isocpp/CppCoreGuidelines/">https://github.com/isocpp/CppCoreGuidelines/</a></em>)</li>&#13;
<li class="noindent">“East End Functions” by Phil Nash (2018; <em><a href="https://levelofindirection.com/blog/east-end-functions.html">https://levelofindirection.com/blog/east-end-functions.html</a></em>)</li>&#13;
<li class="noindent">“References FAQ” by the Standard C++ Foundation (<em><a href="https://isocpp.org/wiki/faq/references/">https://isocpp.org/wiki/faq/references/</a></em>)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>