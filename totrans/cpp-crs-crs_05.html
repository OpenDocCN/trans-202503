<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_66"/><span epub:type="pagebreak" id="page_67"/><strong><span class="big">3</span><br/>REFERENCE TYPES</strong></h2>&#13;
<p class="quote"><em>Everyone knows that debugging is twice as hard as writing a program in the first place. So if you’re as clever as you can be when you write it, how will you ever debug it?<br/>—Brian Kernighan</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent"><em>Reference types</em> store the memory addresses of objects. These types enable efficient programming, and many elegant design patterns feature them. In this chapter, I’ll discuss the two kinds of reference types: pointers and references. I’ll also discuss <span class="literal">this</span>, <span class="literal">const</span>, and <span class="literal">auto</span> along the way.</p>&#13;
<h3 class="h3" id="ch03lev1sec1"><strong>Pointers</strong></h3>&#13;
<p class="noindent"><em>Pointers</em> are the fundamental mechanism used to refer to memory addresses. Pointers encode both pieces of information required to interact with another object—that is, the object’s address and the object’s type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>You can declare a pointer’s type by appending an asterisk (<span class="literal">*</span>) to the pointed-to type. For example, you declare a pointer to <span class="literal">int</span> called <span class="literal">my_ptr</span> as follows:</p>&#13;
<pre>int* my_ptr;</pre>&#13;
<p class="noindent">The format specifier for a pointer is <span class="literal">%p</span>. For example, to print the value in <span class="literal">my_ptr</span>, you could use the following:</p>&#13;
<pre>printf("The value of my_ptr is %p.", my_ptr);</pre>&#13;
<p class="indent">Pointers are very low-level objects. Although they play a central role in most C programs, C++ offers higher-level, sometimes more efficient, constructs that obviate the need to deal with memory addresses directly. Nonetheless, pointers are a foundational concept that you’ll no doubt come across in your system-programming travels.</p>&#13;
<p class="indent">In this section, you’ll learn how to find the address of an object and how to assign the result to a pointer variable. You’ll also learn how to perform the opposite operation, which is called <em>dereferencing</em>: given a pointer, you can obtain the object residing at the corresponding address.</p>&#13;
<p class="indent">You’ll learn more about <em>arrays</em>, the simplest construct for managing an object collection, as well as how arrays relate to pointers. As low-level constructs, arrays and pointers are relatively dangerous. You’ll learn about what can go wrong when pointer- and array-based programs go awry.</p>&#13;
<p class="indent">This chapter introduces two special kinds of pointers: <span class="literal">void</span> pointers and <span class="literal">std::byte</span> pointers. These very useful types have some special behaviors that you’ll need to keep in mind. Additionally, you’ll learn how to encode empty pointers with <span class="literal">nullptr</span> and how to use pointers in Boolean expressions to determine whether they’re empty.</p>&#13;
<h4 class="h4" id="ch03lev2sec1"><strong><em>Addressing Variables</em></strong></h4>&#13;
<p class="noindent">You can obtain the address of a variable by prepending the <em>address-of operator</em> (<span class="literal">&amp;</span>). You might want to use this operator to initialize a pointer so it “points to” the corresponding variable. Such programming requirements arise very often in operating systems programming. For example, major operating systems, such as Windows, Linux, and FreeBSD, have interfaces that use pointers heavily.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex01">Listing 3-1</a> demonstrates how to obtain the address of an <span class="literal">int</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int gettysburg{}; <span class="ent">➊</span>&#13;
  printf("gettysburg: %d\n", gettysburg); <span class="ent">➋</span>&#13;
  int *gettysburg_address = &amp;gettysburg; <span class="ent">➌</span>&#13;
  printf("&amp;gettysburg: %p\n", gettysburg_address); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex01"/><em>Listing 3-1: A program featuring the address-of operator <span class="literal">&amp;</span> and a terrible pun</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/>First, you declare the integer <span class="literal">gettysburg</span> <span class="ent">➊</span> and print its value <span class="ent">➋</span>. Then you declare a pointer, called <span class="literal">gettysburg_address</span>, to that integer’s address <span class="ent">➌</span>; notice that the asterisk prepends the pointer and the ampersand prepends <span class="literal">gettysburg</span>. Finally, you print the pointer to the screen <span class="ent">➍</span> to reveal the <span class="literal">gettysburg</span> integer’s address.</p>&#13;
<p class="indent">If you run <a href="ch03.xhtml#ch03ex01">Listing 3-1</a> on Windows 10 (x86), you should see the following output:</p>&#13;
<pre>gettysburg: 0&#13;
&amp;gettysburg: 0053FBA8</pre>&#13;
<p class="indent">Running the same code on Windows 10 x64 yields the following output:</p>&#13;
<pre>gettysburg: 0&#13;
&amp;gettysburg: 0000007DAB53F594</pre>&#13;
<p class="indent">Your output should have an identical value for <span class="literal">gettysburg</span>, but <span class="literal">gettysburg_address</span> should be different each time. This variation is due to <em>address space layout randomization</em>, which is a security feature that scrambles the base address of important memory regions to hamper exploitation.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong>Address Space Layout Randomization</strong></p>&#13;
<p class="noindent">Why does address space layout randomization hamper exploitation? When a hacker finds an exploitable condition in a program, they can sometimes cram a malicious payload into user-provided input. One of the first security features designed to prevent a hacker from getting this malicious payload to execute is to make all data sections non-executable. If the computer attempts to execute data as code, then the theory is that it knows something’s amiss and should terminate the program with an exception.</p>&#13;
<p class="indent">Some exceedingly clever hackers figured out how to repurpose executable code instructions in totally unforeseen ways by carefully crafting exploits containing so-called <em>return-oriented programs</em>. These exploits could arrange to invoke the relevant system APIs to mark their payload executable, hence defeating the non-executable-memory mitigation.</p>&#13;
<p class="indent">Address space layout randomization combats return-oriented programming by randomizing memory addresses, making it difficult to repurpose existing code because the attacker doesn’t know where it resides in memory.</p>&#13;
</div>&#13;
<p class="indent">Also note that in the outputs for <a href="ch03.xhtml#ch03ex01">Listing 3-1</a>, <span class="literal">gettysburg_address</span> contains 8 hexadecimal digits (4 bytes) for an x86 architecture and 16 hexadecimal digits (8 bytes) for an x64 architecture. This should make some sense because on modern desktop systems, the pointer size is the same as the CPU’s general-purpose register. An x86 architecture has 32-bit (4-byte) general-purpose registers, whereas an x64 architecture has 64-bit (8-byte) general-purpose registers.</p>&#13;
<h4 class="h4" id="ch03lev2sec2"><strong><em><span epub:type="pagebreak" id="page_70"/>Dereferencing Pointers</em></strong></h4>&#13;
<p class="noindent">The <em>dereference operator</em> (<span class="literal">*</span>) is a unary operator that accesses the object to which a pointer refers. This is the inverse operation of the address-of operator. Given an address, you can obtain the object residing there. Like the address-of operator, system programmers use the dereference operator very often. Many operating system APIs will return pointers, and if you want to access the referred-to object, you’ll use the dereference operator.</p>&#13;
<p class="indent">Unfortunately, the dereference operator can cause a lot of notation-based confusion for beginners because the dereference operator, the pointer declaration, and multiplication all use asterisks. Remember that you append an asterisk to the end of the pointed-to object’s type to declare a pointer; however, you prepend the dereference operator—an asterisk—to the pointer, like this:</p>&#13;
<pre>*gettysburg_address</pre>&#13;
<p class="indent">After accessing an object by prepending the dereference operator to a pointer, you can treat the result like any other object of the pointed-to type. For example, because <span class="literal">gettysburg</span> is an integer, you can write the value 17325 into <span class="literal">gettysburg</span> using <span class="literal">gettysburg_address</span>. The correct syntax is as follows:</p>&#13;
<pre>*gettysburg_address = 17325;</pre>&#13;
<p class="indent">Because the dereferenced pointer—that is, <span class="literal">*gettysburg_address</span>—appears on the left side of the equal sign, you’re writing to the address where <span class="literal">gettysburg</span> is stored.</p>&#13;
<p class="indent">If a dereferenced pointer appears anywhere except the left side of an equal sign, you’re reading from the address. To retrieve the <span class="literal">int</span> pointed to by <span class="literal">gettysburg_address</span>, you just tack on the dereference operator. For instance, the following statement will print the value stored in <span class="literal">gettysburg</span>:</p>&#13;
<pre>printf("%d", *gettysburg_address);</pre>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex02">Listing 3-2</a> uses the dereference operator to read and write.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int gettysburg{};&#13;
  int* gettysburg_address = &amp;gettysburg; <span class="ent">➊</span>&#13;
  printf("Value at gettysburg_address: %d\n", *gettysburg_address); <span class="ent">➋</span>&#13;
  printf("Gettysburg Address: %p\n", gettysburg_address); <span class="ent">➌</span>&#13;
  *gettysburg_address = 17325; <span class="ent">➍</span>&#13;
  printf("Value at gettysburg_address: %d\n", *gettysburg_address); <span class="ent">➎</span>&#13;
  printf("Gettysburg Address: %p\n", gettysburg_address); <span class="ent">➏</span>&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Value at gettysburg_address: 0 <span class="ent">➋</span></span>&#13;
<span class="color1">Gettysburg Address: 000000B9EEEFFB04 <span class="ent">➌</span></span>&#13;
<span class="color1"><span epub:type="pagebreak" id="page_71"/>Value at gettysburg_address: 17325 <span class="ent">➎</span></span>&#13;
<span class="color1">Gettysburg Address: 000000B9EEEFFB04 <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch03ex02"/><em>Listing 3-2: An example program illustrating reads and writes using a pointer (output is from a Windows 10 x64 machine)</em></p>&#13;
<p class="indent">First, you initialize <span class="literal">gettysburg</span> to zero. Then, you initialize the pointer <span class="literal">gettysburg_address</span> to the address of <span class="literal">gettysburg</span> <span class="ent">➊</span>. Next, you print the <span class="literal">int</span> pointed to by <span class="literal">gettysburg_address</span> <span class="ent">➋</span> and the value of <span class="literal">gettysburg_address</span> itself <span class="ent">➌</span>.</p>&#13;
<p class="indent">You write the value 17325 into the memory pointed to by <span class="literal">gettysburg_address</span> <span class="ent">➍</span> and then print the pointed-to value <span class="ent">➎</span> and address <span class="ent">➏</span> again.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex02">Listing 3-2</a> would be functionally identical if you assigned the value 17325 directly to <span class="literal">gettysburg</span> instead of to the <span class="literal">gettysburg_address</span> pointer, like this:</p>&#13;
<pre>  gettysburg = 17325;</pre>&#13;
<p class="indent">This example illustrates the close relationship between a pointed-to object (<span class="literal">gettysburg</span>) and a dereferenced pointer to that object (<span class="literal">*gettysburg_address)</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec3"><strong><em>The Member-of-Pointer Operator</em></strong></h4>&#13;
<p class="noindent">The <em>member-of-pointer operator</em>, or <em>arrow operator</em> (<span class="literal">-&gt;</span>), performs two simultaneous operations:</p>&#13;
<ul>&#13;
<li class="noindent">It dereferences a pointer.</li>&#13;
<li class="noindent">It accesses a member of the pointed-to object.</li>&#13;
</ul>&#13;
<p class="indent">You can use this operator to reduce <em>notational friction</em>, the resistance a programmer feels in expressing their intent in code, when you’re handling pointers to classes. You’ll need to handle pointers to classes in a variety of design patterns. For example, you might want to pass a pointer to a class as a function parameter. If the receiving function needs to interact with a member of that class, the member-of-pointer operator is the tool for the job.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex03">Listing 3-3</a> employs the arrow operator to read the <span class="literal">year</span> from a <span class="literal">ClockOfTheLongNow</span> object (which you implemented in <a href="ch02.xhtml#ch02ex22">Listing 2-22</a> on <a href="ch02.xhtml#page_58">page 58</a>).</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  ClockOfTheLongNow clock;&#13;
  ClockOfTheLongNow* clock_ptr = &amp;clock; <span class="ent">➊</span>&#13;
  clock_ptr-&gt;set_year(2020); <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_72"/>  printf("Address of clock: %p\n", clock_ptr); <span class="ent">➌</span>&#13;
  printf("Value of clock's year: %d", clock_ptr-&gt;get_year()); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Address of clock: 000000C6D3D5FBE4 <span class="ent">➌</span></span>&#13;
<span class="color1">Value of clock's year: 2020 <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch03ex03"/><em>Listing 3-3: Using a pointer and the arrow operator to manipulate the <span class="literal">ClockOfTheLongNow</span> object (output is from a Windows 10 x64 machine)</em></p>&#13;
<p class="indent">You declare a <span class="literal">clock</span> and then store its address in <span class="literal">clock_ptr</span> <span class="ent">➊</span>. Next, you use the arrow operator to set the <span class="literal">year</span> member of <span class="literal">clock</span> to 2020 <span class="ent">➋</span>. Finally, you print the address of <span class="literal">clock</span> <span class="ent">➌</span> and the value of <span class="literal">year</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">You could achieve an identical result using the dereference (<span class="literal">*</span>) and member of (<span class="literal">.</span>) operators. For example, you could have written the last line of <a href="ch03.xhtml#ch03ex03">Listing 3-3</a> as follows:</p>&#13;
<pre>  printf("Value of clock's year: %d", (*clock_ptr).get_year());</pre>&#13;
<p class="indent">First, you dereference <span class="literal">clock_ptr</span>, and then you access the <span class="literal">year</span>. Although this is equivalent to invoking the pointer-to-member operator, it’s a more verbose syntax and provides no benefit over its simpler alternative.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For now, use parentheses to emphasize the order of operations. <a href="ch07.xhtml#ch07">Chapter 7</a> walks through the precedents rules for operators.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec4"><strong><em>Pointers and Arrays</em></strong></h4>&#13;
<p class="noindent">Pointers share several characteristics with arrays. Pointers encode object location. Arrays encode the location and length of contiguous objects.</p>&#13;
<p class="indent">At the slightest provocation, an array will <em>decay</em> into a pointer. A decayed array loses length information and converts to a pointer to the array’s first element. For example:</p>&#13;
<pre>int key_to_the_universe[]{ 3, 6, 9 };&#13;
int* key_ptr = key_to_the_universe; // Points to 3</pre>&#13;
<p class="indent">First, you initialize an <span class="literal">int</span> array <span class="literal">key_to_the_universe</span> with three elements. Next, you initialize the <span class="literal">int</span> pointer <span class="literal">key_ptr</span> to <span class="literal">key_to_the_universe</span>, which decays into a pointer. After initialization, <span class="literal">key_ptr</span> points to the first element of <span class="literal">key_to_the_universe</span>.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex04">Listing 3-4</a> initializes an array containing <span class="literal">College</span> objects and passes the array to a function as a pointer.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct College {&#13;
  char name[256];&#13;
};&#13;
<span epub:type="pagebreak" id="page_73"/>void print_name(College* college_ptr<span class="ent">➊</span>) {&#13;
  printf("%s College\n", college_ptr-&gt;name<span class="ent">➋</span>);&#13;
}&#13;
&#13;
int main() {&#13;
  College best_colleges[] = { "Magdalen", "Nuffield", "Kellogg" <a id="_idTextAnchor113"/><a id="_idTextAnchor114"/>};&#13;
  print_name(best_colleges);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Magdalen College <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch03ex04"/><em>Listing 3-4: A program illustrating array decay into a pointer</em></p>&#13;
<p class="indent">The <span class="literal">print_name</span> function takes a pointer-to-<span class="literal">College</span> argument <span class="ent">➊</span>, so the <span class="literal">best_colleges</span> array decays into a pointer when you call <span class="literal">print_name</span>. Because arrays decay into pointers to their first element, <span class="literal">college_ptr</span> at <span class="ent">➊</span> points to the first <span class="literal">College</span> in <span class="literal">best_colleges</span>.</p>&#13;
<p class="indent">There’s another array decay in <a href="ch03.xhtml#ch03ex04">Listing 3-4</a> <span class="ent">➋</span> as well. You use the arrow operator (<span class="literal">-&gt;</span>) to access the <span class="literal">name</span> member of the <span class="literal">College</span> pointed to by <span class="literal">college_ptr</span>, which is itself a <span class="literal">char</span> array. The <span class="literal">printf</span> format specifier <span class="literal">%s</span> expects a C-style string, which is a <span class="literal">char</span> pointer, and <span class="literal">name</span> decays into a pointer to satisfy <span class="literal">printf</span>.</p>&#13;
<h5 class="h5" id="ch03lev3sec1"><strong>Handling Decay</strong></h5>&#13;
<p class="indent">Often, you pass arrays as two arguments:</p>&#13;
<ul>&#13;
<li class="noindent">A pointer to the first array element</li>&#13;
<li class="noindent">The array’s length</li>&#13;
</ul>&#13;
<p class="indent">The mechanism that enables this pattern is square brackets (<span class="literal">[]</span>), which work with pointers just as with arrays. <a href="ch03.xhtml#ch03ex05">Listing 3-5</a> employs this technique.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct College {&#13;
  char name[256];&#13;
};&#13;
&#13;
void print_names(College* colleges<span class="ent">➊</span>, size_t n_colleges<span class="ent">➋</span>) {&#13;
  for (size_t i = 0; i &lt; n_colleges; i++) { <span class="ent">➌</span>&#13;
    printf("%s College\n", colleges[i]<span class="ent">➍</span>.name<span class="ent">➎</span>);&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  College oxford[] = { "Magdalen", "Nuffield", "Kellogg" };&#13;
  print_names(oxfor<a id="_idTextAnchor115"/><a id="_idTextAnchor116"/>d, sizeof(oxford) / sizeof(College));&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_74"/><span class="color1">Magdalen College</span>&#13;
<span class="color1">Nuffield College</span>&#13;
<span class="color1">Kellogg College</span></pre>&#13;
<p class="listing"><a id="ch03ex05"/><em>Listing 3-5: A program illustrating a common idiom for passing arrays to functions</em></p>&#13;
<p class="indent">The <span class="literal">print_names</span> function accepts an array in two arguments: a pointer to the first <span class="literal">College</span> element <span class="ent">➊</span> and the number of elements <span class="literal">n_colleges</span> <span class="ent">➋</span>. Within <span class="literal">print_names</span>, you iterate with a <span class="literal">for</span> loop and an index <span class="literal">i</span>. The value of <span class="literal">i</span> iterates from <span class="literal">0</span> to <span class="literal">n_colleges-1</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">You extract the corresponding college name by accessing the <span class="literal">i</span>th element <span class="ent">➍</span> and then get the <span class="literal">name</span> member <span class="ent">➎</span>.</p>&#13;
<p class="indent">This pointer-plus-size approach to passing arrays is ubiquitous in C-style APIs, for example, in Windows or Linux system programming.</p>&#13;
<h5 class="h5" id="ch03lev3sec2"><strong>Pointer Arithmetic</strong></h5>&#13;
<p class="noindent">To obtain the address of the <span class="literal">n</span>th element of an array, you have two options. First, you can take the direct approach of obtaining the <span class="literal">n</span>th element with square brackets (<span class="literal">[]</span>) and then use the address-of (<span class="literal">&amp;</span>) operator:</p>&#13;
<pre>College* third_college_ptr = &amp;oxford[2];</pre>&#13;
<p class="indent"><em>Pointer arithmetic</em>, the set of rules for addition and subtraction on pointers, provides an alternate approach. When you add or subtract integers to pointers, the compiler figures out the correct byte offset using the size of the pointed-to type. For example, adding 4 to a <span class="literal">uint64_t</span> pointer adds 32 bytes: a <span class="literal">uint64_t</span> takes up 8 bytes, so 4 of them take up 32 bytes. The following is therefore equivalent to the previous option of obtaining the address of the <span class="literal">n</span>th element of an array:</p>&#13;
<pre>College* third_college_ptr = oxford + 2;</pre>&#13;
<h4 class="h4" id="ch03lev2sec5"><strong><em>Pointers Are Dangerous</em></strong></h4>&#13;
<p class="noindent">It’s not possible to convert a pointer to an array, which is a good thing. You shouldn’t need to, and besides it wouldn’t be possible in general for a compiler to recover the size of the array from a pointer. But the compiler can’t save you from all the dangerous things you might try to do.</p>&#13;
<h5 class="h5" id="ch03lev3sec3"><strong>Buffer Overflows</strong></h5>&#13;
<p class="noindent">For arrays and pointers, you can access arbitrary array elements with the bracket operator (<span class="literal">[]</span>) or with pointer arithmetic. These are very powerful tools for low-level programming because you can interact with memory more or less without abstraction. This gives you exquisite control over the system, which you need in some environments (for example, in system programming contexts like implementing network protocols or with embedded <span epub:type="pagebreak" id="page_75"/>controllers). With great power comes great responsibility, however, and you must be very careful. Simple mistakes with pointers can have catastrophic and mysterious consequences.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex06">Listing 3-6</a> performs low-level manipulation on two strings.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
int main() {&#13;
  char lower[] = "abc?e";&#13;
  char upper[] = "ABC?E";&#13;
  char* upper_ptr = upper;     <span class="ent">➊</span> // Equivalent: &amp;upper[0]&#13;
&#13;
  lower[3] = 'd';              <span class="ent">➋</span> // lower now contains a b c d e \0&#13;
  upper_ptr[3] = 'D';             // upper now contains A B C D E \0&#13;
&#13;
  char letter_d = lower[3];    <span class="ent">➌</span> // letter_d equals 'd'&#13;
  char letter_D = upper_ptr[3];   // letter_D equals 'D'&#13;
&#13;
  printf("lower: %s\nupper: %s", lower, upper); <span class="ent">➍</span>&#13;
&#13;
  lower[7] = 'g';              <span class="ent">➎</span> // Super bad. You must never do this.&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">lower: abcde <span class="ent">➍</span></span>&#13;
<span class="color1">upper: ABCDE</span>&#13;
<span class="color1">The time is 2:14 a.m. Eastern time, August 29th. Skynet is now online. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch03ex06"/><em>Listing 3-6: A program containing a buffer overflow</em></p>&#13;
<p class="indent">After initializing the strings <span class="literal">lower</span> and <span class="literal">upper</span>, you initialize <span class="literal">upper_ptr</span> pointing to the first element <span class="ent">➊</span> in <span class="literal">upper</span>. You then reassign the fourth elements of both <span class="literal">lower</span> and <span class="literal">upper</span> (the question marks) to <span class="literal">d</span> and <span class="literal">D</span> <span class="ent">➋</span> <span class="ent">➌</span>. Notice that <span class="literal">lower</span> is an array and <span class="literal">upper_ptr</span> is a pointer, but the mechanism is the same. So far, so good.</p>&#13;
<p class="indent">Finally, you make a major boo-boo by writing out-of-bounds memory <span class="ent">➎</span>. By accessing the element at index <span class="literal">7</span> <span class="ent">➍</span>, you’ve gone past the storage allotted to <span class="literal">lower</span>. No bounds checking occurs; this code compiles without warning.</p>&#13;
<p class="indent">At runtime, you get <em>undefined behavior</em>. Undefined behavior means the C++ language specification doesn’t prescribe what happens, so your program might crash, open a security vulnerability, or spawn an artificial general intelligence <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch03lev3sec4"><strong>The Connection Between Brackets and Pointer Arithmetic</strong></h5>&#13;
<p class="noindent">To understand the ramifications of out-of-bounds access, you must understand the connection between bracket operators and pointer arithmetic. Consider that you could have written <a href="ch03.xhtml#ch03ex06">Listing 3-6</a> with pointer arithmetic and dereference operators rather than bracket operators, as demonstrated in <a href="ch03.xhtml#ch03ex07">Listing 3-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
int main() {&#13;
<span epub:type="pagebreak" id="page_76"/>  char lower[] = "abc?e";&#13;
  char upper[] = "ABC?E";&#13;
  char* upper_ptr = &amp;upper[0];&#13;
&#13;
  *(lower + 3) = 'd';&#13;
  *(upper_ptr + 3) = 'D';&#13;
&#13;
  char letter_d = *(lower + 3); // lower decays into a pointer when we add&#13;
  char letter_D = *(upper_ptr + 3);&#13;
&#13;
  printf("lower: %s\nupper: %s", lower, upper);&#13;
&#13;
  *(lower + 7) = 'g'; <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex07"/><em>Listing 3-7: An equivalent program to <a href="ch03.xhtml#ch03ex06">Listing 3-6</a> that uses pointer arithmetic</em></p>&#13;
<p class="indent">The <span class="literal">lower</span> array has length 6 (the letters <em>a</em>–<em>e</em> plus a null terminator). It should now be clear why assigning <span class="literal">lower[7]</span> <span class="ent">➊</span> is perilous. In this case, you’re writing to some memory that doesn’t belong to <span class="literal">lower</span>. This can result in access violations, program crashes, security vulnerabilities, and corrupted data. These kinds of errors can be very insidious, because the point at which the bad write occurs might be far removed from the point at which the bug manifests.</p>&#13;
<h4 class="h4" id="ch03lev2sec6"><strong><em>void Pointers and std::byte Pointers</em></strong></h4>&#13;
<p class="noindent">Sometimes the pointed-to type is irrelevant. In such situations, you use the <em>void pointer</em> <span class="literal">void*</span>. The <span class="literal">void</span> pointers have important restrictions, the principal of which is that you cannot dereference a <span class="literal">void*</span>. Because the pointed-to type has been erased, dereferencing makes no sense (recall that the set of values for <span class="literal">void</span> objects is empty). For similar reasons, C++ forbids <span class="literal">void</span> pointer arithmetic.</p>&#13;
<p class="indent">Other times, you want to interact with raw memory at the byte level. Examples include low-level operations like copying raw data between files and memory, encryption, and compression. You cannot use a <span class="literal">void</span> pointer for such purposes because bit-wise and arithmetic operations are disabled. In such situations, you can use a <span class="literal">std::byte</span> pointer.</p>&#13;
<h4 class="h4" id="ch03lev2sec7"><strong><em>nullptr and Boolean Expressions</em></strong></h4>&#13;
<p class="noindent">Pointers can have a special literal value, <span class="literal">nullptr</span>. Generally, a pointer that equals <span class="literal">nullptr</span> doesn’t point to anything. You could use <span class="literal">nullptr</span> to indicate, for example, that there’s no more memory left to allocate or that some error occurred.</p>&#13;
<p class="indent">Pointers have an implicit conversion to <span class="literal">bool</span>. Any value that is not <span class="literal">nullptr</span> converts implicitly to <span class="literal">true</span>, whereas <span class="literal">nullptr</span> converts implicitly to <span class="literal">false</span>. This is useful when a function returning a pointer ran successfully. A common idiom is that such a function returns <span class="literal">nullptr</span> in the case of failure. The canonical example is memory allocation.</p>&#13;
<h3 class="h3" id="ch03lev1sec2"><span epub:type="pagebreak" id="page_77"/><strong>References</strong></h3>&#13;
<p class="noindent"><em>References</em> are safer, more convenient versions of pointers. You declare references with the <span class="literal">&amp;</span> declarator appended to the type name. References cannot be assigned to null (easily), and they cannot be <em>reseated</em> (or reassigned). These characteristics eliminate some bugs endemic to pointers.</p>&#13;
<p class="indent">The syntax for dealing in references is much cleaner than for pointers. Rather than using the member-of-pointer and dereference operators, you use references exactly as if they’re of the pointed-to type.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex08">Listing 3-8</a> features a reference argument.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
void add_year(ClockOfTheLongNow&amp;<span class="ent">➊</span> clock) {&#13;
  clock.set_year(clock.get_year() + 1); <span class="ent">➋</span> // No deref operator needed&#13;
}&#13;
&#13;
int main() {&#13;
  ClockOfTheLongNow clock;&#13;
  printf("The year is %d.\n", clock.get_year()); <span class="ent">➌</span>&#13;
  add_year(clock); <span class="ent">➍</span> // Clock is implicitly passed by reference!&#13;
  printf("The year is %d.\n", clock.get_year()); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">The year is 2019. <span class="ent">➌</span></span>&#13;
<span class="color1">The year is 2020. <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch03ex08"/><em>Listing 3-8: A program using references</em></p>&#13;
<p class="indent">You declare the <span class="literal">clock</span> argument as a <span class="literal">ClockOfTheLongNow</span> reference using the ampersand rather than the asterisk <span class="ent">➊</span>. Within <span class="literal">add_year</span>, you use clock as if it were of type <span class="literal">ClockOfTheLongNow</span> <span class="ent">➋</span>: there’s no need to use clumsy dereference and pointer-to-reference operators. First, you print the value of <span class="literal">year</span> <span class="ent">➌</span>. Next, at the call site, you pass a <span class="literal">ClockOfTheLongNow</span> object directly into <span class="literal">add_year</span> <span class="ent">➍</span>: there’s no need to take its address. Finally, you print the value of <span class="literal">year</span> again to illustrate that it has incremented <span class="ent">➎</span>.</p>&#13;
<h3 class="h3" id="ch03lev1sec3"><strong>Usage of Pointers and References</strong></h3>&#13;
<p class="indent">Pointers and references are largely interchangeable, but both have trade-offs. If you must sometimes change your reference type’s value—that is, if you must change what your reference type refers to—you must use a pointer. Many data structures (including forward-linked lists, which are covered in the next section) require that you be able to change a pointer’s value. Because references cannot be reseated and they shouldn’t generally be assigned to <span class="literal">nullptr</span>, they’re sometimes not suitable.</p>&#13;
<h4 class="h4" id="ch03lev2sec8"><span epub:type="pagebreak" id="page_78"/><strong><em>Forward-Linked Lists: The Canonical Pointer-Based Data Structure</em></strong></h4>&#13;
<p class="noindent">A <em>forward-linked list</em> is a simple data structure made up of a series of elements. Each element holds a pointer to the next element. The last element in the linked list holds a <span class="literal">nullptr</span>. Inserting elements into a linked list is very efficient, and elements can be discontinuous in memory.<a href="ch03.xhtml#ch03fig01">Figure 3-1</a> illustrates their layout.</p>&#13;
<div class="image"><img src="../images/fig3_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch03fig01"><em>Figure 3-1: A linked list</em></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex09">Listing 3-9</a> demonstrates a possible implementation of a singly linked list element.</p>&#13;
<pre>struct Element {&#13;
  Element* next{}; <span class="ent">➊</span>&#13;
  void insert_after(Element* new_element) { <span class="ent">➋</span>&#13;
    new_element-&gt;next = next; <span class="ent">➌</span>&#13;
    next = new_element; <span class="ent">➍</span>&#13;
  }&#13;
  char prefix[2]; <span class="ent">➎</span>&#13;
  short operating_number; <span class="ent">➏</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex09"/><em>Listing 3-9: An implementation of a linked list <span class="literal">Element</span> with an operating number</em></p>&#13;
<p class="indent">Each <span class="literal">element</span> has a pointer to the <span class="literal">next</span> element in the linked list <span class="ent">➊</span>, which initializes to <span class="literal">nullptr</span>. You insert a new element using the <span class="literal">insert_after</span> method <span class="ent">➋</span>. It sets the <span class="literal">next</span> member of <span class="literal">new_element</span> to the <span class="literal">next</span> of <span class="literal">this</span> <span class="ent">➌</span> and then sets <span class="literal">next</span> of <span class="literal">this</span> to <span class="literal">new_element</span> <span class="ent">➍</span>.<a href="ch03.xhtml#ch03fig02">Figure 3-2</a> illustrates this insertion. You haven’t changed the memory location of any <span class="literal">Element</span> objects in this listing; you’re only modifying pointer values.</p>&#13;
<div class="image"><img src="../images/fig3_2.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch03fig02"><em>Figure 3-2: Inserting an element into a linked list</em></p>&#13;
<p class="indent">Each <span class="literal">Element</span> also contains a <span class="literal">prefix</span> array <span class="ent">➎</span> and an <span class="literal">operating_number</span> short <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/><a href="ch03.xhtml#ch03ex10">Listing 3-10</a> traverses a linked list of stormtroopers of type <span class="literal">Element</span>, printing their operating numbers along the way.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct Element {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
int main() {&#13;
  Element trooper1, trooper2, trooper3; <span class="ent">➊</span>&#13;
  trooper1.prefix[0] = 'T';&#13;
  trooper1.prefix[1] = 'K';&#13;
  trooper1.operating_number = 421;&#13;
  trooper1.insert_after(&amp;trooper2); <span class="ent">➋</span>&#13;
  trooper2.prefix[0] = 'F';&#13;
  trooper2.prefix[1] = 'N';&#13;
  trooper2.operating_number = 2187;&#13;
  trooper2.insert_after(&amp;trooper3); <span class="ent">➌</span>&#13;
  trooper3.prefix[0] = 'L';&#13;
  trooper3.prefix[1] = 'S';&#13;
  trooper3.operating_number = 005; <span class="ent">➍</span>&#13;
&#13;
  for (Element *cursor = &amp;trooper1<span class="ent">➎</span>; cursor<span class="ent">➏</span>; cursor = cursor-&gt;next<span class="ent">➐</span>) {&#13;
    printf("stormtrooper %c%c-%d\n",&#13;
           cursor-&gt;prefix[0],&#13;
           cursor-&gt;prefix[1],&#13;
           cursor-&gt;operating_number); <span class="ent">➑</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">stormtrooper TK-421 <span class="ent">➑</span></span>&#13;
<span class="color1">stormtrooper FN-2187 <span class="ent">➑</span></span>&#13;
<span class="color1">stormtrooper LS-5 <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch03ex10"/><em>Listing 3-10: A program illustrating a forward-linked list</em></p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03ex10">Listing 3-10</a> initializes three stormtroopers <span class="ent">➊</span>. The element <span class="literal">trooper1</span> is assigned the operating number TK-421, and then you insert it as the next element in the list <span class="ent">➋</span>. The elements <span class="literal">trooper2</span> and <span class="literal">trooper3</span> have operating numbers FN-2187 and LS-005 and are also inserted into the list <span class="ent">➌➍</span>.</p>&#13;
<p class="indent">The <span class="literal">for</span> loop iterates through the linked list. First, you assign the cursor pointer to the address of <span class="literal">trooper1</span> <span class="ent">➎</span>. This is the beginning of the list. Before each iteration, you make sure that <span class="literal">cursor</span> is not <span class="literal">nullptr</span> <span class="ent">➏</span>. After each iteration, you set <span class="literal">cursor</span> to the <span class="literal">next</span> element <span class="ent">➐</span>. Within the loop, you print each stormtrooper’s operating number <span class="ent">➑</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec9"><strong><em>Employing References</em></strong></h4>&#13;
<p class="noindent">Pointers provide a lot of flexibility, but this flexibility comes at a safety cost. If you don’t need the flexibility of reseatability and <span class="literal">nullptr</span>, references are the go-to reference type.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>Let’s drive home the point that references cannot be reseated. <a href="ch03.xhtml#ch03ex11">Listing 3-11</a> initializes an <span class="literal">int</span> reference and then attempts to reseat it with a <span class="literal">new_value</span>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  int original = 100;&#13;
  int&amp; original_ref = original;&#13;
  printf("Original:  %d\n", original); <span class="ent">➊</span>&#13;
  printf("Reference: %d\n", original_ref); <span class="ent">➋</span>&#13;
&#13;
  int new_value = 200;&#13;
  original_ref = new_value; <span class="ent">➌</span>&#13;
  printf("Original:  %d\n", original); <span class="ent">➍</span>&#13;
  printf("New Value: %d\n", new_value); <span class="ent">➎</span>&#13;
  printf("Reference: %d\n", original_ref); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Original:  100 <span class="ent">➊</span></span>&#13;
<span class="color1">Reference: 100 <span class="ent">➋</span></span>&#13;
<span class="color1">Original:  200 <span class="ent">➍</span></span>&#13;
<span class="color1">New Value: 200 <span class="ent">➎</span></span>&#13;
<span class="color1">Reference: 200 <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch03ex11"/><em>Listing 3-11: A program illustrating that you cannot reseat references</em></p>&#13;
<p class="indent">This program initializes an <span class="literal">int</span> called <span class="literal">original</span> to 100. Then it declares a reference to <span class="literal">original</span> called <span class="literal">original_ref</span>. From this point on, <span class="literal">original_ref</span> will <em>always</em> refer to <span class="literal">original</span>. This is illustrated by printing the value of <span class="literal">original</span> <span class="ent">➊</span> and the value referred to by <span class="literal">original_ref</span> <span class="ent">➋</span>. They’re the same.</p>&#13;
<p class="indent">Next, you initialize another <span class="literal">int</span> called <span class="literal">new_value</span> to 200 and assign it to <span class="literal">original</span> <span class="ent">➌</span>. Read that carefully: this assignment <span class="ent">➌</span> doesn’t reseat <span class="literal">original_ref</span> so that it points to <span class="literal">new_value</span>. Rather, it assigns the value of <span class="literal">new_value</span> to the object it points to (<span class="literal">original</span>).</p>&#13;
<p class="indent">The upshot is that all of these variables—<span class="literal">original</span>, <span class="literal">original_ref</span>, and <span class="literal">new_value</span>—evaluate to 200 <span class="ent">➍➎➏</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec10"><strong><em>this Pointers</em></strong></h4>&#13;
<p class="noindent">Remember that methods are associated with classes and that instances of classes are objects. When you program a method, sometimes you need to access the <em>current object</em>, which is the object that is executing the method.</p>&#13;
<p class="indent">Within method definitions, you can access the current object using the <span class="literal">this</span> pointer. Usually, <span class="literal">this</span> isn’t needed, because <span class="literal">this</span> is implicit when accessing members. But sometimes you might need to disambiguate—for example, if you declare a method parameter whose name collides with a member variable. For example, you can rewrite <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> to make explicit which <span class="literal">Element</span> you’re referring to, as demonstrated in <a href="ch03.xhtml#ch03ex12">Listing 3-12</a>.</p>&#13;
<pre>struct Element {&#13;
  Element* next{};&#13;
  void insert_after(Element* new_element) {&#13;
<span epub:type="pagebreak" id="page_81"/>    new_element-&gt;next = this-&gt;next; <span class="ent">➊</span>&#13;
    this-&gt;next <span class="ent">➋</span> = new_element;&#13;
  }&#13;
  char prefix[2];&#13;
  short operating_number;&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex12"/><em>Listing 3-12: A rewriting of <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> using the <span class="literal">this</span> pointer</em></p>&#13;
<p class="indent">Here, <span class="literal">next</span> is replaced with <span class="literal">this-&gt;next</span> <span class="ent">➊➋</span>. The listings are functionally identical.</p>&#13;
<p class="indent">Sometimes, you need <span class="literal">this</span> to resolve ambiguity between members and arguments, as demonstrated in <a href="ch03.xhtml#ch03ex13">Listing 3-13</a>.</p>&#13;
<pre>struct ClockOfTheLongNow {&#13;
  bool set_year(int year<span class="ent">➊</span>) {&#13;
    if (year &lt; 2019) return false;&#13;
    this-&gt;year = year; <span class="ent">➋</span>&#13;
    return true;&#13;
  }&#13;
--<span class="codeitalic1">snip</span>--&#13;
private:&#13;
  int year; <span class="ent">➌</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex13"/><em>Listing 3-13: A verbose <span class="literal">ClockOfTheLongNow</span> definition using <span class="literal">this</span></em></p>&#13;
<p class="indent">The <span class="literal">year</span> argument <span class="ent">➊</span> has the same name as the <span class="literal">year</span> member <span class="ent">➌</span>. Method arguments will always mask members, meaning when you type <span class="literal">year</span> within this method, it refers to the <span class="literal">year</span> argument <span class="ent">➊</span>, not the <span class="literal">year</span> member <span class="ent">➌</span>. That’s no problem: you disambiguate with <span class="literal">this</span> <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec11"><strong><em>const Correctness</em></strong></h4>&#13;
<p class="noindent">The keyword <span class="literal">const</span> (short for “constant”) roughly means “I promise not to modify.” It’s a safety mechanism that prevents unintended (and potentially catastrophic) modifications of member variables. You’ll use <span class="literal">const</span> in function and class definitions to specify that a variable (usually a reference or a pointer) won’t be modified by that function or class. If code attempts to modify a <span class="literal">const</span> variable, the compiler will emit an error. When used correctly, <span class="literal">const</span> is one of the most powerful language features in all modern programming languages because it helps you to eliminate many kinds of common programming mistakes at compile time.</p>&#13;
<p class="indent">Let’s look at a few common usages of <span class="literal">const</span>.</p>&#13;
<h5 class="h5" id="ch03lev3sec5"><strong>const Arguments</strong></h5>&#13;
<p class="noindent">Marking an argument <span class="literal">const</span> precludes its modification within a function’s scope. A <span class="literal">const</span> pointer or reference provides you with an efficient mechanism to pass an object into a function for read-only use. The function in <a href="ch03.xhtml#ch03ex14">Listing 3-14</a> takes a <span class="literal">const</span> pointer.</p>&#13;
<pre><span epub:type="pagebreak" id="page_82"/>void petruchio(const char* shrew<span class="ent">➊</span>) {&#13;
  printf("Fear not, sweet wench, they shall not touch thee, %s.", shrew<span class="ent">➋</span>);&#13;
  shrew[0] = "K"; <span class="ent">➌</span> // Compiler error! The shrew cannot be tamed.&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex14"/><em>Listing 3-14: A function taking a <span class="literal">const</span> pointer (This code doesn’t compile.)</em></p>&#13;
<p class="indent">The <span class="literal">petruchio</span> function takes a <span class="literal">shrew</span> string by <span class="literal">const</span> reference <span class="ent">➊</span>. You can read from <span class="literal">shrew</span> <span class="ent">➋</span>, but attempting to write to it results in a compiler error <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch03lev3sec6"><strong>const Methods</strong></h5>&#13;
<p class="noindent">Marking a method <span class="literal">const</span> communicates that you promise not to modify the current object’s state within the <span class="literal">const</span> method. Put another way, these are read-only methods.</p>&#13;
<p class="indent">To mark a method <span class="literal">const</span>, place the <span class="literal">const</span> keyword after the argument list but before the method body. For example, you could update the <span class="literal">ClockOfTheLongNow</span> object’s <span class="literal">get_year</span> with <span class="literal">const</span>, as demonstrated in <a href="ch03.xhtml#ch03ex15">Listing 3-15</a>.</p>&#13;
<pre>struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  int get_year() const <span class="ent">➊</span>{&#13;
      return year;&#13;
  }&#13;
private:&#13;
  int year;&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex15"/><em>Listing 3-15: Updating <span class="literal">ClockOfTheLongNow</span> with <span class="literal">const</span></em></p>&#13;
<p class="indent">All you need to do is place <span class="literal">const</span> between the argument list and the method body <span class="ent">➊</span>. Had you attempted to modify <span class="literal">year</span> within <span class="literal">get_year</span>, the compiler would have generated an error.</p>&#13;
<p class="indent">Holders of <span class="literal">const</span> references and pointers cannot invoke methods that are not <span class="literal">const</span>, because methods that are not <span class="literal">const</span> might modify an object’s state.</p>&#13;
<p class="indent">The <span class="literal">is_leap_year</span> function in <a href="ch03.xhtml#ch03ex16">Listing 3-16</a> takes a <span class="literal">const ClockOfTheLongNow</span> reference and determines whether it’s a leap year.</p>&#13;
<pre>bool is_leap_year(const ClockOfTheLongNow&amp; clock) {&#13;
  if (clock.get_year() % 4 &gt; 0) return false;&#13;
  if (clock.get_year() % 100 &gt; 0) return true;&#13;
  if (clock.get_year() % 400 &gt; 0) return false;&#13;
  return true;&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex16"/><em>Listing 3-16: A function for determining leap years</em></p>&#13;
<p class="indent">Had <span class="literal">get_year</span> not been marked a <span class="literal">const</span> method, <a href="ch03.xhtml#ch03ex16">Listing 3-16</a> would not compile because <span class="literal">clock</span> is a <span class="literal">const</span> reference and cannot be modified within <span class="literal">is_leap_year</span>.</p>&#13;
<h4 class="h4" id="ch03lev2sec12"><span epub:type="pagebreak" id="page_83"/><strong><em>const Member Variables</em></strong></h4>&#13;
<p class="noindent">You can mark member variables <span class="literal">const</span> by adding the keyword to the member’s type. The <span class="literal">const</span> member variables cannot be modified after their initialization.</p>&#13;
<p class="indent">In <a href="ch03.xhtml#ch03ex17">Listing 3-17</a>, the <span class="literal">Avout</span> class contains two member variables, one <span class="literal">const</span> and one not <span class="literal">const</span>.</p>&#13;
<pre>struct Avout {&#13;
  const<span class="ent">➊</span> char* name = "Erasmas";&#13;
  ClockOfTheLongNow apert; <span class="ent">➋</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch03ex17"/><em>Listing 3-17: An <span class="literal">Avout</span> class with a <span class="literal">const</span> member</em></p>&#13;
<p class="indent">The <span class="literal">name</span> member is <span class="literal">const</span>, meaning the pointed-to value cannot be modified <span class="ent">➊</span>. On the other hand, <span class="literal">apert</span> is not <span class="literal">const</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">Of course, a <span class="literal">const Avout</span> reference cannot be modified, so the usual rules would still apply to <span class="literal">apert</span>:</p>&#13;
<pre>void does_not_compile(const Avout&amp; avout) {&#13;
  avout.apert.add_year(); // Compiler error: avout is const&#13;
}</pre>&#13;
<p class="indent">Sometimes you want the safety of marking a member variable <span class="literal">const</span> but would also like to initialize the member with arguments passed into a constructor. For this, you employ member initializer lists.</p>&#13;
<h4 class="h4" id="ch03lev2sec13"><strong><em>Member Initializer Lists</em></strong></h4>&#13;
<p class="noindent"><em>Member initializer lists</em> are the primary mechanism for initializing class members. To declare a member initializer list, place a colon after the argument list in a constructor. Then insert one or more comma-separated <em>member initializers</em>. A member initializer is the name of the member followed by a braced initialization <span class="literal">{ }</span>. Member initializers allow you to set the value of <span class="literal">const</span> fields at runtime.</p>&#13;
<p class="indent">The example in <a href="ch03.xhtml#ch03ex18">Listing 3-18</a> improves <a href="ch03.xhtml#ch03ex17">Listing 3-17</a> by introducing a member initialization list.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
struct ClockOfTheLongNow {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct Avout {&#13;
  Avout(const char* name, long year_of_apert) <span class="ent">➊</span>&#13;
    :<span class="ent">➋</span> name<span class="ent">➌</span>{ name }<span class="ent">➍</span>, apert<span class="ent">➎</span>{ year_of_apert }<span class="ent">➏</span> {&#13;
  }&#13;
  void announce() const { <span class="ent">➐</span>&#13;
    printf("My name is %s and my next apert is %d.\n", name, apert.get_year());&#13;
  }&#13;
<span epub:type="pagebreak" id="page_84"/>  const char* name;&#13;
  ClockOf<a id="_idTextAnchor135"/><a id="_idTextAnchor136"/>TheLongNow apert;&#13;
};&#13;
&#13;
int main() {&#13;
  Avout raz{ "Erasmas", 3010 };&#13;
  Avout jad{ "Jad", 4000 };&#13;
  raz.announce();&#13;
  jad.announce();&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">My name is Erasmas and my next apert is 3010.</span>&#13;
<span class="color1">My name is Jad and my next apert is 4000.</span></pre>&#13;
<p class="listing"><a id="ch03ex18"/><em>Listing 3-18: A program declaring and announcing two <span class="literal">Avout</span> objects</em></p>&#13;
<p class="indent">The <span class="literal">Avout</span> constructor takes two arguments, a <span class="literal">name</span> and the <span class="literal">year_of_apert</span> <span class="ent">➊</span>. A member initializer list is added by inserting a colon <span class="ent">➋</span> followed by the names of each member you’re initializing <span class="ent">➌➎</span> and braced initializations <span class="ent">➍➏</span>. A <span class="literal">const</span> method <span class="literal">announce</span> is also added to print the <span class="literal">Avout</span> constructor’s status <span class="ent">➐</span>.</p>&#13;
<p class="indent">All member initializations execute before the constructor’s body. This has two advantages:</p>&#13;
<ul>&#13;
<li class="noindent">It ensures validity of all members before the constructor executes, so you can focus on initialization logic rather than member error checking.</li>&#13;
<li class="noindent">The members initialize once. If you reassign members in the constructor, you potentially do extra work.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You should order the member initializers in the same order they appear in the class definition, because their constructors will be called in this order.</em></p>&#13;
</div>&#13;
<p class="indent">Speaking of eliminating extra work, it’s time to meet <span class="literal">auto</span>.</p>&#13;
<h3 class="h3" id="ch03lev1sec4"><strong>auto Type Deduction</strong></h3>&#13;
<p class="noindent">As a strongly typed language, C++ affords its compiler a lot of information. When you initialize elements or return from functions, the compiler can divine type information from context. The <span class="literal">auto</span> keyword tells the compiler to perform such a divination for you, relieving you from inputting redundant type information.</p>&#13;
<h4 class="h4" id="ch03lev2sec14"><strong><em>Initialization with auto</em></strong></h4>&#13;
<p class="noindent">In almost all situations, the compiler can determine the correct type of an object using the initialization value. This assignment contains redundant information:</p>&#13;
<pre>int answer = 42;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_85"/>The compiler knows <span class="literal">answer</span> is an <span class="literal">int</span> because 42 is an <span class="literal">int</span>.</p>&#13;
<p class="indent">You can use <span class="literal">auto</span> instead:</p>&#13;
<pre>auto the_answer { 42 };            // int&#13;
auto foot { 12L };                 // long&#13;
auto rootbeer { 5.0F };            // float&#13;
auto cheeseburger { 10.0 };        // double&#13;
auto politifact_claims { false };  // bool&#13;
auto cheese { "string" };          // char[7]</pre>&#13;
<p class="indent">This also works when you’re initializing with parentheses <span class="literal">()</span> and the lone <span class="literal">=</span>:</p>&#13;
<pre>auto the_answer = 42;&#13;
auto foot(12L);&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">Because you’ve committed to universal initialization with <span class="literal">{}</span> as much as possible, this section will say no more of these alternatives.</p>&#13;
<p class="indent">Alone, all of this simple initialization help doesn’t buy you much; however, when types become more complicated—for example, dealing with iterators from stdlib containers—it really saves quite a bit of typing. It also makes your code more resilient to refactoring.</p>&#13;
<h4 class="h4" id="ch03lev2sec15"><strong><em>auto and Reference Types</em></strong></h4>&#13;
<p class="noindent">It’s common to add modifiers like <span class="literal">&amp;</span>, <span class="literal">*</span>, and <span class="literal">const</span> to <span class="literal">auto</span>. Such modifications add the intended meanings (reference, pointer, and <span class="literal">const</span>, respectively):</p>&#13;
<pre>auto year { 2019 };              // int&#13;
auto&amp; year_ref = year;           // int&amp;&#13;
const auto&amp; year_cref = year;    // const int&amp;&#13;
auto* year_ptr = &amp;year;          // int*&#13;
const auto* year_cptr = &amp;year;   // const int*</pre>&#13;
<p class="indent">Adding modifiers to the <span class="literal">auto</span> declaration behaves just as you’d expect: if you add a modifier, the resulting type is guaranteed to have that modifier.</p>&#13;
<h4 class="h4" id="ch03lev2sec16"><strong><em>auto and Code Refactorings</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">auto</span> keyword assists in making code simpler and more resilient to refactoring. Consider the example in <a href="ch03.xhtml#ch03ex19">Listing 3-19</a> with a range-based <span class="literal">for</span> loop.</p>&#13;
<pre>struct Dwarf {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
Dwarf dwarves[13];&#13;
&#13;
struct Contract {&#13;
  void add(const Dwarf&amp;);&#13;
};&#13;
<span epub:type="pagebreak" id="page_86"/>&#13;
void form_company(Contract &amp;contract) {&#13;
  for (const auto&amp; dwarf : dwarves) { <span class="ent">➊</span>&#13;
    contract.add(dwarf);&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch03ex19"/><em>Listing 3-19: An example using <span class="literal">auto</span> in a range-based <span class="literal">for</span> loop</em></p>&#13;
<p class="indent">If ever the type of <span class="literal">dwarves</span> changes, the assignment in the range-based <span class="literal">for</span> loop <span class="ent">➊</span> doesn’t need to change. The <span class="literal">dwarf</span> type will adapt to its surroundings, in much the same way that the dwarves of Middle Earth don’t.</p>&#13;
<p class="indent">As a general rule, use <span class="literal">auto</span> always.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There are some corner cases to using braced initialization where you might get surprising results, but these are few, especially after C++17 fixed some pedantic nonsense behavior. Prior to C++17, using <span class="literal">auto</span> with braces <span class="literal">{}</span> specified a special object called a <span class="literal">std::initializer_list</span>, which you’ll meet in <a href="ch13.xhtml#ch13">Chapter 13</a>.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter covered the two reference types: references and pointers. Along the way, you learned about the member-of-pointer operator, how pointers and arrays interplay, and <span class="literal">void</span>/<span class="literal">byte</span> pointers. You also learned about the meaning of <span class="literal">const</span> and its basic usage, the <span class="literal">this</span> pointer, and member initializer lists. Additionally, the chapter introduced <span class="literal">auto</span> type deduction.</p>&#13;
<div class="box5" id="bm02">&#13;
<p class="boxtitle-d"><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>3-1.</strong> Read about CVE-2001-0500, a buffer overflow in Microsoft’s Internet Information Services. (This vulnerability is commonly referred to as the Code Red worm vulnerability.)</p>&#13;
<p class="noindent"><strong>3-2.</strong> Add a <span class="literal">read_from</span> and a <span class="literal">write_to</span> function to <a href="ch03.xhtml#ch03ex06">Listing 3-6</a>. These functions should read or write to <span class="literal">upper</span> or <span class="literal">lower</span> as appropriate. Perform bounds checking to prevent buffer overflows.</p>&#13;
<p class="noindent"><strong>3-3.</strong> Add an <span class="literal">Element* previous</span> to <a href="ch03.xhtml#ch03ex09">Listing 3-9</a> to make a <em>doubly linked list</em>. Add an <span class="literal">insert_before</span> method to <span class="literal">Element</span>. Traverse the list from front to back, then from back to front, using two separate <span class="literal">for</span> loops. Print the <span class="literal">operating_number</span> inside each loop.</p>&#13;
<p class="noindent"><strong>3-4.</strong> Reimplement <a href="ch03.xhtml#ch03ex11">Listing 3-11</a> using no explicit types. (Hint: use <span class="literal">auto</span>.)</p>&#13;
<p class="noindent"><strong>3-5.</strong> Scan the listings in <a href="ch02.xhtml#ch02">Chapter 2</a>. Which methods could be marked <span class="literal">const</span>? Where could you use <span class="literal">auto</span> ?</p>&#13;
</div>&#13;
<div class="box6" id="bm03">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_87"/><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li>&#13;
<li class="noindent">“C++ Core Guidelines” by Bjarne Stroustrup and Herb Sutter (<em><a href="https://github.com/isocpp/CppCoreGuidelines/">https://github.com/isocpp/CppCoreGuidelines/</a></em>)</li>&#13;
<li class="noindent">“East End Functions” by Phil Nash (2018; <em><a href="https://levelofindirection.com/blog/east-end-functions.html">https://levelofindirection.com/blog/east-end-functions.html</a></em>)</li>&#13;
<li class="noindent">“References FAQ” by the Standard C++ Foundation (<em><a href="https://isocpp.org/wiki/faq/references/">https://isocpp.org/wiki/faq/references/</a></em>)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>