["```\nint main(void) {\n    return 2;\n}\n```", "```\n$ **gcc -S -O -fno-asynchronous-unwind-tables -fcf-protection=none** **return_2.c**\n```", "```\n .globl main\nmain:\n    movl    $2, %eax\n    ret\n```", "```\n$ **gcc return_2.s -o return_2**\n$ **./return_2**\n$ **echo $?**\n2\n```", "```\n**gcc -E -P** **`INPUT_FILE`** **-o** **`PREPROCESSED_FILE`**\n```", "```\n**gcc** **`ASSEMBLY_FILE`** **-o** **`OUTPUT_FILE`**\n```", "```\nwhile input isn't empty:\n    if input starts with whitespace:\n        trim whitespace from start of input\n    else:\n        find longest match at start of input for any regex in [Table 1-1](chapter1.xhtml#tab1-1)\n        if no match is found, raise an error\n        convert matching substring into a token\n        remove matching substring from start of input\n```", "```\nif (a < b) {\n    return 2 + 2;\n}\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, statement body)\nstatement = Return(exp)\nexp = Constant(int)\n```", "```\nstatement = Return(exp) | If(exp condition, statement then, statement? else)\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" \"{\" <statement> \"}\"\n<statement> ::= \"return\" <exp> \";\"\n<exp> ::= <int>\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\n<statement> ::= \"return\" <exp> \";\" | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n```", "```\nparse_statement(tokens):\n    expect(\"return\", tokens)\n    return_val = parse_exp(tokens)\n    expect(\";\", tokens)\n    return Return(return_val)\n\nexpect(expected, tokens):\n    actual = take_token(tokens)\n    if actual != expected:\n        fail(\"Syntax error\")\n```", "```\nProgram(\n    Function(\n        name=\"main\",\n        body=Return(\n          Constant(2)\n        )\n    )\n)\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, instruction* instructions)\ninstruction = Mov(operand src, operand dst) | Ret\noperand = Imm(int) | Register\n```", "```\n .section .note.GNU-stack,\"\",@progbits\n```", "```\n .section .note.GNU-stack,\"\",@progbits\n```", "```\n .globl `<name>  <name>`:\n    `<instructions>`\n```"]