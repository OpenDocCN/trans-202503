<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Translating Game State Changes to the Display"><div class="titlepage"><div><div><h1 class="title"><a id="translating_game_state_changes_to_the_di"/>Chapter 4. Translating Game State Changes to the Display</h1></div></div></div><p><a id="iddle1042" class="indexterm"/><a id="iddle1093" class="indexterm"/><a id="iddle1246" class="indexterm"/><a id="iddle1313" class="indexterm"/><a id="iddle1334" class="indexterm"/><a id="iddle1340" class="indexterm"/><a id="iddle2342" class="indexterm"/>Animation is a powerful visual cue to show players how their actions affect a game. Whenever a player causes the game state to change, you need to display the results. In this chapter, you’ll add code to detect and remove bubble groups, learn more about animating CSS sprites, and implement a nifty exploding effect in jQuery.</p><p>At this point, players can fire bubbles at the game board, and those bubbles will become part of the bubble grid. Now, we need to pop groups of matching bubbles when a player fires the correct color at them. When <code class="literal">curBubble</code> is fired into another bubble and a group of three or more matching bubbles forms, all bubbles in that group should show a popping animation and then be removed from the display and the <code class="literal">Board</code> object.</p><p>We’ll also need to detect and handle any cascading effects caused by popping bubbles. For example, if sets of bubbles are disconnected from the main group when we pop another set, we should destroy the disconnected bubbles in a different way.</p><div class="sect1" title="Calculating Groups"><div class="titlepage"><div><div><h1 class="title"><a id="calculating_groups"/>Calculating Groups</h1></div></div></div><p><a id="iddle1140" class="indexterm"/><a id="iddle1154" class="indexterm"/><a id="iddle1164" class="indexterm"/><a id="iddle1174" class="indexterm"/><a id="iddle1176" class="indexterm"/><a id="iddle1587" class="indexterm"/><a id="iddle2422" class="indexterm"/>The <code class="literal">Board</code> object contains the row and column information for each bubble in the grid and will determine whether a fired bubble forms a group of three or more when it lands. We’ll add a function to <span class="emphasis"><em>board.js</em></span> that returns all of the bubbles surrounding a given (row,column) position. Then we’ll group them by color and work out which ones to pop.</p><div class="sect2" title="Fetching Bubbles"><div class="titlepage"><div><div><h2 class="title"><a id="fetching_bubbles"/>Fetching Bubbles</h2></div></div></div><p>First, we need to retrieve the set of bubbles surrounding the specified coordinates from the board’s <code class="literal">rows</code> variable. Add the following methods to <span class="emphasis"><em>board.js</em></span> after the <code class="literal">addBubble</code> method:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00071"/><pre class="programlisting">  var Board = function(){
    var that = this;
    var rows = createLayout();
    this.getRows = function(){ return rows;};
    this.addBubble = function(bubble,coords){
      --<span class="emphasis"><em>snip</em></span>--
    };
➊  <span class="strong"><strong>this.getBubbleAt = function(rowNum,colNum){</strong></span>
      <span class="strong"><strong>if(!this.getRows()[rowNum])</strong></span>
        <span class="strong"><strong>return null;</strong></span>
      <span class="strong"><strong>return this.getRows()[rowNum][colNum];</strong></span>
    <span class="strong"><strong>};</strong></span>
➋  <span class="strong"><strong>this.getBubblesAround = function(curRow,curCol){</strong></span>
      <span class="strong"><strong>var bubbles = [];</strong></span>
      <span class="strong"><strong>for(var rowNum = curRow - 1;rowNum &lt;= curRow+1; rowNum++){</strong></span>
        <span class="strong"><strong>for(var colNum =</strong></span> ➌<span class="strong"><strong>curCol-2; colNum &lt;=</strong></span> ➍<span class="strong"><strong>curCol+2; colNum++){</strong></span>
          <span class="strong"><strong>var bubbleAt = that.getBubbleAt(rowNum,colNum);</strong></span>
          <span class="strong"><strong>if(bubbleAt &amp;&amp; !(colNum == curCol &amp;&amp; rowNum == curRow))</strong></span>
➎          <span class="strong"><strong>bubbles.push(bubbleAt);</strong></span>
          <span class="strong"><strong>};</strong></span>
        <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>return bubbles;</strong></span>
    <span class="strong"><strong>};</strong></span>
    return this;
  }</pre><p>The <code class="literal">getBubbleAt</code> method ➊ takes an input row and column coordinate and returns the bubble at that location. If no bubble exists at that location, it returns <code class="literal">null</code>. The <code class="literal">getBubblesAround</code> method ➋ loops through the three relevant rows—the same row, the one above, and the one below—and then examines the surrounding columns, calling <code class="literal">getBubbleAt</code> for each position. Note that <code class="literal">getBubbleAt</code> returns <code class="literal">null</code> for every alternate column entry due to the half-populated row arrays. For this reason, we look at two entries to the left ➌ (<code class="literal">curCol-2</code>) and two to the right ➍ (<code class="literal">curCol+2</code>) of the current bubble. No matter whether we start on an odd or an even row, this method should work. We also need to check that a bubble exists at the coordinates we’re examining and that we don’t add the bubble that we’re checking around ➎.</p><p><a id="iddle1181" class="indexterm"/><a id="iddle1264" class="indexterm"/><a id="iddle1364" class="indexterm"/><a id="iddle1380" class="indexterm"/><a id="iddle1391" class="indexterm"/><a id="iddle1413" class="indexterm"/><a id="iddle1640" class="indexterm"/>Any bubbles surrounding the fired bubble are pushed into the <code class="literal">bubbles</code> array and are returned by <code class="literal">getBubblesAround</code>. Each bubble stores its own coordinates, so we don’t need to sort the array or store position information separately.</p></div><div class="sect2" title="Creating Matching Color Groups"><div class="titlepage"><div><div><h2 class="title"><a id="creating_matching_color_groups"/>Creating Matching Color Groups</h2></div></div></div><p>Next, we’ll write a more substantial function called <code class="literal">getGroup</code> to return groups that are the same color as the first bubble and are connected to that bubble. This recursive function will accept two parameters: a bubble, which sets the starting coordinates and the color (type) definition, and an object, which stores bubbles that are part of the group. The object will store found bubbles in two arrays added as properties: first as a linear array and additionally in an array indexed by row and column. The second array allows us to easily check whether we have already added a bubble to the matching set to avoid adding duplicates. Both arrays are added as properties of an object so we can return both when we call the method. The flowchart in <a class="xref" href="ch04.html#grabbing_a_group_of_connected_bubbles_of" title="Figure 4-1. Grabbing a group of connected bubbles of the same color">Figure 4-1</a> shows an overview of this process.</p><p>The function we’ll add to the <code class="literal">Board</code> class looks like this:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00072"/><pre class="programlisting">var Board = function(){
  var that = this;
  var rows = createLayout();
  this.getRows = function(){ return rows;};
  this.addBubble = function(bubble,coords){
    --<span class="emphasis"><em>snip</em></span>--
  };
  this.getBubbleAt = function(rowNum,colNum){
    --<span class="emphasis"><em>snip</em></span>--
  };
  this.getBubblesAround = function(curRow,curCol){
    --<span class="emphasis"><em>snip</em></span>--
  };
  <span class="strong"><strong>this.getGroup = function(bubble,found){</strong></span>
    <span class="strong"><strong>var curRow = bubble.getRow();</strong></span>
    <span class="strong"><strong>if(!found[curRow])</strong></span>
      <span class="strong"><strong>found[curRow] = {};</strong></span>
    <span class="strong"><strong>if(!found.list)</strong></span>
      <span class="strong"><strong>found.list = [];</strong></span>
    <span class="strong"><strong>if(found[curRow][bubble.getCol()]){</strong></span>
      <span class="strong"><strong>return found;</strong></span>
    <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>found[curRow][bubble.getCol()] = bubble;</strong></span>
    <span class="strong"><strong>found.list.push(bubble);</strong></span>
    <span class="strong"><strong>var curCol = bubble.getCol();</strong></span>
    <span class="strong"><strong>var surrounding = that.getBubblesAround(curRow,curCol);</strong></span>
    <span class="strong"><strong>for(var i=0;i&lt;surrounding.length;i++){</strong></span>
      <span class="strong"><strong>var bubbleAt = surrounding[i];</strong></span>
      <span class="strong"><strong>if(bubbleAt.getType() == bubble.getType()){</strong></span>
        <span class="strong"><strong>found = that.getGroup(bubbleAt,found);</strong></span>
      <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>return found;</strong></span>
  <span class="strong"><strong>};</strong></span>
  return this;
};</pre><p>Let’s break down this new function and walk through the logic. After we pass in the <code class="literal">bubble</code> object and <code class="literal">found</code> object, <code class="literal">getGroup</code> first checks to see if this bubble was already found.</p><a id="pro_id00073"/><pre class="programlisting">   var curRow = bubble.getRow();
➊ if(!found[curRow])
     found[curRow] = {};
➋ if(!found.list)
     found.list = [];
➌ if(found[curRow][bubble.getCol()]){
     return found;
   }
➍ found[curRow][bubble.getCol()] = bubble;
➎ <span class="strong"><strong>found.list.push(bubble);</strong></span></pre><p>If the bubble was already found, <code class="literal">getGroup</code> should return the current unchanged data and stop. If the <code class="literal">found</code> object doesn’t have an entry for the current row, we need to create an empty array ➊. Then, if the <code class="literal">list</code> property doesn’t exist, it needs to be created ➋ but only on the initial call to the function. If this bubble was detected previously, we return the found object without adding the bubble again ➌. Otherwise, we track that we’ve looked in this location ➍ and store the bubble in the <code class="literal">found</code> list ➎.</p><p>Next, we retrieve the surrounding bubbles ➏.</p><a id="pro_id00074"/><pre class="programlisting">   var curCol = bubble.getCol();
➏ var surrounding = that.getBubblesAround(curRow,curCol);</pre><p>At most, there should be six, and then we need to check each for a color match:</p><a id="pro_id00075"/><pre class="programlisting">     for(var i=0;i&lt;surrounding.length;i++){
       var bubbleAt = surrounding[i];
➐     if(bubbleAt.getType() == bubble.getType()){
         found = that.getGroup(bubbleAt,found);
       };
     };
➑ return found;</pre><p>If a bubble matches the fired bubble’s color ➐, the function calls itself; <code class="literal">getGroup</code> adds the checked bubble to the flat array and marks that its coordinates have been checked. The function calls itself again, passing in the newly found bubble and the current data state (with the <code class="literal">found</code> list). Whatever the result, we’ll return the final value of <code class="literal">found</code> ➑.</p><div class="figure"><a id="grabbing_a_group_of_connected_bubbles_of"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00016"/><img src="httpatomoreillycomsourcenostarchimages2184519.png" alt="Grabbing a group of connected bubbles of the same color"/></div></div><p class="title">Figure 4-1. Grabbing a group of connected bubbles of the same color</p></div><p><a id="iddle1314" class="indexterm"/><a id="iddle1043" class="indexterm"/><a id="iddle1343" class="indexterm"/><a id="iddle1558" class="indexterm"/><a id="iddle1923" class="indexterm"/><a id="iddle1936" class="indexterm"/><a id="iddle1963" class="indexterm"/><a id="iddle1974" class="indexterm"/><a id="iddle2330" class="indexterm"/>Now we need to call this method when the bubble is fired. In <span class="emphasis"><em>game.js</em></span>, add in the <code class="literal">clickGameScreen</code> routine:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00076"/><pre class="programlisting">  var clickGameScreen = function(e){
    var angle = BubbleShoot.ui.getBubbleAngle(curBubble.getSprite(),e);
    var duration = 750;
    var distance = 1000;
    var collision = BubbleShoot.CollisionDetector.findIntersection(curBubble,
      board,angle);
    if(collision){
      var coords = {
        x : bubbleCoords.left + distX,
        y : bubbleCoords.top - distY
      };
      duration = Math.round(duration * collision.distToCollision / distance);
      board.addBubble(curBubble,coords);
➊    <span class="strong"><strong>var group = board.getGroup(curBubble,{});</strong></span>
➋    <span class="strong"><strong>if(group.list.length &gt;= 3){</strong></span>
➌      <span class="strong"><strong>popBubbles(group.list,duration);</strong></span>
      <span class="strong"><strong>}</strong></span>
    }else{
      --<span class="emphasis"><em>snip</em></span>--
    };
    BubbleShoot.ui.fireBubble(curBubble,coords,duration);
    curBubble = getNextBubble();
  };</pre><p>When we fetch a group of bubbles with <code class="literal">board.getGroup</code> ➊, we might end up with a group containing fewer than three bubbles. Because we need to consider only groups of three or more bubbles, we’ll skip any smaller groups ➋. Now we just need to write the routine for popping bubbles ➌!</p></div></div><div class="sect1" title="Popping Bubbles"><div class="titlepage"><div><div><h1 class="title"><a id="popping_bubbles"/>Popping Bubbles</h1></div></div></div><p>We need the game to determine whether a group of bubbles has three or more bubbles, and if so, remove those bubbles. In this section, you’ll implement the JavaScript functions that remove bubble groups and add a fun popping animation with CSS.</p><div class="sect2" title="Removing Bubble Groups with JavaScript"><div class="titlepage"><div><div><h2 class="title"><a id="removing_bubble_groups_with_javascript"/>Removing Bubble Groups with JavaScript</h2></div></div></div><p>We’ll begin by calculating what the board should look like after a group has been popped. When that’s complete, we can update the display and remove any popped bubbles from view. As long as the game state is calculated correctly, you can add animation thereafter. Updating the game state and then writing separate code to display the new state is a useful approach to take throughout game development.</p><p><a id="iddle1063" class="indexterm"/><a id="iddle1094" class="indexterm"/><a id="iddle1165" class="indexterm"/><a id="iddle1183" class="indexterm"/><a id="iddle1247" class="indexterm"/><a id="iddle1335" class="indexterm"/><a id="iddle1381" class="indexterm"/><a id="iddle1392" class="indexterm"/><a id="iddle1401" class="indexterm"/><a id="iddle1766" class="indexterm"/><a id="iddle1773" class="indexterm"/><a id="iddle1791" class="indexterm"/><a id="iddle2120" class="indexterm"/><a id="iddle2130" class="indexterm"/><a id="iddle2343" class="indexterm"/><a id="iddle2394" class="indexterm"/><a id="iddle2485" class="indexterm"/>Add a new function called <code class="literal">popBubbles</code> after <code class="literal">clickGameScreen</code>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00077"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      var clickGameScreen = function(e){
        --<span class="emphasis"><em>snip</em></span>--
      };
      <span class="strong"><strong>var popBubbles = function(bubbles,delay){</strong></span>
➊      <span class="strong"><strong>$.each(bubbles,function(){</strong></span>
          <span class="strong"><strong>var bubble = this;</strong></span>
➋        <span class="strong"><strong>board.popBubbleAt(this.getRow(),this.getCol());</strong></span>
          <span class="strong"><strong>setTimeout(function(){</strong></span>
            <span class="strong"><strong>bubble.getSprite().remove();</strong></span>
          <span class="strong"><strong>},delay + 200);</strong></span>
        <span class="strong"><strong>});</strong></span>
      <span class="strong"><strong>};</strong></span>
    };
    return Game;
  })(jQuery);</pre><p>The <code class="literal">popBubbles</code> function loops over each <code class="literal">bubble</code> object in the array we pass it ➊ and tells the board to remove the bubble ➋ by calling <code class="literal">popBubbleAt</code> (which we’ll write next). Then it waits for <code class="literal">delay + 200</code> milliseconds to remove the bubble from the DOM to allow time for the animation of firing the bubble to run. As a result, the user can see what’s happened before the screen is updated. The starting value of <code class="literal">delay</code> is passed in from the fired bubble’s duration—the time it took to travel from its starting point—so bubbles will always disappear 200 milliseconds after the grouping has occurred.</p><p>The final piece of code is in <span class="emphasis"><em>board.js</em></span>, where we need to define <code class="literal">popBubbleAt</code>. Add the following method after the close of the <code class="literal">getGroup</code> method:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00078"/><pre class="programlisting">var Board = function(){
  --<span class="emphasis"><em>snip</em></span>--
  this.getGroup = function(bubble,found){
    --<span class="emphasis"><em>snip</em></span>--
  };
  <span class="strong"><strong>this.popBubbleAt = function(rowNum,colNum){</strong></span>
    <span class="strong"><strong>var row = rows[rowNum];</strong></span>
    <span class="strong"><strong>delete row[colNum];</strong></span>
  <span class="strong"><strong>};</strong></span>
  return this;
};</pre><p>The <code class="literal">popBubbleAt</code> method simply removes the entry you pass it from the row/column array.</p><p>Reload the game and fire a bubble. When you make a set of three or more bubbles, they should disappear from view. At last, <span class="emphasis"><em>Bubble Shooter</em></span> is starting to look more like a game!</p></div><div class="sect2" title="Popping Animations with CSS"><div class="titlepage"><div><div><h2 class="title"><a id="popping_animations_with_css"/>Popping Animations with CSS</h2></div></div></div><p><a id="iddle1044" class="indexterm"/><a id="iddle1054" class="indexterm"/><a id="iddle1095" class="indexterm"/><a id="iddle1099" class="indexterm"/><a id="iddle1121" class="indexterm"/><a id="iddle1248" class="indexterm"/><a id="iddle1315" class="indexterm"/><a id="iddle1336" class="indexterm"/><a id="iddle1374" class="indexterm"/><a id="iddle1665" class="indexterm"/><a id="iddle2344" class="indexterm"/><a id="iddle2515" class="indexterm"/><a id="iddle2524" class="indexterm"/><a id="iddle2525" class="indexterm"/><a id="iddle2529" class="indexterm"/><span class="emphasis"><em>Moving</em></span> sprites around the screen with CSS is one type of animation, but now it’s time to animate sprites in a different way and change how they <span class="emphasis"><em>look.</em></span> This will present players with a visually rewarding popping animation, which will use the other sprite frames we created at the beginning of the book.</p><p>The best way to animate a sprite graphic is by changing the position of its background image. Recall that <span class="emphasis"><em>bubble_sprite_sheet.png</em></span> (shown again in <a class="xref" href="ch04.html#four_states_of_the_bubble_spritecomma_as" title="Figure 4-2. The four states of the bubble sprite, as contained in bubble_sprite_sheet.png">Figure 4-2</a> for convenience) contains not only the four bubble types but also four different states for each color.</p><div class="figure"><a id="four_states_of_the_bubble_spritecomma_as"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00017"/><img src="httpatomoreillycomsourcenostarchimages2184521.png.jpg" alt="The four states of the bubble sprite, as contained in bubble_sprite_sheet.png"/></div></div><p class="title">Figure 4-2. The four states of the bubble sprite, as contained in <span class="emphasis"><em>bubble_sprite_sheet.png</em></span></p></div><p>We can display a popping animation by showing the four frames in succession, which we’ll do by shifting the background image to the left by 50 pixels at a time.</p><p>The game pops only bubbles in groups, but the popping effect won’t be nearly as fun to watch if all the bubbles in a group disappear at once. To make the effect more interesting, we’ll pop the bubbles individually rather than all together. Doing so will require a small change to the <code class="literal">popBubbles</code> method we just added to <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00079"/><pre class="programlisting">  var popBubbles = function(bubbles,delay){
    $.each(bubbles,function(){
      var bubble = this;
      <span class="strong"><strong>setTimeout(function(){</strong></span>
➊      <span class="strong"><strong>bubble.animatePop();</strong></span>
      <span class="strong"><strong>},delay);</strong></span>
      board.popBubbleAt(bubble.getRow(),bubble.getCol());
      setTimeout(function(){
        bubble.getSprite().remove();
      },delay + 200);
➋    <span class="strong"><strong>delay += 60;</strong></span>
    });
  };</pre><p><a id="iddle1085" class="indexterm"/><a id="iddle1125" class="indexterm"/><a id="iddle1365" class="indexterm"/><a id="iddle1684" class="indexterm"/><a id="iddle1687" class="indexterm"/><a id="iddle1780" class="indexterm"/><a id="iddle2009" class="indexterm"/><a id="iddle2196" class="indexterm"/><a id="iddle2237" class="indexterm"/><a id="iddle2304" class="indexterm"/><a id="iddle2522" class="indexterm"/><a id="iddle2601" class="indexterm"/>Here, we call <code class="literal">animatePop</code> ➊, a new method that we’ll add to <code class="literal">Bubble</code> to change the bubble’s background image position. The first bubble’s popping animation should start as soon as the fired bubble collides with it. But subsequent pops should be delayed by 60 milliseconds by incrementing <code class="literal">delay</code> ➋. Add <code class="literal">animatePop</code> to <span class="emphasis"><em>bubble.js</em></span>.</p><p><span class="emphasis"><em>bubble.js</em></span></p><a id="pro_id00080"/><pre class="programlisting">  var Bubble = function(row,col,type,sprite){
    --<span class="emphasis"><em>snip</em></span>--
    this.getCoords = function(){
    --<span class="emphasis"><em>snip</em></span>--
    };
    <span class="strong"><strong>this.animatePop = function(){</strong></span>
➊    <span class="strong"><strong>var top = type * that.getSprite().height();</strong></span>
➋    <span class="strong"><strong>this.getSprite().css(Modernizr.prefixed("transform"),"rotate(" + (Math.</strong></span>
        <span class="strong"><strong>random() * 360) + "deg)");</strong></span>
➌    <span class="strong"><strong>setTimeout(function(){</strong></span>
        <span class="strong"><strong>that.getSprite().css("background-position","-50px -" + top + "px");</strong></span>
      <span class="strong"><strong>},125);</strong></span>
      <span class="strong"><strong>setTimeout(function(){</strong></span>
        <span class="strong"><strong>that.getSprite().css("background-position","-100px -" + top + "px");</strong></span>
      <span class="strong"><strong>},150);</strong></span>
      <span class="strong"><strong>setTimeout(function(){</strong></span>
        <span class="strong"><strong>that.getSprite().css("background-position","-150px -" + top + "px");</strong></span>
      <span class="strong"><strong>},175);</strong></span>
➍    <span class="strong"><strong>setTimeout(function(){</strong></span>
        <span class="strong"><strong>that.getSprite().remove();</strong></span>
      <span class="strong"><strong>},200);</strong></span>
    <span class="strong"><strong>};</strong></span>
  };</pre><p>Based on the bubble’s type, <code class="literal">animatePop</code> calculates ➊ the value representing the top part of the bubble’s <code class="literal">background-position</code> property. The <code class="literal">type</code> value tells us what color the bubble should be; we’ll use it to select the appropriate row of popping animation images. Next, using a basic CSS transformation, we add a bit of visual variation ➋ to the animation by rotating the bubble sprite at a random angle to prevent all the popping animations from appearing identical. You’ll see more examples of CSS transformations in <a class="xref" href="ch05.html" title="Chapter 5. CSS Transitions and Transformations">Chapter 5</a>. To stagger the start time of each popping animation, the function makes three delayed calls ➌ that move the <code class="literal">background-position</code> to the left by 50 pixels.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><span class="emphasis"><em>Hard-coding an animation this way is not very scalable, but</em></span> Bubble Shooter <span class="emphasis"><em>has only one sprite with three frames to display. Therefore, we can avoid writing a generic function, which is the reason we use a sequence of <code class="literal">setTimeout</code> calls instead. When we implement the same animation using <code class="literal">canvas</code> rendering, you’ll see an example of how to code an animation that is more reusable.</em></span></p></div><p>Finally, <code class="literal">animatePop</code> removes the sprite’s DOM element ➍ when the animation has finished. Removing the node from the DOM helps with memory management, which would be even more important in a game with more onscreen objects. At approximately 20 frames per second, the resulting <a id="iddle1235" class="indexterm"/><a id="iddle1326" class="indexterm"/><a id="iddle1327" class="indexterm"/><a id="iddle1341" class="indexterm"/><a id="iddle2292" class="indexterm"/><a id="iddle2293" class="indexterm"/>animation frame rate is fairly poor. A professional game should have a frame rate of three times that number. But the principle of creating an animation by shifting a background image is the same regardless.</p><p>When you reload the page and fire a bubble to make a matching group, you should see a pleasing popping animation. However, after popping numerous bubbles, you may see a side effect of removing bubbles that we need to remedy: a popped group might be the only element holding a set of bubbles of varied colors onto the main board. Currently, these bubbles are left hanging in space and look a bit odd. Because the game design stipulates that these bubbles be removed as well, we’ll do that next.</p></div></div><div class="sect1" title="Orphaned Groups"><div class="titlepage"><div><div><h1 class="title"><a id="orphaned_groups"/>Orphaned Groups</h1></div></div></div><p>Groups of bubbles that have been disconnected from the rest of the board are called <span class="emphasis"><em>orphans</em></span>. For example, in <a class="xref" href="ch04.html#popping_the_red_bubbles_creates_four_orp" title="Figure 4-3. Popping the red bubbles creates four orphaned bubbles.">Figure 4-3</a>, popping the boxed group of bubbles would leave four orphaned bubbles hanging in midair. Orphaned sets of bubbles need to be removed by the firing bubble as well. But rather than have them pop in the same way as popped groups, we’ll add a different animation. Orphans will fall off the screen and appear as though they were hanging and had their supports cut. Not only will players recognize that something different has happened, but we also get to experiment with a different animation type. Currently, detecting orphaned groups is not part of the code; so, before we can animate them, we need to find them.</p><div class="figure"><a id="popping_the_red_bubbles_creates_four_orp"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00018"/><img src="httpatomoreillycomsourcenostarchimages2184523.png.jpg" alt="Popping the red bubbles creates four orphaned bubbles."/></div></div><p class="title">Figure 4-3. Popping the red bubbles creates four orphaned bubbles.</p></div><div class="sect2" title="Identifying Orphaned Bubbles"><div class="titlepage"><div><div><h2 class="title"><a id="identifying_orphaned_bubbles"/>Identifying Orphaned Bubbles</h2></div></div></div><p>We’ll check each bubble and determine whether it’s part of a group that’s connected to any bubbles in the top row. Because the top row is considered <a id="iddle1155" class="indexterm"/><a id="iddle1182" class="indexterm"/><a id="iddle1328" class="indexterm"/><a id="iddle2294" class="indexterm"/><a id="iddle2423" class="indexterm"/>to be permanently attached, any bubble that can’t trace a route back to the top row will be identified as part of an orphaned group.</p><p>Tracing this route might seem like a problem we haven’t encountered yet; however, we can actually use the already written <code class="literal">getGroup</code> method and find orphaned sets quite simply. <a class="xref" href="ch04.html#logic_flow_for_determining_the_set_of_or" title="Figure 4-4. The logic flow for determining the set of orphaned bubbles">Figure 4-4</a> shows the process for checking whether a group is part of an orphaned set.</p><div class="figure"><a id="logic_flow_for_determining_the_set_of_or"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00019"/><img src="httpatomoreillycomsourcenostarchimages2184525.png.jpg" alt="The logic flow for determining the set of orphaned bubbles"/></div></div><p class="title">Figure 4-4. The logic flow for determining the set of orphaned bubbles</p></div><p><a id="iddle1141" class="indexterm"/><a id="iddle1166" class="indexterm"/><a id="iddle1177" class="indexterm"/><a id="iddle1265" class="indexterm"/><a id="iddle1316" class="indexterm"/><a id="iddle1588" class="indexterm"/><a id="iddle1641" class="indexterm"/>Using this logic, we can reuse the <code class="literal">getGroup</code> function in step 2. But to do so, we need to revise the criterion that bubbles must be the same color to form a group.</p><p>Let’s change <code class="literal">getGroup</code> to take a parameter that allows for the selection of nonmatching color groups:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00081"/><pre class="programlisting">  var Board = function(){
    --<span class="emphasis"><em>snip</em></span>--
➊  this.getGroup = function(bubble,found<span class="strong"><strong>,differentColor</strong></span>){
      var curRow = bubble.getRow();
      if(!found[curRow])
        found[curRow] = {};
      if(!found.list)
        found.list = [];
      if(found[curRow][bubble.getCol()]){
        return found;
      }
      found[curRow][bubble.getCol()] = bubble;
      found.list.push(bubble);
      var curCol = bubble.getCol();
      var surrounding = that.getBubblesAround(curRow,curCol);
      for(var i=0;i&lt;surrounding.length;i++){
        var bubbleAt = surrounding[i];
➋      if(bubbleAt.getType() == bubble.getType() <span class="strong"><strong>|| differentColor</strong></span>){
          found = that.getGroup(bubbleAt,found<span class="strong"><strong>,differentColor</strong></span>);
        };
      };
      return found;
    };
  }</pre><p>The function definition now takes an extra parameter ➊. Where <code class="literal">getGroup</code> is called recursively, it should ignore the type check ➋ if the value is set to <code class="literal">true</code>, and it passes the input parameter through the recursion chain. With these simple changes, a <code class="literal">getGroup(bubble,{},true)</code> call should return all bubbles that the passed bubble is connected to regardless of color. Calling <code class="literal">getGroup(bubble,{},false)</code> or just <code class="literal">getGroup(bubble,{})</code> should operate the same way as before.</p><p>The <code class="literal">findOrphans</code> function will be a method in the <code class="literal">Board</code> class and will examine every bubble in the top row, finding the group of bubbles each one connects to. (Initially, every bubble on the board will be in one big group, except the bubble to be fired.) An array of (row,column) values will be populated with false values, and every time a bubble is found, the (row,column) entry will be set to true for that location. At the end of the process, coordinates that contain a bubble but have a value set to <code class="literal">false</code> in the returned array will be orphaned and removed from the game.</p><p><a id="iddle1175" class="indexterm"/><a id="iddle1382" class="indexterm"/><a id="iddle1393" class="indexterm"/>Add the following code to <span class="emphasis"><em>board.js</em></span> after <code class="literal">popBubbleAt</code>:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00082"/><pre class="programlisting">var Board = function(){
  --<span class="emphasis"><em>snip</em></span>--
  this.popBubbleAt = function(rowNum,colNum){
    --<span class="emphasis"><em>snip</em></span>--
  };
  <span class="strong"><strong>this.findOrphans = function(){</strong></span>
    <span class="strong"><strong>var connected = [];</strong></span>
    <span class="strong"><strong>var groups = [];</strong></span>
    <span class="strong"><strong>var rows = that.getRows();</strong></span>
    <span class="strong"><strong>for(var i=0;i&lt;rows.length;i++){</strong></span>
      <span class="strong"><strong>connected[i] = [];</strong></span>
    <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>for(var i=0;i&lt;rows[0].length;i++){</strong></span>
      <span class="strong"><strong>var bubble = that.getBubbleAt(0,i);</strong></span>
      <span class="strong"><strong>if(bubble &amp;&amp; !connected[0][i]){</strong></span>
        <span class="strong"><strong>var group = that.getGroup(bubble,{},true);</strong></span>
        <span class="strong"><strong>$.each(group.list,function(){</strong></span>
          <span class="strong"><strong>connected[this.getRow()][this.getCol()] = true;</strong></span>
        <span class="strong"><strong>});</strong></span>
      <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>var orphaned = [];</strong></span>
    <span class="strong"><strong>for(var i=0;i&lt;rows.length;i++){</strong></span>
      <span class="strong"><strong>for(var j=0;j&lt;rows[i].length;j++){</strong></span>
        <span class="strong"><strong>var bubble = that.getBubbleAt(i,j);</strong></span>
        <span class="strong"><strong>if(bubble &amp;&amp; !connected[i][j]){</strong></span>
          <span class="strong"><strong>orphaned.push(bubble);</strong></span>
        <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>return orphaned;</strong></span>
  <span class="strong"><strong>};</strong></span>
  return this;
};</pre><p>Let’s analyze the <code class="literal">findOrphans</code> function more closely. First, we set up the arrays we need to find orphaned groups.</p><a id="pro_id00083"/><pre class="programlisting">➊ var connected = [];
➋ var groups = [];
   var rows = that.getRows();
   for(var i=0;i&lt;rows.length;i++){
     connected[i] = [];
   };</pre><p><a id="iddle1142" class="indexterm"/><a id="iddle1156" class="indexterm"/><a id="iddle1266" class="indexterm"/><a id="iddle1589" class="indexterm"/><a id="iddle1642" class="indexterm"/><a id="iddle2424" class="indexterm"/>The <code class="literal">connected</code> array ➊ is a two-dimensional array of rows and columns; it marks the locations of connected bubbles. The <code class="literal">groups</code> array ➋ will contain a set of all the groups found, which will be a single group if the entire board is connected. Next, we examine each bubble in the top row.</p><a id="pro_id00084"/><pre class="programlisting">for(var i=0;i&lt;rows[0].length;i++){
  var bubble = that.getBubbleAt(0,i);</pre><p>Here, because we’re only interested in bubbles connected to the top row, we loop over just the top row and fetch bubbles to check. When we have a bubble, we can start creating groups.</p><a id="pro_id00085"/><pre class="programlisting">if(bubble &amp;&amp; !connected[0][i]){
  var group = that.getGroup(bubble,{},true);</pre><p>If a bubble is present and this space hasn’t already been marked as connected, we build a group. The call to <code class="literal">getGroup</code> passes <code class="literal">true</code> as the third parameter (<code class="literal">differentColor</code>), because we don’t want to restrict connected bubbles by color.</p><a id="pro_id00086"/><pre class="programlisting">      $.each(group.list,function(){
        connected[this.getRow()][this.getCol()] = true;
      });
  };
};</pre><p>Because the bubble being checked is connected via the first row, the entire group is connected; therefore, we mark each entry in the <code class="literal">connected</code> array with a true flag.</p><p>After calling <code class="literal">findOrphans</code>, we should have an array of connected row and column entries. A list of orphaned bubbles is the final output we want, so we need to create another empty array to hold that list. A single-dimensional array is sufficient because the bubbles store their own coordinates:</p><a id="pro_id00087"/><pre class="programlisting">  var orphaned = [];
  for(var i=0;i&lt;rows.length;i++){
    for(var j=0;j&lt;rows[i].length;j++){
      var bubble = that.getBubbleAt(i,j);
      if(bubble &amp;&amp; !connected[i][j]){
        orphaned.push(bubble);
      };
    };
  };
  return orphaned;
};</pre><p>Using this new array, we examine all the rows and columns on the board, checking whether a bubble exists at each space. If a bubble exists but no entry <a id="iddle1059" class="indexterm"/><a id="iddle1236" class="indexterm"/><a id="iddle1279" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle1786" class="indexterm"/><a id="iddle1788" class="indexterm"/><a id="iddle1927" class="indexterm"/><a id="iddle1937" class="indexterm"/><a id="iddle1964" class="indexterm"/><a id="iddle1975" class="indexterm"/><a id="iddle2331" class="indexterm"/>is in the connected grid, it’s an orphan. We then add it to the orphaned list with the call to <code class="literal">orphaned.push(bubble)</code>. Finally, <code class="literal">findOrphans</code> returns the array of orphaned bubbles, which should be empty if no orphans exist.</p></div><div class="sect2" title="Dropping Orphaned Bubbles"><div class="titlepage"><div><div><h2 class="title"><a id="dropping_orphaned_bubbles"/>Dropping Orphaned Bubbles</h2></div></div></div><p>Now that we can find the groups of bubbles that will be orphaned, we need to call the function and remove any identified orphaned bubbles. Rather than pop, we want the orphaned bubbles to drop, using an animation that occurs after the popping animation has completed. The internal game state will still update instantaneously, because we calculate the outcome as soon as the player has fired the bubble. We add the delay not just to provide a more dramatic effect, but also so players can follow the results of their actions onscreen. If we animated the falling orphaned groups as soon as we knew they would be orphaned, the effect might be lost. In addition, players might be confused as to why bubbles of different colors had disappeared.</p><p>In this situation, the benefits of separating game state from display state are apparent. We update the game state instantly, players can fire their next bubble almost immediately without having to wait for completed animations, and the game feels responsive. But in the display state, we make a big deal of this game state change—for effect and to communicate how the player’s actions lead to the final result. The animation approach is very much a game design decision rather than a coding one, but the way we’ve coded the game allows for flexibility.</p><p>In <span class="emphasis"><em>game.js</em></span>, add the following after the call to <code class="literal">popBubbles</code>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00088"/><pre class="programlisting">  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
    var clickGameScreen = function(e){
      --<span class="emphasis"><em>snip</em></span>--
      if(collision){
        --<span class="emphasis"><em>snip</em></span>--
➊      if(group.list.length &gt;= 3){
          popBubbles(group.list,duration);
➋        <span class="strong"><strong>var orphans = board.findOrphans();</strong></span>
➌        <span class="strong"><strong>var delay = duration + 200 + 30 * group.list.length;</strong></span>
➍        <span class="strong"><strong>dropBubbles(orphans,delay);</strong></span>
        };
      }else{
        --<span class="emphasis"><em>snip</em></span>--
      };
      BubbleShoot.ui.fireBubble(curBubble,coords,duration);
      curBubble = getNextBubble();
    };
  };</pre><p>We need to check for new orphans only if bubbles have been popped ➊, because that’s how orphaned groups are formed. We pop bubbles only if a matching group of three or more is created, so if <code class="literal">group.list</code> is greater than <a id="iddle1037" class="indexterm"/><a id="iddle1072" class="indexterm"/><a id="iddle1184" class="indexterm"/><a id="iddle1281" class="indexterm"/><a id="iddle1383" class="indexterm"/><a id="iddle1394" class="indexterm"/><a id="iddle1402" class="indexterm"/><a id="iddle1836" class="indexterm"/><a id="iddle1996" class="indexterm"/><a id="iddle2110" class="indexterm"/><a id="iddle2129" class="indexterm"/><a id="iddle2242" class="indexterm"/><a id="iddle2321" class="indexterm"/><a id="iddle2486" class="indexterm"/>or equal to three, we need to look for orphaned bubbles. As we retrieve the orphans ➋, we calculate a delay ➌ timed to drop bubbles when all the popping has finished. To perform the animation, we need to write <code class="literal">dropBubbles</code> ➍.</p><p>The <code class="literal">dropBubbles</code> method will drop the bubbles off the screen. Add the following code after the close of the <code class="literal">popBubbles</code> function in <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00089"/><pre class="programlisting">  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
    var popBubbles = function(bubbles,delay){
      --<span class="emphasis"><em>snip</em></span>--
    };
    <span class="strong"><strong>var dropBubbles = function(</strong></span>➊<span class="strong"><strong>bubbles,delay){</strong></span>
      <span class="strong"><strong>$.each(bubbles,function(){</strong></span>
        <span class="strong"><strong>var bubble = this;</strong></span>
➋      <span class="strong"><strong>board.popBubbleAt(bubble.getRow(),bubble.getCol());</strong></span>
        <span class="strong"><strong>setTimeout(function(){</strong></span>
➌        <span class="strong"><strong>bubble.getSprite().animate({</strong></span>
            <span class="strong"><strong>top : 1000</strong></span>
          <span class="strong"><strong>},1000);</strong></span>
        <span class="strong"><strong>},delay);</strong></span>
      <span class="strong"><strong>});</strong></span>
    <span class="strong"><strong>};</strong></span>
  };</pre><p>The <code class="literal">dropBubbles</code> function takes in parameters for the bubbles to drop ➊ (we’ll pass it the array of bubbles returned by <code class="literal">findOrphans</code>) and a delay. It removes the bubbles from the board ➋ and then animates them as they drop down the screen ➌.</p><p>Refresh the game and pop a few groups of bubbles. When you form an orphan group, the bubbles should drop off the screen rather than popping.</p></div></div><div class="sect1" title="Exploding Bubbles with a jQuery Plug-in"><div class="titlepage"><div><div><h1 class="title"><a id="exploding_bubbles_with_a_jquery_plug-in"/>Exploding Bubbles with a jQuery Plug-in</h1></div></div></div><p>Although dropping bubbles is an animation, it’s not very dramatic. Let’s liven it up and create more of an explosion! We’ll write a jQuery plug-in to control this animation and abstract it from the game system.</p><p>To make the orphaned bubbles animation more impressive, we’ll make the bubbles burst outward before dropping down the screen. We’ll do this by assigning a starting momentum to each bubble and then adjusting its speed with some simulated gravity.</p><p>Although writing all the code to do this inline inside <code class="literal">dropBubbles</code> is possible, it would start to clutter the <code class="literal">Game</code> class with display logic. However, this animation is an ideal candidate for a jQuery plug-in, and the advantage is that we can reuse the code in future projects.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note02"/>Note</h3><p><span class="emphasis"><em>For this example, I’ll cover only the most basic principles of writing jQuery plug-ins. You can explore plug-ins in more depth at</em></span> <a class="ulink" href="http://learn.jquery.com/plugins/basic-plugin-creation/">http://learn.jquery.com/plugins/basic-plugin-creation/</a>.</p></div><p><a id="iddle1767" class="indexterm"/><a id="iddle2136" class="indexterm"/><a id="iddle2137" class="indexterm"/><a id="iddle2234" class="indexterm"/><a id="iddle2373" class="indexterm"/>Make a new file called <span class="emphasis"><em>jquery.kaboom.js</em></span> in the <span class="emphasis"><em>_js</em></span> folder and add it to the <code class="literal">Modernizr.load</code> call. The file-naming convention informs others glancing in your <span class="emphasis"><em>scripts</em></span> folder that this file is a jQuery plug-in; they don’t even need to look at the code.</p><p>First, we register the method—which we’ll name <code class="literal">kaboom</code>—by using jQuery’s plug-in format:</p><p><span class="emphasis"><em>jquery.kaboom.js</em></span></p><a id="pro_id00090"/><pre class="programlisting">(function(jQuery){
  jQuery.fn.kaboom = function(settings)
  {
  };
})(jQuery);</pre><p>We’ll flesh out this code shortly; right now it doesn’t do anything. This function definition is the standard way of registering a new plug-in with jQuery. Its structure enables calls of the form <code class="literal">$(...).kaboom()</code>, including passing an optional settings parameter.</p><p>The call to <code class="literal">kaboom</code> will be inside <code class="literal">dropBubbles</code>, so let’s add that call to <code class="literal">dropBubbles</code> and remove the <code class="literal">animate</code> calls:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00091"/><pre class="programlisting">var Game = function(){
  --<span class="emphasis"><em>snip</em></span>--
  var popBubbles = function(bubbles,delay){
    --<span class="emphasis"><em>snip</em></span>--
  };
  var dropBubbles = function(bubbles,delay){
    $.each(bubbles,function(){
      var bubble = this;
      board.popBubbleAt(bubble.getRow(),bubble.getCol());
      setTimeout(function(){
        <span class="strong"><strong>bubble.getSprite().kaboom();</strong></span>
      },delay);
    });
    return;
  };
};</pre><p>The <code class="literal">kaboom</code> method will be called once for each object. This method will also only operate on jQuery objects; as a jQuery plug-in, it will have no knowledge of the game objects and will work only with DOM elements, making the plug-in reusable in future games.</p><p>Inside <code class="literal">jquery.fn.kaboom</code>, we’ll use an array to store all the objects currently being exploded. Every time we call <code class="literal">kaboom</code>, we’ll add the calling object to that array. When the bubble has finished moving, it should remove itself from the list. By storing everything we want to move in an array, we can run a single <code class="literal">setTimeout</code> loop and update the position of all falling bubbles at the same time. Consequently, we’ll avoid having multiple <code class="literal">setTimeouts</code> clamoring for processing power, and the animation should run much more smoothly.</p><p><a id="iddle1073" class="indexterm"/><a id="iddle1997" class="indexterm"/><a id="iddle2353" class="indexterm"/>We’ll also add two more components: some default parameters for gravity and the distance we want a bubble to fall before we consider it off the screen and no longer part of the function.</p><p><span class="emphasis"><em>jquery.kaboom.js</em></span></p><a id="pro_id00092"/><pre class="programlisting">  (function(jQuery){
➊  <span class="strong"><strong>var defaults = {</strong></span>
      <span class="strong"><strong>gravity : 1.3,</strong></span>
      <span class="strong"><strong>maxY : 800</strong></span>
    <span class="strong"><strong>};</strong></span>
➋  <span class="strong"><strong>var toMove = [];</strong></span>
    jQuery.fn.kaboom = function(settings){
    }
  })(jQuery);</pre><p>The default values are <code class="literal">gravity</code> and <code class="literal">maxY</code> ➊, and <code class="literal">toMove</code> ➋ will hold the falling jQuery objects.</p><p>At present, nothing happens when <code class="literal">kaboom</code> is called. The full <code class="literal">jquery.kaboom</code> plug-in follows:</p><p><span class="emphasis"><em>jquery.kaboom.js</em></span></p><a id="pro_id00093"/><pre class="programlisting">  (function(jQuery){
    var defaults = {
      gravity : 1.3,
      maxY : 800
    };
    var toMove = [];
➊  <span class="strong"><strong>jQuery.fn.kaboom = function(settings){</strong></span>
      <span class="strong"><strong>var config = $.extend({}, defaults, settings);</strong></span>
      <span class="strong"><strong>if(toMove.length == 0){</strong></span>
        <span class="strong"><strong>setTimeout(moveAll,40);</strong></span>
      <span class="strong"><strong>};</strong></span>
      <span class="strong"><strong>var dx = Math.round(Math.random() * 10) – 5;</strong></span>
      <span class="strong"><strong>var dy = Math.round(Math.random() * 5) + 5;</strong></span>
      <span class="strong"><strong>toMove.push({</strong></span>
        <span class="strong"><strong>elm : this,</strong></span>
        <span class="strong"><strong>dx : dx,</strong></span>
        <span class="strong"><strong>dy : dy,</strong></span>
        <span class="strong"><strong>x : this.position().left,</strong></span>
        <span class="strong"><strong>y : this.position().top,</strong></span>
        <span class="strong"><strong>config : config</strong></span>
      <span class="strong"><strong>});</strong></span>
    <span class="strong"><strong>};</strong></span>
➋  <span class="strong"><strong>var moveAll = function(){</strong></span>
      <span class="strong"><strong>var frameProportion = 1;</strong></span>
      <span class="strong"><strong>var stillToMove = [];</strong></span>
      <span class="strong"><strong>for(var i=0;i&lt;toMove.length;i++){</strong></span>
        <span class="strong"><strong>var obj = toMove[i];</strong></span>
        <span class="strong"><strong>obj.x += obj.dx * frameProportion;</strong></span>
        <span class="strong"><strong>obj.y -= obj.dy * frameProportion;</strong></span>
        <span class="strong"><strong>obj.dy -= obj.config.gravity * frameProportion;</strong></span>
        <span class="strong"><strong>if(obj.y &lt; obj.config.maxY){</strong></span>
          <span class="strong"><strong>obj.elm.css({</strong></span>
            <span class="strong"><strong>top : Math.round(obj.y),</strong></span>
            <span class="strong"><strong>left : Math.round(obj.x)</strong></span>
          <span class="strong"><strong>});</strong></span>
          <span class="strong"><strong>stillToMove.push(obj);</strong></span>
        <span class="strong"><strong>}else if(obj.config.callback){</strong></span>
          <span class="strong"><strong>obj.config.callback();</strong></span>
     <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>};</strong></span>
    <span class="strong"><strong>toMove = stillToMove;</strong></span>
    <span class="strong"><strong>if(toMove.length &gt; 0)</strong></span>
        <span class="strong"><strong>setTimeout(moveAll,40);</strong></span>
    <span class="strong"><strong>};</strong></span>
  })(jQuery);</pre><p><a id="iddle1101" class="indexterm"/><a id="iddle1685" class="indexterm"/><a id="iddle2665" class="indexterm"/>Two main loops are in this plug-in: <code class="literal">jQuery.fn.kaboom</code> ➊, which adds new elements to the animation queue, and <code class="literal">moveAll</code> ➋, which handles the animation.</p><p>Let’s look at <code class="literal">jQuery.fn.kaboom</code> in more detail first:</p><a id="pro_id00094"/><pre class="programlisting">  jQuery.fn.kaboom = function(settings){
➊  var config = $.extend({}, defaults, settings);
➋  if(toMove.length == 0){
      setTimeout(moveAll,40);
    };
➌  var dx = Math.round(Math.random() * 10) - 5;
    var dy = Math.round(Math.random() * 5) + 5;
➍  toMove.push({
      elm : $(this),
      dx : dx,
      dy : dy,
      x : $(this).position().left,
      y : $(this).position().top,
      config : config
    });
  };</pre><p>This function initiates the animation process and is only called once per object (that is, it doesn’t run as part of an animation loop). The function then sets the config options ➊ for this call to <code class="literal">kaboom</code>. The syntax creates an object with defaults set in the parent definition (the <code class="literal">defaults</code> variable) and overrides these settings with any found in the object that’s been passed. It also adds any new name/value pairs to the object <code class="literal">kaboom</code> will act on.</p><p>We look in the array <code class="literal">toMove</code> and, if the array is empty ➋, set a timeout call that runs the animation. Next, values for the initial <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> velocities are set in <code class="literal">dx</code> and <code class="literal">dy</code> ➌. These values are between –5 and 5 pixels horizontally and between 5 and 10 pixels vertically (upward); both have units of pixels per second. We then add a new object to the <code class="literal">toMove</code> array ➍. The new object contains the jQuery element, its newly created velocity information, the current screen position, and the config options that were specified within this call.</p><p><a id="iddle1191" class="indexterm"/><a id="iddle2156" class="indexterm"/>The <code class="literal">jQuery.fn.kaboom</code> function runs whenever a <code class="literal">$(...).kaboom</code> call is made. If at least one object is exploding, a timeout containing <code class="literal">moveAll</code> will be running. Let’s look at what the <code class="literal">moveAll</code> function does:</p><a id="pro_id00095"/><pre class="programlisting">  var moveAll = function(){
➊  var frameProportion = 1;
➋  var stillToMove = [];
➌  for(var i=0;i&lt;toMove.length;i++){
      var obj = toMove[i];
➍    obj.x += obj.dx * frameProportion;
      obj.y -= obj.dy * frameProportion;
➎    obj.dy -= obj.config.gravity * frameProportion;
➏    if(obj.y &lt; obj.config.maxY){
        obj.elm.css({
          top : Math.round(obj.y),
          left : Math.round(obj.x)
        });
        stillToMove.push(obj);
➐    }else if(obj.config.callback){
        obj.config.callback();
      }
    };
➑  toMove = stillToMove;
    if(toMove.length &gt; 0)
➒    setTimeout(moveAll,40);
  };</pre><p>We assume that <code class="literal">setTimeout</code> is indeed running every 40 milliseconds because it’s the value we specify ➒; therefore, we count the frame rate as 25 per second ➊. If a computer is underpowered (or just busy using CPU cycles on another operation) and the delay between frames is much slower than 40 milliseconds, this assumption may result in a poor animation quality. Later, you’ll learn how to produce an animation at constant speed regardless of processor power, but the current solution provides the best compatibility in legacy browsers.</p><p>After setting the frame rate, <code class="literal">moveAll</code> creates an empty array ➋ to store any objects that don’t move past the maximum value of <span class="emphasis"><em>y</em></span> by the end of the animation frame. The resulting value here will become the new value for <code class="literal">toMove</code> to move again on the next frame.</p><p>With the setup work done, <code class="literal">moveAll</code> loops ➌ over each element in the <code class="literal">toMove</code> array (that is, all the objects currently in the state of exploding; we populated this array in <code class="literal">jQuery.fn.kaboom</code>) and grabs a reference to each one in the <code class="literal">obj</code> variable, which is an object with the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">obj.elm</code> pointing to the jQuery object</p></li><li class="listitem"><p><code class="literal">dx</code> and <code class="literal">dy</code> velocity values</p></li><li class="listitem"><p><span class="emphasis"><em>x</em></span>- and <span class="emphasis"><em>y</em></span>-coordinates storing the current position</p></li></ul></div><p><a id="iddle1074" class="indexterm"/><a id="iddle1768" class="indexterm"/><a id="iddle1998" class="indexterm"/><a id="iddle2134" class="indexterm"/><a id="iddle2468" class="indexterm"/>Inside the loop, we change the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> values ➍ by a proportion of the object’s <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> velocities, respectively. This doesn’t affect the bubble’s screen position yet because we haven’t manipulated the DOM element. The function also adds the configured gravity setting to the object’s vertical velocity ➎. Horizontal velocity should remain constant throughout the explosion effect, but the object will accelerate downward to simulate falling. Next, we check ➏ to see if the object has a value of <span class="emphasis"><em>y</em></span> that exceeds the maximum we either configured in defaults or overrode in the call to <code class="literal">kaboom</code>. If it doesn’t, the position of the screen element is set to the values stored for the current position, and we add the object to the <code class="literal">stillToMove</code> array. On the other hand, if the object <span class="emphasis"><em>has</em></span> passed the maximum <span class="emphasis"><em>y</em></span> and a callback function was passed as part of the original <code class="literal">kaboom</code> call, <code class="literal">moveAll</code> runs ➐ that function. It’s useful to pass a function into an animation and have that function run when the animation is complete.</p><p>Finally, we set the new value of <code class="literal">toMove</code> ➑ to be the contents of <code class="literal">stillToMove</code> (that is, all the objects that are still falling), and if the array contains at least one element, we set a timeout to call the same function again in another 40 milliseconds ➒.</p><p>Now, when you reload the game and create an orphaned group of objects, the kaboom plug-in should make bubbles drop down the screen. Although it works within our game context, you could call it with any valid jQuery selector and produce a similar result. Keep the code handy so you can reuse the effect in future games!</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00007"/>Summary</h1></div></div></div><p>Quite a bit of <span class="emphasis"><em>Bubble Shooter</em></span> is in place now. We can fire bubbles that either settle into the grid or pop groups, and we can detect orphaned groups and drop them off the screen. However, the board can get clogged with unpopped bubbles, and that’s a problem we still need to solve. Currently, there’s also no way to start another level or keep track of your score; both are important elements for this type of game. But before we complete some of the other game functionality, we’ll dive into some HTML5 and CSS implementations of the animations we’ve already written.</p><p>So far, we’ve achieved the features needed with some fairly traditional HTML, CSS, and JavaScript techniques. For the most part, the game should run smoothly on most computers. In the next chapter, we’ll improve performance by offloading some of the animation work from JavaScript to CSS. The shift will let us take advantage of hardware acceleration when possible, and we’ll even use some pure HTML5 features for smoother animation. We’ll also implement the entire game using <code class="literal">canvas</code> rendering rather than DOM and CSS, revealing the advantages and the challenges that result using that approach.</p></div><div class="sect1" title="Further Practice"><div class="titlepage"><div><div><h1 class="title"><a id="further_practice-id00008"/>Further Practice</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>In the exercises in <a class="xref" href="ch03.html" title="Chapter 3. Game Logic">Chapter 3</a>, you changed <code class="literal">createLayout</code> to generate alternative grid patterns. Test your layouts now with the popping and orphan-dropping code. Does the code work? How do your patterns affect the feel of the game?</p></li><li class="listitem"><p>Bubble animations currently consist of four frames. Create your own versions of the images and try adding more frames. Use a <code class="literal">for</code> loop to generate the extra <code class="literal">setTimeout</code> calls rather than copying and pasting new lines. Experiment with the timeout delays to speed up and slow down the animation and see which values produce the best effect.</p></li><li class="listitem"><p>The kaboom jQuery plug-in drops the bubbles off the bottom of the screen, but what would happen if you made the bubbles bounce when they hit the bottom? Amend <span class="emphasis"><em>jquery.kaboom.js</em></span> so the bubbles bounce instead of drop off the screen. You’ll need to reverse their <code class="literal">dy</code> values and scale them down each time they bounce to mimic some of the bounce energy being absorbed; otherwise, they’ll just bounce back to the same height. The bubbles should be removed from the DOM only when they’ve bounced off either the left or the right edge of the screen, so you’ll also need to ensure that the value of <code class="literal">dx</code> isn’t close to zero, or they’ll never disappear.</p></li></ol></div></div></div></body></html>