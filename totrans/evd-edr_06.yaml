- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FILESYSTEM
    MINIFILTER DRIVERS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: 'While the drivers covered in previous chapters can monitor many important events
    on the system, they aren’t able to detect a particularly critical kind of activity:
    filesystem operations. Using filesystem minifilter drivers, or *minifilters* for
    short, endpoint security products can learn about the files being created, modified,
    written to, and deleted.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: These drivers are useful because they can observe an attacker’s interactions
    with the filesystem, such as the dropping of malware to disk. Often, they work
    in conjunction with other components of the system. By integrating with the agent’s
    scanning engine, for example, they can enable the EDR to scan files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Minifilters might, of course, monitor the native Windows filesystem, which is
    called the New Technology File System (NTFS) and is implemented in *ntfs.sys*.
    However, they might also monitor other important filesystems, including named
    pipes, a bidirectional inter-process communication mechanism implemented in *npfs.sys*,
    and mailslots, a unidirectional inter-process communication mechanism implemented
    in *msfs.sys*. Adversary tools, particularly command-and-control agents, tend
    to make heavy use of these mechanisms, so tracking their activities provides crucial
    telemetry. For example, Cobalt Strike’s Beacon uses named pipes for tasking and
    the linking of peer-to-peer agents.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Minifilters are similar in design to the drivers discussed in the previous chapters,
    but this chapter covers some unique details about their implementations, capabilities,
    and operations on Windows. We’ll also discuss evasion techniques that attackers
    can leverage to interfere with them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Legacy Filters and the Filter Manager</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before Microsoft introduced minifilters, EDR developers would write legacy filter
    drivers to monitor filesystem operations. These drivers would sit on the filesystem
    stack, directly inline of user-mode calls destined for the filesystem, as shown
    in [Figure 6-1](#fig6-1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-1.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: The legacy filter
    driver architecture</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'These drivers were notoriously difficult to develop and support in production
    environments. A 2019 article published in *The NT Insider*, titled “Understanding
    Minifilters: Why and How File System Filter Drivers Evolved,” highlights seven
    large problems that developers face when writing legacy filter drivers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Confusing Filter Layering**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In cases when there is more than one legacy filter installed on the system,
    the architecture defines no order for how these drivers should be placed on the
    filesystem stack. This prevents the driver developer from knowing when the system
    will load their driver in relation to the others.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**A Lack of Dynamic Loading and Unloading**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Legacy filter drivers can’t be inserted into a specific location on the device
    stack and can only be loaded at the top of the stack. Additionally, legacy filters
    can’t be unloaded easily and typically require a full system reboot to unload.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Tricky Filesystem-Stack Attachment and Detachment**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics of how the filesystem stack attaches and detaches devices are
    extremely complicated, and developers must have a substantial amount of arcane
    knowledge to ensure that their driver can appropriately handle odd edge cases.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Indiscriminate IRP Processing**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Legacy filter drivers are responsible for processing *all* Interrupt Request
    Packets (IRPs) sent to the device stack, regardless of whether they are interested
    in the IRPs or not.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenges with Fast I/O Data Operations**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Windows supports a mechanism for working with cached files, called *Fast I/O*,
    that provides an alternative to its standard packet-based I/O model. It relies
    on a dispatch table implemented in the legacy drivers. Each driver processes Fast
    I/O requests and passes them down the stack to the next driver. If a single driver
    in the stack lacks a dispatch table, it disables Fast I/O processing for the entire
    device stack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**An Inability to Monitor Non-data Fast I/O Operations**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, filesystems are deeply integrated into other system components,
    such as the memory manager. For instance, when a user requests that a file be
    mapped into memory, the memory manager calls the Fast I/O callback <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireFileForNtCreateSection</samp>.
    These non-data requests always bypass the device stack, making it hard for a legacy
    filter driver to collect information about them. It wasn’t until Windows XP, which
    introduced <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!FsRtlRegisterFileSystemFilterCallbacks()</samp>,
    that developers could request this information.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**Issues with Handling Recursion**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems make heavy use of recursion, so filters in the filesystem stack
    must support it as well. However, due to the way that Windows manages I/O operations,
    this is easier said than done. Because each request passes through the entire
    device stack, a driver could easily deadlock or exhaust its resources if it handles
    recursion poorly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: To address some of these limitations, Microsoft introduced the filter manager
    model. The filter manager (*fltmgr.sys*) is a driver that ships with Windows and
    exposes functionality commonly used by filter drivers when intercepting filesystem
    operations. To leverage this functionality, developers can write minifilters.
    The filter manager then intercepts requests destined for the filesystem and passes
    them to the minifilters loaded on the system, which exist in their own sorted
    stack, as shown in [Figure 6-2](#fig6-2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Minifilters are substantially easier to develop than their legacy counterparts,
    and EDRs can manage them more easily by dynamically loading and unloading them
    on a running system. The ability to access functionality exposed by the filter
    manager makes for less complex drivers, allowing for easier maintenance. Microsoft
    has made tremendous efforts to move developers away from the legacy filter model
    and over to the minifilter model. It has even included an optional registry value
    that allows administrators to block legacy filter drivers from being loaded on
    the system altogether.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure6-2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: The filter manager
    and minifilter architecture</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Minifilter Architecture</samp>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minifilters have a unique architecture in several respects. First is the role
    of the filter manager itself. In a legacy architecture, filesystem drivers would
    filter I/O requests directly, while in a minifilter architecture, the filter manager
    handles this task before passing information about the requests to the minifilters
    loaded on the system. This means that minifilters are only indirectly attached
    to the filesystem stack. Also, they register with the filter manager for the specific
    operations they’re interested in, removing the need for them to handle all I/O
    requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Next is how they interact with registered callback routines. As with the drivers
    discussed in the previous chapters, minifilters may register both pre- and post-operation
    callbacks. When a supported operation occurs, the filter manager first calls the
    correlated pre-operation callback function in each of the loaded minifilters.
    Once a minifilter completes its pre-operation routine, it passes control back
    to the filter manager, which calls the next callback function in the subsequent
    driver. When all drivers have completed their pre-operation callbacks, the request
    travels to the filesystem driver, which processes the operation. After receiving
    the I/O request for completion, the filter manager invokes the post-operation
    callback functions in the minifilters in reverse order. Once the post-operation
    callbacks complete, control is transferred back to the I/O manager, which eventually
    passes control back to the caller application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Each minifilter has an *altitude*, which is a number that identifies its location
    in the minifilter stack and determines when the system will load that minifilter.
    Altitudes address the issue of ordering that plagued legacy filter drivers. Ideally,
    Microsoft assigns altitudes to the minifilters of production applications, and
    these values are specified in the drivers’ registry keys, under <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp>.
    Microsoft sorts altitudes into load-order groups, which are shown in [Table 6-1](#tab6-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</samp> <samp class="SANS_Futura_Std_Book_11">Microsoft’s
    Minifilter Load-Order Groups</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Altitude range</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Load-order
    group name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Minifilter role</samp>
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">420000–429999</samp> | <samp class="SANS_Futura_Std_Book_11">Filter</samp>
    | <samp class="SANS_Futura_Std_Book_11">Legacy filter drivers</samp> |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">400000–409999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Top</samp> | <samp class="SANS_Futura_Std_Book_11">Filters that must attach above
    all others</samp> |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">360000–389999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Activity Monitor</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that observe
    and report on file I/O</samp> |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">340000–349999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Undelete</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that recover deleted
    files</samp> |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">320000–329998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Anti-Virus</samp> | <samp class="SANS_Futura_Std_Book_11">Antimalware drivers</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">300000–309998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Replication</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that copy data
    to a remote system</samp> |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">280000–289998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Continuous Backup</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that
    copy data to backup media</samp> |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">260000–269998</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Content Screener</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that prevent
    the creation of specific files or content</samp> |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">240000–249999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Quota Management</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that provide
    enhanced filesystem quotas that limit the space allowed for a volume or folder</samp>
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">220000–229999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    System Recovery</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that maintain
    operating system integrity</samp> |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">200000–209999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Cluster File System</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers used
    by applications that provide file server metadata across a network</samp> |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">180000–189999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    HSM</samp> | <samp class="SANS_Futura_Std_Book_11">Hierarchical storage management
    drivers</samp> |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">180000–189999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    HSM</samp> | <samp class="SANS_Futura_Std_Book_11">层级存储管理驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">170000–174999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Imaging</samp> | <samp class="SANS_Futura_Std_Book_11">ZIP-like drivers that provide
    a virtual namespace</samp> |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">170000–174999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    图像处理</samp> | <samp class="SANS_Futura_Std_Book_11">类似ZIP的驱动程序，提供虚拟命名空间</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">160000–169999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Compression</samp> | <samp class="SANS_Futura_Std_Book_11">File-data compression
    drivers</samp> |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">160000–169999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    压缩</samp> | <samp class="SANS_Futura_Std_Book_11">文件数据压缩驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">140000–149999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Encryption</samp> | <samp class="SANS_Futura_Std_Book_11">File-data encryption
    and decryption drivers</samp> |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">140000–149999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    加密</samp> | <samp class="SANS_Futura_Std_Book_11">文件数据加密和解密驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">130000–139999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Virtualization</samp> | <samp class="SANS_Futura_Std_Book_11">Filepath virtualization
    drivers</samp> |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">130000–139999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    虚拟化</samp> | <samp class="SANS_Futura_Std_Book_11">文件路径虚拟化驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">120000–129999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Physical Quota Management</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers
    that manage quotes by using physical block counts</samp> |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">120000–129999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    物理配额管理</samp> | <samp class="SANS_Futura_Std_Book_11">通过使用物理块计数来管理配额的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">100000–109999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Open File</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that provide
    snapshots of already-opened files</samp> |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">100000–109999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    打开文件</samp> | <samp class="SANS_Futura_Std_Book_11">提供已打开文件快照的驱动程序</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">80000–89999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Security Enhancer</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that
    apply file-based lockdowns and enhanced access control</samp> |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">80000–89999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    安全增强</samp> | <samp class="SANS_Futura_Std_Book_11">应用基于文件的锁定和增强访问控制的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">60000–69999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Copy Protection</samp> | <samp class="SANS_Futura_Std_Book_11">Drivers that check
    for out-of-band data on storage media</samp> |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">60000–69999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    复制保护</samp> | <samp class="SANS_Futura_Std_Book_11">检查存储介质上是否存在带外数据的驱动程序</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">40000–49999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Bottom</samp> | <samp class="SANS_Futura_Std_Book_11">Filters that must attach
    below all others</samp> |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">40000–49999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    底部</samp> | <samp class="SANS_Futura_Std_Book_11">必须附加在所有其他过滤器下面的过滤器</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11">20000–29999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    System</samp> | <samp class="SANS_Futura_Std_Book_11">Reserved</samp> |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">20000–29999</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    系统</samp> | <samp class="SANS_Futura_Std_Book_11">保留</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_11"><20000</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    Infrastructure</samp> | <samp class="SANS_Futura_Std_Book_11">Reserved for system
    use but attaches closest to the filesystem</samp> |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11"><20000</samp> | <samp class="SANS_Futura_Std_Book_11">FSFilter
    基础设施</samp> | <samp class="SANS_Futura_Std_Book_11">为系统使用保留，但最接近文件系统附加</samp>
    |'
- en: Most EDR vendors register their minifilters in the FSFilter Anti-Virus or FSFilter
    Activity Monitor group. Microsoft publishes a list of registered altitudes, as
    well as their associated filenames and publishers. [Table 6-2](#tab6-2) lists
    altitudes assigned to minifilters belonging to popular commercial EDR solutions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数EDR供应商将其minifilter注册到FSFilter 防病毒或FSFilter 活动监控器组中。微软发布了注册的高度列表，以及它们关联的文件名和发布者。[表6-2](#tab6-2)列出了分配给流行商业EDR解决方案的minifilter的高度。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-2:</samp> <samp class="SANS_Futura_Std_Book_11">Altitudes
    of Popular EDRs</samp>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Altitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Vendor</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">EDR</samp> |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">389220</samp> | <samp class="SANS_Futura_Std_Book_11">Sophos</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">sophosed.sys</samp> |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">389040</samp> | <samp class="SANS_Futura_Std_Book_11">SentinelOne</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">sentinelmonitor.sys</samp> |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">328010</samp> | <samp class="SANS_Futura_Std_Book_11">Microsoft</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">wdfilter.sys</samp> |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">321410</samp> | <samp class="SANS_Futura_Std_Book_11">CrowdStrike</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">csagent.sys</samp> |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">388360</samp> | <samp class="SANS_Futura_Std_Book_11">FireEye/Trellix</samp>
    | <samp class="SANS_Futura_Std_Book_Oblique_I_11">fekern.sys</samp> |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">386720</samp> | <samp class="SANS_Futura_Std_Book_11">Bit9/Carbon
    Black/VMWare</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">carbonblackk.sys</samp>
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: While an administrator can change a minifilter’s altitude, the system can load
    only one minifilter at a single altitude at one time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Writing a Minifilter</samp>
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s walk through the process of writing a minifilter. Each minifilter begins
    with a <samp class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function,
    defined in the same way as other drivers. This function performs any required
    global initializations and then registers the minifilter. Finally, it starts filtering
    I/O operations and returns an appropriate value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Beginning the Registration</samp>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first, and most important, of these actions is registration, which the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DriverEntry()</samp> function performs
    by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>.
    This function adds the minifilter to the list of registered minifilter drivers
    on the host and provides the filter manager with information about the minifilter,
    including a list of callback routines. This function is defined in [Listing 6-1](#list6-1).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fltmgr!FltRegisterFilter()</samp>
    function definition'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Of the three parameters passed to it, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Registration</samp>
    parameter is the most interesting. This is a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure, defined in [Listing 6-2](#list6-2), which houses all the relevant information
    about the minifilter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给它的三个参数中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Registration</samp>
    参数是最有趣的。它是一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    结构的指针，该结构在 [清单 6-2](#list6-2) 中定义，包含关于微过滤器的所有相关信息。
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_REGISTRATION</samp>
    structure definition'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_REGISTRATION</samp>
    结构定义
- en: 'The first two members of this structure set the structure size, which is always
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(FLT_REGISTRATION)</samp>,
    and the structure revision level, which is always <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION_VERSION</samp>.
    The next member is *flags*, which is a bitmask that may be zero or a combination
    of any of the following three values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的前两个成员设置了结构的大小，大小始终为 <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(FLT_REGISTRATION)</samp>，并设置结构修订级别，始终为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION_VERSION</samp>。下一个成员是
    *flags*，它是一个位掩码，可能为零或以下三个值的任意组合：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP
    (1)</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_DO_NOT_SUPPORT_SERVICE_STOP
    (1)</samp>
- en: The minifilter won’t be unloaded in the event of a service stop request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 微过滤器在请求停止服务时不会被卸载。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(2)</samp>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_NPFS_MSFS</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(2)</samp>
- en: The minifilter supports named pipe and mailslot requests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微过滤器支持命名管道和邮件插槽请求。
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME
    (4)</samp>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLTFL_REGISTRATION_SUPPORT_DAX_VOLUME
    (4)</samp>
- en: The minifilter supports attaching to a Direct Access (DAX) volume.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该微过滤器支持附加到直接访问（DAX）卷。
- en: Following this member is the context registration. This will be either an array
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CONTEXT_REGISTRATION</samp>
    structures or null. These contexts allow a minifilter to associate related objects
    and preserve state across I/O operations. After this array of context comes the
    critically important operation registration array. This is a variable length array
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    structures, which are defined in [Listing 6-3](#list6-3). While this array can
    technically be null, it’s rare to see that configuration in an EDR sensor. The
    minifilter must provide a structure for each type of I/O for which it registers
    a pre-operation or post-operation callback routine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的是上下文注册。这将是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CONTEXT_REGISTRATION</samp>
    结构的数组或 null。这些上下文允许微过滤器将相关对象关联起来，并在 I/O 操作之间保持状态。在此上下文数组之后是至关重要的操作注册数组。这是一个可变长度的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    结构的数组，这些结构在 [清单 6-3](#list6-3) 中定义。虽然这个数组在技术上可以为 null，但在 EDR 传感器中很少见到这种配置。微过滤器必须为每种类型的
    I/O 提供一个结构，以便它注册预操作或后操作回调例程。
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_OPERATION_REGISTRATION</samp>
    structure definition'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FLT_OPERATION_REGISTRATION</samp>
    结构定义
- en: The first parameter indicates which major function the minifilter is interested
    in processing. These are constants defined in *wdm.h*, and [Table 6-3](#tab6-3)
    lists some of those most relevant to security monitoring.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数表示微过滤器感兴趣处理的主要功能。这些是 *wdm.h* 中定义的常量，[表 6-3](#tab6-3) 列出了与安全监控最相关的一些常量。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 6-3:</samp> <samp class="SANS_Futura_Std_Book_11">Major
    Functions and Their Purposes</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 6-3：</samp> <samp class="SANS_Futura_Std_Book_11">主要功能及其目的</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Major function</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">主要功能</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">目的</samp>
    |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x00)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new file is being created or a handle to an existing one is being opened.</samp>
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x00)</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建新文件或打开现有文件的句柄。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x01)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    named pipe is being created or opened.</samp> |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x01)</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建或打开一个命名管道。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLOSE (0x02)</samp>
    | <samp class="SANS_Futura_Std_Book_11">A handle to a file object is being closed.</samp>
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLOSE (0x02)</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在关闭文件对象的句柄。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x03)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Data is being read from a file.</samp>
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x03)</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在从文件中读取数据。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x04)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Data is being written to a file.</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x04)</samp>
    | <samp class="SANS_Futura_Std_Book_11">正在向文件写入数据。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x05)</samp> | <samp class="SANS_Futura_Std_Book_11">Information
    about a file, such as its creation time, has been requested.</samp> |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x05)</samp> | <samp class="SANS_Futura_Std_Book_11">已请求有关文件的信息，如其创建时间。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x06)</samp> | <samp class="SANS_Futura_Std_Book_11">Information
    about a file, such as its name, is being set or updated.</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_INFORMATION</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x06)</samp> | <samp class="SANS_Futura_Std_Book_11">正在设置或更新文件的信息，如其名称。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x07)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    file’s extended information has been requested.</samp> |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x07)</samp> | <samp class="SANS_Futura_Std_Book_11">已请求文件的扩展信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x08)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    file’s extended information is being set or updated.</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_EA</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(0x08)</samp> | <samp class="SANS_Futura_Std_Book_11">正在设置或更新文件的扩展信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_LOCK_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x11)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    lock is being placed on a file, such as via a call to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LockFileEx()</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_LOCK_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x11)</samp> | <samp class="SANS_Futura_Std_Book_11">正在对文件加锁，例如通过调用</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!LockFileEx()</samp><samp
    class="SANS_Futura_Std_Book_11">。</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_MAILSLOT</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x13)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new mailslot is being created or opened.</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_MAILSLOT</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x13)</samp> | <samp class="SANS_Futura_Std_Book_11">正在创建或打开一个新的邮件插槽。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x14)</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    information about a file is being requested.</samp> |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_QUERY_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x14)</samp> | <samp class="SANS_Futura_Std_Book_11">正在请求有关文件的安全信息。</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SET_SECURITY</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x15)</samp> | <samp class="SANS_Futura_Std_Book_11">Security
    information related to a file is being set or updated.</samp> |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_SYSTEM_CONTROL</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(0x17)</samp> | <samp class="SANS_Futura_Std_Book_11">A
    new driver has been registered as a supplier of Windows Management Instrumentation.</samp>
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: The next member of the structure specifies the flags. This bitmask describes
    when the callback functions should be invoked for cached I/O or paging I/O operations.
    At the time of this writing, there are four supported flags, all of which are
    prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_OPERATION_REGISTRATION_</samp>.
    First, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_PAGING_IO</samp> indicates
    whether a callback should be invoked for IRP-based read or write paging I/O operations.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_CACHED_IO</samp> flag is
    used to prevent the invocation of callbacks on fast I/O-based read or write cached
    I/O operations. Next, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_DASD_IO</samp>
    is used for requests issued on a Direct Access Storage Device (DASD) volume handle.
    Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">SKIP_NON_CACHED_NON_PAGING_IO</samp>
    prevents callback invocation on read or write I/O operations that are not cached
    or paging operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Pre-operation
    Callbacks</samp>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next two members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    structure define the pre-operation or post-operation callbacks to be invoked when
    each of the target major functions occurs on the system. Pre-operation callbacks
    are passed via a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PRE_OPERATION_CALLBACK</samp>
    structure, and post-operation routines are specified as a pointer to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_POST_OPERATION_CALLBACK</samp> structure.
    While these functions’ definitions aren’t too dissimilar, their capabilities and
    limitations vary substantially.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: As with callbacks in other types of drivers, pre-operation callback functions
    allow the developer to inspect an operation on its way to its destination (the
    target filesystem, in the case of a minifilter). These callback functions receive
    a pointer to the callback data for the operation and some opaque pointers for
    the objects related to the current I/O request, and they return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    return code. In code, this would look like what is shown in [Listing 6-4](#list6-4).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Registering a pre-operation callback'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>,
    is the most complex of the three and contains all the major information related
    to the request that the minifilter is processing. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp>
    structure is used by both the filter manager and the minifilter to process I/O
    operations and contains a ton of useful data for any EDR agent monitoring filesystem
    operations. Some of the important members of this structure include:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Flags</samp>   A bitmask that
    describes the I/O operation. These flags may come preset from the filter manager,
    though the minifilter may set additional flags in some circumstances. When the
    filter manager initializes the data structure, it sets a flag to indicate what
    type of I/O operation it represents: either fast I/O, filter, or IRP operations.
    The filter manager may also set flags indicating whether a minifilter generated
    or reissued the operation, whether it came from the non-paged pool, and whether
    the operation completed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Thread</samp>   A pointer to the
    thread that initiated the I/O request. This is useful for identifying the application
    performing the operation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Iopb</samp>   The I/O parameter
    block that contains information about IRP-based operations (for example, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_BUFFERED_IO</samp>, which indicates
    that it is a buffered I/O operation); the major function code; special flags related
    to the operation (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">SL_CASE_SENSITIVE</samp>,
    which informs drivers in the stack that filename comparisons should be case sensitive);
    a pointer to the file object that is the target of the operation; and an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_PARAMETERS</samp> structure containing
    the parameters unique to the specific I/O operation specified by the major or
    minor function code member of the structure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IoStatus</samp>   A structure that
    contains the completion status of the I/O operation set by the filter manager.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">TagData</samp>   A pointer to an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_TAG_DATA_BUFFER</samp> structure
    containing information about reparse points, such as in the case of NTFS hard
    links or junctions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">RequestorMode</samp>   A value
    indicating whether the request came from user mode or kernel mode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This structure contains much of the information that an EDR agent needs to track
    file operations on the system. The second parameter passed to the pre-operation
    callback, a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RELATED_OBJECTS</samp>
    structure, provides supplemental information. This structure contains opaque pointers
    to the object associated with the operation, including the volume, minifilter
    instance, and file object (if present). The last parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">CompletionContext</samp>,
    contains an optional context pointer that will be passed to the correlated post-operation
    callback if the minifilter returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SUCCESS_WITH_CALLBACK</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'On completion of the routine, the minifilter must return an <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp>
    value. Pre-operation callbacks may return one of seven supported values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_WITH_CALLBACK
    (0)</samp>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Return the I/O operation to the filter manager for processing and instruct it
    to call the minifilter’s post-operation callback during completion.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SUCCESS_NO_CALLBACK (1)</samp>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Return the I/O operation to the filter manager for processing and instruct it
    *not* to call the minifilter’s post-operation callback during completion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_PENDING (2)</samp>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Pend the I/O operation and do not process it further until the minifilter calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPreOperation()</samp>.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FASTIO (3)</samp>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Block the fast I/O path in the operation. This code instructs the filter manager
    not to pass the operation to any other minifilters below the current one in the
    stack and to only call the post-operation callbacks of those drivers at higher
    altitudes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_COMPLETE (4)</samp>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Instruct the filter manager not to send the request to minifilters below the
    current driver in the stack and to only call the post-operation callbacks of those
    minifilters above it in the driver stack.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_SYNCHRONIZE (5)</samp>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Pass the request back to the filter manager but don’t complete it. This code
    ensures that the minifilter’s post-operation callback is called at IRQL ≤ *APC_LEVEL*
    in the context of the original thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FLT_PREOP_DISALLOW_FSFILTER_IO
    (6)</samp>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Disallow a fast <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp>
    operation and force the operation down the slower path, causing the I/O manager
    to process the request using an open, query, or close operation on the file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The filter manager invokes the pre-operation callbacks for all minifilters that
    have registered functions for the I/O operation being processed before passing
    their requests to the filesystem, beginning with the highest altitude.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Post-operation
    Callbacks</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the filesystem performs the operations defined in every minifilter’s pre-operation
    callbacks, control is passed up the filter stack to the filter manager. The filter
    manager then invokes the post-operation callbacks of all minifilters for the request
    type, beginning with the lowest altitude. These post-operation callbacks have
    a similar definition to the pre-operation routines, as shown in [Listing 6-5](#list6-5).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Post-operation callback routine definitions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Two notable differences here are the addition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Flags</samp>
    parameter and the different return type. The only documented flag that a minifilter
    can pass is <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_POST_OPERATION_DRAINING</samp>,
    which indicates that the minifilter is in the process of unloading. Additionally,
    post-operation callbacks can return different statuses. If the callback returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_FINISHED_PROCESSING</samp>
    (*0*), the minifilter has completed its post-operation callback routine and is
    passing control back to the filter manager to continue processing the I/O request.
    If it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_MORE_PROCESSING_REQUIRED</samp>
    (*1*), the minifilter has posted the IRP-based I/O operation to a work queue and
    halted completion of the request until the work item completes, and it calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltCompletePendedPostOperation()</samp>.
    Lastly, if it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_POSTOP_DISALLOW_FSFILTER_IO</samp>
    (*2*), the minifilter is disallowing a fast <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryOpen</samp>
    operation and forcing the operation down the slower path. This is the same as
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_DISALLOW_FSFILTER_IO</samp>.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Post-operation callbacks have some notable limitations that reduce their viability
    for security monitoring. The first is that they’re invoked in an arbitrary thread
    unless the pre-operation callback passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_SYNCHRONIZE</samp>
    flag, preventing the system from attributing the operation to the requesting application.
    Next is that post-operation callbacks are invoked at IRQL ≤ *DISPATCH_LEVEL*.
    This means that certain operations are restricted, including accessing most synchronization
    primitives (for example, mutexes), calling kernel APIs that require an IRQL ≤
    *DISPATCH_LEVEL*, and accessing paged memory. One workaround to these limitations
    involves delaying the execution of the post-operation callback via the use of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltDoCompletionProcessingWhenSafe()</samp>,
    but this solution has its own challenges.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The array of these <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_OPERATION_REGISTRATION</samp>
    structures passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp>
    member of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    may look like [Listing 6-6](#list6-6).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: An array of operation registration callback structures'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: This array registers pre- and post-operation callbacks for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>
    and only pre-operation callbacks for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_READ</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp>. No flags
    are passed in for any of the target operations. Also note that the final element
    in the array is <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_OPERATION_END</samp>.
    Microsoft requires this value to be present at the end of the array, and it serves
    no functional purpose in the context of monitoring.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Optional
    Callbacks</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last section in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure contains the optional callbacks. The first three callbacks, <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterUnloadCallback</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceSetupCallback</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceQueryTeardownCallback</samp>,
    may all technically be null, but this will impose some restrictions on the minifilter
    and system behavior. For example, the system won’t be able to unload the minifilter
    or attach to new filesystem volumes. The rest of the callbacks in this section
    of the structure relate to various functionality provided by the minifilter. These
    include things such as the interception of filename requests (<samp class="SANS_TheSansMonoCd_W5Regular_11">GenerateFileNameCallback</samp>)
    and filename normalization (<samp class="SANS_TheSansMonoCd_W5Regular_11">NormalizeNameComponentCallback</samp>).
    In general, only the first three semi-optional callbacks are registered, and the
    rest are rarely used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Activating the Minifilter</samp>
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After all callback routines have been set, a pointer to the created <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure is passed as the second parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltRegisterFilter()</samp>.
    Upon completion of this function, an opaque filter pointer (<samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp>)
    is returned to the caller in the <samp class="SANS_TheSansMonoCd_W5Regular_11">RetFilter</samp>
    parameter. This pointer uniquely identifies the minifilter and remains static
    as long as the driver is loaded on the system. This pointer is typically preserved
    as a global variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When the minifilter is ready to start processing events, it passes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp> pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltStartFilter()</samp>.
    This notifies the filter manager that the driver is ready to attach to filesystem
    volumes and start filtering I/O requests. After this function returns, the minifilter
    will be considered active and sit inline of all relevant filesystem operations.
    The callbacks registered in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_REGISTRATION</samp>
    structure will be invoked for their associated major functions. Whenever the minifilter
    is ready to unload itself, it passes the <samp class="SANS_TheSansMonoCd_W5Regular_11">PFLT_FILTER</samp>
    pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltUnregisterFilter()</samp>
    to remove any contexts that the minifilter has set on files, volumes, and other
    components and calls the registered <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownStartCallback</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InstanceTeardownCompleteCallback</samp>
    functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Managing a Minifilter</samp>
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to working with other drivers, the process of installing, loading,
    and unloading a minifilter requires special consideration. This is because minifilters
    have specific requirements related to the setting of registry values. To make
    the installation process easier, Microsoft recommends installing minifilters through
    a *setup information (INF)* file. The format of these INF files is beyond the
    scope of this book, but there are some interesting details relevant to how minifilters
    work that are worth mentioning.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ClassGuid</samp> entry in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> section of the
    INF file is a GUID that corresponds to the desired load-order group (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FSFilter Activity Monitor</samp>).
    In the <samp class="SANS_TheSansMonoCd_W5Regular_11">AddRegistry</samp> section
    of the file, which specifies the registry keys to be created, you’ll find information
    about the minifilter’s altitude. This section may include multiple similar entries
    to describe where the system should load various instances of the minifilter.
    The altitude can be set to the name of a variable (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">%MyAltitude%</samp>)
    defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Strings</samp> section
    of the INF file. Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceType</samp>
    entry under the <samp class="SANS_TheSansMonoCd_W5Regular_11">ServiceInstall</samp>
    section is always set to <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_FILE_SYSTEM_DRIVER</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(2)</samp>.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Executing the INF installs the driver, copying files to their specified locations
    and setting up the required registry keys. [Listing 6-7](#list6-7) shows an example
    of what this looks like in the registry keys for *WdFilter*, Microsoft Defender’s
    minifilter driver.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Viewing WdFilter’s altitude with PowerShell'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp> key dictates
    when the minifilter will be loaded. The service can be started and stopped using
    the Service Control Manager APIs, as well as through a client such as *sc.exe*
    or the Services snap-in. In addition, we can manage minifilters with the filter
    manager library, *FltLib*, which is leveraged by the *fltmc.exe* utility included
    by default on Windows. This setup also includes setting the altitude of the minifilter,
    which for *WdFilter* is 328010.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Adversary Tradecraft with
    Minifilters</samp>
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand the inner workings of minifilters, let’s explore how
    they contribute to the detection of attacks on a system. As discussed in “Writing
    a Minifilter” on [page 108](#sec3), a minifilter can register pre- or post-operation
    callbacks for activities that target any filesystem, including NTFS, named pipes,
    and mailslots. This provides an EDR with an extremely powerful sensor for detecting
    adversary activity on the host.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">File Detections</samp>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an adversary interacts with the filesystem, such as by creating new files
    or modifying the contents of existing files, the minifilter has an opportunity
    to detect the behavior. Modern attacks have tended to avoid dropping artifacts
    directly onto the host filesystem in this way, embracing the “disk is lava” mentality,
    but many hacking tools continue to interact with files due to limitations of the
    APIs being leveraged. For example, consider <samp class="SANS_TheSansMonoCd_W5Regular_11">dbghelp!MiniDumpWriteDump()</samp>,
    a function used to create process memory dumps. This API requires that the caller
    pass in a handle to a file for the dump to be written to. The attacker must work
    with files if they want to use this API, so any minifilter that processes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp>
    I/O operations can indirectly detect those memory-dumping operations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the attacker has no control over the format of the data being
    written to the file, allowing a minifilter to coordinate with a scanner to detect
    a memory-dump file without using function hooking. An attacker might try to work
    around this by opening a handle to an existing file and overwriting its content
    with the dump of the target process’s memory, but a minifilter monitoring <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp> could still detect
    this activity, as both the creation of a new file and the opening of a handle
    to an existing file would trigger it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Some defenders use these concepts to implement *filesystem canaries*. These
    are files created in key locations that users should seldom, if ever, interact
    with. If an application other than a backup agent or the EDR requests a handle
    to a canary file, the minifilter can take immediate action, including crashing
    the system. Filesystem canaries provide strong (though at times brutal) anti-ransomware
    control, as ransomware tends to indiscriminately encrypt files on the host. By
    placing a canary file in a directory nested deep in the filesystem, hidden from
    the user but still in one of the paths typically targeted by ransomware, an EDR
    can limit the damage to the files that the ransomware encountered before reaching
    the canary.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Named Pipe Detections</samp>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another key piece of adversary tradecraft that minifilters can detect highly
    effectively is the use of named pipes. Many command-and-control agents, like Cobalt
    Strike’s Beacon, make use of named pipes for tasking, I/O, and linking. Other
    offensive techniques, such as those that use token impersonation for privilege
    escalation, revolve around the creation of a named pipe. In both cases, a minifilter
    monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    requests would be able to detect the attacker’s behavior, in much the same way
    as those that detect file creation via <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE</samp>.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Minifilters commonly look for the creation of anomalously named pipes, or those
    originating from atypical processes. This is useful because many tools used by
    adversaries rely on the use of named pipes, so an attacker who wants to blend
    in should pick pipe and host process names that are typical in the environment.
    Thankfully for attackers and defenders alike, Windows makes enumerating existing
    named pipes easy, and we can straightforwardly identify many of the common process-to-pipe
    relationships. One of the most well-known named pipes in the realm of security
    is *mojo*. When a Chromium process spawns, it creates several named pipes with
    the format *mojo.PID.TID.VALUE* for use by an IPC abstraction library called Mojo.
    This named pipe became popular after its inclusion in a well-known repository
    for documenting Cobalt Strike’s Malleable profile options.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: There are a few problems with using this specific named pipe that a minifilter
    can detect. The main one is related to the structured formatting used for the
    name of the pipe. Because Cobalt Strike’s pipe name is a static attribute tied
    to the instance of the Malleable profile, it is immutable at runtime. This means
    that an adversary would need to accurately predict the process and thread IDs
    of their Beacon to ensure the attributes of their process match those of the pipe
    name format used by Mojo. Remember that minifilters with pre-operation callbacks
    for monitoring <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CREATE_NAMED_PIPE</samp>
    requests are guaranteed to be invoked in the context of the calling thread. This
    means that when a Beacon process creates the “mojo” named pipe, the minifilter
    can check that its current context matches the information in the pipe name. Pseudocode
    to demonstrate this would look like that shown in [Listing 6-8](#list6-8).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-8: Detecting anomalous Mojo named pipes'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Since the format used in Mojo named pipes is known, we can simply concatenate
    the PID and TID ❶ of the thread creating the named pipe and ensure that it matches
    what is expected. If not, we can take some defensive action.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Not every command inside Beacon will create a named pipe. There are certain
    functions that will create an anonymous pipe (as in, a pipe without a name), such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">execute-assembly</samp>. These
    types of pipes have limited operational viability, as their name can’t be referenced
    and code can interact with them through an open handle only. What they lose in
    functionality, however, they gain in evasiveness.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Riccardo Ancarani’s blog post “Detecting Cobalt Strike Default Modules via Named
    Pipe Analysis” details the OPSEC considerations related to Beacon’s usage of anonymous
    pipes. In his research, he found that while Windows components rarely used anonymous
    pipes, their creation could be profiled, and their creators could be used as viable
    *spawnto* binaries. These included *ngen.exe*, *wsmprovhost.exe*, and *firefox.exe*,
    among others. By setting their sacrificial processes to one of these executables,
    attackers could ensure that any actions resulting in the creation of anonymous
    pipes would likely remain undetected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind, however, that activities making use of named pipes would still
    be vulnerable to detection, so operators would need to restrict their tradecraft
    to activities that create anonymous pipes only.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Minifilters</samp>
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most strategies for evading an EDR’s minifilters rely on one of three techniques:
    unloading, prevention, or interference. Let’s walk through examples of each to
    demonstrate how we can use them to our advantage.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unloading</samp>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first technique is to completely unload the minifilter. While you’ll need
    administrator access to do this (specifically, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
    token privilege), it’s the most surefire way to evade the minifilter. After all,
    if the driver is no longer on the stack, it can’t capture events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Unloading the minifilter can be as simple as calling <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unload</samp>, but if the vendor
    has put a lot of effort into hiding the presence of their minifilter, it might
    require complex custom tooling. To explore this idea further, let’s target Sysmon,
    whose minifilter, *SysmonDrv*, is configured in the registry, as shown in [Listing
    6-9](#list6-9).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-9: Using PowerShell to view SysmonDrv’s configuration'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: By default, *SysmonDrv* has the altitude 385201, and we can easily unload it
    via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmc.exe unload SysmonDrv</samp>,
    assuming the caller has the required privilege. Doing so would create a *FilterManager*
    event ID of 1, which indicates that a filesystem filter was unloaded, and a Sysmon
    event ID of 255, which indicates a driver communication failure. However, Sysmon
    will no longer receive events.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To complicate this process for attackers, the minifilter sometimes uses a random
    service name to conceal its presence on the system. In the case of Sysmon, an
    administrator can implement this approach during installation by passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag to the installer and specifying
    a new name. This prevents an attacker from using the built-in *fltmc.exe* utility
    unless they can also identify the service name.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'However, an attacker can abuse another feature of production minifilters to
    locate the driver and unload it: their altitudes. Because Microsoft reserves specific
    altitudes for certain vendors, an attacker can learn these values and then simply
    walk the registry or use <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>
    to locate any driver with the altitude in question. We can’t use *fltmc.exe* to
    unload minifilters based on an altitude, but we can either resolve the driver’s
    name in the registry or pass the minifilter’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterUnload()</samp>
    for tooling that makes use of <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>.
    This is how the Shhmon tool, which hunts and unloads *SysmonDrv*, works under
    the hood.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Defenders could further thwart attackers by modifying the minifilter’s altitude.
    This isn’t recommended in production applications, however, because another application
    might already be using the chosen value. EDR agents sometimes operate across millions
    of devices, raising the odds of an altitude collision. To mitigate this risk,
    a vendor might compile a list of active minifilter allocations from Microsoft
    and choose one not already in use, although this strategy isn’t bulletproof.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Sysmon, defenders could either patch the installer to set the
    altitude value in the registry to a different value upon installation or manually
    change the altitude after installation by directly modifying the registry value.
    Since Windows doesn’t place any technical controls on altitudes, the engineer
    could move *SysmonDrv* to any altitude they wish. Bear in mind, however, that
    the altitude affects the minifilter’s position in the stack, so choosing too low
    a value could have unintended implications for the efficacy of the tool.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Even with all these obfuscation methods applied, an attacker could still unload
    a minifilter. Starting in Windows 10, both the vendor and Microsoft must sign
    a production driver before it can be loaded onto the system, and because these
    signatures are meant to identify the drivers, they include information about the
    vendor that signed them. This information is often enough to tip an adversary
    off to the presence of the target minifilter. In practice, the attacker could
    walk the registry or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fltlib!FilterFindNext()</samp>
    approach to enumerate minifilters, extract the path to the driver on disk, and
    parse the digital signatures of all enumerated files until they’ve identified
    a file signed by an EDR. At that point, they can unload the minifilter using one
    of the previously covered methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve just learned, there are no particularly great ways to hide a minifilter
    on the system. This doesn’t mean, however, that these obfuscations aren’t worthwhile.
    An attacker might lack the tooling or knowledge to counter the obfuscations, providing
    time for the EDR’s sensors to detect their activity without interference.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Prevention</samp>
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prevent filesystem operations from ever passing through an EDR’s minifilter,
    attackers can register their own minifilter and use it to force the completion
    of I/O operations. As an example, let’s register a malicious pre-operation callback
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_WRITE</samp> requests,
    as shown in [Listing 6-10](#list6-10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-10: Registering a malicious pre-operation callback routine'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: When the filter manager invokes this callback routine, it must return an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_CALLBACK_STATUS</samp> value.
    One of the possible values, <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_PREOP_COMPLETE</samp>,
    tells the filter manager that the current minifilter is in the process of completing
    the request, so the request shouldn’t be passed to any minifilters below the current
    altitude. If a minifilter returns this value, it must set the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTSTATUS</samp>
    value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Status</samp> member
    of the I/O status block to the operation’s final status. Antivirus engines whose
    minifilters communicate with user-mode scanning engines commonly use this functionality
    to determine whether malicious content is being written to a file. If the scanner
    indicates to the minifilter that the content is malicious, the minifilter completes
    the request and returns a failure status, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_VIRUS_INFECTED</samp>,
    to the caller.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: But attackers can abuse this feature of minifilters to prevent the security
    agent from ever intercepting their filesystem operations. Using the earlier callback
    we registered, this would look something like what’s shown in [Listing 6-11](#list6-11).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-11: Intercepting write operations and forcing their completion'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The attacker first inserts their malicious minifilter at an altitude higher
    than the minifilter belonging to the EDR. Inside the malicious minifilter’s pre-operation
    callback would exist logic to complete the I/O requests coming from the adversary’s
    processes in user mode ❶, preventing them from being passed down the stack to
    the EDR.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interference</samp>
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A final evasion technique, interference, is built around the fact that a minifilter
    can alter members of the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_CALLBACK_DATA</samp>
    structure passed to its callbacks on a request. An attacker can modify any members
    of this structure except the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestorMode</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> members. This
    includes the file pointer in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_IO_PARAMETER_BLOCK</samp>
    structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetFileObject</samp>
    member. The only requirement of the malicious minifilter is that it calls <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>,
    which indicates that the callback data structure has been modified when it is
    passing the request to minifilters lower in the stack.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: An adversary can abuse this behavior to pass bogus data to the minifilter associated
    with an EDR by inserting itself anywhere above it in the stack, modifying the
    data tied to the request and passing control back to the filter manager. A minifilter
    that receives the modified request may evaluate whether <samp class="SANS_TheSansMonoCd_W5Regular_11">FLTFL_CALLBACK_DATA_DIRTY</samp>,
    which is set by <samp class="SANS_TheSansMonoCd_W5Regular_11">fltmgr!FltSetCallbackDataDirty()</samp>,
    is present and act accordingly, but the data will still be modified.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minifilters are the de facto standard for monitoring filesystem activity on
    Windows, whether it be for NTFS, named pipes, or even mailslots. Their implementation
    is somewhat more complex than the drivers discussed earlier in this book, but
    the way they work is very similar; they sit inline of some system operation and
    receive data about the activity. Attackers can evade minifilters by abusing some
    logical issue in the sensor or even unloading the driver entirely, but most adversaries
    have adapted their tradecraft to drastically limit creating new artifacts on disk
    to reduce the chances of a minifilter picking up their activity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
