<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_612" aria-label="612"/>&#13;
<figure class="co-img"><img id="fig-pg612" class="img40" src="../images/pg612.jpg" alt="" width="687" height="2319"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-63.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_613" aria-label="613"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch20">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">REGISTER ALLOCATION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">Up until now, you’ve allocated space for every pseudoregister on the stack. This strategy is simple but painfully inefficient. Because instructions can’t always operate on values in memory directly, you sometimes need to generate extra instructions to copy values between these stack locations and registers. Even worse, the assembly code you generate has to access memory constantly, even though registers are faster. Now you’ll solve those problems. You’ll finish up your compiler by adding a <i>register allocation</i> pass, bolded in the diagram at the start of the chapter, to assign pseudoregisters to hard registers instead of locations in memory. You’ll use graph coloring, a classic register allocation technique, to come up with this assignment.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_614" aria-label="614"/>Once the initial version of the register allocator is up and running, you’ll give it one more job: to clean up some of the unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions produced during assembly generation. The final version of your allocator will perform <i>register coalescing</i> before assigning pseudoregisters to hard registers. The register coalescing step will look for <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions whose source and destination can be merged, or coalesced, into a single operand, which allows you to delete the instruction.</p>&#13;
<p class="TX">Register allocation has a little bit of everything: high-level theory, low-level details, brand-new concepts, and familiar techniques from earlier chapters. And the payoff is very satisfying: at the end of the chapter, you’ll be generating dramatically more efficient code. I think it’s a good note to end the book on.</p>&#13;
<p class="TX">To get started, let’s look at an example that illustrates why register allocation is such a powerful optimization.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-183"/><samp class="SANS_Futura_Std_Bold_B_11">Register Allocation in Action</samp></h3>&#13;
<p class="TNI">Consider the tiny C function in <a href="chapter20.xhtml#list20-1">Listing 20-1</a>.</p>&#13;
<a id="list20-1"/>&#13;
<pre><code>int f(int x, int y) {&#13;
    return 10 - (3 * y + x);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-1: A tiny C function</samp></p>&#13;
<p class="TX">First, our compiler will turn this into the tiny TACKY function in <a href="chapter20.xhtml#list20-2">Listing 20-2</a>.</p>&#13;
<a id="list20-2"/>&#13;
<pre><code>f(x, y):&#13;
    tmp0 = 3 * y&#13;
    tmp1 = tmp0 + x&#13;
    tmp2 = 10 - tmp1&#13;
    Return(tmp2)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-2: The TACKY code for <a href="chapter20.xhtml#list20-1">Listing 20-1</a></samp></p>&#13;
<p class="TX">This listing gives the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> after the optimization stage. (In particular, we’ve optimized out the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp> that we add to the end of each TACKY function as a backstop for missing <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements.)</p>&#13;
<p class="TX">Next, we’ll convert <a href="chapter20.xhtml#list20-2">Listing 20-2</a> to the assembly code in <a href="chapter20.xhtml#list20-3">Listing 20-3</a>.</p>&#13;
<a id="list20-3"/>&#13;
<pre><code>f:&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> movl    %edi, %x&#13;
    movl    %esi, %y&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> movl    $3, %tmp0&#13;
    imull   %y, %tmp0&#13;
    movl    %tmp0, %tmp1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_615" aria-label="615"/>    addl    %x, %tmp1&#13;
    movl    $10, %tmp2&#13;
    subl    %tmp1, %tmp2&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> movl    %tmp2, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-3: The assembly code for <a href="chapter20.xhtml#list20-2">Listing 20-2</a></samp></p>&#13;
<p class="TX">We set up the function’s parameters <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then we calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The operands <samp class="SANS_TheSansMonoCd_W5Regular_11">%x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2</samp> in this listing refer to the corresponding pseudoregisters; I’ll use this notation throughout the chapter.</p>&#13;
<p class="TX">Now we’ll walk through three approaches to replacing these pseudoregisters with real operands. First, we’ll replace them with stack addresses, which is what our compiler does right now. On our next attempt, we’ll replace them with hard registers, without performing register coalescing first; this is what the initial version of our register allocator will do. The third time around, we’ll perform register coalescing before replacing the pseudoregisters with hard registers. That’s how our finished allocator will handle this program. (A quick note on terminology: throughout this chapter, I’ll use the word <i>register</i> to refer to pseudoregisters and hard registers collectively.)</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2"><span id="sec2"/><span id="h2-226"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take One: Put Everything on the Stack</samp></h4>&#13;
<p class="TNI">In its current form, our compiler will replace each pseudoregister with a stack slot according to <a href="chapter20.xhtml#tab20-1">Table 20-1</a>.</p>&#13;
<p class="TT" id="tab20-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 20-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Replacing Pseudoregisters with Stack Addresses</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Pseudoregister</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Real location</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-20(%rbp)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">This will give us the assembly code in <a href="chapter20.xhtml#list20-4">Listing 20-4</a>.</p>&#13;
<a id="list20-4"/>&#13;
<pre><code>f:&#13;
    movl    %edi, -4(%rbp)&#13;
    movl    %esi, -8(%rbp)&#13;
    movl    $3, -12(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> imull   -8(%rbp), -12(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> movl    -12(%rbp), -16(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> addl    -4(%rbp), -16(%rbp)&#13;
    movl    $10, -20(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> subl    -16(%rbp), -20(%rbp)&#13;
    movl    -20(%rbp), %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-4: <a href="chapter20.xhtml#list20-3">Listing 20-3</a> after replacing pseudoregisters with stack addresses</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_616" aria-label="616"/>Once we replace every pseudoregister with a memory address, instructions <span class="CodeAnnotation" aria-label="annotation1">❶</span>, <span class="CodeAnnotation" aria-label="annotation2">❷</span>, <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and <span class="CodeAnnotation" aria-label="annotation4">❹</span> are invalid, so the instruction fix-up pass will need to repair them. It will insert an extra instruction before <span class="CodeAnnotation" aria-label="annotation1">❶</span> to load its destination into a hard register, and it will add another to store the result back to <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp> afterward. It will also insert instructions to load the source operands of <span class="CodeAnnotation" aria-label="annotation2">❷</span>, <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and <span class="CodeAnnotation" aria-label="annotation4">❹</span> into hard registers. In the context of register allocation, we say a pseudoregister is <i>spilled</i> to memory if we store its contents on the stack instead of in a hard register. The extra instructions we insert to move spilled values between registers and memory are called <i>spill code</i>.</p>&#13;
<p class="TX">We’ll ultimately end up with the assembly code in <a href="chapter20.xhtml#list20-5">Listing 20-5</a>. I’ve bolded the spill code to make it easier to spot. (I’ve also snipped out the instructions to set up and tear down the stack frame, which aren’t relevant here. These are snipped out of assembly programs later in the chapter too.)</p>&#13;
<a id="list20-5"/>&#13;
<pre><code>f:&#13;
<var>    --snip--</var>&#13;
    movl    %edi, -4(%rbp)&#13;
    movl    %esi, -8(%rbp)&#13;
    movl    $3, -12(%rbp)&#13;
<b>    movl    -12(%rbp), %r11d</b>&#13;
    imull   -8(%rbp), %r11d&#13;
<b>    movl    %r11d, -12(%rbp)</b>&#13;
<b>    movl    -12(%rbp), %r10d</b>&#13;
    movl    %r10d, -16(%rbp)&#13;
<b>    movl    -4(%rbp), %r10d</b>&#13;
    addl    %r10d, -16(%rbp)&#13;
    movl    $10, -20(%rbp)&#13;
<b>    movl    -16(%rbp), %r10d</b>&#13;
    subl    %r10d, -20(%rbp)&#13;
    movl    -20(%rbp), %eax&#13;
<var>    --snip--</var>&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-5: <a href="chapter20.xhtml#list20-4">Listing 20-4</a> with spill code</samp></p>&#13;
<p class="TX">This code is incredibly inefficient. Almost every instruction accesses memory, and we waste a huge amount of time copying data from one place to another. To take one particularly egregious example, we store the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">3 * y</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>, then immediately copy it into <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>—which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions—and never use <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp> again.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-227"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take Two: Register Allocation</samp></h4>&#13;
<p class="TNI">Let’s try a more reasonable strategy. This time, we’ll replace each pseudoregister with a hard register instead of a stack address, as shown in <a href="chapter20.xhtml#tab20-2">Table 20-2</a>.</p>&#13;
<p class="TT" id="tab20-2"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_617" aria-label="617"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 20-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Replacing Pseudoregisters with Hard Registers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Pseudoregister</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Real location</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%ecx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> with registers that don’t appear at all in the original assembly program. We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> with EDI, which <i>is</i> used in the original program. This is fine, since we use <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> only once we’re done using EDI for anything else. Later in the chapter, we’ll see how to reason more systematically about which mappings from pseudoregisters to hard registers are safe and which ones might cause conflicts.</p>&#13;
<p class="TX">There’s no spill code this time, so I won’t include separate listings from before and after the instruction fix-up pass. Instead, we’ll skip right to the final assembly code, shown in <a href="chapter20.xhtml#list20-6">Listing 20-6</a>.</p>&#13;
<a id="list20-6"/>&#13;
<pre><code>f:&#13;
<var>    --snip--</var>&#13;
    movl    %edi, %edx&#13;
    movl    %esi, %ecx&#13;
    movl    $3, %r8d&#13;
    imull   %ecx, %r8d&#13;
    movl    %r8d, %r9d&#13;
    addl    %edx, %r9d&#13;
    movl    $10, %edi&#13;
    subl    %r9d, %edi&#13;
    movl    %edi, %eax&#13;
<var>    --snip--</var>&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-6: The final assembly code for <a href="chapter20.xhtml#list20-3">Listing 20-3</a> after register allocation</samp></p>&#13;
<p class="TX">This is a major improvement; we don’t access memory, and we have fewer instructions overall. If we wanted to, we could even omit the instructions to set up and tear down the stack frame, since we never use the stack. But we’re still moving data around more than we need to. For instance, we copy our function parameters from EDI and ESI to new locations, instead of leaving them where they are. We also copy <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> (now in <samp class="SANS_TheSansMonoCd_W5Regular_11">%r8d</samp>) to <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> (now in <samp class="SANS_TheSansMonoCd_W5Regular_11">%r9d</samp>), when we could just as easily use <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> for two calculations in a row. This isn’t the register allocator’s fault; it’s just that we generated inefficient TACKY and assembly code in earlier passes. But if we’re thoughtful about how we allocate registers, we can clean up after those earlier passes. That’s why our register allocator will include one more step: register coalescing.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_618" aria-label="618"/>&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-228"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Take Three: Register Allocation with Coalescing</samp></h4>&#13;
<p class="TNI">Our last approach has two steps. First, we’ll coalesce registers: we’ll look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in the function and decide whether its operands can be merged together. Then, we’ll replace any remaining pseudoregisters with hard registers, like we did in our previous attempt.</p>&#13;
<p class="TX">Let’s take another look at the original assembly program from <a href="chapter20.xhtml#list20-3">Listing 20-3</a>. This program includes four <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions whose source and destination are both registers, which are bolded here:</p>&#13;
<pre><code>f:&#13;
<b>    movl    %edi, %x</b>&#13;
<b>    movl    %esi, %y</b>&#13;
    movl    $3, %tmp0&#13;
    imull   %y, %tmp0&#13;
<b>    movl    %tmp0, %tmp1</b>&#13;
    addl    %x, %tmp1&#13;
    movl    $10, %tmp2&#13;
    subl    %tmp1, %tmp2&#13;
<b>    movl    %tmp2, %eax</b>&#13;
    ret</code></pre>&#13;
<p class="TX">Sometimes, copying values from one register to another is genuinely necessary. For example, we might need to copy <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> out of EDI if we were going to pass another function argument in EDI later. But in this case, it’s safe to merge <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into EDI, since we don’t need EDI for anything else after that first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction. The same logic applies to each of the other three <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions. We won’t need to store different values in the source and destination operands at the same time, so it’s safe to merge them together. We’ll merge <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into EDI, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> into ESI, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EAX.</p>&#13;
<p class="TX"><a href="chapter20.xhtml#tab20-3">Table 20-3</a> summarizes which pairs of registers we’ll coalesce and shows which member of each pair will remain in the program.</p>&#13;
<p class="TT" id="tab20-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 20-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Coalescing Registers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Coalesced pair</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Remaining register</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%edi, %x</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%esi, %y</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%esi</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0, %tmp1</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%tmp2, %eax</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We’ll also delete all four <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions, since they no longer serve any purpose. <a href="chapter20.xhtml#list20-7">Listing 20-7</a> gives the resulting assembly code, with the updated operands bolded.</p>&#13;
<a id="list20-7"/>&#13;
<pre><code>f:&#13;
    movl    $3, %tmp0&#13;
    imull   <b>%esi</b>, %tmp0&#13;
    addl    <b>%edi</b>, <b>%tmp0</b>&#13;
    movl    $10, <b>%eax</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_619" aria-label="619"/>    subl    <b>%tmp0</b>, <b>%eax</b>&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-7: <a href="chapter20.xhtml#list20-3">Listing 20-3</a> after register coalescing</samp></p>&#13;
<p class="TX">This looks a lot more reasonable! We leave <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in EDI and ESI, where they were passed to begin with, instead of copying them to new locations. When we calculate the return value, we store the result in EAX right away, instead of copying it into EAX after we’ve calculated it. And we no longer use two separate temporary registers to calculate the intermediate and final results in <samp class="SANS_TheSansMonoCd_W5Regular_11">3 * y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>; we stick with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> the whole time.</p>&#13;
<p class="TX">We’re not quite done; we still need to replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp0</samp> with a hard register. Any register besides ESI, EDI, or EAX will do—let’s go with ECX. <a href="chapter20.xhtml#list20-8">Listing 20-8</a> shows the assembly code we’ll ultimately wind up with.</p>&#13;
<a id="list20-8"/>&#13;
<pre><code>f:&#13;
<var>    --snip--</var>&#13;
    movl    $3, %ecx&#13;
    imull   %esi, %ecx&#13;
    addl    %edi, %ecx&#13;
    movl    $10, %eax&#13;
    subl    %ecx, %eax&#13;
<var>    --snip--</var>&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-8: The final assembly code for <a href="chapter20.xhtml#list20-3">Listing 20-3</a> after register allocation with coalescing</samp></p>&#13;
<p class="TX">Register allocation without coalescing improved our code in two ways: it reduced the number of memory accesses and the amount of spill code in our program. With register coalescing, we improve our code even further by removing the many unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions generated by earlier passes.</p>&#13;
<p class="TX">Now that we have a sense of what we want to accomplish, let’s look at how register allocation fits into the whole compiler pipeline.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1"><span id="sec5"/><span id="h1-184"/><samp class="SANS_Futura_Std_Bold_B_11">Updating the Compiler Pipeline</samp></h3>&#13;
<p class="TNI">Register allocators work best when there are lots of hard registers available, so the very first thing we’ll do is add every remaining hard register to the assembly AST, including the callee-saved registers that we’ve avoided so far. We’ll also make one small change to the conversion from TACKY to assembly: during this pass, we’ll store extra information in the backend symbol table about which hard registers each function uses to pass parameters and return values.</p>&#13;
<p class="TX">Next, we’ll implement the register allocator itself. The register allocator will run just after we convert the program from TACKY to assembly, before any of the other backend compiler passes. Much like the optimizations we implemented in <span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span>, this pass will process each assembly function independently.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_620" aria-label="620"/>Even after register allocation, there may still be some pseudoregisters left in the program. This could happen for a couple of reasons. First, if a function uses lots of pseudoregisters at once, there might not be enough hard registers to accommodate all of them. When that happens, we’ll have to spill some pseudoregisters to memory. Our register allocator won’t replace spilled pseudoregisters; it will just leave them in the program for the next pass to deal with. Second, some pseudoregisters represent variables with static storage duration. These must live in memory instead of registers. If you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you’ll encounter a few other objects that must live in memory, including aliased variables, structures, and arrays. The register allocator won’t touch these either.</p>&#13;
<p class="TX">To deal with all these stragglers, we’ll run our old pseudo-operand replacement pass immediately after the register allocator. We won’t make any changes to this pass. It will handle any pseudo-operands it finds exactly the same way it did before; it will just find a lot fewer of them.</p>&#13;
<p class="TX">Next, we’ll update the instruction fix-up pass to take care of saving and restoring callee-saved registers. All our existing rewrite rules—including the rules to generate spill code—will stay the same. Since we still replace some pseudoregisters with locations in memory, we’ll still have to generate spill code some of the time.</p>&#13;
<p class="TX">Finally, we’ll extend the code emission stage to support the new hard registers we introduce in this chapter. You might want to stub out the new register allocation stage at this point. Then, we’ll update the assembly AST one last time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1"><span id="sec6"/><span id="h1-185"/><samp class="SANS_Futura_Std_Bold_B_11">Extending the Assembly AST</samp></h3>&#13;
<p class="TNI">So far, the assembly AST has included only the registers that we used for a particular purpose, such as passing parameters or rewriting instructions. It doesn’t include any of the callee-saved registers: RBX, R12, R13, R14, and R15. Now we’ll add these five registers so the register allocator can use them. We’ll also add the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction, which we’ll use to restore callee-saved registers at the end of a function. If you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you should also add the remaining XMM registers, XMM8 through XMM13. These registers are not callee-saved.</p>&#13;
<p class="TX"><a href="chapter20.xhtml#list20-9">Listing 20-9</a> shows the complete assembly AST that includes everything we covered in <span class="Xref-1"><a href="part1.xhtml">Parts I</a></span>, <span class="Xref-1"><a href="part2.xhtml">II</a></span>, and <span class="Xref-1"><a href="part3.xhtml">III</a></span>, with this chapter’s additions bolded.</p>&#13;
<a id="list20-9"/>&#13;
<pre><code>program = Program(top_level*)&#13;
assembly_type = Byte | Longword | Quadword | Double | ByteArray(int size, int alignment)&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, static_init* init_list)&#13;
          | StaticConstant(identifier name, int alignment, static_init init)&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(assembly_type src_type, assembly_type dst_type, operand src, operand dst)&#13;
            | MovZeroExtend(assembly_type src_type, assembly_type dst_type,&#13;
                            operand src, operand dst)&#13;
            | Lea(operand src, operand dst)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_621" aria-label="621"/>            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)&#13;
            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            | Div(assembly_type, operand)&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            <b>| Pop(reg)</b>&#13;
            | Call(identifier)&#13;
            | Ret&#13;
unary_operator = Neg | Not | Shr&#13;
binary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor | Shl | ShrTwoOp&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier, int)&#13;
        | PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)&#13;
cond_code = E | NE | G | GE | L | LE | A | AE | B | BE&#13;
reg = AX <b>| BX</b> | CX | DX | DI | SI | R8 | R9 | R10 | R11 <b>| R12 | R13 | R14 | R15</b> | SP | BP&#13;
    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7&#13;
    <b>| XMM8 | XMM9 | XMM10 | XMM11 | XMM12 | XMM13</b> | XMM14 | XMM15</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-9: The complete assembly AST with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pop</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction and additional registers</samp></p>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> accepts only registers, not other operands. Now that we’ve updated the AST, let’s move on to the conversion from TACKY to assembly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1"><span id="sec7"/><span id="h1-186"/><samp class="SANS_Futura_Std_Bold_B_11">Converting TACKY to Assembly</samp></h3>&#13;
<p class="TNI">We’ll make just one change to this pass. We aren’t changing what assembly we generate; we’re just recording extra information in the backend symbol table. Specifically, we’ll record which registers are used to pass each function’s parameters. As you’ll see in the next section, the register allocator needs this information to figure out which hard registers and pseudoregisters conflict.</p>&#13;
<p class="TX">Suppose we have the following function declaration:</p>&#13;
<pre><code>int foo(int i, int j);</code></pre>&#13;
<p class="TX">We’ll record that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>’s parameters are passed in the first two parameter passing registers, RDI and RSI. We’ll track this information even if <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> is defined in a different translation unit, because we’ll need it to allocate registers in functions that call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.</p>&#13;
<p class="TX">If you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, you should also track which registers are used to pass each function’s return value. Given the function declaration</p>&#13;
<pre><code>double foo(int i, double d);</code></pre>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_622" aria-label="622"/>we’ll record that <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>’s parameters are passed in RDI and XMM0 and that its return value is also passed in XMM0. To figure out which registers a function uses to pass parameters and return values, we’ll use the same logic we implemented in the <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_return_value</samp> helper functions in <span class="Xref-1"><a href="chapter18.xhtml">Chapter 18</a></span>. Note that we might run into function declarations with incomplete return types or parameter types. It doesn’t matter what information we record about these functions, since it would be illegal to either define or call them in the current translation unit; we just need to handle them without crashing. It’s easiest to simply record that they don’t pass any values in registers.</p>&#13;
<p class="TX">Next, we’ll build the register allocator itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1"><span id="sec8"/><span id="h1-187"/><samp class="SANS_Futura_Std_Bold_B_11">Register Allocation by Graph Coloring</samp></h3>&#13;
<p class="TNI">Our compiler will model register allocation as a <i>graph coloring</i> problem. Coloring a graph means assigning every node a label (traditionally called a “color”) so that each node has a different color from all its neighbors. A graph is <i>k-colorable</i> if you can color it with <i>k</i> or fewer colors. <a href="#fig20-1">Figure 20-1</a> illustrates a 3-colored graph.</p>&#13;
<figure class="IMG"><img id="fig20-1" class="img50" src="../images/fig20-1.jpg" alt="" width="600" height="601"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: A 3-colored graph <a href="description-64.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Graph coloring is an important area of research in its own right; mathematicians have been investigating how to color graphs since the 19th century! It’s relevant to register allocation because it captures two fundamental constraints on how we can assign pseudoregisters to hard registers: we have a limited number of hard registers to work with, and some registers will <i>interfere</i> with each other, meaning they can’t occupy the same physical location. If two pseudoregisters interfere, we need to assign them to two different hard registers. A pseudoregister might also interfere with a hard register, which means we can’t assign it to that hard register.</p>&#13;
<p class="TX">Graph coloring lets us express both kinds of interference and handle them in a uniform way. To turn register allocation into a graph coloring problem, we’ll first build a <i>register interference graph</i> with nodes representing <span role="doc-pagebreak" epub:type="pagebreak" id="pg_623" aria-label="623"/>pseudoregisters and hard registers and with edges between any registers that interfere. Then, we’ll color the graph, using one color per hard register. Finally, we’ll assign each pseudoregister to a hard register according to its color. Because each register gets a different color from all of its neighbors, we’ll never assign two pseudoregisters that interfere to the same hard register or assign a pseudoregister to a hard register that it interferes with.</p>&#13;
<p class="TX">Let’s try out this technique on the assembly function in <a href="chapter20.xhtml#list20-10">Listing 20-10</a>.</p>&#13;
<a id="list20-10"/>&#13;
<pre><code>divide_and_subtract:&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> movl    %edi, %a&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> movl    %esi, %b&#13;
    movl    %a, %eax&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> cdq&#13;
    idivl   %b&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> movl    %eax, %tmp&#13;
    subl    %b, %tmp&#13;
    movl    %tmp, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-10: A small assembly function</samp></p>&#13;
<p class="TX">This function takes two parameters, which it copies into the pseudoregisters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. It calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b - b</samp> and stores the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>. Finally, it returns the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> in EAX. We need to figure out which registers in this function interfere so we can build the interference graph. To start off, it’s easy to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interfere. If we map them to the same hard register, we’ll clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This is a problem because <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is still live at this point. You learned in <span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span> that a variable is live if its current value might be used later in the program, and otherwise it’s dead. This definition applies to registers too. When a register is live, we need to preserve its value, so we can’t store a different value in the same location. When it’s dead, we’re free to overwrite its value with something else. This gives us an easy rule for detecting interference: two registers interfere if we update one while the other is live.</p>&#13;
<p class="TX">This rule also tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, since <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is live when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. But <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> don’t interfere; <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is already dead by the time we define <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, so it’s fine to map them to the same hard register.</p>&#13;
<p class="TX">Now let’s think through which hard registers interfere with pseudoregisters. ESI interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> because ESI is live when we define <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If we mapped <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to ESI, we’d clobber the function’s second parameter before we had a chance to copy it to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. EAX interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> because <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is live when we copy <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to EAX to prepare for division. The last source of interference is less obvious. Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction sign extends the value from EAX into EDX <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> implicitly updates EDX while <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is live, it makes EDX interfere with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>; if we mapped <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to EDX, this instruction would clobber it. (Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction updates EAX and EDX implicitly, so it would make both of these registers interfere with <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> if they didn’t already.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_624" aria-label="624"/>Finally, the hard registers all interfere with each other. This is sort of tautological; they can’t occupy the same physical location because they represent different physical locations to begin with. Still, we need to capture this in the interference graph to make sure that each hard register gets its own color.</p>&#13;
<p class="TX">Now that we’ve figured out which registers interfere, we’ll construct the graph. To keep this graph relatively small and readable, we’ll pretend that the only hard registers are EDI, ESI, EAX, and EDX. Our real register interference graphs will include every hard register we can assign pseudoregisters to, even if the assembly program doesn’t use them. However, they’ll exclude RSP, RBP, and the scratch registers that we use during instruction fix-up.</p>&#13;
<p class="TX"><a href="#fig20-2">Figure 20-2</a> illustrates the interference graph for the function in <a href="chapter20.xhtml#list20-10">Listing 20-10</a>.</p>&#13;
<figure class="IMG"><img id="fig20-2" class="img60" src="../images/fig20-2.jpg" alt="" width="872" height="586"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: The register interference graph for divide_and_subtract <a href="description-65.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This graph encodes all the interferences we just identified: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> interferes with ESI and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>; <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> interferes with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, EAX, and EDX as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>; and all four hard registers interfere with each other.</p>&#13;
<p class="TX">Now we’ll try to <i>k</i>-color this graph, where <i>k</i> is the number of hard registers in the graph. In this small example, <i>k</i> is 4. There are several possible 4-colorings of <a href="#fig20-2">Figure 20-2</a>. <a href="#fig20-3">Figure 20-3</a> shows a few of them.</p>&#13;
<figure class="IMG"><img class="img100" id="fig20-3" src="../images/fig20-3.jpg" alt="" width="1674" height="340"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Three valid 4-colorings of the register interference graph for divide_and_subtract <a href="description-66.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_625" aria-label="625"/>Any one of these colorings—or any other 4-coloring we can come up with—will give us a valid register assignment. Each register will receive a different color from any of its neighbors. And because the <i>k</i> hard registers all interfere with each other, we’ll assign each color to exactly one hard register, which creates a 1:1 mapping from colors to hard registers.</p>&#13;
<p class="TX">After we color the graph, we’ll replace each pseudoregister with the hard register that received the same color. If we use the first coloring from <a href="#fig20-3">Figure 20-3</a>, we’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> with EDX, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> with EDI, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> with EAX, which gives us the assembly code in <a href="chapter20.xhtml#list20-11">Listing 20-11</a>.</p>&#13;
<a id="list20-11"/>&#13;
<pre><code>divide_and_subtract:&#13;
    movl    %edi, %edx&#13;
    movl    %esi, %edi&#13;
    movl    %edx, %eax&#13;
    cdq&#13;
    idivl   %edi&#13;
    movl    %eax, %eax&#13;
    subl    %edi, %eax&#13;
    movl    %eax, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-11: Replacing registers in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">divide_and_subtract</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">based on the first coloring in <a href="#fig20-3">Figure 20-3</a></samp></p>&#13;
<p class="TX">If you like, you can work through this listing and confirm that it produces the same result as the original code for <samp class="SANS_TheSansMonoCd_W5Regular_11">divide_and_subtract</samp> in <a href="chapter20.xhtml#list20-10">Listing 20-10</a>. You can also try this out with the other colorings in <a href="#fig20-3">Figure 20-3</a>.</p>&#13;
<p class="TX">Note that coloring the graph produces two different mappings: one from all registers to colors and one from colors to hard registers. Conceptually, each color represents a hard register, but we don’t know <i>which</i> hard register until after we’ve colored the graph. If instead we used the names of the hard registers themselves as colors, or associated each hard register with a color ahead of time, then we would have to <i>precolor</i> each hard register with the corresponding color before we tried to color the rest of the graph. Precoloring adds more constraints to the graph coloring problem, which makes it harder to find a valid coloring. Some graph coloring implementations require precolored nodes; luckily, ours isn’t one of them.</p>&#13;
<aside class="box-rule" aria-label="box-128"><p class="BoxTitle" id="box-128"><samp class="SANS_Dogma_OT_Bold_B_11">USING LIVE RANGES INSTEAD OF PSEUDOREGISTERS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Our register allocator will map pseudoregisters to hard registers. Most register allocators, however, solve a slightly different problem: they map</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">live ranges</samp> <samp class="SANS_Futura_Std_Book_11">to hard registers. A live range is a region of the program in which a particular pseudoregister is live. A single pseudoregister may have multiple live ranges (that is, it may be live in several unconnected regions of a program). These live</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_626" aria-label="626"/><samp class="SANS_Futura_Std_Book_11">ranges can safely be assigned to different hard registers. Here’s a simple, if unrealistic, example:</samp></p>&#13;
<pre><code>two_live_ranges:&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> movl    $1, %x&#13;
    addl    %x, var(%rip)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> movl    $2, %x&#13;
    movl    %x, %eax&#13;
    ret&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">In this example,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">has two live ranges. The first starts when we define</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> <samp class="SANS_Futura_Std_Book_11">and ends after we add it to the static variable</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> <samp class="SANS_Futura_Std_Book_11">in the next instruction. The second starts when we redefine</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> <samp class="SANS_Futura_Std_Book_11">and ends after we use it in the instruction right after that. Let’s rewrite the program to refer to these live ranges explicitly:</samp></p>&#13;
<pre><code>two_live_ranges:&#13;
    movl    $1, %x.1&#13;
    addl    %x.1, var(%rip)&#13;
    movl    $2, %x.2&#13;
    movl    %x.2, %eax&#13;
    ret&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Now it’s clear that we don’t need to assign</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x.1</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x.2</samp> <samp class="SANS_Futura_Std_Book_11">to the same hard register. A typical register allocator starts by identifying the distinct live ranges for each pseudoregister and giving each one its own name, like we just did for</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">two_live_ranges</samp><samp class="SANS_Futura_Std_Book_11">. It then uses these live ranges, rather than pseudoregisters, as nodes in the interference graph. This puts fewer constraints on where the allocator can place each live range, which makes it easier to find a valid register assignment.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">We’re building a simplified register allocator that doesn’t identify live ranges, so we’ll just use pseudoregisters from the original assembly code as nodes in the interference graph. (Confusingly, identifying live ranges isn’t quite the same as</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">liveness analysis</samp><samp class="SANS_Futura_Std_Book_11">, which we discussed in <a href="chapter19.xhtml">Chapter 19</a>. Our allocator will perform liveness analysis to learn when each register is live, but identifying live ranges is a more involved process in which liveness analysis is just the first step.)</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If you want to build a more sophisticated register allocator that works with live ranges instead of pseudoregisters, you’ll find a few useful references listed in “Additional Resources” on <a href="#pg_669">page 669</a>.</samp></p>&#13;
</aside>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-229"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Interference</samp></h4>&#13;
<p class="TNI">Earlier, I said that two registers interfered if we updated one while the other was live. We used this rule to figure out which registers interfered in <samp class="SANS_TheSansMonoCd_W5Regular_11">divide _and_subtract</samp>; it helped us identify both interference between pseudoregisters <span role="doc-pagebreak" epub:type="pagebreak" id="pg_627" aria-label="627"/>and interference between pseudoregisters and hard registers. But there are a couple of important points about this rule that we still need to cover.</p>&#13;
<p class="TX">The first point is that two registers interfere only if one is live <i>immediately after</i> we update the other. Here’s a short example:</p>&#13;
<pre><code>movl    4(%rdi), %x&#13;
movl    %x, %eax&#13;
ret</code></pre>&#13;
<p class="TX">In this code snippet, RDI holds some memory address—presumably the address of a structure or array. The first instruction in this snippet takes the value stored in memory at RDI + 4 and copies it into <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>. Before this instruction, RDI is live; afterward, it’s dead. RDI and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> don’t interfere. If we map <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to RDI, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction will overwrite the address in RDI. But that’s okay, because we won’t use that address again.</p>&#13;
<p class="TX">The second point is that two registers interfere only if they have different values. Concretely, this means the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov src, dst</samp> won’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> interfere, even if <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> is still live afterward. In <a href="chapter20.xhtml#list20-12">Listing 20-12</a>, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> don’t interfere.</p>&#13;
<a id="list20-12"/>&#13;
<pre><code>movl    $1, %y&#13;
movl    %y, %x&#13;
addl    %x, %ecx&#13;
addl    %y, %eax</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-12: A snippet of assembly where the source operand of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">mov</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction is still live after that instruction</samp></p>&#13;
<p class="TX">If we assign <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> to the same hard register, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction won’t clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> with a new value. Instead, it will have no effect at all. When we perform register coalescing, we’ll even go out of our way to put <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in the same register so that we can delete this instruction entirely.</p>&#13;
<p class="TX">Two registers connected by a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction could still interfere for other reasons, as <a href="chapter20.xhtml#list20-13">Listing 20-13</a> demonstrates.</p>&#13;
<a id="list20-13"/>&#13;
<pre><code>movl    $1, %y&#13;
movl    %y, %x&#13;
addl    $1, %y&#13;
addl    %x, %y</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-13: A snippet of assembly where a later instruction makes the operands of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">mov</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction interfere</samp></p>&#13;
<p class="TX">In this snippet, the second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction doesn’t make <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> interfere, but the subsequent <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instruction does, because it updates <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> while <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live. In this case, putting <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> in the same register would be unsafe.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2"><span id="sec10"/><span id="h2-230"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Spilling Registers</samp></h4>&#13;
<p class="TNI">We can’t always <i>k</i>-color the interference graph. Consider the assembly function in <a href="chapter20.xhtml#list20-14">Listing 20-14</a>, which calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">10 / arg1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1 / arg2</samp>.</p>&#13;
<a id="list20-14"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_628" aria-label="628"/>uncolorable:&#13;
    movl    %edi, %arg1&#13;
    movl    %esi, %arg2&#13;
    movl    $10, %eax&#13;
    cdq&#13;
    idivl   %arg1&#13;
    movl    %eax, %tmp&#13;
    movl    %arg1, %eax&#13;
    cdq&#13;
    idivl   %arg2&#13;
    addl    %tmp, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-14: Calculating</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">10 / arg1 + arg1 / arg2</samp></p>&#13;
<p class="TX">For the purpose of this example, we’ll pretend that we have four hardware registers: ESI, EDI, EDX, and EAX. <a href="#fig20-4">Figure 20-4</a> shows the interference graph for the listing. I won’t walk you through how to construct the graph, but you can verify it on your own if you like.</p>&#13;
<figure class="IMG"><img id="fig20-4" class="img40" src="../images/fig20-4.jpg" alt="" width="503" height="897"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: The interference graph for <a href="chapter20.xhtml#list20-14">Listing 20-14</a> <a href="description-67.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">It’s impossible to 4-color this graph. Note that EAX, EDX, <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> all interfere with each other. That means each of them must receive a different color than the other four, which would require five distinct colors. We’ll solve this problem by spilling a register—in other words, removing it from the graph instead of coloring it. Spilling any one of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> will make the graph colorable. If we spill <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, for example, we can use the coloring shown in <a href="#fig20-5">Figure 20-5</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_629" aria-label="629"/>&#13;
<figure class="IMG"><img id="fig20-5" class="img40" src="../images/fig20-5.jpg" alt="" width="585" height="813"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: Coloring the interference graph after spilling tmp <a href="description-68.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now we can replace the two pseudoregisters that we colored, but not <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>. <a href="chapter20.xhtml#list20-15">Listing 20-15</a> gives the resulting assembly code, with changes from <a href="chapter20.xhtml#list20-14">Listing 20-14</a> bolded.</p>&#13;
<a id="list20-15"/>&#13;
<pre><code>uncolorable:&#13;
    movl    %edi, <b>%edi</b>&#13;
    movl    %esi, <b>%esi</b>&#13;
    movl    $10, %eax&#13;
    cdq&#13;
    idivl   <b>%edi</b>&#13;
    movl    %eax, %tmp&#13;
    movl    <b>%edi</b>, %eax&#13;
    cdq&#13;
    idivl   <b>%esi</b>&#13;
    addl    %tmp, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-15: The</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">uncolorable</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function after register allocation</samp></p>&#13;
<p class="TX">Note that we’ve made the first two instructions in this listing redundant. We could optimize the code further by deleting them, but we won’t worry about this optimization for now.</p>&#13;
<p class="TX">After the register allocator has assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">arg1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">arg2</samp> to hard registers, the pseudo-operand replacement pass will put <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> on the stack. <a href="chapter20.xhtml#list20-16">Listing 20-16</a> gives the final assembly code for this function, with the changes from <a href="chapter20.xhtml#list20-15">Listing 20-15</a> bolded.</p>&#13;
<a id="list20-16"/>&#13;
<pre><code>uncolorable:&#13;
<var>    --snip--</var>&#13;
    movl    %edi, %edi&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_630" aria-label="630"/>    movl    %esi, %esi&#13;
    movl    $10, %eax&#13;
    cdq&#13;
    idivl   %edi&#13;
    movl    %eax, <b>-4(%rbp)</b>&#13;
    movl    %edi, %eax&#13;
    cdq&#13;
    idivl   %esi&#13;
    addl    <b>-4(%rbp)</b>, %eax&#13;
<var>    --snip--</var>&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-16: The final assembly code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">uncolorable</samp></p>&#13;
<p class="TX">Spilling one pseudoregister made it possible to replace all the others with hard registers. But <i>which</i> registers we decide to spill matters a lot! As a general rule, the more frequently a pseudoregister is accessed, the more it will hurt performance to spill that pseudoregister. Our allocator will calculate a <i>spill cost</i> for each register in the interference graph. This is an estimate of how much spilling that register will hurt performance. Then, when we color the graph, we’ll use that information to minimize the overall performance impact of spills.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1"><span id="sec11"/><span id="h1-188"/><samp class="SANS_Futura_Std_Bold_B_11">The Basic Register Allocator</samp></h3>&#13;
<p class="TNI">Now that we have some idea of how our register allocator will work, let’s implement it! <a href="chapter20.xhtml#list20-17">Listing 20-17</a> describes how to allocate registers for a single function.</p>&#13;
<a id="list20-17"/>&#13;
<pre><code>allocate_registers(instructions):&#13;
    interference_graph = build_graph(instructions)&#13;
    add_spill_costs(interference_graph, instructions)&#13;
    color_graph(interference_graph)&#13;
    register_map = create_register_map(interference_graph)&#13;
    transformed_instructions = replace_pseudoregs(instructions, register_map)&#13;
    return transformed_instructions</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-17: The top-level register allocation algorithm</samp></p>&#13;
<p class="TX">We start by building the interference graph. Then, we calculate a spill cost for each register based on how frequently it’s used and annotate the graph with that information. Next, we color the graph, annotating each node with its color. If we can’t color every node, we’ll use the spill costs we calculated in the previous step to decide what to spill. To spill a node, we’ll just leave it uncolored.</p>&#13;
<p class="TX">The last step is replacing all the pseudoregisters we colored. In <samp class="SANS_TheSansMonoCd_W5Regular_11">create _register_map</samp>, we construct a map from colored pseudoregisters to hard registers with the same color. Finally, we rewrite the body of the function, replacing each pseudoregister with the corresponding hard register from the map.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_631" aria-label="631"/>Go ahead and stub out <samp class="SANS_TheSansMonoCd_W5Regular_11">allocate_registers</samp>. Then, we’ll walk through how to implement each of these steps.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-231"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Multiple Types During Register Allocation</samp></h4>&#13;
<p class="TNI">If you completed <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, then you’ll need to run the whole algorithm in <a href="chapter20.xhtml#list20-17">Listing 20-17</a> twice: once to allocate general-purpose registers and once to allocate XMM registers. On each run, you’ll include only registers of the appropriate type in the interference graph. The new features we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> will change a few other details about how we build the interference graph too. We’ll take a closer look at these changes when we implement <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp>.</p>&#13;
<p class="TX">The individual steps after building the interference graph—including calculating spill costs, coloring the graph, and replacing pseudoregisters—look exactly the same whether we’re dealing with floating-point or general-purpose registers. The other features we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> won’t impact these steps either.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2"><span id="sec13"/><span id="h2-232"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining the Interference Graph</samp></h4>&#13;
<p class="TNI">To get started, we’ll define the data structure for the interference graph. <a href="chapter20.xhtml#list20-18">Listing 20-18</a> presents one possible representation.</p>&#13;
<a id="list20-18"/>&#13;
<pre><code>node = Node(operand id, operand* neighbors, double spill_cost, int? color, bool pruned)&#13;
graph = Graph(node* nodes)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-18: The definition of the register interference graph</samp></p>&#13;
<p class="TX">Each node in the graph corresponds to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> operand from the assembly AST. We’ll track each node’s neighbors, spill cost, and color. We’ll represent colors with the integers <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>, where <i>k</i> is the number of available hard registers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field is optional because we may not be able to color every node. We’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> flag when we color the graph; you can ignore it until then. When you create a new node, you should initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">spill_cost</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>&#13;
<p class="TX">This definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> is a bit more permissive than it needs to be; the <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp> type includes constants and memory locations, which we’ll never add to the interference graph. Alternatively, you could replace <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp> with a dedicated <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp> type that can represent only registers. I’m using a more permissive definition so that we don’t have to constantly convert back and forth between <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">node_id</samp> throughout the allocator.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-233"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Interference Graph</samp></h4>&#13;
<p class="TNI">We’re finally ready to build the interference graph! First, we’ll walk through an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">build_graph</samp> that supports the assembly AST from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>. Then, we’ll discuss how to modify it to support the assembly AST from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<p class="TX">Since building this graph is a fairly involved process, we’ll break it down into several steps. <a href="chapter20.xhtml#list20-19">Listing 20-19</a> illustrates these steps in pseudocode.</p>&#13;
<a id="list20-19"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_632" aria-label="632"/>build_graph(instructions):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> interference_graph = base_graph&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> add_pseudoregisters(interference_graph, instructions)&#13;
    cfg = make_control_flow_graph(instructions)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> analyze_liveness(cfg)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> add_edges(cfg, interference_graph)&#13;
    return interference_graph</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-19: Building the interference graph</samp></p>&#13;
<p class="TX">We’ll start with a graph that includes every hard register <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (As far as I know, there’s no standard term for this graph, so I’ll call it the <i>base graph</i>.) Next, we’ll insert a node for each pseudoregister that appears in the function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, we’ll figure out which registers interfere with each other. Since this depends on which registers are live at each point, we’ll need to run liveness analysis on our assembly code. Just like in <span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span>, this analysis will take a control-flow graph (which is different from the interference graph!) and annotate it with liveness information <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, we’ll use that information to figure out which edges to add to the interference graph <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Let’s take a closer look at each of these steps.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3"><span id="sec15"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Base Graph</samp></h5>&#13;
<p class="TNI">The base graph, shown in <a href="#fig20-6">Figure 20-6</a>, includes 12 registers: RAX, RBX, RCX, RDX, RDI, RSI, R8, R9, R12, R13, R14, and R15.</p>&#13;
<figure class="IMG"><img id="fig20-6" class="img70" src="../images/fig20-6.jpg" alt="" width="1037" height="1037"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: The base register interference graph <a href="description-69.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_633" aria-label="633"/>We won’t include RSP or RBP in the graph because we’re already using them to manage the stack frame, and we won’t include R10 or R11 because we’ll need them in the instruction fix-up pass. Since the hard registers all interfere with each other, the base graph includes an edge between each pair of nodes. In graph theory jargon, this makes the base graph a <i>complete graph</i>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Because the example programs in this chapter deal with 4-byte pseudoregisters, most of the diagrams of interference graphs use 4-byte aliases for hard registers. I’ve used 8-byte aliases in <a href="#fig20-6">Figure 20-6</a>, since it represents the base graph you’ll use for all programs rather than the interference graph for any specific program. The interference graphs we actually construct will represent hard registers using reg assembly AST nodes, which don’t specify a size.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3"><span id="sec16"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Pseudoregisters to the Graph</samp></h5>&#13;
<p class="TNI">This bit is straightforward: we just loop over every operand in every instruction and decide whether to add it to the graph. Every pseudoregister that appears in the assembly function should go in the graph, unless it has static storage duration. I’ll skip the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp> because there’s not a lot to it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3"><span id="sec17"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Liveness Analysis</samp></h5>&#13;
<p class="TNI">We already know how liveness analysis works, since we implemented it back in <span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span>. Now we’ll need a new implementation that analyzes assembly instead of TACKY and tracks registers instead of variables. Luckily, the basic logic is the same. We can even reuse some of our existing code.</p>&#13;
<p class="TX">First, we’ll construct a control-flow graph. This works just like building a control-flow graph from a TACKY function; only the specific instructions at the boundaries between basic blocks are different. Instead of looking for TACKY control-flow instructions like <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>, we’ll look for their assembly equivalents: the assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Jmp</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">JmpCC</samp>. You’ve already written code to convert TACKY into a control-flow graph; ideally, you’ll be able to refactor it to handle assembly too.</p>&#13;
<p class="TX">Next, we’ll look at the three components of liveness analysis itself: the iterative algorithm, the meet operator, and the transfer function. The iterative algorithm is exactly the same as in <span class="Xref-1"><a href="chapter19.xhtml">Chapter 19</a></span>, so you should be able to use the implementation of this algorithm that you already wrote.</p>&#13;
<p class="TX">We’ll use set union as our meet operator, just like we did before. However, we’ll handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> node in the control-flow graph differently. Our original meet operator assumed that static variables were live when a function exited. Now we don’t care about static variables, because they’re not in the interference graph. Instead, we have to worry about hard registers: specifically EAX, which holds the function’s return value. <a href="chapter20.xhtml#list20-20">Listing 20-20</a> defines our new meet operator, with the one change from the original meet operator defined in <span class="Xref-1"><a href="chapter19.xhtml#list19-24">Listing 19-24</a></span> in bold.</p>&#13;
<a id="list20-20"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_634" aria-label="634"/>meet(block):&#13;
    live_registers = {}&#13;
    for succ_id in block.successors:&#13;
        match succ_id with&#13;
        | EXIT -&gt; <b>live_registers.add(Reg(AX))</b>&#13;
        | ENTRY -&gt; fail("Malformed control-flow graph")&#13;
        | BlockId(id) -&gt;&#13;
            succ_live_registers = get_block_annotation(succ_id)&#13;
            live_registers.add_all(succ_live_registers)&#13;
&#13;
    return live_registers</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-20: The meet operator for liveness analysis of assembly code</samp></p>&#13;
<p class="TX">We’re ignoring the fact that the callee-saved registers are <i>also</i> live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>. We can get away with this because the instruction fix-up pass will spill these registers if we end up using them; that is, it will save their values onto the stack at the start of the function and restore them before we return. Assuming that these registers are dead at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp> makes it possible to actually use them. If we added them to the set of live registers here, we’d conclude that they were live throughout the whole function and interfered with every single pseudoregister.</p>&#13;
<p class="TX">The transfer function is the one part of liveness analysis that differs significantly from the previous chapter. The basic idea is the same: we add registers to the live set when they’re used and remove them when they’re updated. But the specifics are different because we’re working with a different set of instructions than we were before.</p>&#13;
<p class="TX">First, let’s write a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>, that tells us which operands each instruction uses and updates. Both the transfer function and the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp> function that we’ll implement next will use this helper function. <a href="chapter20.xhtml#list20-21">Listing 20-21</a> gives the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp>.</p>&#13;
<a id="list20-21"/>&#13;
<pre><code>find_used_and_updated(instruction):&#13;
    match instruction with&#13;
    | Mov(src, dst) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        used = [src]&#13;
        updated = [dst]&#13;
    | Binary(op, src, dst) -&gt; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        used = [src, dst]&#13;
        updated = [dst]&#13;
    | Unary(op, dst) -&gt;&#13;
        used = [dst]&#13;
        updated = [dst]&#13;
    | Cmp(v1, v2) -&gt;&#13;
        used = [v1, v2]&#13;
        updated = []&#13;
    | SetCC(cond, dst) -&gt;&#13;
        used = []&#13;
        updated = [dst]&#13;
    | Push(v) -&gt;&#13;
        used = [v]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_635" aria-label="635"/>        updated = []&#13;
    | Idiv(divisor) -&gt;&#13;
        used = [divisor, Reg(AX), Reg(DX)]&#13;
        updated = [Reg(AX), Reg(DX)]&#13;
    | Cdq -&gt;&#13;
        used = [Reg(AX)]&#13;
        updated = [Reg(DX)]&#13;
    | Call(f) -&gt;&#13;
        used =<var> &lt;look up parameter passing registers in the backend symbol table&gt; </var><span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        updated = [Reg(DI), Reg(SI), Reg(DX), Reg(CX), Reg(R8), Reg(R9), Reg(AX)]&#13;
    | _ -&gt;&#13;
        used = []&#13;
        updated = []&#13;
    return (used, updated)</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-21: Identifying the operands used and updated by each instruction</samp></p>&#13;
<p class="TX">Keep in mind that this listing covers only the assembly instructions from <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> is the most straightforward case: it uses its source and updates its destination <span class="CodeAnnotation" aria-label="annotation1">❶</span>. A binary instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">add src, dst</samp> uses its source and destination and updates its destination <span class="CodeAnnotation" aria-label="annotation2">❷</span>. It’s also easy to see which operands the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SetCC</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instructions read and update.</p>&#13;
<p class="TX">Some instructions use registers that they don’t mention explicitly. <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> divides the value stored in the EAX and EDX registers by its source operand, so it uses all three values. It stores its results in EAX and EDX, so it updates those two registers. <samp class="SANS_TheSansMonoCd_W5Regular_11">Cdq</samp> sign extends EAX into EDX, which means it uses EAX and updates EDX.</p>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> uses the registers that hold the callee’s parameters; we can look these up in the backend symbol table, where we recorded them during the assembly generation pass <span class="CodeAnnotation" aria-label="annotation3">❸</span>. It updates all the caller-saved registers—whether we’re passing the callee’s parameters in them or not—since these may be clobbered by the callee. This makes all the caller-saved registers interfere with any pseudoregisters that are live when we call this function, so our graph coloring algorithm will assign these pseudoregisters to callee-saved registers instead.</p>&#13;
<p class="TX">If an instruction both uses and updates the same register—like a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction both uses and updates its destination, for example—it’s important to include that register in both the <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">updated</samp> lists. In the transfer function, we’ll only care that the register is used, since that will make it live. But when we use this helper function again in <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edges</samp>, we’ll only care that the register is updated, since that will make it interfere with any other registers that are live at the same time.</p>&#13;
<p class="TX">Now we can write the transfer function, which is defined in <a href="chapter20.xhtml#list20-22">Listing 20-22</a>.</p>&#13;
<a id="list20-22"/>&#13;
<pre><code>transfer(block, end_live_registers):&#13;
    current_live_registers = end_live_registers&#13;
&#13;
    for instruction in reverse(block.instructions):&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> annotate_instruction(instruction, current_live_registers)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> used, updated = find_used_and_updated(instruction)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_636" aria-label="636"/>        for v in updated:&#13;
            if v is a register:&#13;
                current_live_registers.remove(v)&#13;
&#13;
        for v in used:&#13;
            if v is a register:&#13;
                current_live_registers.add(v)&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> annotate_block(block.id, current_live_registers)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-22: The transfer function for liveness analysis in assembly</samp></p>&#13;
<p class="TX">Since this is a backward analysis, we analyze the assembly instructions in reverse order. To process an instruction, we first record which registers are live immediately after it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we calculate which registers are live just before it. We call the helper function we just wrote to figure out what operands it uses and updates <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We then remove any registers it updates from the set of current live registers, and we add any registers it uses. (If an instruction uses and updates the same register, we’ll remove that register from the set of live registers and then immediately add it again.) Once we’ve processed every instruction, we record which registers are live at the start of the block <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">We won’t track constants and memory operands, but our set of live registers might still include some operands that we don’t care about (specifically, pseudoregisters with static storage duration). There’s no harm in including them in our liveness results; we’ll just ignore them when we use those results in the next step.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3"><span id="sec18"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Edges</samp></h5>&#13;
<p class="TNI">With liveness information in hand, we can finally figure out which edges to add to the graph. <a href="chapter20.xhtml#list20-23">Listing 20-23</a> gives the pseudocode for this step.</p>&#13;
<a id="list20-23"/>&#13;
<pre><code>add_edges(liveness_cfg, interference_graph):&#13;
    for node in liveness_cfg.nodes:&#13;
        if node is EntryNode or ExitNode:&#13;
            continue&#13;
&#13;
        for instr in node.instructions:&#13;
            used, updated = find_used_and_updated(instr)&#13;
&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> live_registers = get_instruction_annotation(instr)&#13;
&#13;
            for l in live_registers:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if (instr is Mov) and (l == instr.src):&#13;
                    continue&#13;
&#13;
                for u in updated:&#13;
                  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if (l and u are in interference_graph) and (l != u):&#13;
                        add_edge(interference_graph, l, u)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-23: Adding edges to the interference graph</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_637" aria-label="637"/>We learned earlier that two registers interfere if one is updated while the other is live. Now we’ll look at each instruction and figure out which interferences it creates. To process a single instruction, we’ll first call <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp> to look up what operands it updates. (We’ll ignore the first list this function returns, <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>, because don’t care what operands the instruction uses.) Next, we’ll look up which registers are live immediately after the instruction <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">We then add an edge between each register in <samp class="SANS_TheSansMonoCd_W5Regular_11">live_registers</samp> and each register in <samp class="SANS_TheSansMonoCd_W5Regular_11">updated</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction is a special case. If the current instruction is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>, we’ll skip over its source as we iterate over the set of live registers so that we don’t add an edge between its source and destination <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Before we add an edge between two nodes, we’ll make sure that both nodes are already in the interference graph. We’ll also make sure that they’re different, since we don’t want to add an edge from a node to itself <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3"><span id="sec19"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Handling Other Types While Constructing the Graph</samp></h5>&#13;
<p class="TNI">Now we’ll deal with all the features we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. Since we allocate XMM and general-purpose registers separately, we’ll build two interference graphs. We’ll start with a separate base graph for each register class. The base graph for XMM registers should have 14 nodes; it will include XMM0 through XMM13, but not the scratch registers XMM14 and XMM15. In <samp class="SANS_TheSansMonoCd_W5Regular_11">add_pseudoregisters</samp>, we’ll check that a pseudoregister has the correct type before adding it to the graph. When we allocate XMM registers, we’ll add only pseudoregisters of <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> type to the graph. When we allocate general-purpose registers, we’ll exclude <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> pseudoregisters and include all the other scalar types: <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Byte</samp>.</p>&#13;
<p class="TX">Floating-point registers aside, there are a few other details we need to change. We’ll exclude aliased pseudoregisters from the graph, since they shouldn’t be assigned to registers. You can reuse the previous chapter’s address-taken analysis here; just rerun the analysis immediately before converting the program from TACKY to assembly. If a variable was aliased in the TACKY program, it will still be aliased in assembly.</p>&#13;
<p class="TX">Liveness analysis should reflect the new calling conventions we implemented in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">meet</samp> function can’t assume that EAX is live when the function exits; it should check the backend symbol table to learn which registers the function uses to pass its return value. These registers will all be live at <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT</samp>.</p>&#13;
<p class="TX">We’ll also update the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp> helper function. First, this function needs to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">Memory</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Indexed</samp> operands correctly. These operands designate locations in memory, but they use registers in their address calculations. When we use one of these operands, we <i>read</i> any registers it refers to, even if we <i>write</i> to the memory location it designates. For example, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, 4(%rax)</samp> uses RAX instead of updating it, and the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">leaq (%rax, %rcx, 4), %rdi</samp> uses both RAX and RCX but updates RDI. Second, <samp class="SANS_TheSansMonoCd_W5Regular_11">find_used_and_updated</samp> must recognize that all the XMM registers are caller-saved and therefore updated by <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> instructions. Finally, this function will need to handle all the new assembly instructions we added in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, but there’s nothing particularly tricky about them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_638" aria-label="638"/>&#13;
<h4 class="H2"><span id="sec20"/><span id="h2-234"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating Spill Costs</samp></h4>&#13;
<p class="TNI">After constructing the graph, we annotate each register with a spill cost. If we can’t color every node in the graph, these costs will help us decide which node (or nodes) to spill. We’ll try to color the graph in a way that minimizes the total cost of all spilled nodes.</p>&#13;
<p class="TX">Since we can’t spill hard registers, we assign each of them an infinite spill cost. To estimate the spill cost of each pseudoregister, we just count up the number of times it appears in our assembly code. For example, if we encounter the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $1, %x</samp>, we increase <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s spill cost by one. If we see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">addl %x, %x</samp>, we increase <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s spill cost by two. The rationale here is that the more often a pseudoregister is used, the more memory accesses and new instructions we’ll introduce if we spill it.</p>&#13;
<p class="TX">Frankly, this is a lousy way to calculate spill cost. It ignores the basic fact that some instructions are executed more frequently than others. Clearly, using a pseudoregister inside a loop that executes a million times should increase its spill cost a lot more than using it in an instruction that runs just once. It’s hard to predict exactly how many times a particular instruction will execute, but one approach is to use loop nesting depth as a rough proxy for execution frequency. When compilers that take this approach calculate spill costs, they give more weight to instructions in more deeply nested loops.</p>&#13;
<p class="TX">Unfortunately, we have no idea where the loops in our program are. Discovering loops would require us to implement a whole new type of analysis, and this chapter is long enough. I’ve included a couple of references about identifying loops in <span class="Xref">“Additional Resources” on <a href="#pg_669">page 669</a></span> in case you want to implement this analysis on your own.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2"><span id="sec21"/><span id="h2-235"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coloring the Interference Graph</samp></h4>&#13;
<p class="TNI">It’s time to color the graph! Our goal is to minimize the total spill cost of the nodes we leave uncolored (ideally by coloring every node so that the total spill cost is zero). But exact graph coloring algorithms, which find the best possible coloring, are too slow to use in practice. Instead, we’ll use an approximate algorithm. This algorithm may not find the best coloring, but it can usually find a pretty good one.</p>&#13;
<p class="TX">Our graph coloring algorithm is based on a simple observation: you can always color a node with fewer than <i>k</i> neighbors, because there’s always at least one color that none of its neighbors uses. This observation is called the <i>degree &lt;</i> k <i>rule</i>. (The number of neighbors a node has is called its <i>degree</i>; we say that a node has <i>significant degree</i> if it has <i>k</i> or more neighbors.) The degree &lt; <i>k</i> rule gives us a way to break down the problem. First, we’ll temporarily remove any node with fewer than <i>k</i> neighbors. This is called <i>pruning</i> the graph. Then, we’ll color the rest of the graph somehow (we won’t worry about how to do this just yet). Finally, we’ll put back the nodes that we pruned, one at a time. When we put back a node, we’ll assign it some color that doesn’t conflict with any neighbors that we’ve already colored. There will always be at least one available color, since each node has fewer than <i>k</i> neighbors.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_639" aria-label="639"/>Let’s try to 3-color the graph shown in <a href="#fig20-7">Figure 20-7</a> using this approach and see how far we get.</p>&#13;
<figure class="IMG"><img id="fig20-7" class="img60" src="../images/fig20-7.jpg" alt="" width="814" height="792"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: A graph that hasn’t been colored yet <a href="description-70.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This graph has four nodes with fewer than three neighbors: <i>B</i>, <i>C</i>, <i>F</i>, and <i>H</i>. We’ll prune these nodes from the graph and then figure out how to color the smaller graph. We’ll also define a stack to keep track of the pruned nodes that we’ll eventually need to put back in the graph. <a href="#fig20-8">Figure 20-8</a> shows the pruned graph and the stack.</p>&#13;
<figure class="IMG"><img id="fig20-8" class="img80" src="../images/fig20-8.jpg" alt="" width="1044" height="796"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The graph from <a href="#fig20-7">Figure 20-7</a> with low-degree nodes removed <a href="description-71.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this pruned graph, <i>A</i> and <i>G</i> both have fewer than three neighbors. That means we can apply the same trick to prune the graph again! We’ll <span role="doc-pagebreak" epub:type="pagebreak" id="pg_640" aria-label="640"/>push <i>A</i> and <i>G</i> onto the top of the stack; later on, we’ll pop them off and color them before we color <i>B</i>, <i>C</i>, <i>F</i>, and <i>H</i>. When we pop <i>A</i> and <i>G</i> off the stack and put them back in the graph, they’ll have the same degree they do now, so we know we’ll be able to find a color for each of them.</p>&#13;
<p class="TX"><a href="#fig20-9">Figure 20-9</a> shows how the graph and stack look after we prune <i>A</i> and <i>G</i>.</p>&#13;
<figure class="IMG"><img id="fig20-9" class="img80" src="../images/fig20-9.jpg" alt="" width="1049" height="806"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: The graph from <a href="#fig20-7">Figure 20-7</a> after two rounds of pruning <a href="description-72.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Our two remaining nodes each have fewer than three neighbors, so we could just color them. But we’ll take a slightly different approach to accomplish the same thing: we’ll prune them from the graph, then put them back. After we prune them, the graph is empty. <a href="#fig20-10">Figure 20-10</a> shows how things look after we’ve pruned every node.</p>&#13;
<figure class="IMG"><img id="fig20-10" class="img80" src="../images/fig20-10.jpg" alt="" width="1052" height="811"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: The graph from <a href="#fig20-7">Figure 20-7</a> after pruning every node <a href="description-73.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_641" aria-label="641"/>Our original plan was to prune the graph, color the remaining nodes, then put back the nodes we had pruned. Now that we’re done pruning, we don’t have to do anything for the second step: there are no nodes left to color! We won’t get this lucky with every graph; sometimes we’ll end up with nodes we can’t prune. We’ll talk about how to handle that situation in a moment. For now, let’s finish coloring this graph.</p>&#13;
<p class="TX">As the last step in our plan, we’ll take each of the nodes we pruned earlier, assign it a color, and put it back in the graph. We’ll start with the last node we removed, which is at the top of the stack, then repeat this process until the stack is empty. The sequence of diagrams in <a href="#fig20-11">Figure 20-11</a> illustrates how we’ll rebuild the graph in this example.</p>&#13;
<figure class="IMG"><img class="img100" id="fig20-11" src="../images/fig20-11.jpg" alt="" width="1688" height="1204"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-11: Adding nodes back to the graph and assigning colors <a href="description-74.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When we add <i>E</i> back to the graph, it has no neighbors, so we can assign it any color. Let’s color it white. Then, when we add <i>D</i>, its only neighbor is <i>E</i>, so we can assign it either black or gray. When we add <i>G</i>, we find that it has a white neighbor and a gray neighbor, so we must color it black. We continue until the stack is empty and every node in the graph has been assigned a color.</p>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_642" aria-label="642"/>&#13;
<h5 class="H3"><span id="sec22"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Spills</samp></h5>&#13;
<p class="TNI">For many interference graphs, we can prune every node using the approach we took in the previous section. We can color those graphs without any spills. But there are other graphs where we’ll get stuck: we’ll hit a point where every node has <i>k</i> or more neighbors. Suppose we want to 3-color the graph shown in <a href="#fig20-12">Figure 20-12</a>.</p>&#13;
<figure class="IMG"><img class="img40" id="fig20-12" src="../images/fig20-12.jpg" alt="" width="599" height="843"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-12: A graph where every node has three or more neighbors <a href="description-75.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If we try to prune this graph, we’ll immediately get stuck: every node has at least three neighbors! To get unstuck, we’ll choose a node to prune anyway. We’ll put this node on the stack, then continue with the algorithm as usual. This node is a <i>spill candidate</i> because we might not be able to color it when we put it back in the graph. If we’re lucky, its neighbors won’t use up every color, so we’ll be able to color it. If we’re unlucky, its neighbors will use all <i>k</i> colors, so we’ll have to spill it.</p>&#13;
<p class="TX">We want to choose a spill candidate with a low spill cost. But we also want to choose a spill candidate with lots of neighbors that haven’t been pruned yet, because pruning our spill candidate lowers its neighbors’ degrees and helps us avoid spilling them later on. To balance these two priorities, we’ll choose the node with the smallest value of <i>spill cost / degree</i>, where degree is the number of neighbors that haven’t been pruned yet.</p>&#13;
<p class="TX">Note that we’ll never choose a hard register as a spill candidate, because <i>spill cost / degree</i> for each of these registers is always infinity. If there are any pseudoregisters left in the graph, we’ll always choose one of them as a spill candidate instead of choosing a hard register. If there are no pseudoregisters left, the total number of registers must be <i>k</i> or fewer, so we’ll be able to prune every register.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_643" aria-label="643"/>Some graphs have no valid <i>k</i>-colorings, which makes spilling unavoidable. For other graphs, a valid coloring exists, but whether we find it is a matter of chance; it depends on the exact order in which we remove nodes from the graph and how we happen to color them when we put them back.</p>&#13;
<p class="TX">To illustrate the element of chance in this approach, we’ll make a couple of attempts to color the graph in <a href="#fig20-12">Figure 20-12</a>. This graph is 3-colorable, but only one of our attempts will find a spill-free coloring. In both cases, we’ll choose <i>C</i> as our spill candidate, then prune <i>A</i> and <i>B</i>, leaving <i>D</i>, <i>E</i>, and <i>F</i>. And in both cases, we’ll use the same strategy to color nodes as we add them back into the graph: we’ll choose the first available color from the list <i>[white, gray, black]</i>. The only difference will be the order in which we prune the remaining three nodes. In the first case, we’ll prune <i>D</i>, then <i>E</i>, then <i>F</i>. <a href="#fig20-13">Figure 20-13</a> shows what will happen when we try to add the nodes back in.</p>&#13;
<figure class="IMG"><img class="img100" id="fig20-13" src="../images/fig20-13.jpg" alt="" width="1388" height="843"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-13: A first attempt to color <a href="#fig20-12">Figure 20-12</a> <a href="description-76.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When we reach <i>C</i>, we’ll see that its neighbors are already using all three colors, so we’ll be forced to spill it.</p>&#13;
<p class="TX">Now let’s repeat this process; on this attempt, we’ll prune <i>F</i>, then <i>E</i>, then <i>D</i>. <a href="#fig20-14">Figure 20-14</a> shows what will happen when we put the nodes back in the graph this time around.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_644" aria-label="644"/>&#13;
<figure class="IMG"><img class="img100" id="fig20-14" src="../images/fig20-14.jpg" alt="" width="1648" height="742"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-14: A more successful attempt to color <a href="#fig20-12">Figure 20-12</a> <a href="description-77.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This time, we assigned <i>A</i> and <i>E</i> the same color, which allowed us to assign <i>C</i> a color instead of spilling it. In a small example like this one, it’s easy to see that assigning these nodes the same color is the better choice. But there’s no general rule that lets us avoid unnecessary spills like the one in <a href="#fig20-13">Figure 20-13</a>; that’s what makes this algorithm approximate. We <i>could</i> avoid unnecessary spills if we used an exact algorithm instead, but as I mentioned earlier, exact algorithms are too expensive to be practical.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3"><span id="sec23"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the Graph Coloring Algorithm</samp></h5>&#13;
<p class="TNI">Now that we’ve worked through a few examples using this algorithm, let’s look at the pseudocode, which is shown in <a href="chapter20.xhtml#list20-24">Listing 20-24</a>.</p>&#13;
<a id="list20-24"/>&#13;
<pre><code>color_graph(g):&#13;
    remaining = <var>&lt;unpruned nodes in g&gt;</var>&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if remaining is empty:&#13;
        return&#13;
&#13;
    // choose next node to prune&#13;
    chosen_node = null&#13;
&#13;
    for node in remaining:&#13;
        degree = length(<var>&lt;unpruned neighbors of node&gt;</var>)&#13;
        if degree &lt; k:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> chosen_node = node&#13;
            break&#13;
&#13;
    if chosen_node is null:&#13;
        // choose a spill candidate&#13;
        best_spill_metric = infinity&#13;
        for node in remaining:&#13;
            degree = length(<var>&lt;unpruned neighbors of node&gt;</var>)&#13;
            spill_metric = node.spill_cost / degree&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_645" aria-label="645"/>            if spill_metric &lt; best_spill_metric:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> chosen_node = node&#13;
                best_spill_metric = spill_metric&#13;
&#13;
    chosen_node.pruned = True&#13;
&#13;
    // color the rest of the graph&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> color_graph(g)&#13;
&#13;
    // color this node&#13;
    colors = [1, 2, . . ., k]&#13;
    for neighbor_id in chosen_node.neighbors:&#13;
        neighbor = get_node_by_id(g, neighbor_id)&#13;
        if neighbor.color is not null:&#13;
            colors.remove(neighbor.color)&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> if colors is not empty:&#13;
        if chosen_node is a callee-saved hard register:&#13;
            chosen_node.color = max(colors)&#13;
        else:&#13;
            chosen_node.color = min(colors)&#13;
        chosen_node.pruned = False&#13;
&#13;
    return</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-24: The graph coloring algorithm</samp></p>&#13;
<p class="TX">We’ll color the graph recursively. At each step, we’ll prune a node, then make a recursive call to color the rest of the graph, then put the node back and assign it a color. In the base case, we’ve already pruned every node, so we have nothing left to do <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">In the recursive case, we’ll start by choosing a node to prune, which this listing calls <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>. We’ll pick the first node we find with fewer than <i>k</i> unpruned neighbors <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (If you’re allocating general-purpose registers, <i>k</i> is 12; if you’re allocating XMM registers, it’s 14.) If that search comes up empty, we’ll pick the node with the minimum value of <i>spill cost / degree</i> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. To prune a node, we’ll just set its <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Then, we’ll call <samp class="SANS_TheSansMonoCd_W5Regular_11">color_graph</samp> recursively to color the remaining nodes in the graph <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">After we return from this recursive call, we’ll try to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp> a color. We’ll take the list of integers <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">k</samp>, which represent every possible color, and remove any color that we’ve already assigned to one of <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp>’s neighbors. Some of <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>’s neighbors may not have a color, either because we spilled them or because we pruned them before <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp> and will therefore color them later. We can simply ignore these nodes.</p>&#13;
<p class="TX">If there are any colors left in the list, we’ll assign one of them to <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen _node</samp> <span class="CodeAnnotation" aria-label="annotation5">❺</span>. If there’s more than one color available, the algorithm isn’t fussy about which one we choose. Although the color we choose here might impact how many nodes we ultimately spill, the effect is unpredictable; there’s no color selection strategy that minimizes spills across the board. So, we’ll choose a color with a different goal in mind: assigning pseudoregisters to caller-saved rather than callee-saved hard registers. (We’d like to use as few callee-saved registers as possible, to avoid the cost of saving and restoring <span role="doc-pagebreak" epub:type="pagebreak" id="pg_646" aria-label="646"/>them.) When <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp> represents a callee-saved hard register, we’ll assign it the available color with the highest number. Otherwise, we assign it the lowest-numbered available color. Using this strategy, the coloring algorithm will tend to assign higher-numbered colors to callee-saved registers and lower-numbered colors to caller-saved registers and pseudoregisters. A pseudoregister will end up with a higher-numbered color only when there are no lower-numbered colors available (for example, because it conflicts with every caller-saved register). Once we’ve picked a color, we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute back to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. This isn’t strictly necessary, because we won’t use this attribute again, but it marks that we’ve put the node back in the graph.</p>&#13;
<p class="TX">If there are no colors left in the list, we’ll have to spill <samp class="SANS_TheSansMonoCd_W5Regular_11">chosen_node</samp>. Concretely, this just means we won’t assign it a color. We also won’t update its <samp class="SANS_TheSansMonoCd_W5Regular_11">pruned</samp> attribute, since we aren’t putting this node back in the graph. Note that we don’t explicitly push nodes onto a stack or pop them off afterward. Our recursive algorithm naturally colors nodes in the correct order, starting with the last node we pruned.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2"><span id="sec24"/><span id="h2-236"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Register Map and Rewriting the Function Body</samp></h4>&#13;
<p class="TNI">Once we’ve colored the graph, the rest of the register allocator is pretty simple. We’ll build a map from pseudoregisters to hard registers, which we’ll use to replace the pseudoregisters in our assembly code. As we build this map, we’ll also keep track of which callee-saved registers we’ve allocated so that we can save and restore them in the instruction fix-up pass. <a href="chapter20.xhtml#list20-25">Listing 20-25</a> demonstrates how to construct the map.</p>&#13;
<a id="list20-25"/>&#13;
<pre><code>create_register_map(colored_graph):&#13;
&#13;
    // build map from colors to hard registers&#13;
    color_map = <var>&lt;empty map&gt;</var>&#13;
    for node in colored_graph.nodes:&#13;
        match node.id with&#13;
        | Reg(r) -&gt;&#13;
            color_map.add(node.color, r)&#13;
        | Pseudo(p) -&gt; continue&#13;
&#13;
    // build map from pseudoregisters to hard registers&#13;
    register_map = <var>&lt;empty map&gt;</var>&#13;
    callee_saved_regs = {}&#13;
    for node in colored_graph.nodes:&#13;
        match node.id with&#13;
        | Pseudo(p) -&gt;&#13;
            if node.color is not null:&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> hardreg = color_map.get(node.color)&#13;
                register_map.add(p, hardreg)&#13;
                if hardreg is callee saved:&#13;
                  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> callee_saved_regs.add(hardreg)&#13;
        | Reg(r) -&gt; continue&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_647" aria-label="647"/>  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> record_callee_saved_regs(<var>&lt;current function name&gt;</var>, callee_saved_regs)&#13;
&#13;
    return register_map</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-25: Building a map from pseudoregisters to hard registers</samp></p>&#13;
<p class="TX">First, we’ll iterate through the hard registers in the graph, building up a map from colors to hard registers. Remember that we’ll have a 1:1 mapping between colors and hard registers because each of the <i>k</i> hard registers must be assigned a different one of the <i>k</i> possible colors. Next, we’ll iterate through all the pseudoregisters. If a pseudoregister was assigned a color, we’ll map it to the hard register with the same color, which we can find in <samp class="SANS_TheSansMonoCd_W5Regular_11">color_map</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If a pseudoregister wasn’t assigned a color, we won’t add it to the map.</p>&#13;
<p class="TX">As we build up <samp class="SANS_TheSansMonoCd_W5Regular_11">register_map</samp>, we also track the set of callee-saved registers this function will use. Whenever we add a mapping from a pseudoregister to a callee-saved hard register, we’ll add the hard register to this set <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We’ll record each function’s <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_regs</samp> set so that we can pass that information on to the instruction fix-up phase <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (This listing doesn’t specify <i>where</i> to record that information; you can add it to the function definition itself, the backend symbol table, or some other data structure, depending on what’s most convenient.) We can skip this step when we allocate XMM registers, because none of the XMM registers are callee-saved.</p>&#13;
<p class="TX">Finally, we’ll rewrite the assembly code. We’ll replace each pseudoregister in each instruction with the corresponding hard register from the register map. If a pseudoregister is missing from the map, we won’t replace it. While we’re at it, we’ll remove any <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction whose source and destination ended up in the same hard register. For instance, if we’ve mapped both <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> to EAX, we can rewrite</p>&#13;
<pre><code>my_fun:&#13;
    movl    %edi, %tmp1&#13;
    addl    $5, %tmp1&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> movl    %tmp1, %tmp2&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> movl    %tmp2, %eax&#13;
    ret</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>my_fun:&#13;
    movl    %edi, %eax&#13;
    addl    $5, %eax&#13;
    ret</code></pre>&#13;
<p class="TX">Both <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation2">❷</span> would be rewritten as <samp class="SANS_TheSansMonoCd_W5Regular_11">movl %eax, %eax</samp>, which doesn’t do anything, so we can drop them both from the final assembly program.</p>&#13;
<p class="TX">This bit of cleanup where we delete unnecessary <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions is related to register coalescing, which we’ll implement later in this chapter. But there are some important differences. The register coalescing step will deliberately merge together registers connected by a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, like <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_648" aria-label="648"/>then delete the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions between them. This whole process will happen before we color the rest of the graph. What we’re doing here is much simpler; we’re not trying to merge registers, but if we happen to assign both operands of a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction the same color, we’ll take advantage of it.</p>&#13;
<p class="TX">Even once we implement register coalescing, this post-coloring cleanup will still be useful. As we’ll see, the register coalescing pass isn’t perfect; sometimes it will miss a pair of registers that it would have been helpful to coalesce. If we get lucky and assign that pair of registers the same color, this final step will still be able to delete <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions between them.</p>&#13;
<p class="TX">At this point, we have a working register allocator! We just need to update the instruction fix-up and code emission passes before we test it out.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1"><span id="sec25"/><span id="h1-189"/><samp class="SANS_Futura_Std_Bold_B_11">Instruction Fix-Up with Callee-Saved Registers</samp></h3>&#13;
<p class="TNI">If a function uses any callee-saved registers, we need to save their values at the start of the function and restore them at the end. We’ll save them by pushing them onto the stack on top of the rest of the current stack frame. For example, if a function needs 16 bytes of stack space for local variables and uses R12 and R13, we’ll insert the following three instructions at the very beginning of the function body:</p>&#13;
<pre><code>Binary(Sub, Quadword, Imm(16), Reg(SP))&#13;
Push(Reg(R12))&#13;
Push(Reg(R13))</code></pre>&#13;
<p class="TX">The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp> instruction allocates the current stack frame, just like in earlier chapters. The new <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instructions come immediately after it. (If you skipped <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, the first instruction will be <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Sub</samp>.)</p>&#13;
<p class="TX">Before we return, we’ll restore the values of these registers by popping them off the stack. That is, we’ll rewrite each <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> instruction in this function as:</p>&#13;
<pre><code>Pop(R13)&#13;
Pop(R12)&#13;
Ret</code></pre>&#13;
<p class="TX">We can push callee-saved registers onto the stack in any order, but we’ll always need to pop them back off in the reverse order so that each register ends up with its original value. Since we add the rest of the function epilogue during code emission, we’ll end up deallocating the stack frame just after restoring the callee-saved registers:</p>&#13;
<pre><code>popq    %r13&#13;
popq    %r12&#13;
movq    %rbp, %rsp&#13;
popq    %rbp&#13;
ret</code></pre>&#13;
<p class="TX">We also need to ensure that the entire stack frame, including the values of any callee-saved registers that we save to the stack, is 16-byte aligned. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_649" aria-label="649"/>Suppose the pseudo-operand replacement pass has allocated 20 bytes of stack space to store local variables in a particular function. We’d normally subtract 32 bytes from RSP to maintain the proper stack alignment. But if the function uses a single callee-saved register, we should initially subtract 24 bytes instead:</p>&#13;
<pre><code>Binary(Sub, Quadword, Imm(24), Reg(SP))&#13;
Push(Reg(BX))</code></pre>&#13;
<p class="TX">If we subtract 24 bytes from RSP explicitly and subtract another 8 bytes by pushing RBX, we still end up subtracting a total of 32 bytes, so the stack will be properly aligned. <a href="chapter20.xhtml#list20-26">Listing 20-26</a> demonstrates one way to perform this tricky calculation.</p>&#13;
<a id="list20-26"/>&#13;
<pre><code>calculate_stack_adjustment(bytes_for_locals, callee_saved_count):&#13;
    callee_saved_bytes = 8 * callee_saved_count&#13;
    total_stack_bytes = callee_saved_bytes + bytes_for_locals&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> adjusted_stack_bytes = round_up(total_stack_bytes, 16)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> stack_adjustment = adjusted_stack_bytes - callee_saved_bytes&#13;
    return stack_adjustment</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-26: The stack space calculation that accounts for callee-saved registers</samp></p>&#13;
<p class="TX">In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp> is the number of bytes of stack space we allocated during pseudo-operand replacement, and <samp class="SANS_TheSansMonoCd_W5Regular_11">callee_saved_count</samp> is the number of callee-saved registers the function uses. We start by calculating how many bytes the callee-saved values will occupy. Then, we add this to <samp class="SANS_TheSansMonoCd_W5Regular_11">bytes_for_locals</samp> and round up to the nearest multiple of 16 to get the total size of the stack frame <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Working backward from this value, we subtract the number of bytes the callee-saved values will occupy to find the number of bytes we need to explicitly subtract from RSP <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1"><span id="sec26"/><span id="h1-190"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">Finally, we’ll update the code emission pass to handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction and all the new registers we added in this chapter. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> will always use the 8-byte names for registers. <a href="chapter20.xhtml#tab20-4">Tables 20-4</a> and <a href="chapter20.xhtml#tab20-5">20-5</a> describe how to print out these constructs. (I haven’t bolded new and changed constructs like I did in most code emission tables in earlier chapters, because all of these constructs are new.) For a summary of the complete code emission pass at the end of this chapter, see <span class="Xref-1"><a href="appendix-B.xhtml">Appendix B</a></span>, which includes two sets of code emission tables for <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>: one with the features from <span class="Xref-1"><a href="part2.xhtml">Part II</a></span> and one without them.</p>&#13;
<p class="TT" id="tab20-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 20-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Pop(reg)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">popq</samp>  <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;reg&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab20-5"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_650" aria-label="650"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 20-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF graybg" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(BX)</samp></p></td>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBFL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%rbx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%ebx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%bl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R12)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r12</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r12d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r12b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R13)</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r13</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r13d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r13b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R14)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r14</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r14d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r14b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg" rowspan="3"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R15)</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r15</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r15d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r15b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM8)</samp></p></td>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%xmm8</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM9)</samp></p></td>&#13;
<td class="Basic-Table TB graybg"/>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%xmm9</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM10)</samp></p></td>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%xmm10</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM11)</samp></p></td>&#13;
<td class="Basic-Table TB graybg"/>&#13;
<td class="Basic-Table TB graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%xmm11</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM12)</samp></p></td>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%xmm12</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(XMM13)</samp></p></td>&#13;
<td class="Basic-Table TBL graybg"/>&#13;
<td class="Basic-Table TBL graybg"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%xmm13</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Now you’re ready to try out your register allocator on some real programs!</p>&#13;
<aside class="box" aria-label="box-79"><p class="BoxTitle" id="box-79"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE BASIC REGISTER ALLOCATOR</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you completed only Part I, test out your register allocator with the following command:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 20 --no-coalescing</b>&#13;
<b>--int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This will run all the test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_20/int_only</samp><samp class="SANS_Futura_Std_Book_11">, all the tests from Part I, and all the Part I–specific tests from <a href="chapter19.xhtml">Chapter 19</a>. It will also inspect</samp> <samp class="SANS_Futura_Std_Book_11">the assembly output for the test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_20/int_only/no _coalescing</samp> <samp class="SANS_Futura_Std_Book_11">to make sure that your compiler doesn’t spill registers unnecessarily.</samp></p>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_651" aria-label="651"/><samp class="SANS_Futura_Std_Book_11">If you completed Parts I and II, run the same command without the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--int-only</samp> <samp class="SANS_Futura_Std_Book_11">option:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 20 --no-coalescing</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">There are a couple of things you should know about this chapter’s tests. First, many of them are designed to produce specific interference graphs or use every hard register. If your compiler generates different assembly code or includes extra optimizations beyond what this book covers, these tests may not cover the edge cases they’re intended to target, so you should write your own unit tests too.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Second, if your code to recognize interference is buggy, the test suite might not catch those bugs until you implement register coalescing. Several tests include pairs of registers that could be coalesced, except that they interfere in some specific way. Once you’ve implemented coalescing, your allocator must recognize that they interfere to avoid coalescing them. Without coalescing, the test suite can’t reliably detect this sort of bug; even if your allocator doesn’t know that two registers interfere, it might still get lucky and assign them different colors. To thoroughly test your register allocator before you move on to coalescing, you might want to write your own unit tests for the code that builds the interference graph.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Third, the test commands in this chapter always compile test programs with the optimizations from <a href="chapter19.xhtml">Chapter 19</a> enabled. This doesn’t have any particular</samp> <samp class="SANS_Futura_Std_Book_11">implications; it’s just something to be aware of while you’re debugging your tests.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h3 class="H1"><span id="sec27"/><span id="h1-191"/><samp class="SANS_Futura_Std_Bold_B_11">Register Coalescing</samp></h3>&#13;
<p class="TNI">Our register allocator already works correctly. But as we saw in the example at the start of the chapter, it will produce even more efficient code if we include a coalescing step. That early example also gave us a general sense of how this process works: we look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction that copies a value from one register to another and decide whether to coalesce its source and destination. Once we’ve made these decisions, we rewrite the assembly code, replacing the registers we coalesced and deleting any <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions that we no longer need.</p>&#13;
<p class="TX">To decide which registers to coalesce, we’ll consult the interference graph. We’ll coalesce a pair of registers when two conditions are met. The first condition is obvious: the registers can’t interfere with each other. The example from <a href="chapter20.xhtml#list20-13">Listing 20-13</a>, reproduced here, illustrates why this condition is necessary:</p>&#13;
<pre><code>movl    $1, %y&#13;
movl    %y, %x&#13;
addl    $1, %y&#13;
addl    %x, %y</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_652" aria-label="652"/>Since we update <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> while <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is live, these two registers interfere. If we coalesced them, the first <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instruction would clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, and we’d end up calculating 2 + 2 instead of 1 + 2.</p>&#13;
<p class="TX">The second condition is subtler: we’ll coalesce a pair of registers only if that won’t force us to spill more registers. To understand why coalescing can lead to spills, let’s look at <a href="chapter20.xhtml#list20-27">Listing 20-27</a>.</p>&#13;
<a id="list20-27"/>&#13;
<pre><code>f:&#13;
    movl    %edi, %arg&#13;
    movl    %arg, %tmp&#13;
    addl    $1, %tmp&#13;
    imull   %arg, %tmp&#13;
    movl    $10, %eax&#13;
    subl    %tmp, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-27: An assembly function where coalescing would cause a spill</samp></p>&#13;
<p class="TX">This assembly function calculates <samp class="SANS_TheSansMonoCd_W5Regular_11">10 - (arg</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1) * arg</samp>. For this example, we’ll pretend that EDI and EAX are the only available hard registers, so <i>k</i> is 2. <a href="#fig20-15">Figure 20-15</a> shows this listing’s interference graph, which is clearly 2-colorable.</p>&#13;
<figure class="IMG"><img class="img40" id="fig20-15" src="../images/fig20-15.jpg" alt="" width="452" height="452"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-15: The interference graph for <a href="chapter20.xhtml#list20-27">Listing 20-27</a> <a href="description-78.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in <a href="chapter20.xhtml#list20-27">Listing 20-27</a> looks like a possible candidate for coalescing. (The second instruction isn’t, since <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> interfere.) But if we try to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into EDI, we’ll run into trouble. We’ll end up with the assembly code in <a href="chapter20.xhtml#list20-28">Listing 20-28</a>.</p>&#13;
<a id="list20-28"/>&#13;
<pre><code>f:&#13;
    movl    %edi, %tmp&#13;
    addl    $1, %tmp&#13;
    imull   %edi, %tmp&#13;
    movl    $10, %eax&#13;
    subl    %tmp, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-28: <a href="chapter20.xhtml#list20-27">Listing 20-27</a> after coalescing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arg</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">into EDI</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_653" aria-label="653"/><a href="#fig20-16">Figure 20-16</a> shows the interference graph for this coalesced code.</p>&#13;
<figure class="IMG"><img class="img40" id="fig20-16" src="../images/fig20-16.jpg" alt="" width="451" height="452"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-16: The interference graph for <a href="chapter20.xhtml#list20-28">Listing 20-28</a> <a href="description-79.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now we can’t 2-color the graph anymore. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> interferes with both hard registers, we’ll have to spill it. Instead of improving performance, we’ve made it worse! The cost of spilling <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> to memory outweighs the benefit of removing a single <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction. To avoid this situation, we’ll use a strategy called <i>conservative coalescing</i>: we’ll coalesce two registers only when we can tell in advance that it won’t make the interference graph harder to color. But before we dig into conservative coalescing, we need to learn how to keep the graph up to date.</p>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2"><span id="sec28"/><span id="h2-237"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Interference Graph</samp></h4>&#13;
<p class="TNI">Whenever we decide to coalesce a pair of registers, we need to update the interference graph. Otherwise, we’ll make later coalescing decisions based on bad information. There are two ways to perform this update. The first is to rewrite the assembly code immediately and rebuild the graph from scratch. The problem with this approach is that building the interference graph is slow. We might coalesce dozens or even hundreds of <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions in a single function, but we can’t afford to rebuild the interference graph hundreds of times.</p>&#13;
<p class="TX">A much quicker approach is to merge the two nodes together in the existing interference graph, without referring back to the assembly code. In <a href="#fig20-17">Figure 20-17</a>, we use this approach to coalesce the pseudoregister <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EAX.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_654" aria-label="654"/>&#13;
<figure class="IMG"><img class="img80" id="fig20-17" src="../images/fig20-17.jpg" alt="" width="1094" height="875"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-17: Updating the interference graph to reflect coalescing decisions <a href="description-80.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We’ll assume that any register that originally interfered with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> now interferes with EAX. To make the interference graph reflect this change, we just add an edge from each of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>’s neighbors to EAX and then remove <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>.</p>&#13;
<p class="TX">But this way of updating the graph has a problem too: it’s not always accurate! It might include some extra edges between registers that don’t really interfere. <a href="chapter20.xhtml#list20-29">Listing 20-29</a> gives a slightly contrived example.</p>&#13;
<a id="list20-29"/>&#13;
<pre><code>f:&#13;
    movl    %edi, %tmp1&#13;
    movl    %edi, %tmp2&#13;
    addl    %tmp1, %tmp2&#13;
    movl    %tmp2, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-29: A function that copies its first argument into two different pseudoregisters</samp></p>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> interfere: the second <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction updates <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> while <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> is still live. Let’s try to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into EDI and use our speedy, simple method to update the graph accordingly. <a href="#fig20-18">Figure 20-18</a> shows how the graph will change.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_655" aria-label="655"/>&#13;
<figure class="IMG"><img class="img70" id="fig20-18" src="../images/fig20-18.jpg" alt="" width="891" height="868"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-18: Updating the interference graph for <a href="chapter20.xhtml#list20-29">Listing 20-29</a> <a href="description-81.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">But when we actually replace <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> with EDI, we’ll find that the interference with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> goes away! <a href="chapter20.xhtml#list20-30">Listing 20-30</a> shows the updated assembly code.</p>&#13;
<a id="list20-30"/>&#13;
<pre><code>f:&#13;
    movl    %edi, %tmp2&#13;
    addl    %edi, %tmp2&#13;
    movl    %tmp2, %eax&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-30: <a href="chapter20.xhtml#list20-29">Listing 20-29</a> after coalescing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tmp1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">into EDI</samp></p>&#13;
<p class="TX">We learned earlier that the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">mov src, dst</samp> will never make <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> interfere. Initially, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">movl %edi, %tmp2</samp> caused an interference between <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp>. Now that we’ve merged <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> into EDI, it doesn’t cause an interference anymore.</p>&#13;
<p class="TX">Even though it isn’t completely accurate, our quick update method is still useful. It produces a conservative approximation of the true interference graph; it has all the nodes and edges that should be in the graph, but it might have a few extra edges too. If this graph tells us that two registers are safe to coalesce, we can be sure they really are. But if we rely solely on this method, we’ll leave some coalescing opportunities on the table. If, for instance, we only look at the graph in <a href="#fig20-18">Figure 20-18</a>, we won’t realize that we can coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI. Worse, if we attempted to color this graph, we might end up spilling registers unnecessarily.</p>&#13;
<p class="TX">So, we’ll use <i>both</i> approaches to update the graph. Each time we decide to coalesce a pair of registers, we’ll perform a quick update by merging their nodes together. Then, after we’ve looked at every <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction and rewritten the assembly code, we’ll rebuild the graph from scratch. We’ll repeat this build-coalesce loop until we can’t find any more registers to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_656" aria-label="656"/>coalesce. Combining a speedy, approximate inner loop with a slow, precise outer loop gives us the best of both worlds. We’ll catch every coalescing opportunity and send an accurate interference graph on to the coloring stage, but we won’t waste time rebuilding the graph after every single coalescing decision.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h4 class="H2"><span id="sec29"/><span id="h2-238"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Conservative Coalescing</samp></h4>&#13;
<p class="TNI">Now that we understand how coalescing changes the graph, we can reason about when it might lead to spills. The basic issue is that when we coalesce two nodes, the merged node will have a higher degree than either of them, which could make it more difficult to prune. It’s also likely to have a higher spill cost than either of the original nodes, since it’s used more frequently.</p>&#13;
<p class="TX">We’ll use two conservative coalescing tests to ensure that a merged node doesn’t cause problems when we color the graph. The <i>Briggs test</i> guarantees that we won’t spill the merged node. The <i>George test</i> guarantees that we won’t spill any other nodes unless they were already potential spill candidates in the original graph. We’ll only coalesce two pseudoregisters if they pass the Briggs test. We’ll coalesce a pseudoregister into a hard register if the two registers pass either test; we can be more permissive in this case because we already know that the hard register won’t spill. Both tests are named after the people who invented them; you can find links to the papers that first proposed them in <span class="Xref">“Additional Resources” on <a href="#pg_669">page 669</a></span>.</p>&#13;
<p class="TX">It’s worth clarifying exactly what the conservative coalescing tests guarantee, because it’s a little unintuitive. If you could completely prune the original graph without ever having to choose a spill candidate, these tests guarantee that the same will be true for the coalesced graph. In this case, we can say for sure that coalescing won’t cause any spills.</p>&#13;
<p class="TX">But if you couldn’t totally prune the original graph, it’s harder to predict the impact of coalescing, because a lot of what happens after you pick a spill candidate comes down to chance. We saw an example of this earlier in the chapter, when we tried to color the graph in <a href="#fig20-12">Figure 20-12</a>; pruning nodes in a different order made the difference between being able to color a spill candidate and actually spilling it. Coalescing registers can have similar ripple effects. If we’re unlucky, these effects might lead to a spill that we otherwise would have avoided.</p>&#13;
<p class="TX">In other words, if coloring the original graph required us to choose a spill candidate, coloring the coalesced graph might too—and at that point, it’s impossible to say with any certainty what’s going to happen. In this case, the conservative coalescing tests still give us two valuable guarantees. First, the coalesced node itself won’t spill. Second, at the point where we get stuck and have to choose our first spill candidate, every node’s degree will be the same or lower than it would have been when we got stuck if we hadn’t performed coalescing. This means that, on balance, we’re likely to successfully prune more nodes and spill fewer than we would have without coalescing.</p>&#13;
<p class="TX">Now we’ll take a closer look at the Briggs and George tests. We’ll define both of them and walk through some examples that demonstrate why they work.</p>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_657" aria-label="657"/>&#13;
<h5 class="H3"><span id="sec30"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Briggs Test</samp></h5>&#13;
<p class="TNI">Remember that a node has significant degree if it has <i>k</i> or more neighbors. The Briggs test allows us to merge two nodes if the merged node will have fewer than <i>k</i> neighbors with significant degree. When we color the graph, we’ll be able to prune every neighbor with insignificant degree. The merged node itself will then have insignificant degree—it will have fewer than <i>k</i> neighbors left—so we’ll be able to prune that node too.</p>&#13;
<p class="TX">Let’s look at an example. Consider the interference graph in <a href="#fig20-19">Figure 20-19</a>.</p>&#13;
<figure class="IMG"><img class="img80" id="fig20-19" src="../images/fig20-19.jpg" alt="" width="947" height="561"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-19: An interference graph before coalescing <a href="description-82.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Our coloring algorithm can prune this entire graph without any difficulty. Now let’s apply the Briggs test to see if we can coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. <a href="#fig20-20">Figure 20-20</a> shows how the graph will look once we merge these two nodes together.</p>&#13;
<figure class="IMG"><img class="img80" id="fig20-20" src="../images/fig20-20.jpg" alt="" width="954" height="565"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-20: The graph in <a href="#fig20-19">Figure 20-19</a> after merging x into y <a href="description-83.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After coalescing, <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> will have four neighbors: <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, ESI, and EDI. Only two of these nodes, ESI and EDI, have significant degree. Since <i>k</i> is 3, this example passes the Briggs test. And in fact, we’ll be able to prune <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> after <span role="doc-pagebreak" epub:type="pagebreak" id="pg_658" aria-label="658"/>we’ve pruned <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>, then finish pruning the rest of the graph like we did before.</p>&#13;
<p class="TX">Next, let’s look at a case that fails the Briggs test. The graph in <a href="#fig20-21">Figure 20-21</a> is almost identical to the one in <a href="#fig20-19">Figure 20-19</a>, except for an extra edge from <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to EDI.</p>&#13;
<figure class="IMG"><img class="img80" id="fig20-21" src="../images/fig20-21.jpg" alt="" width="950" height="563"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-21: A variation on the graph in <a href="#fig20-19">Figure 20-19</a> where x and y can no longer be coalesced <a href="description-84.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Even with this extra edge, our coloring algorithm can still prune the whole graph. But <a href="#fig20-22">Figure 20-22</a> shows what happens when we coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> this time around.</p>&#13;
<figure class="IMG"><img class="img80" id="fig20-22" src="../images/fig20-22.jpg" alt="" width="954" height="565"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-22: The graph in <a href="#fig20-21">Figure 20-21</a> after merging x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">into y <a href="description-85.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> has three neighbors with significant degree: ESI, EDI, and <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. This example fails the Briggs test, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> really is impossible to prune. After we prune <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> and EAX we’ll get stuck, and we’ll be forced to choose <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> as a spill candidate.</p>&#13;
<p class="TX">As these examples show us, the Briggs test stops us from transforming a colorable graph into an uncolorable one. It also gives us another guarantee: we’ll never coalesce two nodes if the resulting node might spill. Take a look at <a href="#fig20-23">Figure 20-23</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_659" aria-label="659"/>&#13;
<figure class="IMG"><img class="img60" id="fig20-23" src="../images/fig20-23.jpg" alt="" width="692" height="501"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-23: An interference graph where we can’t coalesce tmp1 and tmp2 <a href="description-86.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Suppose we want to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>. This clearly won’t make the graph harder to color; it will have the same effect on the interference graph as removing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> entirely. But coalescing these nodes is a bad idea for another reason. We won’t be able to color <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> whether we coalesce it with <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> or not, so coalescing will just make things worse by increasing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>’s spill cost.</p>&#13;
<p class="TX">This example fails the Briggs test, since <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp> will have three neighbors with significant degree after coalescing (just like it did before coalescing). If we might not be able to color it, the Briggs test won’t let us coalesce it.</p>&#13;
<p class="TX">Finally, let’s tweak this example to illustrate one of the limits of the Briggs test. Imagine that we want to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp1</samp>. Like in our previous example, this won’t make the graph harder to color. And this also fails the Briggs test, because EDI will have three neighbors with significant degree. But there’s one important difference: as a hard register, EDI can’t spill. This means that there’s no downside to coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI; it won’t force us to spill EDI, and it won’t make other nodes harder to color either. In cases like this, we’ll use the George test to find coalescing opportunities that the Briggs test misses.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h5 class="H3"><span id="sec31"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The George Test</samp></h5>&#13;
<p class="TNI">When we coalesce a pseudoregister with a hard register, we know the coalesced register can’t spill. Instead, we’re worried about a slightly different outcome: if the hard register becomes more difficult to prune, its neighbors could become harder to prune too. Ultimately, this change could force us to spill nodes that we were able to color before. In cases that involve a hard register, we’ll use both the Briggs test and the George test to identify as many coalescing opportunities as possible. The Briggs test proves that we can prune the merged node, so it won’t interfere with attempts to color other nodes. The George test proves that we won’t make the merged node’s neighbors harder to prune (and therefore won’t make those nodes or the rest of the graph more difficult to color), even if we can’t prune the merged node itself. We can coalesce a pair of nodes that passes either of these tests.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_660" aria-label="660"/>The George test says that you can coalesce a pseudoregister <i>p</i> into a hard register <i>h</i> if each of <i>p</i>’s neighbors meets either of two conditions:</p>&#13;
<ol class="NL">&#13;
<li class="NL">It has fewer than <i>k</i> neighbors.</li>&#13;
<li class="NL">It already interferes with <i>h</i>.</li>&#13;
</ol>&#13;
<p class="TX">If a neighbor meets the first condition, we’ll definitely be able to prune it when we color the graph. If it meets the second condition, it will have exactly the same neighbors as before (except for <i>p</i>) after coalescing, so we won’t have made it any harder to prune; if anything, we might have made it easier.</p>&#13;
<p class="TX">Coalescing <i>h</i> and <i>p</i> won’t make any of <i>h</i>’s neighbors harder to prune, either. The only way it could do that would be by preventing us from pruning <i>h</i> itself, but any new neighbors that <i>h</i> acquires through coalescing will have insignificant degree, so they won’t affect our ability to prune it.</p>&#13;
<p class="TX">Let’s take another look at the graph from <a href="#fig20-23">Figure 20-23</a> to see why this works:</p>&#13;
<figure class="IMG"><img class="img50" src="../images/pg660-1.jpg" alt="" width="692" height="501"/></figure>&#13;
<p class="TX">Earlier, we decided that coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI was safe, because EDI couldn’t spill and this change wouldn’t make any of the other nodes harder to color. But we also saw that this case failed the Briggs test, since EDI would then have three neighbors with significant degree. Now we’ll try the George test instead. This test will pass, since both neighbors of <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> already interfere with EDI. Our allocator will coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp2</samp> into EDI, since it coalesces moves that pass either of our two tests.</p>&#13;
<p class="TX">For our last example, let’s revisit the graph from <a href="#fig20-15">Figure 20-15</a>:</p>&#13;
<figure class="IMG"><img class="img40" src="../images/pg660-2.jpg" alt="" width="452" height="452"/></figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_661" aria-label="661"/>The last time we looked at this graph, we were considering whether to coalesce <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into EDI. Now we know that we shouldn’t coalesce them, because this case doesn’t pass either of our two tests. It fails the Briggs test because the coalesced node would have two neighbors with significant degree, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> and EAX. It also fails the George test; <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>’s one neighbor, <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, has significant degree and doesn’t interfere with EDI. The George test tells us that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> <i>might</i> become harder to color if we made this change; we’d be making it interfere with an additional register, and we don’t know what impact that would have. In this small example, we can tell by looking at the graph that <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp> actually would be harder to color if we coalesced <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> into EDI, since it would interfere with both hard registers.</p>&#13;
<p class="TX">There’s one ugly detail about the George test that I want to mention. Remember that we’re using a quick, approximate method to update the graph after each coalescing decision. This approximate method might leave edges in the graph between registers that do not, in fact, interfere. As a result, when applying the George test to registers <i>p</i> and <i>h</i>, we might think that some neighbor <i>n</i> of <i>p</i> also interferes with <i>h</i> when it actually doesn’t. We might then incorrectly conclude that <i>p</i> and <i>h</i> pass the George test and coalesce them.</p>&#13;
<p class="TX">That sounds pretty bad, but it only slightly weakens the guarantee that the George test provides. Earlier, I claimed that the George test guarantees that we won’t make the merged node’s neighbors harder to prune. It actually guarantees that we won’t make them harder to prune than they were <i>before we started the current round of coalescing</i>—that is, the last time we rebuilt the interference graph from scratch.</p>&#13;
<p class="TX">This weaker guarantee still holds because our approximate graph will include an edge between <i>n</i> and <i>h</i> only if <i>n</i> did interfere with <i>h</i> when we built the interference graph, but some earlier coalescing decision removed that interference. Essentially, if an earlier coalescing decision made <i>n</i> or <i>h</i> easier to prune by removing the edge between them, we might accidentally make them more difficult to prune again by putting that edge back. However, we’ll never make things worse than they were before the current round of coalescing. (It’s also worth keeping in mind that the purpose of the Briggs and George tests is to improve performance, <i>not</i> to guarantee correctness; even a “bad” coalescing decision that fails both tests won’t change the program’s observable behavior.)</p>&#13;
<aside class="box-rule" aria-label="box-129"><p class="BoxTitle" id="box-129"><samp class="SANS_Dogma_OT_Bold_B_11">THE LIMITS OF THE BRIGGS AND GEORGE TESTS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The Briggs and George tests share a basic limitation: they both guess whether a node can be pruned by examining only the node and its neighbors, without considering its neighbors’ neighbors, and their neighbors, and so on. That’s not always enough information to recognize that we’ll eventually be able to prune</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_662" aria-label="662"/><samp class="SANS_Futura_Std_Book_11">a node. The following interference graph illustrates the problem: it fails the Briggs test even though coalescing would be safe.</samp></p>&#13;
<figure class="IMG"><img id="fig-pg662-1" class="img70" src="../images/pg662-1.jpg" alt="" width="972" height="830"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-87.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This graph is identical to the one in <a href="#fig20-19">Figure 20-19</a>, which we looked at when we discussed the Briggs test earlier, except that we’ve given</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_Futura_Std_Book_11">some extra neighbors. These extra neighbors don’t impact our ability to color the graph, since we can prune all of them right away. Now let’s try to coalesce</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">into</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
<figure class="IMG"><img id="fig-pg662-2" class="img70" src="../images/pg662-2.jpg" alt="" width="994" height="848"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-88.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_663" aria-label="663"/><samp class="SANS_Futura_Std_Book_11">It’s easy to see that this graph is still colorable. However, it fails the Briggs test because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_Futura_Std_Book_11">now has three neighbors with significant degree: ESI, EDI, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp><samp class="SANS_Futura_Std_Book_11">. If the test went one step further, we would see that ESI, EDI, and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_Futura_Std_Book_11">themselves all have fewer than three neighbors with significant degree, so we’ll be able to prune all of them—but it doesn’t. Instead, it stops after considering</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp><samp class="SANS_Futura_Std_Book_11">’s immediate neighbors. The George test has exactly the same issue: it gets tripped up by nodes that have lots of neighbors to start with but that would have fewer than</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">k</samp> <samp class="SANS_Futura_Std_Book_11">neighbors after a few rounds of pruning.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The same paper that introduced the George test proposed an algorithm called</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">iterated register coalescing</samp> <samp class="SANS_Futura_Std_Book_11">to overcome this limitation. The gist of this technique is that you can alternate between pruning the graph and coalescing. After a round of pruning, the Briggs and George tests can often identify coalescing opportunities that they couldn’t find before. For example, we could prune the nodes with insignificant degree from the first interference graph in this box and then apply the Briggs test to coalesce</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp><samp class="SANS_Futura_Std_Book_11">. Iterated register coalescing is still a conservative approach, so it won’t find every single coalescing opportunity, but it will catch many opportunities that our simpler strategy misses.</samp></p>&#13;
</aside>&#13;
<p class="TX">We’ve looked at both conservative coalescing tests, what guarantees they provide, and why they work. Now we just have to implement them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2"><span id="sec32"/><span id="h2-239"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Register Coalescing</samp></h4>&#13;
<p class="TNI">Our first task is to add the build-coalesce loop to the top-level register allocation algorithm. <a href="chapter20.xhtml#list20-31">Listing 20-31</a> gives the updated algorithm, with this addition bolded.</p>&#13;
<a id="list20-31"/>&#13;
<pre><code>allocate_registers(instructions):&#13;
<b>    while True:</b>&#13;
<b>        interference_graph = build_graph(instructions)</b>&#13;
<b>        coalesced_regs = coalesce(interference_graph, instructions)</b>&#13;
<b>        if nothing_was_coalesced(coalesced_regs):</b>&#13;
<b>            break</b>&#13;
<b>        instructions = rewrite_coalesced(instructions, coalesced_regs)</b>&#13;
    add_spill_costs(interference_graph, instructions)&#13;
    color_graph(interference_graph)&#13;
    register_map = create_register_map(interference_graph)&#13;
    transformed_instructions = replace_pseudoregs(instructions, register_map)&#13;
    return transformed_instructions</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-31: Adding register coalescing to the top-level register allocation algorithm</samp></p>&#13;
<p class="TX">Within this loop, we build the interference graph, then look for registers to coalesce. If we find any, we rewrite the assembly code and start the whole process again. Otherwise, we exit the loop and run the rest of the allocator as usual.</p>&#13;
<p class="TX">We record which registers we’ve coalesced together in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>, which is a <i>disjoint-set</i> data structure. Let’s write a simple implementation <span role="doc-pagebreak" epub:type="pagebreak" id="pg_664" aria-label="664"/>of this data structure; then we’ll define the <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">rewrite_coalesced</samp> functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h5 class="H3"><span id="sec33"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Disjoint Sets</samp></h5>&#13;
<p class="TNI">As the name suggests, a disjoint-set data structure represents multiple disjoint sets of values. Each set is identified by one representative member. Disjoint sets support two operations: <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> merges two sets, and <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> looks up the representative member of a set. In our case, the values in each set are <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operands. Initially, each register is in a set by itself. As we coalesce registers, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> operation to merge these sets together. When we rewrite the assembly code, we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to replace each register with the representative member of its set.</p>&#13;
<p class="TX">There are a few different ways to implement disjoint sets. We’ll use a simple implementation that’s easy to understand. <a href="chapter20.xhtml#list20-32">Listing 20-32</a> defines our implementation.</p>&#13;
<a id="list20-32"/>&#13;
<pre><code>init_disjoint_sets():&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> return <var>&lt;empty map&gt;</var>&#13;
&#13;
union(x, y, reg_map):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> reg_map.add(x, y)&#13;
&#13;
find(r, reg_map):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if r is in reg_map:&#13;
        result = reg_map.get(r)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> return find(result, reg_map)&#13;
    return r&#13;
&#13;
nothing_was_coalesced(reg_map):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> if reg_map is empty:&#13;
        return True&#13;
    return False</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-32: A basic implementation of disjoint sets</samp></p>&#13;
<p class="TX">We use a map to track which sets have been merged together. At first, this map is empty <span class="CodeAnnotation" aria-label="annotation1">❶</span>. To merge two sets whose representative members are <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> operation inserts a mapping from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This makes <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> the representative member of the new set. When we coalesce a pseudoregister into a hard register, it’s important to make the hard register the set’s representative member; we don’t want to replace hard registers with pseudoregisters when we rewrite the code later on.</p>&#13;
<p class="TX">To look up the representative member of the set that contains the register <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> operation first checks whether <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> maps to some other register <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it doesn’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> itself is the representative member of its set, so we return it. Otherwise, looking it up in the map will give us <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>, which is the register we merged <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> into previously. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> recursively <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which leads us up the chain of mappings from <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp> to its representative member. For example, if we’ve merged <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and then merged <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, we’ll follow the mappings from <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> to determine that <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is the representative member for <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_665" aria-label="665"/>The last operation we define in this listing is <samp class="SANS_TheSansMonoCd_W5Regular_11">nothing_was_coalesced</samp>, which just checks whether the map is empty <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h5 class="H3"><span id="sec34"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The coalesce Function</samp></h5>&#13;
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> function will look at each <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction in the assembly code, deciding which registers to coalesce and keeping track of those decisions in the disjoint-set structure we just defined. Let’s walk through <a href="chapter20.xhtml#list20-33">Listing 20-33</a>, which gives the pseudocode for this function.</p>&#13;
<a id="list20-33"/>&#13;
<pre><code>coalesce(graph, instructions):&#13;
    coalesced_regs = init_disjoint_sets()&#13;
&#13;
    for i in instructions:&#13;
        match i with&#13;
        | Mov(src, dst) -&gt;&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> src = find(src, coalesced_regs)&#13;
            dst = find(dst, coalesced_regs)&#13;
&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if (src is in graph&#13;
                and dst is in graph&#13;
                and src != dst&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> and (not are_neighbors(graph, src, dst))&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> and conservative_coalesceable(graph, src, dst)):&#13;
&#13;
                if src is a hard register:&#13;
                    to_keep = src&#13;
                    to_merge = dst&#13;
                else:&#13;
                    to_keep = dst&#13;
                    to_merge = src&#13;
&#13;
              <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> union(to_merge, to_keep, coalesced_regs)&#13;
                update_graph(graph, to_merge, to_keep)&#13;
&#13;
        | _ -&gt; continue&#13;
&#13;
    return coalesced_regs</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-33: Deciding which registers to coalesce</samp></p>&#13;
<p class="TX">We start by initializing a new disjoint-set structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>, to track which registers we’ve coalesced. Then, we iterate through the instruction list. When we hit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to look up its current source and destination <span class="CodeAnnotation" aria-label="annotation1">❶</span>, since we might have coalesced <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> into other registers already. Note that these operands might be constants or memory addresses instead of registers. This is fine; if there’s no mapping for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesced_regs</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">find(x, coalesced_regs)</samp> just returns <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, regardless of whether <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a register or some other kind of operand.</p>&#13;
<p class="TX">Next, we decide whether to coalesce the instruction’s source and destination <span class="CodeAnnotation" aria-label="annotation2">❷</span>. First, we check whether they’re both in the interference graph. (This stops us from trying to coalesce constants or memory operands.) <span role="doc-pagebreak" epub:type="pagebreak" id="pg_666" aria-label="666"/>We then make sure they’re two different registers, since there’s no reason to coalesce a register with itself. If these checks pass, we test the two conditions we learned about earlier: <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> must not interfere <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and coalescing them must not make the graph harder to color <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We check the second of these conditions with the <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp> function, which we’ll come back to in a moment.</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> meet all these conditions, we’ll coalesce them! Now we have to figure out which one to keep in the assembly code and which one to replace. If either operand is a hard register, we’ll keep that one and replace the other one. If they’re both pseudoregisters, we’ll arbitrarily choose to keep <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">union</samp> to actually coalesce these registers <span class="CodeAnnotation" aria-label="annotation5">❺</span>, then we update the interference graph. <a href="chapter20.xhtml#list20-34">Listing 20-34</a> defines the function that performs this update.</p>&#13;
<a id="list20-34"/>&#13;
<pre><code>update_graph(graph, x, y):&#13;
&#13;
    node_to_remove = get_node_by_id(graph, x)&#13;
    for neighbor in node_to_remove.neighbors:&#13;
        add_edge(graph, y, neighbor)&#13;
        remove_edge(graph, x, neighbor)&#13;
&#13;
    remove_node_by_id(graph, x)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-34: Updating the interference graph</samp></p>&#13;
<p class="TX">This function takes each of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>’s neighbors, removes its edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>, and adds an edge to <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> instead. Then, it removes <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> from the graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h5 class="H3"><span id="sec35"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The conservative_coalesceable Function</samp></h5>&#13;
<p class="TNI">Now that the rest of <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp> is in place, let’s take a look at <a href="chapter20.xhtml#list20-35">Listing 20-35</a>, which defines the conservative coalescing tests.</p>&#13;
<a id="list20-35"/>&#13;
<pre><code>conservative_coalesceable(graph, src, dst):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if briggs_test(graph, src, dst):&#13;
        return True&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if src is a hard register:&#13;
        return george_test(graph, src, dst)&#13;
    if dst is a hard register:&#13;
        return george_test(graph, dst, src)&#13;
    return False&#13;
&#13;
briggs_test(graph, x, y):&#13;
    significant_neighbors = 0&#13;
&#13;
    x_node = get_node_by_id(graph, x)&#13;
    y_node = get_node_by_id(graph, y)&#13;
&#13;
    combined_neighbors = set(x_node.neighbors)&#13;
    combined_neighbors.add_all(y_node.neighbors)&#13;
    for n in combined_neighbors:&#13;
        neighbor_node = get_node_by_id(graph, n)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_667" aria-label="667"/>      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> degree = length(neighbor_node.neighbors)&#13;
        if are_neighbors(graph, n, x) and are_neighbors(graph, n, y):&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> degree -= 1&#13;
        if degree &gt;= k:&#13;
            significant_neighbors += 1&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> return (significant_neighbors &lt; k)&#13;
&#13;
george_test(graph, hardreg, pseudoreg):&#13;
    pseudo_node = get_node_by_id(graph, pseudoreg)&#13;
    for n in pseudo_node.neighbors:&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> if are_neighbors(graph, n, hardreg):&#13;
            continue&#13;
&#13;
        neighbor_node = get_node_by_id(graph, n)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> if length(neighbor_node.neighbors) &lt; k:&#13;
            continue&#13;
&#13;
        return False&#13;
    return True</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-35: The conservative coalescing tests</samp></p>&#13;
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">conservative_coalesceable</samp>, we try the Briggs test first <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, if the Briggs test fails and either <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> is a hard register, we try the George test <span class="CodeAnnotation" aria-label="annotation2">❷</span>. When we use the George test, we’ll make sure to pass the hard register as its first argument and the pseudoregister as its second, since it doesn’t treat these registers interchangeably.</p>&#13;
<p class="TX">To apply the Briggs test, we first construct <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp>, which is the set of nodes that interfere with either <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. We then iterate through this set, looking up each neighbor’s degree <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If a node interferes with both of them, coalescing <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> would decrease its degree by one, so we adjust <samp class="SANS_TheSansMonoCd_W5Regular_11">degree</samp> accordingly <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if fewer than <i>k</i> of the nodes in <samp class="SANS_TheSansMonoCd_W5Regular_11">combined_neighbors</samp> have significant degree <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">To apply the George test, we iterate through the pseudoregister’s neighbors, making sure each one either interferes with the hard register <span class="CodeAnnotation" aria-label="annotation6">❻</span> or has insignificant degree <span class="CodeAnnotation" aria-label="annotation7">❼</span>. If we find a neighbor that doesn’t satisfy either condition, we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If every neighbor meets both conditions, we’ll return <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h5 class="H3"><span id="sec36"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The rewrite_coalesced Function</samp></h5>&#13;
<p class="TNI">We’ll wrap up by rewriting the assembly code. <a href="chapter20.xhtml#list20-36">Listing 20-36</a> gives the pseudocode for this step.</p>&#13;
<a id="list20-36"/>&#13;
<pre><code>rewrite_coalesced(instructions, coalesced_regs):&#13;
    new_instructions = []&#13;
    for i in instructions:&#13;
        match i with&#13;
        | Mov(src, dst) -&gt;&#13;
            src = find(src, coalesced_regs)&#13;
            dst = find(dst, coalesced_regs)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_668" aria-label="668"/>          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if src != dst:&#13;
                new_instructions.append(Mov(src, dst))&#13;
        | Binary(op, src, dst) -&gt;&#13;
            src = find(src, coalesced_regs)&#13;
            dst = find(dst, coalesced_regs)&#13;
            new_instructions.append(Binary(op, src, dst))&#13;
        |<var> --snip--</var>&#13;
&#13;
    return new_instructions</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 20-36: Rewriting instructions after deciding which registers to coalesce</samp></p>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> operation to replace each operand in each instruction. (Here, like in <samp class="SANS_TheSansMonoCd_W5Regular_11">coalesce</samp>, we rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> to handle non-registers correctly.) If a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction’s updated source and destination are the same, we’ll omit the instruction from the rewritten code <span class="CodeAnnotation" aria-label="annotation1">❶</span>. As a side benefit, this will also remove any <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions that were redundant before we coalesced registers.</p>&#13;
<p class="TX">And with that, you’ve finished your register allocator! We don’t need to change any other passes, so you can go ahead and test it out.</p>&#13;
<aside class="box" aria-label="box-80"><p class="BoxTitle" id="box-80"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">If you completed only Part I, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 20 --int-only</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If you also completed Part II, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 20</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">These commands run the same test programs as the earlier commands with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--no-coalescing</samp> <samp class="SANS_Futura_Std_Book_11">option, and they perform the same validation, except that they also validate the assembly output for the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_20/int_only/with_coalescing</samp> <samp class="SANS_Futura_Std_Book_11">and (for the second command)</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_20/all_types/with_coalescing</samp> <samp class="SANS_Futura_Std_Book_11">to make sure you’re coalescing registers properly.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h3 class="H1"><span id="sec37"/><span id="h1-192"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you built a register allocator. You used everything you’d already learned about liveness analysis to build an interference graph, and then you implemented a classic graph coloring algorithm to color it. You introduced callee-saved registers and learned how to save and restore them. Then, you used register coalescing to clean up the mess that earlier stages of the compiler left behind. You’ve written your last optimization and completed the project!</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_669" aria-label="669"/>Over the course of this book, you’ve built an impressive piece of software: an optimizing compiler for a substantial chunk of the C language. You’ve covered a lot of ground, from the intricacies of the C standard to the gory details of the System V calling convention to the fundamentals of data-flow analysis. But if you want to push your compiler even further, you have plenty of options. I’ll close out this part of the book with a few ideas for what to work on next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h3 class="H1"><span id="sec38"/><span id="h1-193"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">The register allocator you built in this chapter uses a simplified version of the classic <i>Chaitin-Briggs algorithm</i>. This section tells you where to find the original papers about this algorithm, a couple of textbook chapters that present them in a more approachable way, and some other useful references on more specific topics.</p>&#13;
<p class="ListHead"><b>Key papers</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Register Allocation via Coloring,” a 1981 paper by Gregory Chaitin et al., described the original graph coloring register allocator (<i><a href="https://doi.org/10.1016/0096-0551(81)90048-5">https://<wbr/>doi<wbr/>.org<wbr/>/10<wbr/>.1016<wbr/>/0096<wbr/>-0551(81)90048<wbr/>-5</a></i>). It introduced most of the fundamental concepts in this chapter, including how to build and color an interference graph.</li>&#13;
<li class="ListBullet">Chaitin published an updated description of the same allocator, “Register Allocation &amp; Spilling via Graph Coloring,” in 1982 (<i><a href="https://doi.org/10.1145/872726.806984">https://<wbr/>doi<wbr/>.org<wbr/>/10<wbr/>.1145<wbr/>/872726<wbr/>.806984</a></i>).</li>&#13;
<li class="ListBullet">“Improvements to Graph Coloring Register Allocation,” a 1994 paper by Preston Briggs, Keith Cooper, and Linda Torczon, describes an improved version of Chaitin’s design (<i><a href="https://doi.org/10.1145/177492.177575">https://<wbr/>doi<wbr/>.org<wbr/>/10<wbr/>.1145<wbr/>/177492<wbr/>.177575</a></i>). The name <i>Chaitin-Briggs</i> refers to this improved algorithm. This paper presented the technique of putting spill candidates on the stack and trying to color them later instead of spilling them immediately. (Briggs et al. call this technique <i>optimistic coloring</i>.) It also introduced the Briggs test and the general concept of conservative coalescing; Chaitin’s original design coalesced aggressively, even when it made the graph harder to color. This paper described some techniques that we didn’t cover in this chapter, like rematerialization, as well.</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Textbook chapters</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet"><a href="chapter16.xhtml">Chapter 16</a> of Steven Muchnick’s <i>Advanced Compiler Design and Implementation</i> (Morgan Kaufmann, 1997) presents a register allocator that uses an algorithm similar to Chaitin-Briggs. The most notable difference is that it doesn’t use conservative coalescing; like Chaitin’s original allocator, it coalesces aggressively. I found Muchnick’s explanations of how to include hard registers in the interference graph, how to detect interference, and the overall structure of the allocator especially useful.</li>&#13;
<li class="ListBullet"><a href="chapter13.xhtml">Chapter 13</a> of Keith Cooper and Linda Torczon’s <i>Engineering a Compiler</i>, 2nd edition (Morgan Kaufmann, 2011), provides an excellent overview <span role="doc-pagebreak" epub:type="pagebreak" id="pg_670" aria-label="670"/>of a wide range of approaches to register allocation, including the Chaitin-Briggs algorithm and several others that we didn’t discuss here. I’ve drawn on their definition of interference and their discussion of how to update the interference graph while coalescing; they provide a particularly helpful explanation of why both fast, imprecise updates and slow, complete updates are needed. (You can also consult the third edition of this book, published in 2022.)</li>&#13;
</ul>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>These are both good resources if you want to implement the parts of Chaitin-Briggs that we skipped. The chapter by Muchnick is particularly useful if you want to integrate spill code generation into your register allocator. Both books discuss how to use live ranges (which Muchnick calls</i> <span class="note_Italic">webs</span><i>) instead of pseudoregisters as the nodes in your interference graph, and both provide better spill cost metrics than the one we used.</i></p>&#13;
<p class="ListHead"><b>Conservative coalescing</b></p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">The George test comes from “Iterated Register Coalescing,” by Lal George and Andrew Appel (<i><a href="https://doi.org/10.1145/229542.229546">https://<wbr/>doi<wbr/>.org<wbr/>/10<wbr/>.1145<wbr/>/229542<wbr/>.229546</a></i>). The main point of the paper is that you can coalesce more registers if you alternate between coalescing and pruning; the George test is presented as a minor implementation detail.</li>&#13;
<li class="ListBullet">For an informal discussion of the George and Briggs tests with lots of examples, see the slides from Phillip Gibbons’s course on compiler optimizations at Carnegie Mellon (<i><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L23-Register-Coalescing.pdf">https://<wbr/>www<wbr/>.cs<wbr/>.cmu<wbr/>.edu<wbr/>/afs<wbr/>/cs<wbr/>/academic<wbr/>/class<wbr/>/15745<wbr/>-s19<wbr/>/www<wbr/>/lectures<wbr/>/L23<wbr/>-Register<wbr/>-Coalescing<wbr/>.pdf</a></i>).</li>&#13;
<li class="ListBullet">“Comparing Conservative Coalescing Criteria” by Max Hailperin rigorously defines what the Briggs and George tests actually prove, which is something that the authors of the original papers never bothered to do (<i><a href="https://doi.org/10.1145/1065887.1065894">https://<wbr/>doi<wbr/>.org<wbr/>/10<wbr/>.1145<wbr/>/1065887<wbr/>.1065894</a></i>). My discussion of what these tests guarantee at the start of <span class="listbullet_Xref">“Conservative Coalescing” on <a href="#pg_656">page 656</a></span> relies heavily on Hailperin’s paper. Note that some of his claims don’t apply to our graph coloring implementation because he uses precoloring and we don’t.</li>&#13;
</ul>&#13;
<p class="ListHead"><b>Identifying loops</b></p>&#13;
<p class="TX">To calculate more accurate spill costs, you need to detect the loops in your program. These resources talk about how to identify loops:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet"><a href="chapter9.xhtml">Chapter 9</a>, section 6, of <i>Compilers: Principles, Techniques, and Tools</i>, 2nd edition, by Alfred Aho et al. (Addison-Wesley, 2006).</li>&#13;
<li class="ListBullet">Phillip Gibbons’s lecture slides on induction variable optimizations, from his Carnegie Mellon compiler optimizations course (<i><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L8-Induction-Variables.pdf">https://<wbr/>www<wbr/>.cs<wbr/>.cmu<wbr/>.edu<wbr/>/afs<wbr/>/cs<wbr/>/academic<wbr/>/class<wbr/>/15745<wbr/>-s19<wbr/>/www<wbr/>/lectures<wbr/>/L8<wbr/>-Induction<wbr/>-Variables<wbr/>.pdf</a></i>). This is a great starting point, but the slides aren’t detailed enough to use as a stand-alone guide to loop analysis. You might want to use them alongside the previous reference or another textbook.</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>