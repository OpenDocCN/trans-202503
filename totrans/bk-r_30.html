<html><head></head><body>
<h2 class="h2" id="ch25"><span epub:type="pagebreak" id="page_631"/><span class="big"><strong>25</strong></span><br/><strong>DEFINING COLORS AND PLOTTING IN HIGHER DIMENSIONS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">Now that you’ve mastered some fundamental visualization skills, you can go beyond the standard <em>x</em>- and <em>y</em>-axes by, for example, coloring points according to some additional value or variable or adding a <em>z</em>-axis for constructing a 3D plot. Higher-dimensional plots like this allow you to visually explore your data or models using more variables than would be possible otherwise.</p>&#13;
<p class="indent">In this chapter, you’ll get into more detail when it comes to handling colors and color palettes in R, and then you’ll look at four new plots: 3D scatterplots, contour plots, pixel image plots, and perspective plots.</p>&#13;
<h3 class="h3" id="ch25lev1sec86"><strong>25.1 Representing and Using Color</strong></h3>&#13;
<p class="noindent">Color plays a key role in many plots. As you’ve already seen, color can be used purely for aesthetic enhancement, or it can be a critical aid to interpreting your data/models by distinguishing between values and variables. Before learning about some more complicated data and model visualization tools, it’s useful to understand a little about how R formally represents and <span epub:type="pagebreak" id="page_632"/>handles colors. In this section, you’ll examine common ways to create and represent specific colors and how to define and use a cohesive collection of colors; the latter is referred to as a <em>palette</em>.</p>&#13;
<h4 class="h4" id="ch25lev2sec242"><strong><em>25.1.1 Red-Green-Blue Hexadecimal Color Codes</em></strong></h4>&#13;
<p class="noindent">When specifying colors in plots, your instruction to R so far has been given either in the form of an integer value from <code>1</code> to <code>8</code> or as a character string (see the relevant comments in <a href="ch07.xhtml#ch07lev2sec65">Section 7.2.3</a>). For programming purposes, you need a more objective representation of these colors.</p>&#13;
<p class="indent">One of the most common methods of color specification is to specify different <em>saturations</em> or <em>intensities</em> of three primaries—red, green, and blue (RGB)—which are then mixed to form the resulting target color. Each primary component of the standard RGB system is assigned an integer from 0 to 255 (inclusive). Such mixtures are therefore able to form a total of 256<sup>3</sup> = 16,777,216 possible colors.</p>&#13;
<p class="indent">You always express these values in (R, G, B) order; the result is commonly referred to as a <em>triplet</em>. For example, (0,0,0) represents pure black, (255,255,255) represents pure white, and (0,255,0) is full green.</p>&#13;
<p class="indent">The <code>col</code> argument lets you select one of eight colors when you supply it an integer from 1 to 8. You can find these eight colors with the following call:</p>&#13;
<pre>R&gt; palette()<br/>[1] "black"   "red"    "green3"  "blue"   "cyan"   "magenta"<br/>[7] "yellow"  "gray"</pre>&#13;
<p class="indent">These are but a small subset of the 650+ named colors that you can list by entering <code>colors()</code> at the R prompt. All of these named colors can also be expressed in the standard RGB format. To find the RGB values for a color, supply the desired color names as a vector of character strings to the built-in <code>col2rgb</code> function. Here’s an example:</p>&#13;
<pre>R&gt; col2rgb(c("black","green3","pink"))<br/>      [,1] [,2] [,3]<br/>red      0    0  255<br/>green    0  205  192<br/>blue     0    0  203</pre>&#13;
<p class="indent">The result is a matrix of RGB values, with each column representing one of your specified colors. This is what R actually means, in an RGB sense, when you ask it to plot these colors using the corresponding character string.</p>&#13;
<p class="indent">These RGB triplets are frequently expressed as <em>hexadecimals</em>, a numeric coding system often used in computing. In R, a hexadecimal, or <em>hex code</em>, is a character string with a <code>#</code> followed by six alphanumeric characters: valid characters are the letters <em>A</em> through <em>F</em> and the digits 0 through 9. The first pair of characters represents the red component, and the second and third <span epub:type="pagebreak" id="page_633"/>pairs represent green and blue, respectively. If you have or create one or more RGB triplets, you can turn them into hex codes for R to use in any subsequent plotting through the <code>rgb</code> function. This command takes a matrix of RGB values, though note that it expects each (R, G, B) color to be a row of that matrix (as opposed to the columns provided from a call to, say, <code>col2rgb</code>).</p>&#13;
<p class="indent">You’ll also need to tell <code>rgb</code> that your maximum color value, as per the standard RGB format, is 255 (since by default it scales this and uses 1). The following code performs a matrix transpose (refer to <a href="ch03.xhtml#ch03lev1sec14">Section 3.3</a>) on the result of the previous call to <code>col2rgb</code>, putting my three colors as RGB triplets in the required form as rows, and specifies the <code>maxColorValue</code> accordingly:</p>&#13;
<pre>R&gt; rgb(t(col2rgb(c("black","green3","pink"))),maxColorValue=255)<br/>[1] "#000000" "#00CD00" "#FFC0CB"</pre>&#13;
<p class="indent">The output tells you the hexadecimal codes for the RGB values R refers to with the names <code>"black"</code>, <code>"green3"</code>, and <code>"pink"</code>, respectively.</p>&#13;
<p class="indent">I won’t go into the specifics of converting a standard RGB triplet to a hexadecimal here because it’s beyond the scope of this book, but it’s important to know that R represents any colors you create using RGB triplets as hex codes, so you should be able to at least recognize a hexadecimal when you’re working with colors and color palettes in plotting.</p>&#13;
<p class="indent">For an even more colorful exploration, let’s write a modest little function to plot points in individual colors and label them appropriately with RGB triplets and corresponding hex codes. Consider the following in the editor:</p>&#13;
<pre>pcol &lt;- function(cols){<br/>        n &lt;- length(cols)<br/>        dev.new(width=7,height=7)<br/>        par(mar=rep(1,4))<br/>        plot(1:5,1:5,type="n",xaxt="n",yaxt="n",ann=FALSE)<br/>        for(i in 1:n){<br/>                pt &lt;- locator(1)<br/>                rgbval &lt;- col2rgb(cols[i])<br/>                points(pt,cex=4,pch=19,col=cols[i])<br/>                text(pt$x+1,pt$y,family="mono",<br/>                     label=paste("\"",cols[i],"\"","\nR: ",rgbval[1],<br/>                                 "  G: ",rgbval[2],"  B: ",rgbval[3],<br/>                                 "\nhex: ",rgb(t(rgbval),maxColorValue=255),<br/>                                 sep=""))<br/>        }<br/>}</pre>&#13;
<p class="indent">The function <code>pcol</code> takes one argument, <code>cols</code>, intended to be a character vector of color names recognized by R. When you execute <code>pcol</code>, it opens a new graphics device and equalizes the figure margin settings to be one line on each side. A plot is begun, fully suppressed except for a box. This is so you can use <code>locator</code> (see <a href="ch23.xhtml#ch23lev1sec78">Section 23.3</a>) to place points in the plot region, <span epub:type="pagebreak" id="page_634"/>implemented in a <code>for</code> loop, one after the other. Each point represents one of the <code>cols</code>, and after its coordinates are returned from <code>locator</code>, <code>points</code> puts down a large dot of the color at hand, with <code>text</code> providing annotation to the right of each point achieved using <code>paste</code> (refer to <a href="ch04.xhtml#ch04lev1sec17">Section 4.2</a>). This annotation includes the R color name, the RGB triplet, and the hex code on top of one another; the latter two are found using <code>col2rgb</code> and <code>rgb</code> exactly as demonstrated earlier.</p>&#13;
<p class="indent">The following code sets up the device, first storing 14 valid R color names (chosen randomly) in the character vector <code>mycols</code>. After exhausting these with mouse clicks in different areas of the plot region, the execution is complete.</p>&#13;
<pre>R&gt; mycols &lt;- c("black","blue","royalblue2","pink","magenta","purple",<br/>               "violet","coral","lightgray","seagreen4","red","red2",<br/>               "yellow","lemonchiffon3")<br/>R&gt; pcol(mycols)</pre>&#13;
<p class="indent">When I execute <code>pcol</code> as shown here, I click through the 14 points, producing rough columns on my graphics device. <a href="ch25.xhtml#ch25fig1">Figure 25-1</a> shows the result.</p>&#13;
<div class="image"><img src="../images/f25-01.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig1"/>Figure 25-1: Various named R colors alongside their corresponding RGB triplets and hex codes.</em></p>&#13;
<p class="indent">In essence, you can obtain any color you want (in other words, far more than the named ones that are built into R) by specifying an RGB value and obtaining its hex code. These hexadecimals can be supplied as is to any of the traditional R graphics functions where you specify color (commonly to a <code>col</code> argument). You’ll see this as the chapter progresses. Naturally, you <span epub:type="pagebreak" id="page_635"/>can also assign a hex code or a vector of hex codes (for example, if you’re creating your own custom colors) to a new object in your R workspace so you can use it in subsequent plotting.</p>&#13;
<h4 class="h4" id="ch25lev2sec243"><strong><em>25.1.2 Built-in Palettes</em></strong></h4>&#13;
<p class="noindent">Being able to implement your own RGB colors is most useful when you need many colors, the collection of which is referred to as a <em>palette</em>. You’ll typically need a palette when color is used to describe something on a continuum, like the various shades of blue used for the height measurements in <a href="ch24.xhtml#ch24fig6">Figure 24-6</a> on <a href="ch24.xhtml#page_621">page 621</a>.</p>&#13;
<p class="indent">There are a number of color palettes built into the base R installation. These are defined by the functions <code>rainbow</code>, <code>heat.colors</code>, <code>terrain.colors</code>, <code>topo.colors</code>, <code>cm.colors</code>, <code>gray.colors</code>, and <code>gray</code>. With the exception of <code>gray</code>, you directly specify the number of colors you want, and they’ll be returned as a character vector of hex codes representing an equally spaced sequence over the entire color range of that particular palette.</p>&#13;
<p class="indent">It’s easiest to see this in action with a visualization. The following code generates exactly 600 colors from each palette:</p>&#13;
<pre>R&gt; N &lt;- 600<br/>R&gt; rbow &lt;- rainbow(N)<br/>R&gt; heat &lt;- heat.colors(N)<br/>R&gt; terr &lt;- terrain.colors(N)<br/>R&gt; topo &lt;- topo.colors(N)<br/>R&gt; cm &lt;- cm.colors(N)<br/>R&gt; gry1 &lt;- gray.colors(N)<br/>R&gt; gry2 &lt;- gray(level=seq(0,1,length=N))</pre>&#13;
<p class="indent">Note that instead of a single integer, <code>gray</code> expects a numeric vector of values between 0 (total black) and 1 (total white) to provide a grayscale. Its counterpart function, <code>gray.colors</code>, works the same as the other built-in palettes but defaults to a slightly narrower visual range between the extremes of black and white. These can be reset using the optional arguments <code>start</code> and <code>end</code>, which you’ll see shortly.</p>&#13;
<p class="indent">The next code chunk uses skills from <a href="ch23.xhtml#ch23">Chapter 23</a> to initialize a new plot and uses vector repetition to place 600 points for each palette in a single call to <code>points</code>, coloring them appropriately as per the vectors of hex codes.</p>&#13;
<pre>R&gt; dev.new(width=8,height=3)<br/>R&gt; par(mar=c(1,8,1,1))<br/>R&gt; plot(1,1,xlim=c(1,N),ylim=c(0.5,7.5),type="n",xaxt="n",yaxt="n",ann=FALSE)<br/>R&gt; points(rep(1:N,7),rep(7:1,each=N),pch=19,cex=3,<br/>          col=c(rbow,heat,terr,topo,cm,gry1,gry2))<br/>R&gt; axis(2,at=7:1,labels=c("rainbow","heat.colors","terrain.colors",<br/>                          "topo.colors","cm.colors","gray.colors","gray"),<br/>        family="mono",las=1)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_636"/><a href="ch25.xhtml#ch25fig2">Figure 25-2</a> shows the result.</p>&#13;
<div class="image"><img src="../images/f25-02.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig2"/>Figure 25-2: Showcasing the color ranges of the built-in palettes, with default limits used in</em> <code>gray.colors</code>.</p>&#13;
<p class="indent">For more information, access the help files <code>?gray.colors</code> and <code>?gray</code> for the respective grayscale palettes, with the others all appearing under <code>?rainbow</code>.</p>&#13;
<h4 class="h4" id="ch25lev2sec244"><strong><em>25.1.3 Custom Palettes</em></strong></h4>&#13;
<p class="noindent">You’re not restricted to the ready-to-use color designs. The function <code>colorRampPalette</code> allows you to create your own palettes; you supply two or more desired key colors to an argument of the same name, and it creates a palette that transitions between them. The result of a call to <code>colorRampPalette</code> is itself a function—one that behaves exactly like the built-in palette functions noted earlier.</p>&#13;
<p class="indent">Let’s say you’d like to be able to generate colors on a scale between purple and yellow. You specify the key colors to be interpolated, in the desired order, as a character vector of names from the collection that R recognizes. The following line creates this palette function:</p>&#13;
<pre>R&gt; puryel.colors &lt;- colorRampPalette(colors=c("purple","yellow"))</pre>&#13;
<p class="indent">Let’s create another one, this time picking one that will show up a little clearer in case a color plot that ends up using it is printed in grayscale (in which case sticking to monochromatic palettes is a good idea).</p>&#13;
<pre>R&gt; blues &lt;- colorRampPalette(colors=c("navyblue","lightblue"))</pre>&#13;
<p class="indent">Here are a couple more, using more than two colors this time:</p>&#13;
<pre>R&gt; fours &lt;- colorRampPalette(colors=c("black","hotpink","seagreen4","tomato"))<br/>R&gt; patriot.colors &lt;- colorRampPalette(colors=c("red","white","blue"))</pre>&#13;
<p class="indent">Having created a handful of custom palette functions, you can now generate any number of colors from each range just like before (done here <span epub:type="pagebreak" id="page_637"/>using the previously stored <code>N</code> value of 600 each). After doing so, you can adapt the earlier plotting code to get the image in <a href="ch25.xhtml#ch25fig3">Figure 25-3</a>.</p>&#13;
<pre>R&gt; py &lt;- puryel.colors(N)<br/>R&gt; bls &lt;- blues(N)<br/>R&gt; frs &lt;- fours(N)<br/>R&gt; pat &lt;- patriot.colors(N)<br/>R&gt; dev.new(width=8,height=2)<br/>R&gt; par(mar=c(1,8,1,1))<br/>R&gt; plot(1,1,xlim=c(1,N),ylim=c(0.5,4.5),type="n",xaxt="n",yaxt="n",ann=FALSE)<br/>R&gt; points(rep(1:N,4),rep(4:1,each=N),pch=19,cex=3,col=c(py,bls,frs,pat))<br/>R&gt; axis(2,at=4:1,labels=c("peryel.colors","blues","fours","patriot.colors"),<br/>        family="mono",las=1)</pre>&#13;
<div class="image"><img src="../images/f25-03.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig3"/>Figure 25-3: Some examples of custom color palettes created using</em> <code>colorRampPalette</code>.</p>&#13;
<h4 class="h4" id="ch25lev2sec245"><strong><em>25.1.4 Using Color Palettes to Index a Continuum</em></strong></h4>&#13;
<p class="noindent">You’ve now seen a few times how color can be used to identify groups based on a categorical variable (the data corresponding to a certain level are simply given a distinct color from the others), which is pretty easy to do. However, assigning colors appropriately to values on a continuum requires a little more thought. There are two methods for this: through categorization or through normalization of your continuous values. Let’s look first at the former approach.</p>&#13;
<h5 class="h5" id="ch25lev3sec109"><strong>Via Categorization</strong></h5>&#13;
<p class="noindent">One way to color values according to a continuous variable is to turn it into the familiar problem of coloring points of a categorical variable. You can do this by binning your continuous values into a fixed number of <em>k</em> categories, generating <em>k</em> colors from your palette, and matching each observation to the appropriate color based on the bin it falls into.</p>&#13;
<p class="indent">In <a href="ch20.xhtml#ch20lev1sec62">Section 20.1</a>, you plotted height against writing handspan for the <code>survey</code> data from the <code>MASS</code> package. This time, let’s use color to additionally inform the nonwriting handspan variable. Load the package and execute the following line:</p>&#13;
<pre>R&gt; surv &lt;- na.omit(survey[,c("Wr.Hnd","NW.Hnd","Height")])</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_638"/>This creates the data frame object <code>surv</code>, which is made up of only the three required columns. Any rows with missing values are removed via a call to <code>na.omit</code> (refer to <a href="ch06.xhtml#ch06lev2sec57">Section 6.1.3</a>).</p>&#13;
<p class="indent">Now, the first thing to do is decide on your color palette.</p>&#13;
<pre>R&gt; NW.pal &lt;- colorRampPalette(colors=c("red4","yellow2"))</pre>&#13;
<p class="indent">This will generate colors that go from a dark, dull red at the lower end of the scale to a slightly faded yellow at the higher end (similar to the builtin <code>heat.colors</code> palette; see <a href="ch25.xhtml#ch25fig2">Figure 25-2</a>). Next, you need to decide how many bins, <em>k</em>, you’re going to construct for the continuous values. This determines how many distinct colors to generate from <code>NW.pal</code>. For these data, set <em>k</em> = 5.</p>&#13;
<pre>R&gt; k &lt;- 5<br/>R&gt; ryc &lt;- NW.pal(k)<br/>R&gt; ryc<br/>[1] "#8B0000" "#A33B00" "#BC7700" "#D5B200" "#EEEE00"</pre>&#13;
<p class="indent">Your five <code>NW.pal</code> colors, as hex codes, are available. Next, you need to actually bin the continuous values, which you can do using <code>cut</code>. First you need to set <em>k</em> + 1 break points for the bins (refer to <a href="ch04.xhtml#ch04lev2sec48">Section 4.3.3</a> for a refresher), using <code>seq</code>.</p>&#13;
<pre>R&gt; NW.breaks &lt;- seq(min(surv$NW.Hnd),max(surv$NW.Hnd),length=k+1)<br/>R&gt; NW.breaks<br/>[1] 12.5 14.7 16.9 19.1 21.3 23.5</pre>&#13;
<p class="indent">The six equally spaced values span the range of the students’ nonwriting handspans, delineating your five intended bins. Then <code>cut</code> factorizes the nonwriting handspans with respect to those bins. You can use <code>as.numeric</code> to specifically return the indexes for extracting the appropriate color for each observation from your five ordered hex codes in <code>ryc</code> (full output is suppressed here for reasons of print).</p>&#13;
<pre>R&gt; NW.fac &lt;- cut(surv$NW.Hnd,breaks=NW.breaks,include.lowest=TRUE)<br/>R&gt; as.numeric(NW.fac)<br/>  [1] 3 4 3 4 3 3 3 4 3 3 2 4 3 3 4 4 4 5 4 3 4 4 5 4 3 3 4 4 2 3 5<br/> [32] 3 2 3 4 1 3 5 5 3 3 5 4 3 4 5 3 2 3 4 5 3 4 3 3 4 3 3 3 4 2 3<br/> [63] 2 3 3 3 3 4 3 5 3 3 3   --<span class="codeitalic">snip</span>-<br/>R&gt; NW.cols &lt;- ryc[as.numeric(NW.fac)]<br/>R&gt; NW.cols<br/>  [1] "#BC7700" "#D5B200" "#BC7700" "#D5B200" "#BC7700" "#BC7700"<br/>  [7] "#BC7700" "#D5B200" "#BC7700" "#BC7700"   --<span class="codeitalic">snip</span>--</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_639"/>You’re ready to plot; the result of the following is given on the left of <a href="ch25.xhtml#ch25fig4">Figure 25-4</a>:</p>&#13;
<pre>R&gt; plot(surv$Wr.Hnd,surv$Height,col=NW.cols,pch=19)</pre>&#13;
<div class="image"><img src="../images/f25-04.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig4"/>Figure 25-4: Illustrating two ways to assign color to points based on a continuous value: via categorization (left) and via normalization (right)</em></p>&#13;
<h5 class="h5" id="ch25lev3sec110"><strong>Via Normalization</strong></h5>&#13;
<p class="noindent">Using categorization to index a continuum with color is a little unsophisticated. There are plenty of ways you can bin your observations, for example, so your plot might look very different from the same plot designed by someone else. In a computational sense, it’s more accurate (not to mention elegant) to leave your continuous data as is.</p>&#13;
<p class="indent">Recall the built-in <code>gray</code> palette mentioned in <a href="ch25.xhtml#ch25lev2sec243">Section 25.1.2</a>. This function behaved a little differently from the others. Instead of simply asking for a number of colors from the specified palette, you’re required to provide a numeric vector of values to tell R, on a continuous scale from 0 through 1, how “far along” the palette to go. This type of behavior suits the current task perfectly, since your raw data are also on a continuous scale. To implement it, you need two things: a way to create a palette that will behave like <code>gray</code> and a <em>normalized</em> version of your continuous values that fall within the acceptable standardized range of 0 to 1 inclusive.</p>&#13;
<p class="indent">The <code>colorRamp</code> function allows you to create your palette and is used in the same way as <code>colorRampPalette</code>, but the result is a color palette function that expects a numeric vector as stated. You’ll see that in a moment. To transform a collection of <em>n</em> original values {<em>x</em><sub>1</sub>, ..., <em>x</em><sub>n</sub>} to, say, {<em>z</em><sub>1</sub>, ..., <em>z</em><sub>n</sub>}, where 0 ≤ <em>z<sub>i</sub></em> ≤ 1; <em>i</em> = 1, ..., <em>n</em>, you can employ the following equation:</p>&#13;
<div class="imagec"><a id="ch25eq1"/><img src="../images/e25-1.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_640"/>Let’s make that an R function by writing the following in the R editor:</p>&#13;
<pre>normalize &lt;- function(datavec){<br/>    lo &lt;- min(datavec,na.rm=TRUE)<br/>    up &lt;- max(datavec,na.rm=TRUE)<br/>    datanorm &lt;- (datavec-lo)/(up-lo)<br/>    return(datanorm)<br/>}</pre>&#13;
<p class="indent">Based on a vector <code>datavec</code> as its only argument, <code>normalize</code> implements <a href="ch25.xhtml#ch25eq1">Equation (25.1)</a>, using the optional <code>na.rm</code> argument to ensure any missing values in <code>datavec</code> don’t contaminate the calculation of the minimum and maximum values (see <a href="ch13.xhtml#ch13lev2sec116">Section 13.2.1</a>).</p>&#13;
<p class="indent">Import <code>normalize</code> and enter the following, which shows the original nonwriting handspan values (from the object <code>surv</code> you created earlier) and their corresponding normalized values (output snipped for brevity):</p>&#13;
<pre>R&gt; surv$NW.Hnd<br/>  [1] 18.0 20.5 18.9 20.0 17.7 17.7 17.3 19.5 18.5 17.2 16.0 20.2<br/> [13] 17.0 18.0 19.2 20.5 20.9 22.0 20.7    --<span class="codeitalic">snip</span>-<br/>R&gt; normalize(surv$NW.Hnd)<br/>  [1] 0.50000000 0.72727273 0.58181818 0.68181818 0.47272727<br/>  [6] 0.47272727 0.43636364 0.63636364     --<span class="codeitalic">snip</span>--</pre>&#13;
<p class="indent">Now, you need to create a new version of the color palette with <code>colorRamp</code>.</p>&#13;
<pre>R&gt; NW.pal2 &lt;- colorRamp(colors=c("red4","yellow2"))</pre>&#13;
<p class="indent">Generate the corresponding colors for each observation based on the normalized data.</p>&#13;
<pre>R&gt; ryc2 &lt;- NW.pal2(normalize(surv$NW.Hnd))</pre>&#13;
<p class="indent">If you actually look at the returned object in <code>ryc2</code>, you’ll note it’s a matrix of RGB triplets corresponding to each normalized value you supplied to your <code>colorRamp</code> function <code>NW.pal2</code> (noninteger values end up being coerced to integers). These need to be converted to hex codes before you can use them in plotting. Using <code>rgb</code> just as you saw in <a href="ch25.xhtml#ch25lev2sec242">Section 25.1.1</a>, you get the vector you need (snipped for print).</p>&#13;
<pre>R&gt; NW.cols2 &lt;- rgb(ryc2,maxColorValue=255)<br/>R&gt; NW.cols2<br/>  [1] "#BC7700" "#D3AD00" "#C48A00" "#CEA200" "#B97000" "#B97000"<br/>  [7] "#B66700" "#CA9700" "#C18100" "#B56500"   --<span class="codeitalic">snip</span>--</pre>&#13;
<p class="indent">Note the difference between the hex codes you obtain here in <code>NW.cols2</code> and those in <code>NW.cols</code>. Here, you get a hex code for each unique value, but <span epub:type="pagebreak" id="page_641"/>for the categorized <code>NW.cols</code>, you have only one hex code for each bin (so just <em>k</em> = 5 colors).</p>&#13;
<p class="indent">This line produces the image on the right of <a href="ch25.xhtml#ch25fig4">Figure 25-4</a>.</p>&#13;
<pre>R&gt; plot(surv$Wr.Hnd,surv$Height,col=NW.cols2,pch=19)</pre>&#13;
<p class="indent">In terms of this relatively simple example, the visual difference between the two approaches is minimal, though looking closely you can indeed pick out the smoother color transition in the normalized version. As you increase <em>k</em> when using the categorization technique, the visual result will become closer to that of the normalization approach. That said, the normalization approach should generally be preferred, since it more closely fits the continuous nature of the values you’re trying to visualize, and it works more effectively for values with a skewed distribution or when you’re working with a complex color palette.</p>&#13;
<h4 class="h4" id="ch25lev2sec246"><strong><em>25.1.5 Including a Color Legend</em></strong></h4>&#13;
<p class="noindent">Now that you can use color to significant effect in your plots, you need a legend to reference the color scale. It’s possible to create a legend using base R tools alone, but it can be simpler to use contributed functionality in R instead.</p>&#13;
<p class="indent">One useful function for this is the <code>colorlegend</code> command. This is found in the <code>shape</code> package (<a href="ref.xhtml#ref62">Soetaert, 2014</a>), so first download and install <code>shape</code> from CRAN. The following code then loads the package, reproduces the most recent plot (based on the <code>surv</code> object created earlier and shown on the right of <a href="ch25.xhtml#ch25fig4">Figure 25-4</a>) with some tidier axis titles, and draws the color strip legend:</p>&#13;
<pre>R&gt; library("shape")<br/>R&gt; plot(surv$Wr.Hnd,surv$Height,col=NW.cols2,pch=19,<br/>        xlab="Writing handspan (cm)",ylab="Height (cm)")<br/>R&gt; colorlegend(NW.pal(200),zlim=range(surv$NW.Hnd),zval=seq(13,23,by=2),<br/>               posx=c(0.3,0.33),posy=c(0.5,0.9),main="Nonwriting handspan")</pre>&#13;
<p class="indent">This result is given on the left of <a href="ch25.xhtml#ch25fig5">Figure 25-5</a>.</p>&#13;
<p class="indent">The <code>colorlegend</code> functions assumes that you already have a plot present in an active graphics device, so you need to have one created first. The first thing you supply to <code>colorlegend</code> is the color span of the values you want to reference. This is easiest with a color palette function like those listed in the help file <code>?rainbow</code> or created using <code>colorRampPalette</code>—in other words, a function that takes an integer value telling it how many colors to generate. Doing so with a large number of colors gives you a smooth color strip, so I use <code>NW.pal(200)</code>. Next, you provide <code>colorlegend</code> with the range of the values that will be referenced by the legend using <code>zlim</code>, in this case, the range of the nonwriting handspans <code>range(surv$NW.Hnd)</code>. The <code>zval</code> argument takes in the values that you want to mark off on the legend. The values of a sequence between 13 and 23, in steps of 2, are marked off.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_642"/><img src="../images/f25-05.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig5"/>Figure 25-5: Two examples of implementing a color strip legend using the</em> <code>colorlegend</code> <em>function from the contributed</em> <code>shape</code> <em>package</em></p>&#13;
<p class="indent">The positioning and sizing of the color legend are done using the <code>posx</code> and <code>posy</code> arguments. Rather than taking user coordinates, each of these must be a vector of length 2 describing, in <em>relative device coordinates</em>, the horizontal (<code>posx</code>) and vertical (<code>posy</code>) lengths of the strip. In this example, <code>posx=c(0.3,0.33)</code> tells the function to draw the width of the legend from 30 percent of the left of the device to 33 percent so that the width is 3 percent of the overall device and positioned to the left of the center. Setting <code>posy=c(0.5,0.9)</code> says you want the length of the strip to span 40 percent of the device, from 50 percent of the way up from the bottom to 90 percent and up. Lastly, you can add the title to the legend by supplying a character string to <code>main</code>.</p>&#13;
<p class="indent">You’ll probably need to experiment a bit in a trial-and-error fashion to get the positioning and sizing (and appropriate tick marks using <code>zval</code>) you want. The device-specific nature of <code>posx</code> and <code>posy</code> means that if you resize your device, you might well need to reevaluate the values of these arguments.</p>&#13;
<p class="indent">If you wanted the legend to appear outside the default plot region, you could easily use the <code>xlim</code> argument in the initial call to <code>plot</code> to widen the horizontal size of the plot, giving you extra space to draw a full-length legend. Alternatively, you could’ve changed the figure or outer margin spacing (refer to <a href="ch23.xhtml#ch23lev1sec77">Section 23.2</a>) to give you enough room to put the legend outside the plot region. This next chunk of code does just that by widening the right margin, replotting the scatterplot, and inserting a color legend into that extra space.</p>&#13;
<pre>R&gt; par(mar=c(5,4,4,6))<br/>R&gt; plot(surv$Wr.Hnd,surv$Height,col=NW.cols2,pch=19,<br/>        xlab="Writing handspan (cm)",ylab="Height (cm)")<br/>R&gt; colorlegend(NW.pal(200),zlim=range(surv$NW.Hnd),zval=13.5:22.5,digit=1,<br/>               posx=c(0.89,0.91),main="Nonwriting\nhandspan")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_643"/>The result is given on the right of <a href="ch25.xhtml#ch25fig5">Figure 25-5</a>. The legend is narrower than before, taking up only 2 percent of the device width on the right with <code>posx=c(0.89,0.91)</code>. With no specification of <code>posy</code>, <code>colorlegend</code> has used the default of <code>c(0.05,0.9)</code>, giving a color strip that spans almost the entire height of the device. The tick marks and labeling of the new legend are now placed in increments of 1 from 13.5 to 22.5; note that to display decimal places (in other words, <em>significant digits</em>), you need to increase the <code>digit</code> argument from its default, <code>0</code>, to reveal them. Here, <code>digit=1</code> prints the tick mark labels to one decimal place.</p>&#13;
<p class="indent">There are more properties that you can control with these legends, including labeling style and tick mark positioning; see the <code>?colorlegend</code> help file for details. You may also like to investigate the similarly named function <code>color.legend</code> in the contributed <code>plotrix</code> package (<a href="ref.xhtml#ref40">Lemon, 2006</a>) for a slightly different take on drawing color legends on existing R plots.</p>&#13;
<h4 class="h4" id="ch25lev2sec247"><strong><em>25.1.6 Opacity</em></strong></h4>&#13;
<p class="noindent">Another useful skill is the ability to specify the opacity of any of the colors and color palettes discussed so far. All functions that provide the user with hex codes have an optional argument <code>alpha</code>, the valid range of which depends on the function (a quick check of the corresponding documentation will tell you). For example, the <code>rgb</code> function uses <code>maxColorValue</code> to set the upper bound on opacity, and palette functions like <code>rainbow</code> all use the normalized range from 0 through 1 (just like in the <code>ggplot2</code> plots created throughout <a href="ch24.xhtml#ch24">Chapter 24</a>).</p>&#13;
<p class="indent">By default, R assumes full opacity when you’re creating colors. However, hex codes change slightly when opacity is explicitly set using <code>alpha</code>. Rather than six characters after the <code>#</code>, eight will appear, with the last two containing the additional opacity information. Consider the following lines of code, which generate four different versions of red: default, zero opacity, 40 percent opacity (0.4 × 255 = 102), and full opacity, respectively:</p>&#13;
<pre>R&gt; rgb(cbind(255,0,0),maxColorValue=255)<br/>[1] "#FF0000"<br/>R&gt; rgb(cbind(255,0,0),maxColorValue=255,alpha=0)<br/>[1] "#FF000000"<br/>R&gt; rgb(cbind(255,0,0),maxColorValue=255,alpha=102)<br/>[1] "#FF000066"<br/>R&gt; rgb(cbind(255,0,0),maxColorValue=255,alpha=255)<br/>[1] "#FF0000FF"</pre>&#13;
<p class="indent">Note that the first and last colors are identical; it’s just that the last hex code explicitly specifies full opacity.</p>&#13;
<p class="indent">You can always adjust the opacity of any color you’ve already got with the <code>alpha.f</code> argument (which takes values in the range 0 through 1) of the ready-to-use <code>adjustcolor</code> function. The following line takes the default red <span epub:type="pagebreak" id="page_644"/>hex code created by the first line in the previous example and turns it into a 40 percent opaque version (the third line in the previous code):</p>&#13;
<pre>R&gt; adjustcolor(rgb(cbind(255,0,0),maxColorValue=255),alpha.f=0.4)<br/>[1] "#FF000066"</pre>&#13;
<p class="indent">You briefly came across this command already in <a href="ch24.xhtml#ch24lev2sec238">Section 24.2.1</a>, when creating a transparent gray confidence interval for a LOESS-smoothed trend using base R graphics. This approach is also applicable to hex codes generated after you’ve used a built-in or custom palette function to obtain a vector of colors.</p>&#13;
<p class="indent">You’ll put opacity to the test using the built-in <code>quakes</code> data frame, which consists of data on 1,000 seismic events near Fiji. Let’s re-create the plot in <a href="ch13.xhtml#ch13fig6">Figure 13-6</a> on <a href="ch13.xhtml#page_284">page 284</a> showing “number of detecting stations” against “event magnitude” and dress it up using color to identify the continuous “depth” data. Since there are many overlapping observations, reducing opacity of the individual points would be a good idea for visualization. The code</p>&#13;
<pre>R&gt; keycols &lt;- c("blue","red","yellow")<br/>R&gt; depth.pal &lt;- colorRampPalette(keycols)<br/>R&gt; depth.pal2 &lt;- colorRamp(keycols)</pre>&#13;
<p class="noindent">sets up a custom three-color palette both ways (in other words, as a function expecting an integer, <code>depth.pal</code>, and as a function expecting a value between 0 and 1, <code>depth.pal2</code>; refer to <a href="ch25.xhtml#ch25lev2sec244">Sections 25.1.3</a> and <a href="ch25.xhtml#ch25lev2sec245">25.1.4</a>). Then, the following line uses the normalization approach, with the <code>normalize</code> function defined in <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>, to obtain the appropriate colors for the points to be plotted, according to the “depth” variable of the data set:</p>&#13;
<pre>R&gt; depth.cols &lt;- rgb(depth.pal2(normalize(quakes$depth)),maxColorValue=255,<br/>                     alpha=0.6*255)</pre>&#13;
<p class="indent">The request for 60 percent opacity is made through <code>alpha</code> in the call to <code>rgb</code>. You can create the plot with the following call, which assigns the colors stored in <code>depth.cols</code>:</p>&#13;
<pre>R&gt; plot(quakes$mag,quakes$stations,pch=19,cex=2,col=depth.cols,<br/>        xlab="Magnitude",ylab="No. of stations")</pre>&#13;
<p class="indent">This plot affords another opportunity to showcase the <code>colorlegend</code> function from the <code>shape</code> package. Assuming you have <code>shape</code> already loaded in the current R session, the next line draws a corresponding color legend inside the plot region (on a default-size device):</p>&#13;
<pre>R&gt; colorlegend(adjustcolor(depth.pal(20),alpha.f=0.6),<br/>               zlim=range(quakes$depth),zval=seq(100,600,100),<br/>               posx=c(0.3,0.32),posy=c(0.5,0.9),left=TRUE,main="Depth")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_645"/>Here you can see another demonstration of the use of <code>adjustcolor</code>, where the color sequence generated with the call to <code>depth.pal(20)</code> is then reduced to 60 percent opacity to match the plotted points. Again, <code>posx</code> and <code>posy</code> are used to position the legend, and the optional logical argument <code>left</code> is set to <code>TRUE</code> to make the tick marks and color legend labels appear on the left side of the strip. <a href="ch25.xhtml#ch25fig6">Figure 25-6</a> shows the final result.</p>&#13;
<div class="image"><img src="../images/f25-06.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig6"/>Figure 25-6: Altering the color opacity in a custom palette, used to index the continuous “event depth” observations in a plot of “number of stations” against “magnitude” for the</em> <code>quakes</code> <em>data set, and a corresponding color legend using</em> <code>colorlegend</code> <em>from the</em> <code>shape</code> <em>package</em></p>&#13;
<h4 class="h4" id="ch25lev2sec248"><strong><em>25.1.7 RGB Alternatives and Further Functionality</em></strong></h4>&#13;
<p class="noindent">RGB triplets aren’t the only way color can be represented in R. Other specifications include hue-saturation-value (HSV) and hue-chroma-luminance (HCL), available through the built-in <code>hsv</code> and <code>hcl</code> functions. These work in much the same way as <code>rgb</code>, where you specify the strength of influence of the three components and out pop corresponding character string hex codes that form valid R colors for any relevant plotting command. In fact, the HSV parameterization is what’s used internally by the built-in palettes detailed in <a href="ch25.xhtml#ch25lev2sec243">Section 25.1.2</a>, such as <code>rainbow</code> and <code>heat.colors</code>.</p>&#13;
<p class="indent">Contributed functionality offers even more flexibility. The <code>colorspace</code> package (<a href="ref.xhtml#ref34">Ihaka et al., 2015</a>), which translates between different color formats, is worth noting, as is <code>RColorBrewer</code> (<a href="ref.xhtml#ref51">Neuwirth, 2014</a>), which is based directly on the well-received color schemes designed by Cynthia Brewer (see <em><a href="http://colorbrewer2.org/">http://colorbrewer2.org/</a></em>). <code>RColorBrewer</code> provides more options for creating palettes than are supplied by the built-in functionality <code>colorRampPalette</code> and <span epub:type="pagebreak" id="page_646"/><code>colorRamp</code>. That said, from an introductory perspective, you should find the use of RGB and the base R functionality as discussed here sufficient for most visual explorations of your data and models.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch25exc1"/><strong>Exercise 25.1</strong></p>&#13;
<p class="noindentz">Ensure the <code>car</code> package is loaded. Revisit the <code>Salaries</code> data frame you looked at in <a href="ch24.xhtml#ch24exc1">Exercises 24.1</a> (<a href="ch24.xhtml#page_622">page 622</a>) and <a href="ch24.xhtml#ch24exc2">24.2</a> (<a href="ch24.xhtml#page_628">page 628</a>) and take a look at the help file <code>?Salaries</code> to remind yourself of the variables. Your task is to use color, point size, opacity, and point character type to reflect “years since Ph.D.,” “sex,” and “rank” in a scatterplot of “salary” against “years of service,” by completing the following steps:</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Set up a custom color palette that goes from <code>"black"</code> to <code>"red"</code> to <code>"yellow2"</code>. Create two versions of this palette—one that expects a number of colors and one that expects a vector of normalized values between 0 and 1.</p></li>&#13;
<li><p class="noindents">Create two vectors that will control point character and character expansion following the guidelines in (i) and (ii). Each of these can be achieved in a single line by vector subsetting/repetition based on a numeric coercion of the corresponding factor vector in the data frame.</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Use the point characters <code>19</code>, <code>17</code>, and <code>15</code> to reference the three increasing academic ranks in that order.</p></li>&#13;
<li><p class="noindents">Use a character expansion of <code>1</code> for females and a character expansion of <code>1.5</code> for males.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Use the <code>normalize</code> function defined in <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a> to create a [0,1] normalized version of the range of values of the “years since Ph.D.” variable. Then use the appropriate palette from (a) along with <code>rgb</code> to convert these to the required hex codes.</p></li>&#13;
<li><p class="noindents">Modify the vector of colors you just created in (c), adjusting opacity. Colors in the vector that correspond to females should be reduced to 90 percent opacity; colors that correspond to males should be reduced to 30 percent opacity.</p></li>&#13;
<li><p class="noindents">Now, start the plot; alter the default figure margins to be 5, 4, 4, and 6 lines wide on the bottom, left, top, and right, respectively. Plot salary on the <em>y</em>-axis against years of service on the <em>x</em>-axis. Set the corresponding point colors according to your vector from (d) and the point characters and character expansion according to your vectors from (b). Tidy up the <em>x</em>-axis and <em>y</em>-axis titles.</p></li>&#13;
<li><p class="noindents">Incorporate two separate legends following the guidelines in (i) and (ii). Both legends should be horizontal, and you should relax clipping to allow their placement in figure margins (refer to <a href="ch23.xhtml#ch23lev2sec228">Section 23.2.3</a>).</p>&#13;
<ol type="i">&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_647"/>Place the first legend at the user coordinate given by <code>x=-5</code> and <code>y=265000</code>. It should use the levels of the “rank” factor vector as the referencing text and pair these with the corresponding <code>pch</code> symbols as assigned. Include an appropriate title for the legend.</p></li>&#13;
<li><p class="noindents">The second legend should be placed next to the first, using an <em>x</em>-coordinate of <code>40</code> and the same <em>y</em>-coordinate value. This legend should show two points, both red and of type <code>19</code>, but reference the two levels of sex by altering the character expansion and opacity of these to reference points as assigned.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Lastly, ensure the <code>shape</code> package is loaded and use the <code>colorlegend</code> function along with 50 colors generated from the appropriate palette from (a) to reference “years since Ph.D.” You can leave the horizontal and vertical placements of the legend at their default values. The <code>zlim</code> range should simply be set to match the range of the observed data, and the tick mark values set via <code>zval</code> should be a sequence between 10 and 50, increasing in steps of 10. Include an appropriate title for the color legend.</p>&#13;
<p class="noindentz">After all this, my version of this plot is given here:</p>&#13;
<div class="imagec"><img src="../images/f0647-01.jpg" alt="image"/></div></li>&#13;
</ol>&#13;
<p class="noindentz">Your next task is a little different. The goal is to plot a standard normal probability density function but use color to shade in polygons underneath the curve to denote “distance from mean.” To achieve this, complete the following:</p>&#13;
<ol type="a" start="8">&#13;
<li><p class="noindents">Generate a vector of exactly 25 colors from the built-in palette <code>terrain.colors</code> and name it <code>tcols</code>. Then, using a reversed version <span epub:type="pagebreak" id="page_648"/>of it obtained via <code>tcols[25:1]</code>, append the two vectors together to form a new vector of length 50 containing the first 25 colors shading one way and then the same 25 shading the opposite way.</p></li>&#13;
<li><p class="noindents">Next, create and store an evenly spaced sequence of exactly 51 values between −3 and 3 inclusive; name it <code>vals</code>. Use <code>dnorm</code> to calculate and store the corresponding 51 values of the standard normal density curve; name it <code>normvals</code>.</p></li>&#13;
<li><p class="noindents">Draw the normal density curve by plotting the values in (i) as a line (recall <code>type="l"</code>). In the same call to <code>plot</code>, use knowledge from <a href="ch23.xhtml#ch23">Chapter 23</a> to set both the <em>x</em>-axis and <em>y</em>-axis styles to be of type <code>"i"</code>; suppress both axis titles with empty strings; change the surrounding box to be an <em>L</em> shape; and suppress the drawing of the <em>x</em>-axis. Give the plot a suitable main title.</p></li>&#13;
<li><p class="noindents">To shade the different colors underneath the curve, use a <code>for</code> loop, iterating through the integers 1 to 50. At each iteration, the loop should call <code>polygon</code> (refer to <a href="ch15.xhtml#ch15lev2sec135">Section 15.2.3</a>). Assuming your indexer is <code>i</code>, the vertices of each polygon should be formed by the vectors <code>vals[rep(c(i,i+1),each=2)]</code> and <code>c(0,normvals[c(i,i+1)],0)</code>. Each polygon should suppress its border and be colored according to the relevant <code>i</code>th entry in your color vector of length 50 created in (h).</p></li>&#13;
<li><p class="noindents">Lastly, ensure the <code>shape</code> package has been loaded and use your length 50 color vector to produce a color legend with default placement to reference “distance from mean.” You can easily set the <code>zlim</code> and <code>zval</code> arguments in the call to <code>colorlegend</code> using <code>vals</code>. Include an appropriate title for the legend. For reference, my result is given here:</p></li>&#13;
</ol>&#13;
<div class="imagec"><img src="../images/f0648-01.jpg" alt="image"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch25lev1sec87"><span epub:type="pagebreak" id="page_649"/><strong>25.2 3D Scatterplots</strong></h3>&#13;
<p class="noindent">This section will look at creating 3D scatterplots, which allow you to plot raw observations based on three continuous variables at once, as opposed to only two in a conventional 2D scatterplot. You’ll then learn how to enhance your 3D scatterplot to represent more variables and make it easier to interpret. There are several ways to create three-variable scatterplots in R, but the go-to method is usually the <code>scatterplot3d</code> function in the contributed package of the same name (<a href="ref.xhtml#ref42">Ligges and Mächler, 2003</a>).</p>&#13;
<h4 class="h4" id="ch25lev2sec249"><strong><em>25.2.1 Basic Syntax</em></strong></h4>&#13;
<p class="noindent">The syntax of the <code>scatterplot3d</code> function is similar to the default <code>plot</code> function. In the latter, you supply a vector of <em>x</em>- and <em>y</em>-axis coordinates; in the former, you merely supply an additional third vector of values providing the <em>z</em>-axis coordinates. With that additional dimension, you can think of these three axes in terms of the <em>x</em>-axis increasing from left to right, the <em>y</em>-axis increasing from foreground to background, and the <em>z</em>-axis increasing from bottom to top.</p>&#13;
<p class="indent">Install and load the <code>scatterplot3d</code> package, and let’s go straight into an example. Recall the famous iris flower data, which you first encountered in <a href="ch14.xhtml#ch14lev1sec47">Section 14.4</a>. This data set contains measurements on four continuous variables (petal length/width and sepal length/width) and one categorical variable (flower species); the <code>iris</code> data frame is immediately accessible from the R prompt, so there’s no need to load anything. Enter the following so you have quick access to the measurement values that make up the data:</p>&#13;
<pre>R&gt; pwid &lt;- iris$Petal.Width<br/>R&gt; plen &lt;- iris$Petal.Length<br/>R&gt; swid &lt;- iris$Sepal.Width<br/>R&gt; slen &lt;- iris$Sepal.Length</pre>&#13;
<p class="indent">The most basic 3D scatterplot of, say, petal length, petal width, and sepal width, is achieved with the following:</p>&#13;
<pre>R&gt; library("scatterplot3d")<br/>R&gt; scatterplot3d(x=pwid,y=plen,z=swid)</pre>&#13;
<p class="indent">It’s as simple as that—the result of this code is given on the left of <a href="ch25.xhtml#ch25fig7">Figure 25-7</a>. Here you can observe a general positive relationship among all three plotted variables. There’s also a clearly isolated cluster of observations in the foreground that have relatively large sepal widths but small petal measurements.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_650"/><img src="../images/f25-07.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig7"/>Figure 25-7: Two 3D scatterplots of the famous</em> <code>iris</code> <em>data with petal width, petal length, and sepal width on the</em> x<em>-,</em> y<em>-, and</em> z<em>-axis, respectively. Left: Basic default appearance. Right: Tidying up titles and adding visual enhancements to emphasize 3D depth and legibility via color and vertical line marks.</em></p>&#13;
<h4 class="h4" id="ch25lev2sec250"><strong><em>25.2.2 Visual Enhancements</em></strong></h4>&#13;
<p class="noindent">It can be difficult to clearly perceive depth in the plotted cloud of points, even with the box and <em>x</em>-<em>y</em> plane grid lines that are drawn by default. For this reason, there are a couple of optional enhancements you can make to a <code>scatterplot3d</code> plot—coloring the points to help make the transition from foreground to background clearer and setting the <code>type="h"</code> argument to draw lines perpendicular to the <em>x</em>-<em>y</em> plane.</p>&#13;
<p class="indent">The right-hand plot in <a href="ch25.xhtml#ch25fig7">Figure 25-7</a> shows the plot with these enhancements and is the result of the following:</p>&#13;
<pre>R&gt; scatterplot3d(x=pwid,y=plen,z=swid,highlight.3d=TRUE,type="h",<br/>                 lty.hplot=2,lty.hide=3,xlab="Petal width",<br/>                 ylab="Petal length",zlab="Sepal width",<br/>                 main="Iris Flower Measurements")</pre>&#13;
<p class="indent"><code>xlab</code>, <code>ylab</code>, <code>zlab</code>, and <code>main</code> control the corresponding titles of the three axes and the plot itself.</p>&#13;
<p class="indent">The vertical lines make reading the values of the points much easier. By default, those lines in a <code>type="h"</code> plot are solid, but you can alter this with the <code>lty.hplot</code> argument (which behaves in the same way as the standard graphical parameter <code>lty</code>); setting <code>lty.hplot=2</code> requests dashed lines. Similarly, you can alter the line type of the “nonvisible” sides of the box; setting <code>lty.hide=3</code> instructs the plot to draw those lines as dotted.</p>&#13;
<p class="indent">Setting <code>highlight.3d=TRUE</code> emphasizes 3D depth by applying color transitioning from red to black based on the <em>y</em>-axis position of a point. This is useful, but there’s an important consequence—it means you can no longer use color to represent a fourth variable with such a plot.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_651"/>Along that line of thought, remember that the <code>iris</code> data has a fourth continuous variable, sepal length (stored as <code>slen</code> in <a href="ch25.xhtml#ch25lev2sec249">Section 25.2.1</a>), that you’re not displaying in either of the plots in <a href="ch25.xhtml#ch25fig7">Figure 25-7</a>. You’re also not displaying the categorical variable of flower species, so let’s fix that. First, set up a color band for the missing measurement variable, using your knowledge of having color palettes reference a continuous variable from <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>.</p>&#13;
<pre>R&gt; keycols &lt;- c("purple","yellow2","blue")<br/>R&gt; slen.pal &lt;- colorRampPalette(keycols)<br/>R&gt; slen.pal2 &lt;- colorRamp(keycols)<br/>R&gt; slen.cols &lt;- rgb(slen.pal2(normalize(slen)),maxColorValue=255)</pre>&#13;
<p class="indent">Note that for the last line to run, you’ll need to have the <code>normalize</code> function defined in <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a> available in your current session.</p>&#13;
<p class="indent">The following code produces the 3D scatterplot, which also uses the <code>pch</code> argument to distinguish among the three different species:</p>&#13;
<pre>R&gt; scatterplot3d(x=pwid,y=plen,z=swid,color=slen.cols,<br/>                 pch=c(19,17,15)[as.numeric(iris$Species)],type="h",<br/>                 lty.hplot=2,lty.hide=3,xlab="Petal width",<br/>                 ylab="Petal length",zlab="Sepal width",<br/>                 main="Iris Flower Measurements")</pre>&#13;
<p class="indent">I’ve used the vector <code>c(19,17,15)</code>, with the numeric coercion of the <code>iris$Species</code> vector passed to the square brackets, to pair <code>pch</code> character numbers as follows: <code>19</code> with <em>Iris setosa</em> (the first level of the factor), <code>17</code> with <em>Iris versicolor</em> (the second level), and <code>15</code> with <em>Iris virginica</em> (the third level), respectively (refer to <a href="ch07.xhtml#ch7fig5">Figure 7-5</a> on <a href="ch07.xhtml#page_133">page 133</a> for the different types of point characters).</p>&#13;
<p class="indent">You can then insert a legend referencing species with a familiar call to <code>legend</code>.</p>&#13;
<pre>R&gt; legend("bottomright",legend=levels(iris$Species),pch=c(19,17,15))</pre>&#13;
<p class="indent">And with a little experimentation, you can include a color strip legend too (making sure you’ve loaded the <code>shape</code> package so you have access to the <code>colorlegend</code> function as per <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>).</p>&#13;
<pre>R&gt; colorlegend(slen.pal(200),zlim=range(slen),zval=5:7,digit=1,<br/>               posx=c(0.1,0.13),posy=c(0.7,0.9),left=TRUE,<br/>               main="Sepal length")</pre>&#13;
<p class="indent">The final result of all this is the image in <a href="ch25.xhtml#ch25fig8">Figure 25-8</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_652"/><img src="../images/f25-08.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig8"/>Figure 25-8: A 3D scatterplot of the famous</em> <code>iris</code> <em>data, displaying all five present variables with the additional use of color (for sepal length) and point character (for species).</em></p>&#13;
<p class="indent">With the creative use of color and point type, you’ve now been able to display the five-dimensional data in a single 3D scatterplot. This reveals important information about the data. For instance, you can now identify <em>Iris setosa</em> as the clearly separate group of points in the foreground and see that while <em>Iris setosa</em> tend to have smaller petal widths and lengths and larger sepal widths than the other two species (especially <em>Iris versicolor</em>), the purple coloring at the lower end of the scale suggests they tend to have smaller sepal lengths.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch25exc2"/><strong>Exercise 25.2</strong></p>&#13;
<p class="noindentz">Ensure the <code>scatterplot3d</code> library has been loaded in your current R session.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Turn your attention back to the <code>diabetes</code> data frame found in the <code>faraway</code> package (you first looked at these data in <a href="ch21.xhtml#ch21lev2sec203">Section 21.5.2</a>). Your goal is to produce a <code>scatterplot3d</code> plot of weight, hip, and waist measurements as per the following guidelines:</p>&#13;
<p class="dash">– Hip, waist, and weight variables should correspond to the <em>x</em>-axis, <em>y</em>-axis, and <em>z</em>-axis, respectively; provide neat axis titles.</p>&#13;
<p class="dash">– Use built-in functionality to ensure the 3D depth is highlighted by color.</p>&#13;
<p class="dash"><span epub:type="pagebreak" id="page_653"/>– Choose two different point characters to reflect gender.</p>&#13;
<p class="dash">– Place a simple legend referencing these two point characters and gender in the blank space in the upper-left area.</p></li>&#13;
<li><p class="noindents">Create a 3D scatterplot of the built-in <code>airquality</code> data, which you first met in <a href="ch24.xhtml#ch24lev2sec239">Section 24.2.2</a>, according to the following guidelines:</p>&#13;
<p class="dash">– Create a copy of the data frame using <code>na.omit</code> to remove all rows that contain missing values and work with this copy.</p>&#13;
<p class="dash">– Plot wind speed and solar radiation against the <em>x</em>- and <em>y</em>-axes, respectively, using the <em>z</em>-axis to plot temperature.</p>&#13;
<p class="dash">– Apply vertical dotted lines reaching up from the <em>x</em>-<em>y</em> plane to each observation.</p>&#13;
<p class="dash">– The data in <code>airquality</code> are comprised of measurements taken over five months, from May to September. Each plotted point should take on the corresponding <code>pch</code> value from <code>1</code> to <code>5</code> respective to the order of these five months.</p>&#13;
<p class="dash">– With a vector of 50 colors generated from the built-in <code>topo.colors</code> palette, use the categorization approach to ensure each plotted point is colored according to its ozone value.</p>&#13;
<p class="dash">– Set a legend to reference the five point types according to month.</p>&#13;
<p class="dash">– Set a color legend (using functionality from the <code>shape</code> package) to reference the ozone value accordingly.</p>&#13;
<p class="dash">– Ensure the plot has neat axis, main, and legend titles.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch25lev1sec88"><strong>25.3 Preparing a Surface for Plotting</strong></h3>&#13;
<p class="noindent">In the rest of this chapter, you’ll look at three types of 3D plots geared to visualize a <em>bivariate surface</em>. Such plots are required when you have two variables, based on which a function, estimate, or model has been defined, and you want to use the third available axis (in other words, the <em>z</em>-axis) to map out the resulting surface. You’ve seen examples of bivariate functions already, through the response surfaces for the <code>mtcars</code> data in <a href="ch21.xhtml#ch21lev2sec205">Section 21.5.4</a> (where you looked at mean MPG as a function of car weight and horsepower) and through the study of diagnostic tools for linear regression models in <a href="ch22.xhtml#ch22lev2sec219">Section 22.3.6</a> (where you saw how Cook’s distance can be expressed as a function of residual and leverage).</p>&#13;
<p class="indent">Before you look at producing these plots, it’s important to understand how they’re created in R. The function/estimate/model of interest should be thought of as a plane or surface that can vary according to continuous, two-dimensional <em>x</em>-<em>y</em> coordinates. Plotting a completely continuous surface is technically impossible since that would require you to evaluate the function at an infinite number of coordinates. Therefore, evaluation of the surface is <span epub:type="pagebreak" id="page_654"/>typically performed on a finite <em>grid</em> of evenly spaced coordinates along both the <em>x</em>- and <em>y</em>-axes. The result of the function at each unique pair of coordinates is stored in a corresponding position in an appropriately sized matrix (the size of which depends directly upon the resolution of the evaluation grid in the <em>x</em>- and <em>y</em>-axes), generically referred to as the <em>z-matrix</em>.</p>&#13;
<p class="indent">Since all the traditional R graphics commands that plot these bivariate functions operate in the same way—using this <em>z</em>-matrix—it’s critical to understand how this matrix is constructed, arranged, and interpreted by those commands to ensure you’re correctly drawing the outcome. In this section, you’ll ready yourself for the specific plot types looked at in the remainder of this chapter by getting familiar with this construct in a hypothetical situation.</p>&#13;
<h4 class="h4" id="ch25lev2sec251"><strong><em>25.3.1 Constructing an Evaluation Grid</em></strong></h4>&#13;
<p class="noindent">Say you have a bivariate function that results in a continuous surface that’s defined between 1 and 6 on the <em>x</em>-axis and 1 and 4 on the <em>y</em>-axis. You can define evenly spaced sequences over each of these coordinate ranges using <code>seq</code>; for simplicity, let’s just do so in straight-out integers.</p>&#13;
<pre>R&gt; xcoords &lt;- 1:6<br/>R&gt; xcoords<br/>[1] 1 2 3 4 5 6<br/>R&gt; ycoords &lt;- 1:4<br/>R&gt; ycoords<br/>[1] 1 2 3 4</pre>&#13;
<p class="indent">What this implies is that you’re planning to draw your surface based on evaluation of the bivariate function of interest upon the grid of <em>x</em>-<em>y</em> values defined by 24 unique positions.</p>&#13;
<p class="indent">When passed two vectors, the built-in <code>expand.grid</code> function explicitly generates all unique coordinate pairs by simply repeating each value in the second vector against the entire length of the first vector.</p>&#13;
<pre>R&gt; xycoords &lt;- expand.grid(x=xcoords,y=ycoords)</pre>&#13;
<p class="indent">The result is stored as a two-column data frame with 24 rows. If you look at <code>xycoords</code> object in the R console, you’ll see <code>x</code> values from <code>1</code> to <code>6</code> all paired with a repeated <code>y</code> value of <code>1</code>, then <code>x</code> from <code>1</code> to <code>6</code> paired with <code>y</code> as <code>2</code>, and so on.</p>&#13;
<p class="indent">In practice, what you’d now do is use the evaluation grid coordinates in <code>xycoords</code> to calculate the result of your bivariate function. For this hypothetical example, let’s just say that your bivariate function has resulted in the 24 letters <em>a</em> to <em>x</em>, corresponding to the order of the unique evaluation coordinates in <code>xycoords</code>. To make this even clearer, take a look at the following column-bind of the hypothetical function result with each evaluation <span epub:type="pagebreak" id="page_655"/>coordinate (note that the ready-to-use <code>letters</code> object in R allows you to generate letters of the alphabet quickly):</p>&#13;
<pre>R&gt; z &lt;- letters[1:24]<br/>R&gt; cbind(xycoords,z)<br/>  x y z<br/>1 1 1 a<br/>2 2 1 b<br/>3 3 1 c<br/>4 4 1 d<br/><br/>--<span class="codeitalic">snip</span>--<br/><br/>21 3 4 u<br/>22 4 4 v<br/>23 5 4 w<br/>24 6 4 x</pre>&#13;
<p class="indent">What this emphasizes is that each unique <em>x</em>-<em>y</em> evaluation coordinate, expressible via <code>expand.grid</code>, will have a <em>z</em> value associated with it. All together, these <em>z</em> values define the resulting surface.</p>&#13;
<h4 class="h4" id="ch25lev2sec252"><strong><em>25.3.2 Constructing the z-Matrix</em></strong></h4>&#13;
<p class="noindent">The 3D plots used to visualize a bivariate function require the <em>z</em> values corresponding to the <em>x</em>-<em>y</em> evaluation grid in the form of an appropriately constructed matrix. The size of the <em>z</em>-matrix is determined directly by the resolution of the evaluation grid; the number of rows corresponds to the number of unique <em>x</em> grid values, and the number of columns corresponds to the number of unique <em>y</em> grid values.</p>&#13;
<p class="indent">You therefore need to take a little care turning your calculated <em>z</em> values into a matrix. When your vector of <em>z</em>-axis values corresponds to the evaluation grid arranged in the standard <code>expand.grid</code> fashion (in other words, where coordinates are stacked by increasing <em>x</em> values and repeated <em>y</em> values), be sure that your resulting <em>z</em>-matrix is filled in the default column-wise fashion (see <a href="ch03.xhtml#ch03lev2sec24">Section 3.1.1</a>), with the number of rows and columns being exactly representative of the number of values in each of the <em>x</em>- and <em>y</em>-value sequences, respectively (<code>xcoords</code> and <code>ycoords</code> shown earlier). In the current example, you know that the resulting <em>z</em>-matrix needs to be of size 6 × 4 because there are six <em>x</em> locations and four <em>y</em> locations.</p>&#13;
<p class="indent">The following is the correct matrix representation of the hypothetical “function result” vector <code>z</code>:</p>&#13;
<pre>R&gt; nx &lt;- length(xcoords)<br/>R&gt; ny &lt;- length(ycoords)<br/>R&gt; zmat &lt;- matrix(z,nrow=nx,ncol=ny)<br/><span epub:type="pagebreak" id="page_656"/>R&gt; zmat<br/>     [,1] [,2] [,3] [,4]<br/>[1,] "a"  "g"  "m"  "s"<br/>[2,] "b"  "h"  "n"  "t"<br/>[3,] "c"  "i"  "o"  "u"<br/>[4,] "d"  "j"  "p"  "v"<br/>[5,] "e"  "k"  "q"  "w"<br/>[6,] "f"  "l"  "r"  "x"</pre>&#13;
<h4 class="h4" id="ch25lev2sec253"><strong><em>25.3.3 Conceptualizing the z-Matrix</em></strong></h4>&#13;
<p class="noindent">The most important thing to be gained from this section is an idea of how the <em>z</em>-matrix in its current arrangement translates to <em>x</em>-<em>y</em> coordinate-based plotting. Comparing <code>zmat</code> to the earlier output, you can see that moving down a column of <code>zmat</code> translates to an increase in the <em>x</em>-coordinate value for a given <em>y</em>-coordinate value. In other words, when this hypothetical surface of letters is plotted, moving down a column of the matrix corresponds to moving horizontally from left to right on the corresponding plot, given a particular vertical <em>y</em> position.</p>&#13;
<p class="indent"><a href="ch25.xhtml#ch25fig9">Figure 25-9</a> provides a conceptual diagram of this illustrative surface, indexed by <code>zmat</code> as per the 24 unique coordinates defined via <code>xcoords</code> and <code>ycoords</code>. (The code to produce this is included in the R script files for this book, which can be found at <em><a href="https://www.nostarch.com/bookofr/">https://www.nostarch.com/bookofr/</a></em>.)</p>&#13;
<div class="image"><img src="../images/f25-09.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig9"/>Figure 25-9: Conceptual diagram of a</em> z<em>-matrix for plotting bivariate functions, based on a 6</em> × <em>4 coordinate grid</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_657"/>As you now progress to plot some actual surfaces of interest, you should keep the concept of the <em>z</em>-matrix as illustrated in <a href="ch25.xhtml#ch25fig9">Figure 25-9</a> in mind. The 6 × 4 grid used in this hypothetical example is coarse. In practice, you’ll usually use far finer grids in terms of the resolution of the <em>x</em>- and <em>y</em>-sequences to improve the visual appearance of the surface.</p>&#13;
<h3 class="h3" id="ch25lev1sec89"><strong>25.4 Contour Plots</strong></h3>&#13;
<p class="noindent">One of the most common plots used to display a surface based on evaluation of a function over a grid of bivariate coordinates is the <em>contour plot</em>. Contour plots are perhaps most easily explained as a series of lines—the contours—drawn over the 2D evaluation grid, with each contour marking off a specific level of the surface of interest.</p>&#13;
<h4 class="h4" id="ch25lev2sec254"><strong><em>25.4.1 Drawing Contour Lines</em></strong></h4>&#13;
<p class="noindent">Based on a given numeric <em>z</em>-matrix, the R function <code>contour</code> is what’s used to produce the contours connecting <em>x</em>-<em>y</em> coordinates that share the same <em>z</em> value.</p>&#13;
<h5 class="h5" id="ch25lev3sec111"><strong>Example 1: Topographical Map</strong></h5>&#13;
<p class="noindent">For an example, you’ll use another ready-to-use data set—the <code>volcano</code> object. This data set is simply a matrix containing measurements of the elevation above sea level (in meters) of a dormant volcano over a rectangular area in the Auckland region of New Zealand; see the documentation in <code>?volcano</code> for details. To view the topography, you need the <code>volcano</code> object (which is your <em>z</em>-matrix) and the relevant <em>x</em>- and <em>y</em>-coordinate sequences. In this case, just use integers corresponding to the size of the <code>volcano</code> matrix (row and column numbers can be obtained with a simple call to <code>dim</code>; see <a href="ch03.xhtml#ch03lev2sec26">Section 3.1.3</a>).</p>&#13;
<pre>R&gt; dim(volcano)<br/>[1] 87 61<br/>R&gt; contour(x=1:nrow(volcano),y=1:ncol(volcano),z=volcano,asp=1)</pre>&#13;
<p class="indent">The <em>x</em>- and <em>y</em>-sequences are provided to <code>x</code> and <code>y</code>, respectively, and the <em>z-</em>matrix to <code>z</code>. The optional argument <code>asp=1</code>, referring to the aspect ratio of the plot, forces a 1-to-1 unit treatment of the coordinate axes (this is relevant when the units have a physical size interpretation, like in plots of geographical regions—as is the case here).</p>&#13;
<p class="indent"><a href="ch25.xhtml#ch25fig10">Figure 25-10</a> shows the result of this example. By default, R automatically chooses the levels of <code>z</code> at which to draw the contours for an aesthetically pleasing result. Contours are also selectively labeled with their corresponding <em>z</em> value. Looking at the topography, you can see the highest peak is a rim on the left, marked by an oblong contour at 190 m, with a depression (at around 160 m) falling immediately to the right.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_658"/><img src="../images/f25-10.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig10"/>Figure 25-10: Using</em> <code>contour</code> <em>to produce a topographic map of the</em> <code>volcano</code> <em>data</em></p>&#13;
<p class="indent">Contours are able to show you not only the peaks and troughs in a surface like this but the “steepness” of any such features too. The closer together the contour lines lie, the more rapid the change in the overall level of the bivariate function.</p>&#13;
<h5 class="h5" id="ch25lev3sec112"><strong>Example 2: Parametric Response Surface</strong></h5>&#13;
<p class="noindent">As a different kind of example, consider the multiple linear model fitted to the <code>mtcars</code> data mentioned earlier—that is, of MPG modeled by horsepower, weight, and an interaction between the two predictors. As in <a href="ch21.xhtml#ch21lev2sec205">Section 21.5.4</a>, you can get the fitted model object with the following:</p>&#13;
<pre>R&gt; car.fit &lt;- lm(mpg~hp*wt,data=mtcars)<br/>R&gt; car.fit<br/><br/>Call:<br/>lm(formula = mpg ~ hp * wt, data = mtcars)<br/><br/>Coefficients:<br/>(Intercept)           hp            wt       hp:wt<br/>   49.80842     -0.12010      -8.21662     0.02785</pre>&#13;
<p class="indent">The goal is to plot the response, mean mileage, as the previous function of horsepower and weight. To do this, you need to evaluate the mean MPG, according to the previous model, for a grid of horsepower and weight values. The following code does exactly that.</p>&#13;
<pre>R&gt; len &lt;- 20<br/>R&gt; hp.seq &lt;- seq(min(mtcars$hp),max(mtcars$hp),length=len)<br/><span epub:type="pagebreak" id="page_659"/>R&gt; wt.seq &lt;- seq(min(mtcars$wt),max(mtcars$wt),length=len)<br/>R&gt; hp.wt &lt;- expand.grid(hp=hp.seq,wt=wt.seq)<br/>R&gt; nrow(hp.wt)<br/>[1] 400<br/>R&gt; hp.wt[1:5,]<br/>         hp    wt<br/>1  52.00000 1.513<br/>2  66.89474 1.513<br/>3  81.78947 1.513<br/>4  96.68421 1.513<br/>5 111.57895 1.513</pre>&#13;
<p class="indent">First, this code sets up evenly spaced sequences (each of length 20, spanning the range of the observed data) in both <code>hp</code> and <code>wt</code>—these are your <em>x-</em>and <em>y</em>-sequences. This implies there will be 20 × 20 = 400 unique coordinates at which you’ll be evaluating the fitted model; these coordinates are obtained using <code>expand.grid</code> as in <a href="ch25.xhtml#ch25lev1sec88">Section 25.3</a>.</p>&#13;
<p class="indent">Next, you can use <code>predict</code> to get the 400 corresponding mean MPG (<em>z</em>) values; since it’s already a data frame in the required format, <code>hp.wt</code> can be passed directly to the <code>newdata</code> argument.</p>&#13;
<pre>R&gt; car.pred &lt;- predict(car.fit,newdata=hp.wt)</pre>&#13;
<p class="indent">Then, you simply need to arrange the resulting vector as the appropriate 20 × 20 <em>z</em>-matrix.</p>&#13;
<pre>R&gt; car.pred.mat &lt;- matrix(car.pred,nrow=len,ncol=len)</pre>&#13;
<p class="indent">Finally, you plot the result as contours, as shown in <a href="ch25.xhtml#ch25fig11">Figure 25-11</a>.</p>&#13;
<pre>R&gt; contour(x=hp.seq,y=wt.seq,z=car.pred.mat,levels=32:8,lty=2,lwd=1.5,<br/>           xaxs="i",yaxs="i",xlab="Horsepower",ylab="Weight",<br/>           main="Mean MPG model")</pre>&#13;
<p class="indent">In this call, you can see the use of the optional <code>levels</code> argument. Rather than let R automatically decide at which values of <em>z</em> to show contours, you can supply a numeric vector to this argument with the specific levels at which to draw the lines. This numeric vector must be on the same scale as the resulting bivariate function of interest; here, I asked for contours at all integer levels from 32 through 8. I also employ the familiar arguments <code>lty</code> and <code>lwd</code> to control the appearance of the contour lines themselves, which are set here as dashed and slightly thicker than usual.</p>&#13;
<p class="indent">Furthermore, for contour plots in particular, you’ll often want to deviate from the default axis limit style, because the small amount of additional “padding” space that’s included in the default plot region (refer to <a href="ch23.xhtml#ch23lev2sec232">Section 23.4.1</a>) can be rather prominent—take another look at the volcano contour plot in <a href="ch25.xhtml#ch25fig10">Figure 25-10</a>. As shown previously, setting <code>xaxs</code> and <code>yaxs</code> to <code>"i"</code> restricts all plotting to the exact limits imposed by <code>x</code> and <code>y</code>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_660"/><img src="../images/f25-11.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig11"/>Figure 25-11: Contour lines depicting the response surface based on a multiple linear model of MPG by horsepower and weight, from the</em> <code>mtcars</code> <em>data</em></p>&#13;
<h5 class="h5" id="ch25lev3sec113"><strong>Example 3: Nonparametric Bivariate Density Estimate (Earthquake Data)</strong></h5>&#13;
<p class="noindent">Another useful role fulfilled by contour plots and the other plots in this chapter is to visualize bivariate density functions.</p>&#13;
<p class="indent">In <a href="ch24.xhtml#ch24lev2sec239">Section 24.2.2</a>, you looked at the idea of kernel density estimation (KDE) as a method by which to construct smooth estimates of the probability density functions of your data—essentially, sophisticated histograms. KDE extends to higher dimensions quite naturally so that you can also estimate the density of bivariate observations in the <em>x</em>-<em>y</em> plane. This again involves visualizing a <em>z</em>-matrix over a fixed grid of coordinates. For theoretical details on multivariate KDE, see Wand and Jones (<a href="ref.xhtml#ref70">1995</a>).</p>&#13;
<p class="indent">Turn your attention back to the built-in <code>quakes</code> data frame and recall the plots of the spatial coordinates of the 1,000 seismic events (for example, <a href="ch13.xhtml#ch13fig1">Figure 13-1</a> on <a href="ch13.xhtml#page_265">page 265</a> and <a href="ch23.xhtml#ch23fig1">Figure 23-1</a> on <a href="ch23.xhtml#page_578">page 578</a>). To estimate the probability density function of these points, you can use the <code>kde2d</code> function in the <code>MASS</code> package. Load <code>MASS</code> and execute the following line to produce the kernel estimate of the observed two-dimensional data:</p>&#13;
<pre>R&gt; quak.dens &lt;- kde2d(x=quakes$long,y=quakes$lat,n=100)</pre>&#13;
<p class="indent">You supply the bivariate data as the <code>x</code> and <code>y</code> arguments for the horizontal and vertical axes. The optional argument <code>n</code> is used to specify the number of evaluation coordinates (along each of the two axes) at which to actually return the estimated density surface. This defines the size of the matrix returned by a call to <code>kde2d</code>. Here, you’ve asked for KDE to be performed on a 100 × 100 evenly spaced grid over the range of the observed data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_661"/>The resulting object is simply a list with three members. The components accessed through <code>$x</code> and <code>$y</code> contain the evenly spaced evaluation grid coordinates in the corresponding axis directions, and <code>$z</code> provides you with the corresponding <em>z</em>-matrix. You can confirm by entering either <code>quak.dens$x</code> or <code>quak.dens$y</code> at the prompt that they are indeed increasing sequences spanning the ranges of the observed data. Entering the following confirms the size of the matrix of interest:</p>&#13;
<pre>R&gt; dim(quak.dens$z)<br/>[1] 100 100</pre>&#13;
<p class="indent">With that, you have all the ingredients you need to display contours of the KDE surface. The next line produces the default contour plot, given on the top left of <a href="ch25.xhtml#ch25fig12">Figure 25-12</a>.</p>&#13;
<pre>R&gt; contour(quak.dens$x,quak.dens$y,quak.dens$z)</pre>&#13;
<p class="indent">There are many more optional arguments available to <code>contour</code> for displaying your continuous surface. It can also be helpful to simultaneously view other data or raw observations (if they’ve been used in some way to create the surface, as is the case with bivariate KDE). The following code replots the <code>quakes</code> kernel estimate with unpadded axes, different contour levels to the defaults, and the raw observations; you can see the result on the top right of <a href="ch25.xhtml#ch25fig12">Figure 25-12</a>:</p>&#13;
<pre>R&gt; contour(quak.dens$x,quak.dens$y,quak.dens$z,nlevels=50,drawlabels=FALSE,<br/>           xaxs="i",yaxs="i",xlab="Longitude",ylab="Latitude")<br/>R&gt; points(quakes$long,quakes$lat,cex=0.7)</pre>&#13;
<p class="indent">Rather than using <code>levels</code> to determine the exact levels at which to draw the contours (as you did with Example 2), you can use the <code>nlevels</code> argument to specify the <em>number</em> of levels to display, and the function will choose the specific values. This latest call to <code>contour</code> requested 50 levels to be drawn. You can suppress the automatic labeling of the displayed contours by setting <code>drawlabels=FALSE</code>, also done here, followed by a call to <code>points</code> to add the original observations to the image. Naturally, the smooth contours delineating the nonparametric density estimate reflect the heterogeneous spatial patterning of the data.</p>&#13;
<p class="indent">Changing the appearance of your plotted contours needn’t be done universally; you can also alter the appearance of each individual contour level. This can be handy if, for example, you want to display contours at a handful of specific levels without the default labeling (to focus on the shape of the surface itself) but still want to be able to discern the values of those contours. You might also want to superimpose contours on an existing plot that already depicts other data or model-based results of interest. The third plot of the earthquake KDE surface, given on the bottom of <a href="ch25.xhtml#ch25fig12">Figure 25-12</a>, shows how you can achieve both of these things.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_662"/><img src="../images/f25-12.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig12"/>Figure 25-12: Three examples of a contour plot of the bivariate kernel estimate of the probability density function of the spatial earthquake locations given in the</em> <code>quakes</code> <em>data set</em></p>&#13;
<p class="indent">To start the plot, the spatial locations of the earthquake data are drawn as half-size gray dots using <code>plot</code>, the style of the axes are set using <code>xaxs</code> and <code>yaxs</code> to remove the artificial padding around the edges of the plot region, and axis titles are added.</p>&#13;
<pre>R&gt; plot(quakes$long,quakes$lat,cex=0.5,col="gray",xaxs="i",yaxs="i",<br/>        xlab="Longitude",ylab="Latitude")</pre>&#13;
<p class="indent">Then, before calling <code>contour</code>, store the desired levels at which to draw contours in a vector named <code>quak.levs</code> (again, choosing appropriate contour levels depends entirely on what kind of surface you’re plotting; you need to be at least roughly aware of the values stored in the relevant <em>z</em>-matrix).</p>&#13;
<pre><span epub:type="pagebreak" id="page_663"/>R&gt; quak.levs &lt;- c(0.001,0.005,0.01,0.015)</pre>&#13;
<p class="indent">Now, remember that by default, <code>contour</code> refreshes the graphics device and starts a new plot, but you want to avoid that when adding contour lines to an existing plot. To do so, you need to explicitly specify <code>add=TRUE</code>. You then provide the four specified levels in <code>quak.levs</code> to <code>levels</code> and suppress labeling with <code>drawlabels=FALSE</code>. To control the appearance of contour lines at individual levels, you supply the sequence of integers <code>4:1</code> to <code>lty</code>, the first entry of which, <code>4</code>, defines the line type of the contour at <em>z</em> = 0.001. The second entry, <code>3</code>, specifies the line type of the <em>z</em> = 0.005 contour, and so on. Lastly, set all drawn contours to double-thickness with the single supplied value <code>lwd=2</code>. (You could supply a vector with four elements here too, if you want differing line thicknesses for the different contours. The same element-wise contour specification extends to other relevant aesthetics, such as color via <code>col</code>.)</p>&#13;
<pre>R&gt; contour(quak.dens$x,quak.dens$y,quak.dens$z,add=TRUE,levels=quak.levs,<br/>           drawlabels=FALSE,lty=4:1,lwd=2)</pre>&#13;
<p class="indent">As a final touch, since the automatic labeling was suppressed in <code>contour</code>, add a legend in the bottom-left corner of the plot region, referencing the values of the contours through the four different line types.</p>&#13;
<pre>R&gt; legend("bottomleft",legend=quak.levs,lty=4:1,lwd=2,<br/>          title="Kernel estimate (contours)")</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Many built-in and contributed base R plotting functions that by default initialize, refresh, or open a new plot include an</em> <code><span class="codeitalic">add</code></span> <em>argument as shown here. This allows you to use the graphics produced by these functions as additions to an already existing graphic. Look in the relevant help file to see whether this is the case for a given command.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch25lev2sec255"><strong><em>25.4.2 Color-Filled Contours</em></strong></h4>&#13;
<p class="noindent">For a straightforward variation on the contour plot, you can use color to fill the gaps between the different levels that are drawn. Combined with a color legend, this removes the need to label the contour lines and in certain cases can make it easier to visually interpret fluctuations in the plotted <em>z</em>-matrix surface.</p>&#13;
<p class="indent">The <code>filled.contour</code> function does this for you. You need to supply the increasing sequences of grid coordinates in both the <em>x</em>-axis and <em>y</em>-axisdirections, as well as the corresponding <em>z</em>-matrix, to the arguments <code>x</code>, <code>y</code>, and <code>z</code> in the same way as in <code>contour</code>. The easiest way to specify the colors is to supply a color palette to the <code>color.palette</code> argument (which defaults to the built-in <code>cm.colors</code> palette; refer to <a href="ch25.xhtml#ch25fig2">Figure 25-2</a>), and R does the rest.</p>&#13;
<p class="indent">Let’s use the <code>mtcars</code> response surface from Example 2 for a quick demonstration. If you don’t already have them in your current workspace, use the <span epub:type="pagebreak" id="page_664"/>code from <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a> to obtain the relevant fitted multiple linear regression model, the evaluation grid coordinates, and the prediction thereof. With the objects <code>hp.seq</code>, <code>wt.seq</code>, and <code>car.pred.mat</code> defined as earlier, the following call produces <a href="ch25.xhtml#ch25fig13">Figure 25-13</a>:</p>&#13;
<pre>R&gt; filled.contour(x=hp.seq,y=wt.seq,z=car.pred.mat,<br/>           color.palette=colorRampPalette(c("white","red4")),<br/>           xlab="Horsepower",ylab="Weight",<br/>           key.title=title(main="Mean MPG",cex.main=0.8))</pre>&#13;
<div class="image"><img src="../images/f25-13.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig13"/>Figure 25-13: Filled contour plot of the response surface for the fitted multiple linear model of the</em> <code>mtcars</code> <em>data</em></p>&#13;
<p class="indent">Note in this plot that the default color palette hasn’t been used. Instead, you’ve supplied a custom palette (produced as a direct result of an appropriate call to <code>colorRampPalette</code>; refer to <a href="ch25.xhtml#ch25lev2sec244">Section 25.1.3</a>) to the relevant argument, moving from white at the lower end to dark red at the upper end. Note also that although the <em>x</em>-axis and <em>y</em>-axis titles are provided as usual to <code>xlab</code> and <code>ylab</code>, you have to supply the title for the color legend in a particular way—inside a call to <code>title</code> to the <code>key.title</code> argument. This is because <code>filled.contour</code> actually produces two plots, one for the image itself and one for the color legend, and makes use of the <code>layout</code> command to place them next to one another.</p>&#13;
<p class="indent">This internal use of <code>layout</code> isn’t directly a problem, but, as you saw in <a href="ch23.xhtml#ch23lev2sec225">Section 23.1.4</a>, it complicates matters somewhat if you want to annotate the filled contour plot after the fact (by, for example, adding points to an existing graphic) since the original user coordinate system is lost.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_665"/>Turn your attention back to the two-dimensional kernel estimate of the spatial <code>quakes</code> data (use the code from <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a> to re-create it if you haven’t already got the <code>quak.dens</code> object in your workspace). The following code creates a filled contour plot of the density surface using the built-in <code>topo.colors</code> palette and modifies the number of drawn levels from the default of 20 to 30. In the same call, you can superimpose the points of the raw observations onto the image through special use of the optional <code>plot.axes</code> argument. <a href="ch25.xhtml#ch25fig14">Figure 25-14</a> shows the result.</p>&#13;
<pre>R&gt; filled.contour(x=quak.dens$x,y=quak.dens$y,z=quak.dens$z,<br/>                  color.palette=topo.colors,nlevels=30,xlab="Longitude",<br/>                  ylab="Latitude",key.title=title(main="KDE",cex.main=0.8),<br/>                  plot.axes={axis(1);axis(2);<br/>                             points(quakes$long,quakes$lat,cex=0.5,<br/>                                    col=adjustcolor("black",alpha=0.3))})</pre>&#13;
<div class="image"><img src="../images/f25-14.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig14"/>Figure 25-14: Filled contour plot of the kernel estimate of the probability density function of the spatial</em> <code>quakes</code> <em>data, with raw observations superimposed.</em></p>&#13;
<p class="indent">Take a look at the way in which <code>plot.axes</code> is used; it effectively takes a chunk of code. When <code>plot.axes</code> is invoked, you must explicitly tell it to mark the <em>x</em>- and <em>y</em>-axes if you want the labeled tick marks to remain. This is done with two calls to <code>axis</code> (refer to <a href="ch23.xhtml#ch23lev2sec234">Section 23.4.3</a>—<code>axis(1)</code> gives <em>x</em>, and <code>axis(2)</code> is used for <em>y</em>). You add the data points with a call to <code>points</code>; in this example, these are instructed to plot at half size, with 30 percent opacity imparted with <code>adjustcolor</code>. Since you’re supplying multiple separate commands at <span epub:type="pagebreak" id="page_666"/>once to the <code>plot.axes</code> argument, each command needs to be separated by a semicolon (<code>;</code>) inside braces (<code>{ }</code>).</p>&#13;
<p class="indent">Annotation of a filled contour plot in this fashion requires a little more forethought since you’re required to manually add the axes via calls to <code>axis</code> and perform all subsequently desired plotting actions within the call to <code>filled.contour</code>. It won’t work to, for example, produce a filled contour plot like the <code>quakes</code> KDE surface and then call <code>points</code> as a separate line of code. If you try it, you’ll see the observed data points unable to align correctly with their original user coordinates as indicated on the axes.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch25exc3"/><strong>Exercise 25.3</strong></p>&#13;
<p class="noindentz">Remember that you inspected various multiple linear regression models of the cost of nuclear power plant construction in <a href="ch21.xhtml#ch21">Chapters 21</a> and <a href="ch22.xhtml#ch22">22</a>. The goal now will be to visually assess the impact of including/excluding an interactive term between two continuous predictors using contours. Revisit the <code>nuclear</code> data set, available when you load the <code>boot</code> package, and bring up the help file to refresh your memory of the variables present.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Fit and summarize two linear models with construction cost as the response variable according to the following guidelines:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">The first should account for main effects of the two predictors concerning the date of issue of the construction permit and plant capacity.</p></li>&#13;
<li><p class="noindents">The second, in addition to the two main effects, should include an interaction between permit issue date and capacity.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Set up appropriate <em>z</em>-matrices for plotting each of these response surfaces. Each one should be based on a 50 × 50 evaluation grid constructed using evenly spaced sequences in the capacity and date variables.</p></li>&#13;
<li><p class="noindents">Specify <code>mfrow</code> in <code>par</code> so that you can display default contour plots for the two response surfaces from (a)(i) and (a)(ii) next to one another. Do they appear similar? Does thistie in with the statistical significance (or lack thereof) of the interaction term in (a)(ii)?</p></li>&#13;
<li><p class="noindents">To directly compare the two surfaces, use your choice of built-in color palette to produce a filled contour plot of the main-effects-only model and superimpose the contour lines of the interactive model on it. Take note of the following:</p>&#13;
<p class="dash">– This plot is achieved in a single call to <code>filled.contour</code>. Recall the special way you use <code>plot.axes</code> to draw additional features on an existing color-filled contour plot.</p>&#13;
<p class="dash"><span epub:type="pagebreak" id="page_667"/>– The contour lines of the interactive model can be added with an appropriate call to <code>contour</code>. Recall the use of the optional argument <code>add</code>.</p>&#13;
<p class="dash">– The superimposed contours should be dashed lines of double thickness.</p>&#13;
<p class="dash">– The <em>x</em>- and <em>y</em>-axes should be included and given tidy titles.</p>&#13;
<p class="dash">– Add some brief text describing the filled contours versus the contour lines, with reference to the two versions of the construction cost model and with an additional call to <code>text</code> that makes use of a single mouse-clicked location from <code>locator</code> (see <a href="ch23.xhtml#ch23lev1sec78">Section 23.3</a>). Note that this call will need to fully relax clipping for the text to be visible in any of the margins.</p>&#13;
<p class="dashp">My result is shown here.</p>&#13;
<div class="imagec"><img src="../images/f0667-01.jpg" alt="image"/></div></li>&#13;
<li><p class="noindents">Another built-in data frame in R, <code>faithful</code>, contains observations of waiting times and durations of eruptions of the Old Faithful geyser in Yellowstone National Park, Wyoming. See the documentation in <code>?faithful</code> for details. Plot the data with duration on the <em>y</em>-axis and waiting time on the <em>x</em>-axis.</p></li>&#13;
<li><p class="noindents">Estimate the bivariate density of these data via KDE using a 100 × 100 evaluation grid and produce a default contour plot thereof.</p></li>&#13;
<li><p class="noindents">Create a filled contour plot of the kernel estimate using a custom palette that ranges from <code>"darkblue"</code> to <code>"hotpink"</code>; include the raw data as half-size gray points. Label the axes and titles appropriately.</p></li>&#13;
<li><p class="noindents">Replot the raw data as gray, 3/4-sized, type <code>2</code> point characters; set the style of the axes to restrict to exactly the ranges of the observed data; and ensure tidy axis titles and a main title. To this <span epub:type="pagebreak" id="page_668"/>plot, add the contour lines of the density estimate at the specific levels obtained in a sequence from 0.002 to 0.014 in steps of 0.004. Suppress the labeling of the contours. The contour lines should be dark red and increase in line width thickness for higher levels of the density. Add a legend referencing the density level at each of these lines.</p>&#13;
<p class="noindent">My plots for (g) and (h) are shown here.</p></li>&#13;
</ol>&#13;
<div class="imagec"><img src="../images/f0668-01.jpg" alt="image"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch25lev1sec90"><strong>25.5 Pixel Images</strong></h3>&#13;
<p class="noindent">A <em>pixel image</em> is arguably the most literal visual representation of a continuous surface approximated by a finite evaluation grid. Its appearance is similar to a filled contour plot, but an image plot gives you more direct control over the display of each entry of the relevant <em>z</em>-matrix.</p>&#13;
<h4 class="h4" id="ch25lev2sec256"><strong><em>25.5.1 One Grid Point = One Pixel</em></strong></h4>&#13;
<p class="noindent">Consider each entry of your <em>z</em>-matrix as a little rectangle whose color depicts its relative value. These rectangles, or <em>pixels</em>, are exactly what’s depicted as the cells formed by the dashed gray lines making up the conceptual diagram of the <em>z</em>-matrix in <a href="ch25.xhtml#ch25fig9">Figure 25-9</a> on <a href="ch25.xhtml#page_656">page 656</a>. This emphasizes the important fact that the fineness of your evaluation grid sequences (in both the <em>x</em>- and <em>y</em>-coordinate directions) directly defines the size of each pixel and therefore the smoothness of the resulting image. A smaller pixel means the <em>resolution</em> of the image is increased.</p>&#13;
<p class="indent">The built-in <code>image</code> function plots pixel images. Much as with <code>contour</code>, you supply your <em>x</em>- and <em>y</em>-axis evaluation grid coordinates as increasing sequences to the <code>x</code> and <code>y</code> arguments, with the corresponding <em>z</em>-matrix supplied to <code>z</code>. Going back to the <code>volcano</code> data set first looked at in Example 1 of <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>, the following line produces <a href="ch25.xhtml#ch25fig15">Figure 25-15</a>:</p>&#13;
<pre>R&gt; image(x=1:nrow(volcano),y=1:ncol(volcano),z=volcano,asp=1)</pre>&#13;
<p class="indent">Note again that you use the optional argument <code>asp=1</code> to enforce a one-to-one aspect ratio of the horizontal and vertical axes. This plot is comprised of <span epub:type="pagebreak" id="page_669"/>exactly 87 × 61 = 5307 pixels; each one represents a particular entry in the <code>volcano</code> matrix. Visually, the reflection of this image in the contour plot of the same data in <a href="ch25.xhtml#ch25fig10">Figure 25-10</a> is clear.</p>&#13;
<div class="image"><img src="../images/f25-15.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig15"/>Figure 25-15: Pixel image of the Auckland volcano topography</em></p>&#13;
<p class="indent">The <code>image</code> command expects a vector of colors, usually supplied as hex codes from a palette, to be passed to its <code>col</code> argument. If this isn’t specified, it defaults to <code>heat.colors(12)</code> using the built-in palette, as in the image plot of <code>volcano</code>. One immediate concern, however, is the lack of a color legend. Contributed tools such as the <code>colorlegend</code> function from the <code>shape</code> package (refer to <a href="ch25.xhtml#ch25lev2sec246">Section 25.1.5</a>) prove useful for these plots.</p>&#13;
<p class="indent">Return now to the <code>mtcars</code> response surface from Example 2 that fits the multiple linear regression model of MPG on horsepower and weight (and an interactive effect between the two predictors). The code for the necessary objects is reproduced here in a shortened form for convenience (refer to <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a> for a fuller explanation of the operations):</p>&#13;
<pre>R&gt; car.fit &lt;- lm(mpg~hp*wt,data=mtcars)<br/>R&gt; len &lt;- 20<br/>R&gt; hp.seq &lt;- seq(min(mtcars$hp),max(mtcars$hp),length=len)<br/>R&gt; wt.seq &lt;- seq(min(mtcars$wt),max(mtcars$wt),length=len)<br/>R&gt; hp.wt &lt;- expand.grid(hp=hp.seq,wt=wt.seq)<br/>R&gt; car.pred.mat &lt;- matrix(predict(car.fit,newdata=hp.wt),nrow=len,ncol=len)</pre>&#13;
<p class="indent">Just as earlier, you’ve set up a matrix of 400 elements in <code>car.pred.mat</code>, which is based on sequences of length 20 in both continuous predictors.</p>&#13;
<p class="indent">Now, make sure the <code>shape</code> package is loaded so you have access to the <code>colorlegend</code> function. The code that follows first sets up a custom palette of blue colors, sets new margin limits that widen the area on the rightmost <span epub:type="pagebreak" id="page_670"/>axis, and then plots the predicted 20 × 20 response surface including a color legend; the result is given on the left of <a href="ch25.xhtml#ch25fig16">Figure 25-16</a>.</p>&#13;
<pre>R&gt; blues &lt;- colorRampPalette(c("cyan","navyblue"))<br/>R&gt; par(mar=c(5,4,4,5))<br/>R&gt; image(hp.seq,wt.seq,car.pred.mat,col=blues(10),<br/>         xlab="Horsepower",ylab="Weight")<br/>R&gt; colorlegend(col=blues(10),zlim=range(car.pred.mat),zval=seq(10,30,5),<br/>               main="Mean\nMPG")</pre>&#13;
<div class="image"><img src="../images/f25-16.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig16"/>Figure 25-16: Two pixel images of the</em> <code>mtcars</code> <em>mean MPG response surface introduced in Example 2, with accompanying color legends. In terms of the evaluation grid in the horsepower and weight variables, the surface on the left has a resolution of 20 <sup>2</sup>; the image on the right is based on a finer 50 <sup>2</sup> grid. Contours are superimposed upon the rightmost plot.</em></p>&#13;
<p class="indent">With a relatively coarse evaluation grid, the pixels making up the surface are prominent. You can easily increase the resolution of the parametric response surface by using finer sequences for the <code>hp.seq</code> and <code>wt.seq</code> evaluation grid. The code that follows does just that by increasing <code>len</code> to <code>50</code>, over-writing the objects used previously:</p>&#13;
<pre>R&gt; car.fit &lt;- lm(mpg~hp*wt,data=mtcars)<br/>R&gt; len &lt;- 50<br/>R&gt; hp.seq &lt;- seq(min(mtcars$hp),max(mtcars$hp),length=len)<br/>R&gt; wt.seq &lt;- seq(min(mtcars$wt),max(mtcars$wt),length=len)<br/>R&gt; hp.wt &lt;- expand.grid(hp=hp.seq,wt=wt.seq)<br/>R&gt; car.pred.mat &lt;- matrix(predict(car.fit,newdata=hp.wt),nrow=len,ncol=len)</pre>&#13;
<p class="indent">Then the right-hand image of <a href="ch25.xhtml#ch25fig16">Figure 25-16</a> is produced with the following code:</p>&#13;
<pre>R&gt; par(mar=c(5,4,4,5))<br/>R&gt; image(hp.seq,wt.seq,car.pred.mat,col=blues(100),<br/>         xlab="Horsepower",ylab="Weight")<br/>R&gt; contour(hp.seq,wt.seq,car.pred.mat,add=TRUE,lty=2)<br/><span epub:type="pagebreak" id="page_671"/>R&gt; colorlegend(col=blues(100),zlim=range(car.pred.mat),zval=seq(10,30,5),<br/>               main="Mean\nMPG")</pre>&#13;
<p class="indent">The newly plotted surface consists of 50<sup>2</sup> = 2500 pixels, as opposed to the previous image of merely 20<sup>2</sup> = 400 pixels. The improvement in the picture is obvious. In plotting the new image, the number of colors used (from the custom <code>blues</code> palette) is increased to 100 to provide smoother color transitions. Note also the use of <code>add</code> in a call to <code>contour</code> to superimpose contour lines upon the image to provide further visual emphasis of the fluctuating surface over the evaluation grid. A legend is added with an appropriate call to <code>colorlegend</code> as a final touch.</p>&#13;
<h4 class="h4" id="ch25lev2sec257"><strong><em>25.5.2 Surface Truncation and Empty Pixels</em></strong></h4>&#13;
<p class="noindent">Because of its one-to-one literal representation of the <em>z</em>-matrix, a pixel image is especially good when you want to plot a surface that fits irregularly over, or is smaller than, the standard rectangular evaluation grid spanning the <em>x-</em>and <em>y</em>-axes. To carefully demonstrate this kind of manipulation, let’s turn to a new data set from the contributed <code>spatstat</code> package by Baddeley and Turner (<a href="ref.xhtml#ref06">2005</a>). Install <code>spatstat</code> with a call to <code>install.package("spatstat")</code>. Note that <code>spatstat</code> has a number of dependencies; see <a href="app01.xhtml#app01lev2sec275">Appendix A.2.3</a> if you have any trouble downloading and installing <code>spatstat</code>.</p>&#13;
<h5 class="h5" id="ch25lev3sec114"><strong>Example 4: Nonparametric Bivariate Density Estimate (Chorley-Ribble Data)</strong></h5>&#13;
<p class="noindent">Once <code>spatstat</code> is installed and loaded in your current R session with a call to <code>library("spatstat")</code>, inspect the help file brought up by entering <code>?chorley</code> at the prompt. This details the Chorely-Ribble cancer data—spatial locations of 1,036 cases of cancer of the larynx and lung collected in the late 1970s and early 1980s in a particular region of England (data first analyzed by <a href="ref.xhtml#ref18">Diggle, 1990</a>). The <code>chorley</code> object is of a special class specific to <code>spatstat</code> (a <code>"ppp"</code> object—<em>planar point pattern</em>), but its components can be extracted just as if you’re referencing members of a named list.</p>&#13;
<p class="indent">The coordinates of the observations can be retrieved as the components <code>$x</code> and <code>$y</code>. To view the spatial dispersion of the observations, the following line gives you the top-left image of <a href="ch25.xhtml#ch25fig17">Figure 25-17</a>:</p>&#13;
<pre>R&gt; plot(chorley$x,chorley$y,xlab="Eastings (km)",ylab="Northings (km)")</pre>&#13;
<p class="indent">Your goal is to display a kernel estimate of the two-dimensional probability density function of the cancer distribution, similar to what you did with the earthquake data in Example 3. You’ll use the <code>kde2d</code> function for this—execute <code>library("MASS")</code> to gain access to it. Then, exactly as you used it for the spatial locations of <code>quakes</code>, the default KDE surface for the observed Chorley-Ribble data is given with the following:</p>&#13;
<pre>R&gt; chor.dens &lt;- kde2d(x=chorley$x,y=chorley$y,n=256)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_672"/>Note the specification of a fine 256 × 256 easting-northing evaluation grid.</p>&#13;
<p class="indent">To display the density estimate, use the built-in <code>rainbow</code> palette and use the optional <code>start</code> and <code>end</code> arguments to restrict the total range of the palette to begin at red at the lower end and end at magenta/pink at the upper end (these arguments were mentioned briefly in <a href="ch25.xhtml#ch25lev2sec243">Section 25.1.2</a>; refer to the help file <code>?rainbow</code> for more details on the use of <code>start</code> and <code>end</code>). Prestore 200 colors from this palette with the following line:</p>&#13;
<pre>R&gt; rbow &lt;- rainbow(200,start=0,end=5/6)</pre>&#13;
<p class="indent">Then, the image is produced by calling this:</p>&#13;
<pre>R&gt; image(x=chor.dens$x,y=chor.dens$y,z=chor.dens$z,col=rbow)</pre>&#13;
<p class="indent">Another component of <code>chorley</code>, named <code>$window</code>, contains the vertices of an irregular polygon. This polygon defines the geographical study region in which the observations themselves were made. The <code>$window</code> component also happens to be another special object class of <code>spatstat</code>, namely, <code>"owin"</code> for “observation window.” Although it’s possible to extract the specific vertices of the polygon and plot it manually with built-in functionality, the authors of <code>spatstat</code> have provided a standard <code>plot</code> method to use for this purpose.</p>&#13;
<p class="indent">After running the <code>image</code> command, calling the following code superimposes the border of the study region upon the pixel image:</p>&#13;
<pre>R&gt; plot(chorley$window,add=TRUE)</pre>&#13;
<p class="indent">The final result is given on the top right of <a href="ch25.xhtml#ch25fig17">Figure 25-17</a>.</p>&#13;
<p class="indent">You’ll notice that the geographical region in which the data were collected is a little wider than the <em>x</em>- and <em>y</em>-ranges of the observations themselves, so the current plot hasn’t been able to show the region in its entirety. The following code shows this numerically:</p>&#13;
<pre>R&gt; chor.WIN &lt;- chorley$window<br/>R&gt; range(chorley$x)<br/>[1] 346.6 364.1<br/>R&gt; WIN.xr &lt;- chor.WIN$xrange<br/>R&gt; WIN.xr<br/>[1] 343.45 366.45<br/>R&gt; range(chorley$y)<br/>[1] 412.6 430.3<br/>R&gt; WIN.yr &lt;- chor.WIN$yrange<br/>R&gt; WIN.yr<br/>[1] 410.41 431.79</pre>&#13;
<p class="indent">The <em>x</em>- and <em>y</em>-ranges of the study region can be obtained as the <code>$xrange</code> and <code>$yrange</code> components of the <code>$window</code> component (which is stored in the first line as the object <code>chor.WIN</code>). You can see that the overall study region is <span epub:type="pagebreak" id="page_673"/>slightly larger when you compare its limits to the results of calling <code>range</code> on the raw data.</p>&#13;
<p class="indent">That’s not the only problem, either. From the plot, you can also see that the KDE surface has been estimated and drawn in some areas that are actually <em>outside</em> the study region, so that will need to be fixed as well. (You’ll look at that in a moment.)</p>&#13;
<div class="image"><img src="../images/f25-17.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig17"/>Figure 25-17: Visual experimentations in attempts to plot a two-dimensional kernel estimate of the probability density function of the Chorley-Ribble cancer data as a pixel image. Top left: The raw data. Top right: The default</em> <code>kde2d</code> <em>result based on the data ranges with the study region superimposed. Bottom left: Expanding the</em> <code>xlim</code> <em>and</em> <code>ylim</code> <em>of the call to</em> <code>image</code> <em>when plotting the original density estimate. Bottom right: A revised density estimate, using the full</em> x<em>- and</em> y<em>-ranges of the study region to define the evaluation grid.</em></p>&#13;
<p class="indent">So, first off, what can you do to ensure the entire geographical region is displayed? Well, you could of course use the ranges of the region as stored previously in the vectors <code>WIN.xr</code> and <code>WIN.yr</code> and supply them to the familiar optional <code>xlim</code> and <code>ylim</code> arguments when calling <code>image</code>.</p>&#13;
<pre>R&gt; image(chor.dens$x,chor.dens$y,chor.dens$z,col=rbow,<br/>         xlim=WIN.xr,ylim=WIN.yr)<br/>R&gt; plot(chor.WIN,add=TRUE)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_674"/>The result of these two lines is given on the bottom left of <a href="ch25.xhtml#ch25fig17">Figure 25-17</a>. Unfortunately, the original density estimate is still defined in terms of the original <em>x</em>- and <em>y</em>-ranges of the raw data, which gives you a border of empty pixels; in addition, the aforementioned density areas still fall outside the observation window.</p>&#13;
<p class="indent">All this emphasizes the important fact that a <em>z</em>-matrix is specific to a predefined evaluation grid. The only way to get your density estimate to span the geographical study region for the Chorley-Ribble data is to revise your kernel estimate so that it’s produced on an evaluation grid that spans the limits of the region. Fortunately, the <code>kde2d</code> function allows you to set optional <em>x</em>-<em>y</em> limits of the evaluation grid with the <code>lims</code> argument. This expects a numeric vector of length 4, with the <em>x</em>-axis lower and upper values followed by the <em>y</em>-axis lower and upper values, in that order. The following code reestimates the density using the study region limits and plots it. The result is given on the bottom right of <a href="ch25.xhtml#ch25fig17">Figure 25-17</a>.</p>&#13;
<pre>R&gt; chor.dens.WIN &lt;- kde2d(chorley$x,chorley$y,n=256,lims=c(WIN.xr,WIN.yr))<br/>R&gt; image(chor.dens.WIN$x,chor.dens.WIN$y,chor.dens.WIN$z,col=rbow)<br/>R&gt; plot(chor.WIN,add=TRUE)</pre>&#13;
<p class="indent">With that, you’ve solved the problem of ensuring your surface spans the desired area. However, this definitely highlights the second problem—the data that were actually observed fall strictly within the defined polygon, but you can see plotted pixels outside the geographical region, which doesn’t make sense. You can control precisely which pixels are plotted in any given pixel image by setting the relevant entries in your <em>z</em>-matrix to be <code>NA</code> if you don’t want them drawn.</p>&#13;
<p class="indent">You’ll need a mechanism that can decide whether a given cell entry in your <em>z</em>-matrix, namely, <code>chor.dens.WIN$z</code>, corresponds to a location inside or outside the polygon (the object <code>chor.WIN</code>). If it falls outside, you’ll want to force that entry to be <code>NA</code>. In general, this type of decision making requires you to test each element of the matrix with respect to its coordinate value on the evaluation grid, possibly using your own R function. Fortunately, in this case, the <code>inside.owin</code> function of <code>spatstat</code> does exactly that, but the principle remains the same whenever you need control over precisely which pixels are plotted and which aren’t.</p>&#13;
<p class="indent">Given one or more two-dimensional (<em>x</em>,<em>y</em>) coordinates and an object of class <code>"owin"</code>, the <code>inside.owin</code> function returns a corresponding logical vector with a <code>TRUE</code> for those coordinates inside the defined region and a <code>FALSE</code> for any other coordinate. As a quick demonstration, observe the following result:</p>&#13;
<pre>R&gt; inside.owin(x=c(355,345),y=c(420,415),w=chor.WIN)<br/>[1]  TRUE FALSE</pre>&#13;
<p class="indent">This confirms what you can see from <a href="ch25.xhtml#ch25fig17">Figure 25-17</a>—that the coordinate (355,420) lies well within the polygon and that the coordinate (345,415) doesn’t.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_675"/>Now, you need to use the <code>inside.owin</code> function on every coordinate in the evaluation grid that <em>z</em>-matrix <code>chor.dens.WIN$z</code> sits on. First, create the full set of grid coordinates using <code>expand.grid</code>, in the same way as illustrated in <a href="ch25.xhtml#ch25lev2sec251">Section 25.3.1</a>.</p>&#13;
<pre>R&gt; chor.xy &lt;- expand.grid(chor.dens.WIN$x,chor.dens.WIN$y)<br/>R&gt; nrow(chor.xy)<br/>[1] 65536</pre>&#13;
<p class="indent">Calling <code>nrow</code> on the resulting data frame of coordinates confirms you have exactly 256<sup>2</sup> = 65536 grid points as defined in the <code>chor.dens.WIN</code> KDE object. The following call then takes the two columns of <code>chor.xy</code> and makes use of logical negation (using <code>!</code>) to produce a logical vector that flags grid coordinates that are located <em>outside</em> the defined geographical region.</p>&#13;
<pre>R&gt; chor.outside &lt;- !inside.owin(x=chor.xy[,1],y=chor.xy[,2],w=chor.WIN)</pre>&#13;
<p class="indent">The final step is now at hand.</p>&#13;
<pre>R&gt; chor.out.mat &lt;- matrix(chor.outside,nrow=256,ncol=256)<br/>R&gt; chor.dens.WIN$z[chor.out.mat] &lt;- NA</pre>&#13;
<p class="indent">First, for clarity, recast the long <code>chor.outside</code> vector as a 256 × 256 matrix to emphasize that it corresponds exactly to the <em>z</em>-matrix of interest. Then this logical flag matrix is used to directly overwrite the “outside” entries in the <em>z</em>-matrix to be <code>NA</code>.</p>&#13;
<p class="indent">All that’s left now is to plot the image with the newly manipulated <em>z</em>-matrix. Make sure you have the <code>shape</code> package loaded for the finishing touch of a color legend. The following code creates the KDE surface pixel image plot with pixel points restricted to the geographical region defined by <code>$window</code> only:</p>&#13;
<pre>R&gt; dev.new(width=7.5,height=7)<br/>R&gt; par(mar=c(5,4,4,7))<br/>R&gt; image(chor.dens.WIN$x,chor.dens.WIN$y,chor.dens.WIN$z,col=rbow,<br/>         xlab="Eastings",ylab="Northings",bty="l",asp=1)<br/>R&gt; plot(chor.WIN,lwd=2,add=TRUE)<br/>R&gt; colorlegend(col=rbow,zlim=range(chor.dens.WIN$z,na.rm=TRUE),<br/>               zval=seq(0,0.02,0.0025),main="KDE",digit=4,posx=c(0.85,0.87))</pre>&#13;
<p class="indent">First you open a new graphics device and widen the right margin to incorporate the color legend. Next you invoke <code>image</code> to plot, specifically using an <em>L</em>-shaped box and a strict one-to-one <em>x</em>-<em>y</em> aspect ratio, and then you add the region polygon with slightly thicker lines. Finally you execute <code>colorlegend</code> to obtain an appropriately positioned legend referencing the color values (the specific positioning and tick marks of which were found after a little trial and error). You can see the final result in <a href="ch25.xhtml#ch25fig18">Figure 25-18</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_676"/><img src="../images/f25-18.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig18"/>Figure 25-18: Final pixel image plot of the Chorley-Ribble KDE surface, restricted to the geographical study region of the originally collected data.</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In truncating the kernel estimate of the bivariate density estimate that was originally defined over the full rectangular evaluation grid, technically you no longer have a valid probability density function as a result (since the integral over the irregular region will no longer evaluate to a total probability of 1). A more mathematically sound approach requires a deeper knowledge of multivariate KDE and is beyond the scope of this text. Nevertheless, being able to truncate pixel plots like this is useful in any situation where you want to define your surface on a (possibly irregular) subset of an overall rectangular evaluation grid.</em></p>&#13;
</div>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch25exc4"/><strong>Exercise 25.4</strong></p>&#13;
<p class="noindentz">Revisit the built-in <code>airquality</code> data set and take a look at the help file to refresh your memory of the variables present. Create a copy of the data frame: select the columns pertaining to daily temperature, wind speed, and ozone level and use <code>na.omit</code> to remove any records with missing values.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents">From your explorations of these data in <a href="ch24.xhtml#ch24">Chapter 24</a>, there appears to be an association among daily temperature, wind speed, and ozone level. Fit a multiple linear regression model that aims to predict mean temperature based on the wind speed and ozone level, including an interactive effect. Summarize the resulting object.</p></li>&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_677"/>Using the model from (a), construct a <em>z</em>-matrix of predicted mean daily temperature based on a 50 × 50 evaluation grid in both wind speed and ozone.</p></li>&#13;
<li><p class="noindents">Create a pixel image of the response surface, superimposing the raw observations as per the following:</p>&#13;
<p class="dash">– A graphics device should be initialized based on bottom, left, top, and right margin lines of 5, 4, 4, and 6, respectively.</p>&#13;
<p class="dash">– 20 colors from the built-in <code>topo.colors</code> palette should be used to produce the image; include tidy axis titles.</p>&#13;
<p class="dash">– Revisit the <code>normalize</code> function defined in <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a> and use the built-in function <code>gray</code> to generate a vector of gray colors (refer to <a href="ch25.xhtml#ch25lev2sec243">Section 25.1.2</a>) based on the normalized raw temperature observations. Superimpose the raw observations based on wind speed and ozone onto the pixel image, using the gray color vector to indicate the corresponding temperature observations.</p>&#13;
<p class="dash">– Two separate calls should then be made to <code>colorlegend</code> of the <code>shape</code> package. The first should appear in the space on the right margin, referencing the surface itself. The second should use the built-in <code>gray.colors</code> function, setting the optional arguments <code>start=0</code> and <code>end=1</code>, to generate 10 shades of gray for use in the legend that references the raw temperature observations of the superimposed points. This legend should reside on top of the pixel image itself, in the upper-right quadrant where there are no raw observations.</p>&#13;
<p class="dash">– Both legends should have appropriate titles, and you may need to experiment a little with the <code>posx</code> and <code>posy</code> arguments to find satisfactory placement.</p>&#13;
<p class="noindentt">My result of this plotting exercise appears here.</p>&#13;
<div class="imagec"><img src="../images/f0677-01.jpg" alt="image"/></div></li>&#13;
</ol>&#13;
<p class="noindentz"><span epub:type="pagebreak" id="page_678"/>In <a href="ch25.xhtml#ch25lev2sec257">Section 25.5.2</a>, you used the <code>chorley</code> data set in creating a pixel image truncated to a subset of the overall rectangular evaluation grid. Ensure <code>spatstat</code> is loaded in your current R session and execute the following two lines:</p>&#13;
<p class="programs-b1">R&gt; fire &lt;- split(clmfires)$intentional<br/>R&gt; firewin &lt;- clmfires$window</p>&#13;
<p class="indentz">This extracts the 1,786 locations of fires recorded as intentionally lit in a particular region of Spain. The spatial coordinates can be extracted as the <code>$x</code> and <code>$y</code> members of <code>fire</code>, and the geographical region itself is stored as a polygon in <code>firewin</code> (of the same class as the <code>chorley$window</code> object you looked at earlier). See the documentation obtained with <code>?clmfires</code> for further details.</p>&#13;
<ol type="a" start="4">&#13;
<li><p class="noindents">Using the total <em>x</em>- and <em>y</em>-range of the study region, use <code>kde2d</code> from the <code>MASS</code> package to calculate a bivariate kernel estimate of the probability density function of the spatial dispersion of intentionally lit fires. The KDE surface should be calculated based on a 256 × 256 evaluation grid.</p></li>&#13;
<li><p class="noindents">Identify all points on the rectangular evaluation grid that fall outside the geographical region using <code>expand.grid</code> in conjunction with <code>inside.owin</code>. Set all corresponding pixels of the density surface to <code>NA</code>.</p></li>&#13;
<li><p class="noindents">Construct a pixel image of the truncated density, as per the following:</p>&#13;
<p class="dash">– The graphics device should have three lines of space on the bottom, left, and top of the plot region and should have seven lines on the right.</p>&#13;
<p class="dash">– In producing the image itself, you should use 50 colors generated from the built-in <code>heat.colors</code> palette. A one-to-one aspect ratio should be maintained, the axis titles should be suppressed, and the box type set to be an <em>L</em> shape.</p>&#13;
<p class="dash">– The geographical study region should be superimposed onto the image using a double-width line.</p>&#13;
<p class="dash">– Using <code>colorlegend</code> from <code>shape</code>, a color legend referencing the density with an appropriate title should be placed to the right of the image. You’ll need to experiment with the <code>posx</code> argument for placement. Label the legend at a sequence from <code>5e-6</code> to <code>35e-6</code> in steps of <code>5e-6</code> (refer to <a href="ch02.xhtml#ch02lev2sec19">Section 2.1.3</a> for an explanation of e-notation); also, ensure these labels are able to display up to six decimal places of precision.</p></li>&#13;
</ol>&#13;
<p class="dashp1"><span epub:type="pagebreak" id="page_679"/>For your reference, my result is given here.</p>&#13;
<div class="imagec"><img src="../images/f0679-01.jpg" alt="image"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch25lev1sec91"><strong>25.6 Perspective Plots</strong></h3>&#13;
<p class="noindent">The last kind of plot you’ll look at in this chapter is the <em>perspective plot</em>, some-times also referred to as a <em>wireframe</em>. Unlike contour plots and pixel images, where fluctuations in the surface are emphasized with line patterns and/or colors, a perspective plot uses a physical third dimension against which the <em>z</em> value is plotted.</p>&#13;
<h4 class="h4" id="ch25lev2sec258"><strong><em>25.6.1 Basic Plots and Angle Adjustment</em></strong></h4>&#13;
<p class="noindent">Perspective plots are especially useful when you want to emphasize the fluctuating nature of the values populating your <em>z</em>-matrix. For example, in some applications you might want to get a good impression of the relative extremity of any present peaks and/or troughs in the plotted surface, which is harder to do in, for example, a pixel image or contour plot.</p>&#13;
<p class="indent">Recall the <code>mtcars</code> response surface plotted as contours and as pixel images in <a href="ch25.xhtml#ch25lev2sec254">Sections 25.4.1</a> and <a href="ch25.xhtml#ch25lev2sec256">25.5.1</a>. You created a 20 × 20 evaluation grid in the horsepower and weight variables, as well as a corresponding <em>z</em>-matrix of 400 giving the predicted mean MPG result:</p>&#13;
<pre>R&gt; car.fit &lt;- lm(mpg~hp*wt,data=mtcars)<br/>R&gt; len &lt;- 20<br/>R&gt; hp.seq &lt;- seq(min(mtcars$hp),max(mtcars$hp),length=len)<br/>R&gt; wt.seq &lt;- seq(min(mtcars$wt),max(mtcars$wt),length=len)<br/>R&gt; hp.wt &lt;- expand.grid(hp=hp.seq,wt=wt.seq)<br/>R&gt; car.pred.mat &lt;- matrix(predict(car.fit,newdata=hp.wt),nrow=len,ncol=len)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_680"/>The built-in R function <code>persp</code> is used to create perspective plots. Its basic usage is the same as <code>contour</code>, <code>filled.contour</code>, and <code>image</code>. Your increasing sequences in the <em>x</em>- and <em>y</em>-axis directions, which define the evaluation grid, are passed to <code>x</code> and <code>y</code>, with your corresponding <em>z</em>-matrix passed to <code>z</code>. Bring up the default appearance for the 20 × 20 <code>mtcars</code> response surface with the following:</p>&#13;
<pre>R&gt; persp(x=hp.seq,y=wt.seq,z=car.pred.mat)</pre>&#13;
<p class="indent">This appears in the top left of <a href="ch25.xhtml#ch25fig19">Figure 25-19</a>.</p>&#13;
<p class="indent">Interpreting the perspective plot is straightforward. The default viewing angle shows the <em>x</em>-axis in the foreground, increasing from left to right, and the <em>y</em>-axis on the left side, increasing from the foreground to deeper in the background. In this way, the evaluation grid lies flat along the bottom in the 3D graphic, with the <em>z</em>-axis against which your surface is plotted increasing from the bottom vertically to the top.</p>&#13;
<p class="indent">The viewing angle is one of the most important aspects of such a plot. In <code>persp</code>, you can control it with the two optional arguments <code>theta</code>, which spins the plot around horizontally, and <code>phi</code>, which adjusts the vertical viewing position. Both are specified in degrees; <code>theta</code> defaults to <code>0</code>, so you’re looking directly at the <em>x</em>-axis spanning left to right in front of you, and <code>phi</code> defaults to <code>15</code> to give a slightly elevated viewing position so you can see the <em>y</em>-axis extending foreground to background. In general, you can think of the possible value of <code>theta</code> as anywhere from <code>0</code> to <code>360</code>, representing a complete rotation all around the plot, and the possible value of <code>phi</code> as anywhere from <code>90</code> to <code>-90</code>, the range of which moves you from a bird’s-eye view directly from the top looking down to a submarine view directly from the bottom looking up.</p>&#13;
<p class="indent">This second example demonstrates this behavior:</p>&#13;
<pre>R&gt; persp(x=hp.seq,y=wt.seq,z=car.pred.mat,theta=-30,phi=23,<br/>         xlab="Horsepower",ylab="Weight",zlab="mean MPG")</pre>&#13;
<p class="indent">In fact, it’s this line of code that originally produced the rightmost image in <a href="ch21.xhtml#ch21fig9">Figure 21-9</a> on <a href="ch21.xhtml#page_523">page 523</a> (when you were introduced to the concept of an interactive term between two continuous predictors in a multiple linear regression model). The graphic is reproduced here in the top right of <a href="ch25.xhtml#ch25fig19">Figure 25-19</a>. The axis titles are tidied up using <code>xlab</code> and <code>ylab</code>, with <code>zlab</code> used to control the title for the third vertical axis. The use of <code>theta</code> and <code>phi</code> in this instance has elevated the viewing point slightly more than the default and rotated the plot so that the origin (in other words, the lower vertex denoting the lower limit of the <em>x</em>-<em>y</em> plane) is prominent in the foreground. It’s worth noting that increasing <code>theta</code> from <code>0</code> rotates the plot in a clockwise-horizontal fashion, but you could also supply a negative value to that argument to rotate the plot in the other direction. Setting <code>theta=-30</code>, as shown here, has the same effect as setting <code>theta=330</code>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_681"/><img src="../images/f25-19.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig19"/>Figure 25-19: Perspective plots of the 20</em> × <em>20</em> <code>mtcars</code> <em>response surface created using</em> <code>persp</code><em>. Top left: Default appearance. Top right: Using</em> <code>theta</code> <em>and</em> <code>phi</code> <em>to adjust the viewing angle. Bottom left: Setting</em> <code>ticktype="detailed"</code> <em>to provide detailed axis labeling. Bottom right: Adding depth shading using</em> <code>shade</code> <em>and removing facet border lines with</em> <code>border=NA</code>.</p>&#13;
<p class="indent">By default, there are no tick marks or labels included, only directional arrows. You can remedy this by setting the optional <code>ticktype</code> argument to <code>"detailed"</code>. You can find the result of the following in the bottom left of <a href="ch25.xhtml#ch25fig19">Figure 25-19</a>, which also offers another viewing angle:</p>&#13;
<pre>R&gt; persp(x=hp.seq,y=wt.seq,z=car.pred.mat,theta=40,phi=30,ticktype="detailed",<br/>         xlab="Horsepower",ylab="Weight",zlab="mean MPG")</pre>&#13;
<p class="indent">The help file <code>?persp</code> details a host of other arguments specific to controlling the presentation of any given perspective plot. As a few examples, you could shade the surface in grayscale to emphasize the 3D depth of the image, you could change the color or suppress the plotting of the grid lines making up the surface itself, or you could change the relative length of the <em>z</em>-axis. The final plot of the <code>mtcars</code> response surface illustrates such actions. The result of the following call is visible in the bottom right of <a href="ch25.xhtml#ch25fig19">Figure 25-19</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_682"/>R&gt; persp(x=hp.seq,y=wt.seq,z=car.pred.mat,theta=40,phi=30,ticktype="detailed",<br/>         shade=0.6,border=NA,expand=0.8,<br/>         xlab="Horsepower",ylab="Weight",zlab="mean MPG")</pre>&#13;
<p class="indent">With the same viewing angle as the previous plot, this plot uses the <code>shade</code> argument to shade the surface facets to produce a lighting-style effect, enhancing the perceptive depth slightly. The calculations for the shading rely on a non-negative numeric value; setting <code>shade=0.6</code> provides a moderate-strength effect. You might like to experiment with larger or smaller values. If you’re shading the surface in this way, it’s usually best to suppress the grid lines that by default make up the surface; you can set <code>border=NA</code> to achieve this (the <code>border</code> argument can also be used to simply change the surface grid color by supplying any valid R color to it). Finally, the <code>expand</code> argument is used to adjust the size of the <em>z</em>-axis. Specifying <code>expand=0.8</code> requests a vertical axis that is 80 percent the size of the axes in the evaluation grid, producing a slightly “squashed down” prism in which the surface is drawn. You could also use values greater than 1 for <code>expand</code>, in which case the effect would be to “stretch out” the plot along the vertical.</p>&#13;
<h4 class="h4" id="ch25lev2sec259"><strong><em>25.6.2 Coloring Facets</em></strong></h4>&#13;
<p class="noindent">Like most traditional R plotting commands, you can use the optional <code>col</code> argument to color the facets of a perspective surface. To color a perspective surface with a constant color throughout, you would just provide <code>col</code> with a single value.</p>&#13;
<p class="indent">If you’re interested in <code>col</code>, however, it’s often the case that you want to color the surface according to the fluctuating <em>z</em>-values to highlight the changing value of the bivariate function. To successfully do this for the facets making up the surface, it’s important to understand that these facets aren’t the same as the pixels that would make up a pixel image of the same <em>z</em>-matrix. Where <code>image</code> pixels are directly represented by the entries of, say, your <em>m</em> × <em>n</em>-sized <em>z</em>-matrix, <code>persp</code> facets should be interpreted as the space <em>between</em> the border lines drawn at those matrix entries, leaving you with (<em>m</em> − 1) × (<em>n</em> − 1) facets. In other words, in a perspective plot, each <em>z</em>-matrix entry lies at an intersection of the drawn lines—the <em>z</em>-matrix entries are <em>not</em> situated in the middle of each facet.</p>&#13;
<p class="indent">To illustrate this, take another look at <a href="ch25.xhtml#ch25fig9">Figure 25-9</a> on <a href="ch25.xhtml#page_656">page 656</a>. When you use <code>image</code>, R automatically calculates the pixel sizes based on your <em>x</em>- and <em>y</em>-axis evaluation grid sequences and plots the surface based on the rectangles formed by the dashed gray lines, with the <em>z</em>-matrix entries <code>a</code>, <code>b</code>, <code>c</code>, and so on, represented directly. When you use <code>persp</code>, however, the visible border lines are represented by the solid-line grid (of arrows), intersecting at each entry, and so the facets of the resulting surface are formed by the space between these lines, each one defined by four adjacent entries. <a href="ch25.xhtml#ch25fig20">Figure 25-20</a> shows a section of the hypothetical grid in <a href="ch25.xhtml#ch25fig9">Figure 25-9</a>, where I’ve marked <span epub:type="pagebreak" id="page_683"/>off one pixel as interpreted by <code>image</code> and one facet as interpreted by <code>persp</code>. With that, you can see why, in <a href="ch25.xhtml#ch25fig9">Figure 25-9</a>, there would be exactly 6 × 4 = 24 pixels in an image plot but 5 × 3 = 15 facets in a perspective plot.</p>&#13;
<div class="image"><img src="../images/f25-20.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig20"/>Figure 25-20: Illustrating the difference in treatment of the</em> z<em>-matrix in a pixel image and in a perspective plot. The highlighted box in the bottom-left corner represents an</em> <code>image</code> <em>pixel of the value</em> <code>a</code> <em>in the</em> z<em>-matrix; the highlighted box to the right represents a</em> <code>persp</code> <em>facet formed by the values</em> <code>b</code>, <code>h</code>, <code>i</code><em>, and</em> <code>c</code><em>. For coloring, the</em> z<em>-value of the highlighted facet will be calculated as the mean of those four entries, in other words,</em> (<code>b</code> + <code>h</code> + <code>i</code> + <code>c</code>)<em>/4.</em></p>&#13;
<p class="indent">The <code>col</code> argument needs to specify the (<em>m</em> − 1) × (<em>n</em> − 1) facet colors (assuming an <em>m</em> × <em>n z</em>-matrix passed to <code>z</code>). The typical way to find this in R if you’re intending to color the facets according to the <em>z</em>-value is to first calculate each facet’s <em>z</em>-value, which will be the average of the four adjacent <em>z</em>-matrix entries. Only thereafter can you deploy one of the color assignment approaches from <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>.</p>&#13;
<p class="indent">Let’s recast the pixel image of the Chorley-Ribble kernel density estimate (Example 4; <a href="ch25.xhtml#ch25fig18">Figure 25-18</a>), complete with <em>z</em>-axis-specific coloring, as a perspective plot. First, make sure you have the packages <code>spatstat</code> and <code>MASS</code> already loaded. Then repeat the code from earlier to obtain the kernel estimate on the appropriate evaluation grid, truncated to the geographical study region.</p>&#13;
<pre>R&gt; chor.WIN &lt;- chorley$window<br/>R&gt; chor.dens.WIN &lt;- kde2d(chorley$x,chorley$y,n=256,<br/>                          lims=c(chor.WIN$xrange,chor.WIN$yrange))<br/>R&gt; chor.xy &lt;- expand.grid(chor.dens.WIN$x,chor.dens.WIN$y)<br/>R&gt; chor.out.mat &lt;- matrix(!inside.owin(x=chor.xy[,1],y=chor.xy[,2],w=chor.WIN),<br/>                          256,256)<br/>R&gt; chor.dens.WIN$z[chor.out.mat] &lt;- NA</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_684"/>Next, you need to calculate all the facet <em>z</em> values; this can be done en masse with the following code:</p>&#13;
<pre>R&gt; zm &lt;- chor.dens.WIN$z<br/>R&gt; nr &lt;- nrow(zm)<br/>R&gt; nc &lt;- ncol(zm)<br/>R&gt; zf &lt;- (zm[-1,-1]+zm[-1,-nc]+zm[-nr,-1]+zm[-nr,-nc])/4<br/>R&gt; dim(zf)<br/>[1] 255 255</pre>&#13;
<p class="indent">The first three lines simply store the <em>z</em>-matrix as the object <code>zm</code> and its total rows and columns (both 256 in this case) as <code>nr</code> and <code>nc</code>, respectively, for compactness of the code.</p>&#13;
<p class="indent">The fourth line is where the relevant calculations happen, giving a matrix of the facet <em>z</em> values. It does this systematically, by element-wise summation of four versions of the original <em>z</em>-matrix: <code>zm[-1,-1]</code> (first row and first column omitted), <code>zm[-1,-nc]</code> (first row, last column omitted), <code>zm[-nr,-1]</code> (last row, first column omitted), and <code>zm[-nr,-nc]</code> (last row, last column omitted). When the four alternates are summed in this way and divided by 4 at the end, the result is a matrix <code>zf</code>, each element of which is the four-point average of each “rectangle” of four adjacent entries in the original <em>z</em>-matrix, exactly as noted in the discussion and caption of <a href="ch25.xhtml#ch25fig20">Figure 25-20</a>. The final call to <code>dim</code> on <code>zf</code> confirms the size of the result. Since there are a total of 256 × 256 evaluation grid lines in the defined <em>z</em>-matrix, these encapsulate a total of 255 × 255 perspective facets.</p>&#13;
<p class="indent">The hard work is done, and all you need to do now is assign the colors from your palette to the calculated facet <em>z</em> values in <code>zf</code>. You can do this using either the categorization or normalization approach, as noted in <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>; for simplicity, let’s stick to categorization. Consider the following code:</p>&#13;
<pre>R&gt; rbow &lt;- rainbow(200,start=0,end=5/6)<br/>R&gt; zf.breaks &lt;- seq(min(zf,na.rm=TRUE),max(zf,na.rm=TRUE),length=201)<br/>R&gt; zf.colors &lt;- cut(zf,breaks=zf.breaks,include.lowest=TRUE)</pre>&#13;
<p class="indent">The first line is repeated from <a href="ch25.xhtml#ch25lev2sec257">Section 25.5.2</a> to generate the same 200 colors from the built-in <code>rainbow</code> palette as were used in the pixel images. The second line sets up an evenly spaced sequence spanning the range of the calculated facet <em>z</em>-values to form the category break points that are required by the categorization approach. Note the use of <code>na.rm=TRUE</code> in the required calls to <code>min</code> and <code>max</code> to avoid all the <code>NA</code> entries present in <code>zf</code> (remember, the surface has been truncated to the irregular polygon representing the geographical study region). The sequence is one more in length than the number of generated colors—again, refer to <a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a> for this necessary feature of the categorization approach. Lastly, <code>cut</code> assigns each of the <code>zf</code> facet value entries an appropriate rank with respect to the 200 ordered bins. As you’ve learned, <span epub:type="pagebreak" id="page_685"/>the <code>zf.colors</code> ranks are subsequently used to index the vector of 200 colors stored in <code>rbow</code> when plotting.</p>&#13;
<p class="indent">With that, you can enjoy the fruits of your labor! The following code plots the bivariate kernel density estimate of the Chorley-Ribble observations as a perspective plot using facet coloring to reflect the relative height of the surface along the <em>z</em>-axis. Border lines are suppressed to show off the color clearly, the <em>z</em>-axis is scaled down slightly, and a color legend is inserted on the right side (ensure the <code>shape</code> package has been loaded for that) after manipulating the default figure margins via <code>mar</code> in a call to <code>par</code> to create extra space for it. You can find the result in <a href="ch25.xhtml#ch25fig21">Figure 25-21</a>.</p>&#13;
<pre>R&gt; par(mar=c(0,1,0,7))<br/>R&gt; persp(chor.dens.WIN$x,chor.dens.WIN$y,chor.dens.WIN$z,border=NA,<br/>         col=rbow[zf.colors],theta=-30,phi=30,scale=FALSE,expand=750,<br/>         xlab="Eastings (km)",ylab="Northings (km)",zlab="Kernel estimate")<br/>R&gt; colorlegend(col=rbow,zlim=range(chor.dens.WIN$z,na.rm=TRUE),<br/>               zval=seq(0,0.02,0.0025),main="KDE",digit=4,<br/>               posx=c(0.85,0.87),posy=c(0.2,0.8))</pre>&#13;
<div class="image"><img src="../images/f25-21.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig21"/>Figure 25-21: A perspective plot of the Chorley-Ribble density estimate, demonstrating facet coloring that changes according to the</em> z<em>-value of the surface.</em></p>&#13;
<p class="indent">I’ve included the optional argument <code>scale=FALSE</code> in the execution of <code>persp</code>. This retains a one-to-one aspect ratio in the <em>x</em>- and <em>y</em>-coordinate directions; this is useful since you’re looking at geographical data. Unfortunately, this also forces the density estimate values on the <em>z</em>-axis to be scaled in the same way, which makes no sense in the context of the current plot. To avoid the small scale resulting in a supremely flat appearance of the surface itself, you need to use <code>expand</code> to artificially amplify the surface along the third axis. <span epub:type="pagebreak" id="page_686"/>In this instance, multiplying it by a factor of around 750 provides a visually pleasing result. Note that this would not be necessary if you left the <code>scale</code> argument at its default <code>TRUE</code> value (since, in that case, R internally scales all three axes for a one-to-one-to-one aspect ratio).</p>&#13;
<h4 class="h4" id="ch25lev2sec260"><strong><em>25.6.3 Rotating with Loops</em></strong></h4>&#13;
<p class="noindent">There’s one last bit of fun you can have with perspective plots if you want to get an overall impression of the plotted surface. Using a simple <code>for</code> loop (<a href="ch10.xhtml#ch10lev2sec92">Section 10.2.1</a>) to increment either <code>theta</code> or <code>phi</code>, you can perform a series of repeated calls to <code>persp</code>, each one at a slightly new angle. Doing this in sequence results in an animation—essentially a cartoon—of a rotating surface, allowing you to see it from all different sides.</p>&#13;
<p class="indent">Consider the following basic function in the R editor:</p>&#13;
<pre>persprot &lt;- function(skip=1,...){<br/>    for(i in seq(90,20,by=-skip)){<br/>        persp(phi=i,theta=0,...)<br/>    }<br/>    for(i in seq(0,360,by=skip)){<br/>        persp(phi=20,theta=i,...)<br/>    }<br/>}</pre>&#13;
<p class="indent">Using an ellipsis (see <a href="ch11.xhtml#ch11lev2sec102">Section 11.2.4</a>), <code>persprot</code> simply takes all the arguments you’d usually supply to a call to <code>persp</code>, barring <code>theta</code> and <code>phi</code>. Then comes a <code>for</code> loop, which immediately calls <code>persp</code> with <code>theta=0</code> and the content of the ellipsis. The <code>for</code> loop alters the vertical viewing angle, starting with <code>phi=90</code> (birds-eye view) and moving down to a mildly elevated <code>phi=20</code>. A second <code>for</code> loop then completes a full 360-degree horizontal rotation by altering <code>theta</code>.</p>&#13;
<p class="indent">The only formally tagged argument is <code>skip</code>, which determines the amount <code>phi</code> and <code>theta</code> increment by at each iteration. The default, <code>skip=1</code>, simply moves through the integer-valued angles. Increasing <code>skip</code> will reduce the time it takes to complete the rotation, though it makes for a more jagged animation.</p>&#13;
<p class="indent">Depending on the type of graphics device you’re using, you may want to experiment with <code>skip</code>. Note that not all graphics device types will be well-suited to the animation effect sought by running this rather crude function (for example, it’s not appropriate if you’re using RStudio—see <a href="app02.xhtml#app02">Appendix B</a>). That said, when running the base R GUI applications on OS X or Windows, I find <code>persprot</code> works well under default graphics settings.</p>&#13;
<p class="indent">Import the function to try it; let’s do so here for a perspective plot of a kernel estimate of the probability density function of the spatial <code>quakes</code> locations you first examined as Example 3, <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>. With the <code>MASS</code> package already loaded, produce the density estimate on a 50 × 50 evaluation grid with the following line.</p>&#13;
<pre><span epub:type="pagebreak" id="page_687"/>R&gt; quak.dens &lt;- kde2d(x=quakes$long,y=quakes$lat,n=50)</pre>&#13;
<p class="indent">Then you use <code>persprot</code> just as you’d use <code>persp</code>, without needing to specify either <code>theta</code> or <code>phi</code>.</p>&#13;
<pre>R&gt; persprot(x=quak.dens$x,y=quak.dens$y,z=quak.dens$z,border="red3",shade=0.4,<br/>            ticktype="detailed",xlab="Longitude",ylab="Latitude",<br/>            zlab="Kernel estimate")</pre>&#13;
<p class="indent"><a href="ch25.xhtml#ch25fig22">Figure 25-22</a> shows a series of screenshots of the rotating plot.</p>&#13;
<div class="image"><img src="../images/f25-22.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch25fig22"/>Figure 25-22: A rotating perspective plot of a KDE surface for the spatial earthquake locations, after a call to the custom</em> <code>persprot</code> <em>function</em></p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch25exc5"/><strong>Exercise 25.5</strong></p>&#13;
<p class="noindentz">In <a href="ch25.xhtml#ch25exc3">Exercise 25.3</a> (a), you revisited the <code>nuclear</code> data set from the <code>boot</code> package and fitted two multiple linear regression models aiming to model mean construction cost by permit date issue and plant capacity—one with main effects only and the other including an interaction term between the two continuous predictors.</p>&#13;
<ol type="a">&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_688"/>Refit the two versions of the model and produce perspective plots of the response surfaces based again on a 50 × 50 evaluation grid, taking the following into account:</p>&#13;
<p class="dash">– Use <code>mfrow</code> in a call to <code>par</code> to display the two perspective plots next to each other. In the same call to <code>par</code>, override the default figure margins to have only one line of space on each side (<code>par</code> is explored in this role in <a href="ch23.xhtml#ch23">Chapter 23</a>).</p>&#13;
<p class="dash">– Use <code>zlim</code> to ensure both plots are displayed on the same scale of vertical axis, spin each one horizontally 25 degrees, and ensure detailed axis markings and tidy titles.</p>&#13;
<p class="dash">– Is there any visual indication that the presence of the interaction term has had any meaningful impact on modeling the response?</p></li>&#13;
<li><p class="noindents">Start a fresh plot. To get a better idea of the difference between the two surfaces, produce a perspective plot of the <em>z</em>-matrix obtained as the elementwise difference between the two individual <em>z</em>-matrices for the two fitted models in (a). What, in general, is the effect of including the interaction term?</p></li>&#13;
</ol>&#13;
<p class="noindentz">Turn your attention back to the topographical information on the Auckland volcano, as the built-in R object <code>volcano</code>: an 87 × 61 matrix of elevation values (in meters). You first looked at this in <a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a> as a contour plot.</p>&#13;
<ol type="a" start="3">&#13;
<li><p class="noindents">Produce the most basic, default perspective plot of the volcano, using simple integer sequences for the <em>x</em>- and <em>y</em>-coordinates.</p></li>&#13;
<li><p class="noindents">The plot in (c) is decidedly unappealing for a number of reasons. Produce a more realistic depiction of the volcano as per the following:</p>&#13;
<p class="dash">– Use a new graphics device with the margin widths reset to one, one, one, and four lines on the bottom, left, top, and right, respectively.</p>&#13;
<p class="dash">– The help file <code>?volcano</code> reveals the <em>x</em>- and <em>y</em>-coordinates to which the volcano <em>z</em>-matrix corresponds is in 10-meter units. Using <code>scale</code> and altering <code>expand</code>, replot the surface with the correct aspect ratio in all three axes.</p>&#13;
<p class="dash">– Suppress all axis tick marks and notation using <code>axes</code>.</p>&#13;
<p class="dash">– The facets should be colored according to 50 colors generated from the built-in <code>terrain.colors</code> palette, and the facet border lines should be suppressed.</p>&#13;
<p class="dash"><span epub:type="pagebreak" id="page_689"/>– Find your choice of visually appealing viewing angle.</p>&#13;
<p class="dash">– Use <code>colorlegend</code> from the <code>shape</code> package to place a color legend referencing elevation in meters in the space to the right of the plot. Experiment with the arguments to find appropriate placement and tick mark labels.</p>&#13;
<p class="dashp">Here’s my version of the improved plot:</p>&#13;
<div class="imagec"><img src="../images/f0689-01.jpg" alt="image"/></div></li>&#13;
</ol>&#13;
<p class="noindentz">In <a href="ch25.xhtml#ch25exc4">Exercise 25.4</a>, you looked at the spatial distribution of intentionally lit fires in a region of Spain. Ensure the <code>spatstat</code> package is loaded, and then rerun the following lines to obtain the relevant data objects:</p>&#13;
<p class="programs-b1">R&gt; fire &lt;- split(clmfires)$intentional<br/>R&gt; firewin &lt;- clmfires$window</p>&#13;
<ol type="a" start="5">&#13;
<li><p class="noindents">Borrow the code from <a href="ch25.xhtml#ch25exc4">Exercise 25.4</a> (d) and (e) to reproduce the kernel density estimate of this dispersion of observations, based on a 256 × 256 evaluation grid, truncated to the study region. Then, display it as a perspective plot according to the following:</p>&#13;
<p class="dash">– Just as with the pixel image, use 50 colors from the built-in <code>heat.colors</code> palette to color the facets by <em>z</em> value. Note the truncated <em>z</em>-matrix for this function contains <code>NA</code> values.</p>&#13;
<p class="dash">– Border lines on the surface should be suppressed, and you should find your preferred choice of viewing angle.</p>&#13;
<p class="dash">– Use <code>scale</code> to ensure the correct spatial aspect ratio. In doing so, you’ll also need to adjust the <em>z</em>-axis expansion by a factor of around 5,000,000 for the density surface to be visible along the vertical, given the natural scaling of the density estimate on the specified evaluation grid.</p>&#13;
<p class="dash">– Employ detailed axis labeling and simply entitle the axes <code>"X"</code>, <code>"Y"</code>, and <code>"Z"</code> as appropriate.</p>&#13;
<p class="dashp"><span epub:type="pagebreak" id="page_690"/>My product is given here.</p>&#13;
<div class="imagec"><img src="../images/f0690-01.jpg" alt="image"/></div></li>&#13;
<li><p class="noindents">Use the <code>persprot</code> function defined in <a href="ch25.xhtml#ch25lev2sec260">Section 25.6.3</a> to view the surface from (e), setting <code>skip=10</code>.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch25lev3sec115"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>palette</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">List integer colors</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec242">Section 25.1.1</a>, <a href="ch25.xhtml#page_632">p. 632</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>col2rgb</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Named color to RGB</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec242">Section 25.1.1</a>, <a href="ch25.xhtml#page_632">p. 632</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rgb</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">RGB to hex code</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec242">Section 25.1.1</a>, <a href="ch25.xhtml#page_633">p. 633</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rainbow</code>, <code>heat.colors</code>, <code>gray</code>, <code>terrain.colors</code>, <code>cm.colors</code>, <code>topo.colors</code>, <code>gray.colors</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Built-in palettes</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec243">Section 25.1.2</a>, <a href="ch25.xhtml#page_635">p. 635</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>colorRampPalette</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Custom palette (integer)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec244">Section 25.1.3</a>, <a href="ch25.xhtml#page_636">p. 636</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>colorRamp</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Custom palette ([0,1] interval)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec245">Section 25.1.4</a>, <a href="ch25.xhtml#page_640">p. 640</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>colorlegend</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Color legend (<code>shape</code>)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec246">Section 25.1.5</a>, <a href="ch25.xhtml#page_641">p. 641</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>scatterplot3d</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">3D scatterplot (<code>scatterplot3d</code>)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec249">Section 25.2.1</a>, <a href="ch25.xhtml#page_649">p. 649</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>expand.grid</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">All unique evaluation coords.</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec251">Section 25.3.1</a>, <a href="ch25.xhtml#page_654">p. 654</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>letters</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Alphabet characters</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec251">Section 25.3.1</a>, <a href="ch25.xhtml#page_655">p. 655</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>contour</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Contour plot</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>, <a href="ch25.xhtml#page_657">p. 657</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>kde2D</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Bivariate KDE (<code>MASS</code>)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec254">Section 25.4.1</a>, <a href="ch25.xhtml#page_660">p. 660</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>filled.contour</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Color-filled contour plot</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec255">Section 25.4.2</a>, <a href="ch25.xhtml#page_664">p. 664</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>image</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pixel images</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec256">Section 25.5.1</a>, <a href="ch25.xhtml#page_668">p. 668</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>inside.owin</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Test inside region (<code>spatstat</code>)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec257">Section 25.5.2</a>, <a href="ch25.xhtml#page_674">p. 674</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>persp</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Perspective plot</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch25.xhtml#ch25lev2sec258">Section 25.6.1</a>, <a href="ch25.xhtml#page_680">p. 680</a></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>