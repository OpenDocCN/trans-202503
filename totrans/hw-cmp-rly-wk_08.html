<html><head></head><body>
<span epub:type="pagebreak" id="page_137"/>&#13;
<h2 class="h2"><strong><span class="big">8</span><br/>MACHINE CODE AND ASSEMBLY LANGUAGE</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">We’ve covered the physical parts of a computer: the CPU, main memory, and I/O devices. Understanding the hardware of a computer is important, but hardware is only half the story. The magic of computers is in software. It’s software that moves a computer from being a fixed-purpose device to a highly flexible device that can easily take on new abilities! In this chapter we cover low-level software—machine code and assembly language. I’ve found that these topics are best understood using an interactive approach, so the bulk of this chapter’s content is in the projects.</p>&#13;
<h3 class="h3" id="lev1_50"><strong><span epub:type="pagebreak" id="page_138"/>Software Terms Defined</strong></h3>&#13;
<p class="noindent">To discuss software, I need to first introduce several terms. Instructions that tell a computer what to do are known as <em>software</em>; this contrasts with hardware, the physical elements of a computer. An ordered set of software instructions that accomplishes a task is called a <em>program</em>, and <em>programming</em> is the act of writing such programs.</p>&#13;
<p class="indent">The term <em>application</em> is sometimes used synonymously with program, although <em>application</em> tends to refer to a program that interacts directly with humans, rather than programs that interact with software or hardware. An application may also consist of multiple programs working together. The word <em>app</em> came into popular use around 2008, and tends to carry other connotations that I will cover in <a href="ch13.xhtml">Chapter 13</a>.</p>&#13;
<p class="indent">Another name for a set of software instructions is <em>computer code</em>, or just <em>code</em>. CPUs execute <em>machine code</em>, whereas software developers typically write their source code in a higher-level programming language. The term <em>source code</em> refers to the text of a program as originally written by developers. Such code usually isn’t written in a form that CPUs understand directly, so additional steps must be taken before it can run on a computer. I will cover more details on source code and high-level programming languages in <a href="ch09.xhtml">Chapter 9</a>, but now let’s look at the foundation of software: machine code.</p>&#13;
<p class="indent">Machine code is software in the form of binary <em>machine language</em> instructions. As described in <a href="ch07.xhtml">Chapter 7</a>, a CPU’s architecture determines which instructions that particular CPU understands. In the same way that a human language is formed from a vocabulary, a machine language is formed from a list of instructions known to a CPU family. Vocabulary words arranged into sentences convey meaning, and CPU instructions arranged into programs do the same.</p>&#13;
<p class="indent">No matter how a program was originally written (and there are lots of ways to write programs), it eventually needs to execute on a CPU as a series of machine language instructions. As you might expect, CPU instructions boil down to a series of 0s and 1s, just like everything else a computer deals with. This is worth repeating: no matter how a program was originally written, no matter what programming language was used, no matter what technologies were involved, in the end, that program becomes a series of 0s and 1s, representing instructions that a CPU can execute.</p>&#13;
<p class="indent">Some years ago, I had a job that involved diagnosing software failures. Often, the problems I analyzed occurred in software written by other companies. I didn’t have the source code for this software, nor did I have much information about how the software was supposed to work, and yet my job was to determine why the software was failing! I had a coworker who took this in stride, and he regularly reminded me that “it’s just code.” In other words, the failing software was just a bunch of 1s and 0s that a CPU interpreted as instructions. If a CPU can make sense of the code, so can you.</p>&#13;
<h3 class="h3" id="lev1_51"><strong><span epub:type="pagebreak" id="page_139"/>An Example Machine Instruction</strong></h3>&#13;
<p class="noindent">I think the simplest way to jump into the topic of machine code is to look at an example. Let’s take a look at a specific machine instruction understood by the ARM family of processors. As you may recall, ARM processors are found in most smartphones, so this instruction is probably something your phone would understand.</p>&#13;
<p class="indent">Our example instruction tells the processor to move the number 4 into the <code>r7</code> register, one of several general-purpose registers on ARM processors. Recall from our previous discussion of computer hardware that a register is a small storage location within the CPU. The ARM instruction for doing that looks like this in binary:</p>&#13;
<pre>11100011101000000111000000000100</pre>&#13;
<p class="indent">Let’s examine how an ARM CPU would go about making sense of this instruction, as shown in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>. Note that we’re skipping some of the bits that aren’t relevant to our discussion.</p>&#13;
<div class="image" id="ch8fig1"><img src="../images/fig8-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 8-1: Decoding an ARM instruction</em></p>&#13;
<p class="indent">The <em>condition</em> section specifies the conditions under which the instruction should be executed. <code>1110</code> means the instruction is not conditional, so the CPU should always execute it. Although this is not the case in this example, some instructions only need to run under specific conditions. The next two bits, <code>00</code> in this example, aren’t relevant to our discussion, so we’ll skip them. The <em>immediate bit</em> tells us whether we’re accessing a value in a register or accessing a value specified in the instruction itself (known as an <em>immediate value</em>). In this case, the immediate bit is <code>1</code>, so we’re using a number specified within the instruction. If the immediate bit were <code>0</code>, the register that should be accessed would be specified elsewhere in the instruction’s bits. The <em>opcode</em> represents the operation that the CPU is to perform. In this case, it’s <code>mov</code>, meaning the CPU has to move some data. The <em>destination register</em> of <code>0111</code> tells us we’re moving a value into register <code>r7</code> (<code>0111</code> is binary for seven). Finally, the <span epub:type="pagebreak" id="page_140"/>immediate value of <code>00000100</code> is 4 in decimal, which is the number we want to move into register <code>r7</code>. To recap, this binary sequence tells an ARM CPU to move the number 4 into the <code>r7</code> register.</p>&#13;
<p class="indent">A CPU always deals with everything in binary, but most people have a hard time with all those 0s and 1s. Let’s represent the same instruction in hexadecimal to make it somewhat easier to read:</p>&#13;
<pre>e3a07004</pre>&#13;
<p class="indent">Now isn’t that better? Well, maybe not. It’s more compact and easier to distinguish than binary, but its meaning still isn’t obvious. Fortunately for us, there’s yet another way to represent this instruction: assembly language. <em>Assembly language</em> (or <em>assembler language</em>) is a programming language in which each statement directly represents a machine language instruction. Each type of machine language has a corresponding assembly language—x86 assembly, ARM assembly, and so forth. An assembly language statement consists of a <em>mnemonic</em> that represents a CPU opcode, plus any required operands (such as a register or numeric value). A mnemonic is a human-readable form of an opcode, allowing assembly language programmers to use <code>mov</code> instead of <code>1101</code> in their code. The same ARM instruction discussed earlier can also be represented using the following assembly language statement:</p>&#13;
<pre>mov r7, #4</pre>&#13;
<p class="indent">Compared to the corresponding binary and hexadecimal representations, this statement is certainly a better way to say, “move 4 into the r7 register”! At least it’s easier to read for humans. That said, remember that the assembly language statement is just a convenience for people. A CPU never executes instructions in a text format, it only deals with the binary form of an instruction. If a programmer writes a program in assembly language, the assembly instructions must still be turned into machine code before a computer runs the program. This is accomplished using an <em>assembler</em>, a program that translates assembly language statements to machine code. An assembly language text file is fed into an assembler, and the output is a binary object file containing machine code, as illustrated in <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>.</p>&#13;
<div class="image" id="ch8fig2"><img src="../images/fig8-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 8-2: An assembler turns assembly language into machine code.</em></p>&#13;
<h3 class="h3" id="lev1_52"><strong><span epub:type="pagebreak" id="page_141"/>Calculating a Factorial in Machine Code</strong></h3>&#13;
<p class="noindent">Now that we’ve examined a single ARM instruction, let’s see how multiple instructions can be combined to perform a useful task. Let’s look at some ARM machine code that calculates the factorial of an integer. As you may remember from math class, the factorial of <em>n</em> (written as <em>n</em>!) is the product of the positive integers less than or equal to <em>n</em>. So as an example, the factorial of 4 is</p>&#13;
<p class="centerb">4! = 4 × 3 × 2 × 1 = 24</p>&#13;
<p class="indent">Now that we have a definition for factorial, let’s look at an implementation of a factorial calculation in ARM machine code. To keep things simple, we won’t examine the full program code, just the part that does the factorial algorithm. We assume that initially the value of <em>n</em> is stored in the r0 register, and that when the code completes, the result of the calculation is also stored in r0.</p>&#13;
<p class="indent">Machine code, like any other data a computer deals with, must be loaded into memory before the CPU can access it. The following is a view of our machine code as 32-bit (4-byte) hexadecimal values, along with the memory address of each value.</p>&#13;
<pre>Address   Data   <br/>&#13;
0001007c  e2503001<br/>&#13;
00010080  da000002<br/>&#13;
00010084  e0000093<br/>&#13;
00010088  e2533001<br/>&#13;
0001008c  1afffffc</pre>&#13;
<p class="indent">When our code loads into memory, the factorial logic starts at address <code>0001007c</code>. Let’s examine the contents of memory starting at that address. Note that <code>0001007c</code> isn’t a magic address; it just happens to be where the code loaded in this example. Note, also, that the memory address values increase by 4 because each data value requires 4 bytes of storage. Each ARM instruction is 4 bytes in length, so this data represents five ARM instructions.</p>&#13;
<p class="indent">Looking at these instructions as hexadecimal values doesn’t give us much insight to their meaning, so let’s decode the instructions so we can make sense of this program. In the following listing, I’ve converted the hexadecimal data values to their corresponding assembly language mnemonics. In case you’re wondering, manually translating machine language to assembly language isn’t something you need to know how to do! We have software for that called a <em>disassembler</em>. For now, this book acts as your disassembler. Here’s each instruction paired with its assembly statement:</p>&#13;
<pre>Address   Data      Assembly<br/>&#13;
0001007c  e2503001  subs r3, r0, #1<br/>&#13;
00010080  da000002  ble  0x10090<br/>&#13;
00010084  e0000093  mul  r0, r3, r0<br/>&#13;
00010088  e2533001  subs r3, r3, #1<br/>&#13;
0001008c  1afffffc  bne  0x10084<br/>&#13;
00010090  ---</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_142"/>The CPU executes these instructions sequentially until it hits a branching instruction (such as <code>ble</code> or <code>bne</code>), which may cause it to jump to another part of the program. Address <code>00010090</code> marks the end of the factorial logic. Once that address is reached, the factorial result has been stored in <code>r0</code>. At that point, the CPU executes whatever instruction happens to be at address <code>00010090</code>.</p>&#13;
<p class="indent">You may be wondering how these instructions represent a calculation of a factorial. For most people, a cursory look at such instructions isn’t sufficient to understand the underlying intent. Taking a step-by-step approach and tracking the values of the registers as each instruction is executed can help you understand the program. I’ll provide you with some needed background information, and then you can try evaluating how this program works.</p>&#13;
<p class="indent">To make sense of this program, you first need a description of each instruction used. In <a href="ch08.xhtml#ch8tab1">Table 8-1</a>, I’ve given you an explanation of each instruction in this program. In this table, I’ve used placeholder names for registers such as <em><code>Rd</code></em> and <em><code>Rn</code></em>. When you review assembly code, you’ll see actual register names used instead, such as <code>r0</code> or <code>r3</code>. The order of the operands listed in the code corresponds to the order of the operands in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>. For example, <code>subs r3, r0, #1</code> means subtract 1 from the value stored in <code>r0</code> and store the result in <code>r3</code>.</p>&#13;
<p class="tabcap" id="ch8tab1"><strong>Table 8-1:</strong> Explanation of a Few ARM Instructions</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Instruction</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Details</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><code>subs <em>Rd</em>, <em>Rn</em></code>, #Const</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Subtract</strong></p>&#13;
<p class="tab">Subtracts constant value <code>Const</code> from the value stored in register <code><em>Rn</em></code> and stores the result in register <code><em>Rd</em></code>.</p>&#13;
<p class="tab">In other words, <code><em>Rd</em> = <em>Rn</em></code> – Const</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><code>mul <em>Rd</em>, <em>Rn</em>, <em>Rm</em></code></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Multiply</strong></p>&#13;
<p class="tab">Multiplies the value stored in register <code><em>Rn</em></code> and the value stored in register <code><em>Rm</em></code> and stores the result in register <code><em>Rd</em></code>.</p>&#13;
<p class="tab">In other words, <code><em>Rd</em> = <em>Rn</em> × <em>Rm</em></code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><code>ble <em>Addr</em></code></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Branch if less than or equal</strong></p>&#13;
<p class="tab">If the previous operation’s result was less than or equal to 0, then jump to the instruction at address <code><em>Addr</em></code>. Otherwise, continue to the next instruction.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><code>bne <em>Addr</em></code></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Branch if not equal</strong></p>&#13;
<p class="tab">If the previous operation’s result was not 0, then jump to the instruction at address <code><em>Addr</em></code>. Otherwise, continue to the next instruction.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>BRANCHING AND THE STATUS REGISTER</strong></p>&#13;
<p class="exercise-para">The branch instructions don’t actually look at the numeric result of the previous instruction. ARM processors, like most CPUs, have a register dedicated to tracking status. This status register has 32 bits, and each bit corresponds to a certain status flag. For example, bit 31 is the <code>N</code> flag, and it is set to 1 when an instruction results in a negative number. Only certain instructions affect the state of these flags. For example, the <code>subs</code> instruction alters the state of the flags. If a certain subtraction operation results in a negative result, the <code>N</code> flag is set; otherwise, it is cleared. Other instructions, including branching instructions, then look at the status flags to determine what to do. This may seem like a roundabout approach, but really, it simplifies things for instructions like <code>bne</code>—the processor can branch (or not) based on the value of a single bit.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_143"/>&#13;
<p class="indent">We’ve reached the end of the explanatory content on this topic; the rest of the chapter is made up of an exercise and two projects. In <a href="ch08.xhtml#ch8ex1">Exercise 8-1</a>, you’ll walk through the example factorial program using the details found in <a href="ch08.xhtml#ch8tab1">Table 8-1</a> to understand how each instruction works.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch8ex1"><strong>EXERCISE 8-1: USE YOUR BRAIN AS A CPU</strong></p>&#13;
<p class="exercise-para">Try running the following ARM assembly program in your mind, or use pencil and paper:</p>&#13;
<pre>Address   Assembly<br/>&#13;
0001007c  subs r3, r0, #1<br/>&#13;
00010080  ble  0x10090<br/>&#13;
00010084  mul  r0, r3, r0<br/>&#13;
00010088  subs r3, r3, #1<br/>&#13;
0001008c  bne  0x10084<br/>&#13;
00010090  ---</pre>&#13;
<p class="exercise-parai">Assume an input value of <em>n</em> = 4 is initially stored in <code>r0</code>. When the program gets to the instruction at <code>00010090</code>, you’ve reached the end of the code, and <code>r0</code> should be the expected output value of 24. I recommend that for each instruction, you keep track of the values of <code>r0</code> and <code>r3</code> before and after the instruction completes. Work through the instructions until you reach the instruction at <code>00010090</code> and see if you got the expected result. If things worked correctly, you should have looped through the same instructions several times; that’s intentional. The answer is in <a href="appa.xhtml">Appendix A</a>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>Walking through assembly language on paper is a great start, but trying out assembly language on a computer is even better.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch08.xhtml#proj12">Project #12</a> on <a href="ch08.xhtml#page_145">page 145</a>, where you can assemble the factorial code and examine it while it runs. Also, see <a href="ch08.xhtml#proj13">Project #13</a> on <a href="ch08.xhtml#page_155">page 155</a>, where you can learn some additional approaches for examining machine code</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_53"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter we covered machine code, a series of CPU-specific instructions represented as bytes in memory. You learned how an example ARM processor instruction is encoded, and you saw how that instruction can be represented in assembly language. You learned that assembly language is a kind of source code, specifically a human-readable form of machine code. We saw how multiple assembly language statements can be combined to perform useful operations.</p>&#13;
<p class="indent">In the next chapter, we’ll cover high-level programming languages. Such languages provide an abstraction from a CPU’s instruction set, allowing developers to write source code that’s easier to understand and portable across different computer hardware platforms.</p>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_145"/>&#13;
<p class="exercise" id="proj12"><strong><span class="black1">PROJECT #12: FACTORIAL IN ASSEMBLY</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: A Raspberry Pi, running Raspberry Pi OS. I recommend that you flip to <a href="appb.xhtml">Appendix B</a> and read the entire “Raspberry Pi” section on <a href="appb.xhtml#page_341">page 341</a>. That gets you set up and walks you through using Raspberry Pi OS, including how to work with files, which you do extensively in this chapter’s projects.</p>&#13;
<p class="exercise-parai">In this project, you’ll build a factorial program in assembly language, like the one we covered earlier in this chapter. You’ll then examine the generated machine code. The factorial program includes some additional code beyond what was included in the chapter. Specifically, the program also reads the initial value of <code>n</code> from memory, writes the result back to memory, and hands control back to the operating system at the end.</p>&#13;
<p class="exercise-parac"><strong><em>ASSEMBLY INSTRUCTIONS AND DIRECTIVES</em></strong></p>&#13;
<p class="exercise-para">Since you’re including this additional code, I’ve provided <a href="ch08.xhtml#ch8tab2">Table 8-2</a> to explain the various instructions used in the code. You saw some of these instructions already in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>, but I’m including everything here for easy reference.</p>&#13;
<p class="tabcap" id="ch8tab2"><strong>Table 8-2:</strong> ARM Instructions Used in <a href="ch08.xhtml#proj12">Project #12</a></p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Instruction</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Details</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><code>ldr <em>Rd</em>, Addr</code></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Load register from memory</strong></p>&#13;
<p class="tab">Reads the value at address <code><em>Addr</em></code> and puts it in register <code><em>Rd</em></code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><code>str <em>Rd</em>, <em>Addr</em></code></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Store register to memory</strong></p>&#13;
<p class="tab">Writes the value in register <code><em>Rd</em></code> to address <code><em>Addr</em></code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><code>mov <em>Rd</em></code>, #<code><em>Const</em></code></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Move constant to register</strong></p>&#13;
<p class="tab">Moves constant value <code><em>Const</em></code> to register <code><em>Rd</em></code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><code>svc</code></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Make system call</strong></p>&#13;
<p class="tab">Makes a request of the operating system.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><code>subs <em>Rd</em>, <em>Rn</em></code>, #<code><em>Const</em></code></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Subtract</strong></p>&#13;
<p class="tab">Subtracts constant value <code><em>Const</em></code> from the value stored in register <code><em>Rn</em></code> and stores the result in register <code><em>Rd</em></code>.</p>&#13;
<p class="tab">In other words, <code><em>Rd</em></code> = <code><em>Rn</em></code> – <code><em>Const</em></code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><code>mul <em>Rd</em></code>, <code><em>Rn</em></code>, <code><em>Rm</em></code></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Multiply</strong></p>&#13;
<p class="tab">Multiplies the value stored in register <code><em>Rn</em></code> and the value stored in register <code><em>Rm</em></code> and stores the result in register <em><code>Rd</code></em>.</p>&#13;
<p class="tab">In other words, <code><em>Rd</em></code> = <code><em>Rn</em></code> × <code><em>Rm</em></code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><code>ble <em>Addr</em></code></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>Branch if less than or equal</strong></p>&#13;
<p class="tab">If the previous operation’s result was less than or equal to 0, then jump to the instruction at address <code><em>Addr</em></code>. Otherwise, continue to the next instruction.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><code>bne <em>Addr</em></code></p></td>&#13;
<td style="vertical-align: top;"><p class="tab"><strong>Branch if not equal</strong></p>&#13;
<p class="tab">If the previous operation’s result was not 0, then jump to the instruction at address <code><em>Addr</em></code>. Otherwise, continue to the next instruction.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_146"/>When writing code in assembly language, developers also use <em>assembler directives</em>. These aren’t ARM instructions, but commands to the assembler. These directives start with a period, so they’re easy to distinguish from instructions. In the following code, you also see text followed by a colon—these are <em>labels</em>, names given to a memory address. Since we don’t know where instructions will be located in memory when we write the code, we refer to memory locations by labels instead of by memory addresses. One more thing to note: the <code>@</code> sign indicates that the text following it (on the same line) is a comment. I’ve included comments to explain the program, but you can skip entering them if you prefer.</p>&#13;
<p class="exercise-parac"><strong><em>ENTER AND REVIEW THE CODE</em></strong></p>&#13;
<p class="exercise-para">That’s enough background information; this is a project after all! Time to enter the code. Use the text editor of your choice to create a new file called <em>fac.s</em> in the root of your home folder. Detailed steps for using text editors on Raspberry Pi OS are included in the “Working with Files and Folders” section of the Raspberry Pi documentation on <a href="appb.xhtml#page_346">page 346</a>. Enter the following ARM assembly code into your text editor (you don’t have to preserve indentation and empty lines, but be sure to maintain line breaks, although extra line breaks won’t hurt). Don’t worry if you don’t yet understand all of this code; I explain what you need to know following the code.</p>&#13;
<pre>.global _start<span class="ent">❶</span><br/>&#13;
 <br/>&#13;
.text<span class="ent">❷</span><br/>&#13;
_start:<span class="ent">❸</span><br/>&#13;
  ldr  r1, =n      @ set r1 = address of n<span class="ent">❹</span><br/>&#13;
  ldr  r0, [r1]    @ set r0 = the value of n<br/>&#13;
  subs r3, r0, #1  @ set r3 = r0 - 1 <br/>&#13;
  ble  end         @ jump to end if r3 &lt;= 0<br/>&#13;
loop:<br/>&#13;
  mul  r0, r3, r0  @ set r0 = r3 x r0<br/>&#13;
  subs r3, r3, #1  @ decrement r3<br/>&#13;
  bne  loop        @ jump to loop if r3 &gt; 0<br/>&#13;
end:<br/>&#13;
  ldr  r1, =result @ set r1 = address of result<span class="ent">❺</span><br/>&#13;
  str  r0, [r1]    @ store r0 at result<br/>&#13;
 <br/>&#13;
@ Exit the program<br/>&#13;
  mov  r0, #0<span class="ent">❻</span><br/>&#13;
  mov  r7, #1<br/>&#13;
  svc 0<br/>&#13;
 <br/>&#13;
.data<span class="ent">❼</span><br/>&#13;
  n: .word 5<span class="ent">❽</span><br/>&#13;
  result: .word 0</pre>&#13;
<p class="exercise-parai">After entering in your code, save it in the text editor as <em>fac.s</em> in the root of your home folder. Let’s walk through this code, starting with the directives and labels.</p>&#13;
<p class="exercise-parai">As mentioned earlier, text followed by a colon, like <code>_start:</code>, is a label for a memory location <span class="ent">❸</span>. The <code>_start</code> label marks the point at which the program begins execution. The <code>.global</code> directive makes <span epub:type="pagebreak" id="page_147"/>the <code>_start</code> label visible to the linker <span class="ent">❶</span> (we’ll get to the linker in a minute) so that it can be set as the entry point for the program. The <code>.text</code> directive tells the assembler that the lines following it are instructions <span class="ent">❷</span>.</p>&#13;
<p class="exercise-parai">At the end of the code, the <code>.data</code> directive tells the assembler that the lines following it are data <span class="ent">❼</span>. In the data section, the program is storing two 32-bit values, each indicated by the <code>.word</code> directive <span class="ent">❽</span>. The first is the value of <code>n</code>, initially set to a value of 5. The second is <code>result</code>, initially set to a value of 0. In this context, “word” means 4 bytes, or 32 bits.</p>&#13;
<p class="exercise-parai">Now let’s look at the functional additions to the code beyond what was in the chapter. We now have code that loads <code>n</code> from memory, saves the factorial result to memory, and exits the program. The first two instructions in <code>_start</code> load the value of <code>n</code> from a location in memory <span class="ent">❹</span>. The <code>ldr</code> instruction loads a register with a value. We reference the address of <code>n</code> with <code>=n</code>. On the next line, <code>[r1]</code> is in brackets because the program is accessing the value stored at the address in <code>r1</code>.</p>&#13;
<p class="exercise-parai">The two instructions following <code>end</code> save the result to a location in memory <span class="ent">❺</span>. The first instruction moves the address of the memory location named <code>result</code> into the <code>r1</code> register. After that, the code stores the value in the <code>r0</code> register (which happens to be the calculated factorial) to the <code>result</code> memory address, referenced by <code>r1</code>.</p>&#13;
<p class="exercise-parai">The last three instructions in the <code>.text</code> section are used to cleanly exit the program <span class="ent">❻</span>. This requires the help of the operating system, so I’ll skip over the details of these instructions until we cover operating systems in <a href="ch10.xhtml">Chapter 10</a>.</p>&#13;
<p class="exercise-parac"><strong><em>ASSEMBLE, LINK, AND RUN</em></strong></p>&#13;
<p class="exercise-para">You now have a text file with assembly language instructions, but this isn’t a format that a computer can run. You need to turn the assembly language instructions into bytes of machine code through a two-step process. First, you need to convert (assemble) the instructions to machine code bytes using an <em>assembler</em>. The result of this process is an <em>object file</em>, a file that contains the bytes of your program but still isn’t in the final format needed to run the program. Next, you need to use a program called a <em>linker</em> to turn your object file into an executable file that the operating system can run. This process is illustrated in <a href="ch08.xhtml#ch8fig3">Figure 8-3</a>.</p>&#13;
<div class="image" id="ch8fig3"><img src="../images/fig8-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 8-3: Assembling and linking produces an executable file</em></p>&#13;
<p class="exercise-parai">You may wonder why this two-step process is needed. If you’re assembling multiple source files that all work together as one program, each source file assembles into an object file. The linker then combines the various object files into one executable file. This allows for object files that were created previously to be linked as needed. In this case, you have just one object file, and the linker simply turns it into a format that’s ready to execute.</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_148"/>Now, assemble your code:</p>&#13;
<pre>$ <span class="codestrong1">as -o fac.o fac.s</span></pre>&#13;
<p class="exercise-parai">The <code>as</code> tool is the GNU Assembler, which turns your assembly language statements into machine code. This command writes the generated machine code to a file called <em>fac.o</em>, an object file. The assembler may give you a warning if your <em>fac.s</em> file doesn’t end with a line break—you can safely ignore this warning.</p>&#13;
<p class="exercise-parai">Once your source code has been assembled into an object file, you need to use the GNU linker (<code>ld</code>) to convert your object file to an executable file:</p>&#13;
<pre>$ <span class="codestrong1">ld -o fac fac.o</span></pre>&#13;
<p class="exercise-parai">This command takes <em>fac.o</em> as an input, and outputs an executable file named <em>fac</em>. At this point, you can run your program with the following command:</p>&#13;
<pre>$ <span class="codestrong1">./fac</span></pre>&#13;
<p class="exercise-parai">This command should immediately return to the next line with no output. This is because your program doesn’t actually display any text to the screen. It simply calculates a factorial, saves the result in memory, then exits. To interact with the user, the program would need to request some help from the operating system. However, since we’re trying to keep this program as minimal as possible, you don’t need to do that.</p>&#13;
<p class="exercise-parac"><strong><em>LOAD THE PROGRAM WITH A DEBUGGER</em></strong></p>&#13;
<p class="exercise-para">Since your program doesn’t output anything, how can you tell what it’s doing? You can use a <em>debugger</em>, a program that can examine a process as it runs. A debugger can attach to a running program and then halt its execution. While the program is halted, the debugger can examine the registers and memory of the target process. Here, you use the GNU Debugger, <code>gdb</code>, as your debugger, and your target is the <code>fac</code> program.</p>&#13;
<p class="exercise-parai">To start, just execute the following command:</p>&#13;
<pre>$ <span class="codestrong1">gdb fac</span></pre>&#13;
<p class="exercise-parai">When you run this command, <code>gdb</code> loads the <em>fac</em> file but no instructions execute yet. From the (<code>gdb</code>) prompt, enter the following to view the start address of the program:</p>&#13;
<pre>(gdb) <span class="codestrong1">info files</span></pre>&#13;
<p class="exercise-parai">You should see a line like this, although the specific address may differ:</p>&#13;
<pre>       Entry point: 0x10074</pre>&#13;
<p class="exercise-parai">This tells you that the program’s entry point is address <code>0x10074</code>. Remember, when you wrote the program, you didn’t know what memory addresses would be used, so you used labels instead. <span epub:type="pagebreak" id="page_149"/>Now that the program has been built and loaded into memory, you have real memory addresses to examine. This entry point address corresponds to the <code>_start</code> label, since that’s where the program begins. You can now use <code>gdb</code> to disassemble the machine code starting at the program entry point. <em>Disassembly</em> is the process of viewing machine code bytes as assembly language instructions. The following command uses <code>0x10074</code> as the start address; if your entry point is different, use that address instead.</p>&#13;
<pre>(gdb) <span class="codestrong1">disas 0x10074</span><br/>&#13;
Dump of assembler code for function _start:<br/>&#13;
   0x00010074 &lt;+0&gt;:     ldr     r1, [pc, #40]   ; 0x100a4 &lt;end+20&gt;<br/>&#13;
   0x00010078 &lt;+4&gt;:     ldr     r0, [r1]<br/>&#13;
   0x0001007c &lt;+8&gt;:     subs    r3, r0, #1<br/>&#13;
   0x00010080 &lt;+12&gt;:    ble     0x10090 &lt;end&gt;</pre>&#13;
<p class="exercise-parai">After running this command, you should see the first four instructions disassembled, as shown here. By default, <code>gdb</code> only disassembles a handful of instructions. That’s a good start, but it is better to see the entire program. To do that you need to tell <code>gdb</code> the ending address of the code you want to see. If you look back at the earlier code you entered into <em>fac.s</em>, you can see that there are 12 instructions total in your program. Each instruction is 4 bytes, so the program should be 48 bytes in length. This means your program should end 48 bytes after the start address, so the ending address should be 0x00010074 + 48. You can do this addition by hand or in a calculator program, but since you’re in <code>gdb</code>, you can ask it to do that math for you and find the ending address of your program (again, replace <code>0x10074</code> with your entry point address if you need to):</p>&#13;
<pre>(gdb) <span class="codestrong1">print/x 0x00010074 + 48</span><br/>&#13;
$1 = 0x100a4</pre>&#13;
<p class="exercise-parai">The <code>print</code> command output can be a bit confusing at first. The <code>/x</code> in the command means “print the result in hexadecimal.” If you look at the output, the left-hand value (<code>$1</code>) is a <em>convenience variable</em>, a temporary storage location in <code>gdb</code>. Saving a value in a convenience variable is <code>gdb</code>’s way of making it easy for you to get back to this result later. The value after the equals sign is the printed value, the result of the calculation, <code>0x100a4</code> in this case.</p>&#13;
<p class="exercise-parai">So now you know the ending address (<code>0x100a4</code>), and you can ask <code>gdb</code> to disassemble the entire program. Note that if your starting address is different than mine, you need to replace the two addresses in the following command.</p>&#13;
<pre>(gdb) <span class="codestrong1">disas 0x10074,0x100a4</span><br/>&#13;
Dump of assembler code from 0x10074 to 0x100a4:<br/>&#13;
   0x00010074 &lt;_start+0&gt;:       ldr     r1, [pc, #40]   ; 0x100a4 &lt;end+20&gt;<span class="ent">❶</span><br/>&#13;
   0x00010078 &lt;_start+4&gt;:       ldr     r0, [r1]<br/>&#13;
   0x0001007c &lt;_start+8&gt;:       subs    r3, r0, #1<br/>&#13;
   0x00010080 &lt;_start+12&gt;:      ble     0x10090 &lt;end&gt;<br/>&#13;
   0x00010084 &lt;loop+0&gt;: mul     r0, r3, r0<br/>&#13;
   0x00010088 &lt;loop+4&gt;: subs    r3, r3, #1<br/>&#13;
   0x0001008c &lt;loop+8&gt;: bne     0x10084 &lt;loop&gt;<br/>&#13;
   0x00010090 &lt;end+0&gt;:  ldr     r1, [pc, #16]   ; 0x100a8 &lt;end+24&gt;<span class="ent">❷</span><br/>&#13;
   0x00010094 &lt;end+4&gt;:  str     r0, [r1]<br/>&#13;
<span epub:type="pagebreak" id="page_150"/>&#13;
   0x00010098 &lt;end+8&gt;:  mov     r0, #0<br/>&#13;
   0x0001009c &lt;end+12&gt;: mov     r7, #1<br/>&#13;
   0x000100a0 &lt;end+16&gt;: svc     0x00000000</pre>&#13;
<p class="exercise-parai">This looks very much like what you originally entered into <em>fac.s</em> and assembled, except now each instruction has been assigned an address, and the references to <code>n</code> and <code>result</code> have been replaced with memory offsets relative to the program counter register (for example, <code>[pc, #40]</code> <span class="ent">❶</span>). The <em>program counter</em> register, or <em>instruction pointer</em>, holds the memory address of the current instruction. For the sake of keeping things simple, I’m not going into the details of why program counter offsets are used here, but just know that the instructions at <code>0x10074</code> <span class="ent">❶</span> and <code>0x10090</code> <span class="ent">❷</span> are loading the memory addresses of <code>n</code> and <code>result</code>, respectively, into <code>r1</code>.</p>&#13;
<p class="exercise-parac"><strong><em>RUN AND EXAMINE THE PROGRAM USING DEBUGGER BREAKPOINTS</em></strong></p>&#13;
<p class="exercise-para">Now that you can see the program loaded into memory, let’s see if the program works as expected. To do this, you’re going to set breakpoints on certain instructions, which allows you to examine the state of your program at that point. A <em>breakpoint</em> tells the debugger to halt execution when a certain address is reached. Setting a breakpoint on a certain address halts execution immediately <em>before</em> the corresponding instruction is executed. In the following example commands, I use the addresses shown on my system, but if your memory addresses are different, be sure to use those addresses instead.</p>&#13;
<p class="exercise-parai">You’re going to set the following breakpoints:</p>&#13;
<p class="exercise-para"><strong>0x10074</strong>   The start of the program.</p>&#13;
<p class="exercise-para"><strong>0x1007c</strong>   The beginning of the factorial logic, 8 bytes after the first instruction. When the program reaches this instruction, register <code>r0</code> should be the input value <code>n</code>, which was hard-coded to 5 in the program.</p>&#13;
<p class="exercise-para"><strong>0x10090</strong>   The end of the factorial logic, 0x1C bytes after the first instruction. When the program reaches this instruction, register <code>r0</code> should hold the factorial value that was calculated.</p>&#13;
<p class="exercise-para"><strong>0x100a0</strong>   The final instruction of the program. When the program reaches this instruction, the memory location labeled <code>result</code> should hold the factorial result.</p>&#13;
<p class="exercise-parai">Set the breakpoints as follows (again, adjust the addresses if your start address isn’t <code>0x10074</code>):</p>&#13;
<pre>(gdb) <span class="codestrong1">break *0x10074</span><br/>&#13;
(gdb) <span class="codestrong1">break *0x1007c</span><br/>&#13;
(gdb) <span class="codestrong1">break *0x10090</span><br/>&#13;
(gdb) <span class="codestrong1">break *0x100a0</span></pre>&#13;
<p class="exercise-parai">Now begin running the program:</p>&#13;
<pre>(gdb) <span class="codestrong1">run</span><br/>&#13;
Starting program: /home/pi/fac<br/>&#13;
 <br/>&#13;
Breakpoint 1, 0x00010074 in _start ()</pre>&#13;
<p class="exercise-parai">You should see output like this, indicating that execution stopped at the first breakpoint. At this point the program is ready to execute the first instruction, and you can take a look around at <span epub:type="pagebreak" id="page_151"/>the state of things. First, examine the registers, and really, the only one we care about at this point is the program counter (<code>pc</code>), because we want to confirm that the current instruction is the start address of 0x10074. Now ask the debugger to show the value of the pc register:</p>&#13;
<pre> (gdb) <span class="codestrong1">info register pc</span><br/>&#13;
pc             0x10074  0x10074 &lt;_start&gt;</pre>&#13;
<p class="exercise-parai">This tells you that the program counter is pointing to the start address and first breakpoint, as expected. Another way to confirm the current instruction is to simply disassemble the current code like so:</p>&#13;
<pre>(gdb) <span class="codestrong1">disas</span><br/>&#13;
Dump of assembler code for function _start:<br/>&#13;
<span class="codestrong1">=&gt;</span> 0x00010074 &lt;+0&gt;:     ldr     r1, [pc, #40]   ; 0x100a4 &lt;end+20&gt;<br/>&#13;
   0x00010078 &lt;+4&gt;:     ldr     r0, [r1]<br/>&#13;
   0x0001007c &lt;+8&gt;:     subs    r3, r0, #1<br/>&#13;
   0x00010080 &lt;+12&gt;:    ble     0x10090 &lt;end&gt;</pre>&#13;
<p class="exercise-parai">Note the <code>=&gt;</code> symbol indicating the current instruction.</p>&#13;
<p class="exercise-parai">Now that you’ve confirmed that the program is ready to run its first instruction, you can examine the current values of the two labeled memory addresses: <code>n</code> and <code>result</code>. These should be 5 and 0, respectively, since that’s what you defined their initial values as in the <em>fac.s</em> source code. You can again use the <code>print</code> command to see these values. When you do so, you need to specify a data type of <code>int</code> (a 32-bit integer) so the <code>print</code> command knows how to display these values.</p>&#13;
<pre>(gdb) <span class="codestrong1">print (int)n</span><br/>&#13;
$2 = <span class="codestrong1">5</span><br/>&#13;
(gdb) <span class="codestrong1">p (int)result</span><br/>&#13;
$3 = <span class="codestrong1">0</span></pre>&#13;
<p class="exercise-parai">Note how <code>p</code> is substituted for <code>print</code> in the second command. Shortened versions of commands are supported by <code>gdb</code>; this can save you some typing. As you can see, the <code>print</code> command makes it easy to print the values of labeled memory locations!</p>&#13;
<p class="exercise-parai">Although printing the value of a labeled memory location is convenient, it does raise a question: How does the <code>print</code> command in <code>gdb</code> know about the labels you gave these memory locations in your original <em>fac.s</em> file? The CPU doesn’t use these labels; it just uses memory addresses. The machine code doesn’t refer to these memory locations by name either. The debugger is able to do this because the file that holds the machine code, <em>fac</em>, also holds symbolic information. These <em>debug symbols</em> tell the debugger about certain named memory locations, such as <code>n</code> and <code>result</code>. Usually symbolic information is removed from executable files before they are distributed to end users, but the symbolic info is still present in your <em>fac</em> executable file.</p>&#13;
<p class="exercise-parai">Keeping in mind that <code>n</code> and <code>result</code> are just labels for memory locations, how do you find the actual memory addresses of these variables? One way is to print the address by using the <code>&amp;</code> operator, which means “address of” in <code>gdb</code>. So <code>&amp;n</code> means “the address of n.” Now print the address of <code>n</code> and the address of <code>result</code>.</p>&#13;
<span epub:type="pagebreak" id="page_152"/>&#13;
<pre>(gdb) <span class="codestrong1">p &amp;n</span><br/>&#13;
$4 = (&lt;data variable, no debug info&gt; *) <span class="codestrong1">0x200ac</span><br/>&#13;
(gdb) <span class="codestrong1">p &amp;result</span><br/>&#13;
$5 = (&lt;data variable, no debug info&gt; *) <span class="codestrong1">0x200b0</span></pre>&#13;
<p class="exercise-parai">This tells you that the value of <code>n</code> is stored at address <code>0x200ac</code>, and the value of <code>result</code> is stored at address <code>0x200b0</code>. Note that these are consecutive values in memory, since both <code>n</code> and <code>result</code> are 4 bytes in length. You can examine this memory using the <span class="codestrong">x</span> command:</p>&#13;
<pre>(gdb) <span class="codestrong1">x/2xw 0x200ac</span><br/>&#13;
0x200ac:        <span class="codestrong1">0x00000005</span>      <span class="codestrong1">0x00000000</span></pre>&#13;
<p class="exercise-parai">The <code>x/2xw</code> command means examine two consecutive values, displayed in hex, each “word” sized (4 bytes), starting at address <code>0x200ac</code>. So here again you can see that <code>n</code> is 5, and <code>result</code> is 0. This is just a different way of looking at memory, this time without using named labels.</p>&#13;
<p class="exercise-parai">So back to the program—you’ve now established that the initial memory values are set as expected. Continue execution to your next breakpoint, where you can verify that <code>r0</code> has been set to the initial value of <code>n</code>.</p>&#13;
<pre>(gdb) <span class="codestrong1">continue</span><br/>&#13;
Continuing.<br/>&#13;
 <br/>&#13;
Breakpoint 2, 0x0001007c in _start ()<br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">disas</span><br/>&#13;
Dump of assembler code for function _start:<br/>&#13;
   0x00010074 &lt;+0&gt;:     ldr     r1, [pc, #40]   ; 0x100a4 &lt;end+20&gt;<br/>&#13;
   0x00010078 &lt;+4&gt;:     ldr     r0, [r1]<br/>&#13;
<span class="codestrong1">=&gt;</span> 0x0001007c &lt;+8&gt;:     subs    r3, r0, #1<br/>&#13;
   0x00010080 &lt;+12&gt;:    ble     0x10090 &lt;end&gt;<br/>&#13;
End of assembler dump.<br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">info registers r0</span><br/>&#13;
<span class="codestrong1">r0</span>             0x5      <span class="codestrong1">5</span></pre>&#13;
<p class="exercise-parai">From the preceding output you can see that the program has moved forward to instruction <code>0x1007c</code> as expected, and <code>r0</code> has the expected value of 5 (the value of <code>n</code>). So far, so good. Now, move ahead to your next breakpoint, where <code>r0</code> should now be the calculated value of 5 factorial, which is 120. You can shorten the <code>continue</code> command to just <code>c</code>, and the <code>info registers</code> command to just <code>i r</code>.</p>&#13;
<pre>(gdb) <span class="codestrong1">c</span><br/>&#13;
Continuing.<br/>&#13;
 <br/>&#13;
Breakpoint 3, 0x00010090 in end ()<br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">disas</span><br/>&#13;
Dump of assembler code for function end:<br/>&#13;
<span epub:type="pagebreak" id="page_153"/><span class="codestrong1">=&gt;</span> 0x00010090 &lt;+0&gt;:     ldr     r1, [pc, #16]   ; 0x100a8 &lt;end+24&gt;<br/>&#13;
   0x00010094 &lt;+4&gt;:     str     r0, [r1]<br/>&#13;
   0x00010098 &lt;+8&gt;:     mov     r0, #0<br/>&#13;
   0x0001009c &lt;+12&gt;:    mov     r7, #1<br/>&#13;
   0x000100a0 &lt;+16&gt;:    svc     0x00000000<br/>&#13;
   0x000100a4 &lt;+20&gt;:    andeq   r0, r2, r12, lsr #1<br/>&#13;
   0x000100a8 &lt;+24&gt;:    strheq  r0, [r2], -r0   ; &lt;UNPREDICTABLE&gt;<br/>&#13;
End of assembler dump.<br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">i r r0</span><br/>&#13;
<span class="codestrong1">r0</span>             0x78     <span class="codestrong1">120</span></pre>&#13;
<p class="exercise-parai">That all looks good. Recall that at this point the factorial output hasn’t been saved to the <code>result</code> memory address. Now verify that <code>result</code> is unchanged:</p>&#13;
<pre>(gdb) <span class="codestrong1">p (int)result</span><br/>&#13;
$6 = <span class="codestrong1">0</span></pre>&#13;
<p class="exercise-parai">Although you have the factorial output temporarily stored in <code>r0</code>, it hasn’t been written to memory yet. Continue to the end of program (the final breakpoint) and see if the <code>result</code> memory location has been updated.</p>&#13;
<pre>(gdb) <span class="codestrong1">c</span><br/>&#13;
Continuing.<br/>&#13;
 <br/>&#13;
Breakpoint 4, 0x000100a0 in end ()<br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">p (int)result</span><br/>&#13;
$7 = <span class="codestrong1">120</span></pre>&#13;
<p class="exercise-parai">You should see a value of 120 for <code>result</code>. If so, nice work, your program worked as expected!</p>&#13;
<p class="exercise-parac"><strong><em>HACK THE PROGRAM TO CALCULATE A DIFFERENT FACTORIAL</em></strong></p>&#13;
<p class="exercise-para">This program is hard-coded to calculate the factorial of 5. What if you want it to calculate the factorial of some other number? Well, you could change the hard-coded value in the <em>fac.s</em> source code, rebuild the code, and run it again. Or you could write some code that allows the user to input a desired value of <code>n</code> at runtime. But imagine that you don’t have access to the source code anymore, and you just want a quick way to alter this program’s behavior while it runs, replacing the hard-coded value of <code>n</code> with some value other than 5.</p>&#13;
<p class="exercise-parai">First, restart the program using the <span class="codestrong">run</span> command, and answer <span class="codestrong">y</span> to the question:</p>&#13;
<pre>(gdb) <span class="codestrong1">run</span><br/>&#13;
The program being debugged has been started already.<br/>&#13;
Start it from the beginning? (y or n) <span class="codestrong1">y</span><br/>&#13;
Starting program: /home/pi/fac<br/><br/>&#13;
Breakpoint 1, 0x00010074 in _start ()</pre>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_154"/>Now you’re back at the beginning of the program, at breakpoint 1. You can edit the in-memory value of <code>n</code>, setting it to 7 rather than 5. First, get the memory address of <code>n</code>, then set the value at that address to 7. Then you can print out <code>n</code> to make sure the change worked.</p>&#13;
<pre>(gdb) <span class="codestrong1">p &amp;n</span><br/>&#13;
$8 = (&lt;data variable, no debug info&gt; *) <span class="codestrong1">0x200ac</span><br/><br/>&#13;
(gdb) <span class="codestrong1">set {int}0x200ac = 7</span><br/><br/>&#13;
(gdb) <span class="codestrong1">p (int)n</span><br/>&#13;
$9 = <span class="codestrong1">7</span></pre>&#13;
<p class="exercise-parai">Now go to the end of the program and see if <code>result</code> gets updated to the expected value of 7 factorial, which is 5,040. You can get rid of your two middle breakpoints (numbers 2 and 3), since you want to go straight to the end:</p>&#13;
<pre>(gdb) <span class="codestrong1">disable 2</span><br/>&#13;
(gdb) <span class="codestrong1">disable 3</span><br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">c</span><br/>&#13;
Continuing.<br/>&#13;
 <br/>&#13;
Breakpoint 4, 0x000100a0 in end ()<br/>&#13;
 <br/>&#13;
(gdb) <span class="codestrong1">p (int)result</span><br/>&#13;
$10 = <span class="codestrong1">5040</span></pre>&#13;
<p class="exercise-parai">You should see a value of 5,040 for <code>result</code>. If so, you’ve just successfully hacked a program to make it do your bidding—all without touching the source code!</p>&#13;
<p class="exercise-parai">At this point you may want to try setting <code>n</code> to other values and see if you get the expected results. To do this, restart the program using the <span class="codestrong">run</span> command, edit the in-memory value of <code>n</code>, continue to the final breakpoint, and check the value of <code>result</code>. However, if you use a value of <code>n</code> larger than 12, you get an incorrect result. See the answer to <a href="ch08.xhtml#ch8ex1">Exercise 8-1</a> in <a href="appa.xhtml">Appendix A</a> for the reason why this is so.</p>&#13;
<p class="exercise-parai">If you allow the program to <code>continue</code> to the end, the process exits, and you should get a message like <code>Inferior 1 (process 946) exited normally</code>. This isn’t an insult of your code, rather “inferior” is just how <code>gdb</code> refers to the target being debugged! You can exit the debugger at any time by entering <code>quit</code> in <code>gdb</code>.</p>&#13;
</div>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_155"/>&#13;
<p class="exercise" id="proj13"><strong><span class="black1">PROJECT #13: EXAMINING MACHINE CODE</span></strong></p>&#13;
<p class="exercise-para">Prerequisite: <a href="ch08.xhtml#proj12">Project #12</a>.</p>&#13;
<p class="exercise-parai">Let’s say that you were given the <em>fac</em> executable file, but not the original assembly language source file. You want to know what the program does, but you don’t have the source code. As you saw in <a href="ch08.xhtml#proj12">Project #12</a>, you can use the <code>gdb</code> debugger to examine the <em>fac</em> executable file. In this project, I’ll show you a different set of tools for examining machine code.</p>&#13;
<p class="exercise-parai">Open a terminal on your Raspberry Pi. By default, the terminal should open to the home folder, indicated by the <code>~</code> character. In this folder you should have three factorial-related files from the last project. Check this with the following command:</p>&#13;
<pre>$ <span class="codestrong1">ls fac*</span></pre>&#13;
<p class="exercise-parai">You should see</p>&#13;
<p class="exercise-para"><strong><em>fac</em></strong>   The executable file</p>&#13;
<p class="exercise-para"><strong><em>fac.o</em></strong>   The object file generated during assembly</p>&#13;
<p class="exercise-para"><strong><em>fac.s</em></strong>   The assembly language source code</p>&#13;
<p class="exercise-parai">In our fictional scenario, you only have the executable <em>fac</em> file, and you want to know what you can learn about the program from the contents of this file. First, look at the bytes contained in the file as hexadecimal values by using the <code>hexdump</code> tool:</p>&#13;
<pre>$ <span class="codestrong1">hexdump -C fac</span></pre>&#13;
<p class="exercise-parai">The beginning of the <code>hexdump</code> output should look something like <a href="ch08.xhtml#ch8fig4">Figure 8-4</a> (without the annotations), displaying the bytes in the <em>fac</em> executable file.</p>&#13;
<div class="image" id="ch8fig4"><img src="../images/fig8-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 8-4: Hex dump of Linux executable file</em></p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_156"/>What you see is simply a sequential listing of the bytes in the file, each displayed as a two-character hexadecimal value. If the output of this command is too large to fit in your terminal window, scroll up to see the beginning bytes. The eight-character hex numbers along the left-hand column represent the offset into the file of the first byte in the corresponding row. There are 16 bytes on each row, meaning the offset number of each row (along the left) increases by 0x10. On the right-hand side of the output are the same bytes interpreted as ASCII. Bytes that do not correspond to a printable ASCII character code are indicated with a period.</p>&#13;
<p class="exercise-parai">At offset <code>00000000</code>, the very beginning of the file, you should see a <code>7F</code>, followed by <code>45 4c 46</code>, or in ASCII, <code>ELF</code>. This is an indicator that this is a file that is in <em>executable and linkable format (ELF)</em>. <em>ELF files</em> are the standard Linux format for executable programs. These 4 bytes mark the beginning of the <em>ELF header</em>, a set of properties that describe the contents of the file. Following the ELF header is a <em>program header</em>, which provides details needed by the operating system to run the program.</p>&#13;
<p class="exercise-parai">Now move past the headers and find the text section that contains the program’s machine instructions. On my system, offset <code>00000074</code> is the beginning of the text section, and it starts with bytes <code>28 10 9f e5</code>. If you rearrange these bytes last-to-first, you get <code>e59f1028</code>, which is the machine code instruction for <code>ldr r1, [pc, #40]</code>. Each set of 4 bytes in this section is a machine instruction. Looking at the program in this way is a good reminder that the code of the <code>fac</code> program is simply represented as a sequence of bytes. Refer to <a href="ch08.xhtml#ch8fig1">Figure 8-1</a> for a reminder of how machine code is represented in binary.</p>&#13;
<p class="exercise-parai">Later in the output, at offset <code>000000ac</code> on my system, you should see the data section of the file, containing the two initial 4-byte values defined by the program. You don’t see the <code>n</code> and <code>result</code> labels here, but you should see <code>05 00 00 00</code> and <code>00 00 00 00</code>. The offset of these bytes on your system may differ from mine.</p>&#13;
<p class="exercise-parai">As a side note, the order in which computers store bytes of data for larger numerical values is known as <em>endianness</em>. When a computer stores the least significant byte first (at the lowest address) this is called <em>little-endian</em>. Storing the most significant byte first is called <em>big-endian</em>. In the <code>hexdump</code> output, you see little-endian storage, since the 32-bit machine instruction of <code>e59f1028</code> was stored as bytes in this order: <code>28 10 9f e5</code>. The least significant byte was stored first. The same can be said of the values of <code>n</code> and <code>result</code>. The value of <code>n</code> is stored as <code>05 00 00 00</code>, meaning <code>00000005</code> when you consider it as a 32-bit integer.</p>&#13;
<p class="exercise-parai">If you want to view parts of this hexadecimal data, but grouped into sections, you can use the <code>objdump</code> tool:</p>&#13;
<pre>$ <span class="codestrong1">objdump -s fac</span></pre>&#13;
<p class="exercise-parai">This dumps out some of the same bytes as before, but grouped into sections, like so:</p>&#13;
<pre>Contents of section .text:<br/>&#13;
 10074 28109fe5 000091e5 013050e2 020000da  (........0P.....<br/>&#13;
 10084 930000e0 013053e2 fcffff1a 10109fe5  .....0S.........<br/>&#13;
 10094 000081e5 0000a0e3 0170a0e3 000000ef  .........p......<br/>&#13;
 100a4 ac000200 b0000200                    ........<br/>&#13;
Contents of section .data:<br/>&#13;
<span epub:type="pagebreak" id="page_157"/> 200ac 05000000 00000000                    ........<br/>&#13;
Contents of section .ARM.attributes:<br/>&#13;
 0000 41130000 00616561 62690001 09000000   A....aeabi......<br/>&#13;
 0010 06010801                              ....</pre>&#13;
<p class="exercise-parai">Note how the numbers along the left-hand side have changed. Instead of starting at <code>0074</code>, the <code>.text</code> section (that is, code) starts at <code>10074</code>. Instead of starting at <code>00ac</code>, the <code>.data</code> section containing the values of <code>n</code> and <code>result</code> starts at <code>200ac</code>. The <code>hexdump</code> tool simply shows the byte offset within the file, whereas <code>objdump</code> output refers to the address where the bytes are loaded in memory when the program runs. Another way to view the addresses of the various sections in an ELF executable file is with <code>readelf</code> -e <code>fac</code>. This displays the headers in the file.</p>&#13;
<p class="exercise-parai">You can now try another feature of <code>objdump</code>, disassembly of machine code, so you can see the assembly language instructions alongside the machine code byte values.</p>&#13;
<pre>$ <span class="codestrong1">objdump -d fac</span><br/>&#13;
 <br/>&#13;
fac:     file format elf32-littlearm<br/>&#13;
 <br/>&#13;
Disassembly of section .text:<br/>&#13;
 <br/>&#13;
00010074 &lt;_start&gt;:<br/>&#13;
   10074:       e59f1028        ldr     r1, [pc, #40]   ; 100a4 &lt;end+0x14&gt;<span class="ent">❶</span><br/>&#13;
   10078:       e5910000        ldr     r0, [r1]<br/>&#13;
   1007c:       e2503001        subs    r3, r0, #1<br/>&#13;
   10080:       da000002        ble     10090 &lt;end&gt;<br/>&#13;
 <br/>&#13;
00010084 &lt;loop&gt;:<br/>&#13;
   10084:       e0000093        mul     r0, r3, r0<br/>&#13;
   10088:       e2533001        subs    r3, r3, #1<br/>&#13;
   1008c:       1afffffc        bne     10084 &lt;loop&gt;<br/>&#13;
 <br/>&#13;
00010090 &lt;end&gt;:<br/>&#13;
   10090:       e59f1010        ldr     r1, [pc, #16]   ; 100a8 &lt;end+0x18&gt;<br/>&#13;
   10094:       e5810000        str     r0, [r1]<br/>&#13;
   10098:       e3a00000        mov     r0, #0<br/>&#13;
   1009c:       e3a07001        mov     r7, #1<br/>&#13;
   100a0:       ef000000        svc     0x00000000<br/>&#13;
   100a4:       000200ac        .word   0x000200ac<br/>&#13;
   100a8:       000200b0        .word   0x000200b0</pre>&#13;
<p class="exercise-parai">You should expect to see output similar to what is shown here. Note that the instruction at address <code>10074</code> <span class="ent">❶</span> is the same sequence of bytes highlighted in <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>, the first 4 bytes of machine code. This output is very similar to the output from <code>gdb</code> in the previous project. Consider what this means: using tools like <code>gdb</code> or <code>objdump</code>, you can easily view the machine code and corresponding assembly language for any executable!</p>&#13;
<p class="exercise-parai"><span epub:type="pagebreak" id="page_158"/>Using the techniques I’ve described in the preceding pages, you can get a view of the contents of an ELF executable file. This applies to any standard ELF file on a Linux system, not just code you wrote. Feel free to explore the machine code of any ELF file on your computer. For example, say you want to see the machine code for <code>ls</code>—the tool you used earlier to list the contents of a directory. First, you need to find the filesystem location of the <em>ls</em> ELF file, like so:</p>&#13;
<pre>$ <span class="codestrong1">whereis ls</span><br/>&#13;
ls: /bin/ls /usr/share/man/man1/ls.1.gz</pre>&#13;
<p class="exercise-parai">This tells us the binary executable file for <code>ls</code> is located at <em>/bin/ls</em> (you can ignore any additional results returned). Now you can run <code>objdump</code> (or any of the other tools already covered) to see the machine code for <code>ls</code>:</p>&#13;
<pre>$ <span class="codestrong1">objdump -d /bin/ls &gt; ls.txt</span></pre>&#13;
<p class="exercise-parai">The output of this command is rather long, so it is redirected to a file named <em>ls.txt</em>. You don’t see the disassembled code in the terminal window; instead it is written to the <em>ls.txt</em> file, which you can view using the text editor of your choice. Of course, since Linux is open source, you can just look at the source code for the <code>ls</code> tool online. However, not everything is open source, and this project should give you an idea of how you can view the disassembled code for any Linux executable program.</p>&#13;
</div>&#13;
</body></html>