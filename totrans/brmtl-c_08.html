<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="105" id="Page_105"/>7</span><br/>
<span class="ChapterTitle">Local Variables and Procedures</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">So far, we’ve been using a design pattern called “one big mess.” All code is dumped into <code>main</code>, and all variables are defined at the beginning of the program. This method works fine when your program is 100 or fewer lines long, but when you’re dealing with a 500,000-line program, you’re going to need some organization. This chapter discusses ways of limiting the scope of variables and instructions so you can make long, unmanageable blocks of code easier to understand, manage, and maintain.</p>
<p>For example, you can use a <em>global variable</em> anywhere in a program. To know where and how it’s used in a 500,000-line program, however, you have to scan all 500,000 lines. A <em>local variable</em> has limited scope. To understand where and how a local variable is used, all you need to do is examine the, say, 50 to 200 lines of code where it is valid.</p>
<p><span epub:type="pagebreak" title="106" id="Page_106"/>As your programs get longer and longer, you’ll learn how to divide the code into easily understood sections called <em>procedures</em>. Global variables will be available to every procedure, but you can define local variables that are available only to a single procedure. You’ll also learn how local variables are organized internally into stack frames. Given the limited amount of memory on our STM microcontroller, it’s very important to understand how much stack memory we are using.</p>
<p>Finally, you’ll learn about <em>recursion</em>, which is where a procedure refers to itself. Recursion is complex in what it can do but simple if you understand the rules and follow them.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Nothing in C’s syntax prevents evil programmers from writing 30,000-line procedures or creating local variables whose scope is just as large. However, I’m assuming you’re sane and want to code in a manner that decreases confusion instead of increasing it.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501621c07-0001">Local Variables</h2>
<p class="BodyFirst">Up to this point, we’ve been using only global variables that are available everywhere in the program, from the line they are declared to the end of the program. Local variables are available to a much smaller, or local, area of a program. This area where a variable is valid is called its <em>scope</em>. <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a> demonstrates the declaration of local variables.</p>
<p class="CodeLabel"><b><em>local.c</em></b></p>
<pre><code>/*
 * Useless program to demonstrate local variables
 */
#include &lt;stdio.h&gt;

int global = 5;    // A global variable

int main()
{
      int localToProcedure = 3;
      // ... do something
      {
         <span class="CodeAnnotationCode" aria-label="annotation1">1</span> int local = 6; // A local variable

          {
              int veryLocal = 7;  // An even more local variable
              // ... do something
        <span class="CodeAnnotationCode" aria-label="annotation2">2</span> }
          // veryLocal is no longer valid.
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> }
      // local is no longer valid.
      return (0);
  }</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Local variables</p>
<p><span epub:type="pagebreak" title="107" id="Page_107"/>The scope of a local variable starts where it is declared and goes to the end of the enclosing curly brackets (<code>{}</code>). The variable <code>localToProcedure</code> is valid for the entire <code>main</code> function.</p>
<p>Now let’s look at smaller scopes, starting with the declaration of the <code>local</code> variable <span class="CodeAnnotation" aria-label="annotation1">1</span>. The scope of this variable doesn’t end at the very next closing curly bracket <span class="CodeAnnotation" aria-label="annotation2">2</span>, which is for a different block (section of code enclosed in curly brackets). Instead, it goes to the end bracket <span class="CodeAnnotation" aria-label="annotation3">3</span> for the block that started right before <code>local</code> was declared. The <code>veryLocal</code> variable has an even smaller scope. It starts with the declaration <code>int veryLocal = 7;</code> and ends when the block ends <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>When a variable’s scope ends, the program can’t use the variable anymore. For example, trying to return the value of <code>veryLocal</code> at the end of <code>main</code> using the <code>return(veryLocal);</code> statement wouldn’t work.</p>
<h2 id="h1-501621c07-0002">Hidden Variables</h2>
<p class="BodyFirst">In the previous example, all the local variables had different names in addition to having different scope. However, variables can also have the same name in different scopes. If multiple variables have the same name, C will use the value of the one in the current scope and hide the others. (Please don’t do this because it makes code confusing. It’s mentioned here so you know what to avoid.)</p>
<p>Let’s take a look at <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a>, which demonstrates a very badly written program.</p>
<p class="CodeLabel"><b>hidden.c</b></p>
<pre><code>/*
 * Useless program to demonstrate hidden variables
 */
#include &lt;stdio.h&gt;
  
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> int var = 7;            // A variable
  
int main()
{
    // ... do something
    {
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> int var = 13;   // Hides var = 7
  
        {
          <span class="CodeAnnotationCode" aria-label="annotation3">3</span> int var = 16;     // Hides var = 7, var = 13

            // ... do something
        }
        // ... do something
    }
    // ... do something
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: Hidden variables</p>
<p><span epub:type="pagebreak" title="108" id="Page_108"/>In this program, we define three variables, all named <code>var</code>. When the second one is defined <span class="CodeAnnotation" aria-label="annotation2">2</span>, it hides the first one <span class="CodeAnnotation" aria-label="annotation1">1</span>. Similarly, the <code>int var = 16;</code> declaration hides the second variable <code>var</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which hides the first one <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>Suppose we were to add the following statement after the third declaration:</p>
<pre><code>var = 42;</code></pre>
<p>Which <code>var</code> are we assigning? The one declared at <span class="CodeAnnotation" aria-label="annotation1">1</span>, <span class="CodeAnnotation" aria-label="annotation2">2</span>, or <span class="CodeAnnotation" aria-label="annotation3">3</span>? The fact that we have to ask this question is a good indicator that this code is confusing. I’m not going to leave it as an exercise for the reader to find the answer because the proper solution is to never do this in the first place.</p>
<h2 id="h1-501621c07-0003">Procedures</h2>
<p class="BodyFirst">A <em>procedure</em> is a way to define code so it can be used again. Let’s look at <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a>, which provides a simple example.</p>
<p class="CodeLabel"><b>hello3.c</b></p>
<pre><code>/**
 * Print hello, hello, hello, world.
 */
#include &lt;stdio.h&gt;
  
/**
 * Tell the world hello.
 */
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> void sayHello(void)
{
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> puts("Hello");
}

int main()
{
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> sayHello();
    sayHello();
    sayHello();
    puts("World!");
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: A procedure demonstration</p>
<p>This program prints <code>Hello</code> three times, then <code>World!</code>. The procedure starts with a comment block, which isn’t strictly necessary, but if you’re going to write quality code, you should put one in before each procedure. The beginning (<code>/**</code>) of the comment block indicates that the Doxygen documentation tool should process it. To be compatible with the format of the STM libraries, we are using the same commenting convention.</p>
<p><span epub:type="pagebreak" title="109" id="Page_109"/>The statement <code>void sayHello(void)</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> tells C that our procedure’s name is <code>sayHello</code>. It returns nothing (first <code>void</code>) and takes no parameters (second <code>void</code>). The <code>{}</code> block that follows this statement defines the body of the procedure and contains all the instructions executed by the procedure <span class="CodeAnnotation" aria-label="annotation2">2</span>. The three <code>sayHello();</code> lines <span class="CodeAnnotation" aria-label="annotation3">3</span> are calls to the <code>sayHello</code> procedure. They tell the processor to save the location of the next statement (either another call to <code>sayHello</code> or the call to <code>puts</code>) and then start execution with the first line of <code>sayHello</code>. When the procedure finishes (or hits a <code>return</code> statement), execution continues at the point saved during the call.</p>
<h2 id="h1-501621c07-0004">Stack Frames</h2>
<p class="BodyFirst">Procedures have their own local variables. The compiler’s job is to organize memory so it can hold those variables. For global variables (not in a procedure), the compiler says something like, “I need 4 bytes to hold the integer named <code>Total</code>.” The linker then sees that and assigns the variable a physical location in memory (for example, <code>0xffffec04</code>). Global variables are allocated statically at compile time, meaning the compiler allocates space for the variables and that’s it. The variables are never destroyed, and their memory is not reallocated.</p>
<p>Variables that are local to a procedure are more complex. They have to be allocated dynamically at runtime. When a procedure starts, all the local variables for that procedure are allocated. (Note: there is a <code>static</code> local variable that’s allocated at compile time, but we haven’t covered that yet.) When the procedure ends, they are deallocated. The compiler accomplishes this by creating a <em>stack frame</em> when the procedure starts and destroying it when the procedure ends. The stack frame holds all the temporary information the procedure needs.</p>
<p>Let’s look at <a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a>, which shows a sample program.</p>
<p class="CodeLabel"><b>proc.c</b></p>
<pre><code>/**
 * @brief Program to demonstrate procedures and local variables
 */

/**
 * Function that is called from another function
 */
void inner(void) {
    int i = 5;     // A variable
    int k = 3;     // Another variable
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> i = i + k;     // Do something with variables
}
/**
 * Outer-level function
 */
void outer(void) {
    int i = 6;     // A variable
    int j = 2;     // Another variable
    i = j + i;     // Use variables
    inner();
<span epub:type="pagebreak" title="110" id="Page_110"/>}

int main()
{
    outer();
    return(0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: A stack frame demonstration</p>
<p>Let’s create a project for this program and start debugging it. Run the program in the debugger, then step through it using the command <b>Run</b><span class="MenuArrow">▶</span><b>Step Into</b> (F5) until you reach <span class="CodeAnnotation" aria-label="annotation1">1</span>. Your screen should look like <a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a>.</p>
<figure>
<img src="image_fi/501621c07/f07001.png" alt="f07001" class=""/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: Debugging <em>proc.c</em></p></figcaption>
</figure>
<p>When a program is loaded, all the statically allocated variables get their own memory locations. In the STM32 chip, they are assigned to the lower portion of the random access memory (RAM). The leftover memory is reserved for dynamic allocation. Specifically, two memory areas are used dynamically: the <em>stack</em>, which holds local variables, and the <em>heap</em>. We won’t worry about the heap for now; our microprocessor doesn’t have enough memory to use it. (We’ll discuss the heap in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>, when we talk about programming for larger systems.)</p>
<p>The name <em>stack</em> comes from the fact that data is stacked on top of each other in memory. When your program starts, the <code>main</code> function allocates a stack frame for its local variables and temporary values. When <code>outer</code> is called, it allocates another stack frame on top of the one for <code>main</code>. The call to <code>inner</code> adds a third stack frame to the stack.</p>
<p>To see where the stack is in each procedure, click the <b>Registers</b> tab in the upper-right panel and scroll down until you see the <code>rsp</code> register. <a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a> shows that it contains <code>0x7fffffffd0e0</code>.</p>
<span epub:type="pagebreak" title="111" id="Page_111"/><figure>
<img src="image_fi/501621c07/f07002.png" alt="f07002" class=""/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: Displaying the registers</p></figcaption>
</figure>
<p>Depending on the machine, the stack may either start at a low memory address and grow up or at a high memory address and grow down. On this machine (the x86), it starts high and goes down.</p>
<p>The stack from the <code>outer</code> frame is at <code>0x7fffffffd0f0</code>. Because our stack grows down, this number is lower than the stack frame for <code>main</code>. The <code>inner</code> frame is at <code>0x7fffffffd110</code> (see <a href="#table7-1" id="tableanchor7-1">Table 7-1</a>).</p>
<figure>
<figcaption class="TableTitle"><p><a id="table7-1">Table 7-1</a>: Stack Usage</p></figcaption>
<table id="table-501621c07-0001" border="1">
<thead>
<tr>
<td><b>Address</b></td>
<td><b>Procedure</b></td>
<td><b>Contents</b></td>
<td><b>Comments</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x7fffffffd110</code></td>
<td><code>main</code></td>
<td>&lt;overhead&gt;</td>
<td>Bottom of stack</td>
</tr>
<tr>
<td><code>0x7fffffffd0f0</code></td>
<td><code>outer</code></td>
<td>&lt;overhead&gt;<br/>
<code>i</code><br/>
<code>j</code></td>
<td/>
</tr>
<tr>
<td><code>0x7fffffffd0e0</code></td>
<td><code>inner</code></td>
<td>&lt;overhead&gt;<br/>
<code>i</code><br/>
<code>k</code></td>
<td>Top of stack</td>
</tr>
</tbody>
</table>
</figure>
<p>One key concept to understand is that stack frames are allocated in last in, first out (LIFO) order. When we are done with <code>inner</code>, its stack frame will be destroyed and then the <code>outer</code> frame will be destroyed.</p>
<p>The Variables panel (shown in <a href="#figure7-1">Figure 7-1</a>, upper right) displays the <code>i</code> and <code>k</code> variables. The debugger is displaying the variables in the stack frame for <code>inner</code>, indicated by the fact that the stack frame for <code>inner</code> is highlighted in the Debug panel (upper left). Click the <code>outer</code> stack frame in the Debug panel, and you’ll see the Variables panel change and show the variables for <code>outer</code>, as in <a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a>.</p>
<figure>
<img src="image_fi/501621c07/f07003.png" alt="f07003" class=""/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: The <span class="LiteralInCaption"><code>outer</code></span> stack frame</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="112" id="Page_112"/>Let’s continue debugging the program by stepping past the last instruction of <code>inner</code>. When we exit <code>inner</code>, the stack frame for that function disappears, because we are no longer executing <code>inner</code> and have no need for a place to store its variables.</p>
<p><a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a> shows the stack after we exit the <code>inner</code> stack frame.</p>
<figure>
<img src="image_fi/501621c07/f07004.png" alt="f07004" class=""/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: The stack after exiting the <span class="LiteralInCaption"><code>inner</code></span> stack frame</p></figcaption>
</figure>
<p>Notice there are now only two stack frames on the stack.</p>
<h2 id="h1-501621c07-0005">Recursion</h2>
<p class="BodyFirst">So far, we’ve been dealing with basic procedure calls; each procedure was given a different name, and the calling process was simple. Now we’re going to focus on <em>recursion</em>, which is when a function calls itself. Recursion can be a powerful tool, but it’s tricky to use if you don’t understand the rules.</p>
<p>The classic recursive problem is computing a factorial. The factorial function is defined as follows:</p>
<ol class="none">
<li>f(<em>n</em>) = 1, when <em>n</em> is 1</li>
<li>otherwise, f(<em>n</em>) = <em>n</em> × f(<em>n</em> – 1)</li>
</ol>
<p>Turning this into code gives us <a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a>.</p>
<p class="CodeLabel"><b>factor.c</b></p>
<pre><code>/**
 * Compute factorial recursively
 * (the basic recursive example)
 */
  
#include &lt;stdio.h&gt;
 
/**
 * Compute factorial
 *
 * @param x The number to compute the factorial of
 * @returns the factorial
 */
int factor(const int x) {
    if (x == 1)
        return (1);
    return (x * factor(x-1));
<span epub:type="pagebreak" title="113" id="Page_113"/>}

int main()
{
    int result = factor(5);
    printf("5! is %d\n", result);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: A program to compute factorials</p>
<p>First, we call <code>factor(5)</code> to get the factorial of 5. For that, we need <code>factor(4)</code>, so we suspend <code>factor(5)</code> while we call <code>factor(4)</code>. But <code>factor(4)</code> needs <code>factor(3)</code>, so we suspend work and call <code>factor(3)</code>. Now <code>factor(3)</code> needs <code>factor(2)</code>, and, again, <code>factor(2)</code> needs <code>factor(1)</code>. Finally, <code>factor(1)</code> doesn’t need anything, so it returns 1 to its caller, <code>factor(2)</code>. The function <code>factor(2)</code> is running, so it computes 2 × 1 and returns 2 to its caller, <code>factor(3)</code>. Next, <code>factor(3)</code> takes the return value (2), computes 2 × 3, and returns 6 to its caller, <code>factor(4)</code>. Nearing the end, <code>factor(4)</code> computes 6 × 4 and returns 24. Finally, <code>factor(5)</code> computes 24 × 5 and returns 120.</p>
<p>When you execute this program in the debugger, you should see the stack grow and shrink as the program computes the factorial. You also should see a stack with five stack frames allocated for the <code>factor</code> procedure, one for each instance: <code>factor(1)</code>, <code>factor(2)</code>, <code>factor(3)</code>, <code>factor(4)</code>, and <code>factor(5)</code>.</p>
<p>Two rules determine when you can use recursion:</p>
<ol class="decimal">
<li value="1">Each call to the procedure must make the problem simpler.</li>
<li value="2">There must be an end point.</li>
</ol>
<p>Let’s see how those rules work with our factorial program. In order to compute <code>factor(5)</code>, we need to compute <code>factor(4)</code>. The first rule is satisfied because <code>factor(4)</code> is simpler than <code>factor(5)</code>. Sooner or later, we reach <code>factor(1)</code>, and that’s the end point, which satisfies the second rule.</p>
<p>Let’s violate the rules to see what happens; we’ll modify the program and try to compute <code>factor(-1)</code>.</p>
<p>Does this satisfy the two rules? Well, <code>factor(-1)</code> needs <code>factor(-2)</code>, which needs <code>factor(-3)</code>, and so on, until we reach 1. But there is no way to go from –1 to 1 by subtraction, so we have no way of ending the program.</p>
<p>When I run this program on my little Linux box, I see the following:</p>
<pre><code> $ <b>./06.factor-m1</b>
Segmentation fault (core dumped)</code></pre>
<p>The system ran out of stack memory, and the program aborted because it violated the constraints of the memory protection of the x86 processor. On other systems, the results may be different. For example, on ARM processors, the stack can run into the heap and trash it (more on the heap in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>), or something else can get clobbered. In any case, running out of stack is not a good thing to do.</p>
<p>Incidentally, the program got all the way to <code>x=-262007</code> before it aborted.</p>
<h2 id="h1-501621c07-0006"><span epub:type="pagebreak" title="114" id="Page_114"/>Programming Style</h2>
<p class="BodyFirst">In this book, we try to use good programming style whenever we can. For example, we’ve made sure to include a comment block at the top of every procedure, and we always include a comment after each variable declaration. Good programming style is designed the way it is for two reasons: to give the programmer who comes after you a clear idea of what you did and to make it difficult to make errors.</p>
<p>We violated one of those rules in the factorial example. This is the offending line:</p>
<pre><code>int factor(const int x) {</code></pre>
<p>What’s wrong with it? The <code>int</code> type is signed, but you can compute the factorial only on positive numbers. We could have written our function as the following:</p>
<pre><code>unsigned int factor(const unsigned int x) {</code></pre>
<p>Writing it that way would make it impossible to pass in a negative number. Note that the compiler will helpfully change –1 to an unsigned number (4294967295) without warning, unless you include the compiler switch <code>-Wconversion</code>. GCC has hundreds of options, and finding out which to use is its own art form. The first version of that line did have two advantages, however; it’s a good example of bad style, and it allowed us to demonstrate stack overflow with <code>factor(-1)</code>.</p>
<h2 id="h1-501621c07-0007">Summary</h2>
<p class="BodyFirst">You may have noticed something about this book. It’s divided into chapters. Why? To make it easier to read, of course. A chapter provides the reader with an understandable unit of information that can be absorbed in one sitting.</p>
<p>Computer programs need to be divided into bite-size chunks as well. It’s impossible to keep track of a 750,000-line program. It is possible to understand everything about a 300-line procedure. Local variables also help in this organization. If you have a variable that’s local to a 300-line procedure, you know it will be used only in those 300 lines. On the other hand, a global variable can be used anywhere in a 750,000-line program.</p>
<p>The key to writing good code is to make it understandable and simple. Procedures help you divide your program into simple, understandable units, which helps you write code that’s more reliable and easier to maintain.</p>
<h2 id="h1-501621c07-0008"><span epub:type="pagebreak" title="115" id="Page_115"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a function to compute the area of a triangle and a small main program to test it with three different sets of values.</li>
<li value="2">Write a procedure called <code>max</code> that returns the maximum of two numbers.</li>
<li value="3">Write a program that computes the fifth Fibonacci number. Bonus points for doing it recursively.</li>
<li value="4">Create a function that adds up the digits in a number. For example, 123 results in 6 (in other words, 1 + 2 + 3). If the result is 10 or greater, the process should repeat until the result is a single digit. For example, 987 is 9 + 8 + 7 = 24. That’s bigger than 10, so 24 is 2 + 4, which yields 6.</li>
</ol>
</section>
</body></html>