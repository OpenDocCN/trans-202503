<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch20" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch20">
<span class="CN"><span aria-label=" Page 351. " epub:type="pagebreak" id="pg_351" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">20</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">REMOTE CONTROL VIA TELEGRAM</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">Controlling your Arduino from a distance greater than your local area network often requires paid IoT services, such as Blynk or Microsoft Azure, or some complex coding and time. For a simpler and less expensive way to remotely control your Arduino and retrieve data, you can use the Telegram instant-messaging service and an ESP32-based Arduino-compatible board.</p>
<p class="TX">Telegram is a free, globally accessible cross-platform encrypted messaging service that allows users to chat with each other one on one or in groups on a relatively secret basis. Thanks to Telegram’s automation feature, you can get an Arduino to control a Telegram user account to send and receive data over the service. This allows you to build remote-controlled devices and remotely request data from an internet-connected Arduino using Telegram.</p>
<p class="TX"><span aria-label=" Page 352. " epub:type="pagebreak" id="pg_352" role="doc-pagebreak"/>In this chapter, I’ll introduce you to the Telegram app and web interface. You’ll interface Arduino sketches with the Telegram library. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Create a simple remote to control digital output pins</li>
<li class="BL">Build a project that remotely retrieves data generated by the BMP180 sensor board</li>
<li class="BL">Configure an automated data transmitter that you can monitor from the internet</li>
</ul>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-148"/><samp class="SANS_Futura_Std_Bold_B_11">Configuring Your Telegram Account</samp></h2>
<p class="TNI">You can communicate over Telegram using either an app on your device or a web browser on almost any device connected to the internet. However, you’ll need to create a Telegram account using a device such as a smartphone or tablet before you can use the service on your computer. If you don’t already have an account, visit the website <a href="https://telegram.org"><i>https://<wbr/>telegram<wbr/>.org</i></a>, download and install the app for your device, and set up a user account.</p>
<p class="TX">To communicate with your Arduino-compatible ESP32 board over Telegram, you’ll need to create a Telegram “bot,” your own automated Telegram user that receives and sends messages to and from your ESP32. To do so, open Telegram, log into your account on your device, and search for the user <i>BotFather</i>, as shown in <a href="chapter20.xhtml#fig20-1">Figure 20-1</a> (Android).</p>
<figure class="IMG"><img alt="A SCREENSHOT OF SEARCHING FOR THE BOTFATHER USER ON TELEGRAM" class="img5" id="fig20-1" src="../images/fig20-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-1: Searching for the Telegram user</samp> <samp class="SANS_Futura_Std_Book_11">BotFather</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">on Android</samp></p></figcaption>
</figure>
<p class="TX">Select the BotFather account with the blue tick, and you should be presented with the start screen.</p>
<p class="TX">Tap <b>START</b> to proceed. Telegram should then show you a list of options. Click, touch, or just send <b>/newbot</b> in the messenger to be prompted for a bot account name. Once you enter your preferred bot name, you’ll be prompted for a username for your bot. Enter your preferred username. You’ll then be presented with your <i>token</i>, a unique identifier for your bot that’s required for your Arduino sketches, as shown in <a href="chapter20.xhtml#fig20-2">Figure 20-2</a>.<span aria-label=" Page 353. " epub:type="pagebreak" id="pg_353" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF BOT ACCOUNT CREATION" class="img4" id="fig20-2" src="../images/fig20-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-2: Bot account creation in Telegram</samp></p></figcaption>
</figure>
<p class="TX">Write the token down for later reference. You might copy and paste it into a file if you’re using Telegram on a computer or into a notes app on your mobile device.</p>
<p class="TX">Next, you need to determine your Telegram chat ID, a unique number you’ll use to authenticate your Arduino’s messages to Telegram. Search for the Telegram user <i>IDBot</i> and select the result with the image of a fingerprint for the avatar, as shown in <a href="chapter20.xhtml#fig20-3">Figure 20-3</a>.<span aria-label=" Page 354. " epub:type="pagebreak" id="pg_354" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCREENSHOT OF SEARCHING FOR IDBOT" class="img4" id="fig20-3" src="../images/fig20-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-3: Searching for the</samp> <samp class="SANS_Futura_Std_Book_11">IDBot</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Telegram account</samp></p></figcaption>
</figure>
<p class="TX">Once you have opened its account, send IDBot the message <b>/start</b> to initialize communication and then <b>/getid</b>, as shown in <a href="chapter20.xhtml#fig20-4">Figure 20-4</a>. When IDBot replies with your chat ID, write that number down as well, as you’ll need it along with the token.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF SEARCHING FOR THE CHAT ID OF THE ACCOUNT" class="img4" id="fig20-4" src="../images/fig20-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-4: Searching for the account’s chat ID</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 355. " epub:type="pagebreak" id="pg_355" role="doc-pagebreak"/>Now that you have your Telegram account and bot set up, it’s time to configure your Arduino IDE.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-149"/><samp class="SANS_Futura_Std_Bold_B_11">Configuring the Arduino IDE</samp></h2>
<p class="TNI">If you haven’t already done so, follow the instructions in <span class="Xref">“Configuring the Arduino IDE for the ESP32”</span> and <span class="Xref">“Testing the ESP32”</span> in <span class="Xref"><a href="chapter19.xhtml">Chapter 19</a></span>. Once you’ve set up your ESP32, you need to install two libraries. Search for <b>UniversalTelegramBot</b> in the Library Manager, and then click <b>Install</b>.</p>
<p class="TX">Once UniversalTelegramBot is installed, search for <b>ArduinoJson</b> in the Library Manager, and then click <b>Install</b> at the bottom of the library description (unless the library was already installed along with UniversalTelegramBot).</p>
<p class="TX">You’re now ready to create your first project remote-controlled by Telegram.</p>
<p class="HeadProject"><span id="h1-150"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #58: Remote-Controlling Four LEDs</samp></p>
<p class="TNI">This project demonstrates a fast and simple method of controlling four LEDs via four digital output pins on your Arduino-compatible board via Telegram. With your existing knowledge of electronics and Arduino, you should be able to easily extrapolate from this basic framework how to control other devices that can be triggered with a digital output pin.</p>
<p class="TX">You’ll need the following hardware:</p>
<ul class="ul">
<li class="BL">An ESP32 dev board and matching USB cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">Four LEDs</li>
<li class="BL">One 560 Ω, 0.25 W, 1 percent resistor</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter20.xhtml#fig20-5">Figure 20-5</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #58" class="img5" id="fig20-5" src="../images/fig20-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-5: The schematic for Project #58</samp></p></figcaption>
</figure>
<p class="TX">Next, enter and upload the Project #58 sketch, adding your Wi-Fi network credentials in the first few lines as appropriate, as originally explained <span aria-label=" Page 356. " epub:type="pagebreak" id="pg_356" role="doc-pagebreak"/>in <span class="Xref">Project #55 in <a href="chapter19.xhtml">Chapter 19</a></span>. Once the sketch has uploaded, the ESP32 should attempt to connect to your Wi-Fi network and communicate with the Telegram bot you created earlier. After a few moments, open Telegram on your device or web browser and search for your bot.</p>
<p class="TX">Select your bot. You should be presented with the bot’s chat history page. You can control your ESP32 board from this chat history. When a user sends the <b>/start</b> command, any Telegram bot should send it back to the ESP32, which is programmed to reply to that command with a basic set of instructions. Always include such instructions in your own projects so the user isn’t left at a loss on how to control the system.</p>
<p class="TX">After Telegram displays the start message, you can send the commands included in the instruction set and watch the LEDs respond to your commands. <a href="chapter20.xhtml#fig20-6">Figure 20-6</a> shows an example of starting the bot and controlling the LEDs.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE ESP32 CONTROL VIA TELEGRAM" class="img4" id="fig20-6" src="../images/fig20-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-6: Sending various commands to the ESP32 board via Telegram</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 357. " epub:type="pagebreak" id="pg_357" role="doc-pagebreak"/>You should receive a response to all the commands being sent; again, it’s good practice to write code that replies to the user to make sure actions have taken place. The sketch also acknowledges responses in the Arduino IDE’s Serial Monitor, as shown in <a href="chapter20.xhtml#fig20-7">Figure 20-7</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF THE EXAMPLE SERIAL MONITOR OUTPUT FOR PROJECT #58" class="img4" id="fig20-7" src="../images/fig20-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-7: Example Serial Monitor output for Project #58</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-58"/>

<pre><code>// Project #58 - ESP32 GPIO remote control over Telegram

#include &lt;WiFi.h&gt;
#include &lt;WiFiClientSecure.h&gt;
#include &lt;UniversalTelegramBot.h&gt;
#include &lt;ArduinoJson.h&gt;

// Enter your Wi-Fi network SSID and password:
const char* ssid = "<var>wifiname</var>";
const char* password = "<var>password</var>";

// Enter your Telegram bot token and chat ID:
#define botToken "token"
#define chatID "chatID"

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define LED1 17
#define LED2 16
#define LED3 27
#define LED4 14

WiFiClientSecure client;
UniversalTelegramBot bot(botToken, client);

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> int bot_delay = 1000;
unsigned long lastRun=0;

void processMessages(int numNewMessages)
{
    Serial.println("Handling New Message");
    Serial.println(String(numNewMessages));

    for (int i = 0; i &lt; numNewMessages; i++)
    {
        // Chat ID of the requester:
<span aria-label=" Page 358. " epub:type="pagebreak" id="pg_358" role="doc-pagebreak"/>      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> String chat_id = String(bot.messages[i].chat_id);
        if (chat_id != chatID)
        {
            bot.sendMessage(chat_id, "Unauthorized user", " ");
            continue;
        }

        // Print the received message:
        String user_text = bot.messages[i].text;
        Serial.println(user_text);

      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> String your_name = bot.messages[i].from_name;

      <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (user_text == "/start")
        {
            String startMessage = "Hello, " + your_name + ".\n";
            startMessage += "Choose from the following commands:\n";
            startMessage += "(replace x with LED number 1~4)\n";
            startMessage += "Send /xon to turn LEDx ON \n";
            startMessage += "Send /xoff to turn LEDx ON \n";
            startMessage += "Send /alloff to turn all LEDs off \n";
            startMessage += "Send /status to check LED states \n";
          <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> bot.sendMessage(chat_id, startMessage, " ");
        }

      <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> if (user_text == "/1on")
        {
            bot.sendMessage(chat_id, "LED 1 turned on", " ");
            digitalWrite(LED1, HIGH);
        }

        if (user_text == "/1off")
        {
            bot.sendMessage(chat_id, "LED 1 turned off", " ");
            digitalWrite(LED1, LOW);
        }

        if (user_text == "/2on")
        {
            bot.sendMessage(chat_id, "LED 2 turned on", " ");
            digitalWrite(LED2, HIGH);
        }

        if (user_text == "/2off")
        {
            bot.sendMessage(chat_id, "LED 2 turned off", " ");
            digitalWrite(LED2, LOW);
        }

        if (user_text == "/3on")
        {
            bot.sendMessage(chat_id, "LED 3 turned on", " ");
            digitalWrite(LED3, HIGH);
        }

<span aria-label=" Page 359. " epub:type="pagebreak" id="pg_359" role="doc-pagebreak"/>        if (user_text == "/3off")
        {
            bot.sendMessage(chat_id, "LED 3 turned off", " ");
            digitalWrite(LED3, LOW);
        }

        if (user_text == "/4on")
        {
            bot.sendMessage(chat_id, "LED 4 turned on", " ");
            digitalWrite(LED4, HIGH);
        }

        if (user_text == "/4off")
        {
            bot.sendMessage(chat_id, "LED 4 turned off", " ");
            digitalWrite(LED4, LOW);
        }

        if (user_text == "/alloff")
        {
            bot.sendMessage(chat_id, "Turning all LEDs off", " ");
            digitalWrite(LED1, LOW);
            digitalWrite(LED2, LOW);
            digitalWrite(LED3, LOW);
            digitalWrite(LED4, LOW);
        }

        if (user_text == "/status")
        {
            if (digitalRead(LED1))
            {
                bot.sendMessage(chat_id, "LED1 is on", " ");
            } else
            {
                bot.sendMessage(chat_id, "LED1 is off", " ");
            }
            if (digitalRead(LED2))
            {
                bot.sendMessage(chat_id, "LED2 is on", " ");
            } else
            {
                bot.sendMessage(chat_id, "LED2 is off", " ");
            }
            if (digitalRead(LED3))
            {
                bot.sendMessage(chat_id, "LED3 is on", " ");
            } else
            {
                bot.sendMessage(chat_id, "LED3 is off", " ");
            }
            if (digitalRead(LED4))
            {
                bot.sendMessage(chat_id, "LED4 is on", " ");
            } else
<span aria-label=" Page 360. " epub:type="pagebreak" id="pg_360" role="doc-pagebreak"/>            {
                bot.sendMessage(chat_id, "LED4 is off", " ");
            }
        }
    }
}

void setup()
{
    Serial.begin(115200);

    pinMode(LED1, OUTPUT);
    pinMode(LED2, OUTPUT);
    pinMode(LED3, OUTPUT);
    pinMode(LED4, OUTPUT);

    digitalWrite(LED1, LOW);
    digitalWrite(LED2, LOW);
    digitalWrite(LED3, LOW);
    digitalWrite(LED4, LOW);

    // Connect to Wi-Fi
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);

    // Add root certificate for api.telegram.org
    client.setCACert(TELEGRAM_CERTIFICATE_ROOT);
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(1000);
        Serial.println("Connecting to Wi-Fi…");
    }
    Serial.println(WiFi.localIP()); // Display IP address used by ESP32
}

void loop()
{
    if (millis() &gt; lastRun + bot_delay)
    {
        int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
        while (numNewMessages)
        {
            Serial.println("Received message");
            processMessages(numNewMessages);
            numNewMessages = bot.getUpdates(bot.last_message_received + 1);
        }
        lastRun = millis();
    }
}
</code></pre>

<p class="TX">The sketch first includes the required libraries, followed by fields to enter your Wi-Fi network’s ID and password and then fields to enter your <span aria-label=" Page 361. " epub:type="pagebreak" id="pg_361" role="doc-pagebreak"/>Telegram token and chat ID. It defines the pin numbers for the LEDs so you can easily refer to them in the rest of the sketch <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then starts instances of the secure Wi-Fi connection client and the Telegram bot interface. Next, the sketch sets the length of the period it will wait before checking if new Telegram messages are available to 1,000 milliseconds <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The sketch uses the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp> to retrieve the messages received by the Telegram bot and then takes actions based on the contents of the message. The entire process is repeated for the amount passed through the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">numNewMessages</samp>. The sketch first performs a security check by comparing your Telegram alphanumeric chat ID against the chat ID being sent with the message from Telegram <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This prevents hackers from attempting to control your Telegram bot. If the two don’t match, the sketch jumps out of the loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> function and ignores the message(s) received. If they do match, the sketch proceeds to send the message received to the Serial Monitor for debugging purposes and then retrieves the Telegram username attached to your Telegram account <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. This is used to add a friendly level of personalization.</p>
<p class="TX">To decide how to act on the message received, the sketch compares the received message against various <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> functions, the first of which is <samp class="SANS_TheSansMonoCd_W5Regular_11">/start</samp> <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. When activated, this part of the sketch combines lines of text, including the Telegram username, into one string variable, which is then sent to be displayed in the Telegram chat using <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. The sketch is set up to accept various other chat messages from a user, all beginning with a forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>). For example, the message to turn on LED number 1 (<samp class="SANS_TheSansMonoCd_W5Regular_11">/1on</samp>) is detected at <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. When a message is received from the user, a <samp class="SANS_TheSansMonoCd_W5Regular_11">bot.sendMessage()</samp> function sends an acknowledgment back to the Telegram chat and then turns on the LED. The sketch receives and acts upon the rest of the possible messages in a similar manner.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>, the sketch configures the digital pins for the LEDs and sets them to <samp class="SANS_TheSansMonoCd_W5Regular_11">LOW</samp> by default, initializes the Wi-Fi library, and sets up a secure connection to Telegram. Finally, it connects the ESP32 board to your Wi-Fi and sends the IP address to the Serial Monitor.</p>
<p class="TX">In <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, the sketch checks Telegram for any new chat messages every second, using the comparison in the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> function. Every time a message is received, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp> is updated to the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp>. If the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">lastRun</samp> plus <samp class="SANS_TheSansMonoCd_W5Regular_11">bot_delay</samp> (the amount of time to wait between checking for messages), it’s time to check for messages again. The number of new messages is then retrieved from Telegram and processed in turn with the <samp class="SANS_TheSansMonoCd_W5Regular_11">processMessages()</samp> function described earlier.</p>
<p class="TX">This sketch provides a simple framework for acting upon messages received from Telegram, along with a simple remote control for digital outputs. The next project builds on this framework, teaching you to retrieve data from the remote ESP32 board using Telegram.</p>
<p class="HeadProject"><span id="h1-151"/><span aria-label=" Page 362. " epub:type="pagebreak" id="pg_362" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #59: Retrieving Remote Data</samp></p>
<p class="TNI">This project enables you to retrieve, on demand, the data generated by the BMP180 sensor board first used in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, including temperature, air pressure, or height above sea level. You can also use this project as a general framework for remotely monitoring parameters over Telegram.</p>
<p class="TX">You’ll need the following hardware:</p>
<ul class="ul">
<li class="BL">An ESP32 dev board and matching USB cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">A BMP180 sensor board</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter20.xhtml#fig20-8">Figure 20-8</a>. The BMP180 can work on 3.3 V as well as 5 V, so a level converter board isn’t necessary in this case.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #59" class="img5" id="fig20-8" src="../images/fig20-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-8: The schematic for Project #59</samp></p></figcaption>
</figure>
<p class="TX">Once you have built the circuit and uploaded the sketch, open Telegram and enter the chat history for your Telegram bot, as with the previous project. Enter <b>/start</b> in Telegram. You should receive a message listing the commands you can use to retrieve sensor data, as shown in <a href="chapter20.xhtml#fig20-9">Figure 20-9</a>. For variety, I’ve used the Telegram Windows application, rather than the Android app, to take screenshots for this project.</p>
<figure class="IMG"><img alt="THE EXAMPLE OUTPUT FROM PROJECT #59" class="img8" id="fig20-9" src="../images/fig20-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-9: Example output from Project #59</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 363. " epub:type="pagebreak" id="pg_363" role="doc-pagebreak"/>Let’s see how this works:</p>
<span id="pro-59"/>

<pre><code>// Project #59 - ESP32 remote data retrieval via Telegram

#include &lt;WiFi.h&gt;
#include &lt;WiFiClientSecure.h&gt;
#include &lt;UniversalTelegramBot.h&gt;
#include &lt;ArduinoJson.h&gt;
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #include &lt;Adafruit_BMP085.h&gt;

Adafruit_BMP085 bmp;

// Enter your Wi-Fi network SSID and password:
const char* ssid = "<var>wifiname</var>";
const char* password = "<var>password</var>";

// Enter your Telegram bot token and chatID:
#define botToken "token"
#define chatID "chatID"

WiFiClientSecure client;
UniversalTelegramBot bot(botToken, client);

// Checks for new messages every 1 second:
int bot_delay = 1000;
unsigned long lastRun=0;

void processMessages(int numNewMessages)
{
    String welcome; // Used for assembling messages to send
    Serial.println("Handling New Message");
    Serial.println(String(numNewMessages));

    for (int i = 0; i &lt; numNewMessages; i++)
    {
        // Chat ID of the requester:
        String chat_id = String(bot.messages[i].chat_id);
        if (chat_id != chatID)
        {
            bot.sendMessage(chat_id, "Unauthorized user", " ");
            continue;
        }

        // Print the received message:
        String user_text = bot.messages[i].text;
        Serial.println(user_text);

        String your_name = bot.messages[i].from_name;

      <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> if (user_text == "/start")
        {
            welcome = "Hello, " + your_name + ".\n";
            welcome += "Choose from the following commands:\n\n";
            welcome += "Send /temp for temperature\n";
            welcome += "Send /pressure for air pressure\n";
<span aria-label=" Page 364. " epub:type="pagebreak" id="pg_364" role="doc-pagebreak"/>            welcome += "Send /altitude for altitude\n";
            bot.sendMessage(chat_id, welcome, " ");
        }

      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> if (user_text == "/temp")
        {
            // get BMP180 temperature
            welcome = "Temperature (C): ";
            welcome += String(bmp.readTemperature());
            bot.sendMessage(chat_id, welcome, " ");
        }

      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> if (user_text == "/pressure")
        {
            // Get BMP180 air pressure, convert to hPa:
            welcome = "Air pressure (hPa): ";
            welcome += String(bmp.readSealevelPressure() / 100);
            bot.sendMessage(chat_id, welcome, " ");
        }

      <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> if (user_text == "/altitude")
        {
            // Get BMP180 altitude:
            welcome = "Altitude (m): ";
            welcome += String(bmp.readAltitude());
            bot.sendMessage(chat_id, welcome, " ");
        }
    }
}

void setup()
{
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> bmp.begin();
    Serial.begin(115200);

    // Connect to Wi-Fi:
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);

    client.setCACert(TELEGRAM_CERTIFICATE_ROOT);
    // Add root certificate for api.telegram.org:
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(1000);
        Serial.println("Connecting to Wi-Fi…");
    }
    // Print ESP32 Local IP Address:
    Serial.println(WiFi.localIP());
}

void loop()
{
    if (millis() &gt; lastRun + bot_delay)
    {
        int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
        while (numNewMessages)
<span aria-label=" Page 365. " epub:type="pagebreak" id="pg_365" role="doc-pagebreak"/>        {
            Serial.println("Received message");
            processMessages(numNewMessages);
            numNewMessages = bot.getUpdates(bot.last_message_received + 1);
        }
        lastRun = millis();
    }
}
</code></pre>

<p class="TX">This sketch’s framework for using Telegram is the same as in Project #58. The only differences are the changes required for new hardware used—in this case the BMP180 sensor—and the communication messages for use with Telegram. The sketch includes the required library and initialization for the BMP180 sensor <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. It modifies the prior Telegram start message to suit this project’s purposes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and programs the responses to temperature <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, air pressure <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, and altitude message requests <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. You can easily modify the sketch for this project to substitute your own required actions to control ESP32 Arduino-compatible boards remotely via Telegram.</p>
<p class="TX">Keep the hardware for this project connected. You’ll use it in the next project, in which you’ll learn to automate data transmission over Telegram.</p>
<p class="HeadProject"><span id="h1-152"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #60: Automating Data Transmission</samp></p>
<p class="TNI">This project automatically sends data generated by the BMP180 sensor board on a recurring basis to your Telegram account. Rather than using messaging to request data, you can simply open your Telegram chat to view the latest project updates, watching changes in data in (nearly) real time.</p>
<p class="TX">The required hardware is the same as that for Project #59. Once you’ve set it up, enter and upload the Project #60 sketch, adding your Wi-Fi network credentials in the <samp class="SANS_TheSansMonoCd_W5Regular_11">#define</samp> fields as usual. After a few moments, open the Telegram bot chat window. You should see the temperature from the BMP180 displayed around every five seconds, as shown in <a href="chapter20.xhtml#fig20-10">Figure 20-10</a>.</p>
<figure class="IMG"><img alt="THE EXAMPLE OUTPUT FROM PROJECT #60" class="img8" id="fig20-10" src="../images/fig20-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 20-10: Example output from Project #60</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 366. " epub:type="pagebreak" id="pg_366" role="doc-pagebreak"/>Let’s see how this works:</p>
<span id="pro-60"/>

<pre><code>// Project #60 - Automating data transmission over Telegram

#include &lt;WiFi.h&gt;
#include &lt;WiFiClientSecure.h&gt;
#include &lt;UniversalTelegramBot.h&gt;
#include &lt;ArduinoJson.h&gt;
#include &lt;Adafruit_BMP085.h&gt;

Adafruit_BMP085 bmp;

// Enter your Wi-Fi network SSID and password:
const char* ssid = "<var>wifiname</var>";
const char* password = "<var>password</var>";

// Enter your Telegram bot token and chatID:
#define botToken "token"
#define chatID "chat ID"

WiFiClientSecure client;
UniversalTelegramBot bot(botToken, client);

void setup()
{
    bmp.begin();
    Serial.begin(115200);

    // Connect to Wi-Fi:
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);

    client.setCACert(TELEGRAM_CERTIFICATE_ROOT);
    // Add root certificate for api.telegram.org:
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(1000);
        Serial.println("Connecting to Wi-Fi…");
    }
    // Print ESP32 Local IP Address:
    Serial.println(WiFi.localIP());
}

void loop()
{
    String messageOut; // Used for assembling messages to send
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> messageOut = "Temperature (C): ";
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> messageOut += String(bmp.readTemperature());
    bot.sendMessage(chatID, messageOut, " ");
    delay(5000);
}
</code></pre>

<p class="TX">As this project is a one-way form of messaging, the required code is much shorter than that of the previous projects. The setup for the BMP180, <span aria-label=" Page 367. " epub:type="pagebreak" id="pg_367" role="doc-pagebreak"/>Wi-Fi and Telegram is still required, but the custom functions to deal with receiving and acting upon messages from the Telegram chat aren’t required. The sketch simply sends one message on a regular basis, using <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>. It declares the string variable <samp class="SANS_TheSansMonoCd_W5Regular_11">messageOut</samp> to hold the text to send out, then composes the message with explanation text showing that the data is temperature <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and the temperature value from the BMP180 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. It then sends the message to the Telegram chat. After a delay of five seconds, the process repeats.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-153"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned to harness the Telegram messaging application for remote project control or data retrieval, without any extra costs for a cloud service or special smartphone app. You could harness these projects to control your own devices with a digital output pin, or you could retrieve data from any sensor that can be connected to your Arduino or compatible boards.</p>
<p class="TX">The next chapter introduces you to retrieving the current time from internet time servers.</p>
</section>
</section>
</body>
</html>