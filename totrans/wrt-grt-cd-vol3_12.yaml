- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SYSTEM DOCUMENTATION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: System documentation specifies system requirements, design, test cases, and
    test procedures. In a large software system, the system documentation is often
    the most expensive part; the Waterfall software development model, for example,
    often produces more documentation than code. In addition, typically you must maintain
    system documentation manually, so if you change a description (such as a requirement)
    in one document, you’ll need to search through the system documentation and update
    every other document that references that description for consistency. This is
    a difficult and costly process.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at the common types of system documents, ways to
    enforce consistency within them, and documentation strategies to reduce some of
    the costs associated with development.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter discusses* system *documentation, not* user *documentation. To
    learn about user documentation in detail, check out “For More Information” on
    [page 184](ch09.xhtml#page_184).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.1 System Documentation Types**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Traditional software engineering generally uses the following system documentation
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System Requirements Specification (SyRS) document**'
  prefs: []
  type: TYPE_NORMAL
- en: The SyRS (see “[The System Requirements Specification Document](ch10.xhtml#lev-10.3)”
    on [page 193](ch10.xhtml#page_193)) is a *system-level* requirements document.
    In addition to software requirements, it might include hardware, business, procedural,
    manual, and other non-software-related requirements. The SyRS is a customer/management/stakeholder-level
    document that eschews detail to present a “big picture” view of the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Requirements Specification (SRS) document**'
  prefs: []
  type: TYPE_NORMAL
- en: The SRS (see “[The Software Requirements Specification Document](ch10.xhtml#lev-10.4)”
    on [page 194](ch10.xhtml#page_194)) extracts the software requirements^([1](ch19_footnote.xhtml#ch09fn1))
    from the SyRS and drills down on the high-level requirements to introduce new
    requirements at a much finer level of detail (suitable for software engineers).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The SyRS and SRS are* requirements *documents whose content may differ in
    scope and detail. Many organizations produce a single document rather than two
    separate ones, but this book treats them separately because the SyRS deals with
    a wider range of requirements (for example, hardware and business requirements)
    than the SRS.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Design Description (SDD) document**'
  prefs: []
  type: TYPE_NORMAL
- en: The SDD (see [Chapter 11](ch11.xhtml)) discusses *how* the system will be constructed
    (versus the SyRS and SRS, which describe *what* the system will do). In theory,
    any programmer should be able to use the SDD and write the corresponding code
    to implement the software system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Test Cases (STC) document**'
  prefs: []
  type: TYPE_NORMAL
- en: The STC (see “[Software Test Case Documentation](ch12.xhtml#lev-12.4)” on [page
    274](ch12.xhtml#page_274)) describes the various test values needed to verify
    that the system incorporates all the requirements, and functions correctly beyond
    the requirements list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Software Test Procedures (STP) document**'
  prefs: []
  type: TYPE_NORMAL
- en: The STP (see “[Software Test Procedure Documentation](ch12.xhtml#lev-12.5)”
    on [page 288](ch12.xhtml#page_288)) describes the procedures to efficiently execute
    the software test cases (from the STC) to verify correct system operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirements (or Reverse) Traceability Matrix (RTM) document**'
  prefs: []
  type: TYPE_NORMAL
- en: The RTM (see “[The Requirements/Reverse Traceability Matrix](ch09.xhtml#lev-9.2.3)”
    on [page 178](ch09.xhtml#page_178)) links the requirements against the design,
    test cases, and code. Using an RTM, a stakeholder can verify that a requirement
    is implemented in the design and the code, and that the test cases and procedures
    properly check that requirement’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some organizations might also have a* Functional Requirements Specification
    *document; this often refers to the requirements that an external customer provides,
    or it can simply be a synonym for the SRS or SyRS. This book won’t use this term
    further.*'
  prefs: []
  type: TYPE_NORMAL
- en: There are many additional types of documents, but these are the basic ones you’d
    expect for any (non-XP, at least) project, and they correspond to the various
    stages of the Waterfall model (see “[The Waterfall Model](ch03.xhtml#lev-3.2.2)”
    on [page 44](ch03.xhtml#page_44)), as shown in [Figure 9-1](ch09.xhtml#ch9fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: System documentation dependencies*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the SRS is constructed from the SyRS. The SDD is constructed
    from the SRS, as is the STC (which, in some cases, is also influenced by the SDD,
    as indicated by the gray arrow^([2](ch19_footnote.xhtml#ch09fn2))). The STP is
    constructed from the STC.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2 Traceability**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the greatest logistical issue with system documentation is consistency.
    A requirement typically generates some design item and a test case (which is part
    of a test procedure in the STP). This is an intuitive and natural progression
    when you’re following a strict Waterfall model—writing the SRS first, followed
    by the SDD, the STC, and the SDD. However, problems arise when you have to make
    corrections to documents earlier in this chain. For example, when you change a
    requirement, you might need to change entries in the SDD, STC, and STP documents.
    Best practice is therefore to use *traceability*, which allows you to easily trace
    items from one document to all the other system documents. If you can trace your
    requirements to design elements, test cases, and test procedures, you can rapidly
    locate and change those elements whenever you modify a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reverse traceability* allows you to trace a test procedure back to the corresponding
    test cases, and test cases and design items back to their corresponding requirements.
    For example, you might encounter problems with a test that require changes to
    the test procedure, in which case you can locate the corresponding test cases
    and requirements to ensure that your changes to the test procedure still handle
    all of them. In this way, reverse traceability also helps you determine whether
    you need to make changes to the test cases or requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.1 Ways to Build Traceability into Your Documentation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a couple of ways to accomplish traceability and reverse traceability.
    One approach is to build the traceability into an *identifier*, or *tag*, associated
    with the requirement, design element, test case, or test procedure documentation.
    This tag could be a paragraph (or item) number, a descriptive word, or some other
    set of symbols that uniquely identify the text to reference. Software documents
    that use tags avoid wasting space by directly quoting other documents.
  prefs: []
  type: TYPE_NORMAL
- en: Often authors use paragraph numbers as tags, which is really easy to do in a
    word processing system. However, many word processors don’t support cross-referencing
    across multiple document types. Also, the tagging mechanism or format you want
    to use might not match what the word processor provides.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s possible to write custom software, or use a database application
    to extract and maintain cross-reference information, the most common solution
    is to maintain tags manually. This might sound as though it would require considerable
    effort, but with a little planning, it isn’t very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the best solution is to create an RTM (see “[The Requirements/Reverse
    Traceability Matrix](ch09.xhtml#lev-9.2.3)” on [page 178](ch09.xhtml#page_178)),
    which tracks the links between the items in your system documentation. Although
    the RTM is yet another document you’ll have to maintain, it provides a complete
    and easy-to-use mechanism for tracking all the components in your system.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first talk through common tag formats, and then we’ll look into building
    an RTM.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.2 Tag Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is no particular standard for tag syntax; tags can take any form you like
    as long as the syntax is consistent and each tag is unique. For my own purposes
    (and for this book), I’ve created a syntax that incorporates elements of traceability
    directly into the tag. The tag formats that follow are organized by document type.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2.2.1 SyRS Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For the SyRS, a tag takes the form [*productID*_SYRS_*xxx*] where:'
  prefs: []
  type: TYPE_NORMAL
- en: '***productID*** Refers to the product or project. For example, for a swimming
    pool monitor application, *productID* might be “POOL.” You don’t want to use a
    long ID (four to five characters should be the maximum length) because it will
    be typed frequently.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SYRS** States that this is a tag from the SyRS document (this is probably
    a system requirements tag).'
  prefs: []
  type: TYPE_NORMAL
- en: '***xxx*** Represents one or more numbers, separated by periods if more than
    one integer is used. This numeric sequence uniquely identifies the tag within
    the SyRS.'
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, all the SyRS requirements (and other items requiring a tag)
    would be numbered sequentially from 1 with no correlation between the integers
    and the meanings of the text blocks to which they refer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following two requirements in an SyRS document:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_001]: Pool temperature monitoring**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall monitor the pool temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_002]: Maximum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say that 150 additional requirements follow [POOL_SYRS_002].
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose that someone suggests a requirement that the pool heater be turned
    on if the pool temperature drops below 70 degrees Fahrenheit. You could add the
    following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_153]: Minimum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_154]: Maximum heater on temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: In the SyRS, it makes sense to arrange related requirements close to one another,
    so the reader can locate all the pertinent requirements for a given feature at
    one point in the document. You can see why you wouldn’t want to sort the requirements
    by their tags—doing so would push the two new requirements for the pool heater
    to the end of the document, away from the other pool temperature requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s nothing stopping you from moving the requirements together; however,
    it’s somewhat confusing to see a set of requirements like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_001]: Pool temperature monitoring**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall monitor the pool temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_153]: Minimum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_154]: Maximum heater on temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_002]: Maximum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to renumber the tags using *dotted sequences* to expand
    the tag numbers. A dotted sequence consists of two or more integers separated
    by a dot. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_001]: Pool temperature monitoring**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall monitor the pool temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_001.1]: Minimum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_001.2]: Maximum heater on temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_002]: Maximum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to flow in new requirements or changes anywhere. Note that 001.1
    and 001.10 are not the same. These numbers are not floating-point numeric values;
    they’re two integers separated by a period. The number 001.10 is probably the
    10th value in the sequence 001.1 through 001.10\. Likewise, 001 is not the same
    as 001.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to insert a requirement between 001.1 and 001.2, you can simply
    add another period to the end of the sequence, such as 001.1.1\. You can also
    leave gaps between your tag numbers if you expect to insert additional tags in
    the future, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_010]: Pool temperature monitoring**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall monitor the pool temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_020]: Maximum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: 'So when you decide to add the other two requirements, you have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_010]: Pool temperature monitoring**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall monitor the pool temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_013]: Minimum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the pool heater if the pool temperature drops below
    70 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_017]: Maximum heater on temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn off the pool heater if the pool temperature exceeds 70
    degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: '**[POOL_SYRS_020]: Maximum pool temperature**'
  prefs: []
  type: TYPE_NORMAL
- en: The system shall turn on the “High Temp” LED if the pool temperature exceeds
    86 degrees Fahrenheit.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that it’s important to make all the tags unique.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Thus far in this section, tags have been part of a paragraph title, which
    is useful when people want to search for the tags within the document (particularly,
    if the document is not in electronic form). However, you can also place tags within
    paragraphs.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2.2.2 SRS Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For system document sets that have only the SRS—not an SyRS—as the requirements
    document, “SRS” can simply replace “SYRS” in the tag: [POOL_SRS_010]: Pool temperature
    monitoring.'
  prefs: []
  type: TYPE_NORMAL
- en: However, when a project’s document set includes both an SyRS and an SRS, this
    book uses a convention that builds reverse traceability from the SRS to the SyRS
    directly into the SRS tag. Such SRS tags have the format [*productID*_SRS_*xxx_yyy*].
  prefs: []
  type: TYPE_NORMAL
- en: 'The *productID* is the same as for the SyRS tag: SRS denotes a Software Requirements
    Specification tag (versus a System Requirements Specification tag), and *xxx*
    and *yyy* are decimal numbers, where *xxx* is the number of a corresponding SyRS
    tag (see “[SyRS Tags](#lev-9.2.2.1)” on [page 172](ch09.xhtml#page_172)).'
  prefs: []
  type: TYPE_NORMAL
- en: Including the tag number of the parent SyRS requirement embeds reverse traceability
    information for an SRS requirement directly into its tag. Because almost all SRS
    requirements are derived from a corresponding SyRS tag, and there is a one-to-many
    relationship between SyRS requirements and SRS requirements, a single SyRS requirement
    can generate one or more SRS requirements, but each SRS requirement can be traced
    back to just one SyRS requirement, as shown in [Figure 9-2](ch09.xhtml#ch9fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig9-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: An SyRS-to-SRS relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *yyy* component is the SRS tag value. As a general rule (and the convention
    this book follows), *yyy* doesn’t have to be unique among all the SRS tags, but
    the combination *xxx_yyy* must be unique. The following are all valid (and unique)
    SRS tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[POOL_SRS_020_001]'
  prefs: []
  type: TYPE_NORMAL
- en: '[POOL_SRS_020_001.5]'
  prefs: []
  type: TYPE_NORMAL
- en: '[POOL_SRS_020_002]'
  prefs: []
  type: TYPE_NORMAL
- en: '[POOL_SRS_030.1_005]'
  prefs: []
  type: TYPE_NORMAL
- en: '[POOL_SRS_031_003]'
  prefs: []
  type: TYPE_NORMAL
- en: This book also uses the convention of restarting the *yyy* numbering with each
    *xxx* value.
  prefs: []
  type: TYPE_NORMAL
- en: By constructing SRS tags this way, you build automatic reverse traceability
    from the SRS to the SyRS directly into the tag identifier. To locate the SyRS
    requirement associated with an SRS requirement, just extract the *xxx* value and
    search for the corresponding tag in your SyRS document. It’s also easy to locate
    SRS tags associated with an SyRS tag in the SRS document. For example, to find
    all SRS requirements associated with POOL_SYRS_030, search for all instances of
    “SRS_030” in your SRS document.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible that an SRS document might produce some brand-new requirements
    that are not based on a specific SyRS requirement. If so, there won’t be an *xxx*
    number to use as part of the SRS tag. This book reserves SyRS tag number 000 (that
    is, there will never be an SyRS tag [*productID*_SYRS_000]), and any new SRS requirement
    that isn’t based on an SyRS requirement will take the form [*productID*_SRS_000_*yyy*].
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Another convention this book uses is to substitute an asterisk (*) in place
    of the* 000 *value.*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to include all software-related requirements from the SyRS
    directly in the SRS.^([3](ch19_footnote.xhtml#ch09fn3)) This allows the SRS to
    serve as a stand-alone document for software developers to use. When copying SyRS
    requirements directly into the SRS, we’ll use the syntax [*productID*_SRS_*xxx*_000]
    for the copied requirement tags. That is, a *yyy* value of 000 denotes a copied
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2.2.3 SDD Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unfortunately, there is not a one-to-many relationship between SRS requirements
    and SDD design elements.^([4](ch19_footnote.xhtml#ch09fn4)) That makes it more
    difficult to build reverse traceability from an SDD tag to the corresponding SRS
    tag into the SDD tag syntax. You’ll have to rely on an external RTM document to
    provide the links between the SRS and SDD documents.
  prefs: []
  type: TYPE_NORMAL
- en: Given that reverse traceability is not practical in the SDD tag, this book uses
    the simplified SDD tag format [*productID*_SDD_*ddd*], where *productID* has the
    usual meaning, and *ddd* is a unique identifier similar to *xxx* in the SyRS tag.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2.2.4 STC Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There should be a one-to-many relationship between SRS requirements and STC
    test cases, as shown in [Figure 9-3](ch09.xhtml#ch9fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig9-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: An SRS-to-STC tag relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: This means you can build reverse traceability from the STC to the SRS into the
    tags, just as you did from the SRS to the SyRS. For STC tags, this book uses the
    syntax [*productID*_STC_*xxx_yyy_zzz*]. If all your *yyy* values were unique (rather
    than the *xxx_yyy* combination being unique), you could drop the *xxx* from the
    tag, but having both *xxx* and *yyy* does provide reverse traceability to both
    the SRS and SyRS, which can be convenient (at the expense of extra typing for
    your STC tags).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it rarely occurs, it’s possible to create a unique test case that
    isn’t based on any SRS requirement.^([5](ch19_footnote.xhtml#ch09fn5)) For example,
    the software engineers using the SDD to implement the code might create test cases
    based on the source code they write. In such situations, this book uses the scheme
    shown previously for SRS requirements that aren’t based on an SyRS requirement:
    we reserve the *xxx*_*yyy* value of 000_000 or *_*, and any new STC tags that
    aren’t based on a requirement tag will use 000 as the tag number suffix. An *xxx*_000
    component means that the test case is based on an SyRS requirement but not any
    underlying SRS requirement (or perhaps it’s based on the SRS tag copied from the
    SyRS using the syntax shown earlier); this is not a stand-alone test case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'STC tags that have the numeric form 000_000 don’t contain any traceability
    information. In such cases, you’ll need to explicitly provide link information
    to describe the origin of the test case. Here are a few suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *:source* after the tag to describe the source of the test case (where *source*
    is the name of the file or other document containing the information producing
    the test case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an RTM to provide the source information (see the next section, “The Requirements/Reverse
    Traceability Matrix,” for more details).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the document containing the source of the test case contains a comment
    or other link specifying the STC tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**9.2.2.5 STP Tags**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: STC test cases have a many-to-one relationship with STP test procedures, as
    shown in [Figure 9-4](ch09.xhtml#ch9fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig9-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: An STC-to-STP tag relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: This means, as with the SDD, you can’t encode reverse traceability information
    into the STP tags. Therefore, for STP tags this book uses the syntax [*productID*_STP_*ppp*],
    where *productID* has the usual meaning, and *ppp* is a unique STP tag value.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.2.3 The Requirements/Reverse Traceability Matrix***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned, it isn’t possible to build reverse traceability into the SDD and
    STP tags, so you’ll need the Requirements/Reverse Traceability Matrix (RTM).
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name implies, an RTM is a two-dimensional matrix, or table, wherein:'
  prefs: []
  type: TYPE_NORMAL
- en: Each row specifies a link between requirements, design items, test cases, or
    test procedures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each column specifies a particular document (SyRS, SRS, SDD, STC, or STP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each cell contains the tag for the associated document type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical row in the table might contain entries such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/page_178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In general, the SyRS or SRS requirement tags drive the RTM, and you’d usually
    organize the table by sorting it via these columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because there is a one-to-many relationship between SyRS requirements and SRS
    requirements, you might need to replicate the SyRS requirements across multiple
    rows, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/page_179_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rows 1, 2, and 3 share the same SyRS tag with different SRS tags; rows 3 and
    4 share the same SRS tags (and SyRS tags) with differing STC tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it might be cleaner to omit duplicate SyRS and SRS tags when they
    can be inferred from previous rows, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/page_179_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although you could create an RTM using a word processor (for example, Microsoft
    Word or Apple Pages), a far better solution is to use a spreadsheet program (for
    example, Microsoft Excel or Apple Numbers) or a database application, which allows
    you to easily sort the rows in the table based on your current requirements. This
    book assumes you’re using a spreadsheet program.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2.3.1 Adding Extra Columns**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At a bare minimum, you’ll want one column in the RTM for each system document
    type—SyRS (if present), SRS, SDD, STC, and STP—but you might want to include other
    information in the RTM as well. For example, you might consider a “Description”
    column that can help make sense of all the tags.
  prefs: []
  type: TYPE_NORMAL
- en: Or, if you have an SyRS document, an “Allocations” column might be useful to
    specify whether an SyRS item is hardware, software, or other. Note that SRS, SDD,
    STP, and STC (by definition) are always software related, so the Allocations entry
    would be either “N/A” (not applicable) or always “software” for such tags.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful column might be “Verification,” which describes how a particular
    requirement might be tested (or verified) in the system. Examples of verification
    types might be test (as part of a software test procedure), by review, by inspection,
    by design, by analysis, other, or no test possible.
  prefs: []
  type: TYPE_NORMAL
- en: One last option is an additional column (or columns) containing some row numbers
    you can use to quickly sort data in different ways. For example, you might add
    a column numbered 1 through *n* (where *n* is the number of rows) that, when sorted,
    lists the rows in order of requirements (SyRS and SRS); another column numbered
    1 through *n* that could order the rows by SDD tag values; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2.3.2 Sorting the RTM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Of course, if you fill in every cell in the matrix, you can sort by column
    values (or multiple column values). For example, suppose you’re using Microsoft
    Excel and the columns are organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Description'
  prefs: []
  type: TYPE_NORMAL
- en: 'B: SyRS tags'
  prefs: []
  type: TYPE_NORMAL
- en: 'C: Allocations'
  prefs: []
  type: TYPE_NORMAL
- en: 'D: SRS tags'
  prefs: []
  type: TYPE_NORMAL
- en: 'E: Testing method'
  prefs: []
  type: TYPE_NORMAL
- en: 'F: SDD tags'
  prefs: []
  type: TYPE_NORMAL
- en: 'G: STC tags'
  prefs: []
  type: TYPE_NORMAL
- en: 'H: STP tags'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by column B, then by D, then by G, will sort the document in requirements
    order. Sorting by column F, then by B, then by D, will sort the document in design
    element order. Sorting by column H, then by D, then by G, will sort the document
    in test procedure order.
  prefs: []
  type: TYPE_NORMAL
- en: To use the RTM to trace from an SyRS or SRS requirement to an SRS requirement,
    SDD design item, STC test case, or STP test procedure, simply sort the matrix
    by requirements order, find the SyRS or SRS tag you’re interested in, and then
    pick out the corresponding tag(s) for the other document(s) from the same row
    as the requirement tag. You can use this same scheme to trace from STC tags to
    the corresponding test procedure (because the requirements sort will also sort
    the test case tags).
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverse traceability from STC to SRS to SyRS is inherent in the tag syntax,
    so nothing special is needed for this operation. Reverse traceability from the
    SDD to the SRS (or SyRS) and from the STP to the STC/SRS/SyRS is a little more
    involved. First, sort the matrix by SDD tag order or STP tag order. This will
    give you a list of SDD or STP tags all collected together (and sorted in lexicographical
    order). Now all the tags on the rows containing a particular SDD or STP tag will
    be the tags of interest to you. The following example shows the previous RTM examples
    sorted by test procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/page_180.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this table, you can easily see that test procedure 005 is associated with
    SyRS tag 020 and SRS tags 020_001 and 020_002\. In this simple example, you wouldn’t
    have to sort the data to determine these links. But with a more complex RTM (with
    dozens, hundreds, or even thousands of requirements), it would be significantly
    more work to manually search for these reverse links if the table wasn’t sorted
    by STP tags.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.3 Validation, Verification, and Reviews**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Validation (see “[The Iterative Model](ch03.xhtml#lev-3.2.4)” on [page 46](ch03.xhtml#page_46))
    is the process of showing that the product meets the end users’ needs (that is,
    “Are we building the right product?”), while verification is ensuring that you’ve
    built it to satisfy the project specifications (that is, “Are we building the
    product right?”). While validation takes place at the end of the requirements
    phase(s) and at the end of the entire development cycle (see “[Reducing Costs
    via Validation](ch09.xhtml#lev-9.4.1)” on [page 182](ch09.xhtml#page_182)), verification
    typically occurs at the end of each phase in the software development process
    to ensure that the phase respects all the input requirements. For example, verification
    of the SDD would consist of ensuring that it covers all the requirements in the
    SRS document (the SRS requirements are the input to the SDD stage).
  prefs: []
  type: TYPE_NORMAL
- en: 'The verification steps for each phase are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SyRS/SRS** Ensuring that the requirements in the document fully cover all
    the requirements provided by the customer—perhaps from UML use cases (see “[The
    UML Use Case Model](ch04.xhtml#lev-4.2)” on [page 74](ch04.xhtml#page_74)) or
    the customer’s functional specification.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SDD** Ensuring that the design covers all requirements. The input is the
    requirements from the SRS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**STC** Ensuring that at least one test case exists for each (testable) requirement.
    The inputs are the requirements from the SRS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**STP** Ensuring that all the test cases are covered by the test procedures.
    The inputs are the test cases from the STC (and, indirectly, the requirements
    on which the test cases are based).'
  prefs: []
  type: TYPE_NORMAL
- en: To verify each preceding phase, you’ll need to review the document resulting
    from it. The RTM will prove useful during these reviews. For example, when reviewing
    the SDD, you’d search for each requirement in the SRS, look up the corresponding
    SDD tag, and then verify that the design element implements the specified requirement.
    You’d use the same process to verify that the STC document covers all the requirements
    with test cases.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re reviewing the code, the safest approach is to go through all the
    inputs to a phase (that is, requirements for the SDD and STC, and test cases for
    the STP) and physically check each input off after verifying that you properly
    handled it. This final list becomes part of the review document for that phase.
  prefs: []
  type: TYPE_NORMAL
- en: In the review process, you should also confirm the correctness of the outputs
    from the phase. For example, when reviewing the SRS, you should check each requirement
    to make sure it’s useful (see “[The Software Requirements Specification Document](ch10.xhtml#lev-10.4)”
    on [page 194](ch10.xhtml#page_194)); when reviewing the SDD, you should make sure
    each design item is correct (for example, you’re using suitable algorithms and
    handling concurrent operations appropriately); when reviewing the STC documentation,
    you should ensure each test case properly tests the associated requirement; and
    when reviewing the STP, you should verify that each test procedure properly tests
    its associated test cases.
  prefs: []
  type: TYPE_NORMAL
- en: If at all possible, and for the best results, an engineer other than the document
    author should conduct the final, formal review, or a second engineer should participate
    in the review process. The document author is more likely to gloss over an omission,
    because they’re too close to that portion of the project and could mentally fill
    in missing elements during the review. Of course, they should do their own review
    of the document prior to submitting it for formal review.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.4 Reducing Development Costs Using Documentation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation costs are often a major component of a project’s overall cost.
    Part of the reason is that there is so *much* documentation. But another reason
    is that the documents are interdependent, which makes them difficult to update
    and maintain. In *Code Complete* (Microsoft Press, 2004), Steve McConnell reports
    that, compared to the requirements phase, correcting errors is 3 times more expensive
    during the design (architectural) phase, 5 to 10 times more expensive during coding,
    and 10 times more expensive during system testing. There a couple of reasons for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: If you fix a defect early in the development process, you don’t waste time writing
    additional documentation, coding, and testing defective designs. For example,
    it takes time to write the SDD documentation for a requirement, to write code
    to implement that requirement, to write test cases and test procedures for the
    requirement, and to run those tests. If the requirement was wrong to begin with,
    you’ve wasted all that effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you discover a defective item in one phase of the system, you have to locate
    and edit anything associated with that defect throughout the rest of the system.
    This can be laborious work, and it’s easy to miss changes, which creates inconsistencies
    and other problems down the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***9.4.1 Reducing Costs via Validation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Nowhere is the validation activity more important than in the requirements phase
    (SyRS and SRS development). If you insist that the customer understands and approves
    all requirements before moving on to later phases, you can ensure there are no
    unwanted requirements and that you’re solving the customer’s problems. Few things
    are worse than spending several months documenting, coding, and testing a program’s
    feature only to have the customer say, “This isn’t what we were asking for.” A
    good validation process can help reduce the likelihood of this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation, which should take place at the end of the requirements phase(s)
    and at the end of the development cycle, involves asking the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SyRS (if present)**'
  prefs: []
  type: TYPE_NORMAL
- en: Is each existing requirement important? Does the requirement describe some feature
    that the customer wants?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is each requirement correct? Does it precisely state (without ambiguity) exactly
    what the customer wants?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any missing requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SRS**'
  prefs: []
  type: TYPE_NORMAL
- en: Are all software requirements listed in the SyRS (if present) also listed in
    the SRS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is each existing requirement important? Is this feature important to the system
    architect and agreed upon by the customer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is each requirement correct? Does it precisely state (without ambiguity) exactly
    what the software must do to be effective?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there any missing requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During final acceptance testing, the test engineer(s) should have a list of
    all the requirements in the SRS in a checkbox form. They should check off each
    requirement as it’s tested (perhaps when following the test procedures in the
    STP) to ensure that the software implements it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '***9.4.2 Reducing Costs via Verification***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned in “Validation, Verification, and Reviews” on [page 181](ch09.xhtml#page_181),
    verification should occur after each phase of the software development process.
    In particular, there should be a verification step associated with each of the
    system documents after the SRS. Here are some questions you might ask after completing
    each document:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SDD**'
  prefs: []
  type: TYPE_NORMAL
- en: Do the design components completely cover all the requirements in the SRS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there a many-to-one (or one-to-one) relationship between requirements (many)
    and software design elements (one)? Although a design item might satisfy multiple
    requirements, it should not take multiple design elements to satisfy a single
    requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does a software design element provide an accurate design that will implement
    the given requirement(s)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**STC**'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a one-to-many (or one-to-one) relationship between requirements and
    test cases? (That is, a requirement can have multiple associated test cases, but
    you shouldn’t have multiple requirements sharing the same test case.^([6](ch19_footnote.xhtml#ch09fn6)))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does a particular test case accurately test the associated requirement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do all the test cases associated with a requirement completely test the correct
    implementation of that requirement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**STP**'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a many-to-one relationship between test cases in the STC and test procedures
    in the STP? That is, does a test procedure implement one or more test cases while
    each test case is handled by exactly one test procedure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does a given test procedure accurately implement all its associated test cases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**9.5 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'IEEE. “IEEE Standard 830-1998: IEEE Recommended Practice for Software Requirements
    Specifications.” October 20, 1998\. *[https://doi.org/10.1109/IEEESTD.1998.88286](https://doi.org/10.1109/IEEESTD.1998.88286)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leffingwell, Dean, and Don Widrig. *Managing Software Requirements*. Boston:
    Addison-Wesley Professional, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'McConnell, Steve. *Code Complete*. 2nd ed. Redmond, WA: Microsoft Press, 2004.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wiegers, Karl E. *Software Requirements*. Redmond, WA: Microsoft Press, 2009.'
  prefs: []
  type: TYPE_NORMAL
- en: '———. “Writing Quality Requirements.” *Software Development* 7, no. 5 (May 1999):
    44–48.'
  prefs: []
  type: TYPE_NORMAL
