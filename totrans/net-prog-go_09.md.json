["```\nerr := os.Chown(\"/path/to/socket/file\", 1-1, 2100)\n```", "```\ngrp, err := user.LookupGroup(\"users\")\n```", "```\nerr := os.Chmod(\"/path/to/socket/file\", os.ModeSocket|0660)\n```", "```\npackage echo\n\nimport (\n    \"context\"\n    \"net\"\n)\n\nfunc 1streamingEchoServer(ctx context.Context, network string,\n addr string) (net.Addr, error) {\n    s, err := 2net.Listen(network, addr)\n    if err != nil {\n        return nil, err\n    }\n```", "```\n`--snip--`\n\n    go func() {\n        go func() {\n          1<-ctx.Done()\n            _ = s.Close()\n        }()\n\n        for {\n            conn, err := 2s.Accept()\n            if err != nil {\n                return\n            }\n\n            go func() {\n                defer func() { _ = conn.Close() }()\n\n                for {\n                    buf := make([]byte, 1024)\n                    n, err := 3conn.Read(buf)\n                    if err != nil {\n                        return\n                    }\n\n                    _, err = 4conn.Write(buf[:n])\n                    if err != nil {\n                        return\n                    }\n                }\n            }()\n }\n    }()\n\n    return s.Addr(), nil\n}\n```", "```\npackage echo\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net\"\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n)\n\nfunc TestEchoServerUnix(t *testing.T) {\n    dir, err := 1ioutil.TempDir(\"\", \"echo_unix\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer func() {\n        if rErr := 2os.RemoveAll(dir); rErr != nil {\n            t.Error(rErr)\n        }\n    }()\n\n    ctx, cancel := context.WithCancel(context.Background())\n    3 socket := filepath.Join(dir, fmt.Sprintf(\"%d.sock\", os.Getpid()))\n    rAddr, err := streamingEchoServer(ctx, \"unix\", socket)\n    if err != nil {\n t.Fatal(err)\n    }\n\n    err = 4os.Chmod(socket, os.ModeSocket|0666)\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```\n`--snip--`\n\n    conn, err := net.Dial(\"unix\", 1rAddr.String())\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer func() { _ = conn.Close() }()\n\n    msg := []byte(\"ping\")\n    2 for i := 0; i < 3; i++ { // write 3 \"ping\" messages\n        _, err = conn.Write(msg)\n        if err != nil {\n            t.Fatal(err)\n        }\n    }\n\n    buf := make([]byte, 1024)\n    n, err := 3conn.Read(buf) // read once from the server\n    if err != nil {\n        t.Fatal(err)\n    }\n\n    expected := 4bytes.Repeat(msg, 3)\n    if !bytes.Equal(expected, buf[:n]) {\n        t.Fatalf(\"expected reply %q; actual reply %q\", expected,\n            buf[:n])\n    }\n\n    _ = closer.Close()\n    <-done\n}\n```", "```\n`--snip--`\n\nfunc datagramEchoServer(ctx context.Context, network string,\n    addr string) (net.Addr, error) {\n    s, err := 1net.ListenPacket(network, addr)\n    if err != nil {\n        return nil, err\n    }\n\n    go func() {\n        go func() {\n            <-ctx.Done()\n            _ = s.Close()\n            if network == \"unixgram\" {\n                _ = 2os.Remove(addr)\n            }\n        }()\n\n        buf := make([]byte, 1024)\n        for {\n            n, clientAddr, err := s.ReadFrom(buf)\n            if err != nil {\n                return\n            }\n\n            _, err = s.WriteTo(buf[:n], clientAddr)\n            if err != nil {\n                return\n }\n        }\n    }()\n\n    return s.LocalAddr(), nil\n}\n```", "```\n// +build darwin linux\n\npackage echo\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net\"\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n)\n```", "```\n`--snip--`\n\nfunc TestEchoServerUnixDatagram(t *testing.T) {\n    dir, err := ioutil.TempDir(\"\", \"echo_unixgram\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer func() {\n        if rErr := os.RemoveAll(dir); rErr != nil {\n            t.Error(rErr)\n }\n    }()\n\n    ctx, cancel := context.WithCancel(context.Background())\n    1 sSocket := filepath.Join(dir, fmt.Sprintf(\"s%d.sock\", os.Getpid()))\n    serverAddr, err := datagramEchoServer(ctx, \"unixgram\", sSocket)\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer cancel()\n\n    err = os.Chmod(sSocket, os.ModeSocket|0622)\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```\n`--snip--`\n\n    1 cSocket := filepath.Join(dir, fmt.Sprintf(\"c%d.sock\", os.Getpid()))\n    client, err := net.ListenPacket(\"unixgram\", cSocket)\n    if err != nil {\n        t.Fatal(err)\n    }\n    2 defer func() { _ = client.Close() }()\n\n    err = 3os.Chmod(cSocket, os.ModeSocket|0622)\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```\n`--snip--`\n\n    msg := []byte(\"ping\")\n    for i := 0; i < 3; i++ { // write 3 \"ping\" messages\n        _, err = 1client.WriteTo(msg, serverAddr)\n        if err != nil {\n            t.Fatal(err)\n        }\n    }\n\n    buf := make([]byte, 1024)\n    for i := 0; i < 3; i++ { // read 3 \"ping\" messages\n        n, addr, err := 2client.ReadFrom(buf)\n        if err != nil {\n            t.Fatal(err)\n        }\n\n        if addr.String() != serverAddr.String() {\n            t.Fatalf(\"received reply from %q instead of %q\", \n                addr, serverAddr)\n        }\n\n        if !bytes.Equal(msg, buf[:n]) {\n            t.Fatalf(\"expected reply %q; actual reply %q\", msg,\n                buf[:n])\n        }\n    }\n}\n```", "```\npackage echo\n\nimport (\n    \"bytes\"\n    \"context\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net\"\n    \"os\"\n    \"path/filepath\"\n    \"testing\"\n)\n\nfunc TestEchoServerUnixPacket(t *testing.T) {\n    dir, err := ioutil.TempDir(\"\", \"echo_unixpacket\")\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer func() {\n        if rErr := os.RemoveAll(dir); rErr != nil {\n            t.Error(rErr)\n        }\n    }()\n\n    ctx, cancel := context.WithCancel(context.Background())\n    socket := filepath.Join(dir, fmt.Sprintf(\"%d.sock\", os.Getpid()))\n    rAddr, err := streamingEchoServer(ctx, \"unixpacket\", socket)\n    if err != nil {\n        t.Fatal(err)\n    }\n    defer cancel()\n\n    err = os.Chmod(socket, os.ModeSocket|0666)\n    if err != nil {\n        t.Fatal(err)\n    }\n```", "```\n`--snip--`\n\n    conn, err := 1net.Dial(\"unixpacket\", rAddr.String())\n    if err != nil {\n t.Fatal(err)\n    }\n    defer func() { _ = conn.Close() }()\n\n    msg := []byte(\"ping\")\n    2 for i := 0; i < 3; i++ { // write 3 \"ping\" messages\n        _, err = conn.Write(msg)\n        if err != nil {\n            t.Fatal(err)\n        }\n    }\n\n    buf := make([]byte, 1024)\n    3 for i := 0; i < 3; i++ { // read 3 times from the server\n        n, err := conn.Read(buf)\n        if err != nil {\n            t.Fatal(err)\n        }\n\n        if !bytes.Equal(msg, buf[:n]) {\n            t.Errorf(\"expected reply %q; actual reply %q\", msg, buf[:n])\n        }\n    }\n```", "```\n`--snip--`\n\n    for i := 0; i < 3; i++ { // write 3 more \"ping\" messages\n        _, err = conn.Write(msg)\n        if err != nil {\n            t.Fatal(err)\n        }\n    }\n\n    1 buf = make([]byte, 2)    // only read the first 2 bytes of each reply\n    for i := 0; i < 3; i++ { // read 3 times from the server\n        n, err := conn.Read(buf)\n        if err != nil {\n            t.Fatal(err)\n        }\n\n        if !bytes.Equal(2msg[:2], buf[:n]) {\n t.Errorf(\"expected reply %q; actual reply %q\", msg[:2],\n                buf[:n])\n        }\n    }\n}\n```", "```\ngo get -u golang.org/x/sys/unix\n```", "```\npackage auth\n\nimport (\n    \"log\"\n    \"net\"\n    \"golang.org/x/sys/unix\"\n)\n\nfunc Allowed(conn *net.UnixConn, groups map[string]struct{}) bool {\n    if conn == nil || groups == nil || len(groups) == 0 {\n        return false\n    }\n\n    file, _ := 1conn.File()\n    defer func(){ _ = file.Close() }()\n\n    var (\n        err   error\n        ucred *unix.Ucred\n    )\n\n    for {\n        ucred, err = 2unix.GetsockoptUcred(int(3file.Fd()), unix.SOL_SOCKET,\n            unix.SO_PEERCRED)\n        if err == unix.EINTR {\n            continue // syscall interrupted, try again\n        }\n        if err != nil {\n            log.Println(err)\n            return false\n        }\n\n        break\n    }\n\n    u, err := 4user.LookupId(string(ucred.Uid))\n    if err != nil {\n        log.Println(err)\n        return false\n    }\n\n    gids, err := 5u.GroupIds()\n    if err != nil {\n        log.Println(err)\n        return false\n    }\n\n    for _, gid := range gids {\n        if _, ok := 6groups[gid]; ok {\n return true\n        }\n    }\n\n    return false\n}\n```", "```\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"log\"\n    \"net\"\n    \"os\"\n    \"os/signal\"\n    \"os/user\"\n    \"path/filepath\"\n\n    \"github.com/awoodbeck/gnp/ch07/creds/auth\"\n)\n\nfunc init() {\n    flag.Usage = func() {\n        _, _ = fmt.Fprintf(flag.CommandLine.Output(),\n            \"Usage:\\n\\t%s 1<group names>\\n\", filepath.Base(os.Args[0]))\n        flag.PrintDefaults()\n    }\n}\n```", "```\n`--snip--`\n\nfunc parseGroupNames(args []string) map[string]struct{} {\n    groups := make(map[string]struct{})\n\n    for _, arg := range args {\n        grp, err := 1user.LookupGroup(arg)\n        if err != nil {\n            log.Println(err)\n            continue\n        }\n\n        groups[2grp.Gid] = struct{}{}\n    }\n\n    return groups\n}\n```", "```\n`--snip--`\n\nfunc main() {\n    flag.Parse()\n\n    groups := parseGroupNames(flag.Args())\n    socket := filepath.Join(os.TempDir(), \"creds.sock\")\n    addr, err := net.ResolveUnixAddr(\"unix\", socket)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    s, err := net.ListenUnix(\"unix\", addr)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    c := make(chan os.Signal, 1)\n    signal.Notify(c, 1os.Interrupt)\n    2 go func() {\n        <-c\n        _ = s.Close()\n    }()\n\n    fmt.Printf(\"Listening on %s ...\\n\", socket)\n\n    for {\n        conn, err := 3s.AcceptUnix()\n        if err != nil {\n            break\n        }\n        if 4auth.Allowed(conn, groups) {\n            _, err = conn.Write([]byte(\"Welcome\\n\"))\n            if err == nil {\n                // handle the connection in a goroutine here\n                continue\n            }\n        } else {\n            _, err = conn.Write([]byte(\"Access denied\\n\"))\n        }\n        if err != nil {\n            log.Println(err)\n        }\n        _ = conn.Close()\n    }\n}\n```", "```\n$ **sudo apt install netcat-openbsd**\n```", "```\n$ **sudo dnf install nmap-ncat**\n```", "```\n$ **cd $GOPATH/src/github.com/awoodbeck/gnp/ch07/creds**\n$ **go run . -- users staff**\nListening on /tmp/creds.sock …\n```", "```\n$ **sudo -g staff -- nc -U /tmp/creds.sock**\nWelcome\n**^C**\n$\n```", "```\n$ **sudo -g nogroup -- nc -U /tmp/creds.sock**\nAccess denied\n$\n```"]