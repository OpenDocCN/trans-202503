["```\n\n\t\t\tif( SomeBooleanExpression ) then begin\n\n    << Some code that executes 99.9% of the time >>\n\nend\nelse begin\n\n    << Some code that executes 0.01% of the time >>\n\nend;\n```", "```\n\n\t\t\t    << evaluate Boolean expression, leave true/false in EAX >>\n    test( eax, eax );\n    jz exprWasFalse;\n    << Some code that executes 99.9% of the time >>\nrtnLabel:\n    << Code normally following the last END in the\n               Pascal example >>\n        .\n        .\n        .\n// somewhere else in the code, not in the direct execution path\n// of the above:\n\nexprWasFalse:\n    << Some code that executes 0.1% of the time >>\n\n    jmp rtnLabel;\n```", "```\n\n\t\t\t    << evaluate Boolean expression, leave true/false in EAX >>\n    test eax, eax\n    jz exprWasFalse\n    << Some code that executes 99.9% of the time >>\nalternateCode segment\n\nexprWasFalse:\n    << Some code that executes 0.1% of the time >>\n\n    jmp rtnLabel;\nalternateCode ends\n\nrtnLabel:\n    << Code normally following the last END in the Pascal example >>\n```", "```\n\n\t\t\tstatic int i = 10;\nstatic char ch[] = { 'a', 'b', 'c', 'd' };\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *c = \"\";\nstatic int i = 2;\nstatic int j = 1;\nstatic double array[4] = {0.0, 1.0, 2.0, 3.0};\n\nint main( void )\n{\n\n      .\n      .\n      .\n```", "```\n\n\t\t\t_DATA   SEGMENT\n?c@@3PEADEA   DQ  FLAT:$SG6912                 ; c\n?i@@3HA       DD  02H                          ; i\n?j@@3HA       DD  01H                          ; j\n?array@@3PANA DQ  00000000000000000r      ; 0  ; array\n              DQ  03ff0000000000000r      ; 1\n              DQ  04000000000000000r      ; 2\n              DQ  04008000000000000r      ; 3\n_DATA   ENDS\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\n\nstatic char *c;\nstatic int i;\nstatic int j;\nstatic double array[4];\n\nint main( void )\n{\n      .\n      .\n      .\n```", "```\n\n\t\t\t_BSS    SEGMENT\n?c@@3PEADEA   DQ  01H DUP (?)                             ; c\n?i@@3HA       DD  01H DUP (?)                             ; i\n?j@@3HA       DD  01H DUP (?)                             ; j\n?array@@3PANA DQ  04H DUP (?)                             ; array\n_BSS    ENDS\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic int i = 5;\nstatic int j = 6;\n\nint main( int argc, char **argv)\n{\n\n    i = j + 3;\n    j = i + 2;\n    printf( \"%d %d\\n\", i, j );\n    return 0;\n}\n\n; The following are the memory declarations\n; for the 'i' and 'j' variables. Note that\n; these are declared in the global '_DATA'\n; section.\n\n_DATA   SEGMENT\ni       DD      05H\nj       DD      06H\n$SG6835 DB      '%d %d', 0aH, 00H\n_DATA   ENDS\nmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 8\n;\n;    int main( int argc, char **argv)\n;    {\n$LN3:\n        mov     QWORD PTR [rsp+16], rdx\n        mov     DWORD PTR [rsp+8], ecx\n        sub     rsp, 40                                 ; 00000028H\n; Line 10\n;\n;            i = j + 3;\n;\n; Load the EAX register with the\n; current value of the global j\n; variable using the displacement-only\n; addressing mode, add three to the\n; value, and store back into 'i':\n\n        mov     eax, DWORD PTR j\n        add     eax, 3\n        mov     DWORD PTR i, eax\n\n; Line 11\n;\n;            j = i + 2;\n;\n        mov     eax, DWORD PTR i\n        add     eax, 2\n        mov     DWORD PTR j, eax\n\n; Line 12\n; Load i, j, and format string into appropriate registers\n; and call printf:\n\n        mov     r8d, DWORD PTR j\n        mov     edx, DWORD PTR i\n        lea     rcx, OFFSET FLAT:$SG6835\n        call    printf\n; Line 13\n;\n; RETURN 0\n\n        xor     eax, eax\n; Line 14\n        add     rsp, 40                                 ; 00000028H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n```", "```\n\n\t\t\t#include <stdio.h>\n\nint main( int argc, char **argv)\n{\n\n    int i;\n    int j;\n\n    j = 1;\n    i = j + 3;\n    j = i + 2;\n    printf( \"%d %d\\n\", i, j );\n    return 0;\n}\n\n; Data emitted for the string constant\n; in the printf function call:\n\nCONST   SEGMENT\n$SG6917 DB      '%d %d', 0aH, 00H\nCONST   ENDS\n\nPUBLIC  _main\nEXTRN   _printf:NEAR\n; Function compile flags: /Ods\n\n_TEXT   SEGMENT\nj$ = 32\ni$ = 36\nargc$ = 64\nargv$ = 72\nmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 5\n$LN3:\n        mov     QWORD PTR [rsp+16], rdx\n        mov     DWORD PTR [rsp+8], ecx\n        sub     rsp, 56                                 ; 00000038H\n; Line 10\n        mov     DWORD PTR j$[rsp], 1\n; Line 11\n        mov     eax, DWORD PTR j$[rsp]\n        add     eax, 3\n        mov     DWORD PTR i$[rsp], eax\n; Line 12\n        mov     eax, DWORD PTR i$[rsp]\n        add     eax, 2\n        mov     DWORD PTR j$[rsp], eax\n; Line 13\n        mov     r8d, DWORD PTR j$[rsp]\n        mov     edx, DWORD PTR i$[rsp]\n        lea     rcx, OFFSET FLAT:$SG6917\n        call    printf\n; Line 14\n        xor     eax, eax\n; Line 15\n        add     rsp, 56                                 ; 00000038H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\n\nint main( int argc, char **argv)\n{\n\n    int *i;\n    int *j;\n\n    i = (int *) malloc( sizeof( int ) );\n    j = (int *) malloc( sizeof( int ) );\n    *i = 1;\n    *j = 2;\n    printf( \"%d %d\\n\", *i, *j );\n    free( i );\n    free( j );\n    return 0;\n}\n```", "```\n\n\t\t\t_DATA   SEGMENT\n$SG6837 DB      '%d %d', 0aH, 00H\n_DATA   ENDS\nPUBLIC  _main\n_TEXT   SEGMENT\ni$ = 32\nj$ = 40\nargc$ = 64\nargv$ = 72\nmain    PROC\n; File c:\\users\\rhyde\\test\\t\\t\\t.cpp\n; Line 7 // Construct the activation record\n$LN3:\n\n        mov     QWORD PTR [rsp+16], rdx\n        mov     DWORD PTR [rsp+8], ecx\n        sub     rsp, 56                                 ; 00000038H\n\n; Line 13\n; Call malloc and store the returned\n; pointer value into the i variable:\n\n        mov     ecx, 4\n        call    malloc\n        mov     QWORD PTR i$[rsp], rax\n\n; Line 14\n; Call malloc and store the returned\n; pointer value into the j variable:\n\n        mov     ecx, 4\n        call    malloc\n        mov     QWORD PTR j$[rsp], rax\n\n; Line 15\n; Store 1 into the dynamic variable pointed\n; at by i. Note that this requires two\n; instructions.\n\n        mov     rax, QWORD PTR i$[rsp]\n        mov     DWORD PTR [rax], 1\n\n; Line 16\n; Store 2 into the dynamic variable pointed\n; at by j. This also requires two instructions.\n\n        mov     rax, QWORD PTR j$[rsp]\n        mov     DWORD PTR [rax], 2\n\n; Line 17\n; Call printf to print the dynamic variables'\n; values:\n\n        mov     rax, QWORD PTR j$[rsp]\n        mov     r8d, DWORD PTR [rax]\n        mov     rax, QWORD PTR i$[rsp]\n        mov     edx, DWORD PTR [rax]\n        lea     rcx, OFFSET FLAT:$SG6837\n        call    printf\n\n; Line 18\n; Free the two variables\n;\n        mov     rcx, QWORD PTR i$[rsp]\n        call    free\n; Line 19\n        mov     rcx, QWORD PTR j$[rsp]\n        call    free\n\n; Line 20\n; Return a function result of zero:\n        xor     eax, eax\n; Line 21\n        add     rsp, 56                                 ; 00000038H\n        ret     0\nmain    ENDP\n_TEXT   ENDS\nEND\n```", "```\nx = y + z - t;\n```", "```\n\n\t\t\t#include <stdio.h>\n\nstatic char c;\nstatic short s;\nstatic long l;\n\nstatic long a;\nstatic long b;\nstatic long d;\n\nint main( int argc, char **argv)\n{\n\n    l = l + s + c;\n    printf( \"%ld %hd %hhd\\n\", l, s, c );\n\n    a = a + b + d;\n    printf( \"%ld %ld %ld\\n\", a, b, d );\n\n    return 0;\n}\n```", "```\n\n\t\t\t;            l = l + s + c;\n;\n        movsx   eax, WORD PTR s\n        mov     ecx, DWORD PTR l\n        add     ecx, eax\n        mov     eax, ecx\n        movsx   ecx, BYTE PTR c\n        add     eax, ecx\n        mov     DWORD PTR l, eax\n;\n;            a = a + b + d;\n;\n        mov     eax, DWORD PTR b\n        mov     ecx, DWORD PTR a\n        add     ecx, eax\n        mov     eax, ecx\n        add     eax, DWORD PTR d\n        mov     DWORD PTR a, eax\n```", "```\n\n\t\t\tfunction trivial( i:integer; j:integer ):integer;\nvar\n    k:integer;\nbegin\n\n    k := i + j;\n    trivial := k;\n\nend;\n```", "```\n\n\t\t\tprocedure ARDemo( i:uns32; j:int32; k:dword ); @nodisplay;\nvar\n    a:int32;\n    r:real32;\n    c:char;\n    b:boolean;\n    w:word;\nbegin ARDemo;\n    .\n    .\n    .\nend ARDemo;\n```", "```\nint BigLocals( int i, int j )\n{\n    int array[256];\n    int k;\n        .\n        .\n        .\n}\n```", "```\n\n\t\t\tint BigLocals( int i, int j );\n{\n    int k;\n    int array[256];\n        .\n        .\n        .\n}\n```", "```\n\n\t\t\timport Cocoa\nimport Foundation\n\nvar globalVariable = 2\n\nfunc procOne()\n{\n    var intermediateVariable = 2;\n\n    func procTwo()\n    {\n        let localVariable =\n            intermediateVariable + globalVariable\n        print( localVariable )\n    }\n    procTwo()\n}\n\nprocOne()\n```", "```\n\n\t\t\tint *pi;\n    .\n    .\n    .\ni = *pi;    // Assume pi is initialized with a\n            // reasonable address at this point.\n```", "```\n\n\t\t\tpi: pointer to int32;\n    .\n    .\n    .\nmov( pi, ebx );     // Again, assume pi has\nmov( [ebx], eax );  // been properly initialized\nmov( eax, i );\n```", "```\n\n\t\t\tint *pi;\n    .\n    .   // Assume code in this area\n    .   // initializes pi appropriately.\n    .\n*pi = i;\n*pi = *pi + 2;\n*pi = *pi + *pi;\nprintf( \"pi = %d\\n\", *pi );\n```", "```\n\n\t\t\tpi: pointer to int32;\n    .\n    . // Assume code in this area\n    . // initializes pi appropriately.\n    .\n// Extra instruction that we need to initialize EBX\n\nmov( pi, ebx );\n\nmov( i, eax );\nmov( eax, [ebx] );  //  This code can clearly be optimized,\nmov( [ebx], eax );  //  but we'll ignore that fact for the\nadd( 2, eax );      //  sake of the discussion here.\nmov( eax, [ebx] );\nmov( [ebx], eax );\nadd( [ebx], eax );\nmov( eax [ebx] );\nstdout.put( \"pi = \", (type int32 [ebx]), nl );\n```", "```\nmov([ebx],eax);\n```", "```\n\n\t\t\ttypedef struct\n{\n    int i;\n    int j;\n    char *s;\n    char name[20];\n    short t;\n} vars;\n\nstatic vars v;\nvars *pv = &v;  // Initialize pv with the address of v.\n        .\n        .\n        .\n    pv->i = 0;\n    pv->j = 5;\n    pv->s = pv->name;\n    pv->t = 0;\n    strcpy( pv->name, \"Write Great Code!\" );\n        .\n        .\n        .\n```", "```\n\n\t\t\tint someFunction( void )\n{\n    int d1;   // Assume ints are 32-bit objects\n    int d2;\n    int d3;\n    short w1; // Assume shorts are 16-bit objects\n    short w2;\n    char b1;  // Assume chars are 8-bit objects\n    char b2;\n    char b3;\n        .\n        .\n        .\n} // end someFunction\n```", "```\n\n\t\t\tint someFunction2( void )\n{\n    char  b1; // Assume chars are 8-bit objects\n    int   d1; // Assume ints are 32-bit objects\n    short w1; // Assume shorts are 16-bit objects\n    int   d2;\n    short w2;\n    char  b2;\n    int   d3;\n    char  b3;\n        .\n        .\n        .\n} // end someFunction2\n```", "```\n\n\t\t\tprocedure someFunction; @nodisplay; @noalignstack;\nvar\n    d1  :dword;\n    d2  :dword;\n    d3  :dword;\n    w1  :word;\n    w2  :word;\n    b1  :byte;\n    b2  :byte;\n    b3  :byte;\nbegin someFunction;\n        .\n        .\n        .\nend someFunction;\n\nprocedure someFunction2; @nodisplay; @noalignstack;\nvar\n    b1  :byte;\n    d1  :dword;\n    w1  :word;\n    d2  :dword;\n    w2  :word;\n    b2  :byte;\n    d3  :dword;\n    b3  :byte;\nbegin someFunction2;\n        .\n        .\n        .\nend someFunction2;\n\nprocedure someFunction3; @nodisplay; @noalignstack;\nvar\n    // HLA align directive forces alignment of the next declaration.\n\n    align(4);\n    b1  :byte;\n    align(4);\n    d1  :dword;\n    align(4);\n    w1  :word;\n    align(4);\n    d2  :dword;\n    align(4);\n    w2  :word;\n    align(4);\n    b2  :byte;\n    align(4);\n    d3  :dword;\n    align(4);\n    b3  :byte;\nbegin someFunction3;\n        .\n        .\n        .\nend someFunction3;\n```", "```\n\n\t\t\ttypedef struct IveAligned\n{\n    char byteValue;\n    char padding0[3];\n    int  dwordValue;\n    short wordValue;\n    char padding1[2];\n    unsigned long dwordValue2;\n        .\n        .\n        .\n};\n```", "```\n\n\t\t\tStudent  struct  2\nscore    word    ?   ; offset:0\nid       byte    ?   ; offset 2 + 1 byte of padding\nyear     dword   ?   ; offset 4\nid2      byte    ?   ; offset:8\nStudent  ends\n```", "```\n\n\t\t\tStudent  struct\nscore    word    ?   ; offset:0\nid       byte    ?   ; offset 2\n         align   2   ; Injects 1 byte of padding.\nyear     dword   ?   ; offset 4\nid2      byte    ?   ; offset:8\n         align   2   ; Adds 1 byte of padding to the end of the struct.\nStudent  ends\n```", "```\n\n\t\t\ttype\n    Student :record\n        score :word;\n        id    :byte;\n        align(2);\n        year  :dword;\n        id2   :byte;\n        align(2);\n    endrecord;\n```", "```\n\n\t\t\ttype\n    Student :record[2]  // This tells HLA to align all\n                        // fields on a word boundary\n        score :word;\n        id    :byte;\n        year  :dword;\n        id2   :byte;\n    endrecord;\n```", "```\n\n\t\t\trecordID: record[ maxAlign : minAlign ]\n    <<fields>>\nendrecord;\n```", "```\n\n\t\t\tStudent  struct  4\nscore    word    ?   ; offset:0\nid       byte    ?   ; offset 2\n\n    ; 1 byte of padding appears here\n\nyear     dword   ?   ; offset 4\nid2      byte    ?   ; offset:8\n\n    ; 3 padding bytes appear here\n\ncourses  dword   ?   ; offset:12\nStudent  ends\n```", "```\n\n\t\t\ttype\n    //  Align on 4-byte offset, or object's size, whichever\n    //  is the smaller of the two. Also, make sure that the\n    //  entire record is a multiple of 4 bytes long.\n\n    Student  :record[4:1]\n        score   :word;\n        id      :byte;\n        year    :dword;\n        id2     :byte;\n      courses   :dword;\n    endrecord;\n```"]