<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">LOG MONITORING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">If you’ve spent time poking around macOS, you may have encountered the system’s unified logging mechanism, a resource that can help you understand macOS internals and, as you’ll soon see, uncover malware. In this chapter, I’ll start by highlighting the various kinds of information that can be extracted from these logs to detect malicious activity. We’ll then reverse engineer the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> utility and one of its core private frameworks so we can programmatically ingest real-time information directly and efficiently from the logging subsystem.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-44"/><span class="SANS_Futura_Std_Bold_B_11">Exploring Log Information</span></h3>&#13;
<p class="TNI">I’ll begin by covering a few examples of useful activity that can show up in the system log, starting with webcam access. Especially insidious malware specimens, including FruitFly, Mokes, and Crisis, surreptitiously spy on their victims through the infected host’s webcam. Accessing the webcam generates system log messages, however. For example, depending on the version of macOS, the Core Media I/O subsystem may produce the following:</p>&#13;
&#13;
<pre><code>CMIOExtensionProvider.m:2671:-[CMIOExtensionProvider setDevicePropertyValuesForClientID:&#13;
deviceID:propertyValues:reply:] &lt;CMIOExtensionProvider&gt;,&#13;
3F4ADF48-8358-4A2E-896B-96848FDB6DD5, propertyValues {&#13;
    <b>CMIOExtensionPropertyDeviceControlPID = 90429;</b>&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The bolded value contains the ID of the process accessing the webcam. Although the process could be legitimate, such as a Zoom or FaceTime session launched by the user for a virtual meeting, it’s prudent to confirm that this is the case, as the responsible process could also be malware attempting to spy on the user. Because Apple doesn’t provide an API that identifies the process accessing the webcam, log messages are one of the only ways to reliably get this information most of the time.</p>&#13;
<p class="TX">Other activities that often show up in system logs are remote logins, which could indicate a compromise, such as attackers gaining initial access to a host or even returning to a previously infected one. For example, the IPStorm malware spreads to victims by brute-forcing SSH logins.<sup><a role="doc-noteref" id="chapter6_1" href="#chapter6-1">1</a></sup> Another interesting case is XCSSET, which locally initiates a seemingly remote connection back to the host to bypass the macOS security mechanism known as Transparency, Consent, and Control (TCC).<sup><a role="doc-noteref" id="chapter6_2" href="#chapter6-2">2</a></sup></p>&#13;
<p class="TX">When a remote login occurs via SSH, the system generates log messages such as the following:</p>&#13;
&#13;
<pre><code>sshd: Accepted keyboard-interactive/pam for Patrick from 192.168.1.176 port 59363 ssh2&#13;
sshd: (libpam.2.dylib) in pam_sm_setcred(): Establishing credentials&#13;
sshd: (libpam.2.dylib) in pam_sm_setcred(): Got user: Patrick&#13;
...&#13;
sshd: (libpam.2.dylib) in pam_sm_open_session(): UID: 501&#13;
sshd: (libpam.2.dylib) in pam_sm_open_session(): server_URL: (null)&#13;
sshd: (libpam.2.dylib) in pam_sm_open_session(): path: (null)&#13;
sshd: (libpam.2.dylib) in pam_sm_open_session(): homedir: /Users/Patrick&#13;
sshd: (libpam.2.dylib) in pam_sm_open_session(): username: Patrick&#13;
</code></pre>&#13;
<p class="TX">These log messages provide the source IP address of the connection, as well as the identity of the user who logged in. This information can help defenders determine whether the SSH session is legitimate (perhaps a remote worker connecting to their office machine) or unauthorized.</p>&#13;
<p class="TX">Log messages can also provide insight into the TCC mechanism, which governs access to sensitive information and hardware features. In an Objective by the Sea conference talk, “The Clock Is TCCing,” researchers <span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>Calum Hall and Luke Roberts noted that messages found in the unified log enabled them to determine several pieces of information for a given TCC event (for example, malware attempting to capture the screen or access a user’s documents), including the resource for which the process requested access, the responsible and target processes, and whether the system denied or approved the request and why.<sup><a role="doc-noteref" id="chapter6_3" href="#chapter6-3">3</a></sup></p>&#13;
<p class="TX">At this point, it may be tempting to treat log messages as a panacea for malware detection. Don’t. Apple doesn’t officially support log messages and has often changed their contents or removed them altogether, even between minor releases of macOS. For example, on older versions of the operating system, you could detect microphone access and identify the process responsible for it by looking for the following log message:</p>&#13;
&#13;
<pre><code>send: 0/7 synchronous to com.apple.tccd.system: request: msgID=408.11,&#13;
function=TCCAccessRequest, service=kTCCServiceMicrophone, target_token={pid:23207, auid:501,&#13;
euid:501},&#13;
</code></pre>&#13;
<p class="TX">Unfortunately, Apple updated the relevant macOS framework so it no longer produces the message. If your security tool relied solely on this indicator to detect unauthorized microphone access, it would no longer function. Thus, it’s best to treat log messages as initial signs of suspicious behavior, then investigate further.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-45"/><span class="SANS_Futura_Std_Bold_B_11">The Unified Logging Subsystem</span></h3>&#13;
<p class="TNI">We often think of log messages as a way to figure out what happened in the past. But macOS also lets you subscribe to the stream of messages as they’re delivered to the logging subsystem in essentially real time. Better yet, the logging subsystem supports the filtering of these messages via custom predicates, providing efficient and unparalleled insight into the activity happening on the system.</p>&#13;
<p class="TX">In versions of macOS beginning with 10.12, this logging mechanism is called the <i>unified logging system</i>.<sup><a role="doc-noteref" id="chapter6_4" href="#chapter6-4">4</a></sup> A replacement of the traditional syslog interface, it records messages from core system daemons, operating system components, and any third-party software that generates logging messages via the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLog</span> APIs.</p>&#13;
<p class="TX">It’s worth noting that if you examine log messages in the unified system log, you may encounter redactions; the logging subsystem replaces any information deemed sensitive with the string <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;private&gt;</span>. To disable this functionality, you could install a configuration profile.<sup><a role="doc-noteref" id="chapter6_5" href="#chapter6-5">5</a></sup> While useful for understanding undocumented features of the operating system, however, you shouldn’t disable log redactions on end-user or production systems, which would make sensitive data available to anybody with access to the log.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/>&#13;
<h4 class="H2" id="sec3"><span id="h2-48"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Manually Querying the log Utility</span></h4>&#13;
<p class="TNI">To manually interface with the logging subsystem, use the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> utility found in <i>/usr/bin</i>:</p>&#13;
&#13;
<pre><code>% <b>/usr/bin/log</b>&#13;
usage:&#13;
    log &lt;command&gt;&#13;
&#13;
global options:&#13;
    -?, --help&#13;
    -q, --quiet&#13;
    -v, --verbose&#13;
&#13;
commands:&#13;
    collect         gather system logs into a log archive&#13;
    config          view/change logging system settings&#13;
    erase           delete system logging data&#13;
    show            view/search system logs&#13;
    stream          watch live system logs&#13;
    stats           show system logging statistics&#13;
&#13;
further help:&#13;
    log help &lt;command&gt;&#13;
    log help predicates&#13;
</code></pre>&#13;
<p class="TX">You can search previously logged data with the <span class="SANS_TheSansMonoCd_W5Regular_11">show</span> flag or use the <span class="SANS_TheSansMonoCd_W5Regular_11">stream</span> flag to view logging data as it’s generated in real time. Unless you specify otherwise, the output will include messages with a default log level only. To override this setting for past data, use the <span class="SANS_TheSansMonoCd_W5Regular_11">--info</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">--debug</span> flag, along with <span class="SANS_TheSansMonoCd_W5Regular_11">show</span>, to view further information and debug messages, respectively. For streaming data, specify both <span class="SANS_TheSansMonoCd_W5Regular_11">stream</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">--level</span>, then either <span class="SANS_TheSansMonoCd_W5Regular_11">info</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">debug</span>. These flags are hierarchical; specifying the debug level will return informational and default messages too.</p>&#13;
<p class="TX">Use the <span class="SANS_TheSansMonoCd_W5Regular_11">--predicate</span> flag with a predicate to filter the output. A rather extensive list of valid predicate fields allows you to find messages based on the process, subsystem, type, and much more. For example, to stream log messages from the kernel, execute the following:</p>&#13;
&#13;
<pre><code>% <b>log stream --predicate 'process == "kernel"'</b></code></pre>&#13;
<p class="TX">There is often more than one way to craft a predicate. For instance, we could also receive kernel messages by using <span class="SANS_TheSansMonoCd_W5Regular_11">'processIdentifier == 0'</span>, as the kernel always has a process ID of 0.</p>&#13;
<p class="TX">To stream messages from the security subsystem, enter the following:</p>&#13;
&#13;
<pre><code>% <b>log stream --predicate 'subsystem == "com.apple.securityd"'</b></code></pre>&#13;
<p class="TX">The examples shown here all use the equality operator (<span class="SANS_TheSansMonoCd_W5Regular_11">==</span>). However, predicates can use many other operators, including comparative operators <span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>(such as <span class="SANS_TheSansMonoCd_W5Regular_11">==</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">!=</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span>), logical operators (such as <span class="SANS_TheSansMonoCd_W5Regular_11">AND</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">OR</span>), and even membership operators (such as <span class="SANS_TheSansMonoCd_W5Regular_11">BEGINSWITH</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">CONTAINS</span>). Membership operators are powerful, as they allow you to craft filter predicates resembling regular expressions.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> man pages and the command <span class="SANS_TheSansMonoCd_W5Regular_11">log help predicates</span> provide a succinct overview of predicates.<sup><a role="doc-noteref" id="chapter6_6" href="#chapter6-6">6</a></sup></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-49"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reverse Engineering log APIs</span></h4>&#13;
<p class="TNI">To read log data programmatically, we could use the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLog</span> APIs.<sup><a role="doc-noteref" id="chapter6_7" href="#chapter6-7">7</a></sup> These APIs return only historical data, however, and in the context of malware detection, we’re much more interested in real-time events. No public API allows us to achieve this, but by reverse engineering the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> utility (specifically, the code that backs the <span class="SANS_TheSansMonoCd_W5Regular_11">stream</span> command), we can uncover exactly how to ingest logging messages as they enter the unified logging subsystem. Moreover, by providing a filter predicate, we can receive only messages of interest to us.</p>&#13;
<p class="TX">Although I won’t cover the full details of reversing the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> utility, I’ll provide an overview of the process in this section. Of course, you could apply a similar process against other Apple utilities and frameworks to extract private APIs useful for malware detection (as we showed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> while implementing package code signing checks).</p>&#13;
<p class="TX">First, we need to find the binary that implements the logging subsystem’s APIs so we can invoke them from our own code. Normally, we’ll find such APIs in a framework that is dynamically linked into the utility’s binary. By executing <span class="SANS_TheSansMonoCd_W5Regular_11">otool</span> with the <span class="SANS_TheSansMonoCd_W5Regular_11">-L</span> command line option, we can view the frameworks against which the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> utility is dynamically linked:</p>&#13;
&#13;
<pre><code>% <b>otool -L /usr/bin/log</b>&#13;
/System/Library/PrivateFrameworks/ktrace.framework/Versions/A/ktrace&#13;
/System/Library/PrivateFrameworks/LoggingSupport.framework/Versions/A/LoggingSupport&#13;
/System/Library/PrivateFrameworks/CoreSymbolication.framework/Versions/A/CoreSymbolication&#13;
...&#13;
</code></pre>&#13;
<p class="TX">Based on its name, the <i>LoggingSupport</i> framework seems likely to contain relevant logging APIs. In past versions of macOS, you could find the framework in the <i>/System/Library/PrivateFrameworks/</i> directory, while in newer versions, you’ll find it in the shared <i>dyld</i> cache.</p>&#13;
<p class="TX">After loading the framework into Hopper (which can directly load frameworks from the <i>dyld</i> cache), we find that the framework implements an undocumented class named <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventLiveStream</span> whose base class is <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventStreamBase</span>. These classes implement methods such as <span class="SANS_TheSansMonoCd_W5Regular_11">activate</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">setEventHandler:</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">setFilterPredicate:</span>. We also encounter an undocumented <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> class that appears to represent log events. Here are some of its properties:</p>&#13;
&#13;
<pre><code>NSString* process;&#13;
int processIdentifier;&#13;
NSString* processImagePath;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>NSString* sender;&#13;
NSString* senderImagePath;&#13;
NSString* category;&#13;
NSString* subsystem;&#13;
NSDate* date;&#13;
NSString* composedMessage;&#13;
</code></pre>&#13;
<p class="TX">By examining the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> utility, we can see how it uses these classes and their methods to capture streaming log data. For example, here is a decompiled snippet from the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> binary:</p>&#13;
&#13;
<pre><code>r21 = [OSLogEventLiveStream initWithLiveSource:...];&#13;
[r21 setEventHandler:&amp;var_110];&#13;
...&#13;
[r21 setFilterPredicate:r22];&#13;
&#13;
printf("Filtering the log data using \"%s\"\n", @selector(UTF8String));&#13;
...&#13;
[r21 activate];&#13;
</code></pre>&#13;
<p class="TX">In the decompilation, we first see a call to <span class="SANS_TheSansMonoCd_W5Regular_11">initWithLiveSource:</span> initializing an <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventLiveStream</span> object. Calls to methods such as <span class="SANS_TheSansMonoCd_W5Regular_11">setEventHandler:</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">setFilterPredicate:</span> then configure this object, stored in the <span class="SANS_TheSansMonoCd_W5Regular_11">r21</span> register. After the predicate is set, a helpful debug message indicates that a provided predicate can filter log data. Finally, the object activates, which triggers the ingestion of streaming log messages matching the specified predicate.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-46"/><span class="SANS_Futura_Std_Bold_B_11">Streaming Log Data</span></h3>&#13;
<p class="TNI">Using the information we gleaned by reverse engineering the <span class="SANS_TheSansMonoCd_W5Regular_11">log</span> binary and <i>LoggingSupport</i> framework, we can craft code to directly stream data from the universal logging subsystem in our detection tools. Here, we’ll cover important parts of the code, though you’re encouraged to consult the full code, found in this chapter’s <i>logStream</i> project.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#Lis6-1">Listing 6-1</a> shows a method that accepts a log filter predicate, a log level (such as <span class="SANS_TheSansMonoCd_W5Regular_11">default</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">info</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">debug</span>), and a callback function to invoke for each logging event that matches the specified predicate.</p>&#13;
<span id="Lis6-1"/>&#13;
<pre><code>#define LOGGING_SUPPORT @"/System/Library/PrivateFrameworks/LoggingSupport.framework"&#13;
&#13;
-(void)start:(NSPredicate*)predicate&#13;
level:(NSUInteger)level eventHandler:(void(^)(OSLogEventProxy*))eventHandler {&#13;
    [[NSBundle bundleWithPath:LOGGING_SUPPORT] load]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    Class LiveStream = NSClassFromString(@"OSLogEventLiveStream"); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    self.liveStream = [[LiveStream alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    @try {&#13;
        [self.liveStream setFilterPredicate:predicate]; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
    } @catch (NSException* exception) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>        // Code to handle invalid predicate removed for brevity&#13;
    }&#13;
    [self.liveStream setInvalidationHandler:^void (int reason, id streamPosition) {&#13;
        ;&#13;
    }];&#13;
&#13;
    [self.liveStream setDroppedEventHandler:^void (id droppedMessage) {&#13;
        ;&#13;
    }];&#13;
&#13;
    [self.liveStream setEventHandler:eventHandler]; <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
    [self.liveStream setFlags:level]; <span class="codewide_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
&#13;
    [self.liveStream activate]; <span class="codewide_CodeAnnotation" aria-label="annotation7">❼</span>&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: Starting a logging stream with a specified predicate</span></p>&#13;
<p class="TX">Note that I’ve omitted part of this code, such as the class definition and properties of the custom log class.</p>&#13;
<p class="TX">After loading the logging support framework <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the code retrieves the private <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventLiveStream</span> class by name <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Now we can instantiate an instance of the class <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We then configure this instance by setting the filter predicate <span class="CodeAnnotation" aria-label="annotation4">❹</span>, making sure to wrap it in a <span class="SANS_TheSansMonoCd_W5Regular_11">try...catch</span> block, as the <span class="SANS_TheSansMonoCd_W5Regular_11">setFilterPredicate:</span> method can throw an exception if provided with an invalid predicate. Next, we set the event handler, which the framework will invoke anytime the universal logging subsystem ingests a log message matching the specified predicate <span class="CodeAnnotation" aria-label="annotation5">❺</span>. We pass these values into the <span class="SANS_TheSansMonoCd_W5Regular_11">start:level:eventHandler:</span> method, where the predicate tells the log stream how to filter the messages it delivers to the event handler. We set the logging level via the <span class="SANS_TheSansMonoCd_W5Regular_11">setFlags:</span> method <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Finally, we start the stream with a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">activate</span> method <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#Lis6-2">Listing 6-2</a> shows how to create an instance of the custom log monitor class and then use it to begin ingesting log messages.</p>&#13;
<span id="Lis6-2"/>&#13;
<pre><code>NSPredicate* predicate = [NSPredicate predicateWithFormat:<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;some string predicate&gt;</span>]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
LogMonitor* logMonitor = [[LogMonitor alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
[logMonitor start:predicate level:Log_Level_Debug eventHandler:^(OSLogEventProxy* event) {&#13;
    printf("New Log Message: %s\n\n", event.description.UTF8String);&#13;
}];&#13;
&#13;
[NSRunLoop.mainRunLoop run];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: Interfacing with the custom log stream class</span></p>&#13;
<p class="TX">First, the code creates a predicate object from a string <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Note that in production code, you should also wrap this action in a <span class="SANS_TheSansMonoCd_W5Regular_11">try...catch</span> block, as the <span class="SANS_TheSansMonoCd_W5Regular_11">predicateWithFormat:</span> method throws a catchable exception if the provided predicate is invalid. Next, we create a <span class="SANS_TheSansMonoCd_W5Regular_11">LogMonitor</span> object and invoke its <span class="SANS_TheSansMonoCd_W5Regular_11">start:level:eventHandler:</span> method <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Note that for the level, we pass in <span class="SANS_TheSansMonoCd_W5Regular_11">Log_Level_Debug</span>. Since the level is hierarchal, this will ensure we capture all <span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/>message types, including those whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">info</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">default</span>. Now the code will invoke our event handler anytime a log message matching the specified predicate streams to the universal logging subsystem. Currently, this handler simply prints out the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> object.</p>&#13;
<p class="TX">To compile this code, we’ll need the undocumented class and method definitions we extracted from the <i>LoggingSupport</i> framework. These definitions live in the <i>logStream</i> project’s <i>LogStream.h</i> file; <a href="chapter6.xhtml#Lis6-3">Listing 6-3</a> provides a snippet of them.</p>&#13;
<span id="Lis6-3"/>&#13;
<pre><code>@interface OSLogEventLiveStream : NSObject&#13;
    -(void)activate;&#13;
    -(void)setFilterPredicate:(NSPredicate*)predicate;&#13;
    -(void)setEventHandler:(void(^)(id))callback;&#13;
    ...&#13;
    @property(nonatomic) unsigned long long flags;&#13;
@end&#13;
&#13;
@interface OSLogEventProxy : NSObject&#13;
    @property(readonly, nonatomic) NSString* process;&#13;
    @property(readonly, nonatomic) int processIdentifier;&#13;
    @property(readonly, nonatomic) NSString* processImagePath;&#13;
    ...&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: The interface for the private <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OSLogEventLiveStream</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OSLogEventProxy</span> classes</span></p>&#13;
<p class="TX">Once we compile this code, we can execute it with a user-specified predicate. For example, let’s monitor the log messages of the security subsystem, <i>com.apple.securityd</i>:</p>&#13;
&#13;
<pre><code>% <b>./logStream 'subsystem == "com.apple.securityd"'</b>&#13;
New Log Message:&#13;
&lt;OSLogEventProxy: 0x155804080, 0x0, 400, 1300, open(%s,0x%x,0x%x) = %d&gt;&#13;
New Log Message:&#13;
&lt;OSLogEventProxy: 0x155804080, 0x0, 400, 1300, %p is a thin file (%s)&gt;&#13;
New Log Message:&#13;
&lt;OSLogEventProxy: 0x155804080, 0x0, 400, 1300, %zd signing bytes in %d blob(s) from %s(%s)&gt;&#13;
New Log Message:&#13;
&lt;OSLogEventProxy: 0x155804080, 0x0, 400, 1009, network access disabled by policy&gt;&#13;
</code></pre>&#13;
<p class="TX">Although we’re indeed capturing streaming log messages that match the specified predicate, the messages don’t appear all that useful at first glance. This is because our event handler simply prints out the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> object via a call to its <span class="SANS_TheSansMonoCd_W5Regular_11">description</span> method, which doesn’t include all components of the message.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-50"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extracting Log Object Properties</span></h4>&#13;
<p class="TNI">To detect activity that could indicate the presence of malware, you’ll want to extract the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> log method object’s properties. While disassembling, we encountered several useful properties, such as the process ID, path, and message, but other interesting ones exist as well. Because <span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/>Objective-C is introspective, you can dynamically query any object, including undocumented ones, to reveal its properties and values. This requires a foray into the bowels of the Objective-C runtime; nevertheless, you’ll find it useful to understand any undocumented classes you encounter, especially when leveraging Apple’s private frameworks.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#Lis6-4">Listing 6-4</a> is a simple function that accepts any Objective-C object, then prints out its properties and their values. It’s based on code by Pat Zearfoss.<sup><a role="doc-noteref" id="chapter6_8" href="#chapter6-8">8</a></sup></p>&#13;
<span id="Lis6-4"/>&#13;
<pre><code>#import &lt;objc/message.h&gt; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
#import &lt;objc/runtime.h&gt;&#13;
&#13;
void inspectObject(id object) {&#13;
    unsigned int propertyCount = 0 ;&#13;
    objc_property_t* properties = class_copyPropertyList([object class], &amp;propertyCount); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    for(unsigned int i = 0; i &lt; propertyCount; i++) {&#13;
        NSString* name = [NSString stringWithUTF8String:property_getName(properties[i])]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
        printf("\n%s: ", [name UTF8String]);&#13;
&#13;
        SEL sel = sel_registerName(name.UTF8String); <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
        const char* attr = property_getAttributes(properties[i]); <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
&#13;
        switch(attr[1]) {&#13;
            case '@':&#13;
                printf("%s\n",&#13;
                [[((id (*)(id, SEL))objc_msgSend)(object, sel) description] UTF8String]);&#13;
                break;&#13;
            case 'i':&#13;
                printf("%i\n", ((int (*)(id, SEL))objc_msgSend)(object, sel));&#13;
                break;&#13;
            case 'f':&#13;
                printf("%f\n", ((float (*)(id, SEL))objc_msgSend)(object, sel));&#13;
                break;&#13;
            default:&#13;
                break;&#13;
        }&#13;
    }&#13;
&#13;
    free(properties);&#13;
    return;&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: Introspecting the properties of an Objective-C object</span></p>&#13;
<p class="TX">First, the code imports the required Objective-C runtime header files <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then it invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">class_copyPropertyList</span> API to get an array and the count of the object’s properties <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We iterate over this array to examine each property, invoking the <span class="SANS_TheSansMonoCd_W5Regular_11">property_getName</span> method to get the name of the property <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Then the <span class="SANS_TheSansMonoCd_W5Regular_11">sel_registerName</span> function retrieves a selector for the property <span class="CodeAnnotation" aria-label="annotation4">❹</span>. We’ll use the property selector later to retrieve the object’s value.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>Next, to determine the type of the property, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">property _getAttributes</span> method <span class="CodeAnnotation" aria-label="annotation5">❺</span>. This returns an array of attributes, with the property type as the second item (at index <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>). The code handles common types such as Objective-C objects (<span class="SANS_TheSansMonoCd_W5Regular_11">@</span>), integers (<span class="SANS_TheSansMonoCd_W5Regular_11">i</span>), and floats (<span class="SANS_TheSansMonoCd_W5Regular_11">f</span>). For each type, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">objc_msgSend</span> function on the object with the property’s selector to retrieve the property’s value.</p>&#13;
<p class="TX">If you look closely, you’ll see that the call to <span class="SANS_TheSansMonoCd_W5Regular_11">objc_msgSend</span> is typecast appropriately for each property type. For a list of type encodings, see Apple’s “Type Encodings” developer documentation.<sup><a role="doc-noteref" id="chapter6_9" href="#chapter6-9">9</a></sup> To inspect Swift objects, use Swift’s Mirror API.<sup><a role="doc-noteref" id="chapter6_10" href="#chapter6-10">10</a></sup></p>&#13;
<p class="TX">In the log monitor code, we can now invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">inspectObject</span> function with each <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> object received from the logging subsystem (<a href="chapter6.xhtml#Lis6-5">Listing 6-5</a>).</p>&#13;
<span id="Lis6-5"/>&#13;
<pre><code>NSPredicate* predicate = [NSPredicate predicateWithFormat:<span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;some string predicate&gt;</span>];&#13;
&#13;
[logMonitor start:predicate level:Log_Level_Debug eventHandler:&#13;
^(OSLogEventProxy* event) {&#13;
    inspectObject(event);&#13;
}];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: Inspecting each log message, encapsulated in an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OSLogEventProxy</span> object</span></p>&#13;
<p class="TX">If we compile and execute the program, we should now receive a more comprehensive view of each log message. For example, by monitoring messages related to XProtect, the built-in antimalware scanner found on certain versions of macOS, we can observe its scan of an untrusted application:</p>&#13;
&#13;
<pre><code>% <b>./logStream 'subsystem == "com.apple.xprotect"'</b>&#13;
&#13;
New Log Message:&#13;
&#13;
composedMessage: Starting malware scan for: /Volumes/Install/Install.app&#13;
&#13;
logType: 1&#13;
timeZone: GMT-0700 (GMT-7) offset -25200&#13;
...&#13;
processIdentifier: 1374&#13;
process: XprotectService&#13;
processImagePath: /System/Library/PrivateFrameworks/XprotectFramework&#13;
.framework/Versions/A/XprotectService.xpc/Contents/MacOS/XprotectService&#13;
...&#13;
senderImagePath: /System/Library/PrivateFrameworks/XprotectFramework&#13;
.framework/Versions/A/XprotectService.xpc/Contents/MacOS/XprotectService&#13;
sender: XprotectService&#13;
...&#13;
subsystem: com.apple.xprotect&#13;
category: xprotect&#13;
...&#13;
</code></pre>&#13;
<p class="TX">The abridged output contains the properties of the <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> object most relevant to security tools. <a href="chapter6.xhtml#tab6-1">Table 6-1</a> summarizes these alphabetically. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>As with many <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> object properties, you can use them in custom predicates.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-1"><span class="SANS_Futura_Std_Heavy_B_11">Table 6-1:</span> <span class="SANS_Futura_Std_Book_11">Security-Relevant</span> <span class="SANS_TheSansMonoCd_W5Regular_11">OSLogEventProxy</span> <span class="SANS_Futura_Std_Book_11">Properties</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Property name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">category</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The category used to log an event</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">composedMessage</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The contents of the log message</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">logType</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">For</span> <span class="SANS_TheSansMonoCd_W5Regular_11">logEvent</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">traceEvent</span><span class="SANS_Futura_Std_Book_11">, the message’s type (</span><span class="SANS_TheSansMonoCd_W5Regular_11">default</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">info</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">debug</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">error</span><span class="SANS_Futura_Std_Book_11">, or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">fault</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">processIdentifier</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The process ID of the process that caused the event</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">processImagePath</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The full path of the process that caused the event</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">senderImagePath</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The full path of the library, framework, kernel extension, or Mach-O image that caused the event</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">subsystem</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The subsystem used to log an event</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">type</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">The type of event (such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">activityCreateEvent</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">activityTransitionEvent</span><span class="SANS_Futura_Std_Book_11">, or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">logEvent</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-51"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining Resource Consumption</span></h4>&#13;
<p class="TNI">It’s important to consider the potential resource impact of streaming log messages. If you take an overly consumptive approach, you can incur a significant CPU cost and impact to the responsiveness of the system.</p>&#13;
<p class="TX">First, pay attention to the log level. Specifying the <span class="SANS_TheSansMonoCd_W5Regular_11">debug</span> level will result in a significant increase in the number of log messages processed against any predicate. Although the predicate evaluation logic is very efficient, more messages mean more CPU cycles. Thus, a security tool that leverages the logging subsystem’s streaming capabilities should probably stick to consuming the <span class="SANS_TheSansMonoCd_W5Regular_11">default</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">info</span> messages.</p>&#13;
<p class="TX">Equally important to efficiency is the predicate you use. Interestingly, my experiments have shown that the logging daemon wholly evaluates some predicates, while the logging subsystem frameworks loaded in client programs, such as the log monitor, handle others. The former is better; otherwise, the program will receive a copy of every single log message for predicate evaluation, which can chew up significant CPU cycles. If the logging daemon performs the predicate evaluation, you’ll receive messages that match the predicate only, which won’t discernibly impact the system.</p>&#13;
<p class="TX">How can you craft a predicate that the logging daemon will evaluate? Trial and error have shown that if you specify a process or subsystem in a predicate, the daemon will evaluate it, meaning you’ll receive only log messages that match. Let’s look at a specific example from OverSight, a tool discussed in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> that monitors the microphone and webcam.<sup><a role="doc-noteref" id="chapter6_11" href="#chapter6-11">11</a></sup></p>&#13;
<p class="TX">OverSight requires access to log messages from the core media I/O subsystem to identify the process accessing the webcam. At the start of the chapter, I noted that certain versions of macOS store this process ID in log messages from the core media I/O subsystem that contain the string <span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label="152"/><span class="SANS_TheSansMonoCd_W5Regular_11">CMIOExtensionPropertyDeviceControlPID</span>. Understandably, you might be tempted to craft a predicate that matches this string:</p>&#13;
&#13;
<pre><code>'composedMessage CONTAINS "CMIOExtensionPropertyDeviceControlPID"'</code></pre>&#13;
<p class="TX">This predicate would lead to processing inefficiencies, however, as the logging daemon will send all messages that the logging frameworks loaded in our log monitor to perform the predicate filtering. Instead, OverSight leverages a broader predicate that makes use of the <span class="SANS_TheSansMonoCd_W5Regular_11">subsystem</span> property:</p>&#13;
&#13;
<pre><code>subsystem=='com.apple.cmio'</code></pre>&#13;
<p class="TX">This approach causes the logging daemon to perform the predicate matching, then deliver only messages from the core media I/O subsystem. OverSight itself manually performs the check for the <span class="SANS_TheSansMonoCd_W5Regular_11">CMIOExtensionPropertyDeviceControlPID</span> string:</p>&#13;
&#13;
<pre><code>if(YES == [logEvent.composedMessage&#13;
containsString:@"CMIOExtensionPropertyDeviceControlPID ="]) {&#13;
    // Extract the PID of the processes accessing the webcam.&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The tool leverages a similar process to return log messages associated with mic access. As a result, it can effectively detect any process (including malware) attempting to use either the mic or webcam.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-47"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">In this chapter, you saw how to use code to interface with the operating system’s universal logging subsystem. By reverse engineering the private <i>LoggingSupport</i> framework, we programmatically streamed messages matching custom predicates and accessed the wealth of data found in the logging subsystem. Security tools could use this information to detect new infections or even uncover the malicious actions of persistently installed malware.</p>&#13;
<p class="TX">In the next chapter, you’ll write network monitoring logic using Apple’s powerful and well-documented network extensions.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-1" href="#chapter6_1">  1</a></span>.  Nicole Fishbein and Avigayil Mechtinger, “A Storm Is Brewing: IPStorm Now Has Linux Malware,” Intezer, November 14, 2023, <a href="https://www.intezer.com/blog/research/a-storm-is-brewing-ipstorm-now-has-linux-malware/"><i>https://<wbr/>www<wbr/>.intezer<wbr/>.com<wbr/>/blog<wbr/>/research<wbr/>/a<wbr/>-storm<wbr/>-is<wbr/>-brewing<wbr/>-ipstorm<wbr/>-now<wbr/>-has<wbr/>-linux<wbr/>-malware<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-2" href="#chapter6_2">  2</a></span>.  “The XCSSET Malware,” TrendMicro, August 13, 2020, <a href="https://documents.trendmicro.com/assets/pdf/XCSSET_Technical_Brief.pdf"><i>https://<wbr/>documents<wbr/>.trendmicro<wbr/>.com<wbr/>/assets<wbr/>/pdf<wbr/>/XCSSET<wbr/>_Technical<wbr/>_Brief<wbr/>.pdf</i></a>. To read more about the abuse of remote logins in macOS, see Jaron Bradley, “What Does APT Activity Look Like on macOS?,” <i>The Mitten Mac</i>, November 14, 2021, <a href="https://themittenmac.com/what-does-apt-activity-look-like-on-macos/"><i>https://<wbr/>themittenmac<wbr/>.com<wbr/>/what<wbr/>-does<wbr/>-apt<wbr/>-activity<wbr/>-look<wbr/>-like<wbr/>-on<wbr/>-macos<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label="153"/><span class="en_tx"><a id="chapter6-3" href="#chapter6_3">  3</a></span>.  Calum Hall and Luke Roberts, “The Clock Is TCCing,” paper presented at Objective by the Sea v6, Spain, October 12, 2023, <a href="https://objectivebythesea.org/v6/talks/OBTS_v6_lRoberts_cHall.pdf"><i>https://<wbr/>objectivebythesea<wbr/>.org<wbr/>/v6<wbr/>/talks<wbr/>/OBTS<wbr/>_v6<wbr/>_lRoberts<wbr/>_cHall<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-4" href="#chapter6_4">  4</a></span>.  “Logging,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/os/logging"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/os<wbr/>/logging</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-5" href="#chapter6_5">  5</a></span>.  Howard Oakley, “How to Reveal ‘Private’ Messages in the Log,” Eclectic Light, May 25, 2020, <a href="https://eclecticlight.co/2020/05/25/how-to-reveal-private-messages-in-the-log/"><i>https://<wbr/>eclecticlight<wbr/>.co<wbr/>/2020<wbr/>/05<wbr/>/25<wbr/>/how<wbr/>-to<wbr/>-reveal<wbr/>-private<wbr/>-messages<wbr/>-in<wbr/>-the<wbr/>-log<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-6" href="#chapter6_6">  6</a></span>.  See Howard Oakley, “log: A Primer on Predicates,” Eclectic Light, October 17, 2016, <a href="https://eclecticlight.co/2016/10/17/log-a-primer-on-predicates/"><i>https://<wbr/>eclecticlight<wbr/>.co<wbr/>/2016<wbr/>/10<wbr/>/17<wbr/>/log<wbr/>-a<wbr/>-primer<wbr/>-on<wbr/>-predicates<wbr/>/</i></a>, and <span class="endnoteentry_Endnote-Text-Char">“Predicate Programming Guide,” Apple Developer</span> Documentation, <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Predicates/AdditionalChapters/Introduction.html"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/documentation<wbr/>/Cocoa<wbr/>/Conceptual<wbr/>/Predicates<wbr/>/AdditionalChapters<wbr/>/Introduction<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-7" href="#chapter6_7">  7</a></span>.  “OSLog,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/oslog"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/oslog</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-8" href="#chapter6_8">  8</a></span>.  Pat Zearfoss, “Objective-C Quickie: Printing All Declared Properties of an Object,” April 14, 2011, <a href="https://zearfoss.wordpress.com/2011/04/14/objective-c-quickie-printing-all-declared-properties-of-an-object/"><i>https://<wbr/>zearfoss<wbr/>.wordpress<wbr/>.com<wbr/>/2011<wbr/>/04<wbr/>/14<wbr/>/objective<wbr/>-c<wbr/>-quickie<wbr/>-printing<wbr/>-all<wbr/>-declared<wbr/>-properties<wbr/>-of<wbr/>-an<wbr/>-object<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-9" href="#chapter6_9">  9</a></span>.  The list is available at <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/library<wbr/>/archive<wbr/>/documentation<wbr/>/Cocoa<wbr/>/Conceptual<wbr/>/ObjCRuntimeGuide<wbr/>/Articles<wbr/>/ocrtTypeEncodings<wbr/>.html#<wbr/>/<wbr/>/apple<wbr/>_ref<wbr/>/doc<wbr/>/uid<wbr/>/TP40008048<wbr/>-CH100<wbr/>-SW1</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-10" href="#chapter6_10">10</a></span>.  Read more about Swift’s Mirror API in Antoine van der Lee, “Reflection in Swift: How Mirror Works,” <i>SwiftLee</i>, December 21, 2021, <a href="https://www.avanderlee.com/swift/reflection-how-mirror-works/"><i>https://<wbr/>www<wbr/>.avanderlee<wbr/>.com<wbr/>/swift<wbr/>/reflection<wbr/>-how<wbr/>-mirror<wbr/>-works<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter6-11" href="#chapter6_11">11</a></span>.  See <a href="https://objective-see.org/products/oversight.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/products<wbr/>/oversight<wbr/>.html</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>