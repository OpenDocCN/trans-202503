- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: STATISTICS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学**
- en: '*The true Logic for this world is the Calculus of Probabilities.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个世界的真正逻辑是概率微积分。*'
- en: —James Clerk Maxwell
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —詹姆斯·克拉克·麦克斯韦
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Many readers of this book are likely to skip one or more chapters in [Part II](part2.xhtml).
    A biologist may not be interested in physics applications, for example. But *this*
    particular chapter has something in it for everyone, because sooner or later,
    all scientists must deal with the subject of statistics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的许多读者可能会跳过[第二部分](part2.xhtml)中的一个或多个章节。例如，一位生物学家可能对物理应用不感兴趣。但是*这一*特定章节对每个人都有帮助，因为迟早所有科学家都必须面对统计学这一主题。
- en: Anyone conducting experiments knows that the treatment and analysis of experimental
    data is a direct application of statistical methods and concepts. Every scientific
    calculator features buttons for calculating means and standard deviations of rows
    of numbers. In this chapter, you will learn how to apply Julia and its statistical
    libraries to manipulate, plot, and analyze all kinds of data. Julia is generally
    faster, more flexible, more extensible, and more powerful than R, the near-standard
    language in this field. But if you have R programs that you are already working
    with, I’ll explain how to use them from within your Julia environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进行实验的人都知道，实验数据的处理和分析是统计方法和概念的直接应用。每台科学计算器都配有用于计算一组数字的均值和标准差的按钮。在本章中，你将学习如何应用Julia及其统计库来操作、绘制和分析各种数据。与统计学领域的标准语言R相比，Julia通常更快、更灵活、更可扩展且更强大。但如果你已经在使用R程序，我会解释如何在Julia环境中使用它们。
- en: 'The concepts of probabilities and distributions are ubiquitous in physics,
    from the classical theories of statistical mechanics to quantum theory, in which
    probability plays a fundamental role. But statistics, and its basis in the language
    of probabilities, has its fingerprints all over science, even apart from experiments
    and observations. One of the detailed examples in this chapter involves probabilistic
    modeling in biology: an application of these ideas outside of both analysis of
    experiments and physics.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 概率和分布的概念在物理学中无处不在，从经典的统计力学理论到量子理论，其中概率扮演着基础性角色。而统计学及其在概率语言中的基础，在科学中几乎无处不在，即使在实验和观察之外也是如此。本章中的一个详细例子涉及生物学中的概率建模：这些思想在分析实验和物理学之外的应用。
- en: '**Probability**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率**'
- en: We don’t have the space here for a complete course in probability and statistics,
    but fortunately, we can do everything we need to do without a detailed mathematical
    development. Almost all scientists have some familiarity with the basic concepts
    and methods of the discipline, but I will not assume any special knowledge.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里没有足够的篇幅讲解完整的概率和统计课程，但幸运的是，我们可以在没有详细数学推导的情况下做我们需要做的一切。几乎所有科学家都对这一学科的基本概念和方法有所了解，但我不会假设读者有任何特别的知识。
- en: To understand and use statistics, we first need a clear grasp of *probability*.
    For our purposes, we can understand a probability as a number between 0 and 1,
    inclusive, that represents the likelihood of an event. A probability of 0 means
    that the event is impossible, and a probability of 1 means that it must occur.
    Any other probability can be interpreted as the frequency, or proportion of times,
    with which the event will occur in a large number of experiments. For example,
    if we say that the probability of heads when you flip a coin is 1/2, this means
    if you flip the coin a large number of times, the ratio of times that it comes
    up heads divided by the total number of flips will be close to 0.5.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解和使用统计学，我们首先需要清楚地掌握*概率*。在我们的应用中，我们可以把概率理解为一个介于0和1之间的数（包括0和1），它表示某事件发生的可能性。概率为0意味着该事件不可能发生，而概率为1意味着该事件必然发生。其他任何概率可以被解释为在大量实验中该事件发生的频率或比例。例如，如果我们说抛硬币时正面朝上的概率是1/2，这意味着如果你抛硬币很多次，硬币正面朝上的次数与总抛掷次数的比例将接近0.5。
- en: How many times is a large number of times? What we really mean is that there
    is a limit
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的“多次”到底是多少次？我们真正的意思是这里有一个极限
- en: '![Image](../images/306math.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/306math.jpg)'
- en: which just says that as we do more and more experiments, the number of times
    that we observe the event *x*, *n*[*x*], divided by the total number of experiments,
    *N*, gets closer and closer to a certain ratio. We call this ratio the probability.
    In probability theory, *experiment* means a process, such as flipping a coin or
    rolling a die.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是说，当我们做更多实验时，观察到事件*x*的次数*n*[*x*]，除以实验总次数*N*，将越来越接近某个特定比例。我们称这个比例为概率。在概率论中，*实验*指的是一个过程，例如掷硬币或掷骰子。
- en: The preceding paragraph describes a particular view of probability called the
    *frequency interpretation*. There are other ways to look at probability and its
    meaning, but in some sense, they are all equivalent. The frequency interpretation
    is practical, serves our purposes well, and is what most people think of when
    they need to pin down their idea of what probability means in practice. For more
    formal approaches to the subject, see “Further Reading” on [page 359](ch10.xhtml#fur10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面一段描述了概率的一种特定观点，叫做*频率解释*。当然也有其他方式来看待概率及其含义，但从某种意义上来说，它们都是等价的。频率解释是实用的，能够很好地服务于我们的目的，而且是大多数人在需要明确理解概率实际含义时所想到的方式。有关该主题的更正式的探讨，请参见[359页](ch10.xhtml#fur10)中的“进一步阅读”。
- en: 'We’ll often want to simulate events in our computer programs that are supposed
    to occur with certain probabilities. This could be part of the simulation of a
    system, such as the molecules of a gas bouncing around in a box, which we may
    want to initialize with random positions and velocities, or it could be part of
    a statistical test. But this presents a problem: if probability represents chance,
    the outcome of some kind of random process, and what goes on inside our computers
    is (we certainly hope) deterministic, how can we use computers to generate random
    events?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常希望在计算机程序中模拟某些事件，这些事件应当以某些概率发生。这可能是系统模拟的一部分，比如模拟气体分子在盒子里碰撞，我们可能希望用随机的位置和速度来初始化这些分子，或者它可能是统计检验的一部分。但这就提出了一个问题：如果概率代表机会，即某种随机过程的结果，而我们计算机内部的过程（我们当然希望如此）是确定性的，那么我们如何利用计算机生成随机事件呢？
- en: For the purposes of the examples in this book, we actually don’t want our random
    events to be random, because we may want to repeat simulations or check to see
    whether we get identical results after changing a computational technique. We
    need to be able to repeat particular sequences of “random” events. Surely this
    is a contradiction. If we know what’s going to happen, it can’t be random.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书中的例子而言，我们实际上并不希望我们的随机事件是随机的，因为我们可能希望重复模拟或者检查在改变计算方法后是否会得到相同的结果。我们需要能够重复特定的“随机”事件序列。这看起来似乎是一个矛盾。如果我们知道结果会是什么，它就不可能是随机的。
- en: The random numbers we generate in our programs are called *pseudorandom* numbers.
    They look like sequences of random numbers, satisfy certain tests of randomness,
    and adhere to given *distributions* (explained next). However, naturally, they
    are not really random. Again, we don’t actually want them to be.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中生成的随机数被称为*pseudorandom*（伪随机）数。它们看起来像是随机数的序列，满足某些随机性测试，并且遵循给定的*分布*（接下来会解释）。然而，本质上它们并不真正是随机的。再次强调，我们并不是真的希望它们是完全随机的。
- en: Except when we do. In some cryptography applications, we really need actual,
    unpredictable random numbers. Because the bad guys know the various algorithms
    for generating pseudorandom numbers, being able to predict such sequences can
    lead to defeating cryptographic systems. For such purposes, computer security
    systems exploit sources of real unpredictability available on any computer (known
    as *entropy sources*). These sources can be stored data derived from the timing
    of key presses on the keyboard, for example. The search for entropy has led to
    some creative solutions, such as pointing cameras at a wall of lava lamps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们确实需要。在某些密码学应用中，我们确实需要真正的、不可预测的随机数。因为不法分子知道各种生成伪随机数的算法，能够预测这些序列可能会导致破解密码系统。为了这样的用途，计算机安全系统利用计算机上任何可用的真实不可预测性来源（称为*熵源*）。这些来源可以是键盘上按键时间生成的存储数据。例如，熵的寻找促使了一些创意的解决方案，比如对着熔岩灯墙拍照。
- en: Julia actually provides a way to tap into the entropy provided by your operating
    system. However, in this book, we are not interested in cryptography, but in science,
    so we want our random numbers to be not so random, and we’ll be using Julia’s
    pseudorandom number generators. I’ll follow common practice for the rest of this
    chapter and just call these pseudorandom numbers “random numbers.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Julia实际上提供了一种方法，可以利用操作系统提供的熵。然而，在本书中，我们并不关心密码学，而是关注科学，所以我们希望我们的随机数并不那么随机，我们将使用Julia的伪随机数生成器。接下来的章节中，我会遵循常见做法，将这些伪随机数称为“随机数”。
- en: '**Random Numbers in Julia**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Julia中的随机数**'
- en: Julia has functions for generating random numbers with all kinds of numerical
    types, even complex numbers. The basic random number generators are part of `Base`,
    so you can use them without any `import` statements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Julia有用于生成各种数值类型的随机数的函数，甚至包括复数。基本的随机数生成器是`Base`的一部分，因此你可以在不需要`import`语句的情况下直接使用它们。
- en: '**NOTE**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I mentioned earlier that one reason to use pseudorandom numbers is so we can
    repeat a sequence of random numbers when developing code. This sequence repeatability
    is not guaranteed to work forever, however. The random sequence returned by a
    particular function can change when upgrading Julia, so you can’t depend on this
    for code development over the long term. See “Further Reading” on [page 359](ch10.xhtml#fur10)
    if you need long-term reproducible number sequences.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*我之前提到过，使用伪随机数的一个原因是我们在开发代码时可以重复一个随机数序列。然而，这种序列的可重复性并不能保证永远有效。特定函数返回的随机序列可能在升级
    Julia 后发生变化，因此你不能长期依赖它进行代码开发。如果你需要长期可复现的数字序列，请参见[第359页](ch10.xhtml#fur10)的“进一步阅读”。*'
- en: The simplest use is just calling `rand()`, which returns a random `Float64`
    *uniformly distributed* in the interval [0, 1). This means that the number might
    be equal to 0, but it will be less than 1, and all numbers in this interval are
    equally likely.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用法是调用`rand()`，它会返回一个在区间[0, 1)内均匀分布的随机`Float64`。这意味着数字可能等于0，但会小于1，并且区间内的所有数字都是等可能的。
- en: 'We can check that the `rand()` function is doing what we expect by generating
    a bunch of random numbers and plotting them with a scatterplot. We could do this
    by calling `rand()` many times, storing its returned values in an array, and plotting
    the array. But `rand()` makes it even easier: if we give it an integer argument,
    it will oblige us by returning an array of random values whose length will be
    determined by the argument. If we give it more than one, we’ll get back a higher-dimensional
    array. The little program shown in [Listing 10-1](ch10.xhtml#ch10lis1) fills a
    length-10⁵ array with random floats and visualizes their distribution with a scatterplot.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过生成一堆随机数并用散点图绘制它们来检查`rand()`函数是否按预期工作。我们可以通过多次调用`rand()`，将其返回的值存储在数组中，并绘制该数组来实现。但`rand()`使这一过程变得更简单：如果我们传递一个整数参数，它会按要求返回一个随机值数组，其长度由参数决定。如果我们传递多个参数，它会返回一个更高维的数组。[列表
    10-1](ch10.xhtml#ch10lis1)中的小程序将一个长度为10⁵的数组填充随机浮点数，并通过散点图可视化它们的分布。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Testing random number generation*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1：测试随机数生成*'
- en: In the resulting plot, shown in [Figure 10-1](ch10.xhtml#ch10fig1), each of
    the 10⁵ numbers is represented by a tiny dot. All the numbers lie within the correct
    interval, and they appear to be randomly and uniformly distributed, as they are
    supposed to be. A plot like this is a useful visual check to ensure that a pseudorandom
    number generator is behaving correctly and not introducing any unwanted patterns
    in the distribution of values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果图中，如[图 10-1](ch10.xhtml#ch10fig1)所示，每个10⁵个数字由一个小点表示。所有数字都位于正确的区间内，并且它们似乎是随机且均匀分布的，正如它们应该的那样。像这样的图表是一个有用的视觉检查，用来确保伪随机数生成器行为正常，并且没有在数值分布中引入任何不需要的模式。
- en: '![Image](../images/ch10fig01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig01.jpg)'
- en: '*Figure 10-1: Uniformly distributed random floats*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：均匀分布的随机浮点数*'
- en: 'To get random integers, or some type other than floats, simply pass the type
    as an argument. The call `rand(Int)`, which is the same as `rand(Int64)`, returns
    a random integer within the range defined by the lowest and highest possible integers
    of that type. This is rarely what you want in applications, however. You’ll probably
    want a random integer within some specified range that is relevant to your problem.
    In that case, simply pass the range as an argument: `rand(1:6)` represents the
    roll of a die, for example.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取随机整数或其他类型（而不是浮点数），只需将类型作为参数传递即可。调用`rand(Int)`（与`rand(Int64)`相同）将返回一个在该类型所定义的最小和最大整数范围内的随机整数。然而，这在应用程序中很少是你想要的。你可能希望得到一个在某个特定范围内的随机整数，这个范围与你的问题相关。在这种情况下，只需将范围作为参数传递：例如，`rand(1:6)`表示掷骰子。
- en: In fact, that argument can be a tuple or list as well, from which `rand()` will
    pick a random element, all with equal likelihood. You can even do something like
    `rand([1, 3, "abc"])`, and get either `1`, `3`, or the string `"abc"`, each with
    a probability of 1/3\. If you pass in a single string, it will be considered a
    collection of characters, and you will get a random character back.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，该参数也可以是元组或列表，`rand()`会从中随机选择一个元素，且每个元素的选择概率相等。你甚至可以像这样做：`rand([1, 3, "abc"])`，并随机得到`1`、`3`或字符串`"abc"`，每个的概率都是1/3。如果你传入一个字符串，它会被视为字符集合，返回一个随机字符。
- en: 'The simple call `rand()` is useful in simulations where you want events to
    occur with a certain probability. If the probability of the event is supposed
    to be `P`, in your code, you’ll have something like the following, which is a
    way to make something happen with a specified probability:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`rand()`调用在模拟中非常有用，特别是当你希望某些事件按特定概率发生时。如果事件发生的概率是`P`，那么在代码中你将看到类似以下的内容，这是一种让某件事以指定概率发生的方式：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The call to `rand()` works because it generates *uniformly distributed* random
    numbers in the interval [0, 1). Imagine repeatedly throwing a dart at a square
    dartboard one meter on a side (and assume it lands in a random place on the board).
    In the long run, the dart will land within the rightmost 90 centimeters 90 percent
    of the time. The `rand()` function is the dart.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`rand()`有效，因为它会生成在区间[0, 1)内*均匀分布*的随机数。想象一下，反复把飞镖投向一个边长为一米的正方形飞镖板（假设它会随机落在板上的某个位置）。从长远来看，飞镖将有90%的时间落在最右边的90厘米范围内。`rand()`函数就像是那个飞镖。
- en: Keeping in mind that, over the long term, you can’t count on being able to repeat
    a particular sequence generated by one of Julia’s random number functions, you’ll
    need to know how to do it in the short term when debugging code or developing
    an algorithm. You’ll often want to rerun a program after changing something that
    you believe should not change the results. If the program uses random numbers,
    and the sequence is truly unpredictable, such tests become impossible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从长远来看，你无法依赖Julia的随机数函数生成的特定序列能够重复，因此在调试代码或开发算法时，你需要知道如何在短期内做到这一点。当你更改某些你认为不应该改变结果的部分时，你通常会希望重新运行程序。如果程序使用了随机数，而且序列是真正不可预测的，这种测试就变得不可能了。
- en: By passing a *seed* to a random number generator, you can generate a sequence
    of high-quality pseudorandom numbers and also repeat the same sequence in subsequent
    runs of your program. To do this, you need to import the `Random` package, as
    you’ll need to use at least one function that’s not in `Base`. But `Random` has
    a few other goodies, as you’ll see shortly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个*种子*传递给随机数生成器，你可以生成一系列高质量的伪随机数，并且在程序的后续运行中重复相同的序列。为了做到这一点，你需要导入`Random`包，因为你将需要使用至少一个不在`Base`中的函数。但`Random`还有一些其他的有用功能，稍后你会看到。
- en: 'The following listing shows the three lines of code that illustrate the basic
    procedure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是展示基本过程的三行代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After importing `Random`, the `MersenneTwister()` function, which is a random
    number–generating algorithm, will be available. The name comes from the mathematical
    library from which the function is taken. Its argument, in this case `7654`, is
    called a *seed*. The purpose of the seed is to generate a particular sequence
    that we can repeat if needed. The `rand()` function, and all the other random
    number functions in Julia, accept an optional first argument that specifies the
    particular instance of the generator to use. As before, every time we call `rand()`,
    we get a random number between 0 and 1\. But now we can restart the sequence anytime
    we want by reinitializing `rgen` using the same seed. We can generate a different,
    unpredictable sequence by simply changing the seed. Except for the most casual
    use, you should always specify a generator and supply it with a seed rather than
    using the simpler form of `rand()` as we did in the previous example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `Random` 后，`MersenneTwister()` 函数，即一个随机数生成算法，就可以使用了。这个名字来自于该函数所在的数学库。它的参数，在这个例子中是
    `7654`，被称为 *种子*。种子的目的是生成一个特定的序列，如果需要，我们可以重复使用该序列。`rand()` 函数，以及 Julia 中的所有其他随机数函数，都接受一个可选的第一个参数，用于指定使用的生成器实例。如前所述，每次调用
    `rand()` 时，我们都会得到一个 0 到 1 之间的随机数。但现在，我们可以通过重新初始化 `rgen` 并使用相同的种子，随时重新启动序列。我们可以通过简单地更改种子来生成一个不同的、不可预测的序列。除了最简单的使用情况外，你应该始终指定一个生成器，并为其提供一个种子，而不是像我们在前一个示例中那样使用更简单的
    `rand()` 形式。
- en: '**The Monty Hall Problem**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Monty Hall 问题**'
- en: The ability to generate random numbers opens up a whole world of possibilities
    for interesting simulations. First, let’s consider the *Monty Hall problem*, which
    is named after the longtime host of the game show *Let’s Make a Deal*. This problem
    is guaranteed to generate lively debate in statistics classes and is something
    that experienced mathematicians, even statisticians, often get wrong—or they used
    to, before the problem became famous. For us, it will serve as an example of how
    a probabilistic computer simulation can verify a result that we believe we have
    calculated analytically. Simulations can supply some additional confidence in
    the solutions to tricky probability problems, where it is so easy to go astray
    analytically.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的能力为有趣的模拟开辟了广阔的可能性。首先，让我们考虑一下 *Monty Hall 问题*，它以长期主持游戏节目 *Let's Make a
    Deal* 的 Monty 为名。这个问题在统计学课堂上常常引发激烈的辩论，甚至经验丰富的数学家，甚至统计学家，常常也会犯错——或者他们曾经会犯错，直到这个问题变得有名。对我们来说，这将作为一个例子，展示如何通过概率计算机模拟验证我们认为已经通过分析方法计算出的结果。模拟可以为那些难度较大的概率问题提供额外的信心，因为在这些问题中，分析计算很容易出现偏差。
- en: Imagine three doors. Behind one is a prize, say, a fancy car, and behind the
    other two are joke prizes. Monty often used goats for these “loser” prizes. You
    want the car. Monty asks you to choose a door. He knows where everything is, but
    you know nothing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有三扇门。 behind one is a prize, say, a fancy car, and behind the other two
    are joke prizes. Monty often used goats for these “loser” prizes. You want the
    car. Monty asks you to choose a door. He knows where everything is, but you know
    nothing.
- en: 'Let’s say, to be definite, that you choose door #1\. Before revealing what’s
    behind that door, Monty opens one of the other ones, say, door #3, to reveal a
    goat. He offers you the chance to switch to door #2 if you like.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你选择了门 #1。 在揭示门后面是什么之前，Monty 打开了另一个门，比如门 #3，露出了一个山羊。他给你机会，如果你愿意的话，可以换到门 #2。'
- en: 'Here is the question: should you stick with your original choice or switch
    to door #2? Does it matter?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '问题来了：你应该坚持原来的选择，还是换到门 #2？这有关系吗？'
- en: 'The correct answer is that you should switch. Nevertheless, many people have
    a strong initial intuition that it must not make any difference. After all, now
    two doors are available: door #1 and door #2\. Surely they have an equal chance
    of leading to the prize, so it’s the same as flipping a coin: heads or tails are
    equally likely.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '正确答案是你应该换门。然而，许多人最初的直觉是，换不换都没有区别。毕竟，现在有两扇门可以选择：门 #1 和门 #2。它们应该有相等的机会通向奖品，所以这就像抛硬币：正面或反面是一样可能的。'
- en: 'However, this thinking is wrong. Initially, the probability that your choice
    was a winner was 1/3\. Everyone agrees with that. That means that the probability
    that the prize was in *one of the other doors* is 2/3\. Since the prize is guaranteed
    to be somewhere, the total probability must add up to 1\. These initial probabilities
    still hold. The probability that door #1 is the winner is still 1/3\. The probability
    that one of the others is, instead, is still 2/3\. But now the set of “one of
    the others” consists of just door #2, since Monty has eliminated door #3\. You
    should switch to increase your chances of winning from 1/3 to 2/3.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种思维是错误的。最初，你的选择是赢家的概率是1/3。大家对此都同意。这意味着奖品在*其他门之一*的概率是2/3。由于奖品一定在某个地方，所以总概率必须加起来等于1。这些初始概率仍然成立。门#1是赢家的概率仍然是1/3。而其他门成为赢家的概率依然是2/3。但是现在，“其他门”这一组只包含门#2，因为蒙提已经排除了门#3。你应该切换选择，将你的获胜概率从1/3提高到2/3。
- en: This analysis is just one of many ways to approach the problem, but they all
    (if done correctly) lead to the same conclusion. Nevertheless, at this point many
    people remain unconvinced. Sometimes actually doing the experiment can persuade
    people who don’t believe in math.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析只是解决问题的众多方法之一，但它们都（如果做得正确）会得出相同的结论。然而，在这个时候，许多人仍然持怀疑态度。有时，实际上进行实验可以说服那些不相信数学的人。
- en: 'The following program performs just such an experiment—a simple example of
    a simulation using a random process:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序就执行了这样的实验——一个使用随机过程的简单模拟示例：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program plays the game `N` times, where `N` is set to 3,000\. It stores
    the record of wins or losses in two arrays, one for the set of 3,000 plays where
    the player stays with the initial choice of door and one for the round where the
    player decides to switch. The arrays are initialized to be all 0s. If the player
    wins game number `game`, that array element is changed to 1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序玩`N`次游戏，其中`N`设为3,000。它将胜负记录存储在两个数组中，一个是玩家保持初始选择的3,000次游戏记录，另一个是玩家决定切换的回合记录。数组初始化为全0。如果玩家在第`game`局获胜，则该数组元素会变为1。
- en: The two arrays ➊ hold the running average of each strategy, defined using list
    comprehensions. These are the arrays we want to look at.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数组➊保存了每种策略的运行平均值，这是通过列表推导式定义的。这些就是我们要查看的数组。
- en: The plot in [Figure 10-2](ch10.xhtml#ch10fig2) shows that in the long run the
    switching strategy wins 2/3 of the time, while the player who stubbornly sticks
    with the initial choice wins only 1/3 of the time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-2](ch10.xhtml#ch10fig2)中的图表显示，从长远来看，切换策略获胜的概率为2/3，而固执地坚持初始选择的玩家仅获胜1/3的时间。'
- en: '![Image](../images/ch10fig02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig02.jpg)'
- en: '*Figure 10-2: Two Monty Hall strategies*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：两种蒙提霍尔策略*'
- en: 'These ratios agree with the argument if we remember the meaning of the frequency
    interpretation of probability: over the long run, the ratio of events (wins, in
    this case) to the total number of experiments should approach the probability.
    Note that if you run this code yourself, the graph may look slightly different,
    because you’ll get a different sequence of random numbers, but the *long-term
    behavior* should be the same.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记住概率的频率解释的含义，这些比例与论点一致：从长远来看，事件（在本例中是获胜）的比率与总实验次数的比率应该接近概率。请注意，如果你自己运行这段代码，图表可能会略有不同，因为你会得到不同的随机数序列，但*长期行为*应该是相同的。
- en: '**Counting**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计数**'
- en: After probability, the next most important idea in statistics is *counting*,
    also called *combinatorics*. Counting has to do with answering questions about
    how many ways an event can happen. If you roll a pair of dice, in how many ways
    can the sum of the two numbers that come up equal six? If there are 30 people
    on the squad, how many nine-person baseball teams are possible?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在概率之后，统计学中下一个最重要的概念是*计数*，也叫做*组合数学*。计数与回答一个事件有多少种发生方式相关。如果你投掷一对骰子，骰子上的两个数字加起来等于六的方式有多少种？如果队伍中有30人，那么有多少种可能的九人棒球队？
- en: When simulating systems involving probability on a computer, to calculate correctly
    the probabilities of various events, we often *count* the number of ways a given
    event can happen and divide by the total number of all possibilities. If all of
    the ways are equally likely, this gives us the probability.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上模拟涉及概率的系统时，为了正确计算各种事件的概率，我们通常会*计数*某个事件发生的方式数，并除以所有可能性中的总数。如果所有方式的可能性相等，这就给出了概率。
- en: In the dice example, there are 10 ways to get a sum of six, so the probability
    is 10/36.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在掷骰子的例子中，得到和为六的方式有10种，所以概率是10/36。
- en: 'Two additional counting concepts arise frequently when dealing with probabilistic
    situations, and often in other places as well: *permutations*, calculated using
    factorials, and *combinations*, which involve binomial coefficients.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理概率问题时，另外两个计数概念经常出现，通常在其他地方也会用到：*排列*（通过阶乘计算）和*组合*（涉及二项式系数）。
- en: '***Factorials***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***阶乘***'
- en: 'The first counting concept is the idea of *permutations*: the number of distinct
    ways to arrange a collection of objects. If you have eight *Scrabble* tiles, all
    bearing different letters, how many different eight-letter strings can you make
    out of them?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个计数概念是*排列*：排列一组物体的不同方式的数量。如果你有八个*拼字游戏*字母牌，每个字母都不同，那么你能从中组成多少种不同的八个字母的字符串呢？
- en: The answer is 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40, 320.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40, 320。
- en: 'Here’s a quick argument to show why this is true: there are eight ways to choose
    the first tile; once that is chosen, there are seven ways to choose the next tile;
    and so on. This pattern comes up so often that we have a special name and mathematical
    notation for it. It is called the *factorial*, and it’s written as 8! in this
    case. Julia also has a built-in function for it, but since `!` is used for other
    purposes, we need to spell it out: `factorial(8)`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的论证，展示为什么这个是正确的：选择第一个字母牌有八种方式；一旦选定了第一个字母牌，选择下一个字母牌有七种方式；依此类推。这个模式出现得非常频繁，以至于我们为它赋予了一个特殊的名称和数学符号，它叫做*阶乘*，在这种情况下写作
    8!。Julia 也有一个内置函数处理它，但由于 `!` 被用于其他目的，我们需要把它写为：`factorial(8)`。
- en: The factorial function grows insanely quickly, so above `factorial(20)`, you
    need to supply the argument as a `BigInt`, and you’ll get a `BigInt` back. How
    quickly does the factorial grow? The number of ways to arrange a standard 52-card
    deck is far larger than the number of stars in the universe. It’s so large that,
    after shuffling a deck, there is almost no chance that the particular arrangement
    of cards you are holding in your hand has existed before in the history of the
    world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数增长得非常快，因此在 `factorial(20)` 以上，你需要将参数作为 `BigInt` 提供，并且返回值也是 `BigInt`。阶乘增长的速度有多快？标准的52张扑克牌的排列方式的数量远大于宇宙中的星星数量。它大到一个程度，以至于洗牌后，你手中的扑克牌排列几乎不可能在世界历史上曾经出现过。
- en: '***Binomial Coefficients***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二项式系数***'
- en: 'The second combinatorial concept we’ll be using is the *binomial coefficient*.
    This comes up in many mathematical contexts, and Julia has a built-in function
    called `binomial()` that deals with it. In the context of counting, the binomial
    coefficient answers the baseball teams question mentioned earlier. If there are
    30 players available, the number of ways to form nine-member teams is written
    as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第二个组合概念是*二项式系数*。这个概念在许多数学场合都会出现，Julia 中有一个内置函数 `binomial()` 用于处理它。在计数的上下文中，二项式系数回答的是前面提到的棒球队问题。如果有30个可用的球员，那么组成九人小队的方式数量可以写作：
- en: '![Image](../images/313math.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/313math.jpg)'
- en: The baseball problem is calculated with `binomial(30, 9)`. The combinatorial
    term for these problems, involving binomial coefficients, is *combinations*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 棒球问题通过 `binomial(30, 9)` 计算。涉及二项式系数的这些问题的组合学术语是*组合*。
- en: 'See “Further Reading” on [page 359](ch10.xhtml#fur10) to learn more details
    about binomial coefficients: why they are so named, how to calculate them using
    factorials, and their connections to other areas of mathematics.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第359页](ch10.xhtml#fur10)的“进一步阅读”，了解更多关于二项式系数的细节：为什么它们这样命名，如何通过阶乘计算它们，以及它们与其他数学领域的联系。
- en: '**Modeling a Pandemic**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流行病建模**'
- en: We now have enough tools to perform a significant calculation. [Listing 10-2](ch10.xhtml#ch10lis2)
    is a simulation that models the spread of an infection through a population. It’s
    similar to models epidemiologists use to perform computational experiments with
    different scenarios for the spread of COVID-19\. This model is a bit simplified
    relative to those, as my purpose is to illustrate an application of the tools
    and ideas from the chapter so far. For a pointer to similar models being used
    now in research, see “Further Reading.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的工具来进行一个重要的计算。[清单 10-2](ch10.xhtml#ch10lis2)是一个模拟，模拟了感染在人群中的传播。这类似于流行病学家用来进行计算实验的模型，研究不同的COVID-19传播情景。这个模型相较于那些稍显简化，因为我的目的是展示目前章节中的工具和思想的应用。有关现在研究中使用的类似模型，请参阅“进一步阅读”。
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-2: A pandemic simulation*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-2：一场大流行模拟*'
- en: 'The strategy is to represent the population as a square matrix. Each cell represents
    one person and can be in one of four possible states: `infected`, `dead`, `isolated`,
    or `ok`. An `isolated` person can’t become `infected`. An `ok` person is not `infected`,
    but may become so. An `infected` person may die after a certain number of “days,”
    or iterations, a number assigned to `dud`; if the person survives past this period,
    immortality is achieved. A `dead` person is no longer infectious. Thus, an `ok`
    person can never be infected (is “protected”) if surrounded by `dead` or `isolated`
    people. Death and lockdown prevent the spread of the disease.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略是将人口表示为一个方阵。每个单元格代表一个人，并且可以处于四种可能的状态之一：`infected`、`dead`、`isolated` 或 `ok`。一个
    `isolated` 的人无法变为 `infected`。一个 `ok` 的人没有被感染，但可能会感染。一个 `infected` 的人在经过一定天数（或迭代次数）后可能会死亡，这个天数由
    `dud` 参数赋值；如果此人活过了这一阶段，则达到了不死之身。一个 `dead` 的人不再具有传染性。因此，如果一个 `ok` 的人被 `dead` 或
    `isolated` 的人包围，那么他将永远不会被感染（处于“保护”状态）。死亡和隔离能防止疾病的传播。
- en: The simulation is initialized with probabilities, to establish both the starting
    state and its evolution. The state at `day = 1` is set up using the probabilities
    in the `initial` dictionary ➊. At every iteration, the state of each person is
    updated according to the probabilities in the `transition` dictionary on the following
    line and the value of `dud` in that dictionary, which is the number of days during
    which someone needs to be infected before the disease may become fatal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是通过概率初始化的，用以建立起起始状态和其演变过程。`day = 1` 时的状态是通过 `initial` 字典中的概率来设置的 ➊。在每一次迭代中，根据
    `transition` 字典中的概率以及字典中的 `dud` 值（它表示在疾病可能致命之前，个体需要感染多少天）来更新每个人的状态。
- en: The population matrix is called `world`, and the length of its side is stored
    in `n`. Don’t take the matrix geometry too literally. It does not assume that
    people stand in one spot while the disease runs its course. The matrix `world`
    represents a network of contact rather than a spatial arrangement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 人口矩阵被称为 `world`，其边长存储在 `n` 中。不要太字面理解矩阵几何结构。它并不假设人们在某一地点静止不动，直到疾病发展完毕。矩阵 `world`
    代表的是接触网络，而不是空间排列。
- en: 'After importing some libraries that you have seen before and including a file
    with the plotting function, which we’ll get to later, the `pandemic()` function,
    which does the actual calculation, is defined. This function gets two keyword
    arguments: `seeding` should be either `:normal` or `:center`. In the former case,
    infection is seeded randomly, according to `initial["infected"]`; but if `seeding`
    is set to `:center`, a single infected individual is placed at the center of the
    world.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入一些你之前见过的库并包含一个绘图函数文件后（我们稍后会介绍），`pandemic()` 函数被定义出来，这个函数执行实际的计算。该函数接收两个关键字参数：`seeding`
    应该是 `:normal` 或 `:center`。在前者的情况下，感染是随机播种的，根据 `initial["infected"]` 来进行；但如果 `seeding`
    设置为 `:center`，则会在世界的中心放置一个感染个体。
- en: The second keyword, `plotmode`, controls whether daily plots are created, and
    if so, whether they are displayed or saved to files. At the end of the calculation,
    the `finish()` function is called, which saves a plot of the final state if the
    `plotmode` = `:last`. This function also uses the `@save` macro to save the `world`
    and the infection and death histories to a *.jld* file (introduced in [Chapter
    9](ch09.xhtml)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键字 `plotmode` 控制是否创建每日的图表，如果创建，图表是显示出来还是保存到文件中。在计算结束时，调用 `finish()` 函数，如果
    `plotmode` = `:last`，该函数会保存最终状态的图表。此函数还使用 `@save` 宏将 `world` 以及感染和死亡历史保存到一个 *.jld*
    文件中（该功能在[第9章](ch09.xhtml)中介绍）。
- en: At every iteration, the program has to decide, for each `ok` person, whether
    to change that person to the `infected` state. This is determined randomly, based
    on the probability of infection by each infected neighbor each day, given in `transition["infected"]`,
    and on the number of infected neighbors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，程序必须决定对于每个 `ok` 的人，是否将其状态更改为 `infected`。这个决定是随机的，基于每天每个感染邻居的感染概率（在 `transition["infected"]`
    中给出）以及感染邻居的数量。
- en: But, we need to be careful here. The probability of infection with two infected
    neighbors is not twice the probability of infection with only a single sick neighbor.
    We need to subtract the probability of becoming infected by both neighbors. We
    won’t provide a full treatment of the combination of events in probability theory
    here, but you likely can easily see why we can’t simply add the probabilities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要小心。两个感染者邻居的感染概率并不是单个感染邻居概率的两倍。我们需要减去同时被两个邻居感染的概率。这里我们不会全面讨论概率论中事件组合的内容，但你很可能能轻松理解为什么我们不能简单地将这些概率相加。
- en: 'Imagine you are flipping two coins and want to find the probability of getting
    at least one head. You know that the probability of a head with either coin alone
    is 1/2\. If you add those, you get a probability of 1\. But that can’t be right,
    because it would mean a head *must* appear, and you know there’s a good chance
    you’ll get two tails. The correct calculation includes subtracting the probability
    of *two* heads: 1/2 + 1/2 *–* 1/4 = 3/4\. You will get at least one head three-fourths
    of the time in the long run. At this point, you are in a good position to write
    a little Julia program to verify this, if you have any doubts.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在掷两个硬币，并想要找出至少有一个正面的概率。你知道，单个硬币正面的概率是1/2。如果你将这两个概率相加，你得到的总概率是1。但这显然不对，因为这意味着正面一定会出现，而你知道两枚硬币出现两个反面的可能性也很大。正确的计算应该减去两个正面同时出现的概率：1/2
    + 1/2 *–* 1/4 = 3/4。在长时间内，你至少会得到一个正面的概率是四分之三。此时，如果你有任何疑问，你已经处于一个良好的位置，可以编写一个简单的Julia程序来验证这一点。
- en: 'The coin problem corresponds exactly to the case where you are in contact with
    two infected people and the probability of infection = 1/2\. On the grid, however,
    each person can have up to eight neighbors. It’s a bit more complicated than the
    case of two neighbors, but the idea is the same. For each new neighbor, you have
    to add the probability of infection by that neighbor, but subtract all the combinations
    it can make with the other neighbors. The word *combinations* suggests that we
    might have to reach for a binomial coefficient, and indeed we do. The formula
    for the total probability of infection by *n* neighbors, if the probability of
    infection by a single neighbor is *p*, is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币问题正好对应于你与两个感染者接触，感染的概率 = 1/2。在网格上，每个人最多可以有八个邻居。这比两个邻居的情况要复杂一些，但思想是一样的。对于每一个新邻居，你需要增加该邻居导致的感染概率，但要减去它与其他邻居之间所有可能的组合。*组合*这个词暗示着我们可能需要使用二项式系数，事实上，确实需要。若一个邻居的感染概率为*p*，*n*个邻居的总感染概率公式为：
- en: '![Image](../images/317math.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/317math.jpg)'
- en: See “Further Reading” on [page 359](ch10.xhtml#fur10) for more about this formula
    and related matters. This probability is pre-calculated for all possible numbers
    of neighbors, `1:8`, and the results are stored in the `tpi` ➋ array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[第359页](ch10.xhtml#fur10)的“进一步阅读”，了解有关此公式及相关问题的更多信息。这个概率已经为所有可能的邻居数量`1:8`进行了预计算，结果存储在`tpi`➋数组中。
- en: It is necessary, before each iteration’s calculations begin, to make a copy
    of the `world` array, which is called `next` in the program ➌. We update the cells
    in `next`, and then copy it back into `world`. If `world` is updated in place,
    cells will be transitioned based on the partially updated information in neighbor
    cells, which would be inconsistent. A `copy` is required, as we’ve encountered
    in previous chapters, because a simple `next = world` would create a second reference
    to the array rather than an actual copy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代的计算开始之前，有必要先复制`world`数组，在程序中将其命名为`next` ➌。我们更新`next`中的单元格，然后将其复制回`world`。如果直接在`world`上更新，单元格将根据邻居单元格中部分更新的信息进行过渡，这将导致不一致。因此，需要进行`copy`，正如我们在前面的章节中遇到的那样，因为简单地使用`next
    = world`会创建对数组的第二个引用，而不是实际的复制。
- en: An array `aoi` is initialized to 0s ➍; it will record the `day` on which each
    person becomes infected, so that the survival probability can be applied at the
    appropriate time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`aoi`初始化为0➍；它将记录每个人感染的`day`，以便在适当的时候应用生存概率。
- en: The subsequent loops over persons within the loop over days, given all the foregoing,
    should be self explanatory. After the sweep of the matrix, we `push!()` ➎ new
    values for the current total number of infected and dead people onto the vectors
    `noi` and `nod`, respectively. Julia’s neat and succinct syntax calculates these
    totals using a sum over a binary array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了前述内容后，随后的循环将在天数的循环内进行人员遍历，应该不言自明。在矩阵扫描后，我们将`push!()` ➎ 当前感染和死亡人数的新值分别推送到向量`noi`和`nod`中。Julia
    简洁明了的语法通过对二进制数组求和来计算这些总数。
- en: Here, and in the previous loops over the `world`, the program treats only elements
    in `2:n-1` rather than the entire array, to implement the boundary condition.
    In keeping one row or column of cells on the boundaries “frozen,” the updating
    logic is simplified, as the expression, for example, for calculating the number
    of each person’s infected neighbors is identical for each nonfrozen person.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里以及前面的 `world` 循环中，程序仅处理`2:n-1`范围内的元素，而不是整个数组，以实现边界条件。通过将边界上的一行或一列“冻结”，更新逻辑简化了，例如，计算每个人感染邻居数量的表达式对于每个非冻结的人来说是相同的。
- en: As in a physics problem, there are other possibilities for boundary conditions.
    The people on the edges could be updated based on their reduced numbers of neighbors,
    but doing so can induce artifacts. Periodic boundary conditions are another possibility,
    where the neighbor-ness wraps around the matrix to the opposite side. Any choice
    is to some degree arbitrary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 像物理问题一样，边界条件还有其他可能性。边缘上的人们可以根据邻居数量的减少来更新，但这样做可能会引入伪影。周期性边界条件是另一种可能性，在这种条件下，邻居关系会绕过矩阵并连接到对面一侧。任何选择在某种程度上都是任意的。
- en: The conditional block ➏ checks to see whether the calculation has reached a
    steady state. If it has, there is no point in continuing, and the cleanup operation
    is called. The final line in the program starts the calculation by calling `pandemic()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 条件块 ➏ 会检查计算是否已经达到了稳态。如果已经达到了稳态，就没有必要继续计算，随后会调用清理操作。程序的最后一行通过调用`pandemic()`来启动计算。
- en: This simple algorithm can produce interesting behavior, and it can be used to
    explore questions such as the effect of lockdown conformity on the spread of the
    infection, and how a higher fatality rate can slow the growth of a pandemic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的算法可以产生有趣的行为，并且可以用来探索诸如封锁遵守对感染传播的影响，以及更高的致死率如何减缓疫情增长等问题。
- en: '[Figure 10-3](ch10.xhtml#ch10fig3) shows the output of a 512×512 simulation
    with these initial and transition probabilities:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](ch10.xhtml#ch10fig3)展示了一个 512×512 的模拟输出，初始和过渡概率如下：'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The simulation stops after 1,064 iterations when reaching a steady state. The
    notation on the figure means that 5.48 percent of the population was protected
    from infection due to the isolation of others and the effects of mortality interrupting
    disease transmission.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟在进行 1,064 次迭代后停止，达到了稳态。图中的标注意味着由于他人的隔离和死亡率的作用，有 5.48% 的人群免受感染。
- en: '![Image](../images/ch10fig03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig03.jpg)'
- en: '*Figure 10-3: Steady state reached in a pandemic simulation*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：疫情模拟中的稳态*'
- en: See the book’s supplementary website ([*https://julia.lee-phillips.org*](https://julia.lee-phillips.org))
    for a color version of the plot and an animation of a similar simulation. In the
    printed grayscale version, the darkest shades on the heatmap plot represent dead
    or infected people, white represents people who remained protected from infection,
    and the middle tone corresponds to isolated people.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问本书的补充网站（[*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)），查看彩色版本的图表和类似模拟的动画。在打印的灰度版中，热图中最深的颜色代表死亡或感染的人，白色代表那些保持免疫的人群，中间的颜色表示被隔离的人。
- en: '[Listing 10-3](ch10.xhtml#ch10lis3) shows the simple function that calculates
    the protected percentage and makes plots as in [Figure 10-3](ch10.xhtml#ch10fig3).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-3](ch10.xhtml#ch10lis3)展示了一个简单的函数，该函数计算保护百分比并绘制如[图 10-3](ch10.xhtml#ch10fig3)所示的图表。'
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-3: Visualizing the pandemic*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：疫情可视化*'
- en: The `plotworld()` function uses the `@sprintf` macro ➊, introduced in “Macros
    for String Formatting” on [page 177](ch06.xhtml#ch06sec1sec11), to format the
    variable `protected` and the y-axis label for display. After creating three plots
    and storing them in `p1`, `p2`, and `p3`, the `@layout` macro, described in “Creating
    Complex Layouts Using @layout” on [page 118](ch04.xhtml#ch04lev1sec28), arranges
    them ➋ into a summary display of the simulation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotworld()`函数使用`@sprintf`宏 ➊，该宏在“字符串格式化宏”一节中介绍，[第177页](ch06.xhtml#ch06sec1sec11)，用于格式化变量`protected`和y轴标签进行显示。在创建了三个图并将其存储在`p1`、`p2`和`p3`中后，`@layout`宏，在“使用@layout创建复杂布局”一节中介绍，[第118页](ch04.xhtml#ch04lev1sec28)，将它们
    ➋ 安排成一个模拟结果的汇总展示。'
- en: '**Common Statistics Functions**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常见统计函数**'
- en: Julia provides functions to calculate all of the common statistical parameters,
    as well as special plotting functions for statistical visualization of data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了计算所有常见统计参数的函数，以及用于数据统计可视化的特殊绘图函数。
- en: Some reorganization of the Julia statistics packages is underway, so everything
    may not be where you might expect it. This section describes where the packages
    are at the time of writing, but, when you try things out, you may discover that
    a function or two have moved.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Julia统计包正在进行一些重组，因此可能有些内容不在你预期的位置。本节描述了在写作时这些包的位置，但当你实际尝试时，可能会发现某些函数已经移动。
- en: If you are analyzing data of any kind, you will make heavy use of at least some
    of the functions described in this section, most of which are in the `Statistics`
    package, which is part of the standard Julia library. In the remainder of this
    chapter, I will assume you’ve imported the package with the `using Statistics`
    command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在分析任何类型的数据，你将大量使用本节描述的至少部分函数，其中大多数位于`Statistics`包中，该包是Julia标准库的一部分。在本章的其余部分，我假设你已经使用`using
    Statistics`命令导入了该包。
- en: The package provides the basic functions that summarize datasets with statistical
    parameters. For the *mean*, or arithmetic average, use `mean(`data`)`, where,
    here and below, data is some vector of observations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该包提供了总结数据集的基本函数，利用统计参数来进行描述。对于*均值*，或算术平均值，使用`mean(data)`，其中这里和下面的数据是一些观察值的向量。
- en: 'For the *median*, which is the middle value in the data, use `median(`data`)`.
    If there are an even number of data points, none of them can be the middle value.
    In this case, `median()` returns the mean of the two middle values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*中位数*，即数据中的中间值，使用`median(data)`。如果数据点数目为偶数，则没有一个数据点是中间值。在这种情况下，`median()`返回两个中间值的均值：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the time of writing, `Statistics` does not contain a *mode* function. The
    mode is the most common value, or the maximum of a continuous distribution, if
    it exists. From this idea come the terms *bimodal* and *multimodal* to describe
    distributions with more than one local maximum. The height distribution in [Figure
    10-4](ch10.xhtml#ch10fig4) is an example of a bimodal distribution.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，`Statistics`包不包含*众数*函数。众数是最常见的值，或者是连续分布的最大值（如果存在）。从这个概念出发，产生了*bimodal*和*multimodal*这两个术语，用来描述具有多个局部最大值的分布。[图10-4](ch10.xhtml#ch10fig4)中的身高分布就是一个双峰分布的例子。
- en: If you need a mode function, you can import it from another package called `StatsBase`,
    which you will need to `add`. `StatsBase` contains some other less commonly used
    statistical functions that are not in the standard `Statistics` package, but you
    may want to import only the ones you plan to use. If you just need to add a mode
    function to your toolbox, you can enter `import` `StatsBase.mode`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个众数函数，你可以从另一个名为`StatsBase`的包中导入它，你需要先`add`该包。`StatsBase`包含一些不常用的统计函数，这些函数不在标准的`Statistics`包中，但你可以只导入计划使用的那些。如果你只需要将众数函数添加到工具箱中，可以输入`import`
    `StatsBase.mode`。
- en: 'Here are a few examples showing how the `mode()` function behaves:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是几个示例，展示了`mode()`函数的行为：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If there is more than one mode, the function returns the first one. Consequently,
    if each value appears only once, they are all modes, so the function returns the
    first value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个众数，函数返回第一个众数。因此，如果每个值仅出现一次，它们都是众数，所以函数返回第一个值。
- en: 'The standard `Statistics` package contains most of the other basic statistical
    functions, including the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 标准`Statistics`包包含大多数其他基本统计函数，包括以下内容：
- en: std  Standard deviation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: std  标准差
- en: stdm  Standard deviation with specified mean
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: stdm  具有指定均值的标准差
- en: var  Variance
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: var  方差
- en: varm  Variance with specified mean
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: varm  具有指定均值的方差
- en: cor  Pearson correlation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: cor  皮尔逊相关系数
- en: cov  Covariance
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: cov  协方差
- en: middle  (max + min) / 2
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数  (最大值 + 最小值) / 2
- en: quantile  Quantile
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 分位数  分位数
- en: These commands work on vectors or pairs of vectors of data in the way you would
    expect. In addition, the `cor()` function will accept a matrix and return a correlation
    matrix, and the `cov()` function can work similarly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令适用于向量或数据对，操作方式与预期一致。此外，`cor()`函数可以接受一个矩阵并返回一个相关矩阵，`cov()`函数也可以以类似方式工作。
- en: 'The `mean()` function takes an optional first argument that can be a unary
    operator or a function of one numeric variable. The function then maps the operator
    or function over the data vector before calculating the mean. This can be convenient
    if you need to scale or otherwise process the data, but, for the case of a simple
    vector, it gives the same result as broadcasting the function over the array:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean()`函数接受一个可选的第一个参数，它可以是一个一元运算符或一个单一数值变量的函数。然后该函数会将运算符或函数映射到数据向量上，再计算均值。如果需要对数据进行缩放或其他处理，这样做会很方便，但对于简单向量的情况，它给出的结果与将函数广播到数组上的结果相同。'
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are two versions of the standard deviation and the variance used in statistics.
    The formula the `var()` function uses by default is
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学中使用标准差和方差有两个版本。`var()`函数默认使用的公式是
- en: '![Image](../images/321math.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/321math.jpg)'
- en: where *μ* is the mean, the *x*[*n*] values are individual data points, *N* is
    the total number of data points, and *σ*² is the *sample variance*, or the variance
    with Bessel’s correction applied. The standard deviation `std()` is just the positive
    square root of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*μ*是均值，*x*[*n*] 是单个数据点，*N*是数据点的总数，*σ*²是*样本方差*，即应用了贝塞尔修正的方差。标准差`std()`只是其正平方根。
- en: In order to calculate the *population variance* and *population standard deviation*,
    supply the keyword argument `corrected` with a value of `false` to either of these
    functions. This will replace the 1/(*N –* 1) term in the formula with 1/*N*. Explaining
    the origin of the correction would take us too far into the arcana of statistical
    theory, but for most purposes, the defaults are what you want, and it makes little
    difference for reasonably large *N* in any case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算*总体方差*和*总体标准差*，需要将关键字参数`corrected`设置为`false`，然后传递给这两个函数中的任意一个。这将把公式中的 1/(*N
    –* 1) 项替换为 1/*N*。解释这个修正的来源会让我们进入统计理论的深奥领域，但对于大多数用途而言，默认值是你想要的，而且无论如何对于合理大的*N*来说几乎没有区别。
- en: In either incarnation, the standard deviation is a measure of the average distance
    from the mean of a set of observations or of a theoretical distribution. It tells
    us how “spread out” the distribution is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种情况，标准差都是一个衡量观察值或理论分布的平均距离的度量。它告诉我们分布的“分散程度”。
- en: '**Distributions**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分布**'
- en: We’ve looked at several examples of how we can do a lot with simple, uniformly
    distributed random numbers. However, not every random occurrence is uniformly
    distributed. Most things in nature display other types of distributions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了几个例子，展示了如何利用简单的、均匀分布的随机数做很多事情。然而，并非所有随机现象都是均匀分布的。大多数自然现象显示的是其他类型的分布。
- en: 'Consider the heights of adults in a particular city. Obviously, you don’t expect
    that the probability of finding a 7-foot-tall adult is the same as finding one
    with closer to average height: heights are not uniformly distributed. If you make
    a graph, dividing the horizontal axis into height ranges covering, say, intervals
    of 2 inches, and collect the heights of a sample of residents, you can plot how
    many heights fall into each interval. After collecting a large number of measurements,
    this plot will start to look like a smooth curve, something like [Figure 10-4](ch10.xhtml#ch10fig4).
    It has two peaks, because the average height of men is a little higher than women,
    and it shows that there are more people close to the average than very tall or
    very short.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们考虑某个特定城市成年人的身高。显然，你不会期望发现一个身高7英尺的成年人和发现一个身高接近平均值的成年人有相同的概率：身高并不是均匀分布的。如果你绘制一个图表，将横坐标划分为例如每2英寸为一个区间，并收集一部分居民的身高数据，你就可以绘制出每个区间内的身高数量。收集了大量测量数据后，这个图表将开始看起来像一条平滑的曲线，类似于[图10-4](ch10.xhtml#ch10fig4)。它有两个峰值，因为男性的平均身高略高于女性，并且它显示出身高接近平均值的人比非常高或非常矮的人要多。
- en: '![Image](../images/ch10fig04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig04.jpg)'
- en: '*Figure 10-4: Possible histogram of adult heights*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：成年人口身高的可能直方图*'
- en: This type of graph is called a *histogram*; it is one way to represent a *distribution*.
    Probability distributions are the mathematical objects at the center of statistics,
    just as a probability forms, naturally, the central idea of probability theory.
    A distribution simply tells you how much of your data, or what proportion of your
    data, falls within different ranges. As a description of actual data it’s called
    an *empirical distribution*, whereas if it comes from a model it’s a *theoretical
    distribution*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的图叫做*直方图*；它是表示*分布*的一种方式。概率分布是统计学中最核心的数学对象，就像概率在概率论中自然地形成了核心概念一样。分布简单地告诉你数据中有多少，或者数据中有多少比例落在不同的区间内。作为实际数据的描述，它被称为*经验分布*，而如果它来自一个模型，则是*理论分布*。
- en: 'You can think of the discipline of statistics this way: probabilities tell
    us how likely something is to happen, and the mathematics of probability theory
    lets us elaborate this, telling us the likelihood of combinations of events and
    answering related questions. Statistics is the reverse: it starts with observations,
    and lets us systematically infer the probabilities that led to those observations.
    With these probabilities, we can make predictions about future observations.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样理解统计学：概率告诉我们某件事情发生的可能性，而概率论的数学让我们进一步阐明这一点，告诉我们事件组合发生的可能性，并回答相关问题。统计学则恰恰相反：它从观察开始，系统地推断出导致这些观察结果的概率。有了这些概率，我们可以对未来的观察做出预测。
- en: Julia provides several packages and a great number of functions for helping
    out with statistics, including functions for statistical graphing. To produce
    a histogram like the one shown in [Figure 10-4](ch10.xhtml#ch10fig4), simply call
    (after `using Plots`) `histogram(data, bins = 100)`. The `data` in this call is
    the actual series of observations; the `bins` tells the routine to use that number
    of intervals to construct the histogram. For each interval, it will count the
    number of observations in `data` and draw the rectangle at the appropriate height.
    The area of each rectangle represents the number of observations in the horizontal
    axis interval that it covers. Beware that the same dataset may produce very different
    plots when choosing different numbers of bins; some choices will better reflect
    the underlying distribution than others. If you leave out the `bins` argument,
    the `histogram()` routine will attempt to choose the “best” value, using a formula
    from statistical theory that is designed to best represent the data. This formula
    does not always work perfectly, so the careful scientist or statistician will
    always be aware of the nature of the data being plotted, and intervene manually
    if necessary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了多个包和大量函数来帮助进行统计分析，包括用于统计绘图的函数。要生成如[图10-4](ch10.xhtml#ch10fig4)所示的直方图，只需在`using
    Plots`之后调用`histogram(data, bins = 100)`。此调用中的`data`是实际的观测数据系列；`bins`告诉程序使用该数量的区间来构建直方图。对于每个区间，它会统计`data`中的观测值数量，并在适当的高度绘制矩形。每个矩形的面积表示其覆盖的水平轴区间中的观测值数量。请注意，选择不同的区间数可能会生成非常不同的图形；有些选择会比其他选择更好地反映底层分布。如果你省略了`bins`参数，`histogram()`函数会尝试选择“最佳”值，使用来自统计理论的公式，这些公式旨在最准确地表示数据。但这个公式并不总是完美有效，因此谨慎的科学家或统计学家会始终关注绘制的数据的性质，并在必要时手动干预。
- en: '***The Normal Distribution***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正态分布***'
- en: Consider the `rand()` function described earlier in this chapter. Since it generates
    a floating-point number that is equally likely to be anywhere in the interval
    from 0 to 1, the mean value of the numbers it returns should be 0.5\. The number
    is just as likely to be greater than 0.5 as to be smaller than that midpoint.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑本章前面提到的`rand()`函数。由于它生成的浮点数在0到1的区间内等概率地出现，因此它返回的数字的平均值应该是0.5。这个数字大于0.5的概率和小于0.5的概率是一样的。
- en: 'This means if you call `rand()` many times, and calculate the mean of the results,
    you should get something fairly close to 0.5: `mean(rand(1000))` should be approximately
    0.5\. I did it just now and got 0.49869515604579906\. Intuitively, you may expect
    if you use a number smaller than 1,000, the mean is more likely to be farther
    from 0.5, and that is correct.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你多次调用`rand()`并计算结果的平均值，你应该得到一个接近0.5的值：`mean(rand(1000))`应该大约是0.5。我刚才做了一次，得到的结果是0.49869515604579906。直观上，你可能会预期，如果使用小于1000的数字，平均值更可能远离0.5，这种预期是正确的。
- en: But even using 1,000 numbers, the mean will rarely be exactly 0.5\. Since (unless
    you reset the seed) you will get a different set of random numbers each time,
    the mean will be different each time, as well. The numbers themselves, as you
    know, are uniformly distributed in [0, 1). If you call `mean(rand(1000))` many
    times, how will the *means* be distributed?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使使用 1,000 个数字，均值也很少能恰好为 0.5。因为（除非你重置了种子）每次你都会得到一组不同的随机数，所以每次的均值也会不同。你知道，这些数字在[0,
    1)之间均匀分布。如果你多次调用`mean(rand(1000))`，这些*均值*将如何分布呢？
- en: You know they can’t be distributed uniformly, because they are more likely to
    be near 0.5 than far from it. But what exactly is the distribution of the means?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道它们不可能均匀分布，因为它们更可能接近 0.5 而不是远离它。那么，*均值*的分布究竟是什么样的呢？
- en: Let’s write a little program to find out. Even those who have studied statistics
    and know what to expect may find the numerical experiment in [Listing 10-4](ch10.xhtml#ch10lis4)
    interesting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个小程序来找出答案。即使是那些学过统计学并知道预期结果的人，也可能会发现[列表 10-4](ch10.xhtml#ch10lis4)中的数值实验很有趣。
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-4: Exploring the distribution of the mean*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-4：探索均值的分布*'
- en: The program is a straightforward calculation of the `N` means of 1,000 random
    numbers. To see how these means are distributed, we turn to the `histogram()`
    plotting function introduced earlier in the chapter. The purpose of this function
    is exactly to display distributions. The `"Empirical"` label indicates that the
    histogram is the result of a numerical experiment. [Figure 10-5](ch10.xhtml#ch10fig5)
    shows the result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是对 1,000 个随机数的 `N` 个均值的直接计算。为了查看这些均值如何分布，我们使用本章早些时候介绍的`histogram()`绘图函数。这个函数的目的正是展示分布。`"Empirical"`标签表示该直方图是数值实验的结果。[图
    10-5](ch10.xhtml#ch10fig5)展示了结果。
- en: '![Image](../images/ch10fig05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig05.jpg)'
- en: '*Figure 10-5: Distribution of the mean of uniform random numbers*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：均匀随机数的均值分布*'
- en: Obviously, the distribution of the means is not uniform. As we expect, it shows
    that means closer to 0.5 are more frequent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，均值的分布不是均匀的。正如我们预期的那样，均值接近 0.5 的情况更为频繁。
- en: In fact, from a central result in probability theory, we can predict the precise
    mathematical form of this distribution. It should be
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，基于概率论中的一个核心结果，我们可以预测这个分布的精确数学形式。它应该是
- en: '![Image](../images/324math.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/324math.jpg)'
- en: where *x* is the random variable whose distribution we are describing, *σ* is
    the standard deviation, and *μ* is the mean.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x* 是我们正在描述分布的随机变量，*σ* 是标准差，*μ* 是均值。
- en: This is the equation for the famous *normal distribution*, also called the *Gaussian*.
    Does it describe the empirical distribution from the program? We don’t need to
    translate the equation into code to find out. This distribution is so crucial,
    it’s included in the second most important Julia package for statistical work,
    `Distributions`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是著名的*正态分布*方程，也叫*高斯分布*。它描述了程序中的经验分布吗？我们不需要将方程转换为代码来找出答案。这个分布如此关键，以至于它被包含在了统计工作中第二重要的
    Julia 包 `Distributions` 中。
- en: Once you import this package into your namespace, the function `Normal`(μ, σ)
    creates a normal distribution with a mean of μ and a standard deviation of σ.
    You can interact with the distribution by sampling from it using the `rand()`
    function. For example, if you create a normal distribution with a mean of 10 and
    a standard deviation of 2 with `d = Normal(10, 2)`, you can draw 10 samples from
    it with `rand(d, 10)`. Calling `rand()` without supplying an explicit distribution,
    as we’ve been doing up to now, uses the uniform distribution by default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将这个包导入到命名空间中，`Normal(μ, σ)`函数将创建一个均值为 μ、标准差为 σ 的正态分布。你可以通过使用`rand()`函数从中进行采样来与分布交互。例如，如果你创建一个均值为
    10、标准差为 2 的正态分布 `d = Normal(10, 2)`，你可以用`rand(d, 10)`从中抽取 10 个样本。如果没有显式提供分布，如我们之前所做的那样，调用`rand()`默认使用均匀分布。
- en: One way to see if the empirical distribution shown is predicted by the normal
    distribution is to take a healthy sample from the normal distribution and plot
    its histogram with the previous one. To make the plot easier to see, instead of
    trying to plot two `histogram()` plots on the same graph, we can plot the second
    one using a different type of histogram display by supplying the `:scatterhist`
    series type to the normal `plot()` command. Adding the four additional lines shown
    in [Listing 10-5](ch10.xhtml#ch10lis5) to the program in [Listing 10-4](ch10.xhtml#ch10lis4)
    makes the graphical comparison that we want.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图示的经验分布是否符合正态分布的预测的一种方法是，从正态分布中抽取一个较大的样本，并将其直方图与之前的直方图进行比较。为了使图表更易于查看，我们可以通过在正态`plot()`命令中使用不同类型的直方图显示，例如提供`:scatterhist`系列类型，而不是试图在同一图表中绘制两个`histogram()`图形。将[清单
    10-5](ch10.xhtml#ch10lis5)中的四行代码添加到[清单 10-4](ch10.xhtml#ch10lis4)中的程序中，能实现我们想要的图形对比。
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-5: Sampling from the normal distribution*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5：从正态分布中抽样*'
- en: '[Figure 10-6](ch10.xhtml#ch10fig6) shows that the two distributions are close,
    as theory predicts.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-6](ch10.xhtml#ch10fig6)表明这两个分布非常接近，正如理论预测的那样。'
- en: '![Image](../images/ch10fig06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig06.jpg)'
- en: '*Figure 10-6: Comparing the empirical and theoretical distributions*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：比较经验分布与理论分布*'
- en: Note that in order to compare two histograms directly, they must have the same
    bin width, or both be normalized. In these examples, I allow the routines to compute
    the bin width automatically, knowing that for similar distributions the widths
    would be the same.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了直接比较两个直方图，它们必须具有相同的箱宽，或者都进行归一化处理。在这些示例中，我允许程序自动计算箱宽，知道对于相似的分布，宽度应该是相同的。
- en: The `Distributions` package provides many probability distributions in addition
    to the normal distribution. It also includes many functions for using these distributions,
    along with other statistical tools.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distributions` 包提供了许多概率分布，除了正态分布外，还包括许多用于使用这些分布的函数以及其他统计工具。'
- en: '***Probability Density Functions***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***概率密度函数***'
- en: 'One of those tools is `pdf()`, which stands for *probability density function*.
    This function describes the distribution in the following sense: if you integrate
    the probability density function over a certain interval, the result is the probability
    that an observation lies within that interval. In other words, the probability
    that an observation lies between *a* and *b* is the area under the distribution
    curve between *a* and *b*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个工具是 `pdf()`，即*概率密度函数*。该函数通过以下方式描述分布：如果你对某个区间内的概率密度函数进行积分，结果就是观察值落在该区间内的概率。换句话说，观察值落在*a*和*b*之间的概率，就是分布曲线在*a*和*b*之间的面积。
- en: Usually, when referring to the graph of a distribution, we mean the graph of
    its probability density function. The integral over the entire distribution must
    exist and be equal to 1, because it is certain that any observation must have
    some value within the range of possible values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们提到分布的图形时，我们指的是其概率密度函数的图形。整个分布的积分必须存在，并且等于 1，因为任何观察值必定会落在可能值的范围内。
- en: 'All of the `histogram()` plotting types have an optional `normalize` keyword
    argument that can be set to `true` to make the histogram plot indicate probabilities
    rather than raw counts—for example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `histogram()` 绘图类型都有一个可选的 `normalize` 关键字参数，设置为 `true` 后，直方图将显示概率而非原始计数——例如：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Those three lines repeat the plots of the two histograms just plotted in [Figure
    10-6](ch10.xhtml#ch10fig6), but normalized. Now the areas of the histogram rectangles,
    shown in [Figure 10-7](ch10.xhtml#ch10fig7), are probabilities rather than raw
    counts. The new curve is a plot ➊ of the probability density function of the normal
    distribution with the same mean and standard deviation as the sample. It is a
    graph of the equation for *ϕ*, displayed after [Figure 10-5](ch10.xhtml#ch10fig5).
    [Figure 10-7](ch10.xhtml#ch10fig7) shows how accurately it predicts the results
    of the numerical experiment in [Listing 10-4](ch10.xhtml#ch10lis4).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那三行代码重复了在[图 10-6](ch10.xhtml#ch10fig6)中绘制的两个直方图的图形，但进行了归一化处理。现在，直方图矩形的面积，如在[图
    10-7](ch10.xhtml#ch10fig7)中所示，代表的是概率而不是原始计数。新的曲线是正态分布的概率密度函数的图像➊，其均值和标准差与样本相同。这是*ϕ*方程的图形，显示在[图
    10-5](ch10.xhtml#ch10fig5)之后。[图 10-7](ch10.xhtml#ch10fig7)展示了它如何准确预测[清单 10-4](ch10.xhtml#ch10lis4)中的数值实验结果。
- en: '![Image](../images/ch10fig07.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig07.jpg)'
- en: '*Figure 10-7: Adding the probability density function*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：添加概率密度函数*'
- en: Because of the normal distribution’s importance, Julia provides another function,
    similar to `rand()`, that returns normally distributed random numbers rather than
    uniformly distributed ones. The `randn()` function is part of `Base`, so you don’t
    need an `import`. It returns single numbers or arrays, normally distributed with
    a mean of 0 and a standard deviation of 1.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正态分布的重要性，Julia 提供了另一个类似于 `rand()` 的函数，它返回的是正态分布的随机数，而不是均匀分布的随机数。`randn()`
    函数是 `Base` 的一部分，因此你无需进行 `import`。它返回单个数字或数组，数据服从均值为 0，标准差为 1 的正态分布。
- en: 'Let’s repeat the plot from [Listing 10-1](ch10.xhtml#ch10lis1) using `randn()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `randn()` 重复 [清单 10-1](ch10.xhtml#ch10lis1) 中的绘图：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference is in using `randn()` instead of `rand()`. [Figure 10-8](ch10.xhtml#ch10fig8)
    shows the result. As in [Figure 10-1](ch10.xhtml#ch10fig1), each of the 10⁵ numbers
    is represented by a tiny dot, but now the dots are not uniformly distributed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是使用 `randn()` 代替 `rand()`。 [图 10-8](ch10.xhtml#ch10fig8) 显示了结果。如同 [图 10-1](ch10.xhtml#ch10fig1)，每个
    10⁵ 个数字都由一个小点表示，但现在这些点并不是均匀分布的。
- en: '![Image](../images/ch10fig08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig08.jpg)'
- en: '*Figure 10-8: Normally distributed random floats*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：正态分布的随机浮动数*'
- en: Instead, they are crowded around the value 0 on the vertical axis, with their
    density getting thinner the farther they are from 0, the mean of their distribution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它们在纵轴上的值集中在 0 附近，随着距离 0（其分布的均值）越来越远，它们的密度变得越来越稀疏。
- en: '**Dealing with Data**'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**处理数据**'
- en: So far, all the “data” in this chapter has been either made up or the result
    of collecting results from numerical pseudorandom processes. If you are using
    Julia for statistical analysis, the odds are good that you have some actual, real-life
    data to analyze.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的所有“数据”要么是虚构的，要么是通过数值伪随机过程收集的结果。如果你正在使用 Julia 进行统计分析，很有可能你已经有了一些实际的、真实的数据需要分析。
- en: In this section, we’ll explore the most important methods in Julia for dealing
    with real data. We’ll look at a data type that comes in handy when manipulating
    data in the real world, how to read data from the most common types of datafiles,
    how to use dataframes to view and analyze this data, and how to take advantage
    of Julia’s statistical packages to understand and visualize numerical information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Julia 处理中实际数据的最重要方法。我们将查看一种在处理实际数据时非常有用的数据类型，学习如何读取最常见的数据文件类型，如何使用数据框来查看和分析这些数据，以及如何利用
    Julia 的统计包来理解和可视化数值信息。
- en: '***Missing Values***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缺失值***'
- en: There is an unusual data type I didn’t mention in [Chapter 8](ch08.xhtml) because
    I was saving it for this chapter. It’s a singleton type called `Missing`, and
    it is used to represent missing values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个不常见的数据类型我在 [第 8 章](ch08.xhtml) 中没有提到，因为我打算在这一章介绍。它是一个叫做 `Missing` 的单例类型，用来表示缺失值。
- en: Imagine you have a sensor that is supposed to record the temperature inside
    a tank of water at regular intervals of time. Unfortunately, every now and then
    it fails to record a measurement. Those failures are recorded as 0s, but that
    number is far outside the range of possible measurements, so these failures can’t
    be mistaken for actual temperatures. At the end of the experiment you have two
    vectors, or perhaps two columns of a matrix, one for the times of the measurements
    and the other for the temperatures. When analyzing this data, you don’t want the
    false zero temperatures to be included in the analysis because that would distort
    your calculations. You want a better solution than simply deleting the failed
    readings because that would create a false record of what actually happened in
    the experiment, and, to keep the timing and temperature vectors the same length,
    perhaps for plotting the results, you will have to delete the corresponding entries
    from the timing vector, leading to a time sequence containing gaps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个传感器，应该定期记录水箱内的温度。不幸的是，它偶尔会未能记录一个测量值。这些失败的记录被记录为 0，但这个数字远远超出了可能的测量范围，因此这些失败的记录不能被误认为是实际温度。在实验结束时，你会有两个向量，或者说是一个矩阵的两列，一个是测量时间，另一个是温度。在分析这些数据时，你不希望将虚假的零温度包含在分析中，因为那样会扭曲你的计算。你希望有一个比简单删除失败读取值更好的解决方案，因为那样会创建一个错误的记录，显示实验中实际上发生的情况，并且为了保持时间和温度向量的长度一致，可能需要删除时间向量中的相应条目，从而导致时间序列中出现间隙。
- en: The `Missing` type provides one solution to this set of problems and others—for
    example, in data science, where the concept of missing values arises. It has some
    properties that may seem peculiar, illustrated in [Listing 10-6](ch10.xhtml#ch10lis6),
    which is a REPL session exploring arithmetic on the `Missing` type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Missing`类型为这类问题及其他问题提供了一个解决方案——例如，在数据科学中，缺失值的概念就来源于此。它具有一些看似奇特的特性，这些特性在[清单
    10-6](ch10.xhtml#ch10lis6)中得到了体现，这是一个在REPL中探索`Missing`类型算术运算的会话。'
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-6: Arithmetic properties of* missing *values*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6：缺失值的算术属性*'
- en: We see from [Listing 10-6](ch10.xhtml#ch10lis6) that arithmetic on `missing`
    values leads to a `missing` result, even when dividing by 0.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从[清单 10-6](ch10.xhtml#ch10lis6)中我们看到，对`missing`值进行算术运算会得到`missing`结果，即使是除以0时也是如此。
- en: Usually, `missing` values are not floating around by themselves, but are found
    as part of a collection of data. [Listing 10-7](ch10.xhtml#ch10lis7) is a little
    function that creates an array, replaces some of its values with `missing` values,
    and plots the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`missing`值并不是单独存在的，而是数据集合的一部分。[清单 10-7](ch10.xhtml#ch10lis7)是一个小函数，它创建一个数组，将其中的一些值替换为`missing`值，并绘制结果。
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-7: Creating some missing data for plotting*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-7：为绘图创建缺失数据*'
- en: We need to declare the array to be able to accept `missing` values as well as
    floating-point numbers. If we omit this declaration, the compiler will complain
    when we try to assign `missing` to any location in the array because it will have
    defined it as `Vector{Float64}`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明数组，以便能够接受`missing`值以及浮动点数。如果我们省略此声明，当我们尝试将`missing`赋值给数组中的任何位置时，编译器会报错，因为它已经将数组定义为`Vector{Float64}`。
- en: The plot in [Figure 10-9](ch10.xhtml#ch10fig9) shows that `Plots` knows how
    to handle missing data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-9](ch10.xhtml#ch10fig9)中的图表显示，`Plots`知道如何处理缺失数据。'
- en: '![Image](../images/ch10fig09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig09.jpg)'
- en: '*Figure 10-9: Plotting with missing data*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：处理缺失数据的绘图*'
- en: By default, it leaves a gap where there are `missing` values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它会在缺失值处留下一个空白。
- en: '**Functions for Handling Missing Values**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理缺失值的函数**'
- en: 'Julia provides several functions to do convenient things with `missing` values.
    To illustrate what these do, suppose we have an array, `a`, with some numbers
    and some `missing` elements:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了几个方便处理`missing`值的函数。为了说明它们的作用，假设我们有一个数组`a`，其中包含一些数字和一些`missing`元素：
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you want the sum of the *numbers* in the array, you might try `sum(a)`,
    but if you refer to [Listing 10-6](ch10.xhtml#ch10lis6), you will see that, since
    adding a number to a `missing` value yields `missing`, the end result of the `sum()`
    operation will just be `missing`. Here, Julia’s `skipmissing()` function, which
    does as its name suggests, comes to the rescue:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想得到数组中*数字*的总和，你可能会尝试`sum(a)`，但是如果你参考[清单 10-6](ch10.xhtml#ch10lis6)，你会看到，由于将数字加到`missing`值上会得到`missing`，因此`sum()`操作的最终结果也会是`missing`。在这里，Julia的`skipmissing()`函数恰好解决了这个问题，它的作用正如其名：
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `skipmissing()` function, which is built into `Base`, returns an iterator:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipmissing()`函数是内置于`Base`中的，它返回一个迭代器：'
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you run that loop, you’ll see this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行那个循环，你会看到这个结果：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you need to make a new array with the `missing` values omitted, use `collect(skipmissing(a))`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个去除`missing`值的新数组，可以使用`collect(skipmissing(a))`。
- en: 'If, instead, you want to make an array with a particular value substituted
    for the `missing` values in the original array, the function for that is `coalesce()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个数组，将某个特定的值替换掉原数组中的`missing`值，那么可以使用`coalesce()`函数：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we need to use the dot operator to apply `coalesce()` to all the
    elements of the vector, and how the type of the returned array is no longer a
    `Union` with `missing`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何需要使用点操作符将`coalesce()`应用于向量的所有元素，以及返回的数组类型不再是带有`missing`的`Union`类型。
- en: If you have a program that analyzes data, and want to generalize it so it can
    handle data collections with `missing` elements, the `skipmissing()` function
    makes that task relatively straightforward. You may only have to replace occurrences
    of your data arrays with `skipmissing()` acting on those arrays.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个分析数据的程序，并且希望使其具有处理包含`missing`元素的数据集合的能力，那么`skipmissing()`函数会让这个任务相对简单。你可能只需要用`skipmissing()`替换你数据数组中的相关部分。
- en: 'You may, however, prefer an approach that does not litter your code with a
    multitude of calls to `skipmissing()`. You can take advantage of Julia’s multiple
    dispatch to define your own methods for `sum()`, and for any other functions that
    operate on your data arrays, to handle `missing` elements however you like. If,
    whenever you `sum()` an array of data (and keeping in mind the warning about type
    piracy from [Chapter 8](ch08.xhtml)), you know that you will always want the `missing`
    values ignored and the numerical values added together, you can define a method
    this way:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能更喜欢一种不让代码充斥着大量`skipmissing()`调用的方法。你可以利用Julia的多重派发定义你自己的`sum()`方法，或者对任何其他处理数据数组的函数，按照自己的喜好处理`missing`元素。如果你在每次`sum()`数据数组时（并且记住[第8章](ch08.xhtml)关于类型窃取的警告），都希望忽略`missing`值并将数值加在一起，你可以这样定义一个方法：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That example works for integers, but it’s easily modified for other numerical
    types.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子适用于整数，但很容易修改为适用于其他数值类型。
- en: The function `ismissing()` returns `true` if its argument is `missing` and `false`
    otherwise. It’s often more expressive than comparing against the `Missing` type
    in data expressions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`ismissing()`函数返回`true`，如果其参数是`missing`，否则返回`false`。它通常比在数据表达式中与`Missing`类型进行比较更具表现力。'
- en: The `Missings` package provides a few more convenience functions for dealing
    with this data type. This package is not in the standard library, so you’ll have
    to `add` and `import` it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Missings`包提供了一些用于处理这种数据类型的便捷函数。这个包不在标准库中，因此你需要使用`add`和`import`来导入它。'
- en: 'Anyone making use of `missing` values is likely to appreciate two functions
    from this package. As shown in [Listing 10-7](ch10.xhtml#ch10lis7), it’s a little
    cumbersome to define a vector that can hold both the needed numerical type and
    optional values—and, more important, you may have a numerical array that you need
    to convert to a type that will allow you to add `missing` values to it. The following
    little REPL session shows how to use the `allowmissing()` function from the `Missings`
    package, which solves both of these problems:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用`missing`值的人可能会感激这个包中的两个函数。如[Listing 10-7](ch10.xhtml#ch10lis7)所示，定义一个既能容纳所需数值类型又能容纳可选值的向量有点繁琐——更重要的是，你可能会有一个数值数组，需要将其转换为一种允许你添加`missing`值的类型。以下是一个小的REPL会话，展示如何使用`Missings`包中的`allowmissing()`函数，它解决了这两个问题：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can convert a `Vector{Union{Missing, Float64}}` type back into a pure floating-point
    numerical type using `Missings.disallowmissing()`, but first you must eliminate
    any `missing` values from it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Missings.disallowmissing()`将`Vector{Union{Missing, Float64}}`类型转换回纯浮点数类型，但首先你必须将其中的`missing`值去除。
- en: '**Logic with Missing Values**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**带有Missing值的逻辑**'
- en: Before leaving the topic of Julia’s `Missing` data type, let’s look at how it
    behaves in the context of logic expressions. We typically think of operations
    on logical values as following a two-valued (Boolean) logic, where the only possible
    values are `true` and `false`, a calculus that is reviewed in “Logic” on [page
    31](ch02.xhtml#ch02lev1sec3). The `missing` value expands the world of Boolean
    logic to encompass a third truth state, which is neither `true` nor `false`, but
    indeterminate. In Julia, the `missing` type, along with bitwise AND (`&`), bitwise
    OR (`|`), bitwise exclusive OR (`xor`), equality (`==`), and negation (`!`), form
    a system of three-valued logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开Julia的`Missing`数据类型话题之前，我们来看看它在逻辑表达式中的表现。我们通常认为逻辑值操作遵循二值（布尔）逻辑，其中唯一可能的值是`true`和`false`，这是在《逻辑》一节中回顾的内容，见[第31页](ch02.xhtml#ch02lev1sec3)。`missing`值扩展了布尔逻辑的世界，加入了第三种真值状态，这既不是`true`也不是`false`，而是未确定的。在Julia中，`missing`类型与按位与（`&`）、按位或（`|`）、按位异或（`xor`）、相等（`==`）和取反（`!`）一起，形成了三值逻辑系统。
- en: The results of a logical expression thus can be `true`, `false`, or `missing`.
    The following list shows how the system works, and after some thought, the entries
    should make intuitive sense. For example, the result of `true | missing` is `true`
    because the result will be `true` *no matter the truth value of the second operand*.
    And the result of `true & missing` must be `missing`, because it will *depend*
    on the truth value of the second operand, which is undetermined.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式的结果可以是`true`、`false`或`missing`。以下列表展示了系统的工作方式，经过思考后，条目应该是直观易懂的。例如，`true
    | missing`的结果是`true`，因为结果将是`true`，*无论第二个操作数的真值如何*。而`true & missing`的结果必须是`missing`，因为它将*依赖*第二个操作数的真值，而第二个操作数的真值是未确定的。
- en: true | missing   `true`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: true | missing   `true`
- en: true & missing   `true`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: true & missing   `true`
- en: false | missing   `missing`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: false | missing   `missing`
- en: false & missing   `false`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: false & missing   `false`
- en: xor(true, missing)   `missing`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: xor(true, missing)   `missing`
- en: xor(false, missing)   `missing`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: xor(false, missing)   `missing`
- en: '!missing   `missing`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '!missing   `missing`'
- en: missing == missing   `missing`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: missing == missing   `missing`
- en: missing === missing   `true`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: missing === missing   `true`
- en: Since the truth value of `missing == missing` depends on the values of the missing
    items, it is itself `missing`. However, since `missing` is a singleton type, all
    instances of it are the same object; hence `missing === missing` must be `true`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`missing == missing`的真值取决于缺失项的值，它本身也是`missing`。然而，由于`missing`是一个单例类型，因此它的所有实例都是相同的对象；因此，`missing
    === missing`必须为`true`。
- en: '***CSV Files***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CSV文件***'
- en: Data that’s of moderate size often comes in the form of a comma-separated value
    (CSV) file. These are text files with items delimited by commas, and optionally
    with descriptive headers. They have the considerable advantages of being human
    readable and amenable to processing with all of the Linux command line tools.
    But they have the disadvantages of taking up more space than necessary, being
    less efficient than binary representations, and possibly not faithfully representing
    the original values after conversion into text. For those reasons, this format
    is probably not the best choice for storing, say, the output of a physics simulation.
    However, CSV is perhaps the most common format for distributing what are commonly
    called “statistics,” such as demographic data or the pandemic data that we’ll
    explore later.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 中等大小的数据通常以逗号分隔值（CSV）文件的形式出现。这些是由逗号分隔的文本文件，且可选择包含描述性标题。它们有一个显著的优点，即人类可读，并且可以使用所有Linux命令行工具进行处理。但是它们也有缺点，通常占用比必要更多的空间，比二进制表示效率低，而且在转换为文本后可能无法忠实地表示原始值。由于这些原因，这种格式可能不是存储物理模拟输出的最佳选择。然而，CSV可能是分发通常称为“统计数据”的最常见格式，例如我们稍后将探讨的人口数据或疫情数据。
- en: You may be tempted to write your own programs for reading CSV files, parsing
    them, and turning them into some Julia data structure. If you’ve come this far
    in the book, you will certainly be able to do so. However, it would be wise to
    resist the temptation, except as an exercise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想编写自己的程序来读取CSV文件、解析它们并将其转换为某种Julia数据结构。如果你已经读到这本书的这一部分，你肯定能够做到这一点。然而，除了作为练习，最好抗拒这种诱惑。
- en: 'For real work, it’s a better idea to use the `CSV` package, which we’ll need
    to `add` in the package manager. This package can handle any delimiter, in addition
    to commas: the popular tab-separated file format as well as any custom format
    you may come across. It’s even able, in many cases, to figure out by itself what
    delimiter the file is using. This delimiter need not be limited to a single character;
    it can be a string as well. The `CSV` package can deal with comments mixed in
    with the data, column headers, and anything else you’re likely to encounter. It
    can read files from disk or, given a URL, can fetch them over the internet. It
    can handle dates in any format and transform labels into more code-friendly forms.
    Perhaps most importantly, it transforms the textual information into a Julia data
    type that can be further transformed into one of several different table-like
    data formats designed to be easily manipulated for statistical work.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际工作，使用`CSV`包是一个更好的选择，我们需要在包管理器中`添加`这个包。这个包可以处理任何分隔符，除了逗号外，还包括流行的制表符分隔文件格式以及任何你可能遇到的自定义格式。它甚至能够在许多情况下自动识别文件使用的分隔符。这个分隔符不必仅限于单个字符；它也可以是一个字符串。`CSV`包可以处理与数据混合的注释、列标题以及你可能遇到的其他内容。它可以从磁盘读取文件，或者在给定URL的情况下从互联网上获取文件。它可以处理任何格式的日期，并将标签转换为更适合编程的形式。也许最重要的是，它将文本信息转换为Julia数据类型，并能进一步转换为几种不同的类似表格的数据格式，这些格式专为统计工作而设计，便于操作。
- en: '***Dataframes***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数据框***'
- en: The most important of these table-like data structures is `dataframe`, provided
    by the `DataFrames` package, which also needs to be `add`ed. Indeed, as the data
    structure returned by CSV after it reads a file is not the most convenient for
    exploration, the usual strategy is to immediately transform it into a `dataframe`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类似表格的数据结构中最重要的是`dataframe`，它由`DataFrames`包提供，我们同样需要`添加`这个包。事实上，由CSV读取文件后返回的数据结构并不是最方便进行探索的，因此通常的做法是立即将其转换为`dataframe`。
- en: A `dataframe` is a table of values, like a matrix, but with extra functionality
    designed for data exploration. Along with the `dataframe` data type, the `DataFrames`
    package exports several functions for manipulating it. In addition, many Julia
    functions with which you are already familiar have methods that extend their functionality
    to the `dataframe`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataframe` 是一个值的表格，类似于矩阵，但具有为数据探索设计的附加功能。除了 `dataframe` 数据类型外，`DataFrames`
    包还导出了几个用于操作数据框的函数。此外，许多你已经熟悉的 Julia 函数也有方法扩展其功能，以适应 `dataframe`。'
- en: It is most useful to think of a `dataframe` as a set of columns stuck together.
    Each column has a unique name. A column can be referred to with its integer index,
    with its name as a string, or with its name as a symbol. When you are examining,
    plotting, or manipulating data, you are doing these things to `dataframe` columns.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的理解方式是将 `dataframe` 看作是一个由列拼接而成的集合。每一列都有一个唯一的名称。可以通过整数索引、字符串形式的名称或符号形式的名称来引用某一列。在你检查、绘制或操作数据时，实际上是在处理
    `dataframe` 的列。
- en: '**NOTE**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We treat dataframes as sets of columns for data analysis and visualization.
    However, most Julia functions that operate on collections treat dataframes as
    collections of rows. See “Further Reading” on [page 359](ch10.xhtml#fur10) for
    an illuminating article on this subject.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将数据框视为用于数据分析和可视化的一组列。然而，大多数在集合上操作的 Julia 函数将数据框视为一组行。有关此主题的详细内容，请参阅 [第 359
    页](ch10.xhtml#fur10)的“进一步阅读”部分。*'
- en: Let’s consider an example using real-life data that comes in a typically messy
    form. Our journey through this data will make the earlier discussion of dataframes
    concrete and introduce the important functions for wrangling data from sources
    in the wild.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际的、通常杂乱无章的数据示例来深入理解。通过对这些数据的处理，我们将使之前关于数据框的讨论更具实际意义，并介绍从野外来源中整理数据的重要函数。
- en: Let’s look at some data from the COVID-19 Data Repository maintained by the
    Center for Systems Science and Engineering (CSSE) at Johns Hopkins University
    ([*https://github.com/CSSEGISandData/COVID-19*](https://github.com/CSSEGISandData/COVID-19)).
    This data comes in the form of CSV files, using an actual comma as a delimiter.
    The first line contains headings to describe each data column, but the format
    of those headings will make subsequent manipulation in Julia inconvenient. The
    first problem is that some of the headers are names of countries or territories
    that contain spaces. The second is that some of the headers are dates, but these
    are in a format that we need to take into account so that they are parsed correctly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一组来自约翰霍普金斯大学系统科学与工程中心（CSSE）维护的 COVID-19 数据库的数据（[*https://github.com/CSSEGISandData/COVID-19*](https://github.com/CSSEGISandData/COVID-19)）。这些数据以
    CSV 文件的形式提供，使用逗号作为分隔符。第一行包含描述每一列数据的标题，但这些标题的格式会使得后续在 Julia 中的操作变得不便。第一个问题是，一些标题是包含空格的国家或地区名称。第二个问题是，一些标题是日期，但这些日期的格式需要我们特别注意，以确保它们能够正确解析。
- en: '**NOTE**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The datafile used in the examples here is available in the online resource
    area under the name* time_series_covid19_confirmed_global.csv*. The CSSE data
    grows in size over time, so some of the plots shown in this section may become
    unwieldy with future versions of the file from Johns Hopkins.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*本示例中使用的数据文件可以在在线资源区找到，文件名为* time_series_covid19_confirmed_global.csv*。CSSE
    数据随着时间的推移而增长，因此，本节中展示的某些图表在使用约翰霍普金斯大学未来版本的文件时可能会变得难以处理。*'
- en: Fortunately, the file reading function in the `CSV` package is equipped to deal
    with both of those common issues. [Listing 10-8](ch10.xhtml#ch10lis8) shows the
    instructions for reading the CSV file and converting it immediately into a `dataframe`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`CSV` 包中的文件读取功能能够处理这两种常见问题。[列表 10-8](ch10.xhtml#ch10lis8)展示了读取 CSV 文件并立即将其转换为
    `dataframe` 的操作指令。
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-8: Reading a CSV file*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-8：读取 CSV 文件*'
- en: The `normalizenames` option replaces spaces and other troublesome characters
    in column names with underscores and performs any other transformations needed
    to turn header text into legal Julia identifiers. The `dateformat` keyword argument
    should be self-explanatory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`normalizenames` 选项会将列名中的空格和其他难以处理的字符替换为下划线，并执行任何其他必要的转换，使标题文本成为合法的 Julia 标识符。`dateformat`
    关键字参数应该是显而易见的。'
- en: 'The first argument to `CSV.File()` is the name of the file on disk, which I
    previously downloaded and saved. Another option is to pass the URL of the file
    here. `CSV.File()` will recognize this and automatically download the data over
    the internet. The date format is determined by inspecting the file, whose first
    line, which contains the column headers, looks like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSV.File()`的第一个参数是磁盘上文件的名称，我之前已经下载并保存了该文件。另一种选择是传递文件的URL。`CSV.File()`将识别这一点，并自动通过互联网下载数据。日期格式是通过检查文件来确定的，文件的第一行包含列标题，内容如下所示：'
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are 432 columns. The end of the second command in [Listing 10-8](ch10.xhtml#ch10lis8)
    converts the `CSV.File()` object into a `DataFrame` object, which is stored in
    the variable `covdat`. If this is executed in a REPL, Julia will print out a truncated
    representation of the dataframe. [Figure 10-10](ch10.xhtml#ch10fig10) shows what
    that looks like. In this particular case, I’ve narrowed the REPL window so it
    fits better on the page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有432列。在[清单10-8](ch10.xhtml#ch10lis8)中的第二个命令的结尾部分，将`CSV.File()`对象转换为`DataFrame`对象，并将其存储在变量`covdat`中。如果在REPL中执行此操作，Julia会打印出数据框的截断表示形式。[图10-10](ch10.xhtml#ch10fig10)展示了这种情况。特定情况下，我将REPL窗口缩小，以便更好地适应页面。
- en: '![Image](../images/ch10fig10.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig10.jpg)'
- en: '*Figure 10-10: Representation of a dataframe in the REPL*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：REPL中数据框的表示*'
- en: 'The display indicates how much information has been omitted, the names of the
    visible columns, and the type of data they contain. A question mark after the
    data type means some values may be `missing`. Here is a typical use for the `missing`
    data type: most of the countries in the files do not have a province listed, but
    a few do. Missing data is represented in the original CSV file by a number that
    is . . . missing.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 显示内容表明省略了多少信息，显示的列名称以及它们包含的数据类型。数据类型后面的问号表示某些值可能是`missing`。以下是`missing`数据类型的典型用法：文件中的大多数国家没有列出省份，但少数有。缺失的数据在原始CSV文件中通过缺失的数字表示……缺失。
- en: The fancy display of dataframes in the REPL is accomplished by `show()`, usually
    implicitly. A `print()` of a dataframe spits out the whole thing, without the
    nice formatting or type information, and is usually not what you want. In addition,
    `show()` can create HTML and LaTeX versions, and control other aspects of the
    dataframe display. Consult the REPL help to learn the details.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框在REPL中的精美显示是通过`show()`实现的，通常是隐式进行的。对数据框进行`print()`操作会将整个数据框打印出来，没有漂亮的格式或类型信息，通常这不是你想要的。除此之外，`show()`还可以创建HTML和LaTeX版本，并控制数据框显示的其他方面。请参考REPL帮助以了解详细信息。
- en: '**The @df Macro**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**@df宏**'
- en: 'For the rest of the chapter, we’re going to make extensive use of a macro found
    in the `StatsPlots` package called `@df`. It’s part of `StatsPlots` because it’s
    especially effective at making commands for plotting from dataframes more concise,
    but its use is not limited to `plot()` commands. From this point on, the following
    command is assumed:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章余下的部分，我们将广泛使用在`StatsPlots`包中找到的一个宏，名为`@df`。它之所以是`StatsPlots`的一部分，是因为它特别有效于简化从数据框生成绘图命令，但它的使用并不限于`plot()`命令。从现在开始，假定使用以下命令：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `@df` macro does what macros do best: it rewrites code so that our programs
    are easier to write and read. This macro has one job: it replaces symbols in an
    expression with the columns of the dataframe that appears as its first argument.
    This simple expression rewriting is enough to make this macro popular because
    it frees the programmer from having to repeat the name of the dataframe multiple
    times in an expression. Consider the following example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`@df`宏做的是宏最擅长的事情：它重写代码，使我们的程序更容易编写和阅读。这个宏的唯一作用就是：它将表达式中的符号替换为作为第一个参数出现的数据框的列。这个简单的表达式重写足以使这个宏非常受欢迎，因为它让程序员不必在表达式中多次重复数据框的名称。考虑以下示例：'
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this expression, the symbol `:_1_1_21` is converted to `covdat._1_1_21` each
    time it appears. The argument of the macro following the name of the dataframe
    must be a block or a function call, so the above would fail without wrapping the
    result in the `print()` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式中，符号`:_1_1_21`每次出现时都会被转换为`covdat._1_1_21`。宏后面的参数必须是一个块或函数调用，因此，如果不将结果包裹在`print()`函数中，上面的代码会失败。
- en: Since `Symbols` are converted into dataframe columns when using the `@df` macro,
    we need some syntax to indicate when a `Symbol` should be left alone—for example,
    if there is a conflict between a column name and a symbol used for another purpose.
    The macro provides the “`^()`” wrapper to handle these conflicts. If, for example,
    a column called “topleft” happens to be in your dataframe, you’ll need to use
    the syntax `legend=^(:topleft)` in the plotting command to put the legend in the
    Northwest.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在使用`@df`宏时，`Symbol`会转换为数据框的列，因此我们需要一些语法来指示何时应该保留`Symbol`不变——例如，如果列名和用于其他目的的符号之间发生冲突。该宏提供了“`^()`”包装器来处理这些冲突。例如，如果数据框中恰好有一个名为“topleft”的列，您需要在绘图命令中使用语法`legend=^(:topleft)`将图例放置在西北方向。
- en: '**Indexing and Filtering Dataframes**'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**索引和筛选数据框**'
- en: A dataframe can be indexed and filtered using the same methods that we apply
    to matrices. However, dataframes come with some extra indexing methods that let
    us take advantage of their named columns.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框可以使用我们应用于矩阵的相同方法进行索引和筛选。然而，数据框提供了一些额外的索引方法，让我们能够利用其命名列。
- en: I include in this chapter only the indexing and filtering methods that I think
    are most likely to be useful in the majority of cases. There are, in addition
    to everything covered here, several packages that supply macros and functions
    providing yet more ways to select and transform the information in a dataframe.
    Their intention is to allow a more streamlined syntax for certain common tasks,
    and these packages can be convenient. However, most of them are in somewhat of
    a state of flux. As in most sections in this book, I try to confine myself to
    methods that have solidified—that you can learn once and use forever.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅包括我认为在大多数情况下最有用的索引和筛选方法。除此之外，还有几个包提供宏和函数，提供更多选择和转换数据框信息的方式。它们的目的是为某些常见任务提供更简化的语法，这些包可以非常方便。然而，大多数包仍处于某种变化之中。与本书中的大多数章节一样，我尽量将自己限制在那些已经稳定的方法上——这些方法你可以学会一次，并永远使用。
- en: 'Items in a dataframe can be extracted using the familiar forms of integer indexing.
    Here are a few examples:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中的项目可以使用熟悉的整数索引形式提取。以下是一些示例：
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice how the data type of the result depends on how we index the dataframe.
    If we ask for one element ➊, we get back a single value, in this case a string.
    If we ask for a range of rows in a single column ➋, we get a `Vector`. Finally,
    if we extract data horizontally, by indexing a single row and a range of columns
    ➌, we get a data type that we haven’t seen before: a `DataFrameRow`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果的数据类型如何取决于我们如何索引数据框。如果我们请求一个元素➊，我们会返回一个单一值，在这种情况下是一个字符串。如果我们请求一个范围的行在单一列中➋，我们会得到一个`Vector`。最后，如果我们按水平方向提取数据，通过索引一个单独的行和一系列列➌，我们会得到一个我们之前未见过的数据类型：`DataFrameRow`。
- en: 'Let’s ask Julia for a range of rows and a range of columns:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们请求Julia提供一个行范围和列范围：
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We get back a smaller dataframe. What else could it be?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是一个更小的数据框。还有什么可能呢？
- en: We don’t have to count indices to refer to columns, but can use their names,
    as in [Listing 10-9](ch10.xhtml#ch10lis9).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必计算索引来引用列，而可以使用它们的名称，如[示例 10-9](ch10.xhtml#ch10lis9)所示。
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-9: Selecting columns by name*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 10-9：按名称选择列*'
- en: 'We use `Symbol`s to index the dataframe’s columns. For each column title, a
    `Symbol` with the same name is created for efficient indexing. We could just as
    well have used the string versions of the column names in [Listing 10-9](ch10.xhtml#ch10lis9),
    but using `Symbol`s is more efficient. This is one reason for using `normalizenames`
    when reading the data: headers containing spaces would not be valid `Symbol` names,
    and we would be forced to use the string versions. [Listing 10-9](ch10.xhtml#ch10lis9)
    shows the last three countries, their latitude and longitude, and the number of
    COVID cases on January 22, 2021.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Symbol`来索引数据框的列。对于每个列标题，会创建一个具有相同名称的`Symbol`以便于索引。我们也可以使用列名的字符串版本，如[示例
    10-9](ch10.xhtml#ch10lis9)所示，但使用`Symbol`更加高效。这也是在读取数据时使用`normalizenames`的原因之一：包含空格的标题将无法成为有效的`Symbol`名称，我们将不得不使用字符串版本。[示例
    10-9](ch10.xhtml#ch10lis9)展示了最后三个国家、它们的纬度和经度，以及2021年1月22日的COVID病例数。
- en: 'The headings of the columns for latitude and longitude have data types printed
    with question marks. This means somewhere in this table is a country or a province
    with one or both of these values missing. To see those countries or provinces,
    we need to find the *row* in the table where `:Lat` or `:Long` has the value `missing`.
    To select rows from a dataframe where one or more columns satisfy some condition,
    we can use the `filter()` function (described in “The filter() Operator” on [page
    163](ch06.xhtml#ch06sec1sec4). The `DataFrame` package extends the `filter()`
    function to operate on dataframes by filtering rows and returning a new dataframe.
    The following line of code filters our COVID dataframe, looking for the rows with
    missing latitude or longitude:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 纬度和经度列的标题旁边打印了数据类型，并且带有问号。这意味着该表格中某个国家或省份的纬度或经度值缺失。为了查看这些国家或省份，我们需要找到数据表中`：Lat`或`：Long`值为`missing`的*行*。要从数据框中选择符合某个条件的行，我们可以使用`filter()`函数（详见[第163页](ch06.xhtml#ch06sec1sec4)的《filter()操作符》）。`DataFrame`包扩展了`filter()`函数，使其可以作用于数据框，过滤行并返回一个新的数据框。以下代码行过滤了我们的COVID数据框，寻找缺失纬度或经度的行：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result is a dataframe with a single row, with the curious notation `Repatriated
    Travellers` in place of the province.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含单行的 dataframe，其中 `Repatriated Travellers` 代替了省份名，显示了一个奇怪的符号。
- en: Rather than use the `filter()` function, you can get the same result with bitmask
    indexing or any other technique that works with normal arrays.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用`filter()`函数，你也可以使用位掩码索引或任何其他适用于普通数组的技术，得到相同的结果。
- en: 'Notice in the example just shown how we specified the columns for the filter
    using the column names as bare words. This is yet another form of indexing, which
    is convenient in filter expressions. We can also use that syntax to select columns
    from the dataframe, turning them into `Vector`s:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在刚才展示的例子中，我们是如何通过直接使用列名作为纯文本来指定过滤的列的。这是另一种索引形式，适用于过滤表达式。我们还可以使用这种语法从数据框中选择列，并将其转换为`Vector`：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since selecting columns provides us with `Vector`s, we can use this form of
    indexing for plotting:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择列会返回`Vector`，我们可以使用这种索引形式来绘制图表：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Nothing mysterious is going on here. We simply extracted two vectors from the
    dataframe and plotted them in the usual way, resulting in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么神秘的。我们只是从数据框中提取了两个向量，并按常规方式绘制了它们，得到的结果如[图 10-11](ch10.xhtml#ch10fig11)所示。
- en: '![Image](../images/ch10fig11.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig11.jpg)'
- en: '*Figure 10-11: Cases vs. country*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11: 病例与国家*'
- en: 'This plot is not ideal, however. It shows us something about the distribution
    of the number of cases on the date in question, but the horizontal axis is essentially
    useless because there is no room for hundreds of country labels. Perhaps, instead
    of trying to plot all the data at once, it would be more useful to plot some meaningful
    subset. Let’s limit our visualization to the countries with a lot of cases, by
    using the filtering mechanism we just learned. Also, let’s switch to a bar chart,
    which is the more appropriate visualization for this type of data:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个图并不理想。它展示了某个特定日期的病例分布情况，但横轴几乎没有意义，因为没有足够的空间容纳数百个国家标签。也许与其试图一次性绘制所有数据，不如绘制一些有意义的子集。我们可以通过刚刚学到的过滤机制，限制可视化仅显示病例较多的国家。此外，我们还可以切换到柱状图，这对于这种数据类型是更合适的可视化方式：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we have something useful: a chart of the countries with more than two million
    cases on New Year’s Day 2021, shown in [Figure 10-12](ch10.xhtml#ch10fig12).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到了一些有用的东西：2021年元旦时，病例超过两百万的国家的图表，见[图 10-12](ch10.xhtml#ch10fig12)。
- en: '![Image](../images/ch10fig12.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig12.jpg)'
- en: '*Figure 10-12: Countries with over two million cases*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12: 超过两百万病例的国家*'
- en: In the previous indexing commands, we used integer indexing to select columns,
    which worked well, but required us to count to the first column of interest. Also,
    it was only convenient because we knew that the columns we wanted extended to
    the end, which simplified the indexing expression.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的索引命令中，我们使用了整数索引来选择列，虽然有效，但需要我们计算到感兴趣的第一列。而且，这样做之所以方便，是因为我们知道我们想要的列一直延伸到最后，这简化了索引表达式。
- en: 'An alternative that lets us use column names directly is the `Between()` function.
    The equivalent expression for selecting the date columns is:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们直接使用列名的另一种方法是`Between()`函数。选择日期列的等效表达式为：
- en: '[PRE34]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This can be easily modified to choose any closed interval of columns.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作可以很容易地修改，以选择任何闭区间的列。
- en: 'Another option is the `Not()` function. Here is a selection that returns the
    same `DataFrameRow` as the previous one:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The columns that remain after the listed ones are excluded are just the ones
    we want: the date columns.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also select columns using regular expressions applied to the names of
    their titles. Here is another way to make the same selection, returning the same
    `DataFrameRow`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Sometimes this is the most convenient way to select data. For example, if we
    want to extract only the columns for February 2021 for Afghanistan, we could just
    say `covdat[1, r"_2_\d*_21"]`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to make a `DataFrameRow` with all the date columns *and*,
    say, the `Country_Region` column (but none of the other ones)? None of the indexing
    techniques we’ve seen so far make this convenient, although you might be able
    to twist them to get the desired result. There is no need for contortions, however,
    because we can use the `Cols()` function. The following lines show four different
    ways to use this function to get a `DataFrameRow` similar to the one we created
    using multiple techniques earlier, but with the addition of the `Country_Region`
    column:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we can see, the `Cols()` function lets you pick out individual columns or
    ranges of columns using numerical indices, regular expressions, or column names
    either as symbols or as strings. It can also reorder columns. The following rearranges
    the `covdat` dataframe to place the latitude and longitude columns at the end:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this, we have a large enough toolbox to do most of the indexing, selecting,
    and rearranging of dataframes that we’re likely to encounter in our work.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutating Dataframes**'
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The indexing expressions `covdat[:, :Country_Region]` and `covdat.Country_Region`
    both seem to return a `Vector` with contents identical to the `Country_Region`
    column of the dataframe called `covdat`. However, they are not identical:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This tells us that while the two left- and right-hand sides contain the same
    values, they are not the same object. The syntax `dataframe[:, :col]` makes a
    *copy* of the column and returns it as a `Vector`. But `covdat.Country_Region`
    is a *reference* to the column. If you have a choice, avoid making unnecessary
    copies, as it is slower and consumes memory. Also, if you want to mutate a column
    by assigning to individual elements, you must use a reference rather than a copy,
    as shown in [Listing 10-10](ch10.xhtml#ch10lis10).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 10-10: Mutating a dataframe*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'The direct dot syntax used here only works when using a literal column name
    after the dot, not with a variable holding a column name. If you’re using variables
    to hold the names of columns, you must use square brackets. However, that doesn’t
    mean you are obligated to make copies of columns. Another syntax allows you to
    use square brackets to reference a column using a variable, and without making
    a copy: `dataframe[!`, var`]` means the same thing as `dataframe.columnname` if
    var is set to `"columnname"`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: A command such as `covdat[:, c][1] = "Disneyworld"` will have no effect on the
    original dataframe. However, the assignment in [Listing 10-10](ch10.xhtml#ch10lis10)
    can also be written as
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，命令`covdat[:, c][1] = "Disneyworld"`对原始数据框没有影响。然而，[示例 10-10](ch10.xhtml#ch10lis10)中的赋值也可以写成
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: which will mutate the dataframe. The meaning of the exclamation point is suggested
    by its use in mutating functions, introduced in “Functions That Mutate Their Arguments”
    on [page 56](ch02.xhtml#ch02lev1sec17).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变数据框。感叹号的含义可以通过其在“变更参数的函数”一章中的使用得到暗示，参见[第56页](ch02.xhtml#ch02lev1sec17)。
- en: '**Transposing Dataframes**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**转置数据框**'
- en: 'Dataframes make it convenient to plot or operate on columns of data. But suppose,
    using the data in the `covdat` dataframe, that you wanted to plot the time histories
    of case numbers for various countries. For each country, its time series is the
    part of the *row* for that country starting in the fifth column. We know, from
    the indexing section earlier, that we can extract rows from the dataframe, and
    that doing so gets us not a `Vector`, but a `DataFrameRow`. This means that, for
    plotting, we need to convert the result into a `Vector`. Here is one way to put
    all of this together to plot the time histories of COVID cases in the US:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框使得绘制或操作数据列变得方便。但假设，使用`covdat`数据框中的数据，你想绘制多个国家的病例时间历史。对于每个国家，其时间序列是从第五列开始的该国对应的*行*部分。我们从之前的索引部分知道，我们可以从数据框中提取行，而且提取的结果不是`Vector`，而是`DataFrameRow`。这意味着，对于绘图，我们需要将结果转换为`Vector`。下面是将这些内容整合起来，用于绘制美国COVID病例时间历史的一个方法：
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'I snuck in a function you haven’t seen before: `names()` returns the names
    of the columns in a dataframe in the form of a `Vector` of strings, so it is what
    we need to make meaningful x-tick labels.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我偷偷加了一个你之前没有见过的函数：`names()`返回数据框中列的名称，形式是一个包含字符串的`Vector`，因此它正是我们用来生成有意义的x轴刻度标签所需的。
- en: The listing employs the `@chain` macro introduced in “The @chain Macro” on [page
    174](ch06.xhtml#ch06sec1sec8). The pipeline syntax is popular when wrangling data
    from dataframes, as this activity inherently involves a series of transformations.
    The code snippet will produce the desired timeline plot, shown in [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表使用了在《@chain 宏》一章中介绍的`@chain`宏，参见[第174页](ch06.xhtml#ch06sec1sec8)。管道语法在处理数据框中的数据时非常流行，因为这一过程本质上涉及一系列转换。这个代码片段将生成所需的时间线图，见[图10-13](ch10.xhtml#ch10fig13)。
- en: '![Image](../images/ch10fig13.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig13.jpg)'
- en: '*Figure 10-13: US cases vs. date*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：美国病例与日期的关系*'
- en: Now, to compare different countries, I would merely need to repeat the plotting
    pipeline using `plot!()` to add a new curve, substituting the country name of
    interest.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了比较不同的国家，我只需要重复绘图管道，使用`plot!()`来添加新的曲线，并替换感兴趣的国家名称。
- en: You may be thinking that there is a lot to type just to plot a row of data,
    and that this could be a bit of a drag for interactive work. Again, all this typing
    is required because the intention behind dataframes is to deal with them as a
    set of columns, so plotting rows is going against the grain. It would be smoother
    to go with the dataframe flow and somehow flip the dataframe around first, so
    the rows become columns. This would make the code easier to write and read. Selecting
    the data to plot would be more direct, and it would come in the form of a `Vector`
    that can be plotted immediately, eliminating the need for conversion.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，仅仅为了绘制一行数据，需要输入这么多内容，可能会让交互式工作变得有点繁琐。再次强调，所有这些输入是必要的，因为数据框的设计初衷是将其作为列集来处理，因此绘制行数据违背了这一设计思路。如果先将数据框翻转一下，使得行变成列，代码会更容易编写和理解。选择要绘制的数据将更直接，并且会以`Vector`的形式呈现，可以立即绘制，避免了转换的需要。
- en: We want to end up with a series of columns for different countries, with each
    column containing the series of case numbers for the country. If we have that
    kind of dataframe, we can plot any country’s case number history directly. We
    would also like a column containing the date labels to use in plots. We can omit
    the other columns. We don’t plan to use the latitude and longitude information
    in these plots or in our subsequent analysis, but they will remain in the original
    `covdat` dataframe if we need them. We are just making a new dataframe as a tool
    to ease our exploration of the data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望得到的是一系列不同国家的列，每列包含该国的病例数数据。如果我们有这样的数据框架，我们可以直接绘制任何国家的病例数历史图。我们还希望有一个包含日期标签的列，用于绘图。其他列可以省略。我们不打算在这些图表或后续分析中使用纬度和经度信息，但它们将保留在原始的`covdat`数据框架中，如果需要的话。我们只是创建一个新的数据框架作为工具，以便更方便地探索数据。
- en: 'Before proceeding, however, we need to do something about the fact that some
    of the country names appear more than once, because some of them are listed along
    with several entries for `Province_State`. If these country names are to become
    column titles, they must be unique. A little later on we’ll learn how to incorporate
    this data, but for now, we can simply eliminate the rows with provinces, keeping
    only the main country entries:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续之前，我们需要处理一些国家名称出现多次的问题，因为其中一些与多个`Province_State`条目一起列出。如果这些国家名称要成为列标题，它们必须是唯一的。稍后我们会学习如何整合这些数据，但现在，我们可以简单地删除带有省份的行，仅保留主要国家条目：
- en: '[PRE43]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the troublesome rows deleted, we can now safely exchange rows for columns.
    It probably sounds like we need some kind of transpose of the dataframe; however,
    the `transpose()` function, that we know and love from our work with matrices,
    will not work here. Fortunately, the `DataFrame` package comes with a function
    designed exactly for this purpose. We learned about the `permutedims()` function
    in “Adjoints and Transposes” on [page 144](ch05.xhtml#ch05lev1sec17), as a kind
    of generalized transpose operation. The `DataFrames` package extends this function
    to handle `DataFrame`s; here’s how to use it:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了麻烦的行后，我们现在可以安全地交换行和列了。这听起来像是我们需要对数据框架进行转置；然而，`transpose()`函数（我们在处理矩阵时熟悉并喜爱的那个）在这里无法使用。幸运的是，`DataFrame`包提供了一个专门用于此目的的函数。我们在《伴随矩阵与转置》一章中（见[第144页](ch05.xhtml#ch05lev1sec17)）了解了`permutedims()`函数，它是一种广义的转置操作。`DataFrames`包扩展了此函数以处理`DataFrame`数据框架；下面是如何使用它的方式：
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the first line, we get rid of the columns that we won’t need. The transpose
    happens in the second line, where the first argument to `permutedims()` is the
    dataframe to be transposed, the second argument selects the column from the original
    dataframe whose contents are to be used as column names for the transposed dataframe,
    and the third argument is the name to give the new column, whose contents will
    be composed of the column names of the original dataframe. Since we eliminated
    the `Province_State` column, the first column of `covmc` is now `Country_Region`,
    so the names in the column of countries are used as the new column titles. We
    can specify the column to pivot around using any kind of selector, so we could
    have written the following as well:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们删除了不需要的列。转置操作发生在第二行，其中`permutedims()`的第一个参数是需要转置的数据框架，第二个参数选择原数据框架中用作转置后数据框架列名的列，第三个参数是新列的名称，列内容将由原数据框架的列名组成。由于我们删除了`Province_State`列，`covmc`的第一列现在是`Country_Region`，因此该列中的国家名称被用作新的列标题。我们可以使用任何类型的选择器来指定旋转的列，因此我们也可以这样写：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our new dataframe, `cdcn`, appears as shown in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新数据框架`cdcn`如[图 10-14](ch10.xhtml#ch10fig14)所示。
- en: '![Image](../images/ch10fig14.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig14.jpg)'
- en: '*Figure 10-14: The* cdcn *dataframe in the REPL*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：REPL中的* cdcn *数据框架*'
- en: 'There is one problem with our freshly transposed dataframe: some of the column
    titles now have spaces in their names. You can’t see them in the small piece of
    the dataframe shown in [Figure 10-14](ch10.xhtml#ch10fig14), but we know that
    they’re there:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚转置的数据框架有一个问题：一些列标题现在包含了空格。你在[图 10-14](ch10.xhtml#ch10fig14)中看到的小片段里看不出这些空格，但我们知道它们存在：
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It’s not a serious problem, but, as you now know, legal symbol names are more
    convenient and lead to neater and more efficient code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个严重的问题，但正如你现在所知道的，合法的符号名称更加方便，有助于编写更简洁、更高效的代码。
- en: The function `rename!()` transforms the column names of a dataframe in place
    (hence the mutation warning sign). It has several methods; the method that we
    shall use takes a function as its first argument and the dataframe to be altered
    as its second argument. The supplied function is applied to each column separately.
    The command in [Listing 10-11](ch10.xhtml#ch10lis11) replaces spaces with underlines
    in the column names of `cdcn`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 10-11: Renaming columns of a dataframe*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Did it work? Let’s take a peek at a relevant bit of the dataframe:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can plot time-dependent case numbers for selected countries with ease:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `@df` macro from `StatsPlots` was useful there, as the command refers to
    several columns using `Symbol`s; without it, we would be obligated to mention
    the name of the dataframe each time. This `plot()` command produces the graph
    in [Figure 10-15](ch10.xhtml#ch10fig15).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig15.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Timeline of cases in three countries*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In a `plot()` command inside a `@df` macro call, the `cols()` function (note
    the lowercase) can be used to select a numerical range of columns with `cols(a:b)`,
    all the columns with `cols()`, or a column whose `Symbol` name is stored in a
    variable, with `c = :thecol` and `cols(c)`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that* Cols*, with an uppercase C, is for column selection within
    square brackets and is part of* DataFrames.jl*, whereas* cols*, using lowercase,
    is a utility function for use in the* @df *macro, provided by* StatsPlots.jl.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the machinery that we now have under our belts, we can do more than
    plot random selections of countries. One thing that might be interesting is to
    plot only those countries whose caseloads rise above a certain level on any day
    included in the dataset. Here is one way to do that, using the `@df` macro and
    `cols()` function from `StatsPlots`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The strategy is to collect the relevant columns as an array of `Symbol`s, so
    that we can select them in the `plot()` statements using `cols()`. [Figure 10-16](ch10.xhtml#ch10fig16)
    shows the result.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig16.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: Countries with large caseloads*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`StatsPlots` has turned the symbols identifying the columns into strings for
    the plot, providing a useful legend.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**Summarizing Dataframes**'
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another useful device that `DataFrames` provides is the `combine` function.
    This allows us to map a function onto a set of columns to create a new dataframe
    that is a summary of an existing dataframe. For example, suppose we want a table
    that contains the maximum number of cases seen for each country. The `combine()`
    function makes this simple:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For each column in the range of columns defined in the second argument, `combine()`
    applies the `maximum()` function to its contents.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The `combine()` function creates new column names by appending the name of the
    function. If you would like to preserve the original name, pass in `renamecols
    = false`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'This data is a good candidate for another bar chart, but it would be more convenient
    to have it transposed, with a column of countries and a column of maximums. We
    know how to do that now, but something is missing: we need to add a column to
    hold the new column names. [Listing 10-12](ch10.xhtml#ch10lis12) combines the
    methods we’ve learned to first make a permuted dataframe called `cdmp` and then,
    in the last line, copy only the rows with the largest caseloads into another dataframe,
    `cdmpc`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 10-12: Plotting maximum caseloads*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the code in [Listing 10-12](ch10.xhtml#ch10lis12), `cdmpc`
    looks like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You see that there are only 14 countries that experienced a caseload of more
    than two million during the time period covered by this dataset. Now we can make
    a bar chart with this simple command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This creates the graph in [Figure 10-17](ch10.xhtml#ch10fig17).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig17.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-17: The highest maximum caseloads*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'The need for summary statistics of the data in a dataframe is so common that
    a function is available that does the foregoing work for us, but it’s good to
    know how to do it “manually,” in case you need something it doesn’t provide. That
    function is called `describe()`, and here’s how it works:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That’s certainly easier! By default, `describe()` returns a `DataFrame` with
    the means and medians as well, but those are not meaningful for these timelines,
    so we limit the statistics calculated by passing a symbol, `:max`, for the one
    we want. The function can calculate the other summary statistics as well, such
    as standard deviation, and automatically skips `missing` values. It can even report
    the number of `missing` values in each column, if you so desire.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '**Grouping Dataframes**'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier we threw away some of the data, namely the additional provinces for
    the several countries for which such entries existed. As promised, we’ll now find
    a way to include that information.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose we are not interested in looking at the data for individual provinces,
    but instead would like to add up the numbers for all the provinces belonging to
    each country and just look at the total case numbers. This makes a bit more sense
    than just deleting that data. The most convenient way to do this kind of thing
    involves the concept of the *grouped dataframe* and an associated new data type,
    the `GroupedDataFrame`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: A `GroupedDataFrame` is something like a vector of dataframes. Each dataframe
    in the vector is created from a source dataframe by collating the rows that have
    the same value in a chosen column. In our case, we’ll group by `Country_Region`.
    Most of the resulting members of the `GroupedDataFrame` will have a single row
    because most countries appear only once. But those countries that appear multiple
    times, because they have `Province_State` values, will give rise to members of
    the `GroupedDataFrame` with more than one row, with one for each `Province_State`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: One small wrinkle is that the members of a `GroupedDataFrame` are not actually
    dataframes, but have a new data type called `SubDataFrame`; however, the distinction
    is usually not important.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will group the `covdat` dataframe by country:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now `cvgp` is a `GroupedDataFrame`. Let’s examine it in the REPL:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The grouped dataframe has 192 members ➊, which tells us how may distinct countries
    are included in the data (remembering that one of them is `Repatriated Travellers`).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Subtracting that from the total number of rows ➋, we learn that 82 countries
    have provinces listed.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Looking at individual members of `cvgp` ➌ ➍ confirms that these are dataframes
    devoted to individual countries. The next step is to add up the case numbers across
    all provinces for each date, so each country’s numbers will include all of its
    provinces. That’s what the `combine()` function is for. When I introduced `combine()`,
    we used it on a dataframe, but when applied to a grouped dataframe, it does exactly
    what we want, applying the specified function along the selected columns for each
    group member individually and then returning a normal `DataFrame` as the result.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need an array holding the columns to sum, which are the date columns,
    and then we can `combine()` them. We’ll store the result in a new variable:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now `cvsm` has the same structure as our original `covdat`, but only 192 rows,
    one for each country. As before, it will be convenient to have on hand the transpose
    of this dataframe:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And, as before, it’s better to normalize (remove the spaces from) the column
    names. After repeating the procedure from [Listing 10-11](ch10.xhtml#ch10lis11)
    on `cvsp`, we have a dataframe convenient for plotting.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s easy to compare the timelines for France, both with and without its
    territories:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[Figure 10-18](ch10.xhtml#ch10fig18) shows the results.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig18.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-18: Time history of the caseload in France*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the inclusion of the `Province_State` columns makes a barely
    visible difference in the plot.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '**Multivariate Data**'
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous examples all dealt with timelines: a single quantity, in this
    case numbers of infections, as a function of date, for various countries. Another
    form of data involves the frequencies of a number of events in, say, different
    places, or compared among different demographic groups. [Figure 10-4](ch10.xhtml#ch10fig4)
    showed a simple example of this form of data, where the events are observations
    of height and the demographic groups are men and women.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: When you have data on more than one variable, you can use statistical methods
    to look for associations among them, always remembering that “correlation does
    not imply causation.” But an association can suggest that it might be worthwhile
    to look further, and the *lack* of correlation might be useful in ruling out hypotheses.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the (made up) example of men’s and women’s heights, if we also had, from
    the same subjects, data about income level, or age, we could look for associations.
    Are richer people taller? When does the increase of height with age level off?
    Julia’s `DataFrame`s, combined with its convenient statistical functions and the
    visualizations provided by `StatsPlots`, make this kind of data exploration a
    relatively easy and pleasant task.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在（虚构的）男性和女性身高的例子中，如果我们还从相同的受试者那里获得了收入水平或年龄的数据，我们可以寻找它们之间的关联。富裕的人是否更高？随着年龄增长，身高的增加何时会趋于平稳？Julia
    的 `DataFrame` 结合其便捷的统计功能和 `StatsPlots` 提供的可视化，使得这种数据探索变得相对简单且愉快。
- en: 'I compiled our second datafile from data maintained by the US Census Bureau
    ([*https://www.census.gov*](https://www.census.gov)). It is available in the supplementary
    website at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org),
    in the file named *census.dat*. The file is in tabseparated value format, with
    one line of column headers and comment lines that each begin with a hash mark
    (#). The data consists of absolute numbers of reported crimes in several categories
    in 2011 for each county in the US, plus a column for the total population of the
    county and one for the percentage of minors who did not complete high school.
    The comment lines give the totals for each state and for the entire country. Here
    are the first nine lines of the 3,143-line file:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我从美国人口普查局维护的数据中编译了我们的第二个数据文件（[*https://www.census.gov*](https://www.census.gov)）。该数据文件可以在补充网站
    [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org) 上获取，文件名为 *census.dat*。该文件是制表符分隔值格式，第一行是列标题，注释行以井号（#）开头。数据包括2011年美国各县在多个类别中报告的犯罪绝对数字，另外还有每个县的总人口和未完成高中学业的未成年人的百分比列。注释行给出了各州和全国的总数。以下是该文件3,143行中的前九行：
- en: '[PRE61]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Clearly, the first thing we need to do is use the `CSV` package to read this
    and store it in a dataframe. The `CSV.File` function will detect that tabs are
    used as delimiters, and also that the first line is a header, but we should tell
    it about the comments:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们首先需要做的是使用 `CSV` 包来读取该文件并将其存储在数据框中。`CSV.File` 函数会自动检测到使用制表符作为分隔符，并且识别出第一行为标题行，但我们仍然需要告诉它注释行的情况：
- en: '[PRE62]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The second line eliminates any rows (there were three) with a zero population.
    As we plan to divide the absolute numbers by population to convert them into rates,
    we need to delete those rows. Here is the conversion:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行删除了任何人口为零的行（共有三行）。由于我们计划将绝对数除以人口以转换为比率，因此需要删除这些行。下面是转换的过程：
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At this point, our dataframe looks like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的数据框看起来是这样的：
- en: '[PRE64]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'How is a particular crime category, say, larceny, distributed among the counties?
    Are they all the same? How likely is it for a county to have an unusually high
    larceny rate? We can answer those kinds of questions with a histogram, which we
    can produce with this command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 某一特定犯罪类别，比如盗窃，在各个县的分布情况如何？它们都是一样的吗？一个县的盗窃率异常高的可能性有多大？我们可以通过直方图来回答这些问题，下面的命令可以帮助我们生成直方图：
- en: '[PRE65]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In many commands that pull data from the dataframe, the `@df` macro will save
    some typing and make the code easier to read. The histogram, shown in [Figure
    10-19](ch10.xhtml#ch10fig19), shows that about 400 counties had no larceny at
    all during the report year, and most had rates (total number divided by population)
    below 2 percent. Above that rate, the distribution drops off steadily and fairly
    rapidly.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多从数据框中提取数据的命令中，`@df` 宏可以节省一些输入时间并使代码更易于阅读。直方图，如 [图 10-19](ch10.xhtml#ch10fig19)
    所示，表明大约400个县在报告年份内没有任何盗窃案件，而大多数县的比率（总数除以人口）低于2%。超过该比率后，分布稳步下降且相对迅速。
- en: '![Image](../images/ch10fig19.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig19.jpg)'
- en: '*Figure 10-19: Histogram of larcenies*'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-19：盗窃案的直方图*'
- en: 'With our dataframe set up, exploring this data in the REPL is simple (the following
    assumes that `Statistics` has already been imported):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好数据框后，在 REPL 中探索这些数据变得非常简单（以下假设 `Statistics` 已经被导入）：
- en: '[PRE66]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The average larceny rate is about 1.4 percent. How is this crime correlated
    with other crimes? The correlation with murder is weak, meaning that knowledge
    of a high larceny rate in a particular county tells you nothing about its murder
    rate. However, the correlation with vehicle theft is significant: a county with
    a high larceny rate is a place where you are more likely to get your car stolen.
    That may not be surprising, but before we take it seriously, we should remember
    that the correlation coefficients calculated by the `cor()` function of the `Statistics`
    package are the Pearson coefficients, which assume a linear relationship between
    the two variables under consideration. Does such a linear relationship hold between
    these two crime categories? The way to answer this kind of question is with a
    scatterplot:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It does look from [Figure 10-20](ch10.xhtml#ch10fig20) as if there is at least
    a roughly linear relationship between the two rates, so the correlation coefficient
    is meaningful.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig20.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-20: Larceny–motor vehicle theft scatterplot*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Using a small marker size combined with a low opacity is effective when making
    scatterplots with many points. The idea is that there are likely to be regions
    with a lot of overlap. Using small, transparent points allows the point density
    at any location to appear as a buildup of image density there. Using opaque or
    larger points would create a plot where we can’t distinguish between moderate
    and high densities once the markers begin to obscure each other.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea is made more systematic with a plot recipe from `StatsPlots` called
    `histogram2d()`. As the name suggests, it takes two variables and creates a two-dimensional
    histogram. The result is similar to a scatterplot, but with the plane divided
    into cells and the cells colored according to the number of points they contain.
    Here is how it works:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As with ordinary histograms, we can adjust the number of bins if the automatic
    calculation is not optimal, but in this case, the algorithm does a good job. The
    result shown in [Figure 10-21](ch10.xhtml#ch10fig21) conveys information similar
    to the scatterplot in [Figure 10-20](ch10.xhtml#ch10fig20), but now we can read
    off the number of cases from the color map.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig21.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-21: Two-dimensional histogram of two categories of crime*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe()` function that we met earlier is useful for getting an overview
    of this type of data. The result can be made more concise by eliminating the uninteresting
    bits:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The last column in the description table informs us that there are no missing
    values. The reason for the composite data types is that the summary dataframe
    contained a row of county names that we eliminated with the indexing expression,
    so these columns actually contain a mix of numbers and strings.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine the two-dimensional histogram of [Figure 10-21](ch10.xhtml#ch10fig21)
    with normal one-dimensional histograms of each variable using the `marginalhist()`
    recipe from `StatsPlots`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The result, shown in [Figure 10-22](ch10.xhtml#ch10fig22), is a nice visualization
    of two distributions simultaneously.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig22.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-22: Illustrating the marginal histogram plot recipe*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StatsPlots` package has another trick up its sleeve. It can combine some
    of the plots we’ve already seen into a composite visualization that makes it easy
    to pick out associations and patterns among a group of variables almost at a glance.
    This is achieved with the `corrplot()` recipe, as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We’ve chosen three variables to look at; it’s possible to look at everything
    at once, or any other subset with more than two categories. The need to include
    the `fillcolor` argument is a bug that may be fixed by the time you are reading
    this, so you may want to try omitting it. It controls the palette used in the
    two-dimensional histograms, and, as you saw earlier, it’s not needed in regular
    `histogram2d` plots to get the default coloring.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-23](ch10.xhtml#ch10fig23) shows the result.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig23.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-23: A correlation plot*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe produces a matrix of plots comparing every possible combination
    of pairs of variables from the vector of arrays provided in the first argument.
    Along the diagonal of this plot matrix (where the two variables are identical)
    we have conventional, one-dimensional histograms; above the diagonal, we see all
    three possible two-dimensional histograms; and below the diagonal, we have all
    the scatterplots, using transparent points. As a bonus, the scatterplots also
    feature regression (best fit) lines drawn through the points, and the marker color
    reflects the type of correlation: positive correlations are blue, lack of correlation
    is indicated by yellow, and negative correlations are red. This is a powerful
    visualization that carries a rich payload of information. A quick look tells us
    that failure to complete secondary school is unrelated to rates of vehicle theft
    or robbery, but those two types of crime are correlated with each other.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Packages**'
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section briefly describes a few more tools that readers interested in statistics
    will want to be aware of. See “Further Reading” on [page 359](ch10.xhtml#fur10)
    for some additional resources you may find useful.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '***JuliaDB for Out of Core Datasets***'
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dataframes are powerful data types, but they’re intended for data structures
    that fit in RAM. For data that is too large to fit in memory, a better choice
    is `JuliaDB`, which is designed to work efficiently with such “out of core” datasets.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '***RCall for Interacting with R***'
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The R programming language is a long-established language and system for statistical
    analysis. Like Julia, R is free software and has a large population of devoted
    users. However, it is not a good general-purpose programming language, and it
    can be quite slow for certain types of calculations. If you are starting a new
    project, and do not happen to have a personal library of R code that you have
    developed over the years, I recommend using Julia for your statistics needs. It
    already has a large and capable ecosystem of statistical packages, and more packages
    are being added every day. Julia won’t let you down if your analysis program turns
    into something that needs to run quickly on big data. Its ability to run on GPUs
    and other multiprocessor hardware, and the efficiency of its compiled code, means
    that you won’t need to rewrite your programs in order for them to scale.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have already invested time and effort into writing R routines
    that you want to keep using, you need not rewrite them. You can use them from,
    and in combination with, Julia. The `RCall` package has several macros for interoperating
    with R routines and data structures, as well as a special REPL mode for interacting
    directly with R within the Julia session. In fact, as soon as you type `using
    RCall`, an R process starts up in the background. It locates your R installation
    and can even install R for you.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '***P-hacking***'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For calculating p-values and performing other analyses to contribute to the
    replication crisis in science, the `HypothesisTests` package at [*https://github.com/JuliaStats/HypothesisTests.jl*](https://github.com/JuliaStats/HypothesisTests.jl)
    is invaluable.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The concepts and techniques of statistics cut across all scientific disciplines.
    Julia, with its statistics packages, puts a lot of exploratory and analytical
    power at our fingertips. Good integration with the `Plots` package makes visualization
    fast and easy as well. While systems such as R, a standard for statistical analysis
    for decades, offer some functions not yet built into Julia’s packages, the latter
    are developing quickly. Julia has some advantages today over the venerable workhorses:
    the ease of developing in the language makes it easier to add missing capabilities,
    and Julia’s efficiency frees you from the need to rewrite your code in a faster
    language when faced with big data or computationally intensive analyses.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit some of the concepts introduced in this chapter in the next chapter,
    with simulated evolution, and in [Chapter 13](ch13.xhtml), where we explore the
    techniques of probabilistic programming to make inferences about models.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: For details on the lava lamp entropy project, see [*https://blog.cloudflare.com/randomness-101-lavarand-in-production/*](https://blog.cloudflare.com/randomness-101-lavarand-in-production/).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pandemic simulation in this chapter implements a simplified model along
    the lines of the widely used COVID-19 model developed at [*https://github.com/mrc-ide/covid-sim*](https://github.com/mrc-ide/covid-sim).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The formula for the combination of events used in the pandemic simulation is
    derived in Chapter IV of William Feller’s standard work on probability theory,
    *An Introduction to Probability Theory and Its Applications*, Volume 1 (Wiley
    1968).
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative random number generator designed for long-term stability is available
    at [*https://github.com/JuliaRandom/StableRNGs.jl*](https://github.com/JuliaRandom/StableRNGs.jl).
    You may want to use it if you would like your programs to use the same pseudorandom
    sequences across future versions of Julia and its packages.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RCall` package resides at [*https://github.com/JuliaInterop/RCall.jl*](https://github.com/JuliaInterop/RCall.jl).
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A frequently updated list of Julia statistics and machine learning packages,
    with brief descriptions, is available at [*https://github.com/JuliaStats*](https://github.com/JuliaStats).
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See this 20-minute tutorial video by Juan Klopper for an introduction to statistics
    in Julia: [*https://www.youtube.com/watch?v=xbsr46Dw8hg*](https://www.youtube.com/watch?v=xbsr46Dw8hg).'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A textbook by Yoni Nazarathy and Hayden Klok about doing statistics, data science,
    and machine learning with Julia is available at [*https://statisticswithjulia.org*](https://statisticswithjulia.org).
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The headquarters of the `JuliaDB` package is [*https://juliadb.juliadata.org/latest/out_of_core/*](https://juliadb.juliadata.org/latest/out_of_core/).
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on dataframes as collections of rows is available at [*https://bkamins.github.io/julialang/2023/02/24/dfrows.html*](https://bkamins.github.io/julialang/2023/02/24/dfrows.html).
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
