- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: STATISTICS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学**
- en: '*The true Logic for this world is the Calculus of Probabilities.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个世界的真正逻辑是概率微积分。*'
- en: —James Clerk Maxwell
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —詹姆斯·克拉克·麦克斯韦
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Many readers of this book are likely to skip one or more chapters in [Part II](part2.xhtml).
    A biologist may not be interested in physics applications, for example. But *this*
    particular chapter has something in it for everyone, because sooner or later,
    all scientists must deal with the subject of statistics.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的许多读者可能会跳过[第二部分](part2.xhtml)中的一个或多个章节。例如，一位生物学家可能对物理应用不感兴趣。但是*这一*特定章节对每个人都有帮助，因为迟早所有科学家都必须面对统计学这一主题。
- en: Anyone conducting experiments knows that the treatment and analysis of experimental
    data is a direct application of statistical methods and concepts. Every scientific
    calculator features buttons for calculating means and standard deviations of rows
    of numbers. In this chapter, you will learn how to apply Julia and its statistical
    libraries to manipulate, plot, and analyze all kinds of data. Julia is generally
    faster, more flexible, more extensible, and more powerful than R, the near-standard
    language in this field. But if you have R programs that you are already working
    with, I’ll explain how to use them from within your Julia environment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进行实验的人都知道，实验数据的处理和分析是统计方法和概念的直接应用。每台科学计算器都配有用于计算一组数字的均值和标准差的按钮。在本章中，你将学习如何应用Julia及其统计库来操作、绘制和分析各种数据。与统计学领域的标准语言R相比，Julia通常更快、更灵活、更可扩展且更强大。但如果你已经在使用R程序，我会解释如何在Julia环境中使用它们。
- en: 'The concepts of probabilities and distributions are ubiquitous in physics,
    from the classical theories of statistical mechanics to quantum theory, in which
    probability plays a fundamental role. But statistics, and its basis in the language
    of probabilities, has its fingerprints all over science, even apart from experiments
    and observations. One of the detailed examples in this chapter involves probabilistic
    modeling in biology: an application of these ideas outside of both analysis of
    experiments and physics.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 概率和分布的概念在物理学中无处不在，从经典的统计力学理论到量子理论，其中概率扮演着基础性角色。而统计学及其在概率语言中的基础，在科学中几乎无处不在，即使在实验和观察之外也是如此。本章中的一个详细例子涉及生物学中的概率建模：这些思想在分析实验和物理学之外的应用。
- en: '**Probability**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**概率**'
- en: We don’t have the space here for a complete course in probability and statistics,
    but fortunately, we can do everything we need to do without a detailed mathematical
    development. Almost all scientists have some familiarity with the basic concepts
    and methods of the discipline, but I will not assume any special knowledge.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里没有足够的篇幅讲解完整的概率和统计课程，但幸运的是，我们可以在没有详细数学推导的情况下做我们需要做的一切。几乎所有科学家都对这一学科的基本概念和方法有所了解，但我不会假设读者有任何特别的知识。
- en: To understand and use statistics, we first need a clear grasp of *probability*.
    For our purposes, we can understand a probability as a number between 0 and 1,
    inclusive, that represents the likelihood of an event. A probability of 0 means
    that the event is impossible, and a probability of 1 means that it must occur.
    Any other probability can be interpreted as the frequency, or proportion of times,
    with which the event will occur in a large number of experiments. For example,
    if we say that the probability of heads when you flip a coin is 1/2, this means
    if you flip the coin a large number of times, the ratio of times that it comes
    up heads divided by the total number of flips will be close to 0.5.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解和使用统计学，我们首先需要清楚地掌握*概率*。在我们的应用中，我们可以把概率理解为一个介于0和1之间的数（包括0和1），它表示某事件发生的可能性。概率为0意味着该事件不可能发生，而概率为1意味着该事件必然发生。其他任何概率可以被解释为在大量实验中该事件发生的频率或比例。例如，如果我们说抛硬币时正面朝上的概率是1/2，这意味着如果你抛硬币很多次，硬币正面朝上的次数与总抛掷次数的比例将接近0.5。
- en: How many times is a large number of times? What we really mean is that there
    is a limit
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的“多次”到底是多少次？我们真正的意思是这里有一个极限
- en: '![Image](../images/306math.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/306math.jpg)'
- en: which just says that as we do more and more experiments, the number of times
    that we observe the event *x*, *n*[*x*], divided by the total number of experiments,
    *N*, gets closer and closer to a certain ratio. We call this ratio the probability.
    In probability theory, *experiment* means a process, such as flipping a coin or
    rolling a die.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是说，当我们做更多实验时，观察到事件*x*的次数*n*[*x*]，除以实验总次数*N*，将越来越接近某个特定比例。我们称这个比例为概率。在概率论中，*实验*指的是一个过程，例如掷硬币或掷骰子。
- en: The preceding paragraph describes a particular view of probability called the
    *frequency interpretation*. There are other ways to look at probability and its
    meaning, but in some sense, they are all equivalent. The frequency interpretation
    is practical, serves our purposes well, and is what most people think of when
    they need to pin down their idea of what probability means in practice. For more
    formal approaches to the subject, see “Further Reading” on [page 359](ch10.xhtml#fur10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面一段描述了概率的一种特定观点，叫做*频率解释*。当然也有其他方式来看待概率及其含义，但从某种意义上来说，它们都是等价的。频率解释是实用的，能够很好地服务于我们的目的，而且是大多数人在需要明确理解概率实际含义时所想到的方式。有关该主题的更正式的探讨，请参见[359页](ch10.xhtml#fur10)中的“进一步阅读”。
- en: 'We’ll often want to simulate events in our computer programs that are supposed
    to occur with certain probabilities. This could be part of the simulation of a
    system, such as the molecules of a gas bouncing around in a box, which we may
    want to initialize with random positions and velocities, or it could be part of
    a statistical test. But this presents a problem: if probability represents chance,
    the outcome of some kind of random process, and what goes on inside our computers
    is (we certainly hope) deterministic, how can we use computers to generate random
    events?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常希望在计算机程序中模拟某些事件，这些事件应当以某些概率发生。这可能是系统模拟的一部分，比如模拟气体分子在盒子里碰撞，我们可能希望用随机的位置和速度来初始化这些分子，或者它可能是统计检验的一部分。但这就提出了一个问题：如果概率代表机会，即某种随机过程的结果，而我们计算机内部的过程（我们当然希望如此）是确定性的，那么我们如何利用计算机生成随机事件呢？
- en: For the purposes of the examples in this book, we actually don’t want our random
    events to be random, because we may want to repeat simulations or check to see
    whether we get identical results after changing a computational technique. We
    need to be able to repeat particular sequences of “random” events. Surely this
    is a contradiction. If we know what’s going to happen, it can’t be random.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书中的例子而言，我们实际上并不希望我们的随机事件是随机的，因为我们可能希望重复模拟或者检查在改变计算方法后是否会得到相同的结果。我们需要能够重复特定的“随机”事件序列。这看起来似乎是一个矛盾。如果我们知道结果会是什么，它就不可能是随机的。
- en: The random numbers we generate in our programs are called *pseudorandom* numbers.
    They look like sequences of random numbers, satisfy certain tests of randomness,
    and adhere to given *distributions* (explained next). However, naturally, they
    are not really random. Again, we don’t actually want them to be.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中生成的随机数被称为*pseudorandom*（伪随机）数。它们看起来像是随机数的序列，满足某些随机性测试，并且遵循给定的*分布*（接下来会解释）。然而，本质上它们并不真正是随机的。再次强调，我们并不是真的希望它们是完全随机的。
- en: Except when we do. In some cryptography applications, we really need actual,
    unpredictable random numbers. Because the bad guys know the various algorithms
    for generating pseudorandom numbers, being able to predict such sequences can
    lead to defeating cryptographic systems. For such purposes, computer security
    systems exploit sources of real unpredictability available on any computer (known
    as *entropy sources*). These sources can be stored data derived from the timing
    of key presses on the keyboard, for example. The search for entropy has led to
    some creative solutions, such as pointing cameras at a wall of lava lamps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们确实需要。在某些密码学应用中，我们确实需要真正的、不可预测的随机数。因为不法分子知道各种生成伪随机数的算法，能够预测这些序列可能会导致破解密码系统。为了这样的用途，计算机安全系统利用计算机上任何可用的真实不可预测性来源（称为*熵源*）。这些来源可以是键盘上按键时间生成的存储数据。例如，熵的寻找促使了一些创意的解决方案，比如对着熔岩灯墙拍照。
- en: Julia actually provides a way to tap into the entropy provided by your operating
    system. However, in this book, we are not interested in cryptography, but in science,
    so we want our random numbers to be not so random, and we’ll be using Julia’s
    pseudorandom number generators. I’ll follow common practice for the rest of this
    chapter and just call these pseudorandom numbers “random numbers.”
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Julia实际上提供了一种方法，可以利用操作系统提供的熵。然而，在本书中，我们并不关心密码学，而是关注科学，所以我们希望我们的随机数并不那么随机，我们将使用Julia的伪随机数生成器。接下来的章节中，我会遵循常见做法，将这些伪随机数称为“随机数”。
- en: '**Random Numbers in Julia**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Julia中的随机数**'
- en: Julia has functions for generating random numbers with all kinds of numerical
    types, even complex numbers. The basic random number generators are part of `Base`,
    so you can use them without any `import` statements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Julia有用于生成各种数值类型的随机数的函数，甚至包括复数。基本的随机数生成器是`Base`的一部分，因此你可以在不需要`import`语句的情况下直接使用它们。
- en: '**NOTE**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I mentioned earlier that one reason to use pseudorandom numbers is so we can
    repeat a sequence of random numbers when developing code. This sequence repeatability
    is not guaranteed to work forever, however. The random sequence returned by a
    particular function can change when upgrading Julia, so you can’t depend on this
    for code development over the long term. See “Further Reading” on [page 359](ch10.xhtml#fur10)
    if you need long-term reproducible number sequences.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*我之前提到过，使用伪随机数的一个原因是我们在开发代码时可以重复一个随机数序列。然而，这种序列的可重复性并不能保证永远有效。特定函数返回的随机序列可能在升级
    Julia 后发生变化，因此你不能长期依赖它进行代码开发。如果你需要长期可复现的数字序列，请参见[第359页](ch10.xhtml#fur10)的“进一步阅读”。*'
- en: The simplest use is just calling `rand()`, which returns a random `Float64`
    *uniformly distributed* in the interval [0, 1). This means that the number might
    be equal to 0, but it will be less than 1, and all numbers in this interval are
    equally likely.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用法是调用`rand()`，它会返回一个在区间[0, 1)内均匀分布的随机`Float64`。这意味着数字可能等于0，但会小于1，并且区间内的所有数字都是等可能的。
- en: 'We can check that the `rand()` function is doing what we expect by generating
    a bunch of random numbers and plotting them with a scatterplot. We could do this
    by calling `rand()` many times, storing its returned values in an array, and plotting
    the array. But `rand()` makes it even easier: if we give it an integer argument,
    it will oblige us by returning an array of random values whose length will be
    determined by the argument. If we give it more than one, we’ll get back a higher-dimensional
    array. The little program shown in [Listing 10-1](ch10.xhtml#ch10lis1) fills a
    length-10⁵ array with random floats and visualizes their distribution with a scatterplot.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过生成一堆随机数并用散点图绘制它们来检查`rand()`函数是否按预期工作。我们可以通过多次调用`rand()`，将其返回的值存储在数组中，并绘制该数组来实现。但`rand()`使这一过程变得更简单：如果我们传递一个整数参数，它会按要求返回一个随机值数组，其长度由参数决定。如果我们传递多个参数，它会返回一个更高维的数组。[列表
    10-1](ch10.xhtml#ch10lis1)中的小程序将一个长度为10⁵的数组填充随机浮点数，并通过散点图可视化它们的分布。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Testing random number generation*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1：测试随机数生成*'
- en: In the resulting plot, shown in [Figure 10-1](ch10.xhtml#ch10fig1), each of
    the 10⁵ numbers is represented by a tiny dot. All the numbers lie within the correct
    interval, and they appear to be randomly and uniformly distributed, as they are
    supposed to be. A plot like this is a useful visual check to ensure that a pseudorandom
    number generator is behaving correctly and not introducing any unwanted patterns
    in the distribution of values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果图中，如[图 10-1](ch10.xhtml#ch10fig1)所示，每个10⁵个数字由一个小点表示。所有数字都位于正确的区间内，并且它们似乎是随机且均匀分布的，正如它们应该的那样。像这样的图表是一个有用的视觉检查，用来确保伪随机数生成器行为正常，并且没有在数值分布中引入任何不需要的模式。
- en: '![Image](../images/ch10fig01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig01.jpg)'
- en: '*Figure 10-1: Uniformly distributed random floats*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：均匀分布的随机浮点数*'
- en: 'To get random integers, or some type other than floats, simply pass the type
    as an argument. The call `rand(Int)`, which is the same as `rand(Int64)`, returns
    a random integer within the range defined by the lowest and highest possible integers
    of that type. This is rarely what you want in applications, however. You’ll probably
    want a random integer within some specified range that is relevant to your problem.
    In that case, simply pass the range as an argument: `rand(1:6)` represents the
    roll of a die, for example.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取随机整数或其他类型（而不是浮点数），只需将类型作为参数传递即可。调用`rand(Int)`（与`rand(Int64)`相同）将返回一个在该类型所定义的最小和最大整数范围内的随机整数。然而，这在应用程序中很少是你想要的。你可能希望得到一个在某个特定范围内的随机整数，这个范围与你的问题相关。在这种情况下，只需将范围作为参数传递：例如，`rand(1:6)`表示掷骰子。
- en: In fact, that argument can be a tuple or list as well, from which `rand()` will
    pick a random element, all with equal likelihood. You can even do something like
    `rand([1, 3, "abc"])`, and get either `1`, `3`, or the string `"abc"`, each with
    a probability of 1/3\. If you pass in a single string, it will be considered a
    collection of characters, and you will get a random character back.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，该参数也可以是元组或列表，`rand()`会从中随机选择一个元素，且每个元素的选择概率相等。你甚至可以像这样做：`rand([1, 3, "abc"])`，并随机得到`1`、`3`或字符串`"abc"`，每个的概率都是1/3。如果你传入一个字符串，它会被视为字符集合，返回一个随机字符。
- en: 'The simple call `rand()` is useful in simulations where you want events to
    occur with a certain probability. If the probability of the event is supposed
    to be `P`, in your code, you’ll have something like the following, which is a
    way to make something happen with a specified probability:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`rand()`调用在模拟中非常有用，特别是当你希望某些事件按特定概率发生时。如果事件发生的概率是`P`，那么在代码中你将看到类似以下的内容，这是一种让某件事以指定概率发生的方式：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The call to `rand()` works because it generates *uniformly distributed* random
    numbers in the interval [0, 1). Imagine repeatedly throwing a dart at a square
    dartboard one meter on a side (and assume it lands in a random place on the board).
    In the long run, the dart will land within the rightmost 90 centimeters 90 percent
    of the time. The `rand()` function is the dart.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`rand()`有效，因为它会生成在区间[0, 1)内*均匀分布*的随机数。想象一下，反复把飞镖投向一个边长为一米的正方形飞镖板（假设它会随机落在板上的某个位置）。从长远来看，飞镖将有90%的时间落在最右边的90厘米范围内。`rand()`函数就像是那个飞镖。
- en: Keeping in mind that, over the long term, you can’t count on being able to repeat
    a particular sequence generated by one of Julia’s random number functions, you’ll
    need to know how to do it in the short term when debugging code or developing
    an algorithm. You’ll often want to rerun a program after changing something that
    you believe should not change the results. If the program uses random numbers,
    and the sequence is truly unpredictable, such tests become impossible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从长远来看，你无法依赖Julia的随机数函数生成的特定序列能够重复，因此在调试代码或开发算法时，你需要知道如何在短期内做到这一点。当你更改某些你认为不应该改变结果的部分时，你通常会希望重新运行程序。如果程序使用了随机数，而且序列是真正不可预测的，这种测试就变得不可能了。
- en: By passing a *seed* to a random number generator, you can generate a sequence
    of high-quality pseudorandom numbers and also repeat the same sequence in subsequent
    runs of your program. To do this, you need to import the `Random` package, as
    you’ll need to use at least one function that’s not in `Base`. But `Random` has
    a few other goodies, as you’ll see shortly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个*种子*传递给随机数生成器，你可以生成一系列高质量的伪随机数，并且在程序的后续运行中重复相同的序列。为了做到这一点，你需要导入`Random`包，因为你将需要使用至少一个不在`Base`中的函数。但`Random`还有一些其他的有用功能，稍后你会看到。
- en: 'The following listing shows the three lines of code that illustrate the basic
    procedure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是展示基本过程的三行代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After importing `Random`, the `MersenneTwister()` function, which is a random
    number–generating algorithm, will be available. The name comes from the mathematical
    library from which the function is taken. Its argument, in this case `7654`, is
    called a *seed*. The purpose of the seed is to generate a particular sequence
    that we can repeat if needed. The `rand()` function, and all the other random
    number functions in Julia, accept an optional first argument that specifies the
    particular instance of the generator to use. As before, every time we call `rand()`,
    we get a random number between 0 and 1\. But now we can restart the sequence anytime
    we want by reinitializing `rgen` using the same seed. We can generate a different,
    unpredictable sequence by simply changing the seed. Except for the most casual
    use, you should always specify a generator and supply it with a seed rather than
    using the simpler form of `rand()` as we did in the previous example.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `Random` 后，`MersenneTwister()` 函数，即一个随机数生成算法，就可以使用了。这个名字来自于该函数所在的数学库。它的参数，在这个例子中是
    `7654`，被称为 *种子*。种子的目的是生成一个特定的序列，如果需要，我们可以重复使用该序列。`rand()` 函数，以及 Julia 中的所有其他随机数函数，都接受一个可选的第一个参数，用于指定使用的生成器实例。如前所述，每次调用
    `rand()` 时，我们都会得到一个 0 到 1 之间的随机数。但现在，我们可以通过重新初始化 `rgen` 并使用相同的种子，随时重新启动序列。我们可以通过简单地更改种子来生成一个不同的、不可预测的序列。除了最简单的使用情况外，你应该始终指定一个生成器，并为其提供一个种子，而不是像我们在前一个示例中那样使用更简单的
    `rand()` 形式。
- en: '**The Monty Hall Problem**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Monty Hall 问题**'
- en: The ability to generate random numbers opens up a whole world of possibilities
    for interesting simulations. First, let’s consider the *Monty Hall problem*, which
    is named after the longtime host of the game show *Let’s Make a Deal*. This problem
    is guaranteed to generate lively debate in statistics classes and is something
    that experienced mathematicians, even statisticians, often get wrong—or they used
    to, before the problem became famous. For us, it will serve as an example of how
    a probabilistic computer simulation can verify a result that we believe we have
    calculated analytically. Simulations can supply some additional confidence in
    the solutions to tricky probability problems, where it is so easy to go astray
    analytically.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的能力为有趣的模拟开辟了广阔的可能性。首先，让我们考虑一下 *Monty Hall 问题*，它以长期主持游戏节目 *Let's Make a
    Deal* 的 Monty 为名。这个问题在统计学课堂上常常引发激烈的辩论，甚至经验丰富的数学家，甚至统计学家，常常也会犯错——或者他们曾经会犯错，直到这个问题变得有名。对我们来说，这将作为一个例子，展示如何通过概率计算机模拟验证我们认为已经通过分析方法计算出的结果。模拟可以为那些难度较大的概率问题提供额外的信心，因为在这些问题中，分析计算很容易出现偏差。
- en: Imagine three doors. Behind one is a prize, say, a fancy car, and behind the
    other two are joke prizes. Monty often used goats for these “loser” prizes. You
    want the car. Monty asks you to choose a door. He knows where everything is, but
    you know nothing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有三扇门。 behind one is a prize, say, a fancy car, and behind the other two
    are joke prizes. Monty often used goats for these “loser” prizes. You want the
    car. Monty asks you to choose a door. He knows where everything is, but you know
    nothing.
- en: 'Let’s say, to be definite, that you choose door #1\. Before revealing what’s
    behind that door, Monty opens one of the other ones, say, door #3, to reveal a
    goat. He offers you the chance to switch to door #2 if you like.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你选择了门 #1。 在揭示门后面是什么之前，Monty 打开了另一个门，比如门 #3，露出了一个山羊。他给你机会，如果你愿意的话，可以换到门 #2。'
- en: 'Here is the question: should you stick with your original choice or switch
    to door #2? Does it matter?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '问题来了：你应该坚持原来的选择，还是换到门 #2？这有关系吗？'
- en: 'The correct answer is that you should switch. Nevertheless, many people have
    a strong initial intuition that it must not make any difference. After all, now
    two doors are available: door #1 and door #2\. Surely they have an equal chance
    of leading to the prize, so it’s the same as flipping a coin: heads or tails are
    equally likely.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '正确答案是你应该换门。然而，许多人最初的直觉是，换不换都没有区别。毕竟，现在有两扇门可以选择：门 #1 和门 #2。它们应该有相等的机会通向奖品，所以这就像抛硬币：正面或反面是一样可能的。'
- en: 'However, this thinking is wrong. Initially, the probability that your choice
    was a winner was 1/3\. Everyone agrees with that. That means that the probability
    that the prize was in *one of the other doors* is 2/3\. Since the prize is guaranteed
    to be somewhere, the total probability must add up to 1\. These initial probabilities
    still hold. The probability that door #1 is the winner is still 1/3\. The probability
    that one of the others is, instead, is still 2/3\. But now the set of “one of
    the others” consists of just door #2, since Monty has eliminated door #3\. You
    should switch to increase your chances of winning from 1/3 to 2/3.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种思维是错误的。最初，你的选择是赢家的概率是1/3。大家对此都同意。这意味着奖品在*其他门之一*的概率是2/3。由于奖品一定在某个地方，所以总概率必须加起来等于1。这些初始概率仍然成立。门#1是赢家的概率仍然是1/3。而其他门成为赢家的概率依然是2/3。但是现在，“其他门”这一组只包含门#2，因为蒙提已经排除了门#3。你应该切换选择，将你的获胜概率从1/3提高到2/3。
- en: This analysis is just one of many ways to approach the problem, but they all
    (if done correctly) lead to the same conclusion. Nevertheless, at this point many
    people remain unconvinced. Sometimes actually doing the experiment can persuade
    people who don’t believe in math.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析只是解决问题的众多方法之一，但它们都（如果做得正确）会得出相同的结论。然而，在这个时候，许多人仍然持怀疑态度。有时，实际上进行实验可以说服那些不相信数学的人。
- en: 'The following program performs just such an experiment—a simple example of
    a simulation using a random process:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序就执行了这样的实验——一个使用随机过程的简单模拟示例：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program plays the game `N` times, where `N` is set to 3,000\. It stores
    the record of wins or losses in two arrays, one for the set of 3,000 plays where
    the player stays with the initial choice of door and one for the round where the
    player decides to switch. The arrays are initialized to be all 0s. If the player
    wins game number `game`, that array element is changed to 1.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序玩`N`次游戏，其中`N`设为3,000。它将胜负记录存储在两个数组中，一个是玩家保持初始选择的3,000次游戏记录，另一个是玩家决定切换的回合记录。数组初始化为全0。如果玩家在第`game`局获胜，则该数组元素会变为1。
- en: The two arrays ➊ hold the running average of each strategy, defined using list
    comprehensions. These are the arrays we want to look at.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数组➊保存了每种策略的运行平均值，这是通过列表推导式定义的。这些就是我们要查看的数组。
- en: The plot in [Figure 10-2](ch10.xhtml#ch10fig2) shows that in the long run the
    switching strategy wins 2/3 of the time, while the player who stubbornly sticks
    with the initial choice wins only 1/3 of the time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-2](ch10.xhtml#ch10fig2)中的图表显示，从长远来看，切换策略获胜的概率为2/3，而固执地坚持初始选择的玩家仅获胜1/3的时间。'
- en: '![Image](../images/ch10fig02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch10fig02.jpg)'
- en: '*Figure 10-2: Two Monty Hall strategies*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：两种蒙提霍尔策略*'
- en: 'These ratios agree with the argument if we remember the meaning of the frequency
    interpretation of probability: over the long run, the ratio of events (wins, in
    this case) to the total number of experiments should approach the probability.
    Note that if you run this code yourself, the graph may look slightly different,
    because you’ll get a different sequence of random numbers, but the *long-term
    behavior* should be the same.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们记住概率的频率解释的含义，这些比例与论点一致：从长远来看，事件（在本例中是获胜）的比率与总实验次数的比率应该接近概率。请注意，如果你自己运行这段代码，图表可能会略有不同，因为你会得到不同的随机数序列，但*长期行为*应该是相同的。
- en: '**Counting**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**计数**'
- en: After probability, the next most important idea in statistics is *counting*,
    also called *combinatorics*. Counting has to do with answering questions about
    how many ways an event can happen. If you roll a pair of dice, in how many ways
    can the sum of the two numbers that come up equal six? If there are 30 people
    on the squad, how many nine-person baseball teams are possible?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在概率之后，统计学中下一个最重要的概念是*计数*，也叫做*组合数学*。计数与回答一个事件有多少种发生方式相关。如果你投掷一对骰子，骰子上的两个数字加起来等于六的方式有多少种？如果队伍中有30人，那么有多少种可能的九人棒球队？
- en: When simulating systems involving probability on a computer, to calculate correctly
    the probabilities of various events, we often *count* the number of ways a given
    event can happen and divide by the total number of all possibilities. If all of
    the ways are equally likely, this gives us the probability.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上模拟涉及概率的系统时，为了正确计算各种事件的概率，我们通常会*计数*某个事件发生的方式数，并除以所有可能性中的总数。如果所有方式的可能性相等，这就给出了概率。
- en: In the dice example, there are 10 ways to get a sum of six, so the probability
    is 10/36.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在掷骰子的例子中，得到和为六的方式有10种，所以概率是10/36。
- en: 'Two additional counting concepts arise frequently when dealing with probabilistic
    situations, and often in other places as well: *permutations*, calculated using
    factorials, and *combinations*, which involve binomial coefficients.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理概率问题时，另外两个计数概念经常出现，通常在其他地方也会用到：*排列*（通过阶乘计算）和*组合*（涉及二项式系数）。
- en: '***Factorials***'
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***阶乘***'
- en: 'The first counting concept is the idea of *permutations*: the number of distinct
    ways to arrange a collection of objects. If you have eight *Scrabble* tiles, all
    bearing different letters, how many different eight-letter strings can you make
    out of them?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个计数概念是*排列*：排列一组物体的不同方式的数量。如果你有八个*拼字游戏*字母牌，每个字母都不同，那么你能从中组成多少种不同的八个字母的字符串呢？
- en: The answer is 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40, 320.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 8 × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40, 320。
- en: 'Here’s a quick argument to show why this is true: there are eight ways to choose
    the first tile; once that is chosen, there are seven ways to choose the next tile;
    and so on. This pattern comes up so often that we have a special name and mathematical
    notation for it. It is called the *factorial*, and it’s written as 8! in this
    case. Julia also has a built-in function for it, but since `!` is used for other
    purposes, we need to spell it out: `factorial(8)`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的论证，展示为什么这个是正确的：选择第一个字母牌有八种方式；一旦选定了第一个字母牌，选择下一个字母牌有七种方式；依此类推。这个模式出现得非常频繁，以至于我们为它赋予了一个特殊的名称和数学符号，它叫做*阶乘*，在这种情况下写作
    8!。Julia 也有一个内置函数处理它，但由于 `!` 被用于其他目的，我们需要把它写为：`factorial(8)`。
- en: The factorial function grows insanely quickly, so above `factorial(20)`, you
    need to supply the argument as a `BigInt`, and you’ll get a `BigInt` back. How
    quickly does the factorial grow? The number of ways to arrange a standard 52-card
    deck is far larger than the number of stars in the universe. It’s so large that,
    after shuffling a deck, there is almost no chance that the particular arrangement
    of cards you are holding in your hand has existed before in the history of the
    world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数增长得非常快，因此在 `factorial(20)` 以上，你需要将参数作为 `BigInt` 提供，并且返回值也是 `BigInt`。阶乘增长的速度有多快？标准的52张扑克牌的排列方式的数量远大于宇宙中的星星数量。它大到一个程度，以至于洗牌后，你手中的扑克牌排列几乎不可能在世界历史上曾经出现过。
- en: '***Binomial Coefficients***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二项式系数***'
- en: 'The second combinatorial concept we’ll be using is the *binomial coefficient*.
    This comes up in many mathematical contexts, and Julia has a built-in function
    called `binomial()` that deals with it. In the context of counting, the binomial
    coefficient answers the baseball teams question mentioned earlier. If there are
    30 players available, the number of ways to form nine-member teams is written
    as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第二个组合概念是*二项式系数*。这个概念在许多数学场合都会出现，Julia 中有一个内置函数 `binomial()` 用于处理它。在计数的上下文中，二项式系数回答的是前面提到的棒球队问题。如果有30个可用的球员，那么组成九人小队的方式数量可以写作：
- en: '![Image](../images/313math.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/313math.jpg)'
- en: The baseball problem is calculated with `binomial(30, 9)`. The combinatorial
    term for these problems, involving binomial coefficients, is *combinations*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 棒球问题通过 `binomial(30, 9)` 计算。涉及二项式系数的这些问题的组合学术语是*组合*。
- en: 'See “Further Reading” on [page 359](ch10.xhtml#fur10) to learn more details
    about binomial coefficients: why they are so named, how to calculate them using
    factorials, and their connections to other areas of mathematics.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第359页](ch10.xhtml#fur10)的“进一步阅读”，了解更多关于二项式系数的细节：为什么它们这样命名，如何通过阶乘计算它们，以及它们与其他数学领域的联系。
- en: '**Modeling a Pandemic**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**流行病建模**'
- en: We now have enough tools to perform a significant calculation. [Listing 10-2](ch10.xhtml#ch10lis2)
    is a simulation that models the spread of an infection through a population. It’s
    similar to models epidemiologists use to perform computational experiments with
    different scenarios for the spread of COVID-19\. This model is a bit simplified
    relative to those, as my purpose is to illustrate an application of the tools
    and ideas from the chapter so far. For a pointer to similar models being used
    now in research, see “Further Reading.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的工具来进行一个重要的计算。[清单 10-2](ch10.xhtml#ch10lis2)是一个模拟，模拟了感染在人群中的传播。这类似于流行病学家用来进行计算实验的模型，研究不同的COVID-19传播情景。这个模型相较于那些稍显简化，因为我的目的是展示目前章节中的工具和思想的应用。有关现在研究中使用的类似模型，请参阅“进一步阅读”。
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-2: A pandemic simulation*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-2：一场大流行模拟*'
- en: 'The strategy is to represent the population as a square matrix. Each cell represents
    one person and can be in one of four possible states: `infected`, `dead`, `isolated`,
    or `ok`. An `isolated` person can’t become `infected`. An `ok` person is not `infected`,
    but may become so. An `infected` person may die after a certain number of “days,”
    or iterations, a number assigned to `dud`; if the person survives past this period,
    immortality is achieved. A `dead` person is no longer infectious. Thus, an `ok`
    person can never be infected (is “protected”) if surrounded by `dead` or `isolated`
    people. Death and lockdown prevent the spread of the disease.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该策略是将人口表示为一个方阵。每个单元格代表一个人，并且可以处于四种可能的状态之一：`infected`、`dead`、`isolated` 或 `ok`。一个
    `isolated` 的人无法变为 `infected`。一个 `ok` 的人没有被感染，但可能会感染。一个 `infected` 的人在经过一定天数（或迭代次数）后可能会死亡，这个天数由
    `dud` 参数赋值；如果此人活过了这一阶段，则达到了不死之身。一个 `dead` 的人不再具有传染性。因此，如果一个 `ok` 的人被 `dead` 或
    `isolated` 的人包围，那么他将永远不会被感染（处于“保护”状态）。死亡和隔离能防止疾病的传播。
- en: The simulation is initialized with probabilities, to establish both the starting
    state and its evolution. The state at `day = 1` is set up using the probabilities
    in the `initial` dictionary ➊. At every iteration, the state of each person is
    updated according to the probabilities in the `transition` dictionary on the following
    line and the value of `dud` in that dictionary, which is the number of days during
    which someone needs to be infected before the disease may become fatal.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是通过概率初始化的，用以建立起起始状态和其演变过程。`day = 1` 时的状态是通过 `initial` 字典中的概率来设置的 ➊。在每一次迭代中，根据
    `transition` 字典中的概率以及字典中的 `dud` 值（它表示在疾病可能致命之前，个体需要感染多少天）来更新每个人的状态。
- en: The population matrix is called `world`, and the length of its side is stored
    in `n`. Don’t take the matrix geometry too literally. It does not assume that
    people stand in one spot while the disease runs its course. The matrix `world`
    represents a network of contact rather than a spatial arrangement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 人口矩阵被称为 `world`，其边长存储在 `n` 中。不要太字面理解矩阵几何结构。它并不假设人们在某一地点静止不动，直到疾病发展完毕。矩阵 `world`
    代表的是接触网络，而不是空间排列。
- en: 'After importing some libraries that you have seen before and including a file
    with the plotting function, which we’ll get to later, the `pandemic()` function,
    which does the actual calculation, is defined. This function gets two keyword
    arguments: `seeding` should be either `:normal` or `:center`. In the former case,
    infection is seeded randomly, according to `initial["infected"]`; but if `seeding`
    is set to `:center`, a single infected individual is placed at the center of the
    world.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入一些你之前见过的库并包含一个绘图函数文件后（我们稍后会介绍），`pandemic()` 函数被定义出来，这个函数执行实际的计算。该函数接收两个关键字参数：`seeding`
    应该是 `:normal` 或 `:center`。在前者的情况下，感染是随机播种的，根据 `initial["infected"]` 来进行；但如果 `seeding`
    设置为 `:center`，则会在世界的中心放置一个感染个体。
- en: The second keyword, `plotmode`, controls whether daily plots are created, and
    if so, whether they are displayed or saved to files. At the end of the calculation,
    the `finish()` function is called, which saves a plot of the final state if the
    `plotmode` = `:last`. This function also uses the `@save` macro to save the `world`
    and the infection and death histories to a *.jld* file (introduced in [Chapter
    9](ch09.xhtml)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键字 `plotmode` 控制是否创建每日的图表，如果创建，图表是显示出来还是保存到文件中。在计算结束时，调用 `finish()` 函数，如果
    `plotmode` = `:last`，该函数会保存最终状态的图表。此函数还使用 `@save` 宏将 `world` 以及感染和死亡历史保存到一个 *.jld*
    文件中（该功能在[第9章](ch09.xhtml)中介绍）。
- en: At every iteration, the program has to decide, for each `ok` person, whether
    to change that person to the `infected` state. This is determined randomly, based
    on the probability of infection by each infected neighbor each day, given in `transition["infected"]`,
    and on the number of infected neighbors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，程序必须决定对于每个 `ok` 的人，是否将其状态更改为 `infected`。这个决定是随机的，基于每天每个感染邻居的感染概率（在 `transition["infected"]`
    中给出）以及感染邻居的数量。
- en: But, we need to be careful here. The probability of infection with two infected
    neighbors is not twice the probability of infection with only a single sick neighbor.
    We need to subtract the probability of becoming infected by both neighbors. We
    won’t provide a full treatment of the combination of events in probability theory
    here, but you likely can easily see why we can’t simply add the probabilities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要小心。两个感染者邻居的感染概率并不是单个感染邻居概率的两倍。我们需要减去同时被两个邻居感染的概率。这里我们不会全面讨论概率论中事件组合的内容，但你很可能能轻松理解为什么我们不能简单地将这些概率相加。
- en: 'Imagine you are flipping two coins and want to find the probability of getting
    at least one head. You know that the probability of a head with either coin alone
    is 1/2\. If you add those, you get a probability of 1\. But that can’t be right,
    because it would mean a head *must* appear, and you know there’s a good chance
    you’ll get two tails. The correct calculation includes subtracting the probability
    of *two* heads: 1/2 + 1/2 *–* 1/4 = 3/4\. You will get at least one head three-fourths
    of the time in the long run. At this point, you are in a good position to write
    a little Julia program to verify this, if you have any doubts.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在掷两个硬币，并想要找出至少有一个正面的概率。你知道，单个硬币正面的概率是1/2。如果你将这两个概率相加，你得到的总概率是1。但这显然不对，因为这意味着正面一定会出现，而你知道两枚硬币出现两个反面的可能性也很大。正确的计算应该减去两个正面同时出现的概率：1/2
    + 1/2 *–* 1/4 = 3/4。在长时间内，你至少会得到一个正面的概率是四分之三。此时，如果你有任何疑问，你已经处于一个良好的位置，可以编写一个简单的Julia程序来验证这一点。
- en: 'The coin problem corresponds exactly to the case where you are in contact with
    two infected people and the probability of infection = 1/2\. On the grid, however,
    each person can have up to eight neighbors. It’s a bit more complicated than the
    case of two neighbors, but the idea is the same. For each new neighbor, you have
    to add the probability of infection by that neighbor, but subtract all the combinations
    it can make with the other neighbors. The word *combinations* suggests that we
    might have to reach for a binomial coefficient, and indeed we do. The formula
    for the total probability of infection by *n* neighbors, if the probability of
    infection by a single neighbor is *p*, is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币问题正好对应于你与两个感染者接触，感染的概率 = 1/2。在网格上，每个人最多可以有八个邻居。这比两个邻居的情况要复杂一些，但思想是一样的。对于每一个新邻居，你需要增加该邻居导致的感染概率，但要减去它与其他邻居之间所有可能的组合。*组合*这个词暗示着我们可能需要使用二项式系数，事实上，确实需要。若一个邻居的感染概率为*p*，*n*个邻居的总感染概率公式为：
- en: '![Image](../images/317math.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/317math.jpg)'
- en: See “Further Reading” on [page 359](ch10.xhtml#fur10) for more about this formula
    and related matters. This probability is pre-calculated for all possible numbers
    of neighbors, `1:8`, and the results are stored in the `tpi` ➋ array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[第359页](ch10.xhtml#fur10)的“进一步阅读”，了解有关此公式及相关问题的更多信息。这个概率已经为所有可能的邻居数量`1:8`进行了预计算，结果存储在`tpi`➋数组中。
- en: It is necessary, before each iteration’s calculations begin, to make a copy
    of the `world` array, which is called `next` in the program ➌. We update the cells
    in `next`, and then copy it back into `world`. If `world` is updated in place,
    cells will be transitioned based on the partially updated information in neighbor
    cells, which would be inconsistent. A `copy` is required, as we’ve encountered
    in previous chapters, because a simple `next = world` would create a second reference
    to the array rather than an actual copy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代的计算开始之前，有必要先复制`world`数组，在程序中将其命名为`next` ➌。我们更新`next`中的单元格，然后将其复制回`world`。如果直接在`world`上更新，单元格将根据邻居单元格中部分更新的信息进行过渡，这将导致不一致。因此，需要进行`copy`，正如我们在前面的章节中遇到的那样，因为简单地使用`next
    = world`会创建对数组的第二个引用，而不是实际的复制。
- en: An array `aoi` is initialized to 0s ➍; it will record the `day` on which each
    person becomes infected, so that the survival probability can be applied at the
    appropriate time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`aoi`初始化为0➍；它将记录每个人感染的`day`，以便在适当的时候应用生存概率。
- en: The subsequent loops over persons within the loop over days, given all the foregoing,
    should be self explanatory. After the sweep of the matrix, we `push!()` ➎ new
    values for the current total number of infected and dead people onto the vectors
    `noi` and `nod`, respectively. Julia’s neat and succinct syntax calculates these
    totals using a sum over a binary array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了前述内容后，随后的循环将在天数的循环内进行人员遍历，应该不言自明。在矩阵扫描后，我们将`push!()` ➎ 当前感染和死亡人数的新值分别推送到向量`noi`和`nod`中。Julia
    简洁明了的语法通过对二进制数组求和来计算这些总数。
- en: Here, and in the previous loops over the `world`, the program treats only elements
    in `2:n-1` rather than the entire array, to implement the boundary condition.
    In keeping one row or column of cells on the boundaries “frozen,” the updating
    logic is simplified, as the expression, for example, for calculating the number
    of each person’s infected neighbors is identical for each nonfrozen person.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里以及前面的 `world` 循环中，程序仅处理`2:n-1`范围内的元素，而不是整个数组，以实现边界条件。通过将边界上的一行或一列“冻结”，更新逻辑简化了，例如，计算每个人感染邻居数量的表达式对于每个非冻结的人来说是相同的。
- en: As in a physics problem, there are other possibilities for boundary conditions.
    The people on the edges could be updated based on their reduced numbers of neighbors,
    but doing so can induce artifacts. Periodic boundary conditions are another possibility,
    where the neighbor-ness wraps around the matrix to the opposite side. Any choice
    is to some degree arbitrary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 像物理问题一样，边界条件还有其他可能性。边缘上的人们可以根据邻居数量的减少来更新，但这样做可能会引入伪影。周期性边界条件是另一种可能性，在这种条件下，邻居关系会绕过矩阵并连接到对面一侧。任何选择在某种程度上都是任意的。
- en: The conditional block ➏ checks to see whether the calculation has reached a
    steady state. If it has, there is no point in continuing, and the cleanup operation
    is called. The final line in the program starts the calculation by calling `pandemic()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 条件块 ➏ 会检查计算是否已经达到了稳态。如果已经达到了稳态，就没有必要继续计算，随后会调用清理操作。程序的最后一行通过调用`pandemic()`来启动计算。
- en: This simple algorithm can produce interesting behavior, and it can be used to
    explore questions such as the effect of lockdown conformity on the spread of the
    infection, and how a higher fatality rate can slow the growth of a pandemic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的算法可以产生有趣的行为，并且可以用来探索诸如封锁遵守对感染传播的影响，以及更高的致死率如何减缓疫情增长等问题。
- en: '[Figure 10-3](ch10.xhtml#ch10fig3) shows the output of a 512×512 simulation
    with these initial and transition probabilities:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-3](ch10.xhtml#ch10fig3)展示了一个 512×512 的模拟输出，初始和过渡概率如下：'
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The simulation stops after 1,064 iterations when reaching a steady state. The
    notation on the figure means that 5.48 percent of the population was protected
    from infection due to the isolation of others and the effects of mortality interrupting
    disease transmission.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟在进行 1,064 次迭代后停止，达到了稳态。图中的标注意味着由于他人的隔离和死亡率的作用，有 5.48% 的人群免受感染。
- en: '![Image](../images/ch10fig03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch10fig03.jpg)'
- en: '*Figure 10-3: Steady state reached in a pandemic simulation*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3：疫情模拟中的稳态*'
- en: See the book’s supplementary website ([*https://julia.lee-phillips.org*](https://julia.lee-phillips.org))
    for a color version of the plot and an animation of a similar simulation. In the
    printed grayscale version, the darkest shades on the heatmap plot represent dead
    or infected people, white represents people who remained protected from infection,
    and the middle tone corresponds to isolated people.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问本书的补充网站（[*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)），查看彩色版本的图表和类似模拟的动画。在打印的灰度版中，热图中最深的颜色代表死亡或感染的人，白色代表那些保持免疫的人群，中间的颜色表示被隔离的人。
- en: '[Listing 10-3](ch10.xhtml#ch10lis3) shows the simple function that calculates
    the protected percentage and makes plots as in [Figure 10-3](ch10.xhtml#ch10fig3).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-3](ch10.xhtml#ch10lis3)展示了一个简单的函数，该函数计算保护百分比并绘制如[图 10-3](ch10.xhtml#ch10fig3)所示的图表。'
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-3: Visualizing the pandemic*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：疫情可视化*'
- en: The `plotworld()` function uses the `@sprintf` macro ➊, introduced in “Macros
    for String Formatting” on [page 177](ch06.xhtml#ch06sec1sec11), to format the
    variable `protected` and the y-axis label for display. After creating three plots
    and storing them in `p1`, `p2`, and `p3`, the `@layout` macro, described in “Creating
    Complex Layouts Using @layout” on [page 118](ch04.xhtml#ch04lev1sec28), arranges
    them ➋ into a summary display of the simulation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotworld()`函数使用`@sprintf`宏 ➊，该宏在“字符串格式化宏”一节中介绍，[第177页](ch06.xhtml#ch06sec1sec11)，用于格式化变量`protected`和y轴标签进行显示。在创建了三个图并将其存储在`p1`、`p2`和`p3`中后，`@layout`宏，在“使用@layout创建复杂布局”一节中介绍，[第118页](ch04.xhtml#ch04lev1sec28)，将它们
    ➋ 安排成一个模拟结果的汇总展示。'
- en: '**Common Statistics Functions**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常见统计函数**'
- en: Julia provides functions to calculate all of the common statistical parameters,
    as well as special plotting functions for statistical visualization of data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Julia提供了计算所有常见统计参数的函数，以及用于数据统计可视化的特殊绘图函数。
- en: Some reorganization of the Julia statistics packages is underway, so everything
    may not be where you might expect it. This section describes where the packages
    are at the time of writing, but, when you try things out, you may discover that
    a function or two have moved.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Julia统计包正在进行一些重组，因此可能有些内容不在你预期的位置。本节描述了在写作时这些包的位置，但当你实际尝试时，可能会发现某些函数已经移动。
- en: If you are analyzing data of any kind, you will make heavy use of at least some
    of the functions described in this section, most of which are in the `Statistics`
    package, which is part of the standard Julia library. In the remainder of this
    chapter, I will assume you’ve imported the package with the `using Statistics`
    command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在分析任何类型的数据，你将大量使用本节描述的至少部分函数，其中大多数位于`Statistics`包中，该包是Julia标准库的一部分。在本章的其余部分，我假设你已经使用`using
    Statistics`命令导入了该包。
- en: The package provides the basic functions that summarize datasets with statistical
    parameters. For the *mean*, or arithmetic average, use `mean(`data`)`, where,
    here and below, data is some vector of observations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该包提供了总结数据集的基本函数，利用统计参数来进行描述。对于*均值*，或算术平均值，使用`mean(data)`，其中这里和下面的数据是一些观察值的向量。
- en: 'For the *median*, which is the middle value in the data, use `median(`data`)`.
    If there are an even number of data points, none of them can be the middle value.
    In this case, `median()` returns the mean of the two middle values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*中位数*，即数据中的中间值，使用`median(data)`。如果数据点数目为偶数，则没有一个数据点是中间值。在这种情况下，`median()`返回两个中间值的均值：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the time of writing, `Statistics` does not contain a *mode* function. The
    mode is the most common value, or the maximum of a continuous distribution, if
    it exists. From this idea come the terms *bimodal* and *multimodal* to describe
    distributions with more than one local maximum. The height distribution in [Figure
    10-4](ch10.xhtml#ch10fig4) is an example of a bimodal distribution.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，`Statistics`包不包含*众数*函数。众数是最常见的值，或者是连续分布的最大值（如果存在）。从这个概念出发，产生了*bimodal*和*multimodal*这两个术语，用来描述具有多个局部最大值的分布。[图10-4](ch10.xhtml#ch10fig4)中的身高分布就是一个双峰分布的例子。
- en: If you need a mode function, you can import it from another package called `StatsBase`,
    which you will need to `add`. `StatsBase` contains some other less commonly used
    statistical functions that are not in the standard `Statistics` package, but you
    may want to import only the ones you plan to use. If you just need to add a mode
    function to your toolbox, you can enter `import` `StatsBase.mode`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个众数函数，你可以从另一个名为`StatsBase`的包中导入它，你需要先`add`该包。`StatsBase`包含一些不常用的统计函数，这些函数不在标准的`Statistics`包中，但你可以只导入计划使用的那些。如果你只需要将众数函数添加到工具箱中，可以输入`import`
    `StatsBase.mode`。
- en: 'Here are a few examples showing how the `mode()` function behaves:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是几个示例，展示了`mode()`函数的行为：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If there is more than one mode, the function returns the first one. Consequently,
    if each value appears only once, they are all modes, so the function returns the
    first value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个众数，函数返回第一个众数。因此，如果每个值仅出现一次，它们都是众数，所以函数返回第一个值。
- en: 'The standard `Statistics` package contains most of the other basic statistical
    functions, including the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 标准`Statistics`包包含大多数其他基本统计函数，包括以下内容：
- en: std  Standard deviation
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: std  标准差
- en: stdm  Standard deviation with specified mean
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: stdm  具有指定均值的标准差
- en: var  Variance
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: var  方差
- en: varm  Variance with specified mean
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: varm  具有指定均值的方差
- en: cor  Pearson correlation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: cor  皮尔逊相关系数
- en: cov  Covariance
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: cov  协方差
- en: middle  (max + min) / 2
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: quantile  Quantile
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: These commands work on vectors or pairs of vectors of data in the way you would
    expect. In addition, the `cor()` function will accept a matrix and return a correlation
    matrix, and the `cov()` function can work similarly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mean()` function takes an optional first argument that can be a unary
    operator or a function of one numeric variable. The function then maps the operator
    or function over the data vector before calculating the mean. This can be convenient
    if you need to scale or otherwise process the data, but, for the case of a simple
    vector, it gives the same result as broadcasting the function over the array:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are two versions of the standard deviation and the variance used in statistics.
    The formula the `var()` function uses by default is
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/321math.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: where *μ* is the mean, the *x*[*n*] values are individual data points, *N* is
    the total number of data points, and *σ*² is the *sample variance*, or the variance
    with Bessel’s correction applied. The standard deviation `std()` is just the positive
    square root of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In order to calculate the *population variance* and *population standard deviation*,
    supply the keyword argument `corrected` with a value of `false` to either of these
    functions. This will replace the 1/(*N –* 1) term in the formula with 1/*N*. Explaining
    the origin of the correction would take us too far into the arcana of statistical
    theory, but for most purposes, the defaults are what you want, and it makes little
    difference for reasonably large *N* in any case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In either incarnation, the standard deviation is a measure of the average distance
    from the mean of a set of observations or of a theoretical distribution. It tells
    us how “spread out” the distribution is.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributions**'
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve looked at several examples of how we can do a lot with simple, uniformly
    distributed random numbers. However, not every random occurrence is uniformly
    distributed. Most things in nature display other types of distributions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the heights of adults in a particular city. Obviously, you don’t expect
    that the probability of finding a 7-foot-tall adult is the same as finding one
    with closer to average height: heights are not uniformly distributed. If you make
    a graph, dividing the horizontal axis into height ranges covering, say, intervals
    of 2 inches, and collect the heights of a sample of residents, you can plot how
    many heights fall into each interval. After collecting a large number of measurements,
    this plot will start to look like a smooth curve, something like [Figure 10-4](ch10.xhtml#ch10fig4).
    It has two peaks, because the average height of men is a little higher than women,
    and it shows that there are more people close to the average than very tall or
    very short.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: Possible histogram of adult heights*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This type of graph is called a *histogram*; it is one way to represent a *distribution*.
    Probability distributions are the mathematical objects at the center of statistics,
    just as a probability forms, naturally, the central idea of probability theory.
    A distribution simply tells you how much of your data, or what proportion of your
    data, falls within different ranges. As a description of actual data it’s called
    an *empirical distribution*, whereas if it comes from a model it’s a *theoretical
    distribution*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of the discipline of statistics this way: probabilities tell
    us how likely something is to happen, and the mathematics of probability theory
    lets us elaborate this, telling us the likelihood of combinations of events and
    answering related questions. Statistics is the reverse: it starts with observations,
    and lets us systematically infer the probabilities that led to those observations.
    With these probabilities, we can make predictions about future observations.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Julia provides several packages and a great number of functions for helping
    out with statistics, including functions for statistical graphing. To produce
    a histogram like the one shown in [Figure 10-4](ch10.xhtml#ch10fig4), simply call
    (after `using Plots`) `histogram(data, bins = 100)`. The `data` in this call is
    the actual series of observations; the `bins` tells the routine to use that number
    of intervals to construct the histogram. For each interval, it will count the
    number of observations in `data` and draw the rectangle at the appropriate height.
    The area of each rectangle represents the number of observations in the horizontal
    axis interval that it covers. Beware that the same dataset may produce very different
    plots when choosing different numbers of bins; some choices will better reflect
    the underlying distribution than others. If you leave out the `bins` argument,
    the `histogram()` routine will attempt to choose the “best” value, using a formula
    from statistical theory that is designed to best represent the data. This formula
    does not always work perfectly, so the careful scientist or statistician will
    always be aware of the nature of the data being plotted, and intervene manually
    if necessary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '***The Normal Distribution***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the `rand()` function described earlier in this chapter. Since it generates
    a floating-point number that is equally likely to be anywhere in the interval
    from 0 to 1, the mean value of the numbers it returns should be 0.5\. The number
    is just as likely to be greater than 0.5 as to be smaller than that midpoint.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'This means if you call `rand()` many times, and calculate the mean of the results,
    you should get something fairly close to 0.5: `mean(rand(1000))` should be approximately
    0.5\. I did it just now and got 0.49869515604579906\. Intuitively, you may expect
    if you use a number smaller than 1,000, the mean is more likely to be farther
    from 0.5, and that is correct.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: But even using 1,000 numbers, the mean will rarely be exactly 0.5\. Since (unless
    you reset the seed) you will get a different set of random numbers each time,
    the mean will be different each time, as well. The numbers themselves, as you
    know, are uniformly distributed in [0, 1). If you call `mean(rand(1000))` many
    times, how will the *means* be distributed?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: You know they can’t be distributed uniformly, because they are more likely to
    be near 0.5 than far from it. But what exactly is the distribution of the means?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a little program to find out. Even those who have studied statistics
    and know what to expect may find the numerical experiment in [Listing 10-4](ch10.xhtml#ch10lis4)
    interesting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-4: Exploring the distribution of the mean*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The program is a straightforward calculation of the `N` means of 1,000 random
    numbers. To see how these means are distributed, we turn to the `histogram()`
    plotting function introduced earlier in the chapter. The purpose of this function
    is exactly to display distributions. The `"Empirical"` label indicates that the
    histogram is the result of a numerical experiment. [Figure 10-5](ch10.xhtml#ch10fig5)
    shows the result.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Distribution of the mean of uniform random numbers*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the distribution of the means is not uniform. As we expect, it shows
    that means closer to 0.5 are more frequent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In fact, from a central result in probability theory, we can predict the precise
    mathematical form of this distribution. It should be
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/324math.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: where *x* is the random variable whose distribution we are describing, *σ* is
    the standard deviation, and *μ* is the mean.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: This is the equation for the famous *normal distribution*, also called the *Gaussian*.
    Does it describe the empirical distribution from the program? We don’t need to
    translate the equation into code to find out. This distribution is so crucial,
    it’s included in the second most important Julia package for statistical work,
    `Distributions`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Once you import this package into your namespace, the function `Normal`(μ, σ)
    creates a normal distribution with a mean of μ and a standard deviation of σ.
    You can interact with the distribution by sampling from it using the `rand()`
    function. For example, if you create a normal distribution with a mean of 10 and
    a standard deviation of 2 with `d = Normal(10, 2)`, you can draw 10 samples from
    it with `rand(d, 10)`. Calling `rand()` without supplying an explicit distribution,
    as we’ve been doing up to now, uses the uniform distribution by default.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: One way to see if the empirical distribution shown is predicted by the normal
    distribution is to take a healthy sample from the normal distribution and plot
    its histogram with the previous one. To make the plot easier to see, instead of
    trying to plot two `histogram()` plots on the same graph, we can plot the second
    one using a different type of histogram display by supplying the `:scatterhist`
    series type to the normal `plot()` command. Adding the four additional lines shown
    in [Listing 10-5](ch10.xhtml#ch10lis5) to the program in [Listing 10-4](ch10.xhtml#ch10lis4)
    makes the graphical comparison that we want.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-5: Sampling from the normal distribution*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-6](ch10.xhtml#ch10fig6) shows that the two distributions are close,
    as theory predicts.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: Comparing the empirical and theoretical distributions*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note that in order to compare two histograms directly, they must have the same
    bin width, or both be normalized. In these examples, I allow the routines to compute
    the bin width automatically, knowing that for similar distributions the widths
    would be the same.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The `Distributions` package provides many probability distributions in addition
    to the normal distribution. It also includes many functions for using these distributions,
    along with other statistical tools.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***Probability Density Functions***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of those tools is `pdf()`, which stands for *probability density function*.
    This function describes the distribution in the following sense: if you integrate
    the probability density function over a certain interval, the result is the probability
    that an observation lies within that interval. In other words, the probability
    that an observation lies between *a* and *b* is the area under the distribution
    curve between *a* and *b*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when referring to the graph of a distribution, we mean the graph of
    its probability density function. The integral over the entire distribution must
    exist and be equal to 1, because it is certain that any observation must have
    some value within the range of possible values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the `histogram()` plotting types have an optional `normalize` keyword
    argument that can be set to `true` to make the histogram plot indicate probabilities
    rather than raw counts—for example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Those three lines repeat the plots of the two histograms just plotted in [Figure
    10-6](ch10.xhtml#ch10fig6), but normalized. Now the areas of the histogram rectangles,
    shown in [Figure 10-7](ch10.xhtml#ch10fig7), are probabilities rather than raw
    counts. The new curve is a plot ➊ of the probability density function of the normal
    distribution with the same mean and standard deviation as the sample. It is a
    graph of the equation for *ϕ*, displayed after [Figure 10-5](ch10.xhtml#ch10fig5).
    [Figure 10-7](ch10.xhtml#ch10fig7) shows how accurately it predicts the results
    of the numerical experiment in [Listing 10-4](ch10.xhtml#ch10lis4).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig07.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: Adding the probability density function*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Because of the normal distribution’s importance, Julia provides another function,
    similar to `rand()`, that returns normally distributed random numbers rather than
    uniformly distributed ones. The `randn()` function is part of `Base`, so you don’t
    need an `import`. It returns single numbers or arrays, normally distributed with
    a mean of 0 and a standard deviation of 1.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s repeat the plot from [Listing 10-1](ch10.xhtml#ch10lis1) using `randn()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference is in using `randn()` instead of `rand()`. [Figure 10-8](ch10.xhtml#ch10fig8)
    shows the result. As in [Figure 10-1](ch10.xhtml#ch10fig1), each of the 10⁵ numbers
    is represented by a tiny dot, but now the dots are not uniformly distributed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig08.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Normally distributed random floats*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Instead, they are crowded around the value 0 on the vertical axis, with their
    density getting thinner the farther they are from 0, the mean of their distribution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Dealing with Data**'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, all the “data” in this chapter has been either made up or the result
    of collecting results from numerical pseudorandom processes. If you are using
    Julia for statistical analysis, the odds are good that you have some actual, real-life
    data to analyze.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore the most important methods in Julia for dealing
    with real data. We’ll look at a data type that comes in handy when manipulating
    data in the real world, how to read data from the most common types of datafiles,
    how to use dataframes to view and analyze this data, and how to take advantage
    of Julia’s statistical packages to understand and visualize numerical information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***Missing Values***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is an unusual data type I didn’t mention in [Chapter 8](ch08.xhtml) because
    I was saving it for this chapter. It’s a singleton type called `Missing`, and
    it is used to represent missing values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a sensor that is supposed to record the temperature inside
    a tank of water at regular intervals of time. Unfortunately, every now and then
    it fails to record a measurement. Those failures are recorded as 0s, but that
    number is far outside the range of possible measurements, so these failures can’t
    be mistaken for actual temperatures. At the end of the experiment you have two
    vectors, or perhaps two columns of a matrix, one for the times of the measurements
    and the other for the temperatures. When analyzing this data, you don’t want the
    false zero temperatures to be included in the analysis because that would distort
    your calculations. You want a better solution than simply deleting the failed
    readings because that would create a false record of what actually happened in
    the experiment, and, to keep the timing and temperature vectors the same length,
    perhaps for plotting the results, you will have to delete the corresponding entries
    from the timing vector, leading to a time sequence containing gaps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The `Missing` type provides one solution to this set of problems and others—for
    example, in data science, where the concept of missing values arises. It has some
    properties that may seem peculiar, illustrated in [Listing 10-6](ch10.xhtml#ch10lis6),
    which is a REPL session exploring arithmetic on the `Missing` type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-6: Arithmetic properties of* missing *values*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: We see from [Listing 10-6](ch10.xhtml#ch10lis6) that arithmetic on `missing`
    values leads to a `missing` result, even when dividing by 0.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Usually, `missing` values are not floating around by themselves, but are found
    as part of a collection of data. [Listing 10-7](ch10.xhtml#ch10lis7) is a little
    function that creates an array, replaces some of its values with `missing` values,
    and plots the result.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-7: Creating some missing data for plotting*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We need to declare the array to be able to accept `missing` values as well as
    floating-point numbers. If we omit this declaration, the compiler will complain
    when we try to assign `missing` to any location in the array because it will have
    defined it as `Vector{Float64}`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The plot in [Figure 10-9](ch10.xhtml#ch10fig9) shows that `Plots` knows how
    to handle missing data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-9: Plotting with missing data*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: By default, it leaves a gap where there are `missing` values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions for Handling Missing Values**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Julia provides several functions to do convenient things with `missing` values.
    To illustrate what these do, suppose we have an array, `a`, with some numbers
    and some `missing` elements:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you want the sum of the *numbers* in the array, you might try `sum(a)`,
    but if you refer to [Listing 10-6](ch10.xhtml#ch10lis6), you will see that, since
    adding a number to a `missing` value yields `missing`, the end result of the `sum()`
    operation will just be `missing`. Here, Julia’s `skipmissing()` function, which
    does as its name suggests, comes to the rescue:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `skipmissing()` function, which is built into `Base`, returns an iterator:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you run that loop, you’ll see this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you need to make a new array with the `missing` values omitted, use `collect(skipmissing(a))`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead, you want to make an array with a particular value substituted
    for the `missing` values in the original array, the function for that is `coalesce()`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we need to use the dot operator to apply `coalesce()` to all the
    elements of the vector, and how the type of the returned array is no longer a
    `Union` with `missing`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: If you have a program that analyzes data, and want to generalize it so it can
    handle data collections with `missing` elements, the `skipmissing()` function
    makes that task relatively straightforward. You may only have to replace occurrences
    of your data arrays with `skipmissing()` acting on those arrays.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'You may, however, prefer an approach that does not litter your code with a
    multitude of calls to `skipmissing()`. You can take advantage of Julia’s multiple
    dispatch to define your own methods for `sum()`, and for any other functions that
    operate on your data arrays, to handle `missing` elements however you like. If,
    whenever you `sum()` an array of data (and keeping in mind the warning about type
    piracy from [Chapter 8](ch08.xhtml)), you know that you will always want the `missing`
    values ignored and the numerical values added together, you can define a method
    this way:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That example works for integers, but it’s easily modified for other numerical
    types.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The function `ismissing()` returns `true` if its argument is `missing` and `false`
    otherwise. It’s often more expressive than comparing against the `Missing` type
    in data expressions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The `Missings` package provides a few more convenience functions for dealing
    with this data type. This package is not in the standard library, so you’ll have
    to `add` and `import` it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyone making use of `missing` values is likely to appreciate two functions
    from this package. As shown in [Listing 10-7](ch10.xhtml#ch10lis7), it’s a little
    cumbersome to define a vector that can hold both the needed numerical type and
    optional values—and, more important, you may have a numerical array that you need
    to convert to a type that will allow you to add `missing` values to it. The following
    little REPL session shows how to use the `allowmissing()` function from the `Missings`
    package, which solves both of these problems:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can convert a `Vector{Union{Missing, Float64}}` type back into a pure floating-point
    numerical type using `Missings.disallowmissing()`, but first you must eliminate
    any `missing` values from it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**Logic with Missing Values**'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before leaving the topic of Julia’s `Missing` data type, let’s look at how it
    behaves in the context of logic expressions. We typically think of operations
    on logical values as following a two-valued (Boolean) logic, where the only possible
    values are `true` and `false`, a calculus that is reviewed in “Logic” on [page
    31](ch02.xhtml#ch02lev1sec3). The `missing` value expands the world of Boolean
    logic to encompass a third truth state, which is neither `true` nor `false`, but
    indeterminate. In Julia, the `missing` type, along with bitwise AND (`&`), bitwise
    OR (`|`), bitwise exclusive OR (`xor`), equality (`==`), and negation (`!`), form
    a system of three-valued logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The results of a logical expression thus can be `true`, `false`, or `missing`.
    The following list shows how the system works, and after some thought, the entries
    should make intuitive sense. For example, the result of `true | missing` is `true`
    because the result will be `true` *no matter the truth value of the second operand*.
    And the result of `true & missing` must be `missing`, because it will *depend*
    on the truth value of the second operand, which is undetermined.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: true | missing   `true`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: true & missing   `true`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: false | missing   `missing`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: false & missing   `false`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: xor(true, missing)   `missing`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: xor(false, missing)   `missing`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '!missing   `missing`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: missing == missing   `missing`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: missing === missing   `true`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Since the truth value of `missing == missing` depends on the values of the missing
    items, it is itself `missing`. However, since `missing` is a singleton type, all
    instances of it are the same object; hence `missing === missing` must be `true`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '***CSV Files***'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Data that’s of moderate size often comes in the form of a comma-separated value
    (CSV) file. These are text files with items delimited by commas, and optionally
    with descriptive headers. They have the considerable advantages of being human
    readable and amenable to processing with all of the Linux command line tools.
    But they have the disadvantages of taking up more space than necessary, being
    less efficient than binary representations, and possibly not faithfully representing
    the original values after conversion into text. For those reasons, this format
    is probably not the best choice for storing, say, the output of a physics simulation.
    However, CSV is perhaps the most common format for distributing what are commonly
    called “statistics,” such as demographic data or the pandemic data that we’ll
    explore later.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to write your own programs for reading CSV files, parsing
    them, and turning them into some Julia data structure. If you’ve come this far
    in the book, you will certainly be able to do so. However, it would be wise to
    resist the temptation, except as an exercise.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'For real work, it’s a better idea to use the `CSV` package, which we’ll need
    to `add` in the package manager. This package can handle any delimiter, in addition
    to commas: the popular tab-separated file format as well as any custom format
    you may come across. It’s even able, in many cases, to figure out by itself what
    delimiter the file is using. This delimiter need not be limited to a single character;
    it can be a string as well. The `CSV` package can deal with comments mixed in
    with the data, column headers, and anything else you’re likely to encounter. It
    can read files from disk or, given a URL, can fetch them over the internet. It
    can handle dates in any format and transform labels into more code-friendly forms.
    Perhaps most importantly, it transforms the textual information into a Julia data
    type that can be further transformed into one of several different table-like
    data formats designed to be easily manipulated for statistical work.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '***Dataframes***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most important of these table-like data structures is `dataframe`, provided
    by the `DataFrames` package, which also needs to be `add`ed. Indeed, as the data
    structure returned by CSV after it reads a file is not the most convenient for
    exploration, the usual strategy is to immediately transform it into a `dataframe`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: A `dataframe` is a table of values, like a matrix, but with extra functionality
    designed for data exploration. Along with the `dataframe` data type, the `DataFrames`
    package exports several functions for manipulating it. In addition, many Julia
    functions with which you are already familiar have methods that extend their functionality
    to the `dataframe`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: It is most useful to think of a `dataframe` as a set of columns stuck together.
    Each column has a unique name. A column can be referred to with its integer index,
    with its name as a string, or with its name as a symbol. When you are examining,
    plotting, or manipulating data, you are doing these things to `dataframe` columns.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '*We treat dataframes as sets of columns for data analysis and visualization.
    However, most Julia functions that operate on collections treat dataframes as
    collections of rows. See “Further Reading” on [page 359](ch10.xhtml#fur10) for
    an illuminating article on this subject.*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example using real-life data that comes in a typically messy
    form. Our journey through this data will make the earlier discussion of dataframes
    concrete and introduce the important functions for wrangling data from sources
    in the wild.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some data from the COVID-19 Data Repository maintained by the
    Center for Systems Science and Engineering (CSSE) at Johns Hopkins University
    ([*https://github.com/CSSEGISandData/COVID-19*](https://github.com/CSSEGISandData/COVID-19)).
    This data comes in the form of CSV files, using an actual comma as a delimiter.
    The first line contains headings to describe each data column, but the format
    of those headings will make subsequent manipulation in Julia inconvenient. The
    first problem is that some of the headers are names of countries or territories
    that contain spaces. The second is that some of the headers are dates, but these
    are in a format that we need to take into account so that they are parsed correctly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '*The datafile used in the examples here is available in the online resource
    area under the name* time_series_covid19_confirmed_global.csv*. The CSSE data
    grows in size over time, so some of the plots shown in this section may become
    unwieldy with future versions of the file from Johns Hopkins.*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the file reading function in the `CSV` package is equipped to deal
    with both of those common issues. [Listing 10-8](ch10.xhtml#ch10lis8) shows the
    instructions for reading the CSV file and converting it immediately into a `dataframe`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-8: Reading a CSV file*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The `normalizenames` option replaces spaces and other troublesome characters
    in column names with underscores and performs any other transformations needed
    to turn header text into legal Julia identifiers. The `dateformat` keyword argument
    should be self-explanatory.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument to `CSV.File()` is the name of the file on disk, which I
    previously downloaded and saved. Another option is to pass the URL of the file
    here. `CSV.File()` will recognize this and automatically download the data over
    the internet. The date format is determined by inspecting the file, whose first
    line, which contains the column headers, looks like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are 432 columns. The end of the second command in [Listing 10-8](ch10.xhtml#ch10lis8)
    converts the `CSV.File()` object into a `DataFrame` object, which is stored in
    the variable `covdat`. If this is executed in a REPL, Julia will print out a truncated
    representation of the dataframe. [Figure 10-10](ch10.xhtml#ch10fig10) shows what
    that looks like. In this particular case, I’ve narrowed the REPL window so it
    fits better on the page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig10.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-10: Representation of a dataframe in the REPL*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The display indicates how much information has been omitted, the names of the
    visible columns, and the type of data they contain. A question mark after the
    data type means some values may be `missing`. Here is a typical use for the `missing`
    data type: most of the countries in the files do not have a province listed, but
    a few do. Missing data is represented in the original CSV file by a number that
    is . . . missing.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The fancy display of dataframes in the REPL is accomplished by `show()`, usually
    implicitly. A `print()` of a dataframe spits out the whole thing, without the
    nice formatting or type information, and is usually not what you want. In addition,
    `show()` can create HTML and LaTeX versions, and control other aspects of the
    dataframe display. Consult the REPL help to learn the details.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**The @df Macro**'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For the rest of the chapter, we’re going to make extensive use of a macro found
    in the `StatsPlots` package called `@df`. It’s part of `StatsPlots` because it’s
    especially effective at making commands for plotting from dataframes more concise,
    but its use is not limited to `plot()` commands. From this point on, the following
    command is assumed:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `@df` macro does what macros do best: it rewrites code so that our programs
    are easier to write and read. This macro has one job: it replaces symbols in an
    expression with the columns of the dataframe that appears as its first argument.
    This simple expression rewriting is enough to make this macro popular because
    it frees the programmer from having to repeat the name of the dataframe multiple
    times in an expression. Consider the following example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this expression, the symbol `:_1_1_21` is converted to `covdat._1_1_21` each
    time it appears. The argument of the macro following the name of the dataframe
    must be a block or a function call, so the above would fail without wrapping the
    result in the `print()` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Since `Symbols` are converted into dataframe columns when using the `@df` macro,
    we need some syntax to indicate when a `Symbol` should be left alone—for example,
    if there is a conflict between a column name and a symbol used for another purpose.
    The macro provides the “`^()`” wrapper to handle these conflicts. If, for example,
    a column called “topleft” happens to be in your dataframe, you’ll need to use
    the syntax `legend=^(:topleft)` in the plotting command to put the legend in the
    Northwest.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Filtering Dataframes**'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A dataframe can be indexed and filtered using the same methods that we apply
    to matrices. However, dataframes come with some extra indexing methods that let
    us take advantage of their named columns.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: I include in this chapter only the indexing and filtering methods that I think
    are most likely to be useful in the majority of cases. There are, in addition
    to everything covered here, several packages that supply macros and functions
    providing yet more ways to select and transform the information in a dataframe.
    Their intention is to allow a more streamlined syntax for certain common tasks,
    and these packages can be convenient. However, most of them are in somewhat of
    a state of flux. As in most sections in this book, I try to confine myself to
    methods that have solidified—that you can learn once and use forever.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Items in a dataframe can be extracted using the familiar forms of integer indexing.
    Here are a few examples:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice how the data type of the result depends on how we index the dataframe.
    If we ask for one element ➊, we get back a single value, in this case a string.
    If we ask for a range of rows in a single column ➋, we get a `Vector`. Finally,
    if we extract data horizontally, by indexing a single row and a range of columns
    ➌, we get a data type that we haven’t seen before: a `DataFrameRow`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask Julia for a range of rows and a range of columns:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We get back a smaller dataframe. What else could it be?
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have to count indices to refer to columns, but can use their names,
    as in [Listing 10-9](ch10.xhtml#ch10lis9).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 10-9: Selecting columns by name*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `Symbol`s to index the dataframe’s columns. For each column title, a
    `Symbol` with the same name is created for efficient indexing. We could just as
    well have used the string versions of the column names in [Listing 10-9](ch10.xhtml#ch10lis9),
    but using `Symbol`s is more efficient. This is one reason for using `normalizenames`
    when reading the data: headers containing spaces would not be valid `Symbol` names,
    and we would be forced to use the string versions. [Listing 10-9](ch10.xhtml#ch10lis9)
    shows the last three countries, their latitude and longitude, and the number of
    COVID cases on January 22, 2021.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The headings of the columns for latitude and longitude have data types printed
    with question marks. This means somewhere in this table is a country or a province
    with one or both of these values missing. To see those countries or provinces,
    we need to find the *row* in the table where `:Lat` or `:Long` has the value `missing`.
    To select rows from a dataframe where one or more columns satisfy some condition,
    we can use the `filter()` function (described in “The filter() Operator” on [page
    163](ch06.xhtml#ch06sec1sec4). The `DataFrame` package extends the `filter()`
    function to operate on dataframes by filtering rows and returning a new dataframe.
    The following line of code filters our COVID dataframe, looking for the rows with
    missing latitude or longitude:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The result is a dataframe with a single row, with the curious notation `Repatriated
    Travellers` in place of the province.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Rather than use the `filter()` function, you can get the same result with bitmask
    indexing or any other technique that works with normal arrays.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in the example just shown how we specified the columns for the filter
    using the column names as bare words. This is yet another form of indexing, which
    is convenient in filter expressions. We can also use that syntax to select columns
    from the dataframe, turning them into `Vector`s:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since selecting columns provides us with `Vector`s, we can use this form of
    indexing for plotting:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Nothing mysterious is going on here. We simply extracted two vectors from the
    dataframe and plotted them in the usual way, resulting in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig11.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: Cases vs. country*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'This plot is not ideal, however. It shows us something about the distribution
    of the number of cases on the date in question, but the horizontal axis is essentially
    useless because there is no room for hundreds of country labels. Perhaps, instead
    of trying to plot all the data at once, it would be more useful to plot some meaningful
    subset. Let’s limit our visualization to the countries with a lot of cases, by
    using the filtering mechanism we just learned. Also, let’s switch to a bar chart,
    which is the more appropriate visualization for this type of data:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we have something useful: a chart of the countries with more than two million
    cases on New Year’s Day 2021, shown in [Figure 10-12](ch10.xhtml#ch10fig12).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig12.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-12: Countries with over two million cases*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In the previous indexing commands, we used integer indexing to select columns,
    which worked well, but required us to count to the first column of interest. Also,
    it was only convenient because we knew that the columns we wanted extended to
    the end, which simplified the indexing expression.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative that lets us use column names directly is the `Between()` function.
    The equivalent expression for selecting the date columns is:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This can be easily modified to choose any closed interval of columns.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is the `Not()` function. Here is a selection that returns the
    same `DataFrameRow` as the previous one:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The columns that remain after the listed ones are excluded are just the ones
    we want: the date columns.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also select columns using regular expressions applied to the names of
    their titles. Here is another way to make the same selection, returning the same
    `DataFrameRow`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Sometimes this is the most convenient way to select data. For example, if we
    want to extract only the columns for February 2021 for Afghanistan, we could just
    say `covdat[1, r"_2_\d*_21"]`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to make a `DataFrameRow` with all the date columns *and*,
    say, the `Country_Region` column (but none of the other ones)? None of the indexing
    techniques we’ve seen so far make this convenient, although you might be able
    to twist them to get the desired result. There is no need for contortions, however,
    because we can use the `Cols()` function. The following lines show four different
    ways to use this function to get a `DataFrameRow` similar to the one we created
    using multiple techniques earlier, but with the addition of the `Country_Region`
    column:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we can see, the `Cols()` function lets you pick out individual columns or
    ranges of columns using numerical indices, regular expressions, or column names
    either as symbols or as strings. It can also reorder columns. The following rearranges
    the `covdat` dataframe to place the latitude and longitude columns at the end:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this, we have a large enough toolbox to do most of the indexing, selecting,
    and rearranging of dataframes that we’re likely to encounter in our work.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutating Dataframes**'
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The indexing expressions `covdat[:, :Country_Region]` and `covdat.Country_Region`
    both seem to return a `Vector` with contents identical to the `Country_Region`
    column of the dataframe called `covdat`. However, they are not identical:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This tells us that while the two left- and right-hand sides contain the same
    values, they are not the same object. The syntax `dataframe[:, :col]` makes a
    *copy* of the column and returns it as a `Vector`. But `covdat.Country_Region`
    is a *reference* to the column. If you have a choice, avoid making unnecessary
    copies, as it is slower and consumes memory. Also, if you want to mutate a column
    by assigning to individual elements, you must use a reference rather than a copy,
    as shown in [Listing 10-10](ch10.xhtml#ch10lis10).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 10-10: Mutating a dataframe*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'The direct dot syntax used here only works when using a literal column name
    after the dot, not with a variable holding a column name. If you’re using variables
    to hold the names of columns, you must use square brackets. However, that doesn’t
    mean you are obligated to make copies of columns. Another syntax allows you to
    use square brackets to reference a column using a variable, and without making
    a copy: `dataframe[!`, var`]` means the same thing as `dataframe.columnname` if
    var is set to `"columnname"`.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: A command such as `covdat[:, c][1] = "Disneyworld"` will have no effect on the
    original dataframe. However, the assignment in [Listing 10-10](ch10.xhtml#ch10lis10)
    can also be written as
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: which will mutate the dataframe. The meaning of the exclamation point is suggested
    by its use in mutating functions, introduced in “Functions That Mutate Their Arguments”
    on [page 56](ch02.xhtml#ch02lev1sec17).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '**Transposing Dataframes**'
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Dataframes make it convenient to plot or operate on columns of data. But suppose,
    using the data in the `covdat` dataframe, that you wanted to plot the time histories
    of case numbers for various countries. For each country, its time series is the
    part of the *row* for that country starting in the fifth column. We know, from
    the indexing section earlier, that we can extract rows from the dataframe, and
    that doing so gets us not a `Vector`, but a `DataFrameRow`. This means that, for
    plotting, we need to convert the result into a `Vector`. Here is one way to put
    all of this together to plot the time histories of COVID cases in the US:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'I snuck in a function you haven’t seen before: `names()` returns the names
    of the columns in a dataframe in the form of a `Vector` of strings, so it is what
    we need to make meaningful x-tick labels.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The listing employs the `@chain` macro introduced in “The @chain Macro” on [page
    174](ch06.xhtml#ch06sec1sec8). The pipeline syntax is popular when wrangling data
    from dataframes, as this activity inherently involves a series of transformations.
    The code snippet will produce the desired timeline plot, shown in [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig13.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-13: US cases vs. date*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Now, to compare different countries, I would merely need to repeat the plotting
    pipeline using `plot!()` to add a new curve, substituting the country name of
    interest.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking that there is a lot to type just to plot a row of data,
    and that this could be a bit of a drag for interactive work. Again, all this typing
    is required because the intention behind dataframes is to deal with them as a
    set of columns, so plotting rows is going against the grain. It would be smoother
    to go with the dataframe flow and somehow flip the dataframe around first, so
    the rows become columns. This would make the code easier to write and read. Selecting
    the data to plot would be more direct, and it would come in the form of a `Vector`
    that can be plotted immediately, eliminating the need for conversion.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: We want to end up with a series of columns for different countries, with each
    column containing the series of case numbers for the country. If we have that
    kind of dataframe, we can plot any country’s case number history directly. We
    would also like a column containing the date labels to use in plots. We can omit
    the other columns. We don’t plan to use the latitude and longitude information
    in these plots or in our subsequent analysis, but they will remain in the original
    `covdat` dataframe if we need them. We are just making a new dataframe as a tool
    to ease our exploration of the data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, however, we need to do something about the fact that some
    of the country names appear more than once, because some of them are listed along
    with several entries for `Province_State`. If these country names are to become
    column titles, they must be unique. A little later on we’ll learn how to incorporate
    this data, but for now, we can simply eliminate the rows with provinces, keeping
    only the main country entries:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the troublesome rows deleted, we can now safely exchange rows for columns.
    It probably sounds like we need some kind of transpose of the dataframe; however,
    the `transpose()` function, that we know and love from our work with matrices,
    will not work here. Fortunately, the `DataFrame` package comes with a function
    designed exactly for this purpose. We learned about the `permutedims()` function
    in “Adjoints and Transposes” on [page 144](ch05.xhtml#ch05lev1sec17), as a kind
    of generalized transpose operation. The `DataFrames` package extends this function
    to handle `DataFrame`s; here’s how to use it:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the first line, we get rid of the columns that we won’t need. The transpose
    happens in the second line, where the first argument to `permutedims()` is the
    dataframe to be transposed, the second argument selects the column from the original
    dataframe whose contents are to be used as column names for the transposed dataframe,
    and the third argument is the name to give the new column, whose contents will
    be composed of the column names of the original dataframe. Since we eliminated
    the `Province_State` column, the first column of `covmc` is now `Country_Region`,
    so the names in the column of countries are used as the new column titles. We
    can specify the column to pivot around using any kind of selector, so we could
    have written the following as well:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our new dataframe, `cdcn`, appears as shown in [Figure 10-14](ch10.xhtml#ch10fig14).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig14.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-14: The* cdcn *dataframe in the REPL*'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one problem with our freshly transposed dataframe: some of the column
    titles now have spaces in their names. You can’t see them in the small piece of
    the dataframe shown in [Figure 10-14](ch10.xhtml#ch10fig14), but we know that
    they’re there:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It’s not a serious problem, but, as you now know, legal symbol names are more
    convenient and lead to neater and more efficient code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The function `rename!()` transforms the column names of a dataframe in place
    (hence the mutation warning sign). It has several methods; the method that we
    shall use takes a function as its first argument and the dataframe to be altered
    as its second argument. The supplied function is applied to each column separately.
    The command in [Listing 10-11](ch10.xhtml#ch10lis11) replaces spaces with underlines
    in the column names of `cdcn`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*Listing 10-11: Renaming columns of a dataframe*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Did it work? Let’s take a peek at a relevant bit of the dataframe:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can plot time-dependent case numbers for selected countries with ease:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `@df` macro from `StatsPlots` was useful there, as the command refers to
    several columns using `Symbol`s; without it, we would be obligated to mention
    the name of the dataframe each time. This `plot()` command produces the graph
    in [Figure 10-15](ch10.xhtml#ch10fig15).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig15.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Timeline of cases in three countries*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In a `plot()` command inside a `@df` macro call, the `cols()` function (note
    the lowercase) can be used to select a numerical range of columns with `cols(a:b)`,
    all the columns with `cols()`, or a column whose `Symbol` name is stored in a
    variable, with `c = :thecol` and `cols(c)`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that* Cols*, with an uppercase C, is for column selection within
    square brackets and is part of* DataFrames.jl*, whereas* cols*, using lowercase,
    is a utility function for use in the* @df *macro, provided by* StatsPlots.jl.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the machinery that we now have under our belts, we can do more than
    plot random selections of countries. One thing that might be interesting is to
    plot only those countries whose caseloads rise above a certain level on any day
    included in the dataset. Here is one way to do that, using the `@df` macro and
    `cols()` function from `StatsPlots`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The strategy is to collect the relevant columns as an array of `Symbol`s, so
    that we can select them in the `plot()` statements using `cols()`. [Figure 10-16](ch10.xhtml#ch10fig16)
    shows the result.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig16.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: Countries with large caseloads*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`StatsPlots` has turned the symbols identifying the columns into strings for
    the plot, providing a useful legend.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**Summarizing Dataframes**'
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another useful device that `DataFrames` provides is the `combine` function.
    This allows us to map a function onto a set of columns to create a new dataframe
    that is a summary of an existing dataframe. For example, suppose we want a table
    that contains the maximum number of cases seen for each country. The `combine()`
    function makes this simple:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For each column in the range of columns defined in the second argument, `combine()`
    applies the `maximum()` function to its contents.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The `combine()` function creates new column names by appending the name of the
    function. If you would like to preserve the original name, pass in `renamecols
    = false`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'This data is a good candidate for another bar chart, but it would be more convenient
    to have it transposed, with a column of countries and a column of maximums. We
    know how to do that now, but something is missing: we need to add a column to
    hold the new column names. [Listing 10-12](ch10.xhtml#ch10lis12) combines the
    methods we’ve learned to first make a permuted dataframe called `cdmp` and then,
    in the last line, copy only the rows with the largest caseloads into another dataframe,
    `cdmpc`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 10-12: Plotting maximum caseloads*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the code in [Listing 10-12](ch10.xhtml#ch10lis12), `cdmpc`
    looks like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You see that there are only 14 countries that experienced a caseload of more
    than two million during the time period covered by this dataset. Now we can make
    a bar chart with this simple command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This creates the graph in [Figure 10-17](ch10.xhtml#ch10fig17).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig17.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-17: The highest maximum caseloads*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'The need for summary statistics of the data in a dataframe is so common that
    a function is available that does the foregoing work for us, but it’s good to
    know how to do it “manually,” in case you need something it doesn’t provide. That
    function is called `describe()`, and here’s how it works:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That’s certainly easier! By default, `describe()` returns a `DataFrame` with
    the means and medians as well, but those are not meaningful for these timelines,
    so we limit the statistics calculated by passing a symbol, `:max`, for the one
    we want. The function can calculate the other summary statistics as well, such
    as standard deviation, and automatically skips `missing` values. It can even report
    the number of `missing` values in each column, if you so desire.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '**Grouping Dataframes**'
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier we threw away some of the data, namely the additional provinces for
    the several countries for which such entries existed. As promised, we’ll now find
    a way to include that information.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose we are not interested in looking at the data for individual provinces,
    but instead would like to add up the numbers for all the provinces belonging to
    each country and just look at the total case numbers. This makes a bit more sense
    than just deleting that data. The most convenient way to do this kind of thing
    involves the concept of the *grouped dataframe* and an associated new data type,
    the `GroupedDataFrame`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: A `GroupedDataFrame` is something like a vector of dataframes. Each dataframe
    in the vector is created from a source dataframe by collating the rows that have
    the same value in a chosen column. In our case, we’ll group by `Country_Region`.
    Most of the resulting members of the `GroupedDataFrame` will have a single row
    because most countries appear only once. But those countries that appear multiple
    times, because they have `Province_State` values, will give rise to members of
    the `GroupedDataFrame` with more than one row, with one for each `Province_State`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: One small wrinkle is that the members of a `GroupedDataFrame` are not actually
    dataframes, but have a new data type called `SubDataFrame`; however, the distinction
    is usually not important.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will group the `covdat` dataframe by country:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now `cvgp` is a `GroupedDataFrame`. Let’s examine it in the REPL:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The grouped dataframe has 192 members ➊, which tells us how may distinct countries
    are included in the data (remembering that one of them is `Repatriated Travellers`).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Subtracting that from the total number of rows ➋, we learn that 82 countries
    have provinces listed.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Looking at individual members of `cvgp` ➌ ➍ confirms that these are dataframes
    devoted to individual countries. The next step is to add up the case numbers across
    all provinces for each date, so each country’s numbers will include all of its
    provinces. That’s what the `combine()` function is for. When I introduced `combine()`,
    we used it on a dataframe, but when applied to a grouped dataframe, it does exactly
    what we want, applying the specified function along the selected columns for each
    group member individually and then returning a normal `DataFrame` as the result.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need an array holding the columns to sum, which are the date columns,
    and then we can `combine()` them. We’ll store the result in a new variable:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now `cvsm` has the same structure as our original `covdat`, but only 192 rows,
    one for each country. As before, it will be convenient to have on hand the transpose
    of this dataframe:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: And, as before, it’s better to normalize (remove the spaces from) the column
    names. After repeating the procedure from [Listing 10-11](ch10.xhtml#ch10lis11)
    on `cvsp`, we have a dataframe convenient for plotting.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s easy to compare the timelines for France, both with and without its
    territories:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[Figure 10-18](ch10.xhtml#ch10fig18) shows the results.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig18.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-18: Time history of the caseload in France*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the inclusion of the `Province_State` columns makes a barely
    visible difference in the plot.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '**Multivariate Data**'
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous examples all dealt with timelines: a single quantity, in this
    case numbers of infections, as a function of date, for various countries. Another
    form of data involves the frequencies of a number of events in, say, different
    places, or compared among different demographic groups. [Figure 10-4](ch10.xhtml#ch10fig4)
    showed a simple example of this form of data, where the events are observations
    of height and the demographic groups are men and women.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: When you have data on more than one variable, you can use statistical methods
    to look for associations among them, always remembering that “correlation does
    not imply causation.” But an association can suggest that it might be worthwhile
    to look further, and the *lack* of correlation might be useful in ruling out hypotheses.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the (made up) example of men’s and women’s heights, if we also had, from
    the same subjects, data about income level, or age, we could look for associations.
    Are richer people taller? When does the increase of height with age level off?
    Julia’s `DataFrame`s, combined with its convenient statistical functions and the
    visualizations provided by `StatsPlots`, make this kind of data exploration a
    relatively easy and pleasant task.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'I compiled our second datafile from data maintained by the US Census Bureau
    ([*https://www.census.gov*](https://www.census.gov)). It is available in the supplementary
    website at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org),
    in the file named *census.dat*. The file is in tabseparated value format, with
    one line of column headers and comment lines that each begin with a hash mark
    (#). The data consists of absolute numbers of reported crimes in several categories
    in 2011 for each county in the US, plus a column for the total population of the
    county and one for the percentage of minors who did not complete high school.
    The comment lines give the totals for each state and for the entire country. Here
    are the first nine lines of the 3,143-line file:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Clearly, the first thing we need to do is use the `CSV` package to read this
    and store it in a dataframe. The `CSV.File` function will detect that tabs are
    used as delimiters, and also that the first line is a header, but we should tell
    it about the comments:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The second line eliminates any rows (there were three) with a zero population.
    As we plan to divide the absolute numbers by population to convert them into rates,
    we need to delete those rows. Here is the conversion:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'At this point, our dataframe looks like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'How is a particular crime category, say, larceny, distributed among the counties?
    Are they all the same? How likely is it for a county to have an unusually high
    larceny rate? We can answer those kinds of questions with a histogram, which we
    can produce with this command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In many commands that pull data from the dataframe, the `@df` macro will save
    some typing and make the code easier to read. The histogram, shown in [Figure
    10-19](ch10.xhtml#ch10fig19), shows that about 400 counties had no larceny at
    all during the report year, and most had rates (total number divided by population)
    below 2 percent. Above that rate, the distribution drops off steadily and fairly
    rapidly.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig19.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-19: Histogram of larcenies*'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'With our dataframe set up, exploring this data in the REPL is simple (the following
    assumes that `Statistics` has already been imported):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The average larceny rate is about 1.4 percent. How is this crime correlated
    with other crimes? The correlation with murder is weak, meaning that knowledge
    of a high larceny rate in a particular county tells you nothing about its murder
    rate. However, the correlation with vehicle theft is significant: a county with
    a high larceny rate is a place where you are more likely to get your car stolen.
    That may not be surprising, but before we take it seriously, we should remember
    that the correlation coefficients calculated by the `cor()` function of the `Statistics`
    package are the Pearson coefficients, which assume a linear relationship between
    the two variables under consideration. Does such a linear relationship hold between
    these two crime categories? The way to answer this kind of question is with a
    scatterplot:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It does look from [Figure 10-20](ch10.xhtml#ch10fig20) as if there is at least
    a roughly linear relationship between the two rates, so the correlation coefficient
    is meaningful.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig20.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-20: Larceny–motor vehicle theft scatterplot*'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Using a small marker size combined with a low opacity is effective when making
    scatterplots with many points. The idea is that there are likely to be regions
    with a lot of overlap. Using small, transparent points allows the point density
    at any location to appear as a buildup of image density there. Using opaque or
    larger points would create a plot where we can’t distinguish between moderate
    and high densities once the markers begin to obscure each other.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea is made more systematic with a plot recipe from `StatsPlots` called
    `histogram2d()`. As the name suggests, it takes two variables and creates a two-dimensional
    histogram. The result is similar to a scatterplot, but with the plane divided
    into cells and the cells colored according to the number of points they contain.
    Here is how it works:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As with ordinary histograms, we can adjust the number of bins if the automatic
    calculation is not optimal, but in this case, the algorithm does a good job. The
    result shown in [Figure 10-21](ch10.xhtml#ch10fig21) conveys information similar
    to the scatterplot in [Figure 10-20](ch10.xhtml#ch10fig20), but now we can read
    off the number of cases from the color map.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig21.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-21: Two-dimensional histogram of two categories of crime*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe()` function that we met earlier is useful for getting an overview
    of this type of data. The result can be made more concise by eliminating the uninteresting
    bits:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The last column in the description table informs us that there are no missing
    values. The reason for the composite data types is that the summary dataframe
    contained a row of county names that we eliminated with the indexing expression,
    so these columns actually contain a mix of numbers and strings.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine the two-dimensional histogram of [Figure 10-21](ch10.xhtml#ch10fig21)
    with normal one-dimensional histograms of each variable using the `marginalhist()`
    recipe from `StatsPlots`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The result, shown in [Figure 10-22](ch10.xhtml#ch10fig22), is a nice visualization
    of two distributions simultaneously.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig22.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-22: Illustrating the marginal histogram plot recipe*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StatsPlots` package has another trick up its sleeve. It can combine some
    of the plots we’ve already seen into a composite visualization that makes it easy
    to pick out associations and patterns among a group of variables almost at a glance.
    This is achieved with the `corrplot()` recipe, as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We’ve chosen three variables to look at; it’s possible to look at everything
    at once, or any other subset with more than two categories. The need to include
    the `fillcolor` argument is a bug that may be fixed by the time you are reading
    this, so you may want to try omitting it. It controls the palette used in the
    two-dimensional histograms, and, as you saw earlier, it’s not needed in regular
    `histogram2d` plots to get the default coloring.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-23](ch10.xhtml#ch10fig23) shows the result.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch10fig23.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-23: A correlation plot*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe produces a matrix of plots comparing every possible combination
    of pairs of variables from the vector of arrays provided in the first argument.
    Along the diagonal of this plot matrix (where the two variables are identical)
    we have conventional, one-dimensional histograms; above the diagonal, we see all
    three possible two-dimensional histograms; and below the diagonal, we have all
    the scatterplots, using transparent points. As a bonus, the scatterplots also
    feature regression (best fit) lines drawn through the points, and the marker color
    reflects the type of correlation: positive correlations are blue, lack of correlation
    is indicated by yellow, and negative correlations are red. This is a powerful
    visualization that carries a rich payload of information. A quick look tells us
    that failure to complete secondary school is unrelated to rates of vehicle theft
    or robbery, but those two types of crime are correlated with each other.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Packages**'
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section briefly describes a few more tools that readers interested in statistics
    will want to be aware of. See “Further Reading” on [page 359](ch10.xhtml#fur10)
    for some additional resources you may find useful.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '***JuliaDB for Out of Core Datasets***'
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dataframes are powerful data types, but they’re intended for data structures
    that fit in RAM. For data that is too large to fit in memory, a better choice
    is `JuliaDB`, which is designed to work efficiently with such “out of core” datasets.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '***RCall for Interacting with R***'
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The R programming language is a long-established language and system for statistical
    analysis. Like Julia, R is free software and has a large population of devoted
    users. However, it is not a good general-purpose programming language, and it
    can be quite slow for certain types of calculations. If you are starting a new
    project, and do not happen to have a personal library of R code that you have
    developed over the years, I recommend using Julia for your statistics needs. It
    already has a large and capable ecosystem of statistical packages, and more packages
    are being added every day. Julia won’t let you down if your analysis program turns
    into something that needs to run quickly on big data. Its ability to run on GPUs
    and other multiprocessor hardware, and the efficiency of its compiled code, means
    that you won’t need to rewrite your programs in order for them to scale.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: However, if you have already invested time and effort into writing R routines
    that you want to keep using, you need not rewrite them. You can use them from,
    and in combination with, Julia. The `RCall` package has several macros for interoperating
    with R routines and data structures, as well as a special REPL mode for interacting
    directly with R within the Julia session. In fact, as soon as you type `using
    RCall`, an R process starts up in the background. It locates your R installation
    and can even install R for you.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '***P-hacking***'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For calculating p-values and performing other analyses to contribute to the
    replication crisis in science, the `HypothesisTests` package at [*https://github.com/JuliaStats/HypothesisTests.jl*](https://github.com/JuliaStats/HypothesisTests.jl)
    is invaluable.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The concepts and techniques of statistics cut across all scientific disciplines.
    Julia, with its statistics packages, puts a lot of exploratory and analytical
    power at our fingertips. Good integration with the `Plots` package makes visualization
    fast and easy as well. While systems such as R, a standard for statistical analysis
    for decades, offer some functions not yet built into Julia’s packages, the latter
    are developing quickly. Julia has some advantages today over the venerable workhorses:
    the ease of developing in the language makes it easier to add missing capabilities,
    and Julia’s efficiency frees you from the need to rewrite your code in a faster
    language when faced with big data or computationally intensive analyses.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: We’ll revisit some of the concepts introduced in this chapter in the next chapter,
    with simulated evolution, and in [Chapter 13](ch13.xhtml), where we explore the
    techniques of probabilistic programming to make inferences about models.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: For details on the lava lamp entropy project, see [*https://blog.cloudflare.com/randomness-101-lavarand-in-production/*](https://blog.cloudflare.com/randomness-101-lavarand-in-production/).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pandemic simulation in this chapter implements a simplified model along
    the lines of the widely used COVID-19 model developed at [*https://github.com/mrc-ide/covid-sim*](https://github.com/mrc-ide/covid-sim).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The formula for the combination of events used in the pandemic simulation is
    derived in Chapter IV of William Feller’s standard work on probability theory,
    *An Introduction to Probability Theory and Its Applications*, Volume 1 (Wiley
    1968).
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative random number generator designed for long-term stability is available
    at [*https://github.com/JuliaRandom/StableRNGs.jl*](https://github.com/JuliaRandom/StableRNGs.jl).
    You may want to use it if you would like your programs to use the same pseudorandom
    sequences across future versions of Julia and its packages.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RCall` package resides at [*https://github.com/JuliaInterop/RCall.jl*](https://github.com/JuliaInterop/RCall.jl).
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A frequently updated list of Julia statistics and machine learning packages,
    with brief descriptions, is available at [*https://github.com/JuliaStats*](https://github.com/JuliaStats).
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See this 20-minute tutorial video by Juan Klopper for an introduction to statistics
    in Julia: [*https://www.youtube.com/watch?v=xbsr46Dw8hg*](https://www.youtube.com/watch?v=xbsr46Dw8hg).'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A textbook by Yoni Nazarathy and Hayden Klok about doing statistics, data science,
    and machine learning with Julia is available at [*https://statisticswithjulia.org*](https://statisticswithjulia.org).
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The headquarters of the `JuliaDB` package is [*https://juliadb.juliadata.org/latest/out_of_core/*](https://juliadb.juliadata.org/latest/out_of_core/).
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on dataframes as collections of rows is available at [*https://bkamins.github.io/julialang/2023/02/24/dfrows.html*](https://bkamins.github.io/julialang/2023/02/24/dfrows.html).
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
