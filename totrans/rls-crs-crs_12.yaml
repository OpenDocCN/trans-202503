- en: Chapter 10. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：测试
- en: So far, you’ve tested your code by typing in the Rails console and clicking
    links in the web browser. As you add more features to your application, however,
    this won’t scale. And even with more effective test methods, you’ll still have
    to remember to retest everything in the application after you add each feature.
    Otherwise you might miss a regression.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在 Rails 控制台中输入代码并点击浏览器中的链接来测试代码。然而，随着你为应用程序添加更多功能，这种方式将无法扩展。即便使用了更有效的测试方法，你仍然需要记得在每次添加新功能后重新测试应用程序中的所有内容。否则，你可能会错过回归错误。
- en: Rather than manually testing your application, you can write automated tests
    in Ruby to ensure your code is correct and meets all of your requirements. Once
    you have a set of automated tests in place, you can run an entire suite of tests
    to catch regressions, helping you to refactor your code with confidence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与其手动测试你的应用程序，不如在 Ruby 中编写自动化测试，确保你的代码是正确的并满足所有需求。一旦你设置好一套自动化测试，你就可以运行整个测试套件来捕捉回归，从而帮助你更有信心地重构代码。
- en: 'Several different test frameworks are available for Ruby. In this chapter,
    we focus on the default test framework used by Rails: MiniTest.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 提供了几种不同的测试框架。本章重点介绍 Rails 默认使用的测试框架：MiniTest。
- en: Testing in Rails
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Rails 中进行测试
- en: 'Basic test skeletons are automatically created in the *test* directory when
    you generate Rails models and controllers. These are just starting points: They
    don’t really test anything, but having the framework in place makes adding your
    own tests much easier.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的测试框架会在生成 Rails 模型和控制器时自动创建在*test*目录中。这些只是起点：它们并不真正测试任何内容，但有了框架，添加你自己的测试将变得更加容易。
- en: In this chapter, I’ll discuss testing models and controllers. You’ll learn how
    to test individual components and the interactions between components. But first,
    let’s prepare your environment for testing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论如何测试模型和控制器。你将学习如何测试单独的组件以及组件之间的交互。但首先，让我们为测试准备好环境。
- en: Preparing to Test
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备测试
- en: So far you’ve been working in the Rails `development` environment while building
    the application. The Rails `test` environment is preconfigured for testing, but
    you still must do a few things before running your tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在 Rails `development` 环境中构建应用程序。Rails `test` 环境已经预先配置好用于测试，但在运行测试之前，你仍然需要做一些准备工作。
- en: 'The `test` environment uses a separate database just for running tests. First,
    make sure your application’s *db/schema.rb* is up to date by running database
    migrations:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 环境使用一个独立的数据库专门用于运行测试。首先，确保通过运行数据库迁移来更新应用程序的*db/schema.rb*：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The test database is automatically re-created before each test run to ensure
    that tests don’t depend on data already in the database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据库会在每次测试运行之前自动重新创建，以确保测试不依赖于数据库中已经存在的数据。
- en: Running Tests
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: Now that the test database is set up, you’re ready to run your tests. Rails
    provides several different rake tasks for running the various types of tests you’ll
    create.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试数据库已经设置好，你可以开始运行你的测试了。Rails 提供了几种不同的 rake 任务，用于运行你将创建的各种类型的测试。
- en: The `bin/rake test` command runs all tests by default. If you include the name
    of a test file on the command line, it only runs the tests in that file. While
    working on a particular model or controller, running the tests associated with
    that class is faster.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`bin/rake test` 命令会运行所有测试。如果你在命令行中包含某个测试文件的名称，它只会运行该文件中的测试。在处理特定模型或控制器时，运行与该类相关的测试会更快。
- en: 'This command runs all of the tests in the file *test/models/user_test.rb*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会运行文件*test/models/user_test.rb*中的所有测试：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After a short pause, you should see output like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，你应该会看到类似下面的输出：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As the last line indicates, no tests have been defined yet. Open *test/models/user_test.rb*
    in your editor and let’s add some tests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如最后一行所示，还没有定义任何测试。打开*test/models/user_test.rb*，让我们添加一些测试。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This test file first requires the file *test/test_helper.rb* ➊, which holds
    the configuration for all tests. The test helper also loads all *fixtures*, or
    sample data, and can include helper methods for tests. Next, the test file defines
    a *test case* named `UserTest` by inheriting from `ActiveSupport::TestCase` ➋.
    A test case is a set of tests related to a class. Inside the test case, a simple
    example test ➌ is provided in the comments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试文件首先引入了文件*test/test_helper.rb* ➊，该文件包含了所有测试的配置。测试助手还会加载所有*fixtures*（样本数据），并且可以包含测试的辅助方法。接下来，测试文件通过继承自`ActiveSupport::TestCase`
    ➋ 定义了一个名为`UserTest`的*测试用例*。测试用例是一组与某个类相关的测试。在测试用例内部，注释中提供了一个简单的示例测试 ➌。
- en: 'The commented-out test doesn’t really test anything even if you uncomment it,
    so you could remove it. But these lines do show the basic structure of all tests,
    so let’s examine them before moving forward:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉的测试即使取消注释也并未真正进行测试，因此可以将其移除。但这些行展示了所有测试的基本结构，所以在继续之前让我们先检查一下：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `test` method ➊ accepts a test name and a block of code to execute. This
    block contains one or more assertions ➋. An *assertion* tests a line of code for
    an expected result. The `assert` method shown here expects its argument to evaluate
    to a true value. If the assertion is true, the test passes and a single dot is
    printed. Otherwise, the test fails and an *F* is printed along with a message
    identifying the failing test.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 方法 ➊ 接受一个测试名称和一个要执行的代码块。这个代码块包含一个或多个断言 ➋。*断言* 用于测试代码行的预期结果。这里显示的 `assert`
    方法期望其参数评估为 true。如果断言为真，测试通过并输出一个点。如果断言为假，测试失败，并输出一个 *F* 以及标识失败测试的消息。'
- en: Now let’s follow this basic test structure to add a real test to this file.
    I find it helpful to open the model I’m testing, in this case, *app/models/user.rb*,
    and the test file at the same time. I usually add tests for any custom methods
    I’ve added to a model and verify that the model’s validations are working as expected.
    Looking at the `user` model, you see several `has_many` associations, followed
    by the Rails `has_secure_password` method, a validation, and the methods you’ve
    written.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照这个基本的测试结构向文件中添加一个真实的测试。我觉得同时打开正在测试的模型文件（在本例中是 *app/models/user.rb*）和测试文件很有帮助。我通常会为模型中添加的任何自定义方法编写测试，并验证模型的验证是否按预期工作。查看
    `user` 模型时，你会看到几个 `has_many` 关联，接着是 Rails 的 `has_secure_password` 方法、一个验证以及你编写的方法。
- en: First, let’s make sure you can create a valid user. Remember, the `has_secure_password`
    method adds validations for attributes named `password` and `password_confirmation`.
    Users are also required to have a unique email address, so to create a valid user,
    you must provide `email`, `password`, and `password_confirmation`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你能够创建一个有效的用户。记住，`has_secure_password` 方法会为名为 `password` 和 `password_confirmation`
    的属性添加验证。用户还需要有一个唯一的电子邮件地址，因此要创建有效的用户，你必须提供 `email`、`password` 和 `password_confirmation`。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, you instantiate a new `User` object with valid attributes ➊ and assert
    that it saves ➋.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你用有效的属性实例化一个新的 `User` 对象 ➊ 并断言它能够成功保存 ➋。
- en: 'Run the tests in this file again:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行此文件中的测试：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The single dot ➊ represents the single test. The last line of output ➋ tells
    you that you ran one test with one assertion and had zero failures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单个点 ➊ 代表单个测试。最后一行输出 ➋ 告诉你你运行了一个测试，包含一个断言且没有失败。
- en: You could continue adding tests at this point, but manually creating users for
    all of your tests will get tedious. Luckily, Rails includes the fixtures I mentioned
    earlier, which can automatically create as many model objects with sample data
    as you need.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续添加更多的测试，但手动为所有测试创建用户会变得很繁琐。幸运的是，Rails 提供了之前提到的 fixtures，它可以自动创建需要的多个带有示例数据的模型对象。
- en: Using Fixtures
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Fixtures
- en: '*Fixtures* provide sample data for tests, and they are written in a format
    called *YAML*. YAML originally stood for *Yet Another Markup Language*, but is
    now a recursive acronym for *YAML Ain’t Markup Language*. Fixtures are automatically
    loaded into the `test` database by the file *tests/test_helper.rb* and are available
    to all test cases.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fixtures* 为测试提供示例数据，它们是用 *YAML* 格式编写的。YAML 最初代表 *Yet Another Markup Language*，但现在是
    *YAML Ain’t Markup Language* 的递归首字母缩略词。Fixtures 会被 *tests/test_helper.rb* 文件自动加载到
    `test` 数据库中，并对所有测试用例可用。'
- en: User Fixtures
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户 Fixtures
- en: 'Open the file *test/fixtures/users.yml*, remove its contents, and create two
    sample users:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件 *test/fixtures/users.yml*，清空其内容，并创建两个示例用户：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code adds sample data for two users. The YAML file begins with the name
    of the first fixture followed by a colon ➊. In this case, the fixture is named
    `user1`. The indented lines under the name specify attributes. The first user
    has an email address of `user1@example.com` ➋.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为两个用户添加了示例数据。YAML 文件以第一个 fixture 的名称开始，后面跟着冒号 ➊。在本例中，fixture 名为 `user1`。在名称下缩进的行指定了属性。第一个用户的电子邮件地址是
    `user1@example.com` ➋。
- en: You can even use ERB to help add data to fixtures. Rather than precompute the
    values for the `password_digest` field, use the `BCrypt::Password.create` method
    to create the `password_digest` ➌ dynamically. This method is part of the bcrypt
    gem you installed in [Chapter 9](ch09.html "Chapter 9. Authentication").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用ERB来帮助向数据中添加内容。与其预先计算`password_digest`字段的值，不如使用`BCrypt::Password.create`方法动态生成`password_digest`
    ➌。这个方法是你在[第9章](ch09.html "第9章.认证")中安装的bcrypt gem的一部分。
- en: Refer to one of these users in your tests by calling the `users` method and
    passing the name of the user you want. For example, `users(:user1)` returns the
    first user just defined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，使用`users`方法并传递你想要的用户的名字来引用这些用户。例如，`users(:user1)`返回之前定义的第一个用户。
- en: 'Go back to the user tests in *test/models/user_test.rb* and let’s try the new
    fixtures:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到*test/models/user_test.rb*中的用户测试，试试新的数据：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This test uses a fixture to initialize a user ➊, sets the user’s `email` to
    `nil` ➋, and ensures the user is not valid with the `assert_not` method ➌. The
    `assert_not` method only passes if its condition is a false value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用数据初始化一个用户 ➊，将该用户的`email`设置为`nil` ➋，并使用`assert_not`方法确保用户无效 ➌。只有当`assert_not`方法的条件为假值时，才会通过。
- en: This test proves that an email is required; now you’ll add a test for email
    uniqueness.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试证明了电子邮件是必需的；现在你将添加一个测试，确保电子邮件的唯一性。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test uses fixtures to initialize two users ➊, sets the first user’s `email`
    equal to the second user’s `email` ➋, and asserts ➌ that the first user is no
    longer valid. The second user is still valid because the first user can’t be saved
    with invalid data. You can look at the test log in *log/test.log* to see the queries
    being run for each test.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用数据初始化两个用户 ➊，将第一个用户的`email`设置为第二个用户的`email` ➋，并验证 ➌ 第一个用户不再有效。第二个用户仍然有效，因为第一个用户由于无效数据不能被保存。你可以查看*log/test.log*中的测试日志，查看每个测试运行的查询。
- en: Fixtures have `id` values based on a hash of the fixture name, and those values
    are always the same. For example, the `id` for `@user1` is 206669143\. This value
    never changes. Associations between fixtures are created by name because the `id`
    of each fixture is based on its name. The `Post` fixtures discussed next include
    associations with the `User` fixtures you created earlier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据有基于数据名称的`id`值，这些值始终是相同的。例如，`@user1`的`id`是206669143\。这个值永远不会改变。数据之间的关联是通过名称创建的，因为每个数据的`id`是基于其名称的。接下来讨论的`Post`数据包括与之前创建的`User`数据的关联。
- en: Post Fixtures
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后置数据
- en: Rails automatically created fixture files for the `TextPost` and `ImagePost`
    types. You’ll include both types of fixtures in the `Post` file. The fixture files
    for the other types will cause an error, so delete the files *test/fixtures/text_posts.yml*
    and *test/fixtures/image_posts.yml* before moving on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Rails自动为`TextPost`和`ImagePost`类型创建了数据文件。你将把这两种类型的数据包括在`Post`文件中。其他类型的数据文件会导致错误，因此在继续之前，请删除文件*test/fixtures/text_posts.yml*和*test/fixtures/image_posts.yml*。
- en: 'Now open the file *test/fixtures/posts.yml* and create some sample posts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开文件*test/fixtures/posts.yml*并创建一些示例帖子：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you have three posts. The first two belong to the `User` named *user1*
    and the third belongs to *user2*. You’ll put these to good use a little later
    when you add tests for the `Post` model.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你有三个帖子。前两个属于名为*user1*的`User`，第三个属于*user2*。稍后你会在为`Post`模型添加测试时用到这些帖子。
- en: Putting Assertions to Work
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将断言应用于实践
- en: 'Assertions are the building blocks of tests. You’ve already seen a few assertions,
    such as `assert` and `assert_not`, in the tests you’ve written so far. The MiniTest
    library contains more, and Rails adds a few of its own. Here are some of the most
    commonly used assertions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是测试的构建块。你已经在之前写的测试中看到了几个断言，如`assert`和`assert_not`。MiniTest库中包含了更多断言，Rails还添加了一些自己的断言。这里是一些最常用的断言：
- en: '**`assert` *`test`***'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert` *`test`***'
- en: Passes if the `test` expression evaluates to true
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`test`表达式的值为真，则测试通过
- en: '**`assert_empty` *`obj`***'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_empty` *`obj`***'
- en: Passes if `obj.empty?` is true
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj.empty?`为真，则测试通过
- en: '**`assert_equal` *`expected, actual`***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_equal` *`expected, actual`***'
- en: Passes if the `expected` value equals the `actual` value
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`expected`值等于`actual`值，则测试通过
- en: '**`assert_includes` *`collection, obj`***'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_includes` *`collection, obj`***'
- en: Passes if `collection.includes?(obj)` returns true
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`collection.includes?(obj)`返回真，则测试通过
- en: '**`assert_instance_of` *`class, obj`***'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_instance_of` *`class, obj`***'
- en: Passes if `obj.instance_of?(class)` is true
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj.instance_of?(class)`为真，则测试通过
- en: '**`assert_match` *`regexp, string`***'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_match` *`regexp, string`***'
- en: Passes if the given `string` matches the regular expression `regexp`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的 `string` 与正则表达式 `regexp` 匹配，则测试通过
- en: '**`assert_nil` *obj***'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_nil` *obj***'
- en: Passes if `obj.nil?` is true
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `obj.nil?` 为真，测试通过
- en: Each of these assertions also comes in a “not” form. For example, `assert_not`
    passes if the expression being tested is false and `assert_not_equal` passes if
    the expected value is not equal to the actual value. Assertions also accept an
    optional message parameter, which is a string that prints if the assertion fails.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个断言也有“不”的形式。例如，`assert_not` 如果被测试的表达式为假则通过，`assert_not_equal` 如果预期值与实际值不相等则通过。断言还接受一个可选的消息参数，这是一个在断言失败时打印的字符串。
- en: 'Let’s put our knowledge of assertions to work and add a few more tests to the
    `user` model. Here’s the first one:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将对断言的知识付诸实践，并为 `user` 模型添加更多测试。以下是第一个测试：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This test creates two users using fixtures ➊ and then calls the `follow!` method
    on `@user1` with `@user2` as an argument ➋. It then ensures that `@user1` has
    one leader and `@user2` has one follower ➌.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试使用 fixtures 创建两个用户 ➊，然后调用 `@user1` 的 `follow!` 方法，并将 `@user2` 作为参数 ➋。接着确保
    `@user1` 有一个领导者，而 `@user2` 有一个追随者 ➌。
- en: 'This next test verifies the `following?` method works correctly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的测试验证了 `following?` 方法是否正常工作：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It again uses fixtures to create two users and then calls the `follow!` method
    on `@user1` with `@user2` as an argument and finally ensures that `@user1.following?(@user2)`
    is true.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次使用 fixtures 创建两个用户，然后调用 `@user1` 的 `follow!` 方法，并将 `@user2` 作为参数，最后确保 `@user1.following?(@user2)`
    返回 true。
- en: Eliminating Duplication with Callbacks
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调消除重复
- en: The tests you’ve made should all work correctly, but I’ve introduced some duplication
    in the code. Almost every test uses fixtures to create users. Remember, don’t
    repeat yourself. Luckily, test cases include two callbacks that can help eliminate
    this duplication. *Callbacks* are methods that are called automatically before
    and after each test.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你所编写的测试应该都能正确工作，但我引入了一些代码重复。几乎每个测试都使用 fixtures 来创建用户。记住，不要重复自己。幸运的是，测试用例包括两个回调，可以帮助消除这些重复。*回调*
    是在每个测试之前和之后自动调用的方法。
- en: The `setup` method is called before each test, and the `teardown` method is
    called after each test. These methods are commonly used to initialize objects
    that are employed in multiple tests. You can use the `setup` method to initialize
    the values of `@user1` and `@user2` automatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup` 方法在每个测试之前调用，而 `teardown` 方法在每个测试之后调用。这些方法通常用于初始化在多个测试中使用的对象。你可以使用 `setup`
    方法自动初始化 `@user1` 和 `@user2` 的值。'
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that `@user1` and `@user2` are being initialized ➊ in the setup method,
    you can remove the duplication from each of the tests, as shown in the rewritten
    test for `following?` ➋.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`@user1` 和 `@user2` 在 `setup` 方法中初始化 ➊，你可以从每个测试中去除重复部分，如重写后的 `following?`
    测试 ➋ 所示。
- en: Model Tests
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型测试
- en: The tests you’ve seen so far are model tests. *Model tests* verify the behavior
    of your application’s models. These types of tests were previously called *unit
    tests*. I typically add tests for validations and for any custom methods I’ve
    written.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你看到的测试都是模型测试。*模型测试* 验证了应用程序模型的行为。这类测试以前被称为 *单元测试*。我通常会为验证和我编写的任何自定义方法添加测试。
- en: I’ve covered both of these for the `User` model, so now let’s add tests for
    the `Post` model. You may also want to refer to the `Post` model in *app/models/post.rb*
    as you write tests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为 `User` 模型覆盖了这两个回调，那么现在让我们为 `Post` 模型添加测试。在编写测试时，你可能还想参考 *app/models/post.rb*
    中的 `Post` 模型。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Post` model is still pretty simple. A post belongs to a user and can have
    many comments. It also validates the presence of a `user_id` and a `type`. Let’s
    add a test to verify that a `Post` has a `user_id`. Open the file *test/models/post_test.rb*
    in your editor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post` 模型仍然非常简单。一个帖子属于一个用户，并且可以有多个评论。它还验证了 `user_id` 和 `type` 的存在。让我们添加一个测试来验证
    `Post` 是否有 `user_id`。在编辑器中打开 *test/models/post_test.rb* 文件：'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `setup` method ➊ initializes two posts that you can refer to in your tests.
    The first test ➋ verifies that a `Post` without a `user_id` is not valid.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup` 方法 ➊ 初始化了两个你可以在测试中引用的帖子。第一个测试 ➋ 验证没有 `user_id` 的 `Post` 是无效的。'
- en: 'Since you have model tests for the users and posts now, you can use the `bin/rake
    test:models` command to run all model tests:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在你已经为用户和帖子编写了模型测试，你可以使用 `bin/rake test:models` 命令来运行所有模型测试：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If this command results in an error, delete the unused fixture files for the
    `TextPost` and `ImagePost` models as mentioned earlier. Delete *test/fixtures/text_posts.yml*
    and *test/fixtures/image_posts.yml*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此命令导致错误，请删除之前提到的`TextPost`和`ImagePost`模型中未使用的 fixture 文件。删除*test/fixtures/text_posts.yml*和*test/fixtures/image_posts.yml*。
- en: 'The other post types have validations of their own. For example, the `TextPost`
    validates the presence of a `body`, and the `ImagePost` validates the presence
    of a `url`. Since we already have `TextPost` and `ImagePost` fixtures, let’s add
    tests for both of those validations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其他帖子类型有自己的验证。例如，`TextPost`验证`body`的存在，`ImagePost`验证`url`的存在。既然我们已经有了`TextPost`和`ImagePost`的fixture，那么让我们为这两个验证添加测试：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both of these tests follow the same pattern. First, verify that `@post1` is
    an instance of `TextPost` ➊. Next, set the `body` of `@post1` to `nil` ➋. Finally,
    verify that `@post1` is no longer valid ➌. The `ImagePost` assertions do the same,
    but for `@post2`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试遵循相同的模式。首先，验证`@post1`是否为`TextPost`的实例 ➊。接着，将`@post1`的`body`设置为`nil` ➋。最后，验证`@post1`不再有效
    ➌。`ImagePost`的断言做了相同的事情，但针对`@post2`。
- en: Controller Tests
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器测试
- en: '*Controller tests* verify the actions of a single controller by simulating
    requests to your application and validating the responses. Controller tests ensure
    that a controller action responds successfully to valid requests, and that it
    renders the correct view or redirects to the correct location. These types of
    tests were previously called *functional tests*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制器测试*通过模拟请求到你的应用程序并验证响应，来验证单个控制器的操作。控制器测试确保控制器操作能够成功响应有效请求，并正确渲染视图或重定向到正确的位置。这类测试之前被称为*功能测试*。'
- en: Controller Test Helpers
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器测试辅助方法
- en: Rails includes several helper methods and variables that make controller tests
    easier to write.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Rails包含了几个辅助方法和变量，使控制器测试更易编写。
- en: 'The methods `get`, `post`, `put`, `patch`, `head`, and `delete` simulate a
    request to a controller action. These methods can take two optional hashes: one
    representing request parameters and another representing the current session.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`get`、`post`、`put`、`patch`、`head`和`delete`模拟对控制器操作的请求。这些方法可以接受两个可选的哈希：一个表示请求参数，另一个表示当前会话。
- en: 'After a request has been made with one of those six methods, the following
    four hashes become available:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上述六个方法之一发出请求后，以下四个哈希变得可用：
- en: '| **`assigns`** | Contains the instance variables assigned in the controller
    action |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **`assigns`** | 包含在控制器操作中分配的实例变量 |'
- en: '| **`cookies`** | Contains any cookie values set in the action |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **`cookies`** | 包含操作中设置的任何cookie值 |'
- en: '| **`flash`** | Holds the flash values set in the action |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **`flash`** | 包含操作中设置的闪存值 |'
- en: '| **`session`** | Contains any session values set by the action |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **`session`** | 包含操作中设置的任何会话值 |'
- en: 'Your tests also have access to three instance variables: `@controller` contains
    the controller processing the request; `@request` is the request being processed;
    and `@response` is the controller’s response to the request.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试还可以访问三个实例变量：`@controller`包含正在处理请求的控制器；`@request`是正在处理的请求；`@response`是控制器对该请求的响应。
- en: Controller Test Assertions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器测试断言
- en: Rails adds several assertions specifically for controller tests in addition
    to those you’ve already seen. Controller actions always either render a response
    or redirect to a different URL.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Rails为控制器测试添加了几个断言，除了你已经见过的那些之外。控制器操作总是会渲染响应或重定向到不同的URL。
- en: '**`assert_response` *`type`***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_response` *`type`***'
- en: Passes if the HTTP response matches a specific status code. Use a status code
    or one of the symbols `:success`, `:redirect`, `:missing`, or `:error` for `type`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP响应与特定状态码匹配，则通过测试。对于`type`，可以使用状态码或符号`：success`、`：redirect`、`：missing`或`：error`。
- en: '**`assert_redirected_to` *`options`***'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_redirected_to` *`options`***'
- en: Passes if the request causes a redirect to the path given in `options`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求导致重定向到`options`中给定的路径，则通过测试。
- en: '**`assert_template` *expected***'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_template` *expected***'
- en: Passes if the request renders the `expected` template.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求渲染了`expected`模板，则通过测试。
- en: These assertions verify that a controller action correctly responds to a request.
    For a simple GET request, `assert_response :success` might be the only test needed.
    If the controller action assigns an instance variable, you should also verify
    that assignment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言验证控制器操作是否正确响应请求。对于简单的GET请求，`assert_response :success`可能是唯一需要的测试。如果控制器操作分配了实例变量，你还应验证该赋值操作。
- en: 'Let’s add controller tests for the `new` and `create` actions in `UsersController`.
    First, test that the `new` action successfully renders the sign-up form with a
    newly created instance of the `User` model. Open the file *test/controllers/users_controller_test.rb*
    to add the following test:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`UsersController`中的`new`和`create`动作添加控制器测试。首先，测试`new`动作是否成功渲染带有新创建的`User`模型实例的注册表单。打开文件*test/controllers/users_controller_test.rb*，添加以下测试：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This test issues a GET request for the new user page ➊, gets a copy of the value
    assigned to the instance variable `@user` ➋ in the controller, and verifies that
    `user` is a new record ➌ and the response was successful.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试发出一个GET请求到新用户页面 ➊，获取控制器中分配给实例变量`@user`的值 ➋，并验证`user`是一个新记录 ➌，且响应成功。
- en: 'The next test checks the ability to create new users given valid data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试检查在给定有效数据时创建新用户的能力：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This test is a bit more complex because the `create` action expects a hash of
    values for the new user ➊. This test issues a POST request to the `create` action
    using the `params` hash ➋ and then verifies that the action redirects to the `root_url`
    ➌.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试稍微复杂一些，因为`create`动作需要一个包含新用户数据的哈希 ➊。这个测试通过`params`哈希向`create`动作发出POST请求
    ➋，然后验证该动作是否重定向到`root_url` ➌。
- en: The previous test checks what happens when a `User` is successfully saved. You
    should test the other path through the controller action, that is, when the `User`
    can’t be saved. You could add a test that attempts to create a user with invalid
    attributes and verifies the new user template is rendered again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个测试检查了`User`成功保存时发生的情况。你应该测试控制器动作中的另一条路径，即当`User`无法保存时。你可以添加一个测试，尝试创建一个具有无效属性的用户，并验证是否再次渲染新用户模板。
- en: 'Run the new controller tests with the `bin/rake test:controllers` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`bin/rake test:controllers`命令运行新的控制器测试：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `UsersController` tests should pass successfully, so let’s move on to the
    `PostsController`. Verify that the `before_action` method `authenticate_user!`
    is working correctly so your application won’t show posts to unauthenticated users.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersController`的测试应该成功通过，那么我们继续进行`PostsController`的测试。验证`before_action`方法`authenticate_user!`是否正常工作，以确保应用程序不会向未认证用户展示帖子。'
- en: 'Open the file *test/controllers/posts_controller_test.rb* in your editor and
    add the following tests:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件*test/controllers/posts_controller_test.rb*，并添加以下测试：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first test attempts to GET the post `index` page ➊ and verifies the action
    redirects to the login page ➋. The second test initializes a user using a fixture
    ➌ then issues the GET request for the `index` page with a `user_id` in the session
    ➍. Simulating a logged-in user by including a valid `user_id` in the session should
    result in a successful response.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试尝试GET请求文章`index`页面 ➊，并验证该动作是否重定向到登录页面 ➋。第二个测试使用一个数据固定项初始化一个用户 ➌，然后带着`user_id`在会话中发出GET请求访问`index`页面
    ➍。通过在会话中包含有效的`user_id`来模拟登录用户，应该能获得一个成功的响应。
- en: Integration Tests
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: '*Integration tests* verify the interaction between several different controllers.
    These are commonly used to test the *flow* between several pages of your application.
    An example of a flow would be logging in to the application, viewing a page, and
    then performing some other action. Each of these actions could be covered by controller
    tests. An integration test ensures that they all work together.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*集成测试*验证不同控制器之间的交互。这些测试通常用于测试应用程序中多个页面之间的*流程*。一个流程的例子可能是登录应用、查看页面，然后执行某个其他操作。这些操作中的每一个都可以通过控制器测试来覆盖。集成测试确保它们能一起工作。'
- en: Integration Helpers
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成辅助工具
- en: Because integration tests generally involve moving between pages in the application,
    your tests need not only to make requests to actions but also to follow any redirects.
    The helper methods `redirect?` and `follow_redirect!` check to see if the last
    request resulted in a redirect and follow a redirect response, respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为集成测试通常涉及在应用程序页面之间移动，所以你的测试不仅需要向动作发出请求，还需要跟随任何重定向。辅助方法`redirect?`和`follow_redirect!`分别检查最后的请求是否导致重定向，并跟随重定向响应。
- en: If you know that a request results in a redirect, more specific methods are
    available. You can use `get_via_redirect`, `post_via_redirect`, `put_via_redirect`,
    `patch_via_redirect`, or `delete_via_redirect` to make the appropriate request
    and also follow the redirect.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道一个请求会导致重定向，可以使用更具体的方法。你可以使用`get_via_redirect`、`post_via_redirect`、`put_via_redirect`、`patch_via_redirect`或者`delete_via_redirect`来发出适当的请求并跟随重定向。
- en: Testing a Flow
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试流程
- en: Rails doesn’t create integration tests automatically like model and controller
    tests because Rails has no way of knowing which flows you want to test. Although
    they are not created automatically, Rails does include a generator you can use
    to create integration tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Rails不会像模型和控制器测试那样自动创建集成测试，因为Rails无法知道你想要测试哪些流程。尽管它们不会自动创建，但Rails确实提供了一个生成器，你可以用来创建集成测试。
- en: 'Let’s add an integration test to verify that a user can log in to the application,
    see the home page, and then log out. First, use the `bin/rails generate` command
    to create a new integration test:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个集成测试，验证用户是否可以登录应用程序、查看主页然后退出。首先，使用`bin/rails generate`命令创建一个新的集成测试：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command creates a new file named *test/integration/user_flow_test.rb*.
    Open that file in your editor and let’s add a test:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建一个新文件，命名为*test/integration/user_flow_test.rb*。在你的编辑器中打开该文件，让我们添加一个测试：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This test looks like an extended controller test. The test requests a page with
    `get` ➊ and then verifies a successful response. You know that a user logs in
    to the application with a POST request to the sessions path and is then redirected
    to the home page, so you use the `post_via_redirect` method to submit the user’s
    email address and password and then follow the redirect automatically ➋. Finally,
    the test issues a GET request for the logout page ➌ and is redirected back to
    the login page.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试看起来像是一个扩展的控制器测试。该测试使用`get`请求页面➊，然后验证响应是否成功。你知道用户是通过向会话路径发送POST请求来登录应用程序，然后被重定向到主页，所以你使用`post_via_redirect`方法提交用户的电子邮件地址和密码，随后自动跟随重定向➋。最后，测试发出一个GET请求到登出页面➌，并被重定向回登录页面。
- en: 'Enter the following command to run the integration test:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令来运行集成测试：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This test confirms that a user can log in to the application, view the home
    page, and then log out successfully.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试确认用户能够登录应用程序、查看主页并成功退出。
- en: This path is basically the only one a user can take through the application
    at this time. As you add more actions to the application, you can create integration
    tests to verify that other flows work correctly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这条路径基本上是用户在应用程序中可以走的唯一路径。当你向应用程序添加更多操作时，可以创建集成测试来验证其他流程是否正常工作。
- en: Adding Features with Test-Driven Development
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试驱动开发添加功能
- en: The tests written so far have all verified existing functionality, but some
    Rails developers use tests to define features before implementing them, a practice
    called *test-driven development (TDD)*. In TDD, you write a test first and then
    add code to make the test pass. Once the test passes, you can refactor the code
    if necessary. If you follow TDD, you won’t have to worry about parsing your code
    later to figure out what functionality to verify.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止编写的所有测试都验证了现有功能，但一些Rails开发者使用测试在实现功能之前定义功能，这种做法被称为*测试驱动开发（TDD）*。在TDD中，你首先编写一个测试，然后添加代码使测试通过。一旦测试通过，你可以根据需要重构代码。如果你遵循TDD，就不必担心以后解析代码来弄清楚需要验证哪些功能。
- en: 'TDD is usually a three-step process known as red-green-refactor:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TDD通常是一个三步过程，称为红-绿-重构：
- en: Write a failing test (red).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个失败的测试（红色）。
- en: Write code to make the test pass (green).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码使测试通过（绿色）。
- en: Refactor as needed (refactor).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重构（refactor）。
- en: By following this process, you can be confident that new functionality meets
    the requirements specified in the test and that it did not introduce any regressions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个过程，你可以确信新功能符合测试中指定的要求，并且没有引入任何回归问题。
- en: 'Let’s use TDD to add features to our social application. Although many features
    are still missing, let’s focus on these:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用TDD向我们的社交应用程序添加功能。尽管许多功能仍然缺失，但我们先集中关注这些：
- en: Add a user `show` page showing a user’s posts and a Follow button.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个用户`show`页面，显示用户的帖子并包含一个“关注”按钮。
- en: Give users the ability to create new posts.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让用户能够创建新帖子。
- en: For each of these features, you’ll first write a failing test and then write
    code to make the test pass.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些功能，你将首先编写一个失败的测试，然后编写代码使测试通过。
- en: Show User
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示用户
- en: The user `show` page displays the user’s name and posts. It should also include
    a button to allow other users to follow this user. To add the user `show` page,
    you need to add a `show` method to the user controller and create a corresponding
    view. You know the controller should assign an instance variable named `@user`
    for the view to use and respond with success, so let’s add a test for that.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的 `show` 页面显示了用户的姓名和帖子，应该还包括一个按钮，允许其他用户关注该用户。为了添加用户的 `show` 页面，你需要在用户控制器中添加一个
    `show` 方法并创建相应的视图。你知道控制器应该为视图分配一个名为 `@user` 的实例变量并返回成功响应，所以我们来为此添加一个测试。
- en: 'Open the file *test/controllers/users_controller_test.rb* and add this test:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件 *test/controllers/users_controller_test.rb* 并添加这个测试：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, run the test and make sure it fails:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试并确保它失败：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running this test should result in an error. The action `show` could not be
    found for `UsersController` because you haven’t created it yet. So let’s add the
    `show` action to *app/controllers/users_controller.rb*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试应该会导致一个错误。由于你还没有创建 `show` 操作，所以找不到 `UsersController` 的 `show` 操作。现在让我们向
    *app/controllers/users_controller.rb* 中添加 `show` 操作：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save the file and run the tests again. This time you should see a different
    error. The template is missing. Create a new file named *app/views/users/show.html.erb*,
    and add that template now:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并再次运行测试。这次你应该会看到一个不同的错误。模板丢失了。创建一个新的文件 *app/views/users/show.html.erb*，并现在添加该模板：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save this file and run the tests again. All tests should now pass, but you still
    have one problem. This page shows the user’s email address and the user’s posts,
    but no one can follow the user!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个文件并再次运行测试。所有测试现在应该都通过了，但你仍然有一个问题。这个页面显示了用户的电子邮件地址和用户的帖子，但没有人可以关注该用户！
- en: Following a user creates a record in the subscriptions table in the database.
    Because this has to happen on the server, adding the Follow button requires a
    controller action and a new route to that action.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关注一个用户会在数据库的 subscriptions 表中创建一条记录。由于这必须在服务器端进行，添加关注按钮需要一个控制器操作和一个新的路由到该操作。
- en: 'Add another controller test to *test/controllers/users_controller_test.rb*
    to describe this action:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *test/controllers/users_controller_test.rb* 中添加另一个控制器测试，以描述这个操作：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This test first creates two users using fixtures ➊. Next, it issues a GET request
    for the `follow` action with the second user’s `id` as a parameter and the first
    user’s `id` in the session ➋. This simulates `user1` following `user2`. Finally,
    it verifies that `user1` is now following `user2` and that the request redirects
    back to the `show` page for `user2` ➌.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试首先使用数据填充（fixtures）创建两个用户 ➊。接下来，它使用第二个用户的 `id` 作为参数，且将第一个用户的 `id` 放入会话中，发出对
    `follow` 操作的 GET 请求 ➋。这模拟了 `user1` 关注 `user2` 的场景。最后，它验证 `user1` 已经关注了 `user2`，并且请求会重定向回
    `user2` 的 `show` 页面 ➌。
- en: 'Now open the file *app/controllers/users_controller.rb*, and add the `follow`
    action after the other actions, but before the `private` methods:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 *app/controllers/users_controller.rb* 文件，并在其他操作之后但在 `private` 方法之前添加 `follow`
    操作：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This method finds the correct user using the id parameter ➊, calls the follow!
    method on current_user ➋, and then redirects to @user ➌.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用 `id` 参数 ➊ 找到正确的用户，调用当前用户的 `follow!` 方法 ➋，然后重定向到 @user ➌。
- en: 'Now open *config/routes.rb* and add a route to the new `follow` action:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 *config/routes.rb* 并为新的 `follow` 操作添加一个路由：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'I added this under the `signup` route because these actions are both in the
    user controller. Now, back in *app/views/users/show.html.erb,* you can add the
    Follow button:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其添加到了 `signup` 路由下，因为这两个操作都在用户控制器中。现在，回到 *app/views/users/show.html.erb* 中，你可以添加关注按钮了：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Follow button is similar to the Home button; it’s actually a link with Bootstrap’s
    `btn` and `btn-default` styles applied to make it look like a button.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关注按钮类似于首页按钮；它实际上是一个带有 Bootstrap `btn` 和 `btn-default` 样式的链接，使其看起来像一个按钮。
- en: You can now run the controller tests again and verify that they all pass. You
    can also start the Rails server if it isn’t already running and go to *http://localhost:3000/users/1*
    in your web browser to see the `show` page for the first user, as shown in [Figure 10-1](ch10.html#user_show_page
    "Figure 10-1. The user show page").
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以重新运行控制器测试，确保它们全部通过。如果 Rails 服务器尚未启动，你也可以启动它，然后在你的浏览器中访问 *http://localhost:3000/users/1*
    来查看第一个用户的 `show` 页面，正如 [图10-1](ch10.html#user_show_page "图10-1. 用户显示页面") 所示。
- en: '![The user show page](httpatomoreillycomsourcenostarchimages2169098.png.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![用户显示页面](httpatomoreillycomsourcenostarchimages2169098.png.jpg)'
- en: Figure 10-1. The user show page
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1. 用户显示页面
- en: '[Figure 10-1](ch10.html#user_show_page "Figure 10-1. The user show page") is
    the `show` page with the user’s name, a button for following this user, and the
    user’s posts.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Create Post
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s give users the ability to add posts. Adding posts requires two controller
    actions: `new` and `create`. The `new` action also requires a matching view. The
    `create` action should redirect to the newly created post, so a view isn’t needed.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application has two different types of posts. Start by adding the ability
    to create posts of type `TextPost`. The `new` action in `TextPostsController`
    should instantiate a new `TextPost` object and render a form for that object.
    Add a failing test to *test/controllers/text_posts_controller_test.rb* and then
    get to work:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The test first creates a new user using a fixture ➊ and then issues a GET request
    for the `new` action with `user_id` set in the session ➋. This step is necessary
    because the `TextPostsController` requires an authenticated user. The test then
    gets the `text_post` instance variable, verifies it’s a new record, and verifies
    a successful response. Run the tests and watch this one fail:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The error message should indicate that the `new` action is missing from `TextPostsController`.
    Open *app/controllers/text_posts_controller.rb*, and add the new action:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You almost have enough to get the test to pass. The last step is to add the
    corresponding view. Create the file *app/views/text_posts/new.html.erb*, and add
    the following content:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This view is a page header followed by a `render` command for the form partial.
    Let’s add the partial now. First, create the file *app/views/text_posts/_form.html.erb*,
    and add this form:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This partial creates a form for the new `TextPost` assigned to `@text_post`
    ➊. The form includes a text field for the post title ➋, a text area for the post
    body ➌, and buttons to submit the form or cancel and go back ➍.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'While you’re editing views, add a button for creating a new text post on the
    home page. Open *app/views/posts/index.html.erb,* and then add this link under
    the page header:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should now be able to run the `TextPostController` tests successfully.
    Now add another controller test to describe creating a `TextPost` to *test/controllers/text_posts_controller_test.rb*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As with the previous controller test for the `TextPostsController`, this test
    first initializes a new user ➊ from a fixture. Next, it sets up the necessary
    parameters ➋ for a new `TextPost`, and then issues a POST request ➌ to the `create`
    action with the `params` hash and the `user.id` in the session. Finally, it ensures
    ➍ the new text post was persisted to the database and that the request redirects
    to the new post’s URL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to making this test pass is to add a `create` action to the
    `TextPostsController`. Open the file *app/controllers/text_posts_controller.rb*,
    and add the following method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `create` method builds a new text post ➊ for the current user using the
    `params` from the form. If it is able to save this new post, it redirects the
    user ➋ to the newly created post. Otherwise, it renders the new text post form
    ➌ again with an error message.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法使用表单中的 `params` 为当前用户创建一个新的文本帖子➊。如果能够保存该新帖子，它将重定向用户➋ 到新创建的帖子页面。否则，它会再次呈现带有错误消息的新建文本帖子表单
    ➌。'
- en: 'Finally, add the `text_post_params` method for Rails strong `params.` This
    method is called in the `create` action to get the permitted parameters for the
    new `TextPost`. Add this private method near the bottom of the `TextPostsController`
    class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `text_post_params` 方法来处理 Rails 强参数。这一方法会在 `create` 操作中调用，以获取新建 `TextPost`
    的允许参数。将此私有方法添加到 `TextPostsController` 类的底部：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method ensures ➊ that the `params` hash contains the `:text_post` key and
    permits key-value pairs for `:title` and `:body` under the `:text_post` key. With
    this change, all of your tests should pass again. Click the **New Text Post**
    button on the home page, as shown in [Figure 10-2](ch10.html#new_text_post_form
    "Figure 10-2. The New Text Post form"), to see the form for creating a `TextPost`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法确保➊ `params` 哈希包含 `:text_post` 键，并允许在 `:text_post` 键下的 `:title` 和 `:body`
    键值对。进行此更改后，所有测试应重新通过。在首页点击 **新建文本帖子** 按钮，如[图 10-2](ch10.html#new_text_post_form
    "图 10-2. 新建文本帖子表单")所示，查看创建 `TextPost` 的表单。
- en: '![The New Text Post form](httpatomoreillycomsourcenostarchimages2169100.png.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![新建文本帖子表单](httpatomoreillycomsourcenostarchimages2169100.png.jpg)'
- en: Figure 10-2. The New Text Post form
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2. 新建文本帖子表单
- en: The process for creating a new `ImagePost` is similar. Exercise 3 at the end
    of this chapter walks through the necessary steps.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的 `ImagePost` 的过程类似。本章末的练习 3 将引导你完成必要的步骤。
- en: These new features bring our application much closer to being a fully functioning
    social network.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新功能使我们的应用更加接近一个完整的社交网络。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a lot of ground in this chapter. You learned about the MiniTest framework.
    You wrote model, controller, and integration tests. We discussed test-driven development
    and then you used it to add features to your social network.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了很多内容。你了解了 MiniTest 框架，编写了模型、控制器和集成测试。我们讨论了测试驱动开发，并使用它向社交网络添加了功能。
- en: You can write the tests either before or after the code, and you can use any
    test framework—what matters is that you write tests. The ability to type a single
    command and verify your application is working correctly is worth the small investment
    of your time. Over the life of an application, the benefits of a comprehensive
    set of tests for your application are immeasurable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码之前或之后编写测试，且可以使用任何测试框架——重要的是你要编写测试。能够输入一个命令并验证应用是否正常工作，值得花费一些时间来实现。在应用的生命周期中，全面的测试集带来的好处是无法估量的。
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '| Q: | 1\. You currently cannot get to the user `show` page without typing
    in the URL. Update the `TextPost` and `ImagePost` partials so the user’s `name`
    is a link to the user’s `show` page. Also, add a link called *Profile* that links
    to the current user’s `show` page next to the *Log Out* link near the top of the
    application layout. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 问：| 1\. 目前你无法通过点击 URL 到达用户的 `show` 页面。请更新 `TextPost` 和 `ImagePost` 的局部视图，使得用户的
    `name` 成为指向该用户 `show` 页面链接。同时，在应用布局的顶部，*Log Out* 链接旁边，添加一个名为 *Profile* 的链接，指向当前用户的
    `show` 页面。 |'
- en: '| Q: | 2\. The `follow` action should not be available to anonymous users.
    Add a call in `UsersController` to `before_action :authenticate_user!` with the
    `only` option to require authentication before the `follow` action. The following
    test should pass after you update `UsersController`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '| 问：| 2\. `follow` 操作不应对匿名用户开放。请在 `UsersController` 中调用 `before_action :authenticate_user!`
    并使用 `only` 选项，要求在执行 `follow` 操作前进行身份验证。更新 `UsersController` 后，以下测试应该通过：'
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Also, the Follow button on the user `show` page should not appear for anonymous
    users or if the current user is already following the user being displayed. Update
    the `show` view to fix this. |
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户 `show` 页面上的 Follow 按钮不应在匿名用户或当前用户已关注该展示用户的情况下显示。请更新 `show` 视图来解决这个问题。|
- en: '| Q: | 3\. Add `new` and `create` actions for image posts and the private `image_post_params`
    method used by the `create` action in *app/controllers/image_posts_controller.rb*.
    Then create a view for the new action at *app/views/image_posts/new.html.erb*
    and a partial for the `ImagePost` form at *app/views/image_posts/_form.html.erb*.
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 问： | 3\. 为图像帖子添加`new`和`create`操作，以及`create`操作中使用的私有`image_post_params`方法，位置在*app/controllers/image_posts_controller.rb*中。然后在*app/views/image_posts/new.html.erb*中为`new`操作创建视图，并在*app/views/image_posts/_form.html.erb*中为`ImagePost`表单创建部分视图。
    |'
- en: Add the following controller tests to *test/controllers/image_posts_controller_test.rb*.
    Both tests should pass after you add the actions to `ImagePostsController` and
    create the associated views.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下控制器测试添加到*test/controllers/image_posts_controller_test.rb*中。在你将操作添加到`ImagePostsController`并创建相关视图后，两个测试应当通过。
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Your implementation of these actions and views should be similar to the TextPost
    new and create actions and views. If you would like to practice TDD, feel free
    to add these tests and confirm they fail before you start implementing the actions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你对这些操作和视图的实现应类似于TextPost的`new`和`create`操作以及视图。如果你想练习TDD，欢迎先添加这些测试并确认它们失败，再开始实现操作。
