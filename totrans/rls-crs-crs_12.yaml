- en: Chapter 10. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve tested your code by typing in the Rails console and clicking
    links in the web browser. As you add more features to your application, however,
    this won’t scale. And even with more effective test methods, you’ll still have
    to remember to retest everything in the application after you add each feature.
    Otherwise you might miss a regression.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than manually testing your application, you can write automated tests
    in Ruby to ensure your code is correct and meets all of your requirements. Once
    you have a set of automated tests in place, you can run an entire suite of tests
    to catch regressions, helping you to refactor your code with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several different test frameworks are available for Ruby. In this chapter,
    we focus on the default test framework used by Rails: MiniTest.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic test skeletons are automatically created in the *test* directory when
    you generate Rails models and controllers. These are just starting points: They
    don’t really test anything, but having the framework in place makes adding your
    own tests much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll discuss testing models and controllers. You’ll learn how
    to test individual components and the interactions between components. But first,
    let’s prepare your environment for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far you’ve been working in the Rails `development` environment while building
    the application. The Rails `test` environment is preconfigured for testing, but
    you still must do a few things before running your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test` environment uses a separate database just for running tests. First,
    make sure your application’s *db/schema.rb* is up to date by running database
    migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The test database is automatically re-created before each test run to ensure
    that tests don’t depend on data already in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Running Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the test database is set up, you’re ready to run your tests. Rails
    provides several different rake tasks for running the various types of tests you’ll
    create.
  prefs: []
  type: TYPE_NORMAL
- en: The `bin/rake test` command runs all tests by default. If you include the name
    of a test file on the command line, it only runs the tests in that file. While
    working on a particular model or controller, running the tests associated with
    that class is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command runs all of the tests in the file *test/models/user_test.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After a short pause, you should see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As the last line indicates, no tests have been defined yet. Open *test/models/user_test.rb*
    in your editor and let’s add some tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This test file first requires the file *test/test_helper.rb* ➊, which holds
    the configuration for all tests. The test helper also loads all *fixtures*, or
    sample data, and can include helper methods for tests. Next, the test file defines
    a *test case* named `UserTest` by inheriting from `ActiveSupport::TestCase` ➋.
    A test case is a set of tests related to a class. Inside the test case, a simple
    example test ➌ is provided in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commented-out test doesn’t really test anything even if you uncomment it,
    so you could remove it. But these lines do show the basic structure of all tests,
    so let’s examine them before moving forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `test` method ➊ accepts a test name and a block of code to execute. This
    block contains one or more assertions ➋. An *assertion* tests a line of code for
    an expected result. The `assert` method shown here expects its argument to evaluate
    to a true value. If the assertion is true, the test passes and a single dot is
    printed. Otherwise, the test fails and an *F* is printed along with a message
    identifying the failing test.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s follow this basic test structure to add a real test to this file.
    I find it helpful to open the model I’m testing, in this case, *app/models/user.rb*,
    and the test file at the same time. I usually add tests for any custom methods
    I’ve added to a model and verify that the model’s validations are working as expected.
    Looking at the `user` model, you see several `has_many` associations, followed
    by the Rails `has_secure_password` method, a validation, and the methods you’ve
    written.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s make sure you can create a valid user. Remember, the `has_secure_password`
    method adds validations for attributes named `password` and `password_confirmation`.
    Users are also required to have a unique email address, so to create a valid user,
    you must provide `email`, `password`, and `password_confirmation`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, you instantiate a new `User` object with valid attributes ➊ and assert
    that it saves ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests in this file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The single dot ➊ represents the single test. The last line of output ➋ tells
    you that you ran one test with one assertion and had zero failures.
  prefs: []
  type: TYPE_NORMAL
- en: You could continue adding tests at this point, but manually creating users for
    all of your tests will get tedious. Luckily, Rails includes the fixtures I mentioned
    earlier, which can automatically create as many model objects with sample data
    as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Fixtures* provide sample data for tests, and they are written in a format
    called *YAML*. YAML originally stood for *Yet Another Markup Language*, but is
    now a recursive acronym for *YAML Ain’t Markup Language*. Fixtures are automatically
    loaded into the `test` database by the file *tests/test_helper.rb* and are available
    to all test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: User Fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the file *test/fixtures/users.yml*, remove its contents, and create two
    sample users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code adds sample data for two users. The YAML file begins with the name
    of the first fixture followed by a colon ➊. In this case, the fixture is named
    `user1`. The indented lines under the name specify attributes. The first user
    has an email address of `user1@example.com` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: You can even use ERB to help add data to fixtures. Rather than precompute the
    values for the `password_digest` field, use the `BCrypt::Password.create` method
    to create the `password_digest` ➌ dynamically. This method is part of the bcrypt
    gem you installed in [Chapter 9](ch09.html "Chapter 9. Authentication").
  prefs: []
  type: TYPE_NORMAL
- en: Refer to one of these users in your tests by calling the `users` method and
    passing the name of the user you want. For example, `users(:user1)` returns the
    first user just defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the user tests in *test/models/user_test.rb* and let’s try the new
    fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This test uses a fixture to initialize a user ➊, sets the user’s `email` to
    `nil` ➋, and ensures the user is not valid with the `assert_not` method ➌. The
    `assert_not` method only passes if its condition is a false value.
  prefs: []
  type: TYPE_NORMAL
- en: This test proves that an email is required; now you’ll add a test for email
    uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This test uses fixtures to initialize two users ➊, sets the first user’s `email`
    equal to the second user’s `email` ➋, and asserts ➌ that the first user is no
    longer valid. The second user is still valid because the first user can’t be saved
    with invalid data. You can look at the test log in *log/test.log* to see the queries
    being run for each test.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures have `id` values based on a hash of the fixture name, and those values
    are always the same. For example, the `id` for `@user1` is 206669143\. This value
    never changes. Associations between fixtures are created by name because the `id`
    of each fixture is based on its name. The `Post` fixtures discussed next include
    associations with the `User` fixtures you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Post Fixtures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rails automatically created fixture files for the `TextPost` and `ImagePost`
    types. You’ll include both types of fixtures in the `Post` file. The fixture files
    for the other types will cause an error, so delete the files *test/fixtures/text_posts.yml*
    and *test/fixtures/image_posts.yml* before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the file *test/fixtures/posts.yml* and create some sample posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have three posts. The first two belong to the `User` named *user1*
    and the third belongs to *user2*. You’ll put these to good use a little later
    when you add tests for the `Post` model.
  prefs: []
  type: TYPE_NORMAL
- en: Putting Assertions to Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assertions are the building blocks of tests. You’ve already seen a few assertions,
    such as `assert` and `assert_not`, in the tests you’ve written so far. The MiniTest
    library contains more, and Rails adds a few of its own. Here are some of the most
    commonly used assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert` *`test`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the `test` expression evaluates to true
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_empty` *`obj`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `obj.empty?` is true
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_equal` *`expected, actual`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the `expected` value equals the `actual` value
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_includes` *`collection, obj`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `collection.includes?(obj)` returns true
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_instance_of` *`class, obj`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `obj.instance_of?(class)` is true
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_match` *`regexp, string`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the given `string` matches the regular expression `regexp`
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_nil` *obj***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if `obj.nil?` is true
  prefs: []
  type: TYPE_NORMAL
- en: Each of these assertions also comes in a “not” form. For example, `assert_not`
    passes if the expression being tested is false and `assert_not_equal` passes if
    the expected value is not equal to the actual value. Assertions also accept an
    optional message parameter, which is a string that prints if the assertion fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put our knowledge of assertions to work and add a few more tests to the
    `user` model. Here’s the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This test creates two users using fixtures ➊ and then calls the `follow!` method
    on `@user1` with `@user2` as an argument ➋. It then ensures that `@user1` has
    one leader and `@user2` has one follower ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'This next test verifies the `following?` method works correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It again uses fixtures to create two users and then calls the `follow!` method
    on `@user1` with `@user2` as an argument and finally ensures that `@user1.following?(@user2)`
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating Duplication with Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tests you’ve made should all work correctly, but I’ve introduced some duplication
    in the code. Almost every test uses fixtures to create users. Remember, don’t
    repeat yourself. Luckily, test cases include two callbacks that can help eliminate
    this duplication. *Callbacks* are methods that are called automatically before
    and after each test.
  prefs: []
  type: TYPE_NORMAL
- en: The `setup` method is called before each test, and the `teardown` method is
    called after each test. These methods are commonly used to initialize objects
    that are employed in multiple tests. You can use the `setup` method to initialize
    the values of `@user1` and `@user2` automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that `@user1` and `@user2` are being initialized ➊ in the setup method,
    you can remove the duplication from each of the tests, as shown in the rewritten
    test for `following?` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Model Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests you’ve seen so far are model tests. *Model tests* verify the behavior
    of your application’s models. These types of tests were previously called *unit
    tests*. I typically add tests for validations and for any custom methods I’ve
    written.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve covered both of these for the `User` model, so now let’s add tests for
    the `Post` model. You may also want to refer to the `Post` model in *app/models/post.rb*
    as you write tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Post` model is still pretty simple. A post belongs to a user and can have
    many comments. It also validates the presence of a `user_id` and a `type`. Let’s
    add a test to verify that a `Post` has a `user_id`. Open the file *test/models/post_test.rb*
    in your editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `setup` method ➊ initializes two posts that you can refer to in your tests.
    The first test ➋ verifies that a `Post` without a `user_id` is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have model tests for the users and posts now, you can use the `bin/rake
    test:models` command to run all model tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If this command results in an error, delete the unused fixture files for the
    `TextPost` and `ImagePost` models as mentioned earlier. Delete *test/fixtures/text_posts.yml*
    and *test/fixtures/image_posts.yml*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other post types have validations of their own. For example, the `TextPost`
    validates the presence of a `body`, and the `ImagePost` validates the presence
    of a `url`. Since we already have `TextPost` and `ImagePost` fixtures, let’s add
    tests for both of those validations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both of these tests follow the same pattern. First, verify that `@post1` is
    an instance of `TextPost` ➊. Next, set the `body` of `@post1` to `nil` ➋. Finally,
    verify that `@post1` is no longer valid ➌. The `ImagePost` assertions do the same,
    but for `@post2`.
  prefs: []
  type: TYPE_NORMAL
- en: Controller Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Controller tests* verify the actions of a single controller by simulating
    requests to your application and validating the responses. Controller tests ensure
    that a controller action responds successfully to valid requests, and that it
    renders the correct view or redirects to the correct location. These types of
    tests were previously called *functional tests*.'
  prefs: []
  type: TYPE_NORMAL
- en: Controller Test Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rails includes several helper methods and variables that make controller tests
    easier to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods `get`, `post`, `put`, `patch`, `head`, and `delete` simulate a
    request to a controller action. These methods can take two optional hashes: one
    representing request parameters and another representing the current session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a request has been made with one of those six methods, the following
    four hashes become available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **`assigns`** | Contains the instance variables assigned in the controller
    action |'
  prefs: []
  type: TYPE_TB
- en: '| **`cookies`** | Contains any cookie values set in the action |'
  prefs: []
  type: TYPE_TB
- en: '| **`flash`** | Holds the flash values set in the action |'
  prefs: []
  type: TYPE_TB
- en: '| **`session`** | Contains any session values set by the action |'
  prefs: []
  type: TYPE_TB
- en: 'Your tests also have access to three instance variables: `@controller` contains
    the controller processing the request; `@request` is the request being processed;
    and `@response` is the controller’s response to the request.'
  prefs: []
  type: TYPE_NORMAL
- en: Controller Test Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rails adds several assertions specifically for controller tests in addition
    to those you’ve already seen. Controller actions always either render a response
    or redirect to a different URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_response` *`type`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the HTTP response matches a specific status code. Use a status code
    or one of the symbols `:success`, `:redirect`, `:missing`, or `:error` for `type`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_redirected_to` *`options`***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the request causes a redirect to the path given in `options`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`assert_template` *expected***'
  prefs: []
  type: TYPE_NORMAL
- en: Passes if the request renders the `expected` template.
  prefs: []
  type: TYPE_NORMAL
- en: These assertions verify that a controller action correctly responds to a request.
    For a simple GET request, `assert_response :success` might be the only test needed.
    If the controller action assigns an instance variable, you should also verify
    that assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add controller tests for the `new` and `create` actions in `UsersController`.
    First, test that the `new` action successfully renders the sign-up form with a
    newly created instance of the `User` model. Open the file *test/controllers/users_controller_test.rb*
    to add the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This test issues a GET request for the new user page ➊, gets a copy of the value
    assigned to the instance variable `@user` ➋ in the controller, and verifies that
    `user` is a new record ➌ and the response was successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test checks the ability to create new users given valid data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This test is a bit more complex because the `create` action expects a hash of
    values for the new user ➊. This test issues a POST request to the `create` action
    using the `params` hash ➋ and then verifies that the action redirects to the `root_url`
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The previous test checks what happens when a `User` is successfully saved. You
    should test the other path through the controller action, that is, when the `User`
    can’t be saved. You could add a test that attempts to create a user with invalid
    attributes and verifies the new user template is rendered again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the new controller tests with the `bin/rake test:controllers` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `UsersController` tests should pass successfully, so let’s move on to the
    `PostsController`. Verify that the `before_action` method `authenticate_user!`
    is working correctly so your application won’t show posts to unauthenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *test/controllers/posts_controller_test.rb* in your editor and
    add the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first test attempts to GET the post `index` page ➊ and verifies the action
    redirects to the login page ➋. The second test initializes a user using a fixture
    ➌ then issues the GET request for the `index` page with a `user_id` in the session
    ➍. Simulating a logged-in user by including a valid `user_id` in the session should
    result in a successful response.
  prefs: []
  type: TYPE_NORMAL
- en: Integration Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Integration tests* verify the interaction between several different controllers.
    These are commonly used to test the *flow* between several pages of your application.
    An example of a flow would be logging in to the application, viewing a page, and
    then performing some other action. Each of these actions could be covered by controller
    tests. An integration test ensures that they all work together.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because integration tests generally involve moving between pages in the application,
    your tests need not only to make requests to actions but also to follow any redirects.
    The helper methods `redirect?` and `follow_redirect!` check to see if the last
    request resulted in a redirect and follow a redirect response, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that a request results in a redirect, more specific methods are
    available. You can use `get_via_redirect`, `post_via_redirect`, `put_via_redirect`,
    `patch_via_redirect`, or `delete_via_redirect` to make the appropriate request
    and also follow the redirect.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rails doesn’t create integration tests automatically like model and controller
    tests because Rails has no way of knowing which flows you want to test. Although
    they are not created automatically, Rails does include a generator you can use
    to create integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add an integration test to verify that a user can log in to the application,
    see the home page, and then log out. First, use the `bin/rails generate` command
    to create a new integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new file named *test/integration/user_flow_test.rb*.
    Open that file in your editor and let’s add a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This test looks like an extended controller test. The test requests a page with
    `get` ➊ and then verifies a successful response. You know that a user logs in
    to the application with a POST request to the sessions path and is then redirected
    to the home page, so you use the `post_via_redirect` method to submit the user’s
    email address and password and then follow the redirect automatically ➋. Finally,
    the test issues a GET request for the logout page ➌ and is redirected back to
    the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to run the integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This test confirms that a user can log in to the application, view the home
    page, and then log out successfully.
  prefs: []
  type: TYPE_NORMAL
- en: This path is basically the only one a user can take through the application
    at this time. As you add more actions to the application, you can create integration
    tests to verify that other flows work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Features with Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tests written so far have all verified existing functionality, but some
    Rails developers use tests to define features before implementing them, a practice
    called *test-driven development (TDD)*. In TDD, you write a test first and then
    add code to make the test pass. Once the test passes, you can refactor the code
    if necessary. If you follow TDD, you won’t have to worry about parsing your code
    later to figure out what functionality to verify.
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is usually a three-step process known as red-green-refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a failing test (red).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write code to make the test pass (green).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor as needed (refactor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following this process, you can be confident that new functionality meets
    the requirements specified in the test and that it did not introduce any regressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use TDD to add features to our social application. Although many features
    are still missing, let’s focus on these:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a user `show` page showing a user’s posts and a Follow button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give users the ability to create new posts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of these features, you’ll first write a failing test and then write
    code to make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: Show User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user `show` page displays the user’s name and posts. It should also include
    a button to allow other users to follow this user. To add the user `show` page,
    you need to add a `show` method to the user controller and create a corresponding
    view. You know the controller should assign an instance variable named `@user`
    for the view to use and respond with success, so let’s add a test for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *test/controllers/users_controller_test.rb* and add this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the test and make sure it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this test should result in an error. The action `show` could not be
    found for `UsersController` because you haven’t created it yet. So let’s add the
    `show` action to *app/controllers/users_controller.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the tests again. This time you should see a different
    error. The template is missing. Create a new file named *app/views/users/show.html.erb*,
    and add that template now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Save this file and run the tests again. All tests should now pass, but you still
    have one problem. This page shows the user’s email address and the user’s posts,
    but no one can follow the user!
  prefs: []
  type: TYPE_NORMAL
- en: Following a user creates a record in the subscriptions table in the database.
    Because this has to happen on the server, adding the Follow button requires a
    controller action and a new route to that action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another controller test to *test/controllers/users_controller_test.rb*
    to describe this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This test first creates two users using fixtures ➊. Next, it issues a GET request
    for the `follow` action with the second user’s `id` as a parameter and the first
    user’s `id` in the session ➋. This simulates `user1` following `user2`. Finally,
    it verifies that `user1` is now following `user2` and that the request redirects
    back to the `show` page for `user2` ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the file *app/controllers/users_controller.rb*, and add the `follow`
    action after the other actions, but before the `private` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This method finds the correct user using the id parameter ➊, calls the follow!
    method on current_user ➋, and then redirects to @user ➌.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open *config/routes.rb* and add a route to the new `follow` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'I added this under the `signup` route because these actions are both in the
    user controller. Now, back in *app/views/users/show.html.erb,* you can add the
    Follow button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The Follow button is similar to the Home button; it’s actually a link with Bootstrap’s
    `btn` and `btn-default` styles applied to make it look like a button.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the controller tests again and verify that they all pass. You
    can also start the Rails server if it isn’t already running and go to *http://localhost:3000/users/1*
    in your web browser to see the `show` page for the first user, as shown in [Figure 10-1](ch10.html#user_show_page
    "Figure 10-1. The user show page").
  prefs: []
  type: TYPE_NORMAL
- en: '![The user show page](httpatomoreillycomsourcenostarchimages2169098.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1. The user show page
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-1](ch10.html#user_show_page "Figure 10-1. The user show page") is
    the `show` page with the user’s name, a button for following this user, and the
    user’s posts.'
  prefs: []
  type: TYPE_NORMAL
- en: Create Post
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s give users the ability to add posts. Adding posts requires two controller
    actions: `new` and `create`. The `new` action also requires a matching view. The
    `create` action should redirect to the newly created post, so a view isn’t needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application has two different types of posts. Start by adding the ability
    to create posts of type `TextPost`. The `new` action in `TextPostsController`
    should instantiate a new `TextPost` object and render a form for that object.
    Add a failing test to *test/controllers/text_posts_controller_test.rb* and then
    get to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The test first creates a new user using a fixture ➊ and then issues a GET request
    for the `new` action with `user_id` set in the session ➋. This step is necessary
    because the `TextPostsController` requires an authenticated user. The test then
    gets the `text_post` instance variable, verifies it’s a new record, and verifies
    a successful response. Run the tests and watch this one fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message should indicate that the `new` action is missing from `TextPostsController`.
    Open *app/controllers/text_posts_controller.rb*, and add the new action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You almost have enough to get the test to pass. The last step is to add the
    corresponding view. Create the file *app/views/text_posts/new.html.erb*, and add
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This view is a page header followed by a `render` command for the form partial.
    Let’s add the partial now. First, create the file *app/views/text_posts/_form.html.erb*,
    and add this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This partial creates a form for the new `TextPost` assigned to `@text_post`
    ➊. The form includes a text field for the post title ➋, a text area for the post
    body ➌, and buttons to submit the form or cancel and go back ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you’re editing views, add a button for creating a new text post on the
    home page. Open *app/views/posts/index.html.erb,* and then add this link under
    the page header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to run the `TextPostController` tests successfully.
    Now add another controller test to describe creating a `TextPost` to *test/controllers/text_posts_controller_test.rb*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous controller test for the `TextPostsController`, this test
    first initializes a new user ➊ from a fixture. Next, it sets up the necessary
    parameters ➋ for a new `TextPost`, and then issues a POST request ➌ to the `create`
    action with the `params` hash and the `user.id` in the session. Finally, it ensures
    ➍ the new text post was persisted to the database and that the request redirects
    to the new post’s URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to making this test pass is to add a `create` action to the
    `TextPostsController`. Open the file *app/controllers/text_posts_controller.rb*,
    and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `create` method builds a new text post ➊ for the current user using the
    `params` from the form. If it is able to save this new post, it redirects the
    user ➋ to the newly created post. Otherwise, it renders the new text post form
    ➌ again with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the `text_post_params` method for Rails strong `params.` This
    method is called in the `create` action to get the permitted parameters for the
    new `TextPost`. Add this private method near the bottom of the `TextPostsController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method ensures ➊ that the `params` hash contains the `:text_post` key and
    permits key-value pairs for `:title` and `:body` under the `:text_post` key. With
    this change, all of your tests should pass again. Click the **New Text Post**
    button on the home page, as shown in [Figure 10-2](ch10.html#new_text_post_form
    "Figure 10-2. The New Text Post form"), to see the form for creating a `TextPost`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The New Text Post form](httpatomoreillycomsourcenostarchimages2169100.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2. The New Text Post form
  prefs: []
  type: TYPE_NORMAL
- en: The process for creating a new `ImagePost` is similar. Exercise 3 at the end
    of this chapter walks through the necessary steps.
  prefs: []
  type: TYPE_NORMAL
- en: These new features bring our application much closer to being a fully functioning
    social network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter. You learned about the MiniTest framework.
    You wrote model, controller, and integration tests. We discussed test-driven development
    and then you used it to add features to your social network.
  prefs: []
  type: TYPE_NORMAL
- en: You can write the tests either before or after the code, and you can use any
    test framework—what matters is that you write tests. The ability to type a single
    command and verify your application is working correctly is worth the small investment
    of your time. Over the life of an application, the benefits of a comprehensive
    set of tests for your application are immeasurable.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q: | 1\. You currently cannot get to the user `show` page without typing
    in the URL. Update the `TextPost` and `ImagePost` partials so the user’s `name`
    is a link to the user’s `show` page. Also, add a link called *Profile* that links
    to the current user’s `show` page next to the *Log Out* link near the top of the
    application layout. |'
  prefs: []
  type: TYPE_TB
- en: '| Q: | 2\. The `follow` action should not be available to anonymous users.
    Add a call in `UsersController` to `before_action :authenticate_user!` with the
    `only` option to require authentication before the `follow` action. The following
    test should pass after you update `UsersController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Also, the Follow button on the user `show` page should not appear for anonymous
    users or if the current user is already following the user being displayed. Update
    the `show` view to fix this. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Q: | 3\. Add `new` and `create` actions for image posts and the private `image_post_params`
    method used by the `create` action in *app/controllers/image_posts_controller.rb*.
    Then create a view for the new action at *app/views/image_posts/new.html.erb*
    and a partial for the `ImagePost` form at *app/views/image_posts/_form.html.erb*.
    |'
  prefs: []
  type: TYPE_TB
- en: Add the following controller tests to *test/controllers/image_posts_controller_test.rb*.
    Both tests should pass after you add the actions to `ImagePostsController` and
    create the associated views.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Your implementation of these actions and views should be similar to the TextPost
    new and create actions and views. If you would like to practice TDD, feel free
    to add these tests and confirm they fail before you start implementing the actions.
  prefs: []
  type: TYPE_NORMAL
