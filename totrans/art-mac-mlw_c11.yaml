- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: EvilQuest’s Persistence and Core Functionality Analysis
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: EvilQuest的持久性和核心功能分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that we’ve triaged the EvilQuest specimen and thwarted its anti-analysis
    logic, we can continue our analysis. In this chapter we’ll detail the malware’s
    methods of persistence, which ensure it is automatically restarted each time an
    infected system is rebooted. Then we’ll dive into the myriad of capabilities supported
    by this insidious threat.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了EvilQuest样本，并且成功破解了其反分析逻辑，我们可以继续进行分析。在本章中，我们将详细介绍该恶意软件的持久性方法，确保每次感染的系统重启时它都能自动重启。然后，我们将深入探讨这一隐秘威胁所支持的各种功能。
- en: Persistence
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性
- en: 'In Chapter 10 you saw that the malware invokes what is likely a persistence-related
    function named `ei_persistence_main`. Let’s take a closer look at this function,
    which can be found at `0x000000010000b880`. [Listing 11-1](#listing11-1) is a
    simplified decompilation of the function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，您看到恶意软件调用了一个可能与持久性相关的函数，名为`ei_persistence_main`。让我们更仔细地看一下这个函数，它位于`0x000000010000b880`。
    [列表11-1](#listing11-1)是该函数的简化反编译版：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 11-1: `ei_persistence_main`, decompiled'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-1：`ei_persistence_main`，反编译版
- en: As you can see, before it persists, the malware invokes the `is_debugging` and
    `prevent_trace` functions, which seek to prevent dynamic analysis via a debugger.
    We discussed how to thwart these functions in the previous chapter. As they are
    easy to bypass, they don’t present any real obstacle to our continued analysis.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在保持持久性之前，恶意软件调用了`is_debugging`和`prevent_trace`函数，这些函数旨在防止通过调试器进行动态分析。我们在上一章中讨论了如何破解这些函数。由于这些函数容易绕过，因此它们并不会对我们的后续分析构成任何实际障碍。
- en: Next, the malware invokes several functions to kill any processes connected
    to antivirus or analysis software and then to persist as both a launch agent and
    launch daemon. Let’s dive into the mechanisms of each of these functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，恶意软件调用多个函数，杀死与杀毒软件或分析软件相关的进程，然后作为启动代理和启动守护进程保持持久性。让我们深入了解这些函数的机制。
- en: Killing Unwanted Processes
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杀死不需要的进程
- en: 'After the anti-debugging logic, the malware invokes a function named `kill_unwanted`.
    This function first enumerates all running processes via a call to one of the
    malware’s helper functions: `get_process_list` (`0x0000000100007c40`). If we decompile
    this function, we can determine that it makes use of Apple’s `sysctl` API to retrieve
    a list of running processes ([Listing 11-2](#listing11-2)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在反调试逻辑之后，恶意软件调用了一个名为`kill_unwanted`的函数。该函数首先通过调用恶意软件的一个辅助函数`get_process_list`（`0x0000000100007c40`）列举所有正在运行的进程。如果我们反编译这个函数，就可以确定它使用了苹果的`sysctl`
    API来检索正在运行的进程列表（[列表11-2](#listing11-2)）：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 11-2: Process enumeration via the `sysctl` API'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-2：通过`sysctl` API列举进程
- en: Notice that an array of three items is found at `0x00000001000104d0` 1. As this
    array is passed to the `sysctl` API, this gives us context to map the constants
    to `CTL_KERN` (`0x1`), `KERN_PROC` (`0xe`), and `KERN_PROC_ALL` (`0x0`). Also
    notice that when passed to the first invocation of the `sysctl` API 2, the `size`
    variable will be initialized with the space to store a list of all processes (as
    the buffer parameter is `0x0`, or null). The code allocates a buffer for this
    list and then re-invokes `sysctl` 3 along with this newly allocated buffer to
    retrieve the list of all processes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`0x00000001000104d0` 1处发现了一个包含三项的数组。当这个数组传递给`sysctl` API时，这为我们提供了上下文，能够将常量映射到`CTL_KERN`（`0x1`）、`KERN_PROC`（`0xe`）和`KERN_PROC_ALL`（`0x0`）。还要注意，当第一次调用`sysctl`
    API 2时，`size`变量将被初始化为存储所有进程列表的空间（因为缓冲区参数为`0x0`，即null）。代码为这个列表分配了一个缓冲区，然后再次调用`sysctl`
    3，并传递这个新分配的缓冲区来获取所有进程的列表。
- en: 'Once EvilQuest has obtained a list of running processes, it enumerates over
    this list to compare each process with an encrypted list of programs that are
    hardcoded within the malware and stored in a global variable named `EI_UNWANTED`.
    Thanks to our injectable decryptor library, we can recover the decrypted list
    of programs, as shown in [Listing 11-3](#listing11-3):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦EvilQuest获得了正在运行的进程列表，它会遍历这个列表，将每个进程与硬编码在恶意软件中的加密程序列表进行比较，并存储在名为`EI_UNWANTED`的全局变量中。借助我们可注入的解密器库，我们可以恢复解密后的程序列表，如[列表11-3](#listing11-3)所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 11-3: EvilQuest’s “unwanted” programs'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11-3：EvilQuest的“不需要的”程序
- en: As you can see, this is a list of common security and antivirus products (albeit
    some, such as “Mcaffee,” are misspelled) that may inhibit or detect the malware’s
    actions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一份常见的安全和杀毒软件的列表（尽管其中有些，比如“Mcaffee”，拼写错误），这些软件可能会抑制或检测恶意软件的行为。
- en: What does EvilQuest do if it finds a process that matches an item on the `EI_UNWANTED`
    list? It terminates the process and removes its executable bit ([Listing 11-4](#listing11-4)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果EvilQuest找到一个与`EI_UNWANTED`列表中的项匹配的进程，它会终止该进程并移除其可执行位（[列表 11-4](#listing11-4)）。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 11-4: Unwanted process termination'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-4：被终止的进程
- en: If a running process matches an unwanted item, the malware first invokes the
    `kill` system call with a `SIGKILL` (`0x9`) 1. Then, to prevent the unwanted process
    from being executed in the future, it manually removes its executable bit with
    `chmod` 2. (The value of `0x29a`, `666` decimal, passed to `chmod` instructs it
    to remove the executable bit for the owner, the group, and other permissions).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在运行的进程匹配不需要的项，恶意软件首先会调用`kill`系统调用，发送`SIGKILL`（`0x9`）信号。然后，为了防止未来不需要的进程被执行，它会使用`chmod`手动移除该进程的可执行位。传递给`chmod`的值`0x29a`（十进制为`666`）指示它移除所有者、组和其他权限的可执行位。
- en: 'We can observe this in action in a debugger by launching the malware (which,
    recall, was copied to */Library/mixednkey/toolroomd*) and setting a breakpoint
    on the call to `kill`, which we find in the disassembly at `0x100008319`. If we
    then create a process that matches any of the items on the unwanted list, such
    as “Kaspersky,” our breakpoint will be hit, as shown in [Listing 11-5](#listing11-5):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在调试器中观察到这一过程，通过启动恶意软件（回想一下，它已被复制到*/Library/mixednkey/toolroomd*）并在调用`kill`时设置断点，`kill`在反汇编中位于`0x100008319`。如果我们随后创建一个与不想要的列表中的任何项匹配的进程，如“Kaspersky”，断点将会被触发，如[列表
    11-5](#listing11-5)所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 11-5: Unwanted process termination, observed in a debugger'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-5：在调试器中观察到的被终止的进程
- en: 'Dumping the arguments passed to `kill` reveals EvilQuest indeed sending a `SIGKILL`
    (`0x9`) 2 to our test process named “Kaspersky” (process ID: `0x5B1` 1).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 转储传递给`kill`的参数显示，EvilQuest确实向我们的测试进程“Kaspersky”（进程ID：`0x5B1`）发送了`SIGKILL`（`0x9`）信号。
- en: Making Copies of Itself
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制自身
- en: 'Once the malware has killed any programs it deems unwanted, it invokes a function
    named `persist_executable` to create a copy of itself in the user’s *Library/*
    directory as *AppQuest/com.apple.questd*. We can observe this passively using
    FileMonitor ([Listing 11-6](#listing11-6)):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件终止了它认为不需要的程序，它会调用名为`persist_executable`的函数，将自身复制到用户的*Library/*目录下，路径为*AppQuest/com.apple.questd*。我们可以通过使用FileMonitor被动地观察到这一过程（[列表
    11-6](#listing11-6)所示）：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 11-6: The start of the malware’s copy operation, seen in FileMonitor'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-6：在FileMonitor中看到的恶意软件复制操作的开始
- en: If the malware is running as root (which is likely the case, as the installer
    requested elevated permissions), it will also copy itself to */Library/AppQuest/com.apple.questd.
    Hashing both files confirms they are indeed exact copies of the malware ([Listing
    11-7](#listing11-7)):*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件以root身份运行（因为安装程序请求了提升权限，这很可能发生），它还会将自身复制到*/Library/AppQuest/com.apple.questd。对这两个文件进行哈希验证确认它们确实是恶意软件的精确副本（[列表
    11-7](#listing11-7)所示）：*
- en: '*[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE6]'
- en: 'Listing 11-7: Hashes confirm the copies are identical'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-7：哈希值确认副本是相同的
- en: Persisting the Copies as Launch Items
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将副本持久化为启动项
- en: 'Once the malware has copied itself, it persists these copies as launch items.
    The function responsible for this logic is named `install_daemon` (found at `0x0000000100009130`),
    and it is invoked twice: once to create a launch agent and once to create a launch
    daemon. The latter requires root privileges.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件复制完成，它会将这些副本作为启动项持久化。负责这一逻辑的函数名为`install_daemon`（位于`0x0000000100009130`），并且它会被调用两次：第一次创建启动代理，第二次创建启动守护进程。后者需要root权限。
- en: 'To see this in action, let’s dump the arguments passed to `install_daemon`
    the first time it’s called, as shown in [Listing 11-8](#listing11-8):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察这一过程，让我们转储第一次调用`install_daemon`时传递的参数，如[列表 11-8](#listing11-8)所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 11-8: Parameters passed to the `install_daemon` function'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-8：传递给`install_daemon`函数的参数
- en: Using these arguments, the function builds a full path to the malware’s persistent
    binary (*com.apple.questd*), as well as to the user’s launch agent directory.
    To the latter, it then appends a string that decrypts to *com.apple.questd.plist*.
    As you’ll see shortly, this is used to persist the malware.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些参数，函数构建了恶意软件持久二进制文件（*com.apple.questd*）的完整路径，以及用户的启动代理目录路径。然后，它会向后者附加一个解密为*com.apple.questd.plist*的字符串。正如你即将看到的，这个文件用于保持恶意软件的持久性。
- en: 'Next, if we continue the debugging session, we’ll observe a call to the malware’s
    string decryption function, `ei_str`. Once this function returns, we find a decrypted
    template of a launch item property list in the `RAX` register ([Listing 11-9](#listing11-9)):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们继续调试会话，我们将看到一个调用恶意软件字符串解密函数`ei_str`的过程。该函数返回后，我们在`RAX`寄存器中找到了一个解密后的启动项属性列表模板（见[清单
    11-9](#listing11-9)）：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 11-9: A (decrypted) launch item property list template'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-9：一个（已解密的）启动项属性列表模板
- en: 'After the malware has decrypted the plist template, it configures it with the
    name “questd” and the full path to its recent copy, */Users/user/Library/AppQuest/com.apple.questd.*
    Now fully configured, the malware writes out the plist using the launch agent
    path it just created, as seen in [Listing 11-10](#listing11-10):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意软件解密了plist模板后，它将其配置为名称“questd”并填入其最近副本的完整路径，*／Users/user/Library/AppQuest/com.apple.questd*。配置完成后，恶意软件使用刚才创建的启动代理路径写出plist文件，如[清单
    11-10](#listing11-10)所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 11-10: The malware’s launch agent plist (*~**/Library/LaunchAgents/com.apple.questd.plist*)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-10：恶意软件的启动代理plist（*~**/Library/LaunchAgents/com.apple.questd.plist*）
- en: As the `RunAtLoad` key is set to `true` 1 in the plist, the operating system
    will automatically restart the specified binary each time the user logs in.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RunAtLoad`键在plist中设置为`true` 1，操作系统将在用户每次登录时自动重新启动指定的二进制文件。
- en: 'The second time the `install_daemon` function is invoked, the function follows
    a similar process. This time, however, it creates a launch daemon instead of a
    launch agent at */Library/LaunchDaemons/com.apple.questd.plist*, and it references
    the second copy of the malware created in the *Library/* directory ([Listing 11-11](#listing11-11)):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用`install_daemon`函数时，函数执行了类似的过程。不过这次，它在*/Library/LaunchDaemons/com.apple.questd.plist*创建了一个启动守护进程，而不是启动代理，并引用了在*Library/*目录下创建的第二个恶意软件副本（见[清单
    11-11](#listing11-11)）：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 11-11: The malware’s launch daemon plist (*/Library/LaunchDaemons/com.apple.questd.plist*)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-11：恶意软件的启动守护进程plist（*/Library/LaunchDaemons/com.apple.questd.plist*）
- en: 'Once again, the `RunAtLoad` key is set to `true` 2, so the system will automatically
    launch the daemon’s binary every time the system is rebooted. (Note that as launch
    daemons always run with root privileges, the inclusion of `sudo` is spurious 1.)
    This will mean that on reboot, two instances of the malware will be running: one
    as a launch daemon and the other as a launch agent ([Listing 11-12](#listing11-12)):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`RunAtLoad`键被设置为`true` 2，因此系统每次重启时都会自动启动守护进程的二进制文件。（请注意，由于启动守护进程始终以root权限运行，`sudo`的加入是多余的1。）这意味着在重启后，恶意软件将以两种方式运行：一种是作为启动守护进程，另一种是作为启动代理（见[清单
    11-12](#listing11-12)）：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 11-12: The malware, running as both a launch daemon and an agent'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-12：恶意软件，作为启动守护进程和代理同时运行
- en: Starting the Launch Items
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动启动项
- en: 'Once the malware has ensured that it has persisted twice, it invokes the `ei_selfretain_main`
    function to start the launch items. Perusing the function’s disassembly, we note
    two calls to a function named `run_daemon` ([Listing 11-13](#listing11-13)):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件确保了其持久性已建立两次，它会调用`ei_selfretain_main`函数来启动启动项。在检查该函数的反汇编代码时，我们注意到有两次调用名为`run_daemon`的函数（见[清单
    11-13](#listing11-13)）：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 11-13: The `run_daemon` function, invoked twice'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-13：`run_daemon`函数被调用两次
- en: 'Further analysis reveals that this function takes a path component and the
    name of the launch item to start. For example, the first call (at `0x000000010000b7a6`)
    refers to the launch agent. We can confirm this in a debugger by printing out
    the first two arguments (found in `RDI` and `RSI`), as shown in [Listing 11-14](#listing11-14):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分析显示，这个函数接受一个路径组件和启动项的名称来启动。例如，第一次调用（位于`0x000000010000b7a6`）是针对启动代理的。我们可以通过在调试器中打印出前两个参数（分别位于`RDI`和`RSI`寄存器）来确认这一点，具体见[清单
    11-14](#listing11-14)：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 11-14: Arguments passed to the `run_daemon` function'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-14：传递给`run_daemon`函数的参数
- en: The next time the `run_daemon` function is invoked (at `0x000000010000b7c8`),
    it’s invoked with the path components and name to the launch daemon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下次调用`run_daemon`函数时（在`0x000000010000b7c8`），它会带着路径组件和启动守护进程的名称一起被调用。
- en: 'Examining the `run_daemon` function, we see it first invokes a helper function
    named `construct_plist_path` with the two path-related arguments (passed to `run_daemon`).
    As its name implies, the goal of the `construct_plist_path` function is to construct
    a full path to a specified launch item’s plist. [Listing 11-15](#listing11-15)
    is a snippet of its disassembly:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`run_daemon`函数，我们看到它首先调用了一个名为`construct_plist_path`的辅助函数，传入了两个与路径相关的参数（由`run_daemon`传入）。顾名思义，`construct_plist_path`函数的目标是构建一个指向指定启动项的plist的完整路径。[Listing
    11-15](#listing11-15)是它反汇编的一部分：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 11-15: Constructing the path for the launch item’s property list'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-15: 构建启动项属性列表的路径'
- en: The function’s core logic simply concatenates the two arguments together with
    the `sprintf_chk` function 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的核心逻辑就是通过`sprintf_chk`函数将两个参数拼接在一起1。
- en: 'Once `construct_plist_path` returns with a constructed path, the `run_daemon`
    function decrypts a lengthy string, which is a template for the command to load,
    and then starts the specified launch via `AppleScript`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`construct_plist_path`返回已构建的路径，`run_daemon`函数会解密一个长字符串，这个字符串是加载命令的模板，然后通过`AppleScript`启动指定的进程：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This templated command is then populated with the path to the launch item (returned
    from `construct_plist_path`), as well as the name of the launch item, “questd.”
    The full command is passed to the `system` API to be executed. We can observe
    this using a process monitor ([Listing 11-16](#listing11-16)):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板命令接着会被填充上由`construct_plist_path`返回的启动项路径，以及启动项的名称“questd”。完整的命令会被传递给`system`
    API执行。我们可以通过进程监视器观察到这一点（[Listing 11-16](#listing11-16)）：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 11-16: Observing the `AppleScript` launch of a launch item'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 11-16: 观察`AppleScript`启动启动项'
- en: As you can see, the call to the `run_daemon` function executes `osascript` 1
    along with the launch commands, path, and name of the launch item 2. You might
    have noticed that there is a subtle bug in the malware’s launch item loading code.
    Recall that to build the full path to the launch item to be started, the `construct_plist_path`
    function concatenates the two provided path components. For the launch agent,
    this path includes a `%s`, which should have been populated at runtime with the
    name of the current user. This never happens. As a result, the concatenation generates
    an invalid plist path, and the manual loading of the launch agent fails. As the
    path components to the launch daemon are absolute, no substitution is required,
    so the daemon is successfully launched. MacOS enumerates all installed launch
    item plists on reboot, so it will find and load both the launch daemon and the
    launch agent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`run_daemon`函数的调用执行了`osascript`1，并携带了启动命令、路径和启动项的名称2。你可能已经注意到，恶意软件在加载启动项时的代码中存在一个细微的bug。回想一下，为了构建要启动的启动项的完整路径，`construct_plist_path`函数会将提供的两个路径组件拼接在一起。对于启动代理而言，这个路径包含一个`%s`，这个`%s`应该在运行时用当前用户的名称填充。但这一过程从未发生。因此，拼接生成了一个无效的plist路径，手动加载启动代理失败。由于启动守护进程的路径组件是绝对路径，因此无需任何替换，守护进程成功启动。MacOS在重启时会枚举所有已安装的启动项plist，因此它会找到并加载启动守护进程和启动代理。
- en: The Repersistence Logic
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Repersistence 逻辑
- en: It’s common for malware to persist, but EvilQuest takes things a step further
    by repersisting itself if any of its persistent components are removed. This self-defense
    mechanism may thwart users or antivirus tools that attempt to disinfect a system
    upon which EvilQuest has taken root. We first came across this repersistence logic
    in Chapter 10, when we noted that the *patch* binary didn’t contain any “trailer”
    data and thus skipped the repersistence-related block of code. Let’s now take
    a look at how the malware achieves this self-defending repersistence logic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件常常会保持持久性，但EvilQuest通过一种自我保持机制进一步增强了这一点。如果它的任何持久性组件被删除，它会重新保持自身。这种自我防御机制可能会挫败那些试图清除EvilQuest根植系统的用户或杀毒工具。我们第一次遇到这个保持持久性逻辑是在第10章，当时我们注意到*patch*二进制文件没有包含任何“尾部”数据，因此跳过了与保持持久性相关的代码块。现在，让我们看看恶意软件是如何实现这种自我防御的保持持久性逻辑的。
- en: 'You’ll locate the start of this logic within the malware’s main function, at
    `0x000000010000c24d`, where a new thread is created. The thread’s start routine
    is a function called `ei_pers_thread` (“persistence thread”) implemented at `0x0000000100009650`.
    Analyzing the disassembly of this function reveals that it creates an array of
    filepaths and then passes these to a function named `set_important_files`. Let’s
    place a breakpoint at the start of the `set_important_files` function to dump
    this array of filepaths ([Listing 11-17](#listing11-17)):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在恶意软件的主函数中找到这段逻辑的起始位置，地址为 `0x000000010000c24d`，在那里创建了一个新线程。该线程的起始例程是一个名为
    `ei_pers_thread`（“持久化线程”）的函数，位于 `0x0000000100009650`。分析该函数的反汇编代码会发现，它创建了一个文件路径数组，并将这些路径传递给一个名为
    `set_important_files` 的函数。我们可以在 `set_important_files` 函数的起始处设置一个断点，以便查看这个文件路径数组（[列表
    11-17](#listing11-17)）：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 11-17: “Important” files'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 11-17: “重要”文件'
- en: 'As you can see, these filepaths look like the malware’s persistent launch items
    and their corresponding binaries. Now what does the `set_important_files` function
    do with these files? First, it opens a kernel queue (via `kqueue`) and adds these
    files in order to instruct the system to monitor them. Apple’s documentation on
    kernel queues states that programs should then call `kevent` in a loop to monitor
    for events such as filesystem notifications.^([1](#c11-endnote-1)) EvilQuest follows
    this advice and indeed calls `kevent` in a loop. The system will now deliver a
    notification if, for example, one of the watched files is modified or deleted.
    Normally the code would then take some action, but it appears that in this version
    of the malware the `kqueue` logic is incomplete: the malware contains no logic
    to actually respond to such events.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些文件路径看起来像是恶意软件的持久化启动项及其对应的二进制文件。那么 `set_important_files` 函数是如何处理这些文件的呢？首先，它通过
    `kqueue` 打开一个内核队列，并将这些文件添加到队列中，以指示系统监视它们。Apple 关于内核队列的文档指出，程序应调用 `kevent` 函数并在循环中等待，以监控诸如文件系统通知之类的事件。^([1](#c11-endnote-1))
    EvilQuest 遵循了这一建议，确实在循环中调用了 `kevent`。现在，如果被监视的文件发生修改或删除等事件，系统将发出通知。通常代码会对这种事件做出反应，但在这个版本的恶意软件中，`kqueue`
    逻辑是不完整的：恶意软件没有包含对这些事件的实际响应逻辑。
- en: 'Despite this omission, EvilQuest will still repersist its components as needed
    because it invokes the original persistence function multiple times. We can manually
    delete one of the malware’s persistent components and use a file monitor to observe
    the malware restoring the file ([Listing 11-18](#listing11-18)):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有此遗漏，EvilQuest 仍然会根据需要持久化其组件，因为它多次调用了最初的持久化函数。我们可以手动删除恶意软件的一个持久化组件，并使用文件监视器观察恶意软件恢复该文件（[列表
    11-18](#listing11-18)）：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 11-18: Observing repersistence logic'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 11-18: 观察持久化逻辑'
- en: Once the malware has persisted and spawned off a thread to repersist if necessary,
    it begins executing its core capabilities. This includes viral infection, file
    exfiltration, remote tasking, and ransomware. Let’s take a look at these now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件成功持久化并在必要时生成了一个线程以进行再次持久化，它便开始执行其核心功能。这些功能包括病毒感染、文件外泄、远程任务和勒索软件。让我们现在来看看这些功能。
- en: The Local Viral Infection Logic
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地病毒感染逻辑
- en: 'In Peter Szor’s seminal book *The Art of Computer Virus Research and Defense*
    we find a succinct definition of a computer virus, attributed to Dr. Frederick
    Cohen:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Peter Szor 的经典著作《*计算机病毒研究与防御艺术*》中，我们找到了一个简明的计算机病毒定义，出处是 Dr. Frederick Cohen：
- en: A virus is a program that is able to infect other programs by modifying them
    to include a possibly evolved copy of itself.^([2](#c11-endnote-2))
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 病毒是一个能够通过修改其他程序，将自己可能演化后的副本植入其中，从而感染其他程序的程序。^([2](#c11-endnote-2))
- en: True viruses are quite rare on macOS. Most malware targeting the operating system
    is self-contained and doesn’t locally replicate once it has compromised a system.
    EvilQuest is an exception. In this section we’ll explore how it is able to virally
    spread to other programs, making attempts to eradicate it a rather involved endeavor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的病毒在 macOS 上非常罕见。大多数针对该操作系统的恶意软件是自包含的，并且一旦入侵系统后不会在本地复制。EvilQuest 是一个例外。在这一节中，我们将探讨它如何能够通过病毒式传播到其他程序，使得清除它的尝试变成一项相当复杂的工作。
- en: Listing Candidate Files for Infection
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表 感染候选文件
- en: 'EvilQuest begins its viral infection logic by invoking a function named `ei_loader_main`.
    [Listing 11-19](#listing11-19) shows a relevant snippet of this function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: EvilQuest 开始其病毒感染逻辑时调用了一个名为 `ei_loader_main` 的函数。[列表 11-19](#listing11-19) 显示了该函数的相关代码片段：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 11-19: Spawning a background thread'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 11-19: 创建后台线程'
- en: First, the `ei_loader_main` function decrypts a string 1. Using the decryption
    techniques discussed in Chapter 10, we can recover its plaintext value, `"/Users"`.
    The function then spawns a background thread with the start routine set to the
    `ei_loader_thread` function 2. The decrypted string is passed as an argument to
    this new thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at the `ei_loader_thread` function, whose annotated decompilation
    is shown in [Listing 11-20](#listing11-20):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 11-20: The `ei_loader_thread` function'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: First, it invokes a helper function named `get_targets` with the decrypted string
    passed in as an argument to the thread function, various output variables, and
    a callback function named `is_executable`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: If we examine the `get_targets` function (found at `0x000000010000e0d0`), we
    see that given a root directory (like */Users*), the `get_targets` function invokes
    the `opendir` and `readdir` APIs to recursively generate a list of files. Then,
    for each file encountered, the callback function (such as `is_executable`) is
    invoked. This allows the list of enumerated files to be filtered by some constraint.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Checking Whether to Infect Each File
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `is_executable` function performs several checks to select only files from
    the list that are non-application Mach-O executables smaller than 25MB. If you
    take a look at `is_executable`’s annotated disassembly, which you can find starting
    at `0x0000000100004ac0`, you’ll see the first check, which confirms that the file
    isn’t an application ([Listing 11-21](#listing11-21)):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 11-21: Core logic of the `is_executable` function'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `is_executable` first uses the `strstr` function 2 to check
    whether the passed-in path contains `".app/"` 1. If it does, the `is_executable`
    function will prematurely return with `0x0` 3. This means the malware skips binaries
    within application bundles.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'For non-application files, the `is_executable` function opens the file and
    reads in `0x1c` bytes, as shown in [Listing 11-22](#listing11-22):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 11-22: Reading the start of a candidate file'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'It then calculates the file’s size by finding the end of the file (via `fseek`)
    and retrieving the file stream’s position (via `ftell`). If the file’s size is
    larger than `0x1900000` bytes (25MB), the `is_executable` function will return
    `0` for that file ([Listing 11-23](#listing11-23)):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 11-23: Calculating the candidate file’s size'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `is_executable` function evaluates whether the file is a Mach-O binary
    by checking whether it starts with a Mach-O “magic” value. In Chapter 5 we noted
    that Mach-O headers always begin with some value that identifies the binary as
    a Mach-O. You can find all magic values defined in Apple’s *mach-o/loader.h*.
    For example, `0xfeedface` is the “magic” value for a 32-bit Mach-O binary ([Listing
    11-24](#listing11-24)):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 11-24: Checking for Mach-O constants'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: To improve the readability of the disassembly, we instructed Hopper to treat
    the bytes read from the start of the file as a Mach-O header structure ([Figure
    11-1](#figure11-1)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高反汇编的可读性，我们指示 Hopper 将从文件开始处读取的字节视为 Mach-O 头结构（[图 11-1](#figure11-1)）。
- en: '![In Hopper, the “Edit variable var_40 at displacement -64” window is open.
    The Name box contains “header” and the Type box has “struct__macho_header” selected.](image_fi/501942c11/f11001.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![在 Hopper 中，“在偏移量 -64 处编辑变量 var_40”窗口已打开。名称框包含“header”，类型框选中了“struct__macho_header”。](image_fi/501942c11/f11001.png)'
- en: 'Figure 11-1: Typecasting the file’s header as a Mach-O header'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：将文件头类型转换为 Mach-O 头
- en: 'Finally, the function checks the `filetype` member of the file’s Mach-O header
    to see if it contains the value `0x2` ([Listing 11-25](#listing11-25)):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该函数检查文件的 Mach-O 头部中的`filetype`成员，以确定它是否包含值`0x2`（[清单 11-25](#listing11-25)）：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 11-25: Checking the file’s Mach-O type'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-25：检查文件的 Mach-O 类型
- en: We can consult Apple’s Mach-O documentation to learn that this member will be
    set to `0x2` (`MH_EXECUTE`) if the file is a standard executable rather than a
    dynamic library or bundle.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查阅 Apple 的 Mach-O 文档了解到，如果文件是标准可执行文件而不是动态库或捆绑包，则该成员将被设置为`0x2`（`MH_EXECUTE`）。
- en: Once `is_executable` has performed these checks, it returns a list of files
    that meet its criteria.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`is_executable`完成这些检查，它将返回一个符合其标准的文件列表。
- en: Infecting Target Files
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 感染目标文件
- en: 'For each file identified as a candidate for infection, the malware invokes
    a function named `append_ei` that contains the actual viral infection logic. At
    a high level, this function modifies the target file in the following manner:
    it prepends a copy of the malware to it; then it appends a trailer that contains
    an infection indicator and the offset to the file’s original code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个被识别为感染候选的文件，恶意软件会调用一个名为`append_ei`的函数，该函数包含实际的病毒感染逻辑。大体上，该函数通过以下方式修改目标文件：将恶意软件的副本添加到文件前面；然后附加一个尾部，包含感染标识符和指向文件原始代码的偏移量。
- en: We can see this viral infection at work by placing a binary of our own into
    the user’s home directory and running the malware under the debugger to watch
    it interact with our file. Any Mach-O binary smaller than 25MB will work. Here
    we’ll use the binary created by compiling Apple’s boilerplate “Hello, World!”
    code in Xcode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们自己的二进制文件放入用户的主目录中，并在调试器中运行恶意软件，观察它与我们的文件互动，来看到这种病毒性感染的作用。任何小于25MB的
    Mach-O 二进制文件都可以工作。在这里，我们将使用通过在 Xcode 中编译 Apple 的示例“Hello, World!”代码生成的二进制文件。
- en: 'In the debugger, set a breakpoint on the `append_ei` function at `0x0000000100004bf0`,
    as shown in [Listing 11-26](#listing11-26):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中，在`0x0000000100004bf0`处设置一个断点，针对`append_ei`函数，正如[清单 11-26](#listing11-26)所示：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 11-26: Arguments passed to the `append_ei` function'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-26：传递给`append_ei`函数的参数
- en: 'When the breakpoint is hit, notice that the function is invoked with two arguments
    held in the `RDI` and `RSI` registers: the path of the malware and the target
    file to infect, respectively. Next, `append_ei` invokes the `stat` function to
    check that the target file is accessible. You can see this in the annotated decompilation
    in [Listing 11-27](#listing11-27):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当断点被触发时，请注意该函数是以两个参数调用的，分别存储在`RDI`和`RSI`寄存器中：恶意软件的路径和要感染的目标文件。接下来，`append_ei`调用`stat`函数检查目标文件是否可访问。你可以在[清单
    11-27](#listing11-27)的注释反汇编中看到这一点：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 11-27: Checking a candidate’s file accessibility'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-27：检查候选文件的可访问性
- en: The source file is then wholly read into memory. In the debugger, we saw that
    this file is the malware itself. It will be virally prepended to the target binary
    ([Listing 11-28](#listing11-28)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，源文件会完全读取到内存中。在调试器中，我们看到这个文件就是恶意软件本身。它将以病毒方式被添加到目标二进制文件中（[清单 11-28](#listing11-28)）。
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 11-28: The malware, reading itself into memory'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-28：恶意软件，读取自身到内存中
- en: Once the malware has been read into memory, the target binary is opened and
    fully read into memory ([Listing 11-29](#listing11-29)). Note that it has been
    opened for updating (using mode `rb+`), because the malware will soon alter it
    1.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件被读取到内存中，目标二进制文件就会被打开并完全读取到内存中（[清单 11-29](#listing11-29)）。注意，它是以更新模式（使用`rb+`）打开的，因为恶意软件很快会对其进行修改
    1。
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 11-29: Reading the target binary into memory'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 11-29：将目标二进制文件读取到内存中
- en: 'Next, the code within the `append_ei` function checks if the target file has
    already been infected (it makes no sense to infect the same binary twice). To
    do so, the code invokes a function named `unpack_trailer`. Implemented at `0x00000001000049c0`,
    this function looks for “trailer” data appended to the end of an infected file.
    We’ll discuss this function and the details of this trailer data shortly. For
    now, note that if the call to `unpack_trailer` returns trailer data, EvilQuest
    knows the file is already infected and the `append_ei` function exits ([Listing
    11-30](#listing11-30)):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`append_ei`函数中的代码检查目标文件是否已经被感染（对同一个二进制文件进行两次感染没有意义）。为此，代码调用了一个名为`unpack_trailer`的函数。该函数位于`0x00000001000049c0`，它会查找附加到感染文件末尾的“尾部”数据。稍后我们将讨论这个函数和尾部数据的详细信息。现在需要注意的是，如果调用`unpack_trailer`返回尾部数据，EvilQuest就知道文件已经被感染，`append_ei`函数将退出（见[列表
    11-30](#listing11-30)）：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 11-30: Checking if the target file is already infected'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-30：检查目标文件是否已经感染
- en: 'Assuming the target file is not already infected, the malware overwrites it
    with the malware. To preserve the target file’s functionality, the `append_ei`
    function then appends the file’s original bytes, which it has read into memory
    ([Listing 11-31](#listing11-31)):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设目标文件尚未感染，恶意软件会用其自身覆盖目标文件。为了保持目标文件的功能，`append_ei` 函数接着会将文件原始的字节追加上去，这些字节已经被读取到内存中（见[列表
    11-31](#listing11-31)）：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 11-31: Writing the malware and target file out to disk'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-31：将恶意软件和目标文件写入磁盘
- en: 'Finally, the malware initializes a trailer and formats it with the `pack_trailer`
    function. The trailer is then written to the very end of the infected file, as
    shown in [Listing 11-32](#listing11-32):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件初始化尾部，并使用`pack_trailer`函数对其进行格式化。然后，尾部被写入感染文件的末尾，如[列表 11-32](#listing11-32)所示：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 11-32: Writing the trailer out to disk'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-32：将尾部写入磁盘
- en: This trailer contains a byte value of `0x3`, followed by the size of the malware.
    As the malware is inserted at the start of the target file, this value is also
    the offset to the infected file’s original bytes. As you’ll see, the malware uses
    this value to restore the original functionality of the infected binary when it’s
    executed. The trailer also contains an infection marker, `0xdeadface`. [Table
    11-1](#table11-1) shows the layout of the resulting file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该尾部包含一个字节值`0x3`，后面跟着恶意软件的大小。由于恶意软件被插入到目标文件的开头，因此该值也是感染文件原始字节的偏移量。正如你所看到的，恶意软件使用这个值在执行时恢复被感染二进制文件的原始功能。尾部还包含一个感染标记`0xdeadface`。[表格
    11-1](#table11-1)展示了最终文件的布局。
- en: 'Table 11-1: The Structure of the File Created by the Viral Infection Logic'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 11-1：病毒感染逻辑创建的文件结构
- en: '| Viral code |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 病毒代码 |'
- en: '| Original code |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 原始代码 |'
- en: '| Trailer `0x3` &#124; size of the viral code (the original code’s offset)
    &#124; `0xdeadface` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 尾部 `0x3` &#124; 病毒代码的大小（原始代码的偏移） &#124; `0xdeadface` |'
- en: 'Let’s examine the infected *HelloWorld* binary to confirm that it conforms
    to this layout. Take a look at the hexdump in [Listing 11-33](#listing11-33):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查被感染的*HelloWorld*二进制文件，以确认它是否符合这种布局。查看[列表 11-33](#listing11-33)中的十六进制转储：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 11-33: Hexdump of an infected file'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11-33：感染文件的十六进制转储
- en: 'The hexdump shows byte values in little-endian order. We find the malware’s
    Mach-O binary code at the start of the binary, and the original *Hello World*
    code begins at offset `0x15770` 1. At the end of the file, we see the packed trailer:
    `03 70 57 01 00 ce fa ad de` 2. The first value is the byte `0x3`, while the subsequent
    two values when viewed as a 32-bit hexadecimal integer are `0x00015770`, the malware’s
    size and offset to the original bytes, and `0xdeadface`, the infection marker.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制转储以小端顺序显示字节值。我们发现恶意软件的Mach-O二进制代码位于二进制文件的开头，而原始的*Hello World*代码从偏移`0x15770`
    1开始。在文件的末尾，我们看到了打包的尾部：`03 70 57 01 00 ce fa ad de` 2。第一个值是字节`0x3`，而后面的两个值按32位十六进制整数查看为`0x00015770`，即恶意软件的大小和指向原始字节的偏移量，`0xdeadface`为感染标记。
- en: Executing and Repersisting from Infected Files
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从感染文件执行并重新持久化
- en: When a user or the system runs a binary infected with EvilQuest, the copy of
    the malware injected into the binary will begin executing instead. This is because
    macOS’s dynamic loader will execute whatever it finds at the start of a binary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户或系统运行一个被EvilQuest感染的二进制文件时，注入到二进制文件中的恶意软件副本将开始执行。这是因为macOS的动态加载器会执行二进制文件开头的内容。
- en: 'As part of its initialization, the malware invokes a method named `extract_ei`,
    which examines the on-disk binary image backing the running process. Specifically,
    the malware reads `0x20` bytes of “trailer” data from the end of the file, which
    it unpacks via a call to a function named `unpack_trailer`. If the last of these
    trailer bytes is `0xdeadface`, the malware knows it is executing as a result of
    an infected file, rather than from, say, one of its launch items ([Listing 11-34](#listing11-34)):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 11-34: Examining the trailer data'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'If trailer data is found, the `extract_ei` function returns a pointer to the
    malware’s bytes in the infected file. It also returns the length of this data;
    recall that this value is stored in the trailer. This block of code resaves, repersists,
    and re-executes the malware if needed, as you can see in [Listing 11-35](#listing11-35):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 11-35: The malware resaving, repersisting, and relaunching itself'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute our infected binary, we can confirm in a debugger that the file
    invokes the `persist_executable_frombundle` function, implemented at `0x0000000100008df0`.
    This function is responsible for writing the malware from the infected file to
    disk, as shown in the debugger output in [Listing 11-36](#listing11-36):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 11-36: Arguments of the `persist_executable_frombundle` function'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We see it invoked with a pointer to the malware’s bytes in the infected file
    1 and one to the length of this data 2.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'In a file monitor, we can observe the infected binary executing this logic
    to recreate both the malware’s persistent binary (*~/Library/AppQuest/com.apple.quest*)
    and launch agent property list (*com.apple.questd.plist*), as shown in [Listing
    11-37](#listing11-37):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 11-37: Observing the recreation of both the malicious launch agent
    binary and plist'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that the malware did not recreate its launch daemon, as this
    requires root privileges, which the infected process did not possess.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The infected binary then launches the malware via `launchctl`, as you can see
    in a process monitor ([Listing 11-38](#listing11-38)):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 11-38: Observing the relaunch of newly repersisted malware'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This confirms that the main goal of the local viral infection is to ensure that
    a system remains infected even if the malware’s launch items and binary are deleted.
    Sneaky!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Executing the Infected File’s Original Code
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the infected binary has repersisted and re-executed the malware, it
    needs to execute the infected binary’s original code so that nothing appears amiss
    to the user. This is handled by a function named `run_target` found at `0x0000000100005140`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The `run_target` function first consults the trailer data to get the offset
    of the original bytes within the infected file. The function then writes these
    bytes out to a new file with the naming scheme *.<originalfilename>1* 1, as shown
    in [Listing 11-39](#listing11-39). This new file is then set to be executable
    (via `chmod`) and executed (via `execl`) 2:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 11-39: Executing a pristine instance of the infected binary to ensure
    nothing appears amiss'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'A process monitor can capture the execution event of the new file containing
    the original binary’s bytes ([Listing 11-40](#listing11-40)):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 11-40: Observing the execution of a pristine instance of the infected
    binary'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of writing the original bytes to a separate file before executing
    it is that this process preserves the code-signing and entitlements of the original
    file. When EvilQuest infects a binary, it will invalidate any code-signing signature
    and entitlements by maliciously modifying the file. Although macOS will still
    allow the binary to run, it will no longer respect its entitlements, which could
    break the legitimate functionality. Writing just the original bytes to a new file
    restores the code-signing signature and any entitlements. This means that, when
    executed, the new file will function as expected.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The Remote Communications Logic
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After EvilQuest infects other binaries on the system, it performs additional
    actions, such as file exfiltration and the execution of remote tasking. These
    actions require communications with a remote server. In this section, we’ll explore
    this remote communications logic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The Mediator and Command and Control Servers
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To determine the address of its remote command and control server, the malware
    invokes a function named `get_mediator`. Implemented at ``0x000000010000a910,
    this function takes two parameters: the address of a server and a filename. It
    then calls a function named `http_request` to ask the specified server for the
    specified file, which the malware expects will contain the address of the command
    and control server. This indirect lookup mechanism is convenient, because it allows
    the malware authors to change the address of the command and control server at
    any time. All they have to do is update the file on the primary server.``'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
