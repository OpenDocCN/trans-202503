["```\n❶ int foo(void) {\n    return 1;\n}\n\n❷ int bar(void) {\n    return 2;\n}\n```", "```\n❸ int foo(void);\n❹ static int bar(void);\n\nint main(void) {\n    return foo() + bar();\n}\n\n❺ static int bar(void) {\n    return 4;\n}\n```", "```\nstatic int a;\nextern int a;\n```", "```\nint main(void) {\n    extern int a;\n    return a;\n}\n\nint a = 5;\n```", "```\nint a = 4;\nint main(void) {\n    int a = 3;\n    {\n      ❶ extern int a;\n        return a;\n    }\n}\n```", "```\nstatic int my_fun(void);\nint my_fun(void) {\n    return 0;\n}\n```", "```\n#include <stdio.h>\n\nint recursive_call(int count_was_initialized) {\n    int count;\n    if(!count_was_initialized) {\n        count = 0;\n        count_was_initialized = 1;\n    }\n    count = count + 1;\n    printf(\"This function has been called %d times\\n\", count);\n    if (count < 20) {\n        recursive_call(count_was_initialized);\n    }\n    return 0;\n}\n```", "```\n#include <stdio.h>\n\nint recursive_call(void) {\n  ❶ static int count = 0;\n    count = count + 1;\n    printf(\"This function has been called %d times\\n\", count);\n    if (count < 20) {\n        recursive_call();\n    }\n    return 0;\n}\n```", "```\nint first_var = 3;\nint second_var = first_var + 1;\n```", "```\nextern int three;\n\nint main(void) {\n    return three;\n}\n\nint three = 3;\n```", "```\nextern int external_var;\n\nint main(void) {\n    return 1 + external_var;\n}\n```", "```\nint x;\n\nint main(void) {\n    return x;\n}\n```", "```\nint x = 0;\n```", "```\nint x;\n\nint main(void) {\n    return x;\n}\n\nint x = 3;\n```", "```\nint a;\nint a;\nextern int a;\nint a;\n```", "```\nint a = 0;\n```", "```\nint main(void) {\n    extern int foo;\n    return foo;\n}\n\nstatic int foo = 3;\n```", "```\nint foo = 3;\n\nint main(void) {\n    int foo(void);\n    return foo();\n}\n```", "```\n .data\n    .align 4\nvar:\n    .long 3\n```", "```\n .globl var\n```", "```\n .bss\n    .align 4\nvar:\n    .zero 4\n```", "```\nmovl    $4, var(%rip)\n```", "```\nprogram = Program(**declaration***)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, exp? init, **storage_class?**)\nfunction_declaration = (identifier name, identifier* params,\n                        block? body, **storage_class?**)\n**storage_class = Static | Extern**\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(int)\n    | Var(identifier)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\n```", "```\n<program> ::= {**<declaration>**}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= **{<specifier>}+** <identifier> [\"=\" <exp>] \";\"\n<function-declaration> ::= **{<specifier>}+** <identifier> \"(\" <param-list> \")\" (<block> | \";\")\n<param-list> ::= \"void\" | \"int\" <identifier> {\",\" \"int\" <identifier>}\n**<specifier> ::= \"int\" | \"static\" | \"extern\"**\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n<factor> ::= <int> | <identifier> | <unop> <factor> | \"(\" <exp> \")\"\n           | <identifier> \"(\" [<argument-list>] \")\"\n<argument-list> ::= <exp> {\",\" <exp>}\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\nstatic int a = 3;\n```", "```\nint static a = 3;\n```", "```\nparse_type_and_storage_class(specifier_list):\n    types = []\n    storage_classes = []\n  ❶ for specifier in specifier_list:\n        if specifier is \"int\":\n            types.append(specifier)\n        else:\n            storage_classes.append(specifier)\n\n    if length(types) != 1:\n        fail(\"Invalid type specifier\")\n    if length(storage_classes) > 1:\n        fail(\"Invalid storage class\")\n\n  ❷ type = Int\n\n    if length(storage_classes) == 1:\n      ❸ storage_class = parse_storage_class(storage_classes[0])\n    else:\n        storage_class = null\n\n    return (type, storage_class)\n```", "```\nresolve_file_scope_variable_declaration(decl, identifier_map):\n    identifier_map.add(decl.name, MapEntry(new_name=decl.name,\n                                           from_current_scope=True,\n                                           has_linkage=True))\n    return decl\n```", "```\nresolve_local_variable_declaration(decl, identifier_map):\n    if decl.name is in identifier_map:\n        prev_entry = identifier_map.get(decl.name)\n      ❶ if prev_entry.from_current_scope:\n            if not (prev_entry.has_linkage and decl.storage_class == Extern):\n                fail(\"Conflicting local declarations\")\n\n    if decl.storage_class == Extern:\n      ❷ identifier_map.add(decl.name, MapEntry(new_name=decl.name,\n                                               from_current_scope=True,\n                                               has_linkage=True))\n        return decl\n    else:\n        unique_name = make_temporary()\n      ❸ identifier_map.add(decl.name, MapEntry(new_name=unique_name,\n                                               from_current_scope=True,\n                                               has_linkage=False))\n        `--snip--`\n```", "```\nidentifier_attrs = FunAttr(bool defined, bool global)\n                 | StaticAttr(initial_value init, bool global)\n                 | LocalAttr\n\ninitial_value = Tentative | Initial(int) | NoInitializer\n```", "```\ntypecheck_function_declaration(decl, symbols):\n    fun_type = FunType(length(decl.params))\n    has_body = decl.body is not null\n    already_defined = False\n  ❶ **global = decl.storage_class != Static**\n\n  ❷ if decl.name is in symbols:\n        old_decl = symbols.get(decl.name)\n        if old_decl.type != fun_type:\n            fail(\"Incompatible function declarations\")\n        already_defined = old_decl.attrs.defined\n        if already_defined and has_body:\n            fail(\"Function is defined more than once\")\n\n **if old_decl.attrs.global and decl.storage_class == Static:**\n **fail(\"Static function declaration follows non-static\")**\n❸ **global = old_decl.attrs.global**\n\n    **attrs = FunAttr(defined=(already_defined or has_body), global=global)**\n    symbols.add(decl.name, fun_type, **attrs=attrs**)\n `--snip--`\n```", "```\ntypecheck_file_scope_variable_declaration(decl, symbols):\n    if decl.init is constant integer i: ❶\n        initial_value = Initial(i)\n    else if decl.init is null: ❷\n        if decl.storage_class == Extern:\n            initial_value = NoInitializer\n        else:\n            initial_value = Tentative\n    else: ❸\n        fail(\"Non-constant initializer!\")\n\n    global = (decl.storage_class != Static) ❹\n\n    if decl.name is in symbols: ❺\n        old_decl = symbols.get(decl.name)\n        if old_decl.type != Int:\n            fail(\"Function redeclared as variable\")\n        if decl.storage_class == Extern:\n            global = old_decl.attrs.global\n        else if old_decl.attrs.global != global:\n            fail(\"Conflicting variable linkage\")\n\n        if old_decl.attrs.init is a constant:\n            if initial_value is a constant:\n                fail(\"Conflicting file scope variable definitions\") ❻\n            else:\n                initial_value = old_decl.attrs.init\n        else if initial_value is not a constant and old_decl.attrs.init == Tentative:\n            initial_value = Tentative\n\n attrs = StaticAttr(init=initial_value, global=global)\n    symbols.add(decl.name, Int, attrs=attrs) ❼\n```", "```\ntypecheck_local_variable_declaration(decl, symbols):\n    if decl.storage_class == Extern:\n        if decl.init is not null: ❶\n            fail(\"Initializer on local extern variable declaration\")\n        if decl.name is in symbols:\n            old_decl = symbols.get(decl.name)\n            if old_decl.type != Int: ❷\n                fail(\"Function redeclared as variable\")\n        else:\n            symbols.add(decl.name, Int, attrs=StaticAttr(init=NoInitializer, global=True)) ❸\n\n    else if decl.storage_class == Static:\n        if decl.init is constant integer i: ❹\n            initial_value = Initial(i)\n        else if decl.init is null: ❺\n            initial_value = Initial(0)\n else:\n            fail(\"Non-constant initializer on local static variable\")\n        symbols.add(decl.name, Int, attrs=StaticAttr(init=initial_value, global=False)) ❻\n\n    else:\n        symbols.add(decl.name, Int, attrs=LocalAttr) ❼\n        if decl.init is not null:\n            typecheck_exp(decl.init, symbols)\n```", "```\nFunction(identifier, **bool global**, identifier* params, instruction* body)\n```", "```\nStaticVariable(identifier, bool global, int init)\n```", "```\nprogram = Program(**top_level***)\n**top_level** = Function(identifier, **bool global**, identifier* params, instruction* body)\n          **| StaticVariable(identifier, bool global, int init)**\ninstruction = Return(val)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val dst)\nval = Constant(int) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\nconvert_symbols_to_tacky(symbols):\n    tacky_defs = []\n    for (name, entry) in symbols:\n        match entry.attrs with\n        | StaticAttr(init, global) ->\n            match init with\n            | Initial(i) -> tacky_defs.append(StaticVariable(name, global, i))\n            | Tentative -> tacky_defs.append(StaticVariable(name, global, 0))\n            | NoInitializer -> continue\n        | _ -> continue\n    return tacky_defs\n```", "```\nprogram = Program(**top_level***)\n**top_level** = Function(identifier name, **bool global,** instruction* instructions)\n          **| StaticVariable(identifier name, bool global, int init)**\ninstruction = Mov(operand src, operand dst)\n            | Unary(unary_operator, operand)\n            | Binary(binary_operator, operand, operand)\n            | Cmp(operand, operand)\n            | Idiv(operand)\n            | Cdq\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | AllocateStack(int)\n            | DeallocateStack(int)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\n\nunary_operator = Neg | Not\nbinary_operator = Add | Sub | Mult\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) | **Data(identifier)**\ncond_code = E | NE | G | GE | L | LE\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Function(name,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">global,</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">[Mov(Reg(DI), param1),\n          Mov(Reg(SI), param2),</samp> \n           <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy next four parameters from registers>,</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">Mov(Stack(16), param7),\n          Mov(Stack(24), param8),</samp> \n           <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><copy remaining parameters from stack></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">]</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">+\n        instructions)</samp></samp></samp>\n```", "```\nMov(Imm(0), Pseudo(\"foo\"))\n```", "```\nMov(Imm(0), Data(\"foo\"))\n```", "```\nMov(Data(\"x\"), Stack(-4))\n```", "```\nMov(Data(\"x\"), Reg(R10))\nMov(Reg(R10), Stack(-4))\n```", "```\n .globl `<name>`\n    .data\n    .align 4\n`<name>`:\n    .long `<init>`\n```", "```\n .globl `<name>`\n    .bss\n    .align 4\n`<name>`:\n    .zero 4\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Print out each top-level construct.</samp> \n<samp class=\"SANS_Futura_Std_Book_11\">On Linux, add at end of file:</samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">.section .note.GNU-stack,\"\",@progbits</samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><global-directive></samp> \n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">  .text</samp> \n<samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:\n    pushq    %rbp\n    movq     %rsp, %rbp    </samp> \n    <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><instructions></samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><global-directive></samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">.bss</samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><alignment-directive>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">:\n    .zero 4</samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><global-directive></samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">.data</samp> \n    <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><alignment-directive>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">:\n    .long</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><init></samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">If</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">global</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">is true:\n.globl</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><identifier></samp> \n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Otherwise, omit this directive.</samp></samp></samp></samp>\n```"]