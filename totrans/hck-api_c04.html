<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 4: Your API Hacking System</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:4817cf93-40a6-403c-8355-e951c69da606" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_71" title="71"/>4</span><br/>
<span class="ChapterTitle">Your API Hacking System</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">This chapter will walk you through setting up your API hacking toolkit. We’ll cover three especially useful tools for API hackers: Chrome DevTools, Burp Suite, and Postman.</p>
<p>In addition to exploring features included in the paid Burp Suite Pro version, I’ll provide a list of tools that can compensate for the features missing from the free Burp Suite Community Edition, as well as several other tools useful for discovering and exploiting API vulnerabilities. At the end of this chapter, we’ll walk through a lab in which you’ll learn to use some of these tools to interact with our first APIs.</p>
<h2 id="h1-502444c04-0001"><span epub:type="pagebreak" id="Page_72" title="72"/>Kali Linux</h2>
<p class="BodyFirst">Throughout this book, we’ll run tools and labs using Kali, an open-source Debian-based distribution of Linux. Kali is built for penetration testing and comes with many useful tools already installed. You can download Kali at <a class="LinkURL" href="https://www.kali.org/downloads">https://www.kali.org/downloads</a>. Plenty of guides can walk you through setting up your hypervisor of choice and installing Kali onto it. I recommend using Null Byte’s “How to Get Started with Kali Linux” or the tutorial at <a class="LinkURL" href="https://www.kali.org/docs/installation">https://www.kali.org/docs/installation</a>.</p>
<p>After your instance of Kali is set up, open a terminal and perform an update and upgrade:</p>
<pre><code>$ <b>sudo apt update</b>
$ <b>sudo apt full-upgrade -y</b></code></pre>
<p>Next, install Git, Python 3, and Golang (Go), which you’ll need to use some of the other tools in your hacking box:</p>
<pre><code>$ <b>sudo apt-get install git python3 golang</b></code></pre>
<p>With these basics installed, you should be prepared to set up the remainder of the API hacking tools.</p>
<h2 id="h1-502444c04-0002">Analyzing Web Apps with DevTools</h2>
<p class="BodyFirst">Chrome’s DevTools is a suite of developer tools built into the Chrome browser that allows you to view what your web browser is running from a web developer’s perspective. DevTools is an often-underrated resource, but it can be very useful for API hackers. We’ll use it for our first interactions with target web applications to discover APIs; interact with web applications using the console; view headers, previews, and responses; and analyze web application source files.</p>
<p>To install Chrome, which includes DevTools, run the following commands:</p>
<pre><code>$ <b>sudo wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</b>
$ <b>sudo apt install ./google-chrome-stable_current_amd64.deb</b></code></pre>
<p>You can launch Chrome through the command line with the <code>google-chrome</code> command. Once you have Chrome running, navigate to the URL you want to investigate and launch DevTools by using either <span class="KeyCaps">ctrl</span>-<span class="KeyCaps">shift</span>-I or F12 or navigating to <b>Settings</b><span class="MenuArrow">▶</span><b>More Tools</b> and selecting the <b>Developer Tools</b> menu. Next, refresh your current page to update the information in the DevTools panels. You can do this by using the <span class="KeyCaps">ctrl</span>-R shortcut. In the Network panel, you should see the various resources requested from APIs (see <a href="#figure4-1" id="figureanchor4-1">Figure 4-1</a>).</p>
<span epub:type="pagebreak" id="Page_73" title="73"/><figure>
<img alt="Screenshot of a DevTools panel populated with a list of requests that have 200 status codes" class="" src="image_fi/502444c04/F04001.png"/>
<figcaption><p><a id="figure4-1">Figure 4-1</a>: The Chrome DevTools Network panel</p></figcaption>
</figure>
<p>Switch panels by selecting the desired tab at the top. The DevTools panel lists the functionality of the different table options. I’ve summarized these in <a href="#table4-1" id="tableanchor4-1">Table 4-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-1">Table 4-1</a>: DevTools Panels</p></figcaption>
<table border="1" id="table-502444c04-0001">
<thead>
<tr>
<td><b>Panel</b></td>
<td><b>Function</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Elements</td>
<td>Allows you to view the current page’s CSS and Document Object Model (DOM), which enables you to inspect the HTML that constructs the web page.</td>
</tr>
<tr>
<td>Console</td>
<td>Provides you with alerts and lets you interact with the JavaScript debugger to alter the current web page.</td>
</tr>
<tr>
<td>Sources</td>
<td>Contains the directories that make up the web application and the content of the source files.</td>
</tr>
<tr>
<td>Network</td>
<td>Lists all the source file requests that make up the client’s perspective of the web application.</td>
</tr>
<tr>
<td>Performance</td>
<td>Provides a way to record and analyze all the events that take place when loading a web page.</td>
</tr>
<tr>
<td>Memory</td>
<td>Lets you record and analyze how the browser is interacting with your system’s memory.</td>
</tr>
<tr>
<td>Application</td>
<td>Provides you with the application manifest, storage items (like cookies and session information), cache, and background services.</td>
</tr>
<tr>
<td>Security</td>
<td>Provides insight regarding the transit encryption, source content origins, and certificate details.</td>
</tr>
</tbody>
</table>
</figure>
<p>When we first begin interacting with a web application, we’ll usually start with the Network panel to get an overview of the resources that power the web application. In <a href="#figure4-1">Figure 4-1</a>, each of the items listed represents a request that was made for a specific resource. Using the Network panel, you <span epub:type="pagebreak" id="Page_74" title="74"/>can drill down into each request to see the request method that was used, the response status code, the headers, and the response body. To do this, click the name of the URL of interest once under the Name column. This will open up a panel on the right side of the DevTools. Now you can review the request that was made under the Headers tab and see how the server responded under the Response tab.</p>
<p>Diving deeper into the web application, you can use the Sources panel to inspect the source files being used in the app. In capture-the-flag (CTF) events (and occasionally in reality) you may find API keys or other hardcoded secrets here. The Sources panel comes equipped with strong search functionality that will help you easily discover the inner workings of the application.</p>
<p>The Console panel is useful for running and debugging the web page’s JavaScript. You can use it to detect errors, view warnings, and execute commands. You will get an opportunity to use the Console panel in the lab in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<p>We will spend the majority of our time in the Console, Sources, and Network panels. However, the other panels can be useful as well. For example, the Performance panel is mainly used to improve a website’s speed, but we could also use it to observe at what point a web application interacts with an API, as shown in <a href="#figure4-2" id="figureanchor4-2">Figure 4-2</a>.</p>
<figure>
<img alt="Screenshot of a DevTools graph on which a point is labeled “client_event.json (api.twitter.com).”" class="" src="image_fi/502444c04/F04002.png"/>
<figcaption><p><a id="figure4-2">Figure 4-2</a>: The DevTool’s Performance tab showing the exact moment the Twitter application interacted with the Twitter API</p></figcaption>
</figure>
<p>In <a href="#figure4-2">Figure 4-2</a> we see that, 1,700 milliseconds in, a client event triggered the Twitter application to interact with the API. As the client, we would then be able to correlate that event to an action we took on the page, such as authenticating to the web app, to know what the web application is using the API for. The more information we can gather before attacking an API, the better our odds will be at finding and exploiting vulnerabilities.</p>
<p>For more information about DevTools, check out the Google Developers documentation at <a class="LinkURL" href="https://developers.google.com/web/tools/chrome-devtools">https://developers.google.com/web/tools/chrome-devtools</a>.</p>
<h2 id="h1-502444c04-0003"><span epub:type="pagebreak" id="Page_75" title="75"/>Capturing and Modifying Requests with Burp Suite</h2>
<p class="BodyFirst">Burp Suite is a magnificent set of web application–testing tools developed and continuously improved on by PortSwigger. All web app cybersecurity professionals, bug bounty hunters, and API hackers should learn to use Burp, which allows you to capture API requests, spider web applications, fuzz APIs, and so much more.</p>
<p><em>Spidering</em>, or <em>web crawling</em>, is a method that bots use to automatically detect the URL paths and resources of a host. Typically, spidering is done by scanning the HTML of web pages for hyperlinks. Spidering is a good way to get a basic idea of the contents of a web page, but it won’t be able to find <em>hidden</em> paths, or the ones that do not have links found within web pages. To find hidden paths, we’ll need to use a tool like Kiterunner that effectively performs directory brute-force attacks. In such an attack, an application will request various possible URL paths and validate whether they actually exist based on the host’s responses.</p>
<p>As described by the OWASP community page on the topic, <em>fuzzing</em> is “the art of automatic bug finding.” Using this attack technique, we’d send various types of input in HTTP requests, trying to find an input or payload that causes an application to respond in unexpected ways and reveal a vulnerability. For example, if you were attacking an API and discovered you could post data to the API provider, you could then attempt to send it various SQL commands. If the provider doesn’t sanitize this input, there is a chance you could receive a response that indicates that a SQL database is in use.</p>
<p>Burp Suite Pro, the paid edition of Burp, provides all the features without restrictions, but if using the free Burp Suite Community Edition (CE) is your only option, you can make it work. However, once you’ve obtained a bug bounty reward or as soon as you can convince your employer, you should make the jump to Burp Suite Pro. This chapter includes a <span class="xref" itemid="xref_target_“Supplemental Tools”">“Supplemental Tools”</span> section that will help replace the functionality missing in Burp Suite CE.</p>
<p>Burp Suite CE is included standard with the latest version of Kali. If for whatever reason it is not installed, run the following:</p>
<pre><code>$ <b>sudo apt-get install burpsuite</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Burp Suite provides a full-featured 30-day trial version of Burp Suite Pro at <a class="LinkURL" href="https://portswigger.net/requestfreetrial/pro">https://portswigger.net/requestfreetrial/pro</a>. For further instructions on using Burp Suite, visit <a class="LinkURL" href="https://portswigger.net/burp/communitydownload">https://portswigger.net/burp/communitydownload</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In the following sections, we will prepare our API hacking rig to use Burp Suite, look at an overview of the various Burp modules, learn how to intercept HTTP requests, dive deeper into the Intruder module, and go over some of the sweet extensions you can use to enhance Burp Suite Pro.</p>
<h3 id="h2-502444c04-0001"><span epub:type="pagebreak" id="Page_76" title="76"/>Setting Up FoxyProxy</h3>
<p class="BodyFirst">One of Burp Suite’s key features is the ability to intercept HTTP requests. In other words, Burp Suite receives your requests before forwarding them to the server and then receives the server’s responses before sending them to the browser, allowing you to view and interact with those requests and responses. For this feature to work, we’ll need to regularly send requests from the browser to Burp Suite. This is done with the use of a web proxy. The proxy is a way for us to reroute web browser traffic to Burp before it is sent to the API provider. To simplify this process, we’ll add a tool called FoxyProxy to our browsers to help us proxy traffic with a click of a button.</p>
<p>Web browsers have proxy functionality built in, but changing and updating these settings every time you want to use Burp would be a time-consuming pain. Instead, we’ll use a browser add-on called FoxyProxy that lets you switch your proxy on and off with a simple click of a button. FoxyProxy is available for both Chrome and Firefox.</p>
<p>Follow these steps to install FoxyProxy:</p>
<ol class="decimal">
<li value="1">Navigate to your browser’s add-on or plug-in store and search <b>FoxyProxy</b>.</li>
<li value="2">Install FoxyProxy Standard and add it to your browser.</li>
<li value="3">Click the fox icon at the top-right corner of your browser (next to your URL) and select <b>Options</b>.</li>
<li value="4">Select <b>Proxies</b><span class="MenuArrow">▶</span><b>Add New Proxy</b><span class="MenuArrow">▶</span><b>Manual Proxy Configuration</b>.</li>
<li value="5">Add <b>127.0.0.1</b> as the host IP address.</li>
<li value="6">Update the port to <b>8080 </b>(Burp Suite’s default proxy settings).</li>
<li value="7">Under the General tab, rename the proxy to <b>Hackz</b> (I will refer to this proxy setting throughout the labs).</li>
</ol>
<p>Now you’ll only need to click the browser add-on and select the proxy you want to use to send your traffic to Burp. When you’ve finished intercepting requests, you can turn the proxy off by selecting the Disable FoxyProxy option.</p>
<h3 id="h2-502444c04-0002">Adding the Burp Suite Certificate</h3>
<p class="BodyFirst"><em>HTTP Strict Transport Security (HSTS) </em>is a common web application security policy that prevents Burp Suite from being able to intercept requests. Whether using Burp Suite CE or Burp Suite Pro, you will need to install Burp Suite’s certificate authority (CA) certificate. To add this certificate, follow these steps:</p>
<ol class="decimal">
<li value="1">Start Burp Suite.</li>
<li value="2">Open your browser of choice.</li>
<li value="3">Using FoxyProxy, select the Hackz proxy. Navigate to <em>http://burpsuite</em>, as seen in <a href="#figure4-3" id="figureanchor4-3">Figure 4-3</a>, and click <b>CA Certificate</b>. This will initiate the download of the Burp Suite CA certificate.
<span epub:type="pagebreak" id="Page_77" title="77"/><figure>
<img alt="F04003" src="image_fi/502444c04/F04003.png"/>
<figcaption><p><a id="figure4-3">Figure 4-3</a>: The landing page you should see when downloading Burp Suite’s CA certificate</p></figcaption>
</figure></li>
<li value="4">Save the certificate somewhere you can find it.</li>
<li value="5">Open your browser and import the certificate. In Firefox, open <b>Preferences</b> and use the search bar to look up <b>certificates</b>. Import the certificate.</li>
<li value="6">In Chrome, open <b>Settings</b>, use the search bar to look up <b>certificates</b>, select <b>More</b><span class="MenuArrow">▶</span><b>Manage Certificates</b><span class="MenuArrow">▶</span><b>Authorities</b>, and import the certificate (see <a href="#figure4-4" id="figureanchor4-4">Figure 4-4</a>). If you do not see the certificate, you may need to expand the file type options to “DER” or “All files.”
<figure>
<img alt="F04004" src="image_fi/502444c04/F04004.png"/>
<figcaption><p><a id="figure4-4">Figure 4-4</a>: The Chrome Certificate Manager with the Authorities tab selected</p></figcaption>
</figure></li>
</ol>
<p>Now that you have the PortSwigger CA certificate added to your browser, you should be able to intercept traffic without experiencing issues.</p>
<h3 id="h2-502444c04-0003">Navigating Burp Suite</h3>
<p class="BodyFirst">As you can see in <a href="#figure4-5" id="figureanchor4-5">Figure 4-5</a>, at the top of Burp are 13 modules.</p>
<span epub:type="pagebreak" id="Page_78" title="78"/><figure>
<img alt="Screenshot of menu items including Comparer, Logger, Extender, Project options, User options, Learn, Dashboard, Target, Proxy, Intruder, Repeater, Sequencer, and Decoder" class="keyline" src="image_fi/502444c04/F04005.png"/>
<figcaption><p><a id="figure4-5">Figure 4-5</a>: The Burp Suite modules</p></figcaption>
</figure>
<p>The <em>Dashboard</em> gives you an overview of the event log and scans you have run against your targets. The Dashboard is more useful in Burp Suite Pro than in CE because it will also display any issues detected during testing.</p>
<p>The <em>Proxy</em> tab is where we will begin capturing requests and responses from your web browser and Postman. The proxy we set up will send any web traffic destined for your browser here. We will typically choose to forward or drop captured traffic until we find the targeted site that we want to interact with. From Proxy we will forward the request or response to other modules for interaction and tampering.</p>
<p>In the <em>Target</em> tab,<b> </b>we can see a site’s map and manage the targets we intend to attack. You can also use this tab to configure the scope of your testing by selecting the Scope tab and including or excluding URLs. Including URLs within scope will limit the URLs being attacked to only those you have authorization to attack.</p>
<p>While using the Target tab, you should be able to locate the <em>Site Map</em>, where you can see all the URLs Burp Suite has detected during your current Burp Suite session. As you perform scans, crawl, and proxy traffic, Burp Suite will start compiling a list of the target web applications and discovered directories. This is another place you can add or remove URLs from scope.</p>
<p>The<em> Intruder</em> tab is where we’ll perform fuzzing and brute-force attacks against web applications. Once you’ve captured an HTTP request, you can forward it to Intruder, where you can select the exact parts of the request that you want to replace with the payload of your choice before sending it to the server.</p>
<p>The <em>Repeater</em> is a module that lets you make hands-on adjustments to HTTP requests, send them to the targeted web server, and analyze the content of the HTTP response.</p>
<p>The <em>Sequencer</em> tool will automatically send hundreds of requests and then perform an analysis of entropy to determine how random a given string is. We will primarily use this tool to analyze whether cookies, tokens, keys, and other parameters are actually random.</p>
<p>The <em>Decoder</em> is a quick way to encode and decode HTML, base64, ASCII hex, hexadecimal, octal, binary, and Gzip.</p>
<p>The<em> Comparer </em>can be used to compare different requests. Most often, you’ll want to compare two similar requests and find the sections of the request that have been removed, added, and modified.</p>
<p>If Burp Suite is too bright for your hacker eyes, navigate to <b>User options</b><span class="MenuArrow">▶</span><b>Display</b> and change <b>Look and Feel</b> to <b>Darcula</b>. Within the User Options tab, you can also find additional connection configurations, TLS settings, and miscellaneous options to learn hotkey shortcuts or configure your own hotkeys. You can then save your preferred settings using Project Options, which allows you to save and load specific configurations you like to use per project.</p>
<p><span epub:type="pagebreak" id="Page_79" title="79"/><em>Learn</em> is an awesome set of resources to help you learn how to use Burp Suite. This tab contains video tutorials, the Burp Suite Support Center, a guided tour of Burp’s features, and a link to the PortSwigger Web Security Academy. Definitely check these resources out if you are new to Burp!</p>
<p>Under the Dashboard you can find the Burp Suite Pro Scanner.<em> Scanner </em>is Burp Suite Pro’s web application vulnerability scanner. It lets you automatically crawl web applications and scan for weaknesses.</p>
<p>The<b> </b><em>Extender</em> is where we’ll obtain and use Burp Suite extensions. Burp has an app store that allows you to find add-ons to simplify web app testing. Many extensions require Burp Suite Pro, but we will make the most of the free extensions to turn Burp into an API hacking powerhouse.</p>
<h3 id="h2-502444c04-0004">Intercepting Traffic</h3>
<p class="BodyFirst">A Burp Suite session will usually begin with intercepting traffic. If you’ve set up FoxyProxy and the Burp Suite certificate correctly, the following process should work smoothly. You can use these instructions to intercept any HTTP traffic with Burp Suite:</p>
<ol class="decimal">
<li value="1">Start Burp Suite and change the Intercept option to <b>Intercept is</b> <b>on</b> ‌(see <a href="#figure4-6" id="figureanchor4-6">Figure 4-6</a>).
<figure>
<img alt="F04006" src="image_fi/502444c04/F04006.png"/>
<figcaption><p><a id="figure4-6">Figure 4-6</a>: Intercept is on in Burp Suite.</p></figcaption>
</figure></li>
<li value="2">In your browser, select the Hackz proxy using FoxyProxy and browse to your target, such as <a class="LinkURL" href="https://twitter.com">https://twitter.com</a> (see <a href="#figure4-7" id="figureanchor4-7">Figure 4-7</a>). This web page will not load in the browser because it was never sent to the server; instead, the request should be waiting for you in Burp Suite.
<figure>
<img alt="F04007" src="image_fi/502444c04/F04007.png"/>
<figcaption><p><a id="figure4-7">Figure 4-7</a>: The request to Twitter gets sent to Burp Suite via the Hackz proxy.</p></figcaption>
</figure></li>
<li value="3"><span epub:type="pagebreak" id="Page_80" title="80"/>In Burp Suite, you should see something much like <a href="#figure4-8" id="figureanchor4-8">Figure 4-8</a>. This should let you know that you’ve successfully intercepted an HTTP request.
<figure>
<img alt="F04008" src="image_fi/502444c04/F04008.png"/>
<figcaption><p><a id="figure4-8">Figure 4-8</a>: An HTTP request to Twitter intercepted by Burp Suite</p></figcaption>
</figure></li>
</ol>
<p>Once you’ve captured a request, you can select an action to perform with it, such as forwarding the intercepted request to the various Burp Suite modules. You perform actions by clicking the Action button above the request pane or by right-clicking the request window. You will then have the option to forward the request to one of the other modules, such as Repeater (see <a href="#figure4-9" id="figureanchor4-9">Figure 4-9</a>).</p>
<figure>
<img alt="Screenshot of the an HTTP request and corresponding response in a Burp Suite interface with a Send button" class="keyline" src="image_fi/502444c04/F04009.png"/>
<figcaption><p><a id="figure4-9">Figure 4-9</a>: Burp Suite Repeater</p></figcaption>
</figure>
<p>The Repeater module is the best way to see how a web server responds to a single request. This is useful for seeing what sort of response you can expect to get from an API before initiating an attack. It’s also helpful when you need to make minor changes to a request and want to see how the server responds.</p>
<h3 id="h2-502444c04-0005"><span epub:type="pagebreak" id="Page_81" title="81"/>Altering Requests with Intruder</h3>
<p class="BodyFirst">We’ve already mentioned that Intruder is a web application fuzzing and scanning tool. It works by letting you create variables within an intercepted HTTP request, replace those variables with different sets of payloads, and send a series of requests to an API provider.</p>
<p>Any part of a captured HTTP request can be transformed into a variable, or <em>attack position</em>, by surrounding it with <b>§</b> symbols. Payloads can be anything from a wordlist to a set of numbers, symbols, and any other type of input that will help you test how an API provider will respond. For example, in <a href="#figure4-10" id="figureanchor4-10">Figure 4-10</a>, we’ve selected the password as the attack position, as indicated by the § symbols.</p>
<figure>
<img alt="Screenshot of the Burp Suite Positions tab with a payload position set around the password field and the Sniper attack type selected" class="keyline" src="image_fi/502444c04/F04010.png"/>
<figcaption><p><a id="figure4-10">Figure 4-10</a>: An Intruder attack against api.twitter.com</p></figcaption>
</figure>
<p>This means that <code>SuperPass321!</code> will be replaced with values from the list of strings found in Payloads. Navigate to the Payloads tab to see these strings, shown in <a href="#figure4-11" id="figureanchor4-11">Figure 4-11</a>.</p>
<figure>
<img alt="Screenshot of the Burp Suite Payloads tab with a Payload Options box that lists strings such as Password1, Password2, APIhacking4tw, and more" class="keyline" src="image_fi/502444c04/F04011.png"/>
<figcaption><p><a id="figure4-11">Figure 4-11</a>: The Intruder Payloads with a list of passwords</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_82" title="82"/>Based on the payload list shown here, Intruder will perform one request per payload listed for a total of nine requests. When an attack is started, each of the strings under Payload Options will replace <code>SuperPass123!</code> in turn and generate a request to the API provider.</p>
<p>The Intruder attack types determine how the payloads are processed. As you can see in <a href="#figure4-12" id="figureanchor4-12">Figure 4-12</a>, there are four different attack types: sniper, battering ram, pitchfork, and cluster bomb.</p>
<figure>
<img alt="Screenshot of the Burp Suite Positions Tab with Sniper selected in the Attack type field" class="keyline" src="image_fi/502444c04/F04012.png"/>
<figcaption><p><a id="figure4-12">Figure 4-12</a>: The Intruder attack types</p></figcaption>
</figure>
<p><em>Sniper </em>is the simplest attack type; it replaces the added attack position with a string provided from a single set of payloads. A sniper attack is limited to using a single payload, but it can have several attack positions. A sniper attack will replace one attack position per request, cycling through the different attack positions in each request. If you were attacking three different variables with a single payload, it would look something like this:</p>
<pre><code>§<var>Variable1</var>§<em>, </em>§<var>variable2</var>§<em>, </em>§<var>variable3</var>§
Request 1:    <b>Payload1</b>, variable2, variable3
Request 2:    Variable1, <b>payload1</b>, variable3
Request 3:    Variable1, variable2, <b>payload1</b></code></pre>
<p><em>Battering ram</em> is like the sniper attack in that it also uses one payload, but it will use that payload across all attack positions in a request. If you were testing for SQL injection across several input positions within a request, you could fuzz them all simultaneously with battering ram.</p>
<p><em>Pitchfork</em> is used for testing multiple payload combinations at the same time. For example, if you have a list of leaked usernames and password combinations, you could use two payloads together to test whether any of the credentials were used with the application being tested. However, this attack doesn’t try out different combinations of payloads; it will only cycle through the payload sets like this: <em>user1:pass1</em>, <em>user2:pass2</em>, <em>user3:pass3</em>.</p>
<p><em>Cluster bomb </em>will cycle through all possible combinations of the payloads provided. If you provide two usernames and three passwords, the payloads would be used in the following pairs: <em>user1:pass1</em>, <em>user1:pass2</em>, <em>user1:pass3</em>, <em>user2:pass1</em>, <em>user2:pass2</em>, <em>user2:pass3</em>.</p>
<p><span epub:type="pagebreak" id="Page_83" title="83"/>The attack type to use depends on your situation. If you’re fuzzing a single attack position, use sniper. If you’re fuzzing several attack positions at once, use battering ram. When you need to test set combinations of payloads, use pitchfork. For password-spraying efforts, use cluster bomb.</p>
<p>Intruder should help you find API vulnerabilities such as broken object level authorization, excessive data exposure, broken authentication, broken function level authorization, mass assignment, injection, and improper assets management. Intruder is essentially a smart fuzzing tool that provides a list of results containing the individual requests and responses. You can interact with the request you’d like to fuzz and replace the attack position with the input of your choice. These API vulnerabilities are typically discovered by sending the right payload to the right location.</p>
<p>For example, if an API were vulnerable to authorization attacks like BOLA, we would be able to replace requested resource IDs with a payload containing a list of possible resource IDs. We could then start the attack with Intruder, which would make all the requests and provide us with a list of results to review. I will cover API fuzzing in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> and API authorization attacks in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Extending the Power of Burp Suite</h2>
<p class="BoxBodyFirst">One of the major benefits of Burp Suite is that you can install custom extensions. These extensions can help you shape Burp Suite into the ultimate API hacking tool. To install extensions, use the search bar to find the one you’re looking for and then click the <b>I</b><b>nstall</b> button. Some extensions require additional resources and have more complex installation requirements. Make sure you follow the install instructions for each extension. I recommend adding the following ones.</p>
<h3>Autorize</h3>
<p class="BoxBodyFirst">Autorize is an extension that helps automate authorization testing, particularly for BOLA vulnerabilities. You can add the tokens of UserA and UserB accounts and then perform a bunch of actions to create and interact with resources as UserA. Also, Autorize can automatically attempt to interact with UserA’s resources with the UserB account. Autorize will highlight any interesting requests that may be vulnerable to BOLA.</p>
<h3>JSON Web Tokens</h3>
<p class="BoxBodyFirst">The JSON Web Tokens extension helps you dissect and attack JSON Web Tokens. We will use this extension to perform authorization attacks later in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>.</p>
<h3>InQL Scanner</h3>
<p class="BoxBodyFirst">InQL is an extension that will aid us in our attacks against GraphQL APIs. We will make the most out of this extension in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>.</p>
<h3><span epub:type="pagebreak" id="Page_84" title="84"/>IP Rotate</h3>
<p class="BoxBodyFirst">IP Rotate allows you to alter the IP address you are attacking from to indicate different cloud hosts in different regions. This is extremely useful against API providers that simply block attacks based on IP address.</p>
<h3>Bypass WAF</h3>
<p class="BoxBodyFirst">The WAF Bypass extension adds some basic headers to your requests in order to bypass some web application firewalls (WAFs). Some WAFs can be tricked by the inclusion of certain IP headers in the request. WAF Bypass saves you from manually adding headers such as <code>X-Originating-IP</code>, <code>X-Forwarded-For</code>, <code>X-Remote-IP</code>, and <code>X-Remote-Addr</code>. These headers normally include an IP address, and you can specify an address that you believe to be permitted, such as the target’s external IP address (127.0.0.1) or an address you suspect to be trusted.</p>
<p>In the lab at the end of this chapter, I will walk you through interacting with an API, capturing the traffic with Burp Suite, and using Intruder to discover a list of existing user accounts. To learn more about Burp Suite, visit the PortSwigger WebSecurity Academy at <a class="LinkURL" href="https://portswigger.net/web-security">https://portswigger.net/web-security</a> or consult the Burp Suite documentation at <a class="LinkURL" href="https://portswigger.net/burp/documentation">https://portswigger.net/burp/documentation</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502444c04-0004">Crafting API Requests in Postman, an API Browser</h2>
<p class="BodyFirst">We’ll use Postman to help us craft API requests and visualize responses. You can think of Postman as a web browser built for interacting with APIs. Originally designed as a REST API client, it now has all sorts of capabilities for interacting with REST, SOAP, and GraphQL. The application is packed with features for creating HTTP requests, receiving responses, scripting, chaining requests together, creating automated testing, and managing API documentation.</p>
<p>We’ll be using Postman as our browser of choice for sending API requests to a server, rather than defaulting to Firefox or Chrome. This section covers the Postman features that matter the most and includes instructions for using the Postman request builder, an overview of working with collections, and some basics around building request tests. Later in this chapter, we will configure Postman to work seamlessly with Burp Suite.</p>
<p>To set up Postman on Kali, open your terminal and enter the following commands:</p>
<pre><code>$ <b>sudo wget https://dl.pstmn.io/download/latest/linux64 -O postman-linux-x64.tar.gz</b>
$ <b>sudo tar -xvzf postman-linux-x64.tar.gz -C /opt</b>
$ <b>sudo ln -s /opt/Postman/Postman /usr/bin/postman</b></code></pre>
<p>If everything has gone as planned, you should be able to launch Postman by entering <code>postman</code> in your terminal. Sign up for a free account using an email address, username, and password. Postman uses accounts <span epub:type="pagebreak" id="Page_85" title="85"/>for collaboration and to synchronize information across devices. Alternatively, you can skip the login screen by clicking the <b>Skip signing in and take me straight to the app</b> button.</p>
<p>Next, you’ll need to go through the FoxyProxy setup process a second time (refer to the <span class="xref" itemid="xref_target_“Setting Up FoxyProxy”">“Setting Up FoxyProxy”</span> section earlier in this chapter) so that Postman can intercept requests. Return to step 4 and add a new proxy. Add the same host IP address, <b>127.0.0.1</b>, and set the port to <b>5555</b>, the default port for Postman’s proxy. Update the name of the proxy under the General tab to <b>Postman</b> and save. Your FoxyProxy tab should now resemble <a href="#figure4-13" id="figureanchor4-13">Figure 4-13</a>.</p>
<figure>
<img alt="Screenshot of the FoxyProxy interface with the Hackz, Postman, and Default proxies enabled" class="keyline" src="image_fi/502444c04/F04013.png"/>
<figcaption><p><a id="figure4-13">Figure 4-13</a>: FoxyProxy with the Hackz and Postman proxies set up</p></figcaption>
</figure>
<p>From the launchpad, open a new tab just like you would in any other browser by clicking the new tab button (+) or using the <span class="KeyCaps">ctrl</span>-T shortcut. As you can see in <a href="#figure4-14" id="figureanchor4-14">Figure 4-14</a>, Postman’s interface can be a little overwhelming if you aren’t familiar with it.</p>
<figure>
<img alt="Screenshot of the Postman interface with many windows and menu items displaying GET requests and JSON data" class="keyline" src="image_fi/502444c04/F04014.png"/>
<figcaption><p><a id="figure4-14">Figure 4-14</a>: The main landing page of Postman with a response from an API collection</p></figcaption>
</figure>
<p>Let’s start by discussing the request builder, which you’ll see when you open a new tab.</p>
<h3 id="h2-502444c04-0006"><span epub:type="pagebreak" id="Page_86" title="86"/>The Request Builder</h3>
<p class="BodyFirst">The request builder, shown in <a href="#figure4-15" id="figureanchor4-15">Figure 4-15</a>, is where you can craft each request by adding parameters, authorization headers, and so on.</p>
<figure>
<img alt="Screenshot of Postman interface with a form field for entering a request URL, a drop-down menu allowing you to select an HTTP method, and a Send button" class="keyline" src="image_fi/502444c04/F04015.png"/>
<figcaption><p><a id="figure4-15">Figure 4-15</a>: The Postman request builder</p></figcaption>
</figure>
<p>The request builder contains several tabs useful for precisely constructing the parameters, headers, and body of a request. The <em>Params </em>tab is where you can add query and path parameters to a request. Essentially, this allows you to enter in various key/value pairs along with a description of those parameters. A great feature of Postman is that you can leverage the power of variables when creating your requests. If you import an API and it contains a variable like <em>:company</em> in <em>http://example.com/</em><b><i>:company</i></b><em>/profile</em>, Postman will automatically detect this and allow you to update the variable to a different value, such as the actual company name. We’ll discuss collections and environments later in this section.</p>
<p>The <em>Authorization </em>tab includes many standard forms of authorization headers for you to include in your request. If you’ve saved a token in an environment, you can select the type of token and use the variable’s name to include it. By hovering your mouse over a variable name, you can see the associated credentials. Several authorization options are available under the Type field that will help you automatically format the authorization header. Authorization types include several expected options such as no auth, API key, Bearer Token, and Basic Auth. In addition, you could use the authorization that is set for the entire collection by selecting <b>inherit auth from parent</b>.</p>
<p>The <em>Headers</em> tab includes the key and value pairs required for certain HTTP requests. Postman has some built-in functionality to automatically create necessary headers and to suggest common headers with preset options.</p>
<p>In Postman, values for parameters, headers, and parts of body work can be added by entering information within the Key column and the corresponding Value column (see <a href="#figure4-16" id="figureanchor4-16">Figure 4-16</a>). Several headers will automatically be created, but you can add your own headers when necessary.</p>
<p>Within the keys and values, you also have the ability to use collection variables and environmental variables. (We’ll cover collections later in this section.) For example, we’ve represented the value for the password key using the variable name <code>{admin_creds}</code>.</p>
<span epub:type="pagebreak" id="Page_87" title="87"/><figure>
<img alt="Screenshot of the Postman Headers tab displaying a table with two columns, Key and Value. The Key column includes headers such as User-Agent and Content-Type, and the values include endpoints, such as PostmanRuntime/7.28.3." class="keyline" src="image_fi/502444c04/F04016.png"/>
<figcaption><p><a id="figure4-16">Figure 4-16</a>: Postman key and value headers</p></figcaption>
</figure>
<p>The request builder can also run pre-request scripts, which can chain together different requests that depend on each other. For example, if request 1 issues a resource value that is needed for the following request, you can script that resource value to automatically be added to request 2.</p>
<p>Within Postman’s request builder, you can use several panels to craft proper API requests and review responses. Once you’ve sent a request, the response will show up in the response panel (see <a href="#figure4-17" id="figureanchor4-17">Figure 4-17</a>).</p>
<figure>
<img alt="Screenshot of Postman interface showing Body and Headers tabs and a Status Code bar" class="keyline" src="image_fi/502444c04/F04017.png"/>
<figcaption><p><a id="figure4-17">Figure 4-17</a>: The Postman request and response panels</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_88" title="88"/>You can set the response panel either to the right or below the request panel. By pressing <span class="KeyCaps">ctrl-alt</span>-V, you can switch the request and response panels between single-pane and split-pane views.</p>
<p>In <a href="#table4-2" id="tableanchor4-2">Table 4-2</a>, I have separated the items into the request panels and the response panels.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table4-2">Table 4-2</a>: Request Builder Panels</p></figcaption>
<table border="1" id="table-502444c04-0002">
<thead>
<tr>
<td><b>Panel</b></td>
<td><b>Purpose</b></td>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2"><i>Request</i></td>
</tr>
<tr>
<td>HTTP request method</td>
<td>The request method is found to the left of the request URL bar (at the top left of <a href="#figure4-17">Figure 4-17</a> where there is a drop-down menu for GET). The options include all the standard requests: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. It also includes several other request methods such as COPY, LINK, UNLINK, PURGE, LOCK, UNLOCK, PROPFIND, and VIEW.</td>
</tr>
<tr>
<td>Body</td>
<td>In <a href="#figure4-17">Figure 4-17</a>, this is the third tab in the request pane. This allows for adding body data to the request, which is primarily used for adding or updating data when using PUT, POST, or PATCH.</td>
</tr>
<tr>
<td>Body options</td>
<td>Body options are the format of the response. These are found below the Body tab when it is selected. The options currently include none, form-data, x-www-formurlencoded, raw, binary, and GraphQL. These options let you view response data in various forms.</td>
</tr>
<tr>
<td>Pre-request script</td>
<td>JavaScript-based scripts that can be added and executed before a request is sent. This can be used to create variables, help troubleshoot errors, and change request parameters.</td>
</tr>
<tr>
<td>Test</td>
<td>This space allows for writing JavaScript-based tests used to analyze and test the API response. This is used to make sure the API responses are functioning as anticipated.</td>
</tr>
<tr>
<td>Settings</td>
<td>Various settings for how Postman will handle requests.</td>
</tr>
<tr>
<td colspan="2"><i>Response</i></td>
</tr>
<tr>
<td>Response body</td>
<td>The body of the HTTP response. If Postman were a typical web browser, this would be the main window to view the requested information.</td>
</tr>
<tr>
<td>Cookies</td>
<td>This shows all the cookies, if any, included with the HTTP response. This tab will include information about the cookie type, cookie value, path, expiration, and cookie security flags.</td>
</tr>
<tr>
<td>Headers</td>
<td>This is where all the HTTP response headers are located.</td>
</tr>
<tr>
<td>Test results</td>
<td>If you created any tests for your request, this is where you can view the results of those tests.</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-502444c04-0007"><span epub:type="pagebreak" id="Page_89" title="89"/>Environments</h3>
<p class="BodyFirst">An <em>environment</em> provides a way to store and use the same variables across APIs. An<em> environmental variable</em> is a value that will replace a variable across an environment. For example, say you’re attacking a production API but discover a<em> test</em> version of the production API as well; you’ll likely want to use an environment to share values between your requests to the two APIs. After all, there is a chance the production and test APIs share values such as API tokens, URL paths, and resource IDs.</p>
<p>To create environmental variables, find <b>Environment</b> at the top right of the request builder (the drop-down menu that says “No Environment” by default) and then press <span class="KeyCaps">ctrl</span>-N to bring up the <b>Create New</b> panel and select <b>Environment</b>, as shown in <a href="#figure4-18" id="figureanchor4-18">Figure 4-18</a>.</p>
<figure>
<img alt="Screenshot of the Postman Create New menu with the Environment option highlighted" class="keyline" src="image_fi/502444c04/F04018.png"/>
<figcaption><p><a id="figure4-18">Figure 4-18</a>: The Create New panel in Postman</p></figcaption>
</figure>
<p>You can give an environment variable both an initial value and a current value (see <a href="#figure4-19" id="figureanchor4-19">Figure 4-19</a>). An<em> initial value </em>will be shared if you share your Postman environment with a team, whereas a current value is not shared and is only stored locally. For example, if you have a private key, you can store the private key as the current value. Then you will be able to use the variable in places where you would have to paste the private key.</p>
<span epub:type="pagebreak" id="Page_90" title="90"/><figure>
<img alt="Screenshot of the Postman Manage Environments window with the admin_credz variable and its current value" class="keyline" src="image_fi/502444c04/F04019.png"/>
<figcaption><p><a id="figure4-19">Figure 4-19</a>: The Manage Environments window in Postman showing the variable <span class="LiteralInCaption"><code>admin_creds</code></span> with a current value of <span class="LiteralInCaption"><code>This_</code></span><span class="LiteralInCaption"><code>i</code></span><span class="LiteralInCaption"><code>s_hidd3n</code></span></p></figcaption>
</figure>
<h3 id="h2-502444c04-0008">Collections</h3>
<p class="BodyFirst"><em>Collections </em>are groups of API requests that can be imported into Postman. If an API provider offers a collection, you won’t have to physically type in every single request. Instead, you can just import its collection. The best way to understand this functionality is to download a public API collection to your Postman from <a class="LinkURL" href="https://www.postman.com/explore/collections">https://www.postman.com/explore/collections</a>. For examples throughout this section, I will be referencing the Age of Empires II collection.</p>
<p>The Import button lets you import collections, environments, and API specifications. Currently, Postman supports OpenAPI 3.0, RAML 0.8, RAML 1.0, GraphQL, cURL, WADL, Swagger 1.2, Swagger 2.0, Runscope, and DHC. You can make your testing quite a bit easier if you can import your target API specification. Doing this will save you the time of having to craft all the API requests by hand.</p>
<p>Collections, environments, and specifications can all be imported as a file, folder, link, or raw test or through linking your GitHub account. For example, you can import the API for the classic PC game <em>Age of Empires II</em> from<em> https://age-of-empires-2-api.herokuapp.com/apispec.json</em> as follows:</p>
<ol class="decimal">
<li value="1">Click the <b>Import</b> button found at the top left of Postman.</li>
<li value="2">Select the <b>Link</b> tab (see <a href="#figure4-20" id="figureanchor4-20">Figure 4-20</a>).</li>
<li value="3">Paste the URL to the API specification and click <b>Continue</b>.</li>
<li value="4">On the Confirm Your Import screen, click <b>Import</b>.</li>
</ol>
<span epub:type="pagebreak" id="Page_91" title="91"/><figure>
<img alt="Screenshot of the Postman Import Link tab with a form field for entering a URL and a Continue button" class="keyline" src="image_fi/502444c04/F04020.png"/>
<figcaption><p><a id="figure4-20">Figure 4-20</a>: Importing an API specification in Postman using the Link tab in the Import panel</p></figcaption>
</figure>
<p>Once this is complete, you should have the Age of Empires II collection saved in Postman. Now test it out. Select one of the requests in the collection shown in <a href="#figure4-21" id="figureanchor4-21">Figure 4-21</a> and click <b>Send</b>.</p>
<figure>
<img alt="Screenshot of the Postman interface populated with requests from the Age of Empires 2 collection and a list of what each does" class="keyline" src="image_fi/502444c04/F04021.png"/>
<figcaption><p><a id="figure4-21">Figure 4-21</a>: The Collections sidebar with the imported Age of Empires II API GET requests</p></figcaption>
</figure>
<p>For the request to work, you might have to first check the collection’s variables to make sure they’re set to the correct values. To see a collection’s variables, you will need to navigate to the Edit Collection window by selecting <b>Edit</b> within the <b>View More Actions</b> button (represented by three circles, as shown in <a href="#figure4-22" id="figureanchor4-22">Figure 4-22</a>).</p>
<span epub:type="pagebreak" id="Page_92" title="92"/><figure>
<img alt="Screenshot of a GET request selected in the Postman interface and the Edit option highlighted in a pop-up menu" class="keyline" src="image_fi/502444c04/F04022.png"/>
<figcaption><p><a id="figure4-22">Figure 4-22</a>: Editing a collection within Postman</p></figcaption>
</figure>
<p>Once you’re in the Edit Collection window, select <b>Variables</b>, as shown in <a href="#figure4-23" id="figureanchor4-23">Figure 4-23</a>.</p>
<figure>
<img alt="Screenshot of the Variables tab in Postman with the baseURL variable selected" class="keyline" src="image_fi/502444c04/F04023.png"/>
<figcaption><p><a id="figure4-23">Figure 4-23</a>: The Age of Empires II API collection variables</p></figcaption>
</figure>
<p>For example, the Age of Empires II API collection uses the variable <code>{{baseUrl}}</code>. The problem with the current <code>{{baseUrl}}</code> is that there are no values. We need to update this variable to the full URL of the public API, <em>https://age-of-empires-2-api.herokuapp.com/api/v1</em>. Add the full URL and click <b>Save</b> to update your changes (see <a href="#figure4-24" id="figureanchor4-24">Figure 4-24</a>).</p>
<figure>
<img alt="Screenshot of the Variables tab in Postman with the initial value of the baseURL set to https://age-of-empires-2-api.herokuapp.com/api/v1" class="keyline" src="image_fi/502444c04/F04024.png"/>
<figcaption><p><a id="figure4-24">Figure 4-24</a>: The updated <span class="LiteralInCaption"><code>baseURL</code></span> variable</p></figcaption>
</figure>
<p>Now that the variable is updated, you can choose one of the requests and click <b>Send</b>. If you are successful, you should receive a response similar to that shown in <a href="#figure4-25" id="figureanchor4-25">Figure 4-25</a>.</p>
<span epub:type="pagebreak" id="Page_93" title="93"/><figure>
<img alt="Screenshot of the Postman interface populated with an HTTP response" class="keyline" src="image_fi/502444c04/F04025.png"/>
<figcaption><p><a id="figure4-25">Figure 4-25</a>: Successfully using the Age of Empires II API collection in Postman</p></figcaption>
</figure>
<p>Whenever you import a collection and run into errors, you can use this process to troubleshoot the collection’s variables. Also be sure to check that you haven’t omitted any authorization requirements.</p>
<h3 id="h2-502444c04-0009">The Collection Runner</h3>
<p class="BodyFirst">The Collection Runner allows you to run all the saved requests in a collection (see <a href="#figure4-26" id="figureanchor4-26">Figure 4-26</a>). You can select the collection you want to run, the environment you want to pair it with, how many times you want to run the collection, and a delay in case there are rate-limiting requirements.</p>
<figure>
<img alt="Screenshot of the Postman Collection Runner listing a variety of GET and POST requests" class="" src="image_fi/502444c04/F04026.png"/>
<figcaption><p><a id="figure4-26">Figure 4-26</a>: The Postman Collection Runner</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_94" title="94"/>The requests can also be put into a specific order. Once the Collection Runner has run, you can review the Run Summary to see how each request was handled. For instance, if I open the Collection Runner, select Twitter API v2, and run the Collection Runner, I can see an overview of all API requests in that collection.</p>
<h3 id="h2-502444c04-0010">Code Snippets</h3>
<p class="BodyFirst">In addition to the panels, you should also be aware of the code snippets feature. At the top-right of the request pane, you’ll see a Code button. This button can be used to translate the built request into many different formats, including cURL, Go, HTTP, JavaScript, NodeJS, PHP, and Python. This is a helpful feature when we craft a request with Postman and then need to pivot to another tool. You can craft a complicated API request in Postman, generate a cURL request, and then use that with other command line tools.</p>
<h3 id="h2-502444c04-0011">The Tests Panel</h3>
<p class="BodyFirst">The Tests panel allows you to create scripts that will be run against responses to your requests. If you are not a programmer, you will appreciate that Postman has made prebuilt code snippets available on the right side of the Tests panel. You can easily build a test by finding a prebuilt code snippet, clicking it, and adjusting the test to fit your testing needs. I suggest checking out the following snippets:</p>
<ul>
<li><code>Status code: Code is 200</code></li>
<li><code>Response time is less than 200ms</code></li>
<li><code>Response body: contains string</code></li>
</ul>
<p>These JavaScript code snippets are fairly straightforward. For instance, the test for <code>Status code: Code is 200</code> is as follows:</p>
<pre><code>pm.test("Status code is 200", function () {
    pm.response.to.have.status(200);
});</code></pre>
<p>You can see that the name of the test that will be displayed in the test results is “Status code is 200.” The function is checking to make sure the Postman response has the status 200. We can easily adjust JavaScript to check for any status code by simply updating the <code>(200)</code> to our desired status code and changing the test name to fit. For example, if we wanted to check for the status code 400, we could change the code as follows:</p>
<pre><code>pm.test("Status code is 400", function () {
    pm.response.to.have.status(400);
});</code></pre>
<p>It’s as simple as that! You really don’t have to be a programmer to understand these JavaScript code snippets.</p>
<p><span epub:type="pagebreak" id="Page_95" title="95"/><a href="#figure4-27" id="figureanchor4-27">Figure 4-27</a> shows a series of tests included with the API request to the AOE2 public API. The tests include a check for a 200 status code, less than 200 ms latency, and “Persians” within the response string.</p>
<figure>
<img alt="Screenshot of the Postman Tests panel in which a test is written and a list of requests are labeled “Pass”" class="keyline" src="image_fi/502444c04/F04027.png"/>
<figcaption><p><a id="figure4-27">Figure 4-27</a>: AOE2 public API tests</p></figcaption>
</figure>
<p>After your tests are configured, you can check the Test Results tab of a response to see if the tests succeeded or failed. A good practice with creating tests is to make sure the tests fail. Tests are only effective if they pass and fail when they are supposed to. Therefore, send a request that would create conditions you would expect to pass or fail the test to ensure it is functioning properly. For more information about creating test scripts, check out the Postman documentation (<a class="LinkURL" href="https://learning.postman.com/docs/writing-scripts/test-scripts">https://learning.postman.com/docs/writing-scripts/test-scripts</a>).</p>
<p>You now have many other options to explore in Postman. Like Burp Suite, Postman has a Learning Center (<a class="LinkURL" href="https://learning.postman.com">https://learning.postman.com</a>) for online resources for those who want to develop a deeper understanding of the software. Alternatively, if you would like to review the Postman documentation, you can find it at <a class="LinkURL" href="https://learning.postman.com/docs/getting-started/introduction">https://learning.postman.com/docs/getting-started/introduction</a>.</p>
<h2 id="h1-502444c04-0005">Configuring Postman to Work with Burp Suite</h2>
<p class="BodyFirst">Postman is useful for interacting with APIs, and Burp Suite is a powerhouse for web application testing. If you combine these applications, you can configure and test an API in Postman and then proxy the traffic over to Burp Suite to brute-force directories, tamper with parameters, and fuzz all the things.</p>
<p>As when you set up FoxyProxy, you’ll need to configure the Postman proxy to send traffic over to Burp Suite using the following steps (see <a href="#figure4-28" id="figureanchor4-28">Figure 4-28</a>):</p>
<ol class="decimal">
<li value="1">Open Postman settings by pressing <span class="KeyCaps">ctrl</span>-, (comma) or navigating to <b>File</b><span class="MenuArrow">▶</span><b>Settings</b>.</li>
<li value="2">Click the <b>Proxy</b> tab.</li>
<li value="3">Click the checkbox for adding a custom proxy configuration.</li>
<li value="4">Make sure to set the proxy server to <b>127.0.0.1</b>.</li>
<li value="5">Set the proxy server port to <b>8080</b>.</li>
<li value="6">Select the <b>General</b> tab and turn SSL certificate verification <b>Off</b>.</li>
<li value="7"><span epub:type="pagebreak" id="Page_96" title="96"/>In Burp Suite, select the <b>Proxy</b> tab.</li>
<li value="8">Click the button to turn Intercept<b> On</b>.</li>
</ol>
<figure>
<img alt="Screenshot of the Postman Settings Proxy tab with the following checkboxes selected: use the system proxy, add a custom proxy configuration, HTTP, and HTTPS" class="keyline" src="image_fi/502444c04/F04028.png"/>
<figcaption><p><a id="figure4-28">Figure 4-28</a>: Postman’s proxy settings configured to interact with Burp Suite</p></figcaption>
</figure>
<p>Try sending a request using Postman; if it is intercepted by Burp Suite, you’ve properly configured everything. Now you can leave the proxy on and toggle Burp Suite’s “turn Intercept on” function when you want to capture requests and responses.</p>
<h2 id="h1-502444c04-0006">Supplemental Tools</h2>
<p class="BodyFirst">This section is meant to provide additional options and to aid those who are limited by the features available in Burp Suite CE. The following tools are excellent at what they do, open source, and free. In particular, the API scanning tools covered here serve several purposes when you’re actively testing your target. Tools such as Nikto and OWASP ZAP can help you actively discover API endpoints, security misconfigurations, and interesting paths, and they provide some surface-level testing of an API. In other words, they are useful when you start actively engaging with a target, whereas tools such as Wfuzz and Arjun will be more useful once you’ve discovered an API and want to narrow the focus of your testing. Use these tools to actively test APIs to discover unique paths, parameters, files, and functionality. Each of these tools has its own unique focus and purpose that will supplement functionality lacking in the free Burp Suite Community Edition.</p>
<h3 id="h2-502444c04-0012"><span epub:type="pagebreak" id="Page_97" title="97"/>Performing Reconnaissance with OWASP Amass</h3>
<p class="BodyFirst">OWASP Amass is an open-source information-gathering tool that can be used for passive and active reconnaissance. This tool was created as a part of the OWASP Amass project, led by Jeff Foley. We will be using Amass to discover the attack surface of our target organizations. With as little as a target’s domain name, you can use Amass to scan through many internet sources for your target’s associated domains and subdomains to get a list of potential target URLs and APIs.</p>
<p>If OWASP Amass is not installed, use the following command:</p>
<pre><code>$ <b>sudo</b><b> apt-get install amass</b></code></pre>
<p>Amass is pretty effective without much setup. However, you can make it into an information collection powerhouse by setting it up with API keys from various sources. I recommend at least setting up accounts with GitHub, Twitter, and Censys. Once you’ve set up these accounts, you can generate API keys for these services and plug them into Amass by adding them to Amass’s configuration file, <em>config.ini</em>. The Amass GitHub repository has a template <em>config.ini</em> file that you can use at <a class="LinkURL" href="https://github.com/OWASP/Amass/blob/master/examples/config.ini">https://github.com/OWASP/Amass/blob/master/examples/config.ini</a>.</p>
<p>On Kali, Amass will attempt to automatically find the <em>config.ini</em> file at the following location:</p>
<pre><code>$ <b>HOME/.config/amass/config.ini</b></code></pre>
<p>To download the content of the sample <em>config.ini</em> file and save it to the default Amass config file location, run the following command from the terminal:</p>
<pre><code>$ <b>mkdir $HOME/.config/amass</b>
$ <b>curl https://raw.githubusercontent.com/OWASP/Amass/master/examples/config.ini &gt;$HOME/.config/amass/config.ini</b></code></pre>
<p>Once you have that file downloaded, you can edit it and add the API keys you would like to include. It should look something like this:</p>
<pre><code># https://umbrella.cisco.com (Paid-Enterprise)
# The apikey must be an API access token created through the Investigate management UI
#[data_sources.Umbrella]
#apikey =

#https://urlscan.io (Free)
#URLScan can be used without an API key
#apikey =

# https://virustotal.com (Free)
#[data_sources.URLScan]
#apikey =</code></pre>
<p><span epub:type="pagebreak" id="Page_98" title="98"/>As you can see, you can remove the comment (<code>#</code>) and simply paste in the API key for whichever service you would like to use. The <em>config.ini</em> file even indicates which keys are free. You can find a list of the sources with APIs you can use to enhance Amass at <a class="LinkURL" href="https://github.com/OWASP/Amass">https://github.com/OWASP/Amass</a>. Although it will be a little time-consuming, I recommend taking advantage of at least all the free sources listed under APIs.</p>
<h3 id="h2-502444c04-0013">Discovering API Endpoints with Kiterunner</h3>
<p class="BodyFirst">Kiterunner (<a class="LinkURL" href="https://github.com/assetnote/kiterunner">https://github.com/assetnote/kiterunner</a>) is a content discovery tool designed specifically for finding API resources. Kiterunner is built with Go, and while it can scan at a speed of 30,000 requests per second, it takes into account the fact that load balancers and web application firewalls will likely enforce rate limiting.</p>
<p>When it comes to APIs, Kiterunner’s search techniques outperform other content discovery tools such as dirbuster, dirb, Gobuster, and dirsearch because this tool was built with API awareness. Its wordlists, request methods, parameters, headers, and path structures are all focused on finding API endpoints and resources. Of note, the tool includes data from 67,500 Swagger files. Kiterunner has also been designed to detect the signature of different APIs, including Django, Express, FastAPI, Flask, Nginx, Spring, and Tomcat (just to name a few).</p>
<p>One of the tool’s most useful capabilities, which we’ll leverage in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, is the request replay feature. If Kiterunner detects endpoints when scanning, it will display this result on the command line. You can then dive deeper into the result by exploring the exact request that triggered the result.</p>
<p>To install Kiterunner, run the following commands:</p>
<pre><code>$ <b>git clone https://github.com/assetnote/kiterunner.git</b>
$ <b>cd kiterunner</b>
$ <b>make build</b>
$ <b>sudo ln -s $(pwd)/dist/kr /usr/local/bin/kr</b></code></pre>
<p>You should then be able to use Kiterunner from the command line by entering the following:</p>
<pre><code>$ <b>kr</b>
kite is a context based webscanner that uses common api paths for content discovery of an applications api paths.

Usage:
  kite [command]

Available Commands:
  brute       brute one or multiple hosts with a provided wordlist
  help        help about any command
  kb          manipulate the kitebuilder schema
  scan        scan one or multiple hosts with a provided wordlist
  version     version of the binary you're running
  wordlist    look at your cached wordlists and remote wordlists

<span epub:type="pagebreak" id="Page_99" title="99"/>Flags:
      --config string    config file (default is $HOME/.kiterunner.yaml)
  -h, --help             help for kite
  -o, --output string    output format. can be json,text,pretty (default "pretty")
  -q, --quiet            quiet mode. will mute unnecessary pretty text
  -v, --verbose string   level of logging verbosity. can be error,info,debug,trace (default "info")

Use "kite [command] --help" for more information about a command.</code></pre>
<p>You can supply Kiterunner with various wordlists, which it then uses as payloads for a series of requests. These requests will help you discover interesting API endpoints. Kiterunner allows you to use Swagger JSON files, Assetnote’s<em> .kites </em>files, and <em>.txt</em> wordlists. Currently, Assetnote releases its wordlists, which contain search terms collected from its internet-wide scans, on a monthly basis. All of the wordlists are hosted at <a class="LinkURL" href="https://wordlists.assetnote.io">https://wordlists.assetnote.io</a>. Create an API wordlists directory as follows:</p>
<pre><code>$ <b>mkdir -p ~/api/wordlists</b></code></pre>
<p>You can then select your desired wordlists and download them to the <em>/api/wordlists </em>directory:</p>
<pre><code>$ <b>curl https://wordlists-cdn.assetnote.io/data/automated/httparchive_apiroutes_2021_06_28.txt &gt; latest_api_wordlist.txt</b>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 6651k  100 6651k    0     0  16.1M      0 --:--:-- --:--:-- --:--:-- 16.1M</code></pre>
<p>You can replace <em>httparchive_apiroutes_2021_06_028.txt</em> with whichever wordlists suit you best. Alternatively, download all the Assetnote wordlists at once:</p>
<pre><code>$ <b>wget -r --no-parent -R "index.html*" https://wordlists-cdn.assetnote.io/data/ -nH</b></code></pre>
<p>Be warned that downloading all of the Assetnote wordlists takes up about 2.2GB of space, but storing them is definitely worth it.</p>
<h3 id="h2-502444c04-0014">Scanning for Vulnerabilities with Nikto</h3>
<p class="BodyFirst">Nikto is a command line web application vulnerability scanner that is quite effective at information gathering. I use Nikto immediately after discovering the existence of a web application, as it can point me toward the application’s interesting aspects. Nikto will provide you with information about the target web server, security misconfigurations, and other web application vulnerabilities. Since Nikto is included in Kali, it should not require any special setup.</p>
<p>To scan a domain, use the following command:</p>
<pre><code>$ <b>nikto -h https://example.com</b></code></pre>
<p><span epub:type="pagebreak" id="Page_100" title="100"/>To see the additional Nikto options, enter <code class="bold">nikto -Help</code> on the command line. A few options you may find useful include <code>-output </code><var>filename</var> for saving the Nikto results to a specified file and <code>-maxtime</code> <var>#ofseconds</var> to limit how long a Nikto scan will take.</p>
<p>The results from a Nikto scan will include an app’s allowed HTTP methods, interesting header information, potential API endpoints, and other directories that could be worth checking out. For additional information about Nikto, review the documentation found at <em>https://cirt.net/nikto2-docs</em>.</p>
<h3 id="h2-502444c04-0015">Scanning for Vulnerabilities with OWASP ZAP</h3>
<p class="BodyFirst">OWASP developed ZAP, an open-source web application scanner, and it’s another essential web application security testing tool. OWASP ZAP should be included in Kali, but if it isn’t, you can clone it from GitHub at <a class="LinkURL" href="https://github.com/zaproxy/zaproxy">https://github.com/zaproxy/zaproxy</a>.</p>
<p>ZAP has two components: automated scan and manual explore. ZAP’s <em>automated scan</em> performs web crawling, detects vulnerabilities, and tests web application responses by altering request parameters. Automated scan is great for detecting the surface directories of a web application, which includes discovering API endpoints. To run it, enter the target URL into the ZAP interface and click the button to start the attack. Once the scan has run its course, you’ll receive a list of alerts that are categorized by the severity of the finding. The issue with ZAP’s automated scan is that it can be riddled with false positives, so it is important to examine and validate the alerts. The testing is also limited to the surface of a web application. Unless there are unintentionally exposed directories, ZAP will not be able to infiltrate beyond authentication requirements. This is where the ZAP manual explore option comes in handy.</p>
<p>ZAP <em>manual explore</em> is especially useful for exploring beyond the surface of the web application. Also known as the ZAP Heads Up Display (ZAP HUD), manual explore proxies your web browser’s traffic through ZAP while you browse. To launch it, enter the URL to explore and open a browser of your choice. When the browser launches, it will appear that you are browsing the site as you normally would; however, ZAP alerts and functions will overlay the web page. This allows you to have much more control over when to start crawling, when to run active scans, and when to turn on “attack mode.” For example, you can go through the user account creation process and authentication/authorization process with the ZAP scanner running to automatically detect flaws in these processes. Any vulnerabilities you detect will pop up like gaming achievements. We will be using ZAP HUD to discover APIs.</p>
<h3 id="h2-502444c04-0016">Fuzzing with Wfuzz</h3>
<p class="BodyFirst">Wfuzz is an open-source Python-based web application fuzzing framework. Wfuzz should come with the latest version of Kali, but you can install it from GitHub at <a class="LinkURL" href="https://github.com/xmendez/wfuzz">https://github.com/xmendez/wfuzz</a>.</p>
<p><span epub:type="pagebreak" id="Page_101" title="101"/>You can use Wfuzz to inject a payload within an HTTP request by replacing occurrences of the word <em>FUZZ</em> with words from a wordlist; Wfuzz will then rapidly perform many requests (around 900 requests per minute) with the specified payload. Since so much of the success of fuzzing depends on the use of a good wordlist, we’ll spend a decent amount of time discussing wordlists in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>.</p>
<p>Here’s the basic request format of Wfuzz:</p>
<pre><code><var>$ </var><b>wfuzz </b><var class="bold">options</var> <b>-z </b><var class="bold">payload,params url</var></code></pre>
<p>To run Wfuzz, use the following command:</p>
<pre><code>$ <b>wfuzz -z file,/usr/share/wordlists/list.txt http://targetname.com/FUZZ</b></code></pre>
<p>This command replaces <em>FUZZ</em> in the URL <em>http://targetname.com/FUZZ</em> with words from <em>/usr/share/wordlists/list.txt</em>. The <code>-z</code> option specifies a type of payload followed by the actual payload. In this example, we specified that the payload is a file and then provided the wordlist’s file path. We could also use <code>-z</code> with <code>list</code> or <code>range</code>. Using the <code>list</code> option means that we will specify the payload in the request, whereas <code>range</code> refers to a range of numbers. For example, you can use the <code>list</code> option to test an endpoint for a list of HTTP verbs:</p>
<pre><code>$ <b>wfuzz -X POST -z list,admin-dashboard-docs-api-test http://targetname.com/FUZZ</b></code></pre>
<p>The <code>-X</code> option specifies the HTTP request method. In the previous example, Wfuzz will perform a POST request with the wordlist used as the path in place of the <em>FUZZ</em> placeholder.</p>
<p>You can use the <code>range</code> option to easily scan a series of numbers:</p>
<pre><code>$ <b>wfuzz -z range,500-1000 http://targetname.com/account?user_id=FUZZ</b></code></pre>
<p>This will automatically fuzz all numbers from 500 to 1000. This will come in handy when we test for BOLA vulnerabilities.</p>
<p>To specify multiple attack positions, you can list off several <code>-z</code> flags and then number the corresponding <code>FUZZ</code> placeholders, such as <code>FUZZ</code>, <code>FUZ1</code>, <code>FUZ2</code>, <code>FUZ3</code>, and so on, like so:</p>
<pre><code>$ wfuzz -z list,A-B-C -z range,1-3 http://targetname.com/<b>FUZZ</b>/user_id=<b>FUZZ2</b></code></pre>
<p>Running Wfuzz against a target can generate a ton of results, which can make it difficult to find anything interesting. Therefore, you should familiarize yourself with the Wfuzz filter options. The following filters display only certain results:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>--sc</code></span></span>  Only shows responses with specific HTTP response codes</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>--sl</code></span></span>  Only shows responses with a certain number of lines</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>--sw</code></span></span>  Only shows responses with a certain number of words</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>--sh</code></span></span>  Only shows responses with a certain number of characters</li>
</ol>
<p><span epub:type="pagebreak" id="Page_102" title="102"/>In the following example, Wfuzz will scan the target and only show results that include a status code of 200:</p>
<pre><code>$ <b>wfuzz -z file,/usr/share/wordlists/list.txt –sc 200 http://targetname.com/FUZZ</b></code></pre>
<p>The following filters hide certain results:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>--hc</code></span></span>  Hides responses with specific HTTP status codes</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>--hl</code></span></span>  Hides responses with a specified number of lines</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>--hw</code></span></span>  Hides responses with a specified number of words</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>--hh</code></span></span>  Hides responses with specified number of characters</li>
</ol>
<p>In the following example, Wfuzz will scan the target and hide all results that have a status code of 404 and hide results that have 950 characters:</p>
<pre><code>$ <b>wfuzz -z file,/usr/share/wordlists/list.txt –sc 404 –sh 950 http://targetname.com/FUZZ</b></code></pre>
<p>Wfuzz is a powerful multipurpose fuzzing tool you can use to thoroughly test endpoints and find their weaknesses. For more information about Wfuzz, check out the documentation at <a class="LinkURL" href="https://wfuzz.readthedocs.io/en/latest">https://wfuzz.readthedocs.io/en/latest</a>.</p>
<h3 id="h2-502444c04-0017">Discovering HTTP Parameters with Arjun</h3>
<p class="BodyFirst">Arjun is another open source Python-based API fuzzer developed specifically to discover web application parameters. We will use Arjun to discover basic API functionality, find hidden parameters, and test API endpoints. You can use it as a great first scan for an API endpoint during black box testing or as an easy way to see how well an API’s documented parameters match up with the scan’s findings.</p>
<p>Arjun comes configured with a wordlist containing nearly 26,000 parameters, and unlike Wfuzz, it does some of the filtering for you using its preconfigured anomaly detection. To set up Arjun, first clone it from GitHub (you’ll need a GitHub account to do this):</p>
<pre><code>$ <b>cd /opt/</b>
$ <b>sudo git clone https://github.com/s0md3v/Arjun.git</b></code></pre>
<p>Arjun works by first performing a standard request to the target API endpoint. If the target responds with HTML forms, Arjun will add the form names to the parameter list during its scan. Arjun then sends a request with parameters it expects to return responses for nonexistent resources. This is done to note the behavior of a failed parameter request. Arjun then kicks off 25 requests containing the payload of nearly 26,000 parameters, compares the API endpoint’s responses, and begins additional scans of the anomalies.</p>
<p><span epub:type="pagebreak" id="Page_103" title="103"/>To run Arjun, use the following command:</p>
<pre><code>$ <b>python3 /opt/Arjun/arjun.py -u http://target_address.com</b></code></pre>
<p>If you would like to have the output results in a certain format, use the <code>-o</code> option with your desired file type:</p>
<pre><code>$ <b>python3 /opt/Arjun/arjun.py -u http://target_address.com -o arjun_results.json</b></code></pre>
<p>If you come across a target with rate limiting, Arjun may trigger the rate limit and cause a security control to block you. Arjun even has built-in suggestions for when a target does not cooperate. Arjun may prompt you with an error message such as “Target is unable to process requests, try --stable switch.” If this happens, simply add the <code>--stable</code> flag. Here’s an example:</p>
<pre><code>$ <b>python3 /opt/Arjun/arjun.py -u http://target_address.com -o arjun_results.json --stable</b></code></pre>
<p>Finally, Arjun can scan multiple targets at once. Use the <code>-i</code> flag to specify a list of target URLs. If you’ve been proxying traffic with Burp Suite, you can select all URLs within the sitemap, use the Copy Selected URLs option, and paste that list to a text file. Then run Arjun against all Burp Suite targets simultaneously, like this:</p>
<pre><code>$ <b>python3 /opt/Arjun/arjun.py -i burp_targets.txt</b></code></pre>
<h2 id="h1-502444c04-0007">Summary</h2>
<p class="BodyFirst">In this chapter, you set up the various tools we’ll use to hack APIs throughout this book. Additionally, we spent some time digging into feature-rich applications such as DevTools, Burp Suite, and Postman. Being comfortable with the API hacking toolbox will help you know when to use which tool and when to pivot.</p>
<h2 class="HeadProject" id="h1-502444c04-0008"><span>Lab #1: Enumerating the User Accounts in a REST API</span></h2>
<p class="BodyFirst">Welcome to your first lab.</p>
<p>In this lab, our goal is simple: find the total number of user accounts in <em>reqres.in</em>, a REST API designed for testing, using the tools discussed in this chapter. You could easily figure this out by guessing the total number of accounts and then checking for that number, but we will discover the answer much more quickly using the power of Postman and Burp Suite. When testing actual targets, you could use this process to discover whether there was a basic BOLA vulnerability present.</p>
<p><span epub:type="pagebreak" id="Page_104" title="104"/>First, navigate to <a class="LinkURL" href="http://reqres.in">http://reqres.in</a> to see if API documentation is available. On the landing page, we find the equivalent of API documentation and can see a sample request that consists of making a request to the <em>/api/users/2</em> endpoint (see <a href="#figure4-29" id="figureanchor4-29">Figure 4-29</a>).</p>
<figure>
<img alt="Screenshot of the web page at https://reqres.in featuring a list of GET requests and their purposes, as well as the JSON data returned from one of the requests" class="keyline" src="image_fi/502444c04/F04029.png"/>
<figcaption><p><a id="figure4-29">Figure 4-29</a>: API documentation found at <a class="LinkURL" href="https://reqres.in">https://reqres.in</a> with instructions for requesting <span class="LiteralInCaption"><code>user id:2</code></span></p></figcaption>
</figure>
<p>You’ll notice a List Users endpoint; we’ll ignore this for the purposes of the lab, as it won’t help you learn the intended concepts. Instead, we’ll be using the Single User endpoint because it will help you build the skills needed to discover vulnerabilities like BOLA and BFLA. The suggested API request for Single User is meant to provide the consumer with the requested user’s account information by sending a GET request to <em>/api/users/</em>. We can easily assume that user accounts are organized in the <em>user</em> directory by their <code>id</code> number.</p>
<p>Let’s test this theory by attempting to send a request to a user with a different ID number. Since we’ll be interacting with an API, let’s set up the API request using Postman. Set the method to GET and add the URL <em>http://reqres.in/api/users/1</em>. Click <b>Send</b> and make sure you get a response. If you requested the user with an ID of 1, the response should reveal the user information for George Bluth, as seen in <a href="#figure4-30" id="figureanchor4-30">Figure 4-30</a>.</p>
<span epub:type="pagebreak" id="Page_105" title="105"/><figure>
<img alt="Screenshot of a GET request to the http://reqres.in/api/users/1 endpoint in Postman showing the JSON data from the response body. The JSON data includes details about a user named George." class="keyline" src="image_fi/502444c04/F04030.png"/>
<figcaption><p><a id="figure4-30">Figure 4-30</a>: A standard API request made using Postman to retrieve user 1 from the  <a class="LinkURL" href="https://reqres.in">https://reqres.in</a> database</p></figcaption>
</figure>
<p>To efficiently retrieve the data of all users by following this method, we’ll use Burp’s Intruder. Proxy the traffic from the <em>reqres.in</em> endpoint over to Burp Suite and submit the same request in Postman. Migrate over to Burp Suite, where you should see the intercepted traffic in Burp Suite’s Proxy tab (see <a href="#figure4-31" id="figureanchor4-31">Figure 4-31</a>).</p>
<figure>
<img alt="The intercepted request shown in Burp Suite Proxy" class="keyline" src="image_fi/502444c04/F04031.png"/>
<figcaption><p><a id="figure4-31">Figure 4-31</a>: The intercepted request made using Postman to retrieve user 1</p></figcaption>
</figure>
<p>Use the shortcut<span class="KeyCaps"> Ctrl</span>-I or right-click the intercepted request and select <b>Send to Intruder</b>. Select the <b>Intruder</b><span class="MenuArrow">▶</span><b>Positions</b> tab to select the payload positions. First, select <b>Clear §</b> to remove the automatic payload positioning. Then select the number at the end of the URL and click the button labeled <b>Add §</b> (see <a href="#figure4-32" id="figureanchor4-32">Figure 4-32</a>).</p>
<span epub:type="pagebreak" id="Page_106" title="106"/><figure>
<img alt="Screenshot of Burp Intruder’s Positions tab with the Sniper attack type selected and the UserID portion of the endpoint selected as the attack position" class="keyline" src="image_fi/502444c04/F04032.png"/>
<figcaption><p><a id="figure4-32">Figure 4-32</a>: Burp Suite’s Intruder configured with the attack position set around the <em>UserID</em> portion of the path</p></figcaption>
</figure>
<p>Once you’ve selected the attack position, select the <b>Payloads</b> tab (see <a href="#figure4-33" id="figureanchor4-33">Figure 4-33</a>). Since our goal is to find out how many user accounts exist, we want to replace the user ID with a series of numbers. Change the payload type to <b>Numbers</b>. Update the range of numbers to test from 0 to 25, stepping by 1. The Step option indicates to Burp how many numbers to increase with each payload. By selecting 1, we are letting Burp do the heavy lifting of creating all the payloads on the fly. This will help us discover all the users with an ID between 0 and 25. With these settings, Burp will send a total of 26 requests, each one with a number from 0 to 25.</p>
<figure>
<img alt="Screenshot of the Burp Suite Payloads tab showing one payload set, the payload type set to numbers, and the payloads ranging from 0 to 25" class="keyline" src="image_fi/502444c04/F04033.png"/>
<figcaption><p><a id="figure4-33">Figure 4-33</a>: Intruder’s Payloads tab with the payload type set to numbers</p></figcaption>
</figure>
<p>Finally, click <b>Start Attack</b> to send the 26 requests to <em>reqres.in</em>. Analyzing the results should give you a clear indication of all the live users. The API provider responds with a status 200 for user accounts between 1 and 12 and a status of 404 for the subsequent requests. Judging by the results, we can conclude that this API has a total of 12 valid user accounts.</p>
<p><span epub:type="pagebreak" id="Page_107" title="107"/>Of course, this was just practice. The values you replace in a future API hacking engagement could be user ID numbers, but they could just as easily be bank account numbers, phone numbers, company names, or email addresses. This lab has prepared you to take on the world of basic BOLA vulnerabilities; we will expand on this knowledge in<span class="xref" itemid="xref_target_ Chapter 10"> Chapter 10</span>.</p>
<p>As a further exercise, try performing this same scan using Wfuzz.</p>
</section>
</body>
</html>