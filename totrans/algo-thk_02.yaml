- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: TREES AND RECURSION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 树与递归
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: In this chapter, we’ll look at two problems that will require processing and
    answering questions about hierarchical data. The first problem is about collecting
    candy from a neighborhood. The second concerns queries on family trees. Because
    loops are a natural means to process collections of data, we’ll try them first.
    We’ll soon see, though, that these problems push against what we can easily express
    with loops, and this will motivate a shift in the way we think about and solve
    such problems. You’ll leave this chapter knowing about recursion, a problem-solving
    technique that applies whenever the solution to a problem involves solutions to
    simpler, smaller problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论两个需要处理和解答层次数据问题的题目。第一个问题是关于从邻里收集糖果，第二个问题则是关于家谱查询。由于循环是处理数据集合的自然方式，我们会先尝试使用循环。但很快我们就会发现，这些问题挑战了我们通过循环轻松表达的能力，这将促使我们改变思考和解决问题的方式。本章结束时，你将了解递归，这是一种在解决问题时应用的技巧，特别是当问题的解决方案涉及到对更简单、更小问题的解决方案时。
- en: 'Problem 1: Halloween Haul'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题 1：万圣节糖果
- en: This is DMOJ problem `dwite12c1p4`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `dwite12c1p4`。
- en: '*The Problem*'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: It’s Halloween, a holiday that often involves getting dressed up, candy from
    neighbors, and a stomachache. In this problem, you want to collect all the candy
    from a particular neighborhood as efficiently as possible. The neighborhood has
    a rigid, though strange, shape. [Figure 2-1](ch02.xhtml#ch02fig01) shows a sample
    neighborhood.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 万圣节到了，这是一个通常涉及穿上戏服、从邻居那里获得糖果以及吃到肚子痛的节日。在这个问题中，你要尽可能高效地收集某个特定邻里的所有糖果。这个邻里有着严谨而奇特的形状。[图
    2-1](ch02.xhtml#ch02fig01)展示了一个示例邻里。
- en: '![Image](../images/ch02fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch02fig01.jpg)'
- en: '*Figure 2-1: A sample neighborhood*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：一个示例邻里*'
- en: The circles with numbers in them are houses. Each number gives the amount of
    candy you’ll get by visiting that house. Candy values are at most two digits.
    The circle at the top is your starting location. The circles without numbers are
    intersections between streets, where you choose which way to walk next. The lines
    that connect circles are the streets. Moving from one circle to another corresponds
    to walking one street.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 带有数字的圆圈是房子。每个数字表示你访问该房子时将获得的糖果数量。糖果值最多是两位数。顶部的圆圈是你的起始位置。没有数字的圆圈是街道交叉口，你可以选择接下来要走的方向。连接圆圈的线条是街道。从一个圆圈移动到另一个圆圈就相当于走一条街道。
- en: Let’s think about how you could move through this neighborhood. Begin at the
    top circle. If you walk down the street on the right, you get to an intersection.
    If you then walk down the street on the right from that circle, you end up at
    a house and collect 41 pieces of candy. You could then walk back up the two streets
    to the top to return to your starting location. You’ll have thus walked a total
    of four streets and collected 41 pieces of candy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下你如何通过这个邻里移动。从顶部圆圈开始。如果你沿着右边的街道走，你会到达一个交叉口。如果你从这个圆圈沿右边的街道继续走，你将到达一个房子并收集到
    41 块糖果。然后你可以沿两条街道走回顶部，回到起始位置。这样你总共走了四条街道并收集了 41 块糖果。
- en: However, your goal is to collect *all* of the candy and to do so by walking
    the minimum number of streets. You’re allowed to end your walk as soon as you’ve
    collected all of the candy; there’s no requirement to get back to the top circle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的目标是收集*所有*的糖果，并通过走最少的街道来实现这一目标。你可以在收集完所有糖果后立即结束步行；不需要返回到起始圆圈。
- en: Input
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of exactly five lines, where each line is a string of at
    most 255 characters that describes a neighborhood.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由恰好五行组成，每行是最多 255 个字符的字符串，描述一个邻里。
- en: How can a string encode a diagram? This isn’t like the Unique Snow-flakes problem
    from [Chapter 1](ch01.xhtml), where each snowflake was just six integers. Here
    we have circles, lines connecting circles, and candy values in some of those circles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如何用字符串编码一个图形？这与[第 1 章](ch01.xhtml)中的独特雪花问题不同，后者中的每个雪花只是六个整数。在这里，我们有圆圈、连接圆圈的线条以及一些圆圈中的糖果值。
- en: 'As with the Unique Snowflakes problem, we can simplify things by initially
    ignoring some of the complexities of the full problem. For that reason, I’ll defer
    the way that the input is provided until later. Here’s a teaser, though: there’s
    a quite clever and compact way to represent these diagrams as strings. Stay tuned.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与独特的雪花问题一样，我们可以通过最初忽略一些完整问题的复杂性来简化问题。因此，我将推迟输入方式的说明。虽然如此，我可以给你一个预告：有一种相当巧妙且简洁的方式将这些图形表示为字符串，敬请期待。
- en: Output
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: 'Our output will be five lines of text, with each line corresponding to one
    of the five input lines. Each line of output contains two integers separated by
    a space: the minimum number of streets walked to obtain all of the candy and the
    total amount of candy obtained.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出将是五行文本，每一行对应一个输入行。每一行输出包含两个由空格分隔的整数：获取所有糖果所需的最小步数和获得的糖果总量。
- en: The time limit for solving the test case is two seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制是两秒钟。
- en: '*Binary Trees*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*二叉树*'
- en: In [Figure 2-2](ch02.xhtml#ch02fig02), I’ve augmented the neighborhood from
    [Figure 2-1](ch02.xhtml#ch02fig01) to include letters in the nonhouse circles.
    These letters have nothing to do with the problem and won’t affect our code, but
    they allow us to uniquely refer to each circle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-2](ch02.xhtml#ch02fig02)中，我在[图 2-1](ch02.xhtml#ch02fig01)的基础上，添加了非房子圆圈中的字母。这些字母与问题无关，不会影响我们的代码，但它们使我们能够唯一地引用每个圆圈。
- en: '![Image](../images/ch02fig02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch02fig02.jpg)'
- en: '*Figure 2-2: A sample neighborhood with letter labels*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：带有字母标签的示例邻域*'
- en: The particular shape of the neighborhoods in our Halloween Haul problem is known
    as a *binary tree*. Both *binary* and *tree* are important words here. Let’s unpack
    their definitions, starting with tree.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的万圣节任务问题中的邻域特定形状被称为*二叉树*。*二叉*和*树*这两个词在这里都很重要。让我们从树的定义开始解释。
- en: Defining Tree
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义树
- en: A *tree* is a structure that consists of *nodes* (the circles) and *edges* between
    nodes (the lines representing streets). The node at the top—the H circle—is referred
    to as the *root*. You’ll often see the term *vertex* used synonymously with node;
    in this book, I’ll stick to “node.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*树*是一种由*节点*（圆圈）和节点之间的*边*（表示街道的线）组成的结构。顶部的节点——H 圆圈——被称为*根*。你经常会看到*顶点*与节点同义使用；在本书中，我将坚持使用“节点”这一术语。'
- en: The nodes in the tree have a parent-child relationship. For example, we say
    that H is the *parent* of F and G, because there is an edge from H to F and an
    edge from H to G. We also say that F and G are *children* of H. More specifically,
    F is the *left child* of H, and G is the *right child* of H. Any node that has
    no children is referred to as a *leaf*. In the current problem, the nodes with
    candy values (the houses) are leaves.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 树中的节点具有父子关系。例如，我们说 H 是 F 和 G 的*父节点*，因为从 H 到 F 和从 H 到 G 都有边。我们也说 F 和 G 是 H 的*子节点*。更具体地说，F
    是 H 的*左子节点*，而 G 是 H 的*右子节点*。任何没有子节点的节点被称为*叶子*。在当前问题中，具有糖果值的节点（即房子）是叶子节点。
- en: Much of the terminology that computer scientists use when discussing trees is
    familiar from the notion of family trees. For example, F and G are *siblings*,
    because they have the same parent. E is an example of a *descendant* of H, because
    E is reachable by moving down the tree from H.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家在讨论树时使用的许多术语，源自家谱树的概念。例如，F 和 G 是*兄妹*，因为它们有相同的父母。E 是 H 的*后代*，因为 E 可以通过从
    H 向下遍历树来到达。
- en: 'The *height* of a tree is determined by the largest number of edges that we
    can traverse on a downward path from the root to a leaf. What is the height of
    our sample tree? Well, here’s one downward path we could traverse: H to G to 7\.
    That path has two edges (H to G and G to 7), giving us a height of at least two.
    However, we can find a much longer downward path! Here’s one such longest downward
    path: H to F to E to D to C to B to 4\. That path has six edges on it. Convince
    yourself that there is no longer downward path here. The height of this tree is
    six.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 树的*高度*由我们可以从根节点到叶子节点的最大边数决定。那么，我们的示例树的高度是多少呢？好吧，这里有一条我们可以遍历的下行路径：H 到 G 到 7。这条路径有两条边（H
    到 G 和 G 到 7），所以它的高度至少是二。然而，我们可以找到一条更长的下行路径！以下是最长的下行路径之一：H 到 F 到 E 到 D 到 C 到 B
    到 4。这条路径有六条边。自己验证一下，这里没有比这更长的下行路径了。该树的高度是六。
- en: Trees have a very regular, repeatable structure, which helps us process them.
    For example, if we remove the root H, along with the edges from H to F and from
    H to G, we end up with two *subtrees* ([Figure 2-3](ch02.xhtml#ch02fig03)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 树具有非常规律、可重复的结构，这有助于我们处理它们。例如，如果我们移除根节点H，以及从H到F和从H到G的边，我们最终会得到两个*子树*（[图 2-3](ch02.xhtml#ch02fig03)）。
- en: '![Image](../images/ch02fig03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch02fig03.jpg)'
- en: '*Figure 2-3: A tree split in two*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：一棵树被分成两部分*'
- en: 'Notice that each of the two subtrees is a legitimate tree on its own: it has
    a root, nodes and edges, and the proper structure. We could further split these
    trees into even smaller pieces, and each of those pieces would be a tree. A tree
    can be thought of as consisting of smaller trees, each of which consists of even
    smaller trees, and so on.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个子树各自都是一个合法的树：它们有根节点、节点和边，以及正确的结构。我们可以进一步将这些树拆分成更小的部分，每一部分都将是一个树。树可以看作是由更小的树组成的，而每棵小树又由更小的树组成，如此类推。
- en: Defining Binary
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义二叉树
- en: 'In the context of trees, *binary* simply means that each node in our trees
    has at most two children. A given node in a binary tree can have zero children,
    or one child, or two children, but no more. The binary trees in our current problem
    are in fact a little more constrained than that: each node is required to have
    exactly zero or two children—you’ll never see a node with exactly one child. Such
    a binary tree, where every nonleaf node has exactly two children, is referred
    to as a *full* binary tree.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在树的上下文中，*二叉*仅仅意味着我们树中的每个节点最多有两个子节点。一个二叉树中的节点可以没有子节点，或者只有一个子节点，或者有两个子节点，但不能有更多。我们当前问题中的二叉树实际上比这更为受限：每个节点必须恰好有零个或两个子节点——你永远不会看到只有一个子节点的节点。这样的二叉树，其中每个非叶子节点恰好有两个子节点，称为*完全*二叉树。
- en: '*Solving the Sample Instance*'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决示例实例*'
- en: Let’s go ahead and solve the Halloween Haul problem on our sample tree ([Figure
    2-2](ch02.xhtml#ch02fig02)). We’re required to return both the minimum number
    of streets we have to walk to get all of the candy and the total amount of candy.
    We’ll start with the latter, because it’s the easier of the two to calculate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的示例树上解决万圣节糖果收集问题（[图 2-2](ch02.xhtml#ch02fig02)）。我们需要返回我们必须走的最少街道数以及糖果的总数。我们先从后者开始，因为计算总糖果数较为简单。
- en: 'We can calculate the total amount of candy by hand: just add up all of the
    candy values in the house nodes. If we do that, we get 7 + 41 + 72 + 3 + 6 + 2
    + 15 + 4 + 9 = 159.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动计算糖果总数：只需将所有房子节点中的糖果值加起来。这样做，我们得到 7 + 41 + 72 + 3 + 6 + 2 + 15 + 4 + 9
    = 159。
- en: Now, let’s figure out the minimum number of streets that you must walk to collect
    all of the candy. Does it even matter how we traverse the tree? After all, you
    have to visit every house—maybe your quickest route is simply to avoid visiting
    the same house multiple times.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来弄清楚收集所有糖果必须走的最少街道数。树的遍历方式有关系吗？毕竟，你必须访问每一所房子——也许你最快的路线是避免多次访问同一所房子。
- en: 'Let’s traverse the tree by visiting left children before right children. By
    using this strategy, here is the order in which you visit the nodes: H, F, A,
    72, A, 3, A, F, E, 6, E, D, C, B, 4, B, 9, B, C, 15, C, D, 2, D, E, F, H, G, 7,
    G, 41\. Note how your final stop is the 41 house and not H: you’re not required
    to return to your starting location once you’re finished collecting the candy.
    There are 30 edges in that path. (There are 31 nodes in the path, and the number
    of edges in a path is always the number of nodes minus one.) Is walking 30 streets
    the best you can do?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按访问左子节点再访问右子节点的策略遍历这棵树。按照这个策略，你访问节点的顺序是：H, F, A, 72, A, 3, A, F, E, 6, E,
    D, C, B, 4, B, 9, B, C, 15, C, D, 2, D, E, F, H, G, 7, G, 41。注意你最后停下来的地方是41号房，而不是H：收集完糖果后，你不需要返回起始位置。那条路径有30条边。（路径中有31个节点，路径中的边数总是节点数减去1。）走30条街道是你能做的最好的选择吗？
- en: 'In fact, you can do better: the most efficient route involves walking only
    26 streets. Spend some time now trying to find this more optimized traversal.
    As in the 30-street traversal, you’ll have to visit the nonhouse nodes multiple
    times and you want to visit each house exactly once, but you can save four street-walks
    by being strategic about the *final* house that you visit.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以做得更好：最有效的路线只需要走26条街道。现在花点时间试着找到这种更优化的遍历方式。就像在30条街道的遍历中一样，你需要多次访问非房子节点，并且希望每个房子只访问一次，但通过在*最后*访问的房子上采取策略，你可以节省四次走街道的时间。
- en: '*Representing Binary Trees*'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*表示二叉树*'
- en: To create a solution in code, we’ll need to find a way to represent neighborhood
    trees. As you’ll see, it’s convenient to convert the strings from the input that
    represent trees to explicit tree structures that represent relationships between
    nodes. In this section, I’ll provide those tree structures. We won’t yet be able
    to read the strings and convert them to trees, but we’ll be able to hardcode trees.
    That gives us the foothold we need to start solving the problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中创建解决方案，我们需要找到一种表示邻里树的方法。正如你将看到的，将输入中表示树的字符串转换为明确表示节点之间关系的树结构是很方便的。在这一节中，我将提供这些树结构。虽然我们还不能读取字符串并将其转换为树，但我们可以硬编码树。这样就为我们提供了一个起点，开始解决问题。
- en: Defining Nodes
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义节点
- en: 'When solving the Unique Snowflakes problem in the last chapter, we used a linked
    list to store a chain of snowflakes. Each snowflake node contained the snowflake
    itself, and it also contained a pointer to the next snowflake in the chain:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章解决“独特雪花”问题时，我们使用了一个链表来存储雪花链。每个雪花节点包含了雪花本身，同时也包含指向链中下一个雪花的指针：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use a similar struct to represent a binary tree. In our neighborhood
    trees, the houses have candy values and the other nodes do not. Even though we
    have these two kinds of nodes, we’ll be okay with just one node structure. We’ll
    just make sure that house nodes have correct candy values; we won’t even initialize
    the `candy` values of nonhouse nodes, because we won’t look at those values anyway.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的结构体来表示二叉树。在我们的邻里树中，房子节点有糖果值，而其他节点没有。尽管我们有这两种节点类型，但只用一个节点结构就足够了。我们只需要确保房子节点有正确的糖果值；我们甚至不会初始化非房子节点的`candy`值，因为我们反正不会查看这些值。
- en: 'That gives us this starting point:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了这个起点：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In a linked list, each node points to the next node in the chain (or is `NULL`
    if there is no next node). From one node, we can move to exactly one other node.
    In contrast, in a tree, a single `next` pointer per node will not suffice, because
    a nonleaf node will have both a left child and a right child. We need two pointers
    per node, as in [Listing 2-1](ch02.xhtml#ch02ex01).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中，每个节点都指向链中的下一个节点（如果没有下一个节点，则为`NULL`）。从一个节点，我们只能移动到另一个节点。相比之下，在树结构中，一个单一的`next`指针是不够的，因为一个非叶子节点将有左子节点和右子节点。我们需要每个节点两个指针，正如[示例
    2-1](ch02.xhtml#ch02ex01)所示。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-1: The* node *struct*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-1：* 节点 *结构体*'
- en: It’s apparent that the `parent` is not included here. Should we throw in a `*parent`
    as well, letting us access the parent of a node in addition to its children? This
    would be useful for some problems, but it is not required for Halloween Haul.
    We will need a way to move up the tree (from child to parent), but we can do so
    implicitly, without explicitly following parent pointers. You’ll see more about
    this later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`parent`在这里没有包含。我们是否应该再加上一个`*parent`，让我们可以访问节点的父节点以及它的子节点？这对于某些问题来说是有用的，但在“万圣节大作战”中并不是必须的。我们需要一种方式来向上移动树（从子节点到父节点），但我们可以通过隐式方式做到这一点，而不需要明确地跟踪父指针。稍后你会看到更多关于这一点的内容。
- en: Building a Tree
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建树
- en: With this `node` type in hand, we can now build sample trees. We work bottom-up,
    uniting subtrees until we reach the root. Let’s demonstrate the start of this
    process on our sample tree.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个`node`类型后，我们现在可以构建示例树了。我们从下往上工作，将子树联合起来，直到到达根节点。让我们在示例树上演示这一过程的开始。
- en: We’ll start with the 4 and 9 nodes at the bottom of our sample tree. Then we
    can combine those under a new parent to create the subtree whose root is B.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从示例树底部的4号和9号节点开始。然后我们可以将它们组合在一个新的父节点下，创建以B为根的子树。
- en: 'Here’s the 4 node:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是4号节点：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a house node, so we remember to give it a candy value. It’s also important
    to set its left and right children to `NULL`. If we don’t do that, they’ll remain
    uninitialized, pointing to unspecified memory, and that’ll mean trouble if we
    try to access it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个房子节点，所以我们记得给它一个糖果值。还需要将它的左子节点和右子节点设置为`NULL`。如果我们不这么做，它们将保持未初始化，指向未定义的内存，如果我们尝试访问这些节点，就会出现问题。
- en: 'Now consider the 9 node. This is another house, so the code is structurally
    identical:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑9号节点。这是另一座房子，因此代码结构完全相同：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now have two nodes. They’re not yet part of a tree. They’re hanging out
    by themselves. We can unite them under a common parent, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个节点。它们还不是树的一部分，它们只是独立存在。我们可以将它们联合在一个公共父节点下，像这样：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This `B` node is given a `left` pointer to the 4 house and a `right` pointer
    to the 9 house. It’s `candy` member is not initialized, which is fine because
    non-house nodes have no sensible `candy` value anyway.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `B` 节点被赋予了一个指向 4 房子的左指针和一个指向 9 房子的右指针。它的 `candy` 成员没有初始化，这没关系，因为非房子节点本来就没有合理的
    `candy` 值。
- en: '[Figure 2-4](ch02.xhtml#ch02fig04) depicts what we’ve generated so far.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-4](ch02.xhtml#ch02fig04) 描述了我们目前为止生成的内容。'
- en: '![Image](../images/ch02fig04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch02fig04.jpg)'
- en: '*Figure 2-4: The first three nodes in our hardcoded tree*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：我们硬编码树中的前三个节点*'
- en: 'Before powering ahead and producing the C subtree, let’s do a little cleanup.
    Creating a house node involves four things: allocating the node, setting the candy
    value, setting the left child to `NULL`, and setting the right child to `NULL`.
    Similarly, creating a nonhouse node involves doing three things: allocating the
    node, setting the left child to some existing subtree, and setting the right child
    to some other existing subtree. We can capture these steps in helper functions
    rather than typing them out each time, as shown in [Listing 2-2](ch02.xhtml#ch02ex02).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建 C 子树之前，让我们做一点清理工作。创建一个房子节点需要四个步骤：分配节点，设置糖果值，将左子节点设置为 `NULL`，将右子节点设置为 `NULL`。类似地，创建一个非房子节点需要做三件事：分配节点，将左子节点设置为某个现有子树，将右子节点设置为另一个现有子树。我们可以将这些步骤封装在辅助函数中，而不是每次都输入它们，如[列表
    2-2](ch02.xhtml#ch02ex02)所示。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-2: Helper functions for creating nodes*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：用于创建节点的辅助函数*'
- en: 'Let’s rewrite our earlier `four`, `nine`, `B` code to use these helper functions,
    and add the 15 and C nodes while we’re at it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写之前的 `four`、`nine`、`B` 代码，使用这些辅助函数，同时加上 15 和 C 节点：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) depicts our five-node tree.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](ch02.xhtml#ch02fig05) 描述了我们的五节点树。'
- en: '![Image](../images/ch02fig05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch02fig05.jpg)'
- en: '*Figure 2-5: The first five nodes in our hardcoded tree*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：我们硬编码树中的前五个节点*'
- en: 'Notice that node `C` has a left child that is a nonhouse node (`B` in our code)
    and a right child that is a house node (`fifteen` in our code). Our `new_nonhouse`
    function allows this asymmetry (one nonhouse child and one house child): each
    is just a node. We can mix and match nonhouse nodes and house nodes at will.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，节点 `C` 的左子节点是一个非房子节点（在我们的代码中是 `B`），右子节点是一个房子节点（在我们的代码中是 `fifteen`）。我们的 `new_nonhouse`
    函数允许这种不对称性（一个非房子子节点和一个房子子节点）：每个都只是一个节点。我们可以随意混合使用非房子节点和房子节点。
- en: At this point, we have a five-node subtree rooted at node `C`. We should be
    able to use that `C` node to access the candy values stored in the tree. (We could
    also use `B`, `four`, `nine`, and `fifteen` to access parts of the tree, because
    building a tree piecewise leaves a residue of node variables in our wake, but
    later we’ll build a function for converting a string to a tree that will furnish
    us with only the tree’s root, so let’s not cheat by using those variables here.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有了一个以节点 `C` 为根的五节点子树。我们应该能够使用 `C` 节点来访问树中存储的糖果值。（我们也可以使用 `B`、`four`、`nine`
    和 `fifteen` 来访问树的部分内容，因为分阶段构建树会留下节点变量的残余，但稍后我们会构建一个将字符串转换为树的函数，它只会提供树的根节点，所以在这里不要通过使用这些变量来作弊。）
- en: 'Here’s a quick exercise: What does this print?'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个快速练习：这将打印什么？
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you said `15`, you’d be correct! We access `C`’s right child, which is the
    `fifteen` house node, and then we access `fifteen`’s candy value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说是 `15`，那你是对的！我们访问了 `C` 的右子节点，即 `fifteen` 房子节点，然后我们访问了 `fifteen` 的糖果值。
- en: How about this?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个怎么样？
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That should output `9`: a left and then a right takes us from `C` to `nine`.
    Now try this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出 `9`：先左后右，我们从 `C` 到达了 `nine`。现在试试这个：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Yikes! On my laptop, I’m getting the value `10752944`. Why? The reason is that
    we’re printing a pointer value, not a candy value. We will have to be careful
    here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 天哪！在我的笔记本上，我得到的值是 `10752944`。为什么？原因是我们打印的是一个指针值，而不是糖果值。我们必须小心这里。
- en: Finally, what would this print?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这将打印什么？
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This gives us a useless number. Here we’re printing the `candy` member for a
    nonhouse node, but only houses have meaningful values of `candy`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个无用的数字。我们在这里打印的是非房子节点的 `candy` 成员，但只有房子节点的 `candy` 值才有意义。
- en: We’re now ready to start tackling this problem. Finish up the code to build
    the sample tree and we’ll be on our way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始解决这个问题了。完成代码来构建示例树，我们就可以继续前进了。
- en: '*Collecting All the Candy*'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*收集所有糖果*'
- en: 'We have two main tasks: calculating the minimum number of streets required
    to collect all of the candy and calculating the total amount of candy in the tree.
    We’ll write a helper function for each task, starting with calculating the total
    amount of candy, the easier of the two tasks. The helper function will have the
    following signature:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个主要任务：计算收集所有糖果所需的最少街道数和计算树中糖果的总量。我们将为每个任务编写一个辅助函数，从计算糖果总量开始，这是两个任务中较为简单的一个。这个辅助函数的签名如下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function takes a pointer to a node that is the root of the tree and returns
    an integer that will be the total amount of candy in the tree.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个指向树根节点的指针，并返回一个整数，这个整数将是树中糖果的总量。
- en: 'If we were dealing with linked lists, we could use a loop like we did when
    solving the Unique Snowflakes problem. The body of the loop would process the
    current node and then use the `next` member of the node to advance to the next
    node. At each step, there’s only one place to go: further down the linked list.
    However, the structure of binary trees is more complex. Each nonleaf node has
    a left and a right subtree. Each must be traversed; otherwise, we’ll miss processing
    part of the tree!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是链表，我们可以像在解决唯一雪花问题时那样使用循环。循环的主体将处理当前节点，然后使用节点的 `next` 成员来前进到下一个节点。在每一步，只有一个地方可以去：继续沿着链表向下走。然而，二叉树的结构更为复杂。每个非叶子节点都有左子树和右子树。每棵子树都必须遍历，否则我们就会错过处理树的一部分！
- en: 'To show a tree traversal in action, we will return to our sample tree ([Figure
    2-2](ch02.xhtml#ch02fig02)): Beginning at node H, where should we go first? We
    could move right to G and then move right again to 41, collecting 41 pieces of
    candy there. Then what? We’re at a dead end, and there’s a lot more candy to collect.
    Remember that each nonleaf node stores pointers only to its left and right children,
    not to its parent. Once at 41, we have no way to get back up to G.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示树的遍历过程，我们将返回到我们的示例树（[图 2-2](ch02.xhtml#ch02fig02)）：从节点 H 开始，我们应该先去哪儿？我们可以向右移动到
    G，然后再向右移动到 41，收集那里 41 个糖果。然后呢？我们到了死胡同，还有更多的糖果需要收集。记住，每个非叶子节点仅存储指向其左子节点和右子节点的指针，而不是指向其父节点的指针。一旦到了
    41，我们就无法返回到 G。
- en: Starting again, we need to move from H to G and to record that we must later
    process the F subtree—otherwise, we’ll have no way to return to the F subtree.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始，我们需要从 H 移动到 G，并记录下我们必须稍后处理 F 子树——否则我们将无法返回到 F 子树。
- en: Once at G, we similarly need to move to 41 and to record that we must later
    process the 7 subtree. When we’re at 41, we see that there are no subtrees to
    process, and we have recorded two subtrees (F and 7) that we still need to process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到了 G，我们类似地需要移动到 41，并记录下我们必须稍后处理 7 子树。当我们到达 41 时，发现没有子树需要处理，我们已经记录了两个待处理的子树（F
    和 7）。
- en: Perhaps next we choose to process the 7 subtree, giving us a total candy value
    of 41 + 7 = 48\. After that, we’ll process the F subtree. Making any one decision
    about where to go from F leaves a whole subtree unprocessed, so we also need to
    record that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 也许接下来我们选择处理 7 子树，这样糖果总数就是 41 + 7 = 48。之后，我们将处理 F 子树。关于从 F 出发去哪里做出任何决策都会导致某棵子树未被处理，所以我们也需要记录下来。
- en: 'That is, if we use a loop, for each nonleaf node we must do two things: choose
    one of its subtrees to process first and record that the other subtree is pending
    to be processed. Choosing one of the subtrees amounts to following the `left`
    or `right` pointer—there is no problem there. Recording information so that we
    can visit the other subtree later, however, will be trickier. We’ll need a new
    tool.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们使用循环，对于每个非叶子节点，我们必须做两件事：选择一个子树先处理，并记录下另一个子树待处理。选择一个子树相当于跟随 `left` 或
    `right` 指针——这没有问题。然而，记录信息以便稍后访问另一个子树会更棘手。我们需要一种新工具。
- en: Storing Pending Subtrees on a Stack
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将待处理的子树存储在栈中
- en: At any moment, we can have multiple subtrees pending for us to visit later.
    We need to be able to add another subtree to that collection and to remove and
    return subtrees when we’re ready to process them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，我们可能有多个子树待我们稍后访问。我们需要能够将另一个子树添加到这个集合中，并在准备好处理时将子树移除并返回。
- en: We can use an array to manage this bookkeeping. We’ll define a large array that
    can hold as many references to pending subtrees as needed. To tell us how many
    subtrees are pending, we’ll keep a `highest_used` variable that will track the
    highest index being used in the array. For example, if `highest_used` is `2`,
    it means that indices `0`, `1`, and `2` hold references to pending subtrees and
    that the rest of the array is currently unused. If `highest_used` is `0`, it means
    that only index `0` is being used. To signify that no part of the array is being
    used, we set `highest_used` to `-1`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个数组来管理这些记录。我们将定义一个大数组，可以容纳任意数量的待处理子树的引用。为了告诉我们有多少子树正在等待，我们将保持一个`highest_used`变量，用来追踪数组中正在使用的最高索引。例如，如果`highest_used`是`2`，这意味着索引`0`、`1`和`2`包含待处理子树的引用，而数组的其余部分目前没有使用。如果`highest_used`是`0`，这意味着只有索引`0`在使用。为了表示数组中没有部分正在使用，我们将`highest_used`设置为`-1`。
- en: The easiest spot to add to the array is at index `highest_used + 1`. If we tried
    to add an element anywhere else, we’d first have to move existing elements to
    the right; otherwise, we’d overwrite one of the existing elements! Similarly,
    the easiest element to remove from the array is `highest_used`. Using any other
    index would necessitate moving elements to the left to fill the vacancy left by
    the removed element.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组中添加元素最简单的位置是索引`highest_used + 1`。如果我们尝试在其他地方添加元素，首先需要将现有元素向右移动；否则，我们会覆盖掉某个现有元素！类似地，从数组中移除元素最简单的位置是`highest_used`。使用其他索引则需要将元素向左移动，以填补被移除元素留下的空位。
- en: 'Using this scheme, suppose we first add a reference to subtree F and then add
    a reference to subtree 7\. This places the F subtree at index `0` and the 7 subtree
    at index `1`. The value of `highest_used` is currently `1`. Now, when we remove
    an element from this array, which subtree do you think gets removed: the F subtree
    or the 7 subtree?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方案，假设我们首先添加对子树F的引用，然后添加对子树7的引用。这将把F子树放在索引`0`的位置，把7子树放在索引`1`的位置。此时，`highest_used`的值为`1`。现在，当我们从这个数组中移除一个元素时，你认为会移除哪个子树：F子树还是7子树？
- en: The 7 subtree gets removed! In general, the element that was most recently added
    is the one that is removed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 7子树被移除了！一般来说，最近添加的元素是被移除的元素。
- en: Computer scientists refer to this as *last-in, first-out (LIFO)* access. Collections
    of data that provide LIFO access are referred to as *stacks*. Adding an element
    to a stack is known as a *push*, and removing an element from a stack is known
    as a *pop*. The *top* of the stack refers to the element that would next be popped
    from the stack; that is, the top of the stack is the most recently pushed item.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家称这种方式为*后进先出（LIFO）*访问。提供LIFO访问的数据集合被称为*堆栈*。向堆栈中添加元素称为*推入*，从堆栈中移除元素称为*弹出*。堆栈的*顶部*指的是下一个将从堆栈中弹出的元素；也就是说，堆栈的顶部是最近被推入的元素。
- en: There are real-life stacks all over the place. Say you have some plates that
    have just been washed, and you put them away on a shelf in a cupboard, one after
    the other. The last one that you add (push) to the shelf will be at the top of
    the stack, and it will be the first plate that you remove (pop) when retrieving
    a plate from the cupboard. This is LIFO.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现实生活中到处都有堆栈。假设你有一些刚洗过的盘子，并将它们一一放置在橱柜的架子上。你放置的最后一个盘子（推入）将位于堆栈的顶部，它也将是你取出盘子时（弹出）最先拿走的盘子。这就是后进先出（LIFO）。
- en: A stack also powers the undo functionality in your word processor. Suppose you
    type a word, then a second word, then a third word. Now you hit undo. The third
    word goes away, since it was the last one that you entered.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈也支持文字处理器中的撤销功能。假设你先输入一个单词，然后输入第二个单词，再输入第三个单词。现在你点击撤销。第三个单词将被删除，因为它是你最后输入的单词。
- en: Implementing a Stack
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现堆栈
- en: 'Let’s implement the stack. To begin, we package both the array and `highest_used`
    into a struct. This keeps the stack’s variables together and also allows us to
    create as many stacks as we wish. (In Halloween Haul, we need only one stack,
    but you might use this code in other settings where multiple stacks are required.)
    Here’s our definition:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现堆栈。首先，我们将数组和`highest_used`打包成一个结构体。这样可以将堆栈的变量集中在一起，并允许我们创建任意数量的堆栈。（在《Halloween
    Haul》游戏中，我们只需要一个堆栈，但你可能会在其他需要多个堆栈的环境中使用此代码。）以下是我们的定义：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Recall that each input line is at most 255 characters. Each character will represent
    at most one node. Each tree that we deal with will thus have at most 255 nodes,
    and this is why our `values` array has space for 255 elements. Also, notice that
    each element in `values` is of type `node *`, a pointer to `node`. We could have
    stored nodes in there directly, rather than pointers to nodes, but that would
    be less memory efficient because the nodes from the tree would be duplicated when
    added to the stack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每行输入最多为255个字符。每个字符最多表示一个节点。我们处理的每棵树最多有255个节点，这也是为什么我们的`values`数组有255个元素空间的原因。此外，注意`values`中的每个元素都是`node
    *`类型，即指向`node`的指针。我们本可以直接存储节点，而不是节点的指针，但那样会降低内存效率，因为树中的节点在加入栈时会被重复存储。
- en: We’ll create a function for each operation on a stack. First, we need a `new_stack`
    function that creates a new stack. Next, we need `push_stack` and `pop_stack`
    functions to add to and remove from the stack, respectively. Finally, we’ll have
    an `is_empty_stack` function that tells us whether the stack is empty.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为栈的每个操作创建一个函数。首先，我们需要一个`new_stack`函数来创建一个新栈。接下来，我们需要`push_stack`和`pop_stack`函数，分别用来向栈中添加和从栈中移除元素。最后，我们会有一个`is_empty_stack`函数，用来告诉我们栈是否为空。
- en: The `new_stack` function is provided in [Listing 2-3](ch02.xhtml#ch02ex03).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_stack`函数在[列表 2-3](ch02.xhtml#ch02ex03)中提供。'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-3: Creating a stack*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-3：创建栈*'
- en: 'First, we allocate memory for the stack ➊. Then, we set `highest_used` to `-1`
    ➋; recall that `-1` here means an empty stack. Notice that we don’t do anything
    to initialize the elements of `s->values` here: our stack is empty, so its values
    are irrelevant.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为栈分配内存 ➊。然后，我们将`highest_used`设置为`-1` ➋；回想一下，这里的`-1`表示栈为空。注意，我们在这里并没有对`s->values`中的元素进行初始化：我们的栈是空的，所以它的值不相关。
- en: I’ve put `stack_push` and `stack_pop` together in [Listing 2-4](ch02.xhtml#ch02ex04)
    to highlight the symmetry of their implementation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`stack_push`和`stack_pop`放在[列表 2-4](ch02.xhtml#ch02ex04)中，以突出它们实现的对称性。
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 2-4: Push and pop on a stack*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-4：栈的推入与弹出*'
- en: In `push_stack`, we first make room for a new element ➊, and then place `value`
    in that free location ➋.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`push_stack`中，我们首先为一个新元素腾出空间 ➊，然后将`value`放入那个空闲位置 ➋。
- en: 'Our `pop_stack` function is responsible for removing the element at index `highest_used`.
    If it did just that, however, then the function wouldn’t be all that useful: we’d
    be able to call it and it would pop the element for us, but it wouldn’t tell us
    what was popped! To remedy that, we store in `ret` the element from the stack
    that we are about to remove ➌. We then remove the element from the stack by decreasing
    `highest_used` by one ➍. Finally, we return the element that was removed ➎.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`pop_stack`函数负责移除索引为`highest_used`的元素。然而，如果它只是这么做，那么这个函数就没那么有用：我们可以调用它，它会为我们弹出元素，但它不会告诉我们弹出了什么！为了解决这个问题，我们将待移除的栈元素存储在`ret`中
    ➌。然后，通过将`highest_used`减去一来移除该元素 ➍。最后，我们返回被移除的元素 ➎。
- en: I have not included error checking in `push_stack` or `pop_stack`. Notice that
    `push_stack` would fail if you tried to push more than the maximum number of elements—but
    we’re safe, because we’ve made the stack as big as any input we’ll be provided.
    Likewise, `pop_stack` would fail if you tried to pop from an empty stack—but we’ll
    be careful to check that the stack is nonempty before we pop. Of course, general-purpose
    stacks should be made more robust!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在`push_stack`或`pop_stack`中包括错误检查。注意，如果你尝试推入超过最大元素数目，`push_stack`会失败——但我们很安全，因为我们已经将栈的大小设置为能够容纳任何输入的大小。同样地，如果你尝试从空栈中弹出元素，`pop_stack`也会失败——但我们会小心检查栈是否为空，在弹出之前确保栈不为空。当然，通用栈应当更加健壮！
- en: We’ll determine whether a stack is empty using `is_empty_stack` (shown in [Listing
    2-5](ch02.xhtml#ch02ex05)), which uses `==` to check whether `highest_used` is
    `-1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`is_empty_stack`（见[列表 2-5](ch02.xhtml#ch02ex05)）来判断栈是否为空，`is_empty_stack`使用`==`来检查`highest_used`是否为`-1`。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 2-5: Determining whether a stack is empty*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：判断栈是否为空*'
- en: Before we calculate the total amount of candy in a tree, let’s exercise our
    stack code with a small, standalone example, as given in [Listing 2-6](ch02.xhtml#ch02ex06).
    I encourage you to take a few minutes to trace the example on your own. Predict
    what will happen! Then, run the code and check whether the output matches what
    you expected.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们计算树中糖果的总数之前，让我们通过一个小的独立示例来练习栈的代码，具体见[列表 2-6](ch02.xhtml#ch02ex06)。我鼓励你花几分钟时间自己追踪这个示例。预测一下会发生什么！然后，运行代码并检查输出是否符合你的预期。
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-6: An example of using a stack*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-6：使用堆栈的示例*'
- en: 'Let’s figure out what this example does. First we create a new stack called
    `s`. We then create three house nodes: `n1` has 20 pieces of candy, `n2` has 30
    pieces of candy, and `n3` has 10 pieces of candy.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个示例做了什么。首先我们创建一个新的堆栈 `s`。然后我们创建三个房子节点：`n1` 有 20 个糖果，`n2` 有 30 个糖果，`n3`
    有 10 个糖果。
- en: 'We push these (single-node) subtrees onto the stack: first `n1` is pushed,
    then `n2`, then `n3`. As long as the stack is nonempty, we pop an element from
    the stack and print its candy value. The elements come off the stack in the opposite
    order in which they were pushed, so we get 10, 30, 20 as the result of the `printf`
    calls.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些（单节点）子树推入堆栈：首先推入 `n1`，然后是 `n2`，再是 `n3`。只要堆栈不为空，我们就从堆栈中弹出一个元素，并打印它的糖果值。元素从堆栈中弹出的顺序与它们被推入的顺序相反，因此我们会得到
    `printf` 调用的结果：10、30、20。
- en: A Stack Solution
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 堆栈解决方案
- en: 'We now have a means of keeping track of pending subtrees: whenever we make
    a choice of which subtree to process, we put the other one on the stack. What’s
    important for calculating the total amount of candy is that the stack gives us
    a way to push a subtree (to help us remember that subtree) and pop a subtree (to
    help us process a subtree when we’re ready to do so).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一种追踪待处理子树的方法：每当我们决定处理哪个子树时，就将另一个子树放入堆栈。对于计算糖果总量来说，堆栈给了我们一种方法来推入子树（帮助我们记住这个子树），并在准备好时弹出子树（帮助我们处理子树）。
- en: We could also have used a *queue*, a data structure to give us elements in *first-in,
    first-out (FIFO)* order, which would change the order in which subtrees are visited
    and the order in which we add candy to our total, but it would give us the same
    end result. I chose a stack because it’s easier to implement than a queue.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 *队列*，一种以 *先进先出（FIFO）* 顺序提供元素的数据结构，这将改变子树访问的顺序和我们添加糖果到总量的顺序，但最终结果是一样的。我选择了堆栈，因为它比队列更容易实现。
- en: 'We’re now ready to implement `tree_candy` using a stack. We need to handle
    two cases: the first is what we do when looking at a nonhouse node, and the second
    is what we do when looking at a house node.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用堆栈来实现 `tree_candy` 了。我们需要处理两种情况：第一种是当我们看到非房子节点时该怎么做，第二种是当我们看到房子节点时该怎么做。
- en: 'To know whether our current node is a nonhouse node, we can check its `left`
    and `right` pointers. For a nonhouse, both will be non-null, because they point
    to subtrees. If we confirm we’re looking at a nonhouse node, we store the pointer
    to the left subtree in the stack, and we proceed down the right subtree. The code
    for the nonhouse-node case goes like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断当前节点是否是非房子节点，我们可以检查其`left`和`right`指针。对于非房子节点，这两个指针都不为 `NULL`，因为它们指向子树。如果确认我们正在查看的是非房子节点，我们将左子树的指针存入堆栈，然后继续遍历右子树。处理非房子节点的代码如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Otherwise, if `left` and `right` are `NULL`, then we’re looking at a house
    node. House nodes have candy, so the first thing we should do is add that house’s
    candy value to our total amount of candy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果 `left` 和 `right` 都是 `NULL`，那么我们正在查看一个房子节点。房子节点有糖果，因此我们应该做的第一件事是将该房子节点的糖果值加到总糖果量中：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s a house, so there’s no further down in the tree we can go. If the stack
    is empty, we’re done: an empty stack means that there are no more pending trees
    to process. If the stack is not empty, then we need to pop a subtree from the
    stack and process that subtree. Here’s the code for processing a house:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个房子节点，因此树中不再有进一步的分支。如果堆栈为空，说明处理完毕：空堆栈表示没有更多待处理的子树。如果堆栈不为空，则需要从堆栈中弹出一个子树并处理它。处理房子节点的代码如下：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete code for `tree_candy`, using a stack, is given in [Listing 2-7](ch02.xhtml#ch02ex07).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆栈的完整代码 `tree_candy` 请见 [清单 2-7](ch02.xhtml#ch02ex07)。
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 2-7: Calculating the total amount of candy using a stack*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-7：使用堆栈计算糖果总量*'
- en: Let *n* be the number of nodes in a tree. Each time through the `while` loop,
    `tree` is a different node. We therefore visit each node just once. Each node
    is also pushed to and popped from the stack at most once. In all, each node is
    involved in a constant number of steps, so we have a linear-time, or *O*(*n*),
    algorithm here.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *n* 为树中节点的数量。每次执行 `while` 循环时，`tree` 是不同的节点。因此我们每个节点只会访问一次。每个节点最多会被推入和弹出堆栈一次。总的来说，每个节点参与的步骤是常数级别的，所以这个算法是线性时间，或者说是
    *O*(*n*) 的。
- en: '*A Completely Different Solution*'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一个完全不同的解决方案*'
- en: 'Our `tree_candy` function works, but it isn’t the simplest solution. We had
    to write an implementation of a stack. We had to keep track of pending trees.
    We had to backtrack to a pending tree whenever we hit a dead end. For two reasons,
    using a stack in the way we have done may not be the ideal solution strategy when
    writing functions on trees:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`tree_candy`函数是有效的，但它并不是最简单的解决方案。我们必须实现一个栈的功能。我们需要跟踪待处理的树。每当我们遇到死胡同时，我们需要回溯到待处理的树。由于两个原因，在树上编写函数时，像我们这样使用栈可能不是理想的解决策略：
- en: Whenever we have to go one way but return later to go the other way, we’re stuck
    using this kind of stack code. Tree-processing is rife with problems that require
    this pattern.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们需要朝一个方向移动，但之后又必须回头走另一个方向时，我们就不得不使用这种栈式代码。树的处理经常出现需要这种模式的问题。
- en: The complexity of stack-based code scales with the complexity of the problem.
    Adding up all of the candy in a tree isn’t so bad, but other related problems
    that we solve later in this chapter are more challenging. Those problems require
    not only a stack of pending trees but control flow information for tracking the
    processing that we need to perform on each tree.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于栈的代码复杂度与问题的复杂度成正比。加总树中所有糖果并不算太难，但本章后面我们将解决的其他相关问题则更加具有挑战性。这些问题不仅需要一个待处理树的栈，还需要控制流信息来跟踪我们在每棵树上需要执行的处理。
- en: We’ll rewrite our code so it’s able to work at a higher level of abstraction,
    eliminating stacks completely from both our code and our thought processes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写代码，使其能够在更高的抽象层次上工作，完全消除代码和思维过程中的栈。
- en: Recursive Definitions
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 递归定义
- en: 'Our stack-based `tree_candy` function is concerned with the *particular steps*
    needed to solve the problem: push this on the stack, move that way in the tree,
    pop from the stack when we hit a dead end, stop when we’ve processed the entire
    tree. I will now give you another solution that focuses on the *structure* of
    the problem. This method solves the main problem in terms of solutions to smaller
    subproblems. The solution comprises two rules:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于栈的`tree_candy`函数关注的是解决问题所需的*特定步骤*：将这个推入栈中，在树中朝某个方向移动，当遇到死胡同时从栈中弹出，处理完整个树时停止。我现在将给出另一种解决方案，它关注的是问题的*结构*。这种方法通过将问题分解为更小的子问题来解决主要问题。该解决方案包括两个规则：
- en: '**Rule 1**   If the root of the tree is a house node, then the total amount
    of candy in the tree equals the amount of candy at that house.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1** 如果树的根是一个房屋节点，那么树中的糖果总量等于该房屋中的糖果数量。'
- en: '**Rule 2**   If the root of the tree is a nonhouse node, then the total amount
    of candy in the tree equals the total amount of candy in the left subtree plus
    the total amount of candy in the right subtree.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2** 如果树的根是一个非房屋节点，那么树中的糖果总量等于左子树中的糖果总量加上右子树中的糖果总量。'
- en: 'This is called a *recursive* definition. A definition is recursive if it offers
    a solution to a problem by referring to solutions to subproblems. Rule 2 is where
    we see this in action. We care about solving the original problem of calculating
    the total amount of candy in the tree. That total can be calculated, according
    to Rule 2, by adding up the solutions to two smaller problems: the total amount
    of candy in the left subtree and the total amount of candy in the right subtree.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*递归*定义。如果一个定义通过引用子问题的解决方案来提供问题的解决方案，那么这个定义就是递归的。规则2就是在这里我们看到它的实际应用。我们关注的是解决计算树中糖果总量的原始问题。根据规则2，这个总量可以通过将两个更小问题的解决方案相加来计算：左子树中的糖果总量和右子树中的糖果总量。
- en: It’s at about this time that students in my classes start blanching all over
    the place. How is this description going to solve anything? Even if it does, how
    can this kind of thing be written in code? The problem is aggravated by books
    and tutorials that imbue recursive definitions with a mystical quality that is
    to be trusted but not understood. However, there is no leap of faith or temerity
    required.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这个时候，我班上的学生通常会开始满脸困惑。这个描述怎么能解决问题呢？即使能，如何将这种东西写成代码呢？书籍和教程常常给递归定义蒙上神秘的面纱，要求相信但不去理解。然而，这并不需要盲目信任或胆大妄为。
- en: Let’s work through a small example to get a feel for why this recursive definition
    is correct.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小例子来理解为什么这种递归定义是正确的。
- en: 'Consider this tree consisting of a single house with four pieces of candy:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个由一座房子和四块糖果组成的树：
- en: '![Image](../images/unch02fig01.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch02fig01.jpg)'
- en: Rule 1 immediately tells us that the answer for this tree is four. Whenever
    we see this tree later, just remember that the answer is four.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 1 立即告诉我们这棵树的答案是四。以后我们看到这棵树时，只需要记住答案是四。
- en: 'Now, consider this tree consisting of a single house with nine pieces of candy:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑这棵只包含一个房子的树，里面有九颗糖果：
- en: '![Image](../images/unch02fig02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/unch02fig02.jpg)'
- en: 'Again, Rule 1 applies, telling us that the answer is nine: when we see this
    tree later, we’ll just respond that the answer is nine.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，规则 1 适用，告诉我们答案是九：当我们稍后看到这棵树时，我们只需要回答答案是九。
- en: 'Now, let’s solve the problem for a bigger tree:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们解决更大树的问题：
- en: '![Image](../images/unch02fig03.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/unch02fig03.jpg)'
- en: 'This time, Rule 1 does not apply: the root of the tree is a nonhouse node,
    not a house node. However, we are rescued by Rule 2, which tells us that the total
    amount of candy here is the total amount of candy in the left subtree plus the
    total amount of candy in the right subtree. We already know that the total amount
    of candy in the left subtree is four: it is a tree that we have seen before. Similarly,
    we know that the total amount of candy in the right subtree is nine: we have seen
    that tree before, too. By Rule 2, therefore, the entire tree has 4 + 9 = 13 pieces
    of candy. Remember this for when we see this tree again!'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，规则 1 不适用：树的根是一个非房节点，而不是房节点。然而，我们得到了规则 2 的帮助，规则 2 告诉我们这里的糖果总数是左子树的糖果总数加上右子树的糖果总数。我们已经知道左子树的糖果总数是四：这是一棵我们之前见过的树。同样，我们知道右子树的糖果总数是九：我们也见过那棵树。因此，根据规则
    2，整个树有 4 + 9 = 13 颗糖果。记住这个，当我们再次看到这棵树时！
- en: 'Let’s go a little further. Here’s another one-house tree, this one with 15
    pieces of candy:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再往前看一点。这是另一棵单房树，它有 15 颗糖果：
- en: '![Image](../images/unch02fig04.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/unch02fig04.jpg)'
- en: 'Rule 1 tells us this tree has a total of 15 pieces of candy. Remember that!
    Now consider a five-node tree:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 1 告诉我们这棵树的糖果总数是 15 颗。记住这个！现在考虑一棵五节点的树：
- en: '![Image](../images/unch02fig05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/unch02fig05.jpg)'
- en: 'Rule 2 applies here, because the root is a nonhouse node. We need the total
    amount of candy in the left subtree and the total amount of candy in the right
    subtree. We already know the total amount of candy in the left subtree, as we
    remember our earlier answer of 13\. There’s no point going into that left subtree
    and recalculating anything: we already know the answer. Similarly, we already
    know the total amount of candy in the right subtree, as it was 15\. By Rule 2,
    then, we have a total of 13 + 15 = 28 pieces of candy in the tree.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 2 在这里适用，因为根是一个非房节点。我们需要左子树的糖果总数和右子树的糖果总数。我们已经知道左子树的糖果总数，因为我们记得之前的答案是 13。没有必要再去左子树重新计算什么：我们已经知道答案。同样，我们也知道右子树的糖果总数，因为它是
    15。根据规则 2，整个树的糖果总数是 13 + 15 = 28 颗糖果。
- en: You can keep using this logic to find the total amount of candy in bigger and
    bigger trees. As we did in the example here, solve smaller subtrees before larger
    subtrees. In doing so, Rule 1 or Rule 2 will always apply, and answers for smaller
    subtrees will be known when they are needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用这个逻辑来找到越来越大树的糖果总数。正如我们在这里的例子中所做的那样，先解决较小的子树，再解决较大的子树。这样，规则 1 或规则 2 总是适用，较小子树的答案会在需要时知道。
- en: Let’s encode Rule 1 and Rule 2 as a C function; see [Listing 2-8](ch02.xhtml#ch02ex08).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将规则 1 和规则 2 编码为 C 函数；请参见 [列表 2-8](ch02.xhtml#ch02ex08)。
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 2-8: Calculating the total amount of candy using recursion*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-8：使用递归计算糖果总数*'
- en: Notice how Rule 1 and Rule 2 are directly represented here. We have an `if`
    statement whose condition is true when the left and right subtrees are `NULL`
    ➊. No subtrees means that `tree` is a house node. We should therefore apply Rule
    1, which is exactly what we do. Specifically, we return the amount of candy in
    the house node `tree`. If Rule 1 does not apply, we know that `tree` is a nonhouse
    node, and we can implement Rule 2 and return the candy in the left subtree plus
    the candy in the right subtree ➋ . . . but here we pause.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意规则 1 和规则 2 如何在这里直接表示。我们有一个 `if` 语句，当左子树和右子树都是 `NULL` 时条件为真 ➊。没有子树意味着 `tree`
    是一个房节点。因此我们应该应用规则 1，这正是我们所做的。具体地，我们返回房节点 `tree` 中的糖果数量。如果规则 1 不适用，我们知道 `tree`
    是一个非房节点，我们可以应用规则 2，返回左子树中的糖果加上右子树中的糖果 ➋... 但是这里我们暂停。
- en: 'How does Rule 2 work here? The total amount of candy in the left subtree is
    obtained by calling `tree_candy` on the left subtree. This is the same as for
    the right subtree: to obtain the total amount of candy in the right subtree, we’re
    calling `tree_candy` on the right subtree. But we’re already in `tree_candy`!'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 2 如何在这里工作？左子树的糖果总量是通过在左子树上调用 `tree_candy` 得到的。对于右子树也是如此：要获得右子树的糖果总量，我们在右子树上调用
    `tree_candy`。但是我们已经在 `tree_candy` 函数中了！
- en: Calling a function from inside itself is known as a *recursive call*. A function
    that makes a recursive call is said to be using *recursion*. One of the biggest
    mistakes you can make at this point is to try to trace what’s going on in the
    computer when this recursion happens. I’m going to refrain from giving the low-level
    details on how the computer organizes these recursive calls. (Suffice it to say
    that it uses a stack to keep track of pending function calls. It’s very similar
    to how we earlier used a stack in our code to solve `tree_candy`! For that reason,
    our recursive code, much like our stack-based code, is an *O*(*n*) solution.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数内部调用自身被称为*递归调用*。一个进行递归调用的函数被称为使用了*递归*。在这一点上，你能犯的最大错误之一就是试图追踪计算机在递归发生时发生了什么。我会避免给出计算机如何组织这些递归调用的底层细节。（可以说，它使用栈来跟踪待处理的函数调用。这与我们之前在代码中使用栈来解决
    `tree_candy` 问题非常相似！因此，我们的递归代码，像我们基于栈的代码一样，是一个 *O*(*n*) 解决方案。）
- en: Over and over, I’ve seen the quagmire that can result from trying to manually
    trace recursive calls. It’s the wrong level of abstraction. Let the computer execute
    it in the same way that, without a second thought, you let it execute your loops
    or function calls.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我反复看到试图手动追踪递归调用所带来的困境。这是一种错误的抽象层级。让计算机以同样的方式执行它，就像你不加思考地让计算机执行循环或函数调用一样。
- en: 'Here’s how I suggest thinking through what the recursive code is doing:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我建议你理解递归代码的方式：
- en: If the root of the tree is a house, return its amount of candy.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果树的根节点是一个房子，返回它的糖果数量。
- en: Otherwise, the root of the tree is a nonhouse. Return the total amount of candy
    in the left subtree plus the total amount of candy in the right subtree.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，树的根节点是一个非房子节点。返回左子树的糖果总量加上右子树的糖果总量。
- en: 'It’s easy to err when writing recursive code. One common mistake is to inadvertently
    throw information away when in fact it should be returned. The following flawed
    implementation exhibits this error:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编写递归代码时很容易出错。一个常见的错误是无意中丢弃本应返回的信息。以下错误的实现展示了这个问题：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our bug is that we return nothing from the recursive calls ➊, as there is no
    `return` keyword. We’re supposed to return the sum, not throw it away.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 bug 是在递归调用 ➊ 中没有返回任何值，因为没有 `return` 关键字。我们应该返回总和，而不是抛弃它。
- en: 'Another common mistake is to make a recursive call on something that’s not
    a smaller subproblem of the current problem. Here’s an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是对不是当前问题更小子问题的对象进行递归调用。这里有一个例子：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Look at the second `return` statement ➊. If I told you that the total amount
    of candy in a tree is obtained by calculating the total amount of candy in the
    tree, I think you’d be quite vexed—but that’s exactly the rule that it embodies.
    This function will not work on a tree whose root is a nonhouse node: it will continue
    to use up memory with pending function calls until the program crashes.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第二个 `return` 语句 ➊。如果我告诉你树中糖果的总量是通过计算树中糖果的总量得到的，我想你一定会很恼火——但这正是它所体现的规则。这个函数在树的根是非房子节点时不起作用：它会不断使用内存来保存待处理的函数调用，直到程序崩溃。
- en: Practicing Recursion
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 递归练习
- en: Before proceeding with solving the Halloween Haul problem, let’s practice with
    recursion by writing two more functions in the spirit of `tree_candy`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续解决万圣节糖果问题之前，让我们通过编写与`tree_candy`类似的两个函数来练习递归。
- en: 'First, given a pointer to the root of a full binary tree, let’s return the
    number of nodes in the tree. If the node is a leaf, then there is only one node
    in the tree, so `1` is the correct return value. Otherwise, we’re looking at a
    nonleaf, and the number of nodes in the tree is one (this node) plus the number
    of nodes in the left subtree plus the number of nodes in the right subtree. That
    is, the two rules are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，给定一棵满二叉树的根节点指针，我们要返回树中节点的数量。如果该节点是叶子节点，那么树中只有一个节点，因此`1`是正确的返回值。否则，我们遇到的是一个非叶子节点，树中节点的数量是一个（即该节点）加上左子树节点的数量再加上右子树节点的数量。也就是说，两个规则如下：
- en: '**Rule 1**   If the root of the tree is a leaf node, then the number of nodes
    in the tree equals `1`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1** 如果树的根是一个叶子节点，那么树中节点的数量等于`1`。'
- en: '**Rule 2**   If the root of the tree is a nonleaf node, then the number of
    nodes in the tree equals `1` plus the number of nodes in the left subtree plus
    the number of nodes in the right subtree.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2** 如果树的根是一个非叶子节点，那么树中节点的数量等于`1`加上左子树中节点的数量，再加上右子树中节点的数量。'
- en: 'A rule like Rule 1 is known as a *base case*, because it can be solved directly,
    without using recursion. A rule like Rule 2 is known as a *recursive case*, because
    its solution requires that smaller subproblems be recursively solved. Every recursive
    function requires at least one base case and at least one recursive case: the
    base case tells us what to do when the problem is easy, and the recursive case
    tells us what to do when the problem is not.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 像规则 1 这样的规则被称为*基本情况*，因为它可以直接解决，无需使用递归。像规则 2 这样的规则被称为*递归情况*，因为它的解决需要递归地解决更小的子问题。每个递归函数至少需要一个基本情况和一个递归情况：基本情况告诉我们在问题简单时该怎么做，而递归情况告诉我们在问题复杂时该怎么做。
- en: Converting these rules to code yields the function in [Listing 2-9](ch02.xhtml#ch02ex09).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些规则转换为代码会得到[示例 2-9](ch02.xhtml#ch02ex09)中的函数。
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 2-9: Calculating the number of nodes*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-9：计算节点的数量*'
- en: Second, let’s write a function to return the number of leaves in a tree. If
    the node is a leaf, we return `1`. If the node is a nonleaf, then that node is
    *not* a leaf, so it doesn’t count; what does count is the number of leaves in
    the left subtree and the number of leaves in the right subtree. The code is given
    in [Listing 2-10](ch02.xhtml#ch02ex010).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来写一个函数，返回树中叶子节点的数量。如果节点是叶子节点，则返回`1`。如果节点是非叶子节点，那么该节点*不是*叶子节点，因此不计算在内；需要计算的是左子树中叶子节点的数量和右子树中叶子节点的数量。代码在[示例
    2-10](ch02.xhtml#ch02ex010)中给出。
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 2-10: Calculating the number of leaves*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 2-10：计算叶子节点的数量*'
- en: The only difference between this code and that in [Listing 2-9](ch02.xhtml#ch02ex09)
    is the lack of the `1 +` in the last line. Recursive functions are often very
    similar to each other but can compute very different things!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[示例 2-9](ch02.xhtml#ch02ex09)中的代码唯一的区别是最后一行缺少了`1 +`。递归函数通常非常相似，但可以计算出非常不同的结果！
- en: '*Walking the Minimum Number of Streets*'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*最小街道数的步行路径*'
- en: I’ve gone on and on and on, so you might want to revisit the problem description
    to reorient yourself. We know how to produce the total amount of candy now, but
    that’s only one of the two required outputs. We also need to output the minimum
    number of streets that must be walked to obtain all of the candy. No candy for
    guessing that we’ll nail this using recursion!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说了这么多，你可能需要重新回顾一下问题描述来重新定位自己。现在我们知道如何计算出糖果的总量了，但那只是两个必需输出中的一个。我们还需要输出获得所有糖果所需走的最少街道数量。想要猜出我们将如何解决这个问题吗？我们会使用递归！
- en: Calculating the Number of Streets
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算街道的数量
- en: Earlier, I provided a 30-street walk for the tree in [Figure 2-2](ch02.xhtml#ch02fig02).
    I also asked you to find an even better—and in fact optimal—26-street walk. This
    optimal walk saves four streets by taking advantage of the fact that we can end
    the walk as soon as the final piece of candy has been collected. There’s no requirement
    in the problem description to walk back to the root of the tree.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提供了[图 2-2](ch02.xhtml#ch02fig02)中树的30条街道步行路径。我还要求你找到一个更好，实际上是最优的26条街道路径。这个最优路径通过利用收集完最后一颗糖果后就可以结束步行的事实，节省了四条街道。问题描述中并没有要求步行返回树的根节点。
- en: What if we *did* return to the root of the tree as part of the walk? It’s true
    that we’d get the wrong answer, because we’d walk more streets than required.
    It’s also true, though, that returning to the root greatly simplifies the problem.
    We don’t have to be concerned with the thorny issue of how to cleverly do the
    walk to minimize the number of streets. (After all, we’ll end up back at the root,
    so we don’t have to orchestrate things so that the final house we visit is a good
    choice.) Perhaps we’ll be able to overshoot the minimum (by returning to the root)
    and then subtract off the extra streets that we walked? That’s our gambit!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们*确实*将步行路径包括返回到树的根节点怎么办？确实这样会得到错误的答案，因为我们走的街道比要求的多。不过，返回根节点也大大简化了问题。我们就不需要为如何巧妙地进行步行以最小化街道数而烦恼了。（毕竟，我们最终会回到根节点，所以我们不需要精心安排最后访问的房子是个好选择。）也许我们可以通过返回根节点而超过最小值，然后减去走的多余街道？这是我们的赌注！
- en: Let’s follow the same plan as for `tree_candy` and define a base case and a
    recursive case.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照`tree_candy`的相同计划来定义基本情况和递归情况。
- en: What do we do if the root of the tree is a house—how many streets do we walk
    starting from that house and getting back to that house? The answer is zero! No
    streets are required.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树的根是房屋节点——从这个房屋开始并返回到这个房屋，我们需要走多少街道？答案是零！不需要走任何街道。
- en: 'What do you do if the root is a nonhouse? Return to [Figure 2-3](ch02.xhtml#ch02fig03),
    where I split the tree in two. Suppose we knew the number of streets required
    to walk the F subtree and the number of streets required to walk the G subtree.
    We can calculate those recursively. Then, add H and its two edges back in. How
    many more streets must we walk now? We have to walk one street from H to F and
    then walk one street from F back to H after we finish with the F subtree. We have
    to do similarly for G: walking from H to G and then from G back to H after we
    finish with the G subtree. That’s four additional streets, beyond those that we
    get from the recursion.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根节点是一个非房屋节点怎么办？返回到[图 2-3](ch02.xhtml#ch02fig03)，在这里我将树分成了两部分。假设我们已经知道了行走F子树所需的街道数和行走G子树所需的街道数。这些可以递归计算。然后，将H及其两条边加回来。现在我们还需要走多少街道？我们必须从H走一条街道到F，完成F子树后，再从F走一条街道返回H。对于G也是类似：从H走到G，然后在完成G子树后从G返回H。这四条额外的街道是递归计算之外的。
- en: 'Here are our two rules:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的两个规则：
- en: '**Rule 1**   If the root of the tree is a house node, then the number of streets
    we walk is zero.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1** 如果树的根是房屋节点，那么我们走的街道数是零。'
- en: '**Rule 2**   If the root of the tree is a nonhouse node, then the number of
    streets we walk is the number of streets we walk for the left subtree plus the
    number of streets we walk for the right subtree plus `4`.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2** 如果树的根是一个非房屋节点，那么我们走的街道数是左子树所需的街道数加上右子树所需的街道数，再加上`4`。'
- en: At this stage, you should be getting a little more comfortable converting such
    rules into code. [Listing 2-11](ch02.xhtml#ch02ex011) supplies an implementation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，你应该开始更熟练地将这些规则转换成代码了。[列表 2-11](ch02.xhtml#ch02ex011)提供了一个实现。
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 2-11: Calculating the number of streets getting back to the root*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-11：计算返回根节点所需的街道数*'
- en: If you perform a walk in [Figure 2-2](ch02.xhtml#ch02fig02) starting at H, collecting
    all the candy, and ending at H, you will walk 32 streets. No matter how you walk
    the tree, as long as you visit each house once and don’t unnecessarily rewalk
    streets, you’ll get 32\. The minimum number of streets we can walk, with no requirement
    to return to the root, is 26\. Since 32 – 26 = 6, by ending at the root we overshoot
    the correct answer by six.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从H开始走[图 2-2](ch02.xhtml#ch02fig02)，收集所有糖果，并最终回到H，你将走32条街道。无论你如何行走这棵树，只要每个房屋只访问一次，并且不重复走街道，你都会走32条。我们可以走的最少街道数是26条，无需返回根节点。从32减去26等于6，所以通过回到根节点，我们多走了六条街道。
- en: 'Because there’s no requirement to return to the root, it makes sense to arrange
    our walk so that the last house that we visit is as far away as possible from
    the root. For example, ending at the house with 7 pieces of candy is a bad move,
    because we’re only two streets from H anyway—but look at those gloriously distant
    4 and 9 houses way at the bottom. It would be wonderful to end our walk at one
    of those houses. If we end our walk at 9, for example, then we’d save six streets:
    9 to B, B to C, C to D, D to E, E to F, and F to H.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有要求返回根节点，所以合理的做法是安排我们的行走，使得最后一个访问的房屋尽可能远离根节点。例如，最终在拥有7块糖果的房屋停下来就是一个糟糕的选择，因为无论如何我们离H只有两条街道——但看看那些远在底部的4号和9号房屋。将我们的行走结束在这些房屋之一将是很棒的。如果我们以9号房屋结束行走，那么我们可以节省六条街道：从9到B，从B到C，从C到D，从D到E，从E到F，最后从F到H。
- en: The plan, then, is to end our walk at a house that is located the maximum number
    of streets away from the root. If that house is six streets from the root, it
    means that there is a path of six edges from the root to some leaf. This is exactly
    the definition of the height of a tree! If we can calculate the height of a tree—recursively,
    I’ll bet—then we can subtract the height from what `tree_streets` gives us. That
    leaves us off at a house furthest from the root, thereby saving us the maximum
    number of streets.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是让我们的遍历以距离根节点最远的房子结束。如果那座房子距离根节点六条街道，意味着从根节点到某个叶子有六条边。这正是树的高度定义！如果我们能计算出树的高度——我敢打赌是递归地——那么我们可以从`tree_streets`给出的值中减去树的高度。这样就能让我们到达离根节点最远的房子，从而节省最大数量的街道。
- en: As a quick aside, there’s actually no reason to know which house is the furthest,
    or even to know how to perform a walk to make that house be last. All we have
    to do is convince ourselves that we *can* construct a walk to make that house
    be last. I’ll give a quick argument using [Figure 2-2](ch02.xhtml#ch02fig02) that
    I hope convinces you. Starting at H, compare the heights of the F and G subtrees,
    and completely walk whichever has smaller height—G, in this case. Then, repeat
    this process using F’s subtrees. Compare the heights of the A and E subtrees,
    and completely walk the A subtree (because it’s height is smaller than that of
    E). Keep doing this until all subtrees have been walked; the final house that
    you visit will be a house furthest from H.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，实际上没有必要知道哪座房子是最远的，甚至也不需要知道如何执行一次遍历来确保那座房子是最后一个。我们要做的只是说服自己，我们*可以*构建一条路径，使得那座房子成为最后一个。我将通过[图
    2-2](ch02.xhtml#ch02fig02)给出一个简短的论证，希望能说服你。从H开始，比较F和G子树的高度，完全遍历高度较小的那一棵——在这个例子中是G。然后，重复这个过程，使用F的子树。比较A和E子树的高度，完全遍历A子树（因为它的高度比E的要小）。一直这样做，直到所有子树都被遍历；你访问的最后一座房子将是离H最远的房子。
- en: Calculating Tree Height
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算树的高度
- en: Let’s now move on to `tree_height` and another manifestation of our Rule 1–
    Rule 2 recursive approach.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论`tree_height`和我们规则1-规则2递归方法的另一种表现。
- en: The height of a tree consisting of a single house is zero, because there are
    no edges at all that we can traverse.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由单个房子组成的树的高度是零，因为没有任何边可以遍历。
- en: For a tree whose root is a nonhouse, consult [Figure 2-3](ch02.xhtml#ch02fig03)
    again. The F subtree has a height of five, and the G subtree has a height of one.
    We can solve these subproblems recursively. The height of the original tree, with
    H in there, is one more than the maximum of five and one, because an edge from
    H increases the number of edges to each leaf by one.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根节点是非房子的树，再次参阅[图 2-3](ch02.xhtml#ch02fig03)。F子树的高度为五，G子树的高度为一。我们可以递归地解决这些子问题。原始树的高度（包括H）是五和一的最大值加一，因为从H出发的边增加了到每个叶子的边数。
- en: 'That analysis gives us these two rules:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这一分析给出了以下两条规则：
- en: '**Rule 1**   If the root of the tree is a house node, then the tree’s height
    is zero.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1** 如果树的根是房子节点，那么树的高度为零。'
- en: '**Rule 2**   If the root of the tree is a nonhouse node, then the tree’s height
    is one more than the maximum of the left subtree’s height and the right subtree’s
    height.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2** 如果树的根是一个非房子节点，那么树的高度是左子树高度和右子树高度的最大值再加一。'
- en: See [Listing 2-12](ch02.xhtml#ch02ex012) for the code. We have a little `max`
    helper function to tell us the maximum of two numbers; otherwise, `tree_height`
    holds no surprises.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[清单 2-12](ch02.xhtml#ch02ex012)中的代码。我们有一个小的`max`辅助函数，用于告诉我们两个数字中的最大值；否则，`tree_height`没有什么惊讶之处。
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 2-12: Calculating the height of the tree*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-12：计算树的高度*'
- en: We now have `tree_candy` to calculate the total amount of candy and `tree_streets`
    and `tree_height` to calculate the minimum number of streets. Putting those three
    together gives us a function that solves the problem given a tree; see [Listing
    2-13](ch02.xhtml#ch02ex013).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`tree_candy`来计算糖果的总量，`tree_streets`和`tree_height`来计算最小街道数。将这三者结合起来，给我们一个能在给定树的情况下解决问题的函数；见[清单
    2-13](ch02.xhtml#ch02ex013)。
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 2-13: Solving the problem, given a tree*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-13：给定一棵树来解决问题*'
- en: Try calling this function on the trees you built in “Building a Tree” on [page
    43](ch02.xhtml#ch02lev1).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你在“构建树”中创建的树上调用这个函数，参见[第43页](ch02.xhtml#ch02lev1)。
- en: '*Reading the Input*'
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*读取输入*'
- en: We are now ever so close, but we’re not quite there. Yes, we can solve the problem
    if we have a tree in hand, but recall that the input to the problem is lines of
    text, not trees. We’ll have to convert each of those lines to a tree before we
    can unleash `tree_solve` on it. At last, we’re finally ready to unveil the way
    in which trees are represented as text.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经非常接近了，但还没有完全解决。是的，如果我们手中有一棵树，我们可以解决这个问题，但请记住，问题的输入是文本行，而不是树。我们必须先将每一行转换为一棵树，然后才能对其应用`tree_solve`。最终，我们终于准备好揭示树是如何作为文本表示的。
- en: Representing a Tree as a String
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将树表示为字符串
- en: I’ll show you the correspondence between a line of text and its tree by progressing
    through several examples.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过几个例子向你展示文本和其树形结构之间的对应关系。
- en: 'First, a tree of a single house node is represented simply as the text of the
    candy value. For example, this tree (whose node’s candy value is four):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个单一房屋节点的树仅仅通过糖果值的文本来表示。例如，这棵树（其节点的糖果值是四）：
- en: '![Image](../images/unch02fig06.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch02fig06.jpg)'
- en: 'is represented as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表示如下：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A tree whose root is a nonhouse node is represented (recursively!) by the following,
    in order: an opening parenthesis, a first smaller tree, a space, a second smaller
    tree, and a closing parenthesis. The first smaller tree in there is the left subtree,
    and the second smaller tree is the right subtree. For example, this three-node
    tree'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一棵根节点是非房屋节点的树（递归地！）按照以下顺序表示：一个左括号、第一个较小的树、一个空格、第二个较小的树和一个右括号。这里的第一个较小的树是左子树，第二个较小的树是右子树。例如，这棵三节点的树
- en: '![Image](../images/unch02fig07.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch02fig07.jpg)'
- en: 'is represented like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表示如下：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, here is a five-node tree:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这里是一个五节点的树：
- en: '![Image](../images/unch02fig08.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/unch02fig08.jpg)'
- en: 'This five-node tree is represented like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个五节点的树表示如下：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the left subtree is `(4 9)` and the right subtree is `15`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，左子树是`(4 9)`，右子树是`15`。
- en: 'Written as rules, we have the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以规则的形式，我们有以下内容：
- en: '**Rule 1**   If the text is the digits of integer `c`, then the tree is a single
    house node with `c` candy.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1**   如果文本是整数`c`的数字，那么树就是一个带有`c`糖果的单一房屋节点。'
- en: '**Rule 2**   If the text starts with an opening parenthesis, then the root
    of the tree is a nonhouse node. After the opening parenthesis, the text contains
    the tree’s left subtree, a space, the tree’s right subtree, and a closing parenthesis.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2**   如果文本以左括号开始，那么树的根节点是一个非房屋节点。在左括号之后，文本包含树的左子树、一个空格、树的右子树和右括号。'
- en: Reading in a Nonhouse Node
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 读取非房屋节点
- en: 'Our goal is to write function `read_tree` with this signature:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写具有以下签名的`read_tree`函数：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It takes a string, and it returns the corresponding tree.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个字符串，并返回相应的树。
- en: Let’s start by implementing Rule 2, since Rule 1 involves some subtle work to
    convert characters to integers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现规则 2 开始，因为规则 1 涉及将字符转换为整数的微妙工作。
- en: 'Rule 2, the recursive rule, requires us to make two calls to `read_tree`: one
    to read the left subtree and one to read the right subtree. Let’s see how far
    we get:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 2，这个递归规则，要求我们对`read_tree`进行两次调用：一次读取左子树，一次读取右子树。让我们看看我们能走多远：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After allocating memory for the root of our tree, we make a recursive call
    to read the left subtree ➊. We pass a pointer to index `1` of `line` so that the
    recursive call receives the string not including the opening parenthesis at index
    `0`. However, in the next line, we’re in trouble ➋. Where do we start reading
    the right subtree? Equivalently, how many characters are in the left subtree?
    We don’t know! We could write a separate function to figure out where the left
    subtree ends. For example, we could count the number of opening and closing parentheses
    until they’re equal, except that this seems wasteful: If `read_tree` successfully
    read the left subtree, surely that recursive call knew where that subtree ended?
    If only there were a way to communicate that information back to the original
    `read_tree` call, it could use that to determine what part of the string to pass
    to the second recursive call.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在为树的根分配内存后，我们发起递归调用来读取左子树 ➊。我们传递一个指向 `line` 索引 `1` 的指针，以便递归调用接收到的字符串不包括索引 `0`
    处的左括号。然而，在下一行中，我们遇到了问题 ➋。我们该从哪里开始读取右子树？换句话说，左子树有多少个字符？我们不知道！我们本可以写一个单独的函数来找出左子树的结束位置。例如，我们可以计算开括号和闭括号的数量，直到它们相等，但这似乎有些浪费：如果
    `read_tree` 已成功读取左子树，那么那个递归调用肯定知道左子树在哪里结束吧？如果只有一种方法能将这个信息传回给原始的 `read_tree` 调用，它就能利用这个信息来确定应该将字符串的哪一部分传递给第二个递归调用。
- en: Adding a parameter to a recursive function is a general and powerful way to
    solve this kind of problem. Whenever a recursive call has information not conveyed
    through what it returns, or it needs information that is not passed, consider
    adding a parameter. If that parameter is a pointer, it can be used to both pass
    additional information to recursive calls and receive information back.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 向递归函数添加参数是一种通用且强大的方法来解决这类问题。每当递归调用有一些信息未通过其返回值传递，或者需要某些未传递的信息时，可以考虑添加一个参数。如果该参数是指针类型，它既可以用于将附加信息传递给递归调用，也可以用来接收返回的信息。
- en: For our purposes, we want to be able to tell a recursive call where its string
    starts. Also, we want the recursive call to be able to tell us, when it’s finished,
    where we should continue processing the string. To do this, we’ll add an integer
    pointer parameter `pos`. However, we don’t want to add that parameter to `read_tree`,
    because the caller of `read_tree` has no business or interest knowing about this
    extra parameter. The caller of `read_tree` should be able to just pass a string,
    not caring about this `pos` parameter that is internal to our implementation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们希望能够告诉递归调用它的字符串从哪里开始。同时，我们希望递归调用能够在完成时告诉我们应该从哪里继续处理字符串。为此，我们将添加一个整数指针参数
    `pos`。然而，我们不想将这个参数添加到 `read_tree` 中，因为 `read_tree` 的调用者不需要知道这个额外的参数。`read_tree`
    的调用者应该只需传递一个字符串，而不关心这个内部实现的 `pos` 参数。
- en: We’ll keep the signature of `read_tree` as before, with only the `line` parameter.
    Then `read_tree` will call `read_tree_helper`, and it’s `read_tree_helper` that
    has this `pos` parameter and induces the recursion.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持 `read_tree` 的签名不变，仅保留 `line` 参数。然后，`read_tree` 将调用 `read_tree_helper`，而
    `read_tree_helper` 拥有这个 `pos` 参数，并引发递归。
- en: '[Listing 2-14](ch02.xhtml#ch02ex014) gives the `read_tree` code. It passes
    a pointer to `0` to `read_tree_helper`, because index `0` (the start of the string)
    is where we want to start processing.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-14](ch02.xhtml#ch02ex014) 给出了 `read_tree` 代码。它将一个指针指向 `0` 传递给 `read_tree_helper`，因为索引
    `0`（字符串的开始位置）是我们希望开始处理的地方。'
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 2-14: Calling our helper, with a pointer to* int'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-14：调用我们的助手，传递一个指向* int 的指针'
- en: 'We’re now ready to try again with our implementation of Rule 2:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好再次尝试实现规则 2：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The function will be called with `pos` referring to the first character of a
    tree, so we first advance `pos` by one character to skip over the opening parenthesis
    ➊. Now `pos` is perfectly positioned at the start of the left subtree. We then
    make the recursive call to read the left subtree. That recursive call will update
    `pos` to the index of the character following the left subtree. Because a space
    follows the left subtree, we skip over that space ➋. Now we’re positioned at the
    start of the right subtree; we recursively grab that right subtree and then skip
    over the closing parenthesis ➌, the one that closes the opening parenthesis that
    we skipped over initially ➊. Skipping the closing parenthesis is important, because
    this function is responsible for processing the entire subtree, including its
    closing parenthesis. If we left out this final skip, whoever called the function
    may be left staring at a closing parenthesis when they expected a space. After
    skipping that closing parenthesis, the only thing left to do is return our tree.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将被调用，`pos`指向树的第一个字符，因此我们首先将`pos`向前移动一个字符，以跳过开括号➊。现在，`pos`正好位于左子树的起始位置。然后我们递归地调用来读取左子树。这个递归调用将更新`pos`，指向左子树后的字符索引。由于左子树后面是一个空格，我们跳过这个空格➋。现在我们位于右子树的起始位置；我们递归地抓取右子树，然后跳过闭括号➌，它是最初跳过的开括号的匹配闭括号➊。跳过闭括号很重要，因为这个函数负责处理整个子树，包括它的闭括号。如果我们没有跳过这个闭括号，调用该函数的人可能会看到一个闭括号，而他们本来应该看到一个空格。跳过闭括号后，剩下的工作就是返回我们的树。
- en: Reading in a House Node
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 读取一个房屋节点
- en: 'With Rule 2 out of the way, let’s tackle Rule 1\. Before we can make much progress,
    we’ll need to be able to convert part of a string to an integer. Let’s write a
    small, separate program to make sure that we can do this. It will take a string
    that we assume represents a house node and print its candy value. Surprisingly,
    if we’re not careful, we may get baffling results. Be advised: we are not careful
    in [Listing 2-15](ch02.xhtml#ch02ex015).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 解决完规则2后，我们来处理规则1。在我们能取得更大进展之前，我们需要能够将字符串的一部分转换为整数。让我们编写一个小程序，确保我们能够做到这一点。这个程序将接受一个字符串，我们假设它代表一个房屋节点，并输出它的糖果值。令人吃惊的是，如果我们不小心，可能会得到令人困惑的结果。请注意：在[清单2-15](ch02.xhtml#ch02ex015)中，我们并没有小心。
- en: '[PRE37]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 2-15: Reading a candy value (bugged!)*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-15：读取糖果值（有 bug！）*'
- en: Run that program and enter the number `4`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序并输入数字`4`。
- en: You’ll likely see `52` as the output. Run it again and enter the number `9`.
    You’re likely to see `57`. Now run it with `0`. You’ll likely see `48`. Finally,
    run it with each value from `0` to `9`. You should see that each output is offset
    by the output that `0` produced. If `0` outputs 48, then `1` will output 49, `2`
    will output 50, `3` will output 51, and so on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到`52`作为输出。再运行一次，输入数字`9`，你可能会看到`57`。现在再试一下输入`0`，你可能会看到`48`。最后，试试输入从`0`到`9`的每个数字。你应该会发现每个输出值与`0`的输出值偏差相同。如果`0`输出48，那么`1`将输出49，`2`输出50，`3`输出51，依此类推。
- en: What we’re seeing here is the character code for each digit. The crucial point
    is that the codes for integers are consecutive. We can therefore subtract the
    character code for zero to put our integers in the proper range. With this fix,
    we get the code in [Listing 2-16](ch02.xhtml#ch02ex016). Try it!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是每个数字的字符代码。关键点是，整数的字符代码是连续的。因此，我们可以通过减去零的字符代码，将整数放入正确的范围。修正后，我们得到[清单2-16](ch02.xhtml#ch02ex016)中的代码。试试看吧！
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 2-16: Reading a candy value*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-16：读取糖果值*'
- en: This little program works for single-digit integers. The description of Halloween
    Haul, though, requires that we also accommodate candy integers that are two digits.
    Suppose we read digit `2` and then digit `8`. We want to combine these and end
    up with the integer `28`. What we can do is multiply the first digit by 10 (that
    gives us 20 here) and then add the 8 (for a total of 28). [Listing 2-17](ch02.xhtml#ch02ex017)
    is another little test program to enable us to check that we’ve got this right.
    Here we assume that a string of two digits will be typed.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序适用于单个数字的整数。然而，Halloween Haul的描述要求我们也能处理两位数的糖果整数。假设我们先读到数字`2`，然后是数字`8`。我们希望将这两个数字组合起来，得到整数`28`。我们可以通过将第一个数字乘以10（这样就得到20），然后再加上8（总共是28）来实现。[清单2-17](ch02.xhtml#ch02ex017)是另一个小测试程序，帮助我们检查我们是否做对了。在这里，我们假设会输入一个两位数的字符串。
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 2-17: Reading a candy value with two digits*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-17：读取一个两位数的糖果值*'
- en: 'That’s all we need for Rule 1, and we can write this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是规则1所需的全部内容，我们可以写出如下代码：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We begin by setting the left and right subtrees to `NULL`; we’re creating a
    house node, after all. We then take a character and convert it to a digit ❶ and
    then skip over that digit ➋. Now, if this candy value is only one digit, then
    we have correctly stored its value. If it is two digits, then we need to multiply
    the first digit by 10 and add the second digit. We therefore determine whether
    the candy value is one or two digits. If we’re not looking at a closing parenthesis,
    or a space, or the null terminator at the end of the string, then we must be looking
    at a second digit. If a second digit is present, we incorporate it into our candy
    value ➌ and move past the digit ➍.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将左子树和右子树设置为`NULL`；毕竟我们是在创建一个树节点。接下来，我们取一个字符并将其转换为数字❶，然后跳过该数字➋。现在，如果这个糖果值只有一位数字，那么我们就已经正确存储了它的值。如果是两位数字，那么我们需要将第一位数字乘以10并加上第二位数字。因此，我们需要确定糖果值是一个数字还是两个数字。如果我们看到的不是一个右括号、空格或者字符串末尾的空字符，那么我们就必须在看第二位数字。如果第二位数字存在，我们将其加入到糖果值中➌，并移动到下一个数字
    ➍。
- en: '[Listing 2-18](ch02.xhtml#ch02ex018) puts together our code for Rules 2 and
    1.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-18](ch02.xhtml#ch02ex018)展示了我们为规则2和规则1编写的代码。'
- en: '[PRE41]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 2-18: Converting a string to a tree*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-18：将字符串转换为树*'
- en: All that’s left is to construct a tidy `main` function to read each test case
    and solve it! [Listing 2-19](ch02.xhtml#ch02ex019) is all it takes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是构建一个整洁的`main`函数，读取每个测试用例并解决它！[清单 2-19](ch02.xhtml#ch02ex019)就是所需的一切。
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Listing 2-19: The* main *function*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-19：主函数*'
- en: We’ve successfully used recursion to solve this problem, as you should be able
    to verify by submitting our solution to the judge.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功使用递归解决了这个问题，你应该能通过将我们的解法提交给判题系统来验证这一点。
- en: Why Use Recursion?
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用递归？
- en: 'It’s not always easy to know whether recursion will offer a clean solution
    to a problem. Here’s the telltale sign: whenever a problem can be solved by combining
    solutions to smaller subproblems, you should try recursion. In all of our recursive
    code in this chapter, we have solved exactly two subproblems in order to solve
    the larger problem. These two-subproblem problems are very common, but a problem
    may require solving three or four or more subproblems.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候很难知道递归是否能为一个问题提供简洁的解决方案。这里有一个明显的标志：每当一个问题可以通过组合解决更小子问题的解决方案来解决时，你应该尝试使用递归。在本章的所有递归代码中，我们都是通过解决正好两个子问题来解决更大的问题。这类“两子问题”的问题非常常见，但有些问题可能需要解决三个、四个或更多的子问题。
- en: How do you know that breaking a problem into subproblems can help you solve
    the original problem, and how do you know what those subproblems are in the first
    place? We’ll revisit these questions in [Chapter 3](ch03.xhtml), when we build
    on what we’ve learned here to study memoization and dynamic programming. In the
    meantime, think about whether you could easily solve a given problem if someone
    told you the solutions to smaller subproblems. For example, think back to calculating
    the total amount of candy in the tree. This is not an easy problem. What if someone
    told you the total amount of candy in the left subtree and the total amount of
    candy in the right subtree? That would make the problem easier. A problem made
    easier by virtue of knowing its subproblem solutions is a strong clue that recursion
    applies.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么知道将一个问题分解为子问题可以帮助你解决原始问题，且你又怎么知道这些子问题是什么呢？我们将在[第3章](ch03.xhtml)中重新探讨这些问题，当时我们会基于在这里学到的内容，研究记忆化和动态规划。与此同时，想一想，如果有人告诉你较小子问题的解决方案，你是否能够轻松地解决给定的问题。例如，回想一下计算树中糖果总数的问题。这不是一个简单的问题。如果有人告诉你左子树和右子树中的糖果总数，问题就变得容易了。通过知道子问题的解决方案使问题变得更简单，这强烈暗示了递归的适用性。
- en: Let’s move on to another problem where recursion is useful. As you read the
    problem description, try to identify where and why recursion will come into play.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论另一个递归非常有用的问题。当你阅读问题描述时，试着找出递归会在何时、为何出现。
- en: 'Problem 2: Descendant Distance'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题2：后代距离
- en: We’ll now move away from binary trees to general trees in which nodes can have
    many children.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从二叉树转向一般树，其中节点可以有多个子节点。
- en: This is DMOJ problem `ecna05b`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ题目`ecna05b`。
- en: '*The Problem*'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题*'
- en: In this problem, we are given a family tree and a specified distance *d*. The
    score for each node in the tree is the number of descendants it has at distance
    *d*. Our task is to output the nodes with high scores; I’ll explain exactly how
    many nodes that is in the Output section. To see what I mean by descendants at
    a specified distance, look at the family tree in [Figure 2-6](ch02.xhtml#ch02fig06).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们给定了一个家族树和一个指定的距离*d*。树中每个节点的得分是它在距离*d*处的后代数量。我们的任务是输出得分较高的节点；我将在输出部分详细说明需要输出多少节点。为了理解我所说的指定距离的后代，请看[图2-6](ch02.xhtml#ch02fig06)中的家族树。
- en: '![Image](../images/ch02fig06.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch02fig06.jpg)'
- en: '*Figure 2-6: A sample family tree*'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：一个示例家族树*'
- en: 'Consider the Amber node. Amber has four children, so she has four descendants
    at a distance of one. Amber also has five grandchildren: five nodes at a distance
    of two. Generalizing, we can say that, for any node, the number of descendants
    at distance *d* is the number of nodes that are exactly *d* edges down the tree
    from that node.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Amber节点。Amber有四个孩子，所以她在距离一的地方有四个后代。Amber还有五个孙子：五个在距离二的节点。一般来说，我们可以说，对于任何节点，距离*d*处的后代数量是该节点到树中恰好距离*d*的节点数。
- en: Input
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: 'The first line of input gives the number of test cases that will follow. Each
    test case consists of the following lines:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的第一行给出接下来将要处理的测试用例的数量。每个测试用例包含以下几行：
- en: A line containing two integers, *n* and *d*, where *n* tells us how many more
    lines there are for this test case and *d* specifies the descendant distance of
    interest.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含两个整数，*n*和*d*，其中*n*告诉我们该测试用例还有多少行，*d*指定了感兴趣的后代距离。
- en: '*n* lines used to build the tree. Each of these lines consists of the name
    of a node, an integer *m*, and *m* node names giving the children of this node.
    Each name is at most 10 characters long. These lines can come in any order—there’s
    no requirement that parent lines come before their descendant lines.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n*行用于构建树。每行包含一个节点的名称，一个整数*m*，以及*m*个节点名称，表示该节点的子节点。这些名称最多10个字符长。这些行的顺序可以是任意的——父节点行不要求在其后代节点行之前。'
- en: There are at most 1,000 nodes in any test case.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例最多包含1,000个节点。
- en: 'Here is a possible input to generate the sample tree in [Figure 2-6](ch02.xhtml#ch02fig06),
    asking for the nodes with the most descendants at a distance of two:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个可能的输入，用于生成[图2-6](ch02.xhtml#ch02fig06)中的示例树，要求输出距离为二的后代最多的节点：
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Output
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: The output for each test case has two parts.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的输出有两部分。
- en: 'First, output the following line:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，输出以下一行：
- en: '[PRE44]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: where i is `1` for the first test case, `2` for the second test case, and so
    on.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 其中i为`1`表示第一个测试用例，`2`表示第二个测试用例，以此类推。
- en: Then, output information for the nodes with high scores (where the score for
    a node is the number of descendants it has at distance *d*), sorted from most
    to least. Output the names that are tied for the number of descendants at distance
    *d* in alphabetical order.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出具有高分的节点信息（节点的得分是它在距离*d*处的后代数量），按得分从高到低排序。对于得分相同的节点，按字母顺序输出它们的名称。
- en: 'Use the following rules to determine how many names to output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下规则确定输出多少个名称：
- en: If there are three or fewer names with descendants at distance *d*, output them
    all.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有三个或更少的名字具有距离为*d*的后代，则输出它们所有。
- en: 'If there are more than three names with descendants at distance *d*, start
    by outputting those with the top three scores, starting from the highest score.
    Then, output each other name whose score is the same as the third score from the
    top. For example, if we have names with eight, eight, two, two, two, one, and
    one descendants at distance *d*, we would output information for five names: those
    with eight, eight, two, two, and two descendants at distance *d*.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有超过三个名称在距离*d*处有后代，则首先输出得分最高的前三个名称。然后，输出每个得分与第三名相同的名称。例如，如果我们有得分为八、八、二、二、二、一、一的后代名称，我们将输出五个名称的信息：得分为八、八、二、二和二的节点。
- en: For each name that we’re required to output, we output a line consisting of
    the name, followed by a space, followed by its number of descendants at distance
    *d*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个需要输出的名称，我们输出一行，包含该名称，后跟一个空格，再后跟它在距离*d*处的后代数量。
- en: Output for each test case is separated from the next by a blank line.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例的输出与下一个测试用例的输出之间由空行分隔。
- en: 'Here is the output for the above sample input:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上面示例输入的输出：
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The time limit for solving the test cases is 0.6 seconds.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 解决测试用例的时间限制为0.6秒。
- en: '*Reading the Input*'
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*读取输入*'
- en: One interesting difference between this problem and the Halloween Haul problem
    is that we’re no longer dealing with binary trees. Here, a node can have any number
    of children. We’ll have to change our node structure, since `left` and `right`
    pointers are not going to work for us anymore. Instead, we’ll use an array `children`
    of children and an integer `num_children` to record the number of children stored
    in the array. We’ll also have a `name` member to store the node’s name (Zara,
    Amber, and so on) and a `score` member for when we calculate the number of descendants
    at distance *d*. Our `node` struct is given in [Listing 2-20](ch02.xhtml#ch02ex020).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与《万圣节大采购》问题之间的一个有趣区别是，我们不再处理二叉树了。在这里，一个节点可以有任意数量的孩子。我们需要更改节点结构，因为`left`和`right`指针将不再适用。相反，我们将使用一个`children`数组来存储孩子们，并使用一个整数`num_children`来记录数组中存储的孩子数量。我们还将有一个`name`成员来存储节点的名字（如Zara、Amber等），以及一个`score`成员，当我们计算距离*d*的后代数时使用。我们的`node`结构体定义见[列表
    2-20](ch02.xhtml#ch02ex020)。
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Listing 2-20: The* node *struct*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-20：* 节点 *结构体*'
- en: 'In Halloween Haul, the trees started as recursively defined expressions, from
    which we could recursively read off the left and right subtrees. This is not the
    case here: nodes can come in any order. For example, we might see'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在《万圣节大采购》中，树是通过递归定义的表达式开始的，我们可以从中递归地读取左右子树。但在这里情况不同：节点可以按任意顺序出现。例如，我们可能会看到
- en: '[PRE47]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where we learn about Zara’s child, Amber, before we learn about Amber’s children.
    However, we could equally well see
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里先了解了Zara的孩子Amber，而不是先了解Amber的孩子。然而，我们也可能会看到
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: where we learn about Amber’s children before Zara’s!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里先了解了Amber的孩子，而不是Zara的孩子！
- en: We know that the nodes and parent-child relationships we read from the file
    will, by the time we’re done, form a single tree. Nonetheless, there’s no guarantee
    that we have a single tree as we process the lines. For example, we might read
    the lines
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，从文件中读取的节点和父子关系，在处理完成后会形成一棵单一的树。然而，在处理这些行时，并没有保证我们始终会得到一棵树。例如，我们可能会读取以下几行
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This tells us that Enzo is a child of Lucas and that Amber is a child of Zara,
    but so far that’s all we know. We have two disconnected subtrees here, and it
    will take future lines to connect these subtrees.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们Enzo是Lucas的孩子，Amber是Zara的孩子，但目前为止我们只知道这些。我们这里有两个不相连的子树，需要后续的行来连接这些子树。
- en: For these reasons, maintaining a single, connected tree as we read the lines
    is hopeless. Instead, we’ll maintain an array of pointers to nodes. Every time
    we see a name we haven’t seen before, we create a new node and add a pointer to
    that node to the array. It will therefore prove valuable to have a helper function
    that searches the array and tells us whether we have seen a name before.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，随着我们读取这些行，维持一棵单一的、连接的树是不可能的。相反，我们将维护一个指向节点的指针数组。每当我们看到一个之前没有见过的名字时，我们就会创建一个新节点，并将该节点的指针添加到数组中。因此，拥有一个辅助函数来搜索数组并告诉我们是否之前见过某个名字将会非常有价值。
- en: Finding a Node
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找节点
- en: '[Listing 2-21](ch02.xhtml#ch02ex021) implements a `find_node` function. The
    `nodes` parameter is an array of pointers to nodes, `num_nodes` gives the number
    of pointers in the array, and `name` is the name that we’re searching for.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-21](ch02.xhtml#ch02ex021)实现了一个`find_node`函数。`nodes`参数是一个指向节点的指针数组，`num_nodes`给出数组中指针的数量，`name`是我们要搜索的名字。'
- en: '[PRE50]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*Listing 2-21: Finding a node*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-21：查找节点*'
- en: A *linear search* is an element-by-element search of an array. Inside our function,
    we use a linear search to search through `nodes`, and . . . but wait! Aren’t we
    searching through an array? This is tailor-made hash table territory right here
    (see [Chapter 1](ch01.xhtml)). I encourage you to swap in a hash table on your
    own and compare the performance. To keep things simple, and because there are
    at most only 1,000 nodes, we’ll proceed with this (slow) linear search.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性搜索*是逐个元素查找数组的一种方法。在我们的函数中，我们使用线性搜索来查找`nodes`，而且……等等！我们难道不是在搜索一个数组吗？这正是哈希表的用武之地（参见[第1章](ch01.xhtml)）。我鼓励你自己尝试使用哈希表，并比较性能。为了简化处理，而且因为最多只有1000个节点，我们将继续使用这种（较慢的）线性搜索。'
- en: We do a string comparison between each name in the array and the desired name.
    If `strcmp` returns `0`, it means that the strings are equal, so we return the
    pointer to the corresponding node. If we reach the end of the array without finding
    the name, we return `NULL` to signal that the name was not found.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对数组中的每个名字与目标名字进行字符串比较。如果 `strcmp` 返回 `0`，意味着字符串相等，此时我们返回指向相应节点的指针。如果遍历完数组仍未找到该名字，我们返回
    `NULL`，表示没有找到该名字。
- en: Creating a Node
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个节点
- en: 'When a name is not found in the array, we’ll have to create a node with that
    name. This will involve a call to `malloc`, and we’ll see that `malloc` will be
    required elsewhere in the program as well. So, I’ve written a helper function,
    `malloc_safe`, that we can call whenever we need it. See [Listing 2-22](ch02.xhtml#ch02ex022):
    it’s just a regular `malloc`, but with error checking added:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当在数组中找不到一个名字时，我们需要创建一个包含该名字的节点。这将涉及到对 `malloc` 的调用，并且我们会看到在程序的其他部分也需要用到 `malloc`。因此，我编写了一个辅助函数
    `malloc_safe`，在需要时可以调用。见[清单 2-22](ch02.xhtml#ch02ex022)：它只是一个常规的 `malloc`，但是加入了错误检查：
- en: '[PRE51]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '*Listing 2-22: The* malloc_safe *function*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-22: malloc_safe 函数*'
- en: The `new_node` helper function in [Listing 2-23](ch02.xhtml#ch02ex023) uses
    `malloc_safe` to create a new node.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-23](ch02.xhtml#ch02ex023)中的 `new_node` 辅助函数使用 `malloc_safe` 来创建一个新节点。'
- en: '[PRE52]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '*Listing 2-23: Creating a node*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-23: 创建一个节点*'
- en: We allocate the new node and then set the node’s `name` member. Then, we set
    the node’s number of children to `0`. The reason we use zero here is because we
    may not know how many children the node has. For example, suppose that the first
    line that we read for the tree is
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为新节点分配内存，然后设置节点的 `name` 成员。接着，我们将节点的孩子数量设置为 `0`。这里我们使用零是因为我们可能不知道该节点有多少个孩子。例如，假设我们读取树的第一行是：
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We know that Lucas has one child, but we have no idea how many children Enzo
    has. The caller of `new_node` can set the number of children to a new value once
    that information is available. That happens immediately for Lucas here, but not
    for Enzo.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 Lucas 有一个孩子，但我们不清楚 Enzo 有多少个孩子。当 `new_node` 的调用者获得相关信息时，可以将孩子的数量设置为新的值。对于
    Lucas 来说，这一过程立即发生，但对于 Enzo，则不会。
- en: Building a Family Tree
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建家族树
- en: Now we’re ready to read and build the tree. [Listing 2-24](ch02.xhtml#ch02ex024)
    gives the function. Here `nodes` is an array of pointers to nodes, with space
    allocated by the caller of this function; `num_lines` indicates the number of
    lines to read.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备读取并构建树。[清单 2-24](ch02.xhtml#ch02ex024)给出了这个函数。这里的 `nodes` 是一个指向节点的指针数组，空间由调用此函数的代码分配；`num_lines`
    表示要读取的行数。
- en: '[PRE54]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Listing 2-24: Converting lines into a tree*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-24: 将行转换成树*'
- en: The outer `for` loop ➊ iterates once for each of the `num_lines` lines of input.
    Each line has the name of a parent and one or more names for children; we deal
    with the parent first. We allocate memory, read the parent’s name, and read the
    parent’s number of children. Then, we use our `find_node` helper function to determine
    whether we have seen this node before ➋. If we have not, we use our `new_node`
    helper function to create a new node, store a pointer to the new node in the `nodes`
    array, and increment the number of nodes. If the node is already in the `nodes`
    array, we free the memory for the parent name since it will not be used ➌.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 外层的 `for` 循环 ➊ 会对每一行输入（共有 `num_lines` 行）执行一次。每一行包含一个父母的名字以及一个或多个孩子的名字；我们首先处理父母的名字。我们分配内存，读取父母的名字，并读取父母的孩子数量。然后，我们使用
    `find_node` 辅助函数来确定这个节点是否之前出现过 ➋。如果没有出现过，我们就使用 `new_node` 辅助函数创建一个新节点，将新节点的指针存储在
    `nodes` 数组中，并增加节点数量。如果该节点已经在 `nodes` 数组中，我们就释放父母名字的内存，因为它将不再被使用 ➌。
- en: We next allocate memory for the parent’s child pointers ➍, and we store the
    number of children ➎. We then process the child nodes; each child is processed
    similarly to the parent node. Once the child node exists and has its members set,
    we store a pointer to it in the parent’s `children` array ➏. Notice that there
    is no child code that allocates any memory or sets the number of children, like
    we had for the parent. If we have seen a child name before, then its children
    were already set when this name was encountered the first time. If this is the
    first time we’re seeing the name, then we’ll set its children when we later learn
    about its children; if this child is a leaf, its number of children will remain
    at its initialized value of `0`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为父节点的子指针分配内存 ➍，并存储子节点的数量 ➎。然后我们处理子节点；每个子节点的处理方式与父节点类似。一旦子节点存在并设置好其成员，我们将一个指针存储在父节点的
    `children` 数组 ➏ 中。请注意，没有为子节点编写分配任何内存或设置子节点数量的代码，像我们为父节点所做的那样。如果我们之前见过某个子节点的名称，那么当第一次遇到这个名称时，它的子节点已经设置好了。如果这是我们第一次看到这个名称，那么当我们之后得知它的子节点时，会设置它的子节点；如果该子节点是叶子节点，它的子节点数量将保持初始化值
    `0`。
- en: We end by returning the number of nodes in the tree. We’ll need this when we
    want to process each node.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回树中节点的数量。当我们想要处理每个节点时，我们需要这个数据。
- en: '*Number of Descendants from One Node*'
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从一个节点的后代数量*'
- en: 'We need to calculate the number of descendants at distance *d* for each node,
    so we can find the nodes with the most such descendants. A more modest goal, and
    the goal for this section, is to calculate the number of descendants at distance
    *d* from a single node. We’ll write the function with this signature:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个节点计算距离 *d* 处的后代数量，以便找到具有最多此类后代的节点。一个更为谦逊的目标，也是本节的目标，是计算从一个节点出发的距离 *d*
    处的后代数量。我们将以这个签名编写函数：
- en: '[PRE55]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: where `n` is the node whose number of descendants at distance `d` we’d like
    to calculate.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`n` 是我们想要计算的节点，其后代在距离 `d` 处的数量。'
- en: 'If `d` is `1`, then we want to know the number of children of `n`. That we
    can do: we have stored a `num_children` member with each node. All we have to
    do is return that:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `d` 为 `1`，那么我们想知道 `n` 的子节点数量。我们可以做到这一点：我们已经为每个节点存储了一个 `num_children` 成员。我们所要做的就是返回它：
- en: '[PRE56]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If `d` is greater than `1`, then what? It may be worth thinking about this
    first in the more familiar context of binary trees. Here’s the binary tree from
    Halloween Haul ([Figure 2-2](ch02.xhtml#ch02fig02)) again:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `d` 大于 `1`，那么该怎么办？也许可以先在更熟悉的二叉树上下文中思考一下。这里再次展示万圣节大礼包的二叉树（[图 2-2](ch02.xhtml#ch02fig02)）：
- en: '![Image](../images/unch02fig09.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/unch02fig09.jpg)'
- en: Suppose we had a node of a binary tree and we wanted to know its number of descendants
    at some specified distance. If we knew how many descendants at that distance were
    in the left subtree and how many were in the right subtree, would that help?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个二叉树的节点，想要知道它在某个指定距离处的后代数量。如果我们知道左子树和右子树中距离该距离的后代数量，这是否有帮助？
- en: Not quite. Suppose, for example, that we wanted to know the number of descendants
    of H at a distance of two. We calculate the number of descendants of F at a distance
    of two and the number of descendants of G at a distance of two. That doesn’t help,
    because each of those descendants is at a distance of three from H! We don’t care
    about nodes at a distance of three.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 还不完全对。例如，假设我们想知道 H 节点在距离 2 处的后代数量。我们计算 F 节点和 G 节点在距离 2 处的后代数量。这样做没有帮助，因为这些后代离
    H 的距离是 3！我们不关心距离 H 为 3 的节点。
- en: How do we fix this? We calculate the number of descendants of F at a distance
    of one and G at a distance of one! Each of those nodes is at a distance of two
    from H.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？我们计算 F 节点在距离 1 处的后代数量，以及 G 节点在距离 1 处的后代数量！每个节点离 H 的距离是 2。
- en: To calculate the number of descendants at any distance *d*, then, we calculate
    the number of descendants at distance *d* – 1 in the left subtree and number of
    descendants at distance *d* – 1 in the right subtree.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要计算任意距离 *d* 处的后代数量，我们需要计算左子树中距离 *d* – 1 的后代数量，以及右子树中距离 *d* – 1 的后代数量。
- en: 'In the context of family trees, where a node can have more than two children,
    we generalize this slightly: the number of descendants at distance *d* is the
    sum of the number of descendants at distance *d* – 1 in each subtree. And how
    are we going to find the number of descendants at distance *d* – 1 in each subtree?
    It’s recursion time!'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在家族树的上下文中，节点可以有超过两个子节点，我们稍微概括一下：距离 *d* 的后代数量是每个子树中距离 *d* – 1 的后代数量之和。那么，我们如何找到每个子树中距离
    *d* – 1 的后代数量呢？是时候用递归了！
- en: 'Here are some rules for us to use. Given a node *n*:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则供我们使用。给定一个节点 *n*：
- en: '**Rule 1**   If *d* equals one, then the number of descendants at distance
    *d* equals the number of children of *n*.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 1**   如果 *d* 等于 1，则在距离 *d* 的后代数量等于 *n* 的子节点数量。'
- en: '**Rule 2**   If *d* is greater than one, then the number of descendants at
    distance *d* equals the sum of the number of descendants at distance *d* – 1 in
    each subtree of *n*.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**规则 2**   如果 *d* 大于 1，则在距离 *d* 的后代数量等于每个子树中距离 *d* – 1 的后代数量之和。'
- en: The corresponding code is given in [Listing 2-25](ch02.xhtml#ch02ex025).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的代码在[列表 2-25](ch02.xhtml#ch02ex025)中给出。
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Listing 2-25: The number of descendants from one node*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-25：一个节点的后代数量*'
- en: '*Number of Descendants from All Nodes*'
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*所有节点的后代数量*'
- en: To calculate the number of descendants at distance *d* for all nodes, we simply
    put `score_one` in a loop ([Listing 2-26](ch02.xhtml#ch02ex026)).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算所有节点在距离 *d* 的后代数量，我们只需将 `score_one` 放入循环中（参见[列表 2-26](ch02.xhtml#ch02ex026)）。
- en: '[PRE58]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Listing 2-26: The number of descendants from all nodes*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-26：所有节点的后代数量*'
- en: 'Here is where we use the `score` member in each `node` struct: after this function
    runs, `score` holds the number of descendants of interest for each node. Now we
    just have to figure out which nodes have the highest scores!'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在每个 `node` 结构体中使用 `score` 成员的地方：当这个函数运行时，`score` 将保存每个节点的后代数量。现在我们只需找出哪些节点具有最高的分数！
- en: '*Sorting Nodes*'
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*排序节点*'
- en: In our ill-fated attempt to sort snowflakes (see “Diagnosing the Problem” on
    [page 9](ch01.xhtml#ch01lev1)), we came across the C `qsort` function. We can
    bring `qsort` to bear here to sort our nodes. We’re required to sort by number
    of descendants at distance *d*, from highest to lowest. If nodes are tied for
    the number of descendants at distance *d*, then we sort those alphabetically.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们失败的雪花排序尝试中（参见“诊断问题”章节，见[第 9 页](ch01.xhtml#ch01lev1)），我们遇到了 C 语言中的 `qsort`
    函数。我们可以在这里使用 `qsort` 来排序我们的节点。我们需要按照距离 *d* 的后代数量从高到低进行排序。如果节点在距离 *d* 的后代数量上有并列情况，我们就按字母顺序对这些节点进行排序。
- en: To use `qsort`, we’re tasked with writing a comparison function that takes pointers
    to two elements and returns a negative integer if the first element is less than
    the second, `0` if they are equal, and a positive integer if the first is greater
    than the second. Our comparison function is given in [Listing 2-27](ch02.xhtml#ch02ex027).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `qsort`，我们需要编写一个比较函数，该函数接受两个元素的指针，并返回一个负整数（如果第一个元素小于第二个），返回 `0`（如果它们相等），或返回一个正整数（如果第一个元素大于第二个）。我们的比较函数在[列表
    2-27](ch02.xhtml#ch02ex027)中给出。
- en: '[PRE59]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '*Listing 2-27: A comparison function for sorting*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-27：用于排序的比较函数*'
- en: 'Any `qsort` comparison function, like this one, has the same signature: it
    takes two void pointers. These pointers are `const` to signify that we should
    not make any changes to the elements that they point to.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `qsort` 比较函数，如这个函数，具有相同的签名：它接受两个 `void` 指针。这些指针是 `const` 的，表示我们不应该对它们指向的元素进行任何修改。
- en: Void pointers must be cast before we can perform comparisons or otherwise access
    the underlying elements. Remember that `qsort` calls `compare` with pointers to
    two elements from our array, but, because our array is an array of pointers, what
    gets passed to `compare` is two pointers to pointers to elements. Therefore, we
    first cast the void pointers to type `const node**`, and then we apply `*` to
    give us values for `n1` and `n2` that are of type `const node*`. Now we can use
    `n1` and `n2` as pointers to nodes.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行比较或其他方式访问底层元素之前，必须先对 `void` 指针进行类型转换。记住，`qsort` 会将我们数组中的两个元素的指针传递给 `compare`，但是因为我们的数组是指针的数组，传递给
    `compare` 的实际上是指向元素指针的指针。因此，我们首先将 `void` 指针转换为 `const node**` 类型，然后使用 `*` 运算符来获取
    `n1` 和 `n2` 的值，这样它们的类型就是 `const node*`。现在我们可以将 `n1` 和 `n2` 用作节点的指针了。
- en: We begin by comparing the scores that are stored in each node. These scores
    will have already been calculated as the number of descendants at the distance
    *d*. If `n1` has more such descendants than `n2`, we return `-1` to indicate that
    `n1` should sort before `n2`. Similarly, if `n1` has fewer descendants at distance
    *d* than `n2`, we return `1` to indicate that `n1` should sort after `n2`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始比较存储在每个节点中的分数。这些分数已经通过计算距离*d*的后代数得出。如果`n1`的后代数比`n2`多，我们返回`-1`表示`n1`应该排在`n2`之前。类似地，如果`n1`的后代数比`n2`少，我们返回`1`表示`n1`应该排在`n2`之后。
- en: The only way to get to the final line, then, is if `n1` and `n2` have the same
    number of descendants at distance *d*. It’s here where we want to break the tie
    by sorting on the nodes’ names. We do this using `strcmp`, which returns a negative
    number, zero, or positive number if the first string is alphabetically less than,
    equal to, or greater than the second string, respectively.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有当`n1`和`n2`在距离*d*的后代数相同时，才能到达最后一行。在这里，我们希望通过对节点的名称进行排序来打破平局。我们通过`strcmp`实现这一点，它会返回一个负数、零或正数，分别表示第一个字符串在字母顺序上小于、等于或大于第二个字符串。
- en: '*Outputting the Information*'
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*输出信息*'
- en: 'After we sort the nodes, the names to output are those at the beginning of
    the `nodes` array. [Listing 2-28](ch02.xhtml#ch02ex028) gives the function that
    produces this output:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 排序节点后，输出的名称是`nodes`数组开头的那些。[清单 2-28](ch02.xhtml#ch02ex028)给出了生成该输出的函数：
- en: '[PRE60]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Listing 2-28: Outputting the nodes*'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-28：输出节点*'
- en: 'The variable `i` counts the number of nodes that we have outputted. The outer
    `while` loop ➊ is controlled by three conditions that together determine whether
    we are allowed to output more nodes. If all three conditions are true, we know
    that more output is required, so we enter the body of that `while` loop. We then
    print information for the current node and increase `i` so that we look at the
    next node. Now, as long as this new node is tied with the previous node, we want
    to keep outputting nodes, with no heed to the “maximum of three nodes” rule. The
    conditions on the inner `while` loop ➋ encode this logic: if there are more nodes
    and the current node’s score is tied with the previous node, then we enter the
    body of the inner `while` loop and print information for the relevant node.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`i`统计我们已经输出的节点数。外部`while`循环➊由三个条件控制，这三个条件共同决定是否允许我们输出更多节点。如果三个条件都为真，我们知道需要更多输出，因此进入该`while`循环的主体。然后，我们打印当前节点的信息，并增加`i`，使我们查看下一个节点。现在，只要这个新节点与前一个节点相同，我们就想继续输出节点，而不考虑“三个节点最大限制”规则。内部`while`循环➋的条件编码了这个逻辑：如果还有更多节点且当前节点的分数与前一个节点相同，那么我们进入内部`while`循环的主体，并打印相关节点的信息。
- en: '*The main Function*'
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*主函数*'
- en: All that remains is to glue our functions together and add the logic to process
    the test cases. We do this in [Listing 2-29](ch02.xhtml#ch02ex029).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将我们的函数连接在一起，并添加处理测试用例的逻辑。我们在[清单 2-29](ch02.xhtml#ch02ex029)中完成了这部分。
- en: '[PRE61]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*Listing 2-29: The* main *function*'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-29：主* *函数*'
- en: 'We begin by allocating pointers for the maximum number of nodes that can make
    up a test case ➊. We then read the number of test cases and loop once for each
    test case. Recall that each test case requires two pieces of output: information
    about the test case number and information about the relevant nodes. The first
    is handled by a single call of `printf` ➋. For the second, we start leaning on
    our earlier functions: we read the tree, solve the problem for each node, sort
    the nodes, and then output the required information.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为能够组成一个测试用例的最大节点数分配指针➊。然后，我们读取测试用例的数量，并针对每个测试用例循环一次。回想一下，每个测试用例需要两部分输出：关于测试用例编号的信息和关于相关节点的信息。第一部分通过一次`printf`调用来处理➋。对于第二部分，我们开始依赖之前的函数：我们读取树，解决每个节点的问题，排序节点，然后输出所需的信息。
- en: There’s a check at the bottom of the code to tell whether or not we’re in the
    final test case ➌; this is so we can output a blank line between tests.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的底部有一个检查，用于判断是否已经是最后一个测试用例➌；这是为了在测试之间输出一个空行。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Recursive solutions are virtuous, simple, clean, easy to devise, easy to understand,
    and easy to prove correct . . .
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 递归解决方案是优秀的，简单的，清晰的，易于构思，易于理解，并且容易证明正确……
- en: Well, at least, that’s the sense you’d get if you read enough about recursion
    and talked to enough recursion enthusiasts. It’s clear what the experts think.
    Through my students, however, I’ve observed a disconnect between the way that
    recursion is touted and the way it is learned. It takes time and practice to appreciate
    the expert perspective. Don’t worry if you find recursive solutions tough to devise
    and trust. Keep at it! Many teachers and writers have their own approaches and
    examples for introducing recursion. More than for any other topic in the book,
    I encourage you to seek out additional material on recursion to complement what
    I have offered here.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，如果你阅读了足够多关于递归的资料并与足够多的递归爱好者交流，你大概会有这样的感觉。专家们的观点是显而易见的。然而，通过我的学生们，我发现递归的宣传方式和实际学习过程中存在一定的脱节。要真正理解专家的观点，确实需要时间和练习。如果你觉得递归的解决方案难以设计和信任，不必担心，继续努力！许多教师和作者都有自己介绍递归的方式和示例。我鼓励你寻找更多关于递归的资料，来补充我在这里提供的内容，这比书中的任何其他话题都更加重要。
- en: In the next chapter, we’ll keep going with recursion, optimizing it for a different
    class of problems.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将继续探索递归，并针对不同类型的问题进行优化。
- en: Notes
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Halloween Haul is originally from the 2012 DWITE Programming Competition, Round
    1\. Descendant Distance is originally from the 2005 East Central North America
    Regional Programming Contest. For a book-length treatment of recursion, check
    out *Thinking Recursively with Java* by Eric Roberts (2005).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 《万圣节购物》最初来源于2012年DWITE编程竞赛第1轮。 《后代距离》最初来源于2005年东中北美地区编程竞赛。如果你想要一本关于递归的长篇书籍，可以参考Eric
    Roberts（2005年）的《*Thinking Recursively with Java*》。
