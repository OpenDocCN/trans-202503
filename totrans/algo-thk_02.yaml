- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TREES AND RECURSION
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll look at two problems that will require processing and
    answering questions about hierarchical data. The first problem is about collecting
    candy from a neighborhood. The second concerns queries on family trees. Because
    loops are a natural means to process collections of data, we’ll try them first.
    We’ll soon see, though, that these problems push against what we can easily express
    with loops, and this will motivate a shift in the way we think about and solve
    such problems. You’ll leave this chapter knowing about recursion, a problem-solving
    technique that applies whenever the solution to a problem involves solutions to
    simpler, smaller problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 1: Halloween Haul'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is DMOJ problem `dwite12c1p4`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s Halloween, a holiday that often involves getting dressed up, candy from
    neighbors, and a stomachache. In this problem, you want to collect all the candy
    from a particular neighborhood as efficiently as possible. The neighborhood has
    a rigid, though strange, shape. [Figure 2-1](ch02.xhtml#ch02fig01) shows a sample
    neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: A sample neighborhood*'
  prefs: []
  type: TYPE_NORMAL
- en: The circles with numbers in them are houses. Each number gives the amount of
    candy you’ll get by visiting that house. Candy values are at most two digits.
    The circle at the top is your starting location. The circles without numbers are
    intersections between streets, where you choose which way to walk next. The lines
    that connect circles are the streets. Moving from one circle to another corresponds
    to walking one street.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think about how you could move through this neighborhood. Begin at the
    top circle. If you walk down the street on the right, you get to an intersection.
    If you then walk down the street on the right from that circle, you end up at
    a house and collect 41 pieces of candy. You could then walk back up the two streets
    to the top to return to your starting location. You’ll have thus walked a total
    of four streets and collected 41 pieces of candy.
  prefs: []
  type: TYPE_NORMAL
- en: However, your goal is to collect *all* of the candy and to do so by walking
    the minimum number of streets. You’re allowed to end your walk as soon as you’ve
    collected all of the candy; there’s no requirement to get back to the top circle.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The input consists of exactly five lines, where each line is a string of at
    most 255 characters that describes a neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: How can a string encode a diagram? This isn’t like the Unique Snow-flakes problem
    from [Chapter 1](ch01.xhtml), where each snowflake was just six integers. Here
    we have circles, lines connecting circles, and candy values in some of those circles.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the Unique Snowflakes problem, we can simplify things by initially
    ignoring some of the complexities of the full problem. For that reason, I’ll defer
    the way that the input is provided until later. Here’s a teaser, though: there’s
    a quite clever and compact way to represent these diagrams as strings. Stay tuned.'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our output will be five lines of text, with each line corresponding to one
    of the five input lines. Each line of output contains two integers separated by
    a space: the minimum number of streets walked to obtain all of the candy and the
    total amount of candy obtained.'
  prefs: []
  type: TYPE_NORMAL
- en: The time limit for solving the test case is two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary Trees*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Figure 2-2](ch02.xhtml#ch02fig02), I’ve augmented the neighborhood from
    [Figure 2-1](ch02.xhtml#ch02fig01) to include letters in the nonhouse circles.
    These letters have nothing to do with the problem and won’t affect our code, but
    they allow us to uniquely refer to each circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A sample neighborhood with letter labels*'
  prefs: []
  type: TYPE_NORMAL
- en: The particular shape of the neighborhoods in our Halloween Haul problem is known
    as a *binary tree*. Both *binary* and *tree* are important words here. Let’s unpack
    their definitions, starting with tree.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A *tree* is a structure that consists of *nodes* (the circles) and *edges* between
    nodes (the lines representing streets). The node at the top—the H circle—is referred
    to as the *root*. You’ll often see the term *vertex* used synonymously with node;
    in this book, I’ll stick to “node.”
  prefs: []
  type: TYPE_NORMAL
- en: The nodes in the tree have a parent-child relationship. For example, we say
    that H is the *parent* of F and G, because there is an edge from H to F and an
    edge from H to G. We also say that F and G are *children* of H. More specifically,
    F is the *left child* of H, and G is the *right child* of H. Any node that has
    no children is referred to as a *leaf*. In the current problem, the nodes with
    candy values (the houses) are leaves.
  prefs: []
  type: TYPE_NORMAL
- en: Much of the terminology that computer scientists use when discussing trees is
    familiar from the notion of family trees. For example, F and G are *siblings*,
    because they have the same parent. E is an example of a *descendant* of H, because
    E is reachable by moving down the tree from H.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *height* of a tree is determined by the largest number of edges that we
    can traverse on a downward path from the root to a leaf. What is the height of
    our sample tree? Well, here’s one downward path we could traverse: H to G to 7\.
    That path has two edges (H to G and G to 7), giving us a height of at least two.
    However, we can find a much longer downward path! Here’s one such longest downward
    path: H to F to E to D to C to B to 4\. That path has six edges on it. Convince
    yourself that there is no longer downward path here. The height of this tree is
    six.'
  prefs: []
  type: TYPE_NORMAL
- en: Trees have a very regular, repeatable structure, which helps us process them.
    For example, if we remove the root H, along with the edges from H to F and from
    H to G, we end up with two *subtrees* ([Figure 2-3](ch02.xhtml#ch02fig03)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: A tree split in two*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that each of the two subtrees is a legitimate tree on its own: it has
    a root, nodes and edges, and the proper structure. We could further split these
    trees into even smaller pieces, and each of those pieces would be a tree. A tree
    can be thought of as consisting of smaller trees, each of which consists of even
    smaller trees, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Binary
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In the context of trees, *binary* simply means that each node in our trees
    has at most two children. A given node in a binary tree can have zero children,
    or one child, or two children, but no more. The binary trees in our current problem
    are in fact a little more constrained than that: each node is required to have
    exactly zero or two children—you’ll never see a node with exactly one child. Such
    a binary tree, where every nonleaf node has exactly two children, is referred
    to as a *full* binary tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Solving the Sample Instance*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s go ahead and solve the Halloween Haul problem on our sample tree ([Figure
    2-2](ch02.xhtml#ch02fig02)). We’re required to return both the minimum number
    of streets we have to walk to get all of the candy and the total amount of candy.
    We’ll start with the latter, because it’s the easier of the two to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can calculate the total amount of candy by hand: just add up all of the
    candy values in the house nodes. If we do that, we get 7 + 41 + 72 + 3 + 6 + 2
    + 15 + 4 + 9 = 159.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s figure out the minimum number of streets that you must walk to collect
    all of the candy. Does it even matter how we traverse the tree? After all, you
    have to visit every house—maybe your quickest route is simply to avoid visiting
    the same house multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s traverse the tree by visiting left children before right children. By
    using this strategy, here is the order in which you visit the nodes: H, F, A,
    72, A, 3, A, F, E, 6, E, D, C, B, 4, B, 9, B, C, 15, C, D, 2, D, E, F, H, G, 7,
    G, 41\. Note how your final stop is the 41 house and not H: you’re not required
    to return to your starting location once you’re finished collecting the candy.
    There are 30 edges in that path. (There are 31 nodes in the path, and the number
    of edges in a path is always the number of nodes minus one.) Is walking 30 streets
    the best you can do?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you can do better: the most efficient route involves walking only
    26 streets. Spend some time now trying to find this more optimized traversal.
    As in the 30-street traversal, you’ll have to visit the nonhouse nodes multiple
    times and you want to visit each house exactly once, but you can save four street-walks
    by being strategic about the *final* house that you visit.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Representing Binary Trees*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a solution in code, we’ll need to find a way to represent neighborhood
    trees. As you’ll see, it’s convenient to convert the strings from the input that
    represent trees to explicit tree structures that represent relationships between
    nodes. In this section, I’ll provide those tree structures. We won’t yet be able
    to read the strings and convert them to trees, but we’ll be able to hardcode trees.
    That gives us the foothold we need to start solving the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Nodes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When solving the Unique Snowflakes problem in the last chapter, we used a linked
    list to store a chain of snowflakes. Each snowflake node contained the snowflake
    itself, and it also contained a pointer to the next snowflake in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can use a similar struct to represent a binary tree. In our neighborhood
    trees, the houses have candy values and the other nodes do not. Even though we
    have these two kinds of nodes, we’ll be okay with just one node structure. We’ll
    just make sure that house nodes have correct candy values; we won’t even initialize
    the `candy` values of nonhouse nodes, because we won’t look at those values anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'That gives us this starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a linked list, each node points to the next node in the chain (or is `NULL`
    if there is no next node). From one node, we can move to exactly one other node.
    In contrast, in a tree, a single `next` pointer per node will not suffice, because
    a nonleaf node will have both a left child and a right child. We need two pointers
    per node, as in [Listing 2-1](ch02.xhtml#ch02ex01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: The* node *struct*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s apparent that the `parent` is not included here. Should we throw in a `*parent`
    as well, letting us access the parent of a node in addition to its children? This
    would be useful for some problems, but it is not required for Halloween Haul.
    We will need a way to move up the tree (from child to parent), but we can do so
    implicitly, without explicitly following parent pointers. You’ll see more about
    this later.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With this `node` type in hand, we can now build sample trees. We work bottom-up,
    uniting subtrees until we reach the root. Let’s demonstrate the start of this
    process on our sample tree.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the 4 and 9 nodes at the bottom of our sample tree. Then we
    can combine those under a new parent to create the subtree whose root is B.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the 4 node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a house node, so we remember to give it a candy value. It’s also important
    to set its left and right children to `NULL`. If we don’t do that, they’ll remain
    uninitialized, pointing to unspecified memory, and that’ll mean trouble if we
    try to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the 9 node. This is another house, so the code is structurally
    identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two nodes. They’re not yet part of a tree. They’re hanging out
    by themselves. We can unite them under a common parent, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `B` node is given a `left` pointer to the 4 house and a `right` pointer
    to the 9 house. It’s `candy` member is not initialized, which is fine because
    non-house nodes have no sensible `candy` value anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](ch02.xhtml#ch02fig04) depicts what we’ve generated so far.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch02fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: The first three nodes in our hardcoded tree*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before powering ahead and producing the C subtree, let’s do a little cleanup.
    Creating a house node involves four things: allocating the node, setting the candy
    value, setting the left child to `NULL`, and setting the right child to `NULL`.
    Similarly, creating a nonhouse node involves doing three things: allocating the
    node, setting the left child to some existing subtree, and setting the right child
    to some other existing subtree. We can capture these steps in helper functions
    rather than typing them out each time, as shown in [Listing 2-2](ch02.xhtml#ch02ex02).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: Helper functions for creating nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite our earlier `four`, `nine`, `B` code to use these helper functions,
    and add the 15 and C nodes while we’re at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) depicts our five-node tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch02fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: The first five nodes in our hardcoded tree*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that node `C` has a left child that is a nonhouse node (`B` in our code)
    and a right child that is a house node (`fifteen` in our code). Our `new_nonhouse`
    function allows this asymmetry (one nonhouse child and one house child): each
    is just a node. We can mix and match nonhouse nodes and house nodes at will.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a five-node subtree rooted at node `C`. We should be
    able to use that `C` node to access the candy values stored in the tree. (We could
    also use `B`, `four`, `nine`, and `fifteen` to access parts of the tree, because
    building a tree piecewise leaves a residue of node variables in our wake, but
    later we’ll build a function for converting a string to a tree that will furnish
    us with only the tree’s root, so let’s not cheat by using those variables here.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick exercise: What does this print?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you said `15`, you’d be correct! We access `C`’s right child, which is the
    `fifteen` house node, and then we access `fifteen`’s candy value.
  prefs: []
  type: TYPE_NORMAL
- en: How about this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That should output `9`: a left and then a right takes us from `C` to `nine`.
    Now try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Yikes! On my laptop, I’m getting the value `10752944`. Why? The reason is that
    we’re printing a pointer value, not a candy value. We will have to be careful
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, what would this print?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a useless number. Here we’re printing the `candy` member for a
    nonhouse node, but only houses have meaningful values of `candy`.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now ready to start tackling this problem. Finish up the code to build
    the sample tree and we’ll be on our way.
  prefs: []
  type: TYPE_NORMAL
- en: '*Collecting All the Candy*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have two main tasks: calculating the minimum number of streets required
    to collect all of the candy and calculating the total amount of candy in the tree.
    We’ll write a helper function for each task, starting with calculating the total
    amount of candy, the easier of the two tasks. The helper function will have the
    following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function takes a pointer to a node that is the root of the tree and returns
    an integer that will be the total amount of candy in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were dealing with linked lists, we could use a loop like we did when
    solving the Unique Snowflakes problem. The body of the loop would process the
    current node and then use the `next` member of the node to advance to the next
    node. At each step, there’s only one place to go: further down the linked list.
    However, the structure of binary trees is more complex. Each nonleaf node has
    a left and a right subtree. Each must be traversed; otherwise, we’ll miss processing
    part of the tree!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To show a tree traversal in action, we will return to our sample tree ([Figure
    2-2](ch02.xhtml#ch02fig02)): Beginning at node H, where should we go first? We
    could move right to G and then move right again to 41, collecting 41 pieces of
    candy there. Then what? We’re at a dead end, and there’s a lot more candy to collect.
    Remember that each nonleaf node stores pointers only to its left and right children,
    not to its parent. Once at 41, we have no way to get back up to G.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting again, we need to move from H to G and to record that we must later
    process the F subtree—otherwise, we’ll have no way to return to the F subtree.
  prefs: []
  type: TYPE_NORMAL
- en: Once at G, we similarly need to move to 41 and to record that we must later
    process the 7 subtree. When we’re at 41, we see that there are no subtrees to
    process, and we have recorded two subtrees (F and 7) that we still need to process.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps next we choose to process the 7 subtree, giving us a total candy value
    of 41 + 7 = 48\. After that, we’ll process the F subtree. Making any one decision
    about where to go from F leaves a whole subtree unprocessed, so we also need to
    record that.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, if we use a loop, for each nonleaf node we must do two things: choose
    one of its subtrees to process first and record that the other subtree is pending
    to be processed. Choosing one of the subtrees amounts to following the `left`
    or `right` pointer—there is no problem there. Recording information so that we
    can visit the other subtree later, however, will be trickier. We’ll need a new
    tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Storing Pending Subtrees on a Stack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At any moment, we can have multiple subtrees pending for us to visit later.
    We need to be able to add another subtree to that collection and to remove and
    return subtrees when we’re ready to process them.
  prefs: []
  type: TYPE_NORMAL
- en: We can use an array to manage this bookkeeping. We’ll define a large array that
    can hold as many references to pending subtrees as needed. To tell us how many
    subtrees are pending, we’ll keep a `highest_used` variable that will track the
    highest index being used in the array. For example, if `highest_used` is `2`,
    it means that indices `0`, `1`, and `2` hold references to pending subtrees and
    that the rest of the array is currently unused. If `highest_used` is `0`, it means
    that only index `0` is being used. To signify that no part of the array is being
    used, we set `highest_used` to `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest spot to add to the array is at index `highest_used + 1`. If we tried
    to add an element anywhere else, we’d first have to move existing elements to
    the right; otherwise, we’d overwrite one of the existing elements! Similarly,
    the easiest element to remove from the array is `highest_used`. Using any other
    index would necessitate moving elements to the left to fill the vacancy left by
    the removed element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this scheme, suppose we first add a reference to subtree F and then add
    a reference to subtree 7\. This places the F subtree at index `0` and the 7 subtree
    at index `1`. The value of `highest_used` is currently `1`. Now, when we remove
    an element from this array, which subtree do you think gets removed: the F subtree
    or the 7 subtree?'
  prefs: []
  type: TYPE_NORMAL
- en: The 7 subtree gets removed! In general, the element that was most recently added
    is the one that is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Computer scientists refer to this as *last-in, first-out (LIFO)* access. Collections
    of data that provide LIFO access are referred to as *stacks*. Adding an element
    to a stack is known as a *push*, and removing an element from a stack is known
    as a *pop*. The *top* of the stack refers to the element that would next be popped
    from the stack; that is, the top of the stack is the most recently pushed item.
  prefs: []
  type: TYPE_NORMAL
- en: There are real-life stacks all over the place. Say you have some plates that
    have just been washed, and you put them away on a shelf in a cupboard, one after
    the other. The last one that you add (push) to the shelf will be at the top of
    the stack, and it will be the first plate that you remove (pop) when retrieving
    a plate from the cupboard. This is LIFO.
  prefs: []
  type: TYPE_NORMAL
- en: A stack also powers the undo functionality in your word processor. Suppose you
    type a word, then a second word, then a third word. Now you hit undo. The third
    word goes away, since it was the last one that you entered.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Stack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s implement the stack. To begin, we package both the array and `highest_used`
    into a struct. This keeps the stack’s variables together and also allows us to
    create as many stacks as we wish. (In Halloween Haul, we need only one stack,
    but you might use this code in other settings where multiple stacks are required.)
    Here’s our definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Recall that each input line is at most 255 characters. Each character will represent
    at most one node. Each tree that we deal with will thus have at most 255 nodes,
    and this is why our `values` array has space for 255 elements. Also, notice that
    each element in `values` is of type `node *`, a pointer to `node`. We could have
    stored nodes in there directly, rather than pointers to nodes, but that would
    be less memory efficient because the nodes from the tree would be duplicated when
    added to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a function for each operation on a stack. First, we need a `new_stack`
    function that creates a new stack. Next, we need `push_stack` and `pop_stack`
    functions to add to and remove from the stack, respectively. Finally, we’ll have
    an `is_empty_stack` function that tells us whether the stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The `new_stack` function is provided in [Listing 2-3](ch02.xhtml#ch02ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-3: Creating a stack*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we allocate memory for the stack ➊. Then, we set `highest_used` to `-1`
    ➋; recall that `-1` here means an empty stack. Notice that we don’t do anything
    to initialize the elements of `s->values` here: our stack is empty, so its values
    are irrelevant.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve put `stack_push` and `stack_pop` together in [Listing 2-4](ch02.xhtml#ch02ex04)
    to highlight the symmetry of their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-4: Push and pop on a stack*'
  prefs: []
  type: TYPE_NORMAL
- en: In `push_stack`, we first make room for a new element ➊, and then place `value`
    in that free location ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `pop_stack` function is responsible for removing the element at index `highest_used`.
    If it did just that, however, then the function wouldn’t be all that useful: we’d
    be able to call it and it would pop the element for us, but it wouldn’t tell us
    what was popped! To remedy that, we store in `ret` the element from the stack
    that we are about to remove ➌. We then remove the element from the stack by decreasing
    `highest_used` by one ➍. Finally, we return the element that was removed ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: I have not included error checking in `push_stack` or `pop_stack`. Notice that
    `push_stack` would fail if you tried to push more than the maximum number of elements—but
    we’re safe, because we’ve made the stack as big as any input we’ll be provided.
    Likewise, `pop_stack` would fail if you tried to pop from an empty stack—but we’ll
    be careful to check that the stack is nonempty before we pop. Of course, general-purpose
    stacks should be made more robust!
  prefs: []
  type: TYPE_NORMAL
- en: We’ll determine whether a stack is empty using `is_empty_stack` (shown in [Listing
    2-5](ch02.xhtml#ch02ex05)), which uses `==` to check whether `highest_used` is
    `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-5: Determining whether a stack is empty*'
  prefs: []
  type: TYPE_NORMAL
- en: Before we calculate the total amount of candy in a tree, let’s exercise our
    stack code with a small, standalone example, as given in [Listing 2-6](ch02.xhtml#ch02ex06).
    I encourage you to take a few minutes to trace the example on your own. Predict
    what will happen! Then, run the code and check whether the output matches what
    you expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-6: An example of using a stack*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s figure out what this example does. First we create a new stack called
    `s`. We then create three house nodes: `n1` has 20 pieces of candy, `n2` has 30
    pieces of candy, and `n3` has 10 pieces of candy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We push these (single-node) subtrees onto the stack: first `n1` is pushed,
    then `n2`, then `n3`. As long as the stack is nonempty, we pop an element from
    the stack and print its candy value. The elements come off the stack in the opposite
    order in which they were pushed, so we get 10, 30, 20 as the result of the `printf`
    calls.'
  prefs: []
  type: TYPE_NORMAL
- en: A Stack Solution
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We now have a means of keeping track of pending subtrees: whenever we make
    a choice of which subtree to process, we put the other one on the stack. What’s
    important for calculating the total amount of candy is that the stack gives us
    a way to push a subtree (to help us remember that subtree) and pop a subtree (to
    help us process a subtree when we’re ready to do so).'
  prefs: []
  type: TYPE_NORMAL
- en: We could also have used a *queue*, a data structure to give us elements in *first-in,
    first-out (FIFO)* order, which would change the order in which subtrees are visited
    and the order in which we add candy to our total, but it would give us the same
    end result. I chose a stack because it’s easier to implement than a queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to implement `tree_candy` using a stack. We need to handle
    two cases: the first is what we do when looking at a nonhouse node, and the second
    is what we do when looking at a house node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To know whether our current node is a nonhouse node, we can check its `left`
    and `right` pointers. For a nonhouse, both will be non-null, because they point
    to subtrees. If we confirm we’re looking at a nonhouse node, we store the pointer
    to the left subtree in the stack, and we proceed down the right subtree. The code
    for the nonhouse-node case goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, if `left` and `right` are `NULL`, then we’re looking at a house
    node. House nodes have candy, so the first thing we should do is add that house’s
    candy value to our total amount of candy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a house, so there’s no further down in the tree we can go. If the stack
    is empty, we’re done: an empty stack means that there are no more pending trees
    to process. If the stack is not empty, then we need to pop a subtree from the
    stack and process that subtree. Here’s the code for processing a house:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for `tree_candy`, using a stack, is given in [Listing 2-7](ch02.xhtml#ch02ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-7: Calculating the total amount of candy using a stack*'
  prefs: []
  type: TYPE_NORMAL
- en: Let *n* be the number of nodes in a tree. Each time through the `while` loop,
    `tree` is a different node. We therefore visit each node just once. Each node
    is also pushed to and popped from the stack at most once. In all, each node is
    involved in a constant number of steps, so we have a linear-time, or *O*(*n*),
    algorithm here.
  prefs: []
  type: TYPE_NORMAL
- en: '*A Completely Different Solution*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our `tree_candy` function works, but it isn’t the simplest solution. We had
    to write an implementation of a stack. We had to keep track of pending trees.
    We had to backtrack to a pending tree whenever we hit a dead end. For two reasons,
    using a stack in the way we have done may not be the ideal solution strategy when
    writing functions on trees:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have to go one way but return later to go the other way, we’re stuck
    using this kind of stack code. Tree-processing is rife with problems that require
    this pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complexity of stack-based code scales with the complexity of the problem.
    Adding up all of the candy in a tree isn’t so bad, but other related problems
    that we solve later in this chapter are more challenging. Those problems require
    not only a stack of pending trees but control flow information for tracking the
    processing that we need to perform on each tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll rewrite our code so it’s able to work at a higher level of abstraction,
    eliminating stacks completely from both our code and our thought processes.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Definitions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our stack-based `tree_candy` function is concerned with the *particular steps*
    needed to solve the problem: push this on the stack, move that way in the tree,
    pop from the stack when we hit a dead end, stop when we’ve processed the entire
    tree. I will now give you another solution that focuses on the *structure* of
    the problem. This method solves the main problem in terms of solutions to smaller
    subproblems. The solution comprises two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   If the root of the tree is a house node, then the total amount
    of candy in the tree equals the amount of candy at that house.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   If the root of the tree is a nonhouse node, then the total amount
    of candy in the tree equals the total amount of candy in the left subtree plus
    the total amount of candy in the right subtree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called a *recursive* definition. A definition is recursive if it offers
    a solution to a problem by referring to solutions to subproblems. Rule 2 is where
    we see this in action. We care about solving the original problem of calculating
    the total amount of candy in the tree. That total can be calculated, according
    to Rule 2, by adding up the solutions to two smaller problems: the total amount
    of candy in the left subtree and the total amount of candy in the right subtree.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s at about this time that students in my classes start blanching all over
    the place. How is this description going to solve anything? Even if it does, how
    can this kind of thing be written in code? The problem is aggravated by books
    and tutorials that imbue recursive definitions with a mystical quality that is
    to be trusted but not understood. However, there is no leap of faith or temerity
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through a small example to get a feel for why this recursive definition
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this tree consisting of a single house with four pieces of candy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rule 1 immediately tells us that the answer for this tree is four. Whenever
    we see this tree later, just remember that the answer is four.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider this tree consisting of a single house with nine pieces of candy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, Rule 1 applies, telling us that the answer is nine: when we see this
    tree later, we’ll just respond that the answer is nine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s solve the problem for a bigger tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, Rule 1 does not apply: the root of the tree is a nonhouse node,
    not a house node. However, we are rescued by Rule 2, which tells us that the total
    amount of candy here is the total amount of candy in the left subtree plus the
    total amount of candy in the right subtree. We already know that the total amount
    of candy in the left subtree is four: it is a tree that we have seen before. Similarly,
    we know that the total amount of candy in the right subtree is nine: we have seen
    that tree before, too. By Rule 2, therefore, the entire tree has 4 + 9 = 13 pieces
    of candy. Remember this for when we see this tree again!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go a little further. Here’s another one-house tree, this one with 15
    pieces of candy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rule 1 tells us this tree has a total of 15 pieces of candy. Remember that!
    Now consider a five-node tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rule 2 applies here, because the root is a nonhouse node. We need the total
    amount of candy in the left subtree and the total amount of candy in the right
    subtree. We already know the total amount of candy in the left subtree, as we
    remember our earlier answer of 13\. There’s no point going into that left subtree
    and recalculating anything: we already know the answer. Similarly, we already
    know the total amount of candy in the right subtree, as it was 15\. By Rule 2,
    then, we have a total of 13 + 15 = 28 pieces of candy in the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: You can keep using this logic to find the total amount of candy in bigger and
    bigger trees. As we did in the example here, solve smaller subtrees before larger
    subtrees. In doing so, Rule 1 or Rule 2 will always apply, and answers for smaller
    subtrees will be known when they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s encode Rule 1 and Rule 2 as a C function; see [Listing 2-8](ch02.xhtml#ch02ex08).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-8: Calculating the total amount of candy using recursion*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how Rule 1 and Rule 2 are directly represented here. We have an `if`
    statement whose condition is true when the left and right subtrees are `NULL`
    ➊. No subtrees means that `tree` is a house node. We should therefore apply Rule
    1, which is exactly what we do. Specifically, we return the amount of candy in
    the house node `tree`. If Rule 1 does not apply, we know that `tree` is a nonhouse
    node, and we can implement Rule 2 and return the candy in the left subtree plus
    the candy in the right subtree ➋ . . . but here we pause.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does Rule 2 work here? The total amount of candy in the left subtree is
    obtained by calling `tree_candy` on the left subtree. This is the same as for
    the right subtree: to obtain the total amount of candy in the right subtree, we’re
    calling `tree_candy` on the right subtree. But we’re already in `tree_candy`!'
  prefs: []
  type: TYPE_NORMAL
- en: Calling a function from inside itself is known as a *recursive call*. A function
    that makes a recursive call is said to be using *recursion*. One of the biggest
    mistakes you can make at this point is to try to trace what’s going on in the
    computer when this recursion happens. I’m going to refrain from giving the low-level
    details on how the computer organizes these recursive calls. (Suffice it to say
    that it uses a stack to keep track of pending function calls. It’s very similar
    to how we earlier used a stack in our code to solve `tree_candy`! For that reason,
    our recursive code, much like our stack-based code, is an *O*(*n*) solution.)
  prefs: []
  type: TYPE_NORMAL
- en: Over and over, I’ve seen the quagmire that can result from trying to manually
    trace recursive calls. It’s the wrong level of abstraction. Let the computer execute
    it in the same way that, without a second thought, you let it execute your loops
    or function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how I suggest thinking through what the recursive code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: If the root of the tree is a house, return its amount of candy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the root of the tree is a nonhouse. Return the total amount of candy
    in the left subtree plus the total amount of candy in the right subtree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s easy to err when writing recursive code. One common mistake is to inadvertently
    throw information away when in fact it should be returned. The following flawed
    implementation exhibits this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our bug is that we return nothing from the recursive calls ➊, as there is no
    `return` keyword. We’re supposed to return the sum, not throw it away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common mistake is to make a recursive call on something that’s not
    a smaller subproblem of the current problem. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the second `return` statement ➊. If I told you that the total amount
    of candy in a tree is obtained by calculating the total amount of candy in the
    tree, I think you’d be quite vexed—but that’s exactly the rule that it embodies.
    This function will not work on a tree whose root is a nonhouse node: it will continue
    to use up memory with pending function calls until the program crashes.'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing Recursion
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before proceeding with solving the Halloween Haul problem, let’s practice with
    recursion by writing two more functions in the spirit of `tree_candy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, given a pointer to the root of a full binary tree, let’s return the
    number of nodes in the tree. If the node is a leaf, then there is only one node
    in the tree, so `1` is the correct return value. Otherwise, we’re looking at a
    nonleaf, and the number of nodes in the tree is one (this node) plus the number
    of nodes in the left subtree plus the number of nodes in the right subtree. That
    is, the two rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   If the root of the tree is a leaf node, then the number of nodes
    in the tree equals `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   If the root of the tree is a nonleaf node, then the number of
    nodes in the tree equals `1` plus the number of nodes in the left subtree plus
    the number of nodes in the right subtree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A rule like Rule 1 is known as a *base case*, because it can be solved directly,
    without using recursion. A rule like Rule 2 is known as a *recursive case*, because
    its solution requires that smaller subproblems be recursively solved. Every recursive
    function requires at least one base case and at least one recursive case: the
    base case tells us what to do when the problem is easy, and the recursive case
    tells us what to do when the problem is not.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting these rules to code yields the function in [Listing 2-9](ch02.xhtml#ch02ex09).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-9: Calculating the number of nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: Second, let’s write a function to return the number of leaves in a tree. If
    the node is a leaf, we return `1`. If the node is a nonleaf, then that node is
    *not* a leaf, so it doesn’t count; what does count is the number of leaves in
    the left subtree and the number of leaves in the right subtree. The code is given
    in [Listing 2-10](ch02.xhtml#ch02ex010).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-10: Calculating the number of leaves*'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between this code and that in [Listing 2-9](ch02.xhtml#ch02ex09)
    is the lack of the `1 +` in the last line. Recursive functions are often very
    similar to each other but can compute very different things!
  prefs: []
  type: TYPE_NORMAL
- en: '*Walking the Minimum Number of Streets*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve gone on and on and on, so you might want to revisit the problem description
    to reorient yourself. We know how to produce the total amount of candy now, but
    that’s only one of the two required outputs. We also need to output the minimum
    number of streets that must be walked to obtain all of the candy. No candy for
    guessing that we’ll nail this using recursion!
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Number of Streets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Earlier, I provided a 30-street walk for the tree in [Figure 2-2](ch02.xhtml#ch02fig02).
    I also asked you to find an even better—and in fact optimal—26-street walk. This
    optimal walk saves four streets by taking advantage of the fact that we can end
    the walk as soon as the final piece of candy has been collected. There’s no requirement
    in the problem description to walk back to the root of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: What if we *did* return to the root of the tree as part of the walk? It’s true
    that we’d get the wrong answer, because we’d walk more streets than required.
    It’s also true, though, that returning to the root greatly simplifies the problem.
    We don’t have to be concerned with the thorny issue of how to cleverly do the
    walk to minimize the number of streets. (After all, we’ll end up back at the root,
    so we don’t have to orchestrate things so that the final house we visit is a good
    choice.) Perhaps we’ll be able to overshoot the minimum (by returning to the root)
    and then subtract off the extra streets that we walked? That’s our gambit!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s follow the same plan as for `tree_candy` and define a base case and a
    recursive case.
  prefs: []
  type: TYPE_NORMAL
- en: What do we do if the root of the tree is a house—how many streets do we walk
    starting from that house and getting back to that house? The answer is zero! No
    streets are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you do if the root is a nonhouse? Return to [Figure 2-3](ch02.xhtml#ch02fig03),
    where I split the tree in two. Suppose we knew the number of streets required
    to walk the F subtree and the number of streets required to walk the G subtree.
    We can calculate those recursively. Then, add H and its two edges back in. How
    many more streets must we walk now? We have to walk one street from H to F and
    then walk one street from F back to H after we finish with the F subtree. We have
    to do similarly for G: walking from H to G and then from G back to H after we
    finish with the G subtree. That’s four additional streets, beyond those that we
    get from the recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are our two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   If the root of the tree is a house node, then the number of streets
    we walk is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   If the root of the tree is a nonhouse node, then the number of
    streets we walk is the number of streets we walk for the left subtree plus the
    number of streets we walk for the right subtree plus `4`.'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you should be getting a little more comfortable converting such
    rules into code. [Listing 2-11](ch02.xhtml#ch02ex011) supplies an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-11: Calculating the number of streets getting back to the root*'
  prefs: []
  type: TYPE_NORMAL
- en: If you perform a walk in [Figure 2-2](ch02.xhtml#ch02fig02) starting at H, collecting
    all the candy, and ending at H, you will walk 32 streets. No matter how you walk
    the tree, as long as you visit each house once and don’t unnecessarily rewalk
    streets, you’ll get 32\. The minimum number of streets we can walk, with no requirement
    to return to the root, is 26\. Since 32 – 26 = 6, by ending at the root we overshoot
    the correct answer by six.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because there’s no requirement to return to the root, it makes sense to arrange
    our walk so that the last house that we visit is as far away as possible from
    the root. For example, ending at the house with 7 pieces of candy is a bad move,
    because we’re only two streets from H anyway—but look at those gloriously distant
    4 and 9 houses way at the bottom. It would be wonderful to end our walk at one
    of those houses. If we end our walk at 9, for example, then we’d save six streets:
    9 to B, B to C, C to D, D to E, E to F, and F to H.'
  prefs: []
  type: TYPE_NORMAL
- en: The plan, then, is to end our walk at a house that is located the maximum number
    of streets away from the root. If that house is six streets from the root, it
    means that there is a path of six edges from the root to some leaf. This is exactly
    the definition of the height of a tree! If we can calculate the height of a tree—recursively,
    I’ll bet—then we can subtract the height from what `tree_streets` gives us. That
    leaves us off at a house furthest from the root, thereby saving us the maximum
    number of streets.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick aside, there’s actually no reason to know which house is the furthest,
    or even to know how to perform a walk to make that house be last. All we have
    to do is convince ourselves that we *can* construct a walk to make that house
    be last. I’ll give a quick argument using [Figure 2-2](ch02.xhtml#ch02fig02) that
    I hope convinces you. Starting at H, compare the heights of the F and G subtrees,
    and completely walk whichever has smaller height—G, in this case. Then, repeat
    this process using F’s subtrees. Compare the heights of the A and E subtrees,
    and completely walk the A subtree (because it’s height is smaller than that of
    E). Keep doing this until all subtrees have been walked; the final house that
    you visit will be a house furthest from H.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Tree Height
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now move on to `tree_height` and another manifestation of our Rule 1–
    Rule 2 recursive approach.
  prefs: []
  type: TYPE_NORMAL
- en: The height of a tree consisting of a single house is zero, because there are
    no edges at all that we can traverse.
  prefs: []
  type: TYPE_NORMAL
- en: For a tree whose root is a nonhouse, consult [Figure 2-3](ch02.xhtml#ch02fig03)
    again. The F subtree has a height of five, and the G subtree has a height of one.
    We can solve these subproblems recursively. The height of the original tree, with
    H in there, is one more than the maximum of five and one, because an edge from
    H increases the number of edges to each leaf by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'That analysis gives us these two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   If the root of the tree is a house node, then the tree’s height
    is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   If the root of the tree is a nonhouse node, then the tree’s height
    is one more than the maximum of the left subtree’s height and the right subtree’s
    height.'
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 2-12](ch02.xhtml#ch02ex012) for the code. We have a little `max`
    helper function to tell us the maximum of two numbers; otherwise, `tree_height`
    holds no surprises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-12: Calculating the height of the tree*'
  prefs: []
  type: TYPE_NORMAL
- en: We now have `tree_candy` to calculate the total amount of candy and `tree_streets`
    and `tree_height` to calculate the minimum number of streets. Putting those three
    together gives us a function that solves the problem given a tree; see [Listing
    2-13](ch02.xhtml#ch02ex013).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-13: Solving the problem, given a tree*'
  prefs: []
  type: TYPE_NORMAL
- en: Try calling this function on the trees you built in “Building a Tree” on [page
    43](ch02.xhtml#ch02lev1).
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Input*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are now ever so close, but we’re not quite there. Yes, we can solve the problem
    if we have a tree in hand, but recall that the input to the problem is lines of
    text, not trees. We’ll have to convert each of those lines to a tree before we
    can unleash `tree_solve` on it. At last, we’re finally ready to unveil the way
    in which trees are represented as text.
  prefs: []
  type: TYPE_NORMAL
- en: Representing a Tree as a String
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I’ll show you the correspondence between a line of text and its tree by progressing
    through several examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a tree of a single house node is represented simply as the text of the
    candy value. For example, this tree (whose node’s candy value is four):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A tree whose root is a nonhouse node is represented (recursively!) by the following,
    in order: an opening parenthesis, a first smaller tree, a space, a second smaller
    tree, and a closing parenthesis. The first smaller tree in there is the left subtree,
    and the second smaller tree is the right subtree. For example, this three-node
    tree'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'is represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here is a five-node tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This five-node tree is represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the left subtree is `(4 9)` and the right subtree is `15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Written as rules, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   If the text is the digits of integer `c`, then the tree is a single
    house node with `c` candy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   If the text starts with an opening parenthesis, then the root
    of the tree is a nonhouse node. After the opening parenthesis, the text contains
    the tree’s left subtree, a space, the tree’s right subtree, and a closing parenthesis.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading in a Nonhouse Node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our goal is to write function `read_tree` with this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It takes a string, and it returns the corresponding tree.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by implementing Rule 2, since Rule 1 involves some subtle work to
    convert characters to integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 2, the recursive rule, requires us to make two calls to `read_tree`: one
    to read the left subtree and one to read the right subtree. Let’s see how far
    we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After allocating memory for the root of our tree, we make a recursive call
    to read the left subtree ➊. We pass a pointer to index `1` of `line` so that the
    recursive call receives the string not including the opening parenthesis at index
    `0`. However, in the next line, we’re in trouble ➋. Where do we start reading
    the right subtree? Equivalently, how many characters are in the left subtree?
    We don’t know! We could write a separate function to figure out where the left
    subtree ends. For example, we could count the number of opening and closing parentheses
    until they’re equal, except that this seems wasteful: If `read_tree` successfully
    read the left subtree, surely that recursive call knew where that subtree ended?
    If only there were a way to communicate that information back to the original
    `read_tree` call, it could use that to determine what part of the string to pass
    to the second recursive call.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a parameter to a recursive function is a general and powerful way to
    solve this kind of problem. Whenever a recursive call has information not conveyed
    through what it returns, or it needs information that is not passed, consider
    adding a parameter. If that parameter is a pointer, it can be used to both pass
    additional information to recursive calls and receive information back.
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we want to be able to tell a recursive call where its string
    starts. Also, we want the recursive call to be able to tell us, when it’s finished,
    where we should continue processing the string. To do this, we’ll add an integer
    pointer parameter `pos`. However, we don’t want to add that parameter to `read_tree`,
    because the caller of `read_tree` has no business or interest knowing about this
    extra parameter. The caller of `read_tree` should be able to just pass a string,
    not caring about this `pos` parameter that is internal to our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll keep the signature of `read_tree` as before, with only the `line` parameter.
    Then `read_tree` will call `read_tree_helper`, and it’s `read_tree_helper` that
    has this `pos` parameter and induces the recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-14](ch02.xhtml#ch02ex014) gives the `read_tree` code. It passes
    a pointer to `0` to `read_tree_helper`, because index `0` (the start of the string)
    is where we want to start processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-14: Calling our helper, with a pointer to* int'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to try again with our implementation of Rule 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The function will be called with `pos` referring to the first character of a
    tree, so we first advance `pos` by one character to skip over the opening parenthesis
    ➊. Now `pos` is perfectly positioned at the start of the left subtree. We then
    make the recursive call to read the left subtree. That recursive call will update
    `pos` to the index of the character following the left subtree. Because a space
    follows the left subtree, we skip over that space ➋. Now we’re positioned at the
    start of the right subtree; we recursively grab that right subtree and then skip
    over the closing parenthesis ➌, the one that closes the opening parenthesis that
    we skipped over initially ➊. Skipping the closing parenthesis is important, because
    this function is responsible for processing the entire subtree, including its
    closing parenthesis. If we left out this final skip, whoever called the function
    may be left staring at a closing parenthesis when they expected a space. After
    skipping that closing parenthesis, the only thing left to do is return our tree.
  prefs: []
  type: TYPE_NORMAL
- en: Reading in a House Node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With Rule 2 out of the way, let’s tackle Rule 1\. Before we can make much progress,
    we’ll need to be able to convert part of a string to an integer. Let’s write a
    small, separate program to make sure that we can do this. It will take a string
    that we assume represents a house node and print its candy value. Surprisingly,
    if we’re not careful, we may get baffling results. Be advised: we are not careful
    in [Listing 2-15](ch02.xhtml#ch02ex015).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-15: Reading a candy value (bugged!)*'
  prefs: []
  type: TYPE_NORMAL
- en: Run that program and enter the number `4`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll likely see `52` as the output. Run it again and enter the number `9`.
    You’re likely to see `57`. Now run it with `0`. You’ll likely see `48`. Finally,
    run it with each value from `0` to `9`. You should see that each output is offset
    by the output that `0` produced. If `0` outputs 48, then `1` will output 49, `2`
    will output 50, `3` will output 51, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: What we’re seeing here is the character code for each digit. The crucial point
    is that the codes for integers are consecutive. We can therefore subtract the
    character code for zero to put our integers in the proper range. With this fix,
    we get the code in [Listing 2-16](ch02.xhtml#ch02ex016). Try it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-16: Reading a candy value*'
  prefs: []
  type: TYPE_NORMAL
- en: This little program works for single-digit integers. The description of Halloween
    Haul, though, requires that we also accommodate candy integers that are two digits.
    Suppose we read digit `2` and then digit `8`. We want to combine these and end
    up with the integer `28`. What we can do is multiply the first digit by 10 (that
    gives us 20 here) and then add the 8 (for a total of 28). [Listing 2-17](ch02.xhtml#ch02ex017)
    is another little test program to enable us to check that we’ve got this right.
    Here we assume that a string of two digits will be typed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-17: Reading a candy value with two digits*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all we need for Rule 1, and we can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We begin by setting the left and right subtrees to `NULL`; we’re creating a
    house node, after all. We then take a character and convert it to a digit ❶ and
    then skip over that digit ➋. Now, if this candy value is only one digit, then
    we have correctly stored its value. If it is two digits, then we need to multiply
    the first digit by 10 and add the second digit. We therefore determine whether
    the candy value is one or two digits. If we’re not looking at a closing parenthesis,
    or a space, or the null terminator at the end of the string, then we must be looking
    at a second digit. If a second digit is present, we incorporate it into our candy
    value ➌ and move past the digit ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-18](ch02.xhtml#ch02ex018) puts together our code for Rules 2 and
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-18: Converting a string to a tree*'
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to construct a tidy `main` function to read each test case
    and solve it! [Listing 2-19](ch02.xhtml#ch02ex019) is all it takes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-19: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully used recursion to solve this problem, as you should be able
    to verify by submitting our solution to the judge.
  prefs: []
  type: TYPE_NORMAL
- en: Why Use Recursion?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s not always easy to know whether recursion will offer a clean solution
    to a problem. Here’s the telltale sign: whenever a problem can be solved by combining
    solutions to smaller subproblems, you should try recursion. In all of our recursive
    code in this chapter, we have solved exactly two subproblems in order to solve
    the larger problem. These two-subproblem problems are very common, but a problem
    may require solving three or four or more subproblems.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you know that breaking a problem into subproblems can help you solve
    the original problem, and how do you know what those subproblems are in the first
    place? We’ll revisit these questions in [Chapter 3](ch03.xhtml), when we build
    on what we’ve learned here to study memoization and dynamic programming. In the
    meantime, think about whether you could easily solve a given problem if someone
    told you the solutions to smaller subproblems. For example, think back to calculating
    the total amount of candy in the tree. This is not an easy problem. What if someone
    told you the total amount of candy in the left subtree and the total amount of
    candy in the right subtree? That would make the problem easier. A problem made
    easier by virtue of knowing its subproblem solutions is a strong clue that recursion
    applies.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to another problem where recursion is useful. As you read the
    problem description, try to identify where and why recursion will come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem 2: Descendant Distance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now move away from binary trees to general trees in which nodes can have
    many children.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ecna05b`.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this problem, we are given a family tree and a specified distance *d*. The
    score for each node in the tree is the number of descendants it has at distance
    *d*. Our task is to output the nodes with high scores; I’ll explain exactly how
    many nodes that is in the Output section. To see what I mean by descendants at
    a specified distance, look at the family tree in [Figure 2-6](ch02.xhtml#ch02fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch02fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: A sample family tree*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the Amber node. Amber has four children, so she has four descendants
    at a distance of one. Amber also has five grandchildren: five nodes at a distance
    of two. Generalizing, we can say that, for any node, the number of descendants
    at distance *d* is the number of nodes that are exactly *d* edges down the tree
    from that node.'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first line of input gives the number of test cases that will follow. Each
    test case consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing two integers, *n* and *d*, where *n* tells us how many more
    lines there are for this test case and *d* specifies the descendant distance of
    interest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines used to build the tree. Each of these lines consists of the name
    of a node, an integer *m*, and *m* node names giving the children of this node.
    Each name is at most 10 characters long. These lines can come in any order—there’s
    no requirement that parent lines come before their descendant lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are at most 1,000 nodes in any test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a possible input to generate the sample tree in [Figure 2-6](ch02.xhtml#ch02fig06),
    asking for the nodes with the most descendants at a distance of two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The output for each test case has two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, output the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: where i is `1` for the first test case, `2` for the second test case, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Then, output information for the nodes with high scores (where the score for
    a node is the number of descendants it has at distance *d*), sorted from most
    to least. Output the names that are tied for the number of descendants at distance
    *d* in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following rules to determine how many names to output:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are three or fewer names with descendants at distance *d*, output them
    all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If there are more than three names with descendants at distance *d*, start
    by outputting those with the top three scores, starting from the highest score.
    Then, output each other name whose score is the same as the third score from the
    top. For example, if we have names with eight, eight, two, two, two, one, and
    one descendants at distance *d*, we would output information for five names: those
    with eight, eight, two, two, and two descendants at distance *d*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each name that we’re required to output, we output a line consisting of
    the name, followed by a space, followed by its number of descendants at distance
    *d*.
  prefs: []
  type: TYPE_NORMAL
- en: Output for each test case is separated from the next by a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for the above sample input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The time limit for solving the test cases is 0.6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reading the Input*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One interesting difference between this problem and the Halloween Haul problem
    is that we’re no longer dealing with binary trees. Here, a node can have any number
    of children. We’ll have to change our node structure, since `left` and `right`
    pointers are not going to work for us anymore. Instead, we’ll use an array `children`
    of children and an integer `num_children` to record the number of children stored
    in the array. We’ll also have a `name` member to store the node’s name (Zara,
    Amber, and so on) and a `score` member for when we calculate the number of descendants
    at distance *d*. Our `node` struct is given in [Listing 2-20](ch02.xhtml#ch02ex020).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-20: The* node *struct*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Halloween Haul, the trees started as recursively defined expressions, from
    which we could recursively read off the left and right subtrees. This is not the
    case here: nodes can come in any order. For example, we might see'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: where we learn about Zara’s child, Amber, before we learn about Amber’s children.
    However, we could equally well see
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: where we learn about Amber’s children before Zara’s!
  prefs: []
  type: TYPE_NORMAL
- en: We know that the nodes and parent-child relationships we read from the file
    will, by the time we’re done, form a single tree. Nonetheless, there’s no guarantee
    that we have a single tree as we process the lines. For example, we might read
    the lines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that Enzo is a child of Lucas and that Amber is a child of Zara,
    but so far that’s all we know. We have two disconnected subtrees here, and it
    will take future lines to connect these subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, maintaining a single, connected tree as we read the lines
    is hopeless. Instead, we’ll maintain an array of pointers to nodes. Every time
    we see a name we haven’t seen before, we create a new node and add a pointer to
    that node to the array. It will therefore prove valuable to have a helper function
    that searches the array and tells us whether we have seen a name before.
  prefs: []
  type: TYPE_NORMAL
- en: Finding a Node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 2-21](ch02.xhtml#ch02ex021) implements a `find_node` function. The
    `nodes` parameter is an array of pointers to nodes, `num_nodes` gives the number
    of pointers in the array, and `name` is the name that we’re searching for.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-21: Finding a node*'
  prefs: []
  type: TYPE_NORMAL
- en: A *linear search* is an element-by-element search of an array. Inside our function,
    we use a linear search to search through `nodes`, and . . . but wait! Aren’t we
    searching through an array? This is tailor-made hash table territory right here
    (see [Chapter 1](ch01.xhtml)). I encourage you to swap in a hash table on your
    own and compare the performance. To keep things simple, and because there are
    at most only 1,000 nodes, we’ll proceed with this (slow) linear search.
  prefs: []
  type: TYPE_NORMAL
- en: We do a string comparison between each name in the array and the desired name.
    If `strcmp` returns `0`, it means that the strings are equal, so we return the
    pointer to the corresponding node. If we reach the end of the array without finding
    the name, we return `NULL` to signal that the name was not found.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Node
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When a name is not found in the array, we’ll have to create a node with that
    name. This will involve a call to `malloc`, and we’ll see that `malloc` will be
    required elsewhere in the program as well. So, I’ve written a helper function,
    `malloc_safe`, that we can call whenever we need it. See [Listing 2-22](ch02.xhtml#ch02ex022):
    it’s just a regular `malloc`, but with error checking added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-22: The* malloc_safe *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The `new_node` helper function in [Listing 2-23](ch02.xhtml#ch02ex023) uses
    `malloc_safe` to create a new node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-23: Creating a node*'
  prefs: []
  type: TYPE_NORMAL
- en: We allocate the new node and then set the node’s `name` member. Then, we set
    the node’s number of children to `0`. The reason we use zero here is because we
    may not know how many children the node has. For example, suppose that the first
    line that we read for the tree is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We know that Lucas has one child, but we have no idea how many children Enzo
    has. The caller of `new_node` can set the number of children to a new value once
    that information is available. That happens immediately for Lucas here, but not
    for Enzo.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Family Tree
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we’re ready to read and build the tree. [Listing 2-24](ch02.xhtml#ch02ex024)
    gives the function. Here `nodes` is an array of pointers to nodes, with space
    allocated by the caller of this function; `num_lines` indicates the number of
    lines to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-24: Converting lines into a tree*'
  prefs: []
  type: TYPE_NORMAL
- en: The outer `for` loop ➊ iterates once for each of the `num_lines` lines of input.
    Each line has the name of a parent and one or more names for children; we deal
    with the parent first. We allocate memory, read the parent’s name, and read the
    parent’s number of children. Then, we use our `find_node` helper function to determine
    whether we have seen this node before ➋. If we have not, we use our `new_node`
    helper function to create a new node, store a pointer to the new node in the `nodes`
    array, and increment the number of nodes. If the node is already in the `nodes`
    array, we free the memory for the parent name since it will not be used ➌.
  prefs: []
  type: TYPE_NORMAL
- en: We next allocate memory for the parent’s child pointers ➍, and we store the
    number of children ➎. We then process the child nodes; each child is processed
    similarly to the parent node. Once the child node exists and has its members set,
    we store a pointer to it in the parent’s `children` array ➏. Notice that there
    is no child code that allocates any memory or sets the number of children, like
    we had for the parent. If we have seen a child name before, then its children
    were already set when this name was encountered the first time. If this is the
    first time we’re seeing the name, then we’ll set its children when we later learn
    about its children; if this child is a leaf, its number of children will remain
    at its initialized value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: We end by returning the number of nodes in the tree. We’ll need this when we
    want to process each node.
  prefs: []
  type: TYPE_NORMAL
- en: '*Number of Descendants from One Node*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to calculate the number of descendants at distance *d* for each node,
    so we can find the nodes with the most such descendants. A more modest goal, and
    the goal for this section, is to calculate the number of descendants at distance
    *d* from a single node. We’ll write the function with this signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: where `n` is the node whose number of descendants at distance `d` we’d like
    to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `d` is `1`, then we want to know the number of children of `n`. That we
    can do: we have stored a `num_children` member with each node. All we have to
    do is return that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If `d` is greater than `1`, then what? It may be worth thinking about this
    first in the more familiar context of binary trees. Here’s the binary tree from
    Halloween Haul ([Figure 2-2](ch02.xhtml#ch02fig02)) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/unch02fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose we had a node of a binary tree and we wanted to know its number of descendants
    at some specified distance. If we knew how many descendants at that distance were
    in the left subtree and how many were in the right subtree, would that help?
  prefs: []
  type: TYPE_NORMAL
- en: Not quite. Suppose, for example, that we wanted to know the number of descendants
    of H at a distance of two. We calculate the number of descendants of F at a distance
    of two and the number of descendants of G at a distance of two. That doesn’t help,
    because each of those descendants is at a distance of three from H! We don’t care
    about nodes at a distance of three.
  prefs: []
  type: TYPE_NORMAL
- en: How do we fix this? We calculate the number of descendants of F at a distance
    of one and G at a distance of one! Each of those nodes is at a distance of two
    from H.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the number of descendants at any distance *d*, then, we calculate
    the number of descendants at distance *d* – 1 in the left subtree and number of
    descendants at distance *d* – 1 in the right subtree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of family trees, where a node can have more than two children,
    we generalize this slightly: the number of descendants at distance *d* is the
    sum of the number of descendants at distance *d* – 1 in each subtree. And how
    are we going to find the number of descendants at distance *d* – 1 in each subtree?
    It’s recursion time!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some rules for us to use. Given a node *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1**   If *d* equals one, then the number of descendants at distance
    *d* equals the number of children of *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2**   If *d* is greater than one, then the number of descendants at
    distance *d* equals the sum of the number of descendants at distance *d* – 1 in
    each subtree of *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding code is given in [Listing 2-25](ch02.xhtml#ch02ex025).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-25: The number of descendants from one node*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Number of Descendants from All Nodes*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To calculate the number of descendants at distance *d* for all nodes, we simply
    put `score_one` in a loop ([Listing 2-26](ch02.xhtml#ch02ex026)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-26: The number of descendants from all nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where we use the `score` member in each `node` struct: after this function
    runs, `score` holds the number of descendants of interest for each node. Now we
    just have to figure out which nodes have the highest scores!'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sorting Nodes*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our ill-fated attempt to sort snowflakes (see “Diagnosing the Problem” on
    [page 9](ch01.xhtml#ch01lev1)), we came across the C `qsort` function. We can
    bring `qsort` to bear here to sort our nodes. We’re required to sort by number
    of descendants at distance *d*, from highest to lowest. If nodes are tied for
    the number of descendants at distance *d*, then we sort those alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: To use `qsort`, we’re tasked with writing a comparison function that takes pointers
    to two elements and returns a negative integer if the first element is less than
    the second, `0` if they are equal, and a positive integer if the first is greater
    than the second. Our comparison function is given in [Listing 2-27](ch02.xhtml#ch02ex027).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-27: A comparison function for sorting*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any `qsort` comparison function, like this one, has the same signature: it
    takes two void pointers. These pointers are `const` to signify that we should
    not make any changes to the elements that they point to.'
  prefs: []
  type: TYPE_NORMAL
- en: Void pointers must be cast before we can perform comparisons or otherwise access
    the underlying elements. Remember that `qsort` calls `compare` with pointers to
    two elements from our array, but, because our array is an array of pointers, what
    gets passed to `compare` is two pointers to pointers to elements. Therefore, we
    first cast the void pointers to type `const node**`, and then we apply `*` to
    give us values for `n1` and `n2` that are of type `const node*`. Now we can use
    `n1` and `n2` as pointers to nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by comparing the scores that are stored in each node. These scores
    will have already been calculated as the number of descendants at the distance
    *d*. If `n1` has more such descendants than `n2`, we return `-1` to indicate that
    `n1` should sort before `n2`. Similarly, if `n1` has fewer descendants at distance
    *d* than `n2`, we return `1` to indicate that `n1` should sort after `n2`.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to get to the final line, then, is if `n1` and `n2` have the same
    number of descendants at distance *d*. It’s here where we want to break the tie
    by sorting on the nodes’ names. We do this using `strcmp`, which returns a negative
    number, zero, or positive number if the first string is alphabetically less than,
    equal to, or greater than the second string, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '*Outputting the Information*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After we sort the nodes, the names to output are those at the beginning of
    the `nodes` array. [Listing 2-28](ch02.xhtml#ch02ex028) gives the function that
    produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-28: Outputting the nodes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable `i` counts the number of nodes that we have outputted. The outer
    `while` loop ➊ is controlled by three conditions that together determine whether
    we are allowed to output more nodes. If all three conditions are true, we know
    that more output is required, so we enter the body of that `while` loop. We then
    print information for the current node and increase `i` so that we look at the
    next node. Now, as long as this new node is tied with the previous node, we want
    to keep outputting nodes, with no heed to the “maximum of three nodes” rule. The
    conditions on the inner `while` loop ➋ encode this logic: if there are more nodes
    and the current node’s score is tied with the previous node, then we enter the
    body of the inner `while` loop and print information for the relevant node.'
  prefs: []
  type: TYPE_NORMAL
- en: '*The main Function*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All that remains is to glue our functions together and add the logic to process
    the test cases. We do this in [Listing 2-29](ch02.xhtml#ch02ex029).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-29: The* main *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by allocating pointers for the maximum number of nodes that can make
    up a test case ➊. We then read the number of test cases and loop once for each
    test case. Recall that each test case requires two pieces of output: information
    about the test case number and information about the relevant nodes. The first
    is handled by a single call of `printf` ➋. For the second, we start leaning on
    our earlier functions: we read the tree, solve the problem for each node, sort
    the nodes, and then output the required information.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a check at the bottom of the code to tell whether or not we’re in the
    final test case ➌; this is so we can output a blank line between tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive solutions are virtuous, simple, clean, easy to devise, easy to understand,
    and easy to prove correct . . .
  prefs: []
  type: TYPE_NORMAL
- en: Well, at least, that’s the sense you’d get if you read enough about recursion
    and talked to enough recursion enthusiasts. It’s clear what the experts think.
    Through my students, however, I’ve observed a disconnect between the way that
    recursion is touted and the way it is learned. It takes time and practice to appreciate
    the expert perspective. Don’t worry if you find recursive solutions tough to devise
    and trust. Keep at it! Many teachers and writers have their own approaches and
    examples for introducing recursion. More than for any other topic in the book,
    I encourage you to seek out additional material on recursion to complement what
    I have offered here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll keep going with recursion, optimizing it for a different
    class of problems.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Halloween Haul is originally from the 2012 DWITE Programming Competition, Round
    1\. Descendant Distance is originally from the 2005 East Central North America
    Regional Programming Contest. For a book-length treatment of recursion, check
    out *Thinking Recursively with Java* by Eric Roberts (2005).
  prefs: []
  type: TYPE_NORMAL
