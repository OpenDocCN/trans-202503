- en: 'Chapter 11. Rubinius: Ruby Implemented with Ruby'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。Rubinius：用Ruby实现的Ruby
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![无标题图像](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Rubinius uses Ruby to implement Ruby.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Rubinius使用Ruby实现Ruby。*'
- en: Like JRuby, Rubinius is an alternative implementation of Ruby. Much of Rubinius’s
    internal source code is written in Ruby itself instead of in only C or Java. Rubinius
    implements built-in classes, such as `Array`, `String`, and `Integer`, just as
    you would—with Ruby code!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 像JRuby一样，Rubinius是Ruby的一个替代实现。Rubinius的许多内部源代码是用Ruby本身编写的，而不是仅使用C或Java编写。Rubinius实现了内置类，如`Array`、`String`和`Integer`，正如你使用Ruby代码实现它们一样！
- en: This design offers a unique opportunity for you to learn about Ruby internals.
    If you aren’t sure how a particular Ruby feature or method works, you can read
    the Ruby code inside Rubinius to find out, without special knowledge of C or Java
    programming.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这一设计为你提供了一个独特的机会，了解Ruby的内部工作原理。如果你不确定某个特定的Ruby特性或方法是如何工作的，你可以阅读Rubinius中的Ruby代码来了解，而无需特别掌握C或Java编程知识。
- en: Rubinius also includes a sophisticated virtual machine written in C++. This
    machine executes your Ruby program and, like JRuby, supports JIT and true concurrency
    and uses a sophisticated garbage collection algorithm.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius还包括一个用C++编写的复杂虚拟机。这个虚拟机会执行你的Ruby程序，像JRuby一样，支持JIT和真正的并发，并使用复杂的垃圾回收算法。
- en: This chapter starts with a high-level overview of Rubinius and an example of
    how to use backtrace output to dig through the Rubinius source code. Later in
    the chapter, we’ll learn how Rubinius and MRI implement the `Array` class, including
    how Ruby saves data into an array and what happens when you remove an element
    from an array.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时提供了Rubinius的高级概述，并举例说明如何使用回溯输出深入探讨Rubinius的源代码。接下来，我们将了解Rubinius和MRI如何实现`Array`类，包括Ruby如何将数据保存到数组中，以及从数组中删除元素时发生的事情。
- en: Roadmap
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[The Rubinius Kernel and Virtual Machine](ch11.html#rubinius_kernel_and_virtual_machine
    "The Rubinius Kernel and Virtual Machine")'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rubinius内核和虚拟机](ch11.html#rubinius_kernel_and_virtual_machine "Rubinius内核和虚拟机")'
- en: '[Tokenization and Parsing](ch11.html#tokenization_and_parsing-id00043 "Tokenization
    and Parsing")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[词法分析与解析](ch11.html#tokenization_and_parsing-id00043 "词法分析与解析")'
- en: '[Using Ruby to Compile Ruby](ch11.html#using_ruby_to_compile_ruby "Using Ruby
    to Compile Ruby")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用Ruby编译Ruby](ch11.html#using_ruby_to_compile_ruby "使用Ruby编译Ruby")'
- en: '[Rubinius Bytecode Instructions](ch11.html#rubinius_bytecode_instructions "Rubinius
    Bytecode Instructions")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rubinius字节码指令](ch11.html#rubinius_bytecode_instructions "Rubinius字节码指令")'
- en: '[Ruby and C++ Working Together](ch11.html#ruby_and_cplusplus_working_together
    "Ruby and C++ Working Together")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby与C++的协作](ch11.html#ruby_and_cplusplus_working_together "Ruby与C++的协作")'
- en: '[Implementing Ruby Objects with C++ Objects](ch11.html#implementing_ruby_objects_with_cplusplus
    "Implementing Ruby Objects with C++ Objects")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用C++对象实现Ruby对象](ch11.html#implementing_ruby_objects_with_cplusplus "使用C++对象实现Ruby对象")'
- en: '**[Experiment 11-1: Comparing Backtraces in MRI and Rubinius](ch11.html#experiment_11-1_comparing_backtraces_in
    "Experiment 11-1: Comparing Backtraces in MRI and Rubinius")**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 11-1：比较MRI和Rubinius中的回溯](ch11.html#experiment_11-1_comparing_backtraces_in
    "实验 11-1：比较MRI和Rubinius中的回溯")**'
- en: '[Backtraces in Rubinius](ch11.html#backtraces_in_rubinius "Backtraces in Rubinius")'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rubinius中的回溯](ch11.html#backtraces_in_rubinius "Rubinius中的回溯")'
- en: '[Arrays in Rubinius and MRI](ch11.html#arrays_in_rubinius_and_mri "Arrays in
    Rubinius and MRI")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rubinius和MRI中的数组](ch11.html#arrays_in_rubinius_and_mri "Rubinius和MRI中的数组")'
- en: '[Arrays Inside of MRI](ch11.html#arrays_inside_of_mri "Arrays Inside of MRI")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MRI中的数组](ch11.html#arrays_inside_of_mri "MRI中的数组")'
- en: '[The RArray C Structure Definition](ch11.html#rarray_c_structure_definition
    "The RArray C Structure Definition")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RArray C结构定义](ch11.html#rarray_c_structure_definition "RArray C结构定义")'
- en: '[Arrays Inside of Rubinius](ch11.html#arrays_inside_of_rubinius "Arrays Inside
    of Rubinius")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rubinius中的数组](ch11.html#arrays_inside_of_rubinius "Rubinius中的数组")'
- en: '**[Experiment 11-2: Exploring the Rubinius Implementation of Array#shift](ch11.html#experiment_11-2_exploring_the_rubinius_i
    "Experiment 11-2: Exploring the Rubinius Implementation of Array#shift")**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 11-2：探索Rubinius中Array#shift的实现](ch11.html#experiment_11-2_exploring_the_rubinius_i
    "实验 11-2：探索Rubinius中Array#shift的实现")**'
- en: '[Reading Array#shift](ch11.html#reading_arrayhashshift "Reading Array#shift")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阅读Array#shift](ch11.html#reading_arrayhashshift "阅读Array#shift")'
- en: '[Modifying Array#shift](ch11.html#modifying_arrayhashshift "Modifying Array#shift")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[修改Array#shift](ch11.html#modifying_arrayhashshift "修改Array#shift")'
- en: '[Summary](ch11.html#summary-id00044 "Summary")'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch11.html#summary-id00044 "总结")'
- en: The Rubinius Kernel and Virtual Machine
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rubinius内核和虚拟机
- en: To run a Ruby program using Rubinius (see [Figure 11-1](ch11.html#rubinius_consists_of_a_cplusplus_virtual
    "Figure 11-1. Rubinius consists of a C++ virtual machine and a Ruby kernel.")),
    you typically use the `ruby` command (as with MRI) or `rbx` because the `ruby`
    command is actually a symbolic link to the executable *rbx* in Rubinius.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Rubinius运行Ruby程序（参见[图11-1](ch11.html#rubinius_consists_of_a_cplusplus_virtual
    "图11-1. Rubinius由C++虚拟机和Ruby内核组成")），通常使用`ruby`命令（与MRI相同）或`rbx`，因为`ruby`命令实际上是Rubinius中可执行文件*rbx*的符号链接。
- en: '![Rubinius consists of a C++ virtual machine and a Ruby kernel.](httpatomoreillycomsourcenostarchimages1854317.png.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius由C++虚拟机和Ruby内核组成。](httpatomoreillycomsourcenostarchimages1854317.png.jpg)'
- en: Figure 11-1. Rubinius consists of a C++ virtual machine and a Ruby kernel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1. Rubinius由C++虚拟机和Ruby内核组成。
- en: 'As with MRI, you launch Rubinius using an executable that reads and executes
    the Ruby program specified on the command line. But the Rubinius executable is
    completely different from the standard Ruby executable. As the preceding figure
    shows, Rubinius consists of two major pieces:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与MRI一样，你通过一个可执行文件来启动Rubinius，该文件读取并执行命令行中指定的Ruby程序。但Rubinius的可执行文件与标准的Ruby可执行文件完全不同。正如前面的图所示，Rubinius由两个主要部分组成：
- en: '****The Rubinius kernel****. This is the part of Rubinius written in Ruby.
    It implements a lot of the language, including the definitions of many built-in,
    core classes, such as `String` and `Array`. The Rubinius kernel is compiled into
    bytecode instructions that are installed onto your computer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****Rubinius内核****。这是Rubinius中用Ruby编写的部分。它实现了大部分语言特性，包括许多内建核心类的定义，如`String`和`Array`。Rubinius内核被编译成字节码指令并安装到你的计算机上。'
- en: '****The Rubinius virtual machine****. The Rubinius virtual machine is written
    in C++. It executes the bytecode instructions from the Rubinius kernel and performs
    a range of other low-level tasks, such as garbage collection. The Rubinius executable
    contains a compiled, machine-language version of this virtual machine.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****Rubinius虚拟机****。Rubinius虚拟机是用C++编写的。它执行来自Rubinius内核的字节码指令，并执行一系列其他低级任务，如垃圾回收。Rubinius可执行文件包含了此虚拟机的已编译机器语言版本。'
- en: '[Figure 11-2](ch11.html#closer_view_of_rubinius_internals "Figure 11-2. A closer
    view of Rubinius internals") takes a closer look at Rubinius’s virtual machine
    and kernel. The Rubinius kernel contains a set of Ruby classes, such as `String`,
    `Array`, and `Object`, as well as other Ruby classes that perform various tasks,
    such as compiling or loading code. The Rubinius virtual machine at the left of
    the figure is the *rbx* executable that you launch from the command line. The
    C++ virtual machine contains code to perform garbage collection, just-in-time
    compilation (and many other tasks), as well as additional code for built-in classes,
    such as `String` or `Array`. In fact, as indicated by the arrows, each Ruby class
    built into Rubinius consists of both C++ and Ruby code working together. Rubinius
    defines certain methods using Ruby and other methods using C++.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-2](ch11.html#closer_view_of_rubinius_internals "图11-2. Rubinius内部的更近视图")更详细地展示了Rubinius的虚拟机和内核。Rubinius内核包含一组Ruby类，如`String`、`Array`和`Object`，以及执行各种任务的其他Ruby类，如编译或加载代码。图中左侧的Rubinius虚拟机是你从命令行启动的*rbx*可执行文件。C++虚拟机包含执行垃圾回收、即时编译（以及许多其他任务）的代码，以及用于内建类（如`String`或`Array`）的附加代码。事实上，正如箭头所示，每个内建于Rubinius中的Ruby类都由C++和Ruby代码共同工作。Rubinius使用Ruby定义某些方法，使用C++定义其他方法。'
- en: '![A closer view of Rubinius internals](httpatomoreillycomsourcenostarchimages1854319.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius内部的更近视图](httpatomoreillycomsourcenostarchimages1854319.png)'
- en: Figure 11-2. A closer view of Rubinius internals
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2. Rubinius内部的更近视图
- en: Why implement Ruby using two languages? Because C++ speeds up Rubinius programs
    and allows them to interact with the operating system directly at a low level.
    The use of C++ instead of C also allows Rubinius to use an elegant object-oriented
    design internally. And the use of Ruby to implement built-in classes and other
    features makes it easy for Ruby developers to read and understand much of the
    Rubinius source code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用两种语言实现Ruby？因为C++加速了Rubinius程序，并允许它们以低级别直接与操作系统进行交互。使用C++而不是C还使得Rubinius能够在内部使用优雅的面向对象设计。而使用Ruby来实现内建类和其他功能使得Ruby开发者能够轻松阅读和理解Rubinius源代码的大部分内容。
- en: Tokenization and Parsing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分词和解析
- en: Rubinius processes your Ruby program in much the same way that MRI does, as
    shown in [Figure 11-3](ch11.html#how_rubinius_processes_your_code "Figure 11-3. How
    Rubinius processes your code").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 处理你的 Ruby 程序的方式与 MRI 非常相似，如[图 11-3](ch11.html#how_rubinius_processes_your_code
    "图 11-3. Rubinius 如何处理你的代码")所示。
- en: '![How Rubinius processes your code](httpatomoreillycomsourcenostarchimages1854321.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 如何处理你的代码](httpatomoreillycomsourcenostarchimages1854321.png.jpg)'
- en: Figure 11-3. How Rubinius processes your code
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3. Rubinius 如何处理你的代码
- en: Rubinius generates an LALR parser using Bison during its build process, just
    as MRI does. When you run your program, the parser converts your code into a token
    stream, an abstract syntax tree (AST) structure, and then a series of high-level
    virtual machine instructions called *Rubinius instructions*. [Figure 11-4](ch11.html#how_mri_and_rubinius_transform_your_code
    "Figure 11-4. How MRI and Rubinius transform your code internally") compares the
    forms that your code takes inside MRI and Rubinius.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 在构建过程中使用 Bison 生成一个 LALR 解析器，和 MRI 一样。当你运行程序时，解析器将代码转换为一个标记流、一个抽象语法树（AST）结构，然后是一个高层次虚拟机指令序列，称为
    *Rubinius 指令*。[图 11-4](ch11.html#how_mri_and_rubinius_transform_your_code "图 11-4.
    MRI 和 Rubinius 如何在内部转换你的代码")比较了代码在 MRI 和 Rubinius 内部的形式。
- en: At first, Rubinius and MRI work similarly, but instead of interpreting your
    code as MRI does, Rubinius uses a compiler framework called the Low-Level Virtual
    Machine (LLVM) to compile your code again into lower-level instructions. LLVM,
    in turn, may compile these instructions all the way to machine language, using
    a JIT compiler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Rubinius 和 MRI 的工作方式相似，但与 MRI 直接解释代码不同，Rubinius 使用名为低级虚拟机（LLVM）的编译器框架，将代码再次编译成更低级的指令。LLVM
    反过来可能使用 JIT 编译器将这些指令编译成机器语言。
- en: '![How MRI and Rubinius transform your code internally](httpatomoreillycomsourcenostarchimages1854323.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![MRI 和 Rubinius 如何在内部转换你的代码](httpatomoreillycomsourcenostarchimages1854323.png.jpg)'
- en: Figure 11-4. How MRI and Rubinius transform your code internally
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4. MRI 和 Rubinius 如何在内部转换你的代码
- en: Using Ruby to Compile Ruby
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ruby 编译 Ruby
- en: One of the most fascinating aspects of Rubinius is how it implements a Ruby
    compiler with a combination of Ruby and C++. When you run a program using Rubinius,
    your code is processed by both C++ and Ruby code, as shown in [Figure 11-5](ch11.html#high-level_overview_of_how_rubinius_co
    "Figure 11-5. A high-level overview of how Rubinius compiles your code").
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 最吸引人的特点之一是它如何通过 Ruby 和 C++ 的结合实现 Ruby 编译器。当你使用 Rubinius 运行程序时，你的代码将同时由
    C++ 和 Ruby 代码处理，如[图 11-5](ch11.html#high-level_overview_of_how_rubinius_co "图
    11-5. Rubinius 如何编译你的代码的高级概述")所示。
- en: '![A high-level overview of how Rubinius compiles your code](httpatomoreillycomsourcenostarchimages1854325.png.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 如何编译你的代码的高级概述](httpatomoreillycomsourcenostarchimages1854325.png.jpg)'
- en: Figure 11-5. A high-level overview of how Rubinius compiles your code
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-5. Rubinius 如何编译你的代码的高级概述
- en: At the top left of the diagram, Rubinius, like MRI, uses C code to parse Ruby
    code with a series of grammar rules. At right, Rubinius starts to process your
    Ruby program using Ruby code, representing each node in the AST with an instance
    of a Ruby class. Each Ruby AST node knows how to generate Rubinius instructions
    for its piece of your program during compilation. Finally, at bottom left, the
    LLVM framework further compiles the Rubinius instructions into LLVM instructions
    and ultimately into machine language.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左上角，Rubinius 和 MRI 一样，使用 C 代码通过一系列语法规则解析 Ruby 代码。在右侧，Rubinius 开始使用 Ruby 代码处理你的
    Ruby 程序，将 AST 中的每个节点表示为 Ruby 类的实例。在编译过程中，每个 Ruby AST 节点都知道如何为程序的相应部分生成 Rubinius
    指令。最后，在左下角，LLVM 框架进一步将 Rubinius 指令编译成 LLVM 指令，并最终编译成机器语言。
- en: Rubinius Bytecode Instructions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rubinius 字节码指令
- en: To get a sense of Rubinius instructions, let’s run a short program using Rubinius
    (see [Example 11-1](ch11.html#using_rubinius_to_calculate_2_plus_2_equ "Example 11-1. Using
    Rubinius to calculate 2 + 2 = 4 (simple.rb)")).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Rubinius 指令，让我们使用 Rubinius 运行一个简短的程序（参见[示例 11-1](ch11.html#using_rubinius_to_calculate_2_plus_2_equ
    "示例 11-1. 使用 Rubinius 计算 2 + 2 = 4 (simple.rb)"))。
- en: Example 11-1. Using Rubinius to calculate 2 + 2 = 4 *(simple.rb)*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-1. 使用 Rubinius 计算 2 + 2 = 4 *(simple.rb)*
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we rerun *simple.rb* using the `rbx compile` command with the `-B` option,
    Rubinius displays the bytecode instructions its compiler generates, as shown in
    [Example 11-2](ch11.html#displaying_rubinius_bytecode_instruction "Example 11-2. Displaying
    Rubinius bytecode instructions using the rbx compile command with the -B option").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `rbx compile` 命令和 `-B` 选项重新运行 *simple.rb* 时，Rubinius 显示了它的编译器生成的字节码指令，如[示例
    11-2](ch11.html#displaying_rubinius_bytecode_instruction "示例 11-2. 使用 rbx compile
    命令和 -B 选项显示 Rubinius 字节码指令")所示。
- en: Example 11-2. Displaying Rubinius bytecode instructions using the `rbx compile`
    command with the `-B` option
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-2. 使用 `rbx compile` 命令和 `-B` 选项显示 Rubinius 字节码指令
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The instructions vaguely resemble MRI’s YARV instructions. Each instruction
    typically pushes a value onto an internal stack, operates on stack values, or
    executes a method such as the `+` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    or `puts` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令与 MRI 的 YARV 指令有些相似。每条指令通常会将一个值推送到内部栈上，对栈上的值进行操作，或者执行一个方法，比如 `+` 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    或 `puts` 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。
- en: '[Figure 11-6](ch11.html#puts_method_in_rubinius_is_implement "Figure 11-6. The
    puts method in Rubinius is implemented with Ruby code.") shows both the Ruby code
    and corresponding Rubinius instructions for *simple.rb* and part of the `Kernel`
    module.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-6](ch11.html#puts_method_in_rubinius_is_implement "图 11-6. Rubinius 中的
    puts 方法是通过 Ruby 代码实现的.") 显示了 Ruby 代码和对应的 Rubinius 指令，分别用于 *simple.rb* 和 `Kernel`
    模块的一部分。'
- en: '![The puts method in Rubinius is implemented with Ruby code.](httpatomoreillycomsourcenostarchimages1854327.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 中的 puts 方法是通过 Ruby 代码实现的。](httpatomoreillycomsourcenostarchimages1854327.png.jpg)'
- en: Figure 11-6. The `puts` method in Rubinius is implemented with Ruby code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6. Rubinius 中的 `puts` 方法是通过 Ruby 代码实现的。
- en: 'You can see Ruby code at the top of the figure: the `puts 2+2` code at left
    and Rubinius’s definition of the `puts` method at right. Rubinius implements built-in
    Ruby classes, such as the `Kernel` module, in Ruby; therefore, when we call the
    `puts` method, Rubinius simply passes control to the Ruby code for the `Kernel#puts`
    method contained inside the Rubinius kernel.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图中的顶部看到 Ruby 代码：左侧是 `puts 2+2` 代码，右侧是 Rubinius 对 `puts` 方法的定义。Rubinius 在
    Ruby 中实现了内置 Ruby 类，比如 `Kernel` 模块；因此，当我们调用 `puts` 方法时，Rubinius 会将控制权传递给 Rubinius
    内核中包含的 Ruby 代码中的 `Kernel#puts` 方法。
- en: The lower portion of the figure shows the Rubinius instructions into which the
    Ruby code is compiled. At left are the instructions for `puts 2+2`, and at right
    is the compiled version of the `Kernel#puts` method. Rubinius compiles its built-in
    Ruby code and your Ruby code in the same manner (except that Rubinius compiles
    the built-in Ruby code during the Rubinius build process).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图的下半部分显示了 Ruby 代码编译后的 Rubinius 指令。左侧是 `puts 2+2` 的指令，右侧是 `Kernel#puts` 方法的编译版本。Rubinius
    以相同的方式编译其内置 Ruby 代码和你的 Ruby 代码（只是 Rubinius 在构建过程中编译内置 Ruby 代码）。
- en: Ruby and C++ Working Together
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 和 C++ 协同工作
- en: In order to handle certain low-level technical details and to speed things up,
    Rubinius uses C++ code in its virtual machine to help implement built-in classes
    and modules. That is, it uses both Ruby and C++ to implement the language’s core
    classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理某些底层技术细节并提高速度，Rubinius 在其虚拟机中使用 C++ 代码来帮助实现内置的类和模块。也就是说，它同时使用 Ruby 和 C++
    来实现语言的核心类。
- en: To understand how this works, let’s execute this short Ruby script in Rubinius
    (see [Example 11-3](ch11.html#calling_the_stringhashleft_square_bracke "Example 11-3. Calling
    the String#[] method")).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个过程，让我们在 Rubinius 中执行这个简短的 Ruby 脚本（见[示例 11-3](ch11.html#calling_the_stringhashleft_square_bracke
    "示例 11-3. 调用 String#[] 方法")）。
- en: Example 11-3. Calling the `String#[]` method
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-3. 调用 `String#[]` 方法
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This simple program prints the fifth character (the letter *q* at index 4) in
    the sample string. Because the `String#[]` method is part of a built-in Ruby class,
    Rubinius implements it using Ruby code, as shown in [Figure 11-7](ch11.html#rubinius_implements_built-in_classes_wit
    "Figure 11-7. Rubinius implements built-in classes with a combination of Ruby
    and C++ code.").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序打印了样本字符串中的第五个字符（索引为 4 的字母 *q*）。由于 `String#[]` 方法是内置 Ruby 类的一部分，Rubinius
    使用 Ruby 代码来实现它，如[图 11-7](ch11.html#rubinius_implements_built-in_classes_wit "图
    11-7. Rubinius 通过结合 Ruby 和 C++ 代码实现内置类.")所示。
- en: '![Rubinius implements built-in classes with a combination of Ruby and C++ code.](httpatomoreillycomsourcenostarchimages1854329.png.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 通过结合 Ruby 和 C++ 代码实现内置类。](httpatomoreillycomsourcenostarchimages1854329.png.jpg)'
- en: Figure 11-7. Rubinius implements built-in classes with a combination of Ruby
    and C++ code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7. Rubinius 使用 Ruby 和 C++ 代码的组合来实现内置类。
- en: 'On the left of the figure is the Ruby script that prints the letter *q*. On
    the right is the Ruby code that Rubinius uses to implement the `String#[]` method,
    taken from a Rubinius source code file called *string.rb* (named after the `String`
    class). (We’ll learn how to find Rubinius source code files in [Experiment 11-1:
    Comparing Backtraces in MRI and Rubinius](ch11.html#experiment_11-1_comparing_backtraces_in
    "Experiment 11-1: Comparing Backtraces in MRI and Rubinius").)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图左侧是打印字母 *q* 的 Ruby 脚本。右侧是 Rubinius 用于实现 `String#[]` 方法的 Ruby 代码，取自名为 *string.rb*
    的 Rubinius 源代码文件（该文件以 `String` 类命名）。(我们将在[实验 11-1：比较 MRI 和 Rubinius 的回溯](ch11.html#experiment_11-1_comparing_backtraces_in
    "实验 11-1：比较 MRI 和 Rubinius 的回溯")中学习如何找到 Rubinius 源代码文件。)
- en: Notice that the beginning of `String#[]` starts with the method call `Rubinius.primitive`.
    This indicates that Rubinius actually uses C++ code to implement this method;
    `Rubinius.primitive` is a directive that tells the Rubinius compiler to generate
    a call to the corresponding C++ code. The code that actually implements `String#[]`
    is a C++ method called `String::aref`, shown at the bottom right of [Figure 11-7](ch11.html#rubinius_implements_built-in_classes_wit
    "Figure 11-7. Rubinius implements built-in classes with a combination of Ruby
    and C++ code.").
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`String#[]` 的开始部分是方法调用 `Rubinius.primitive`。这表明 Rubinius 实际上使用 C++ 代码来实现这个方法；`Rubinius.primitive`
    是一个指令，告诉 Rubinius 编译器生成对相应 C++ 代码的调用。实际实现 `String#[]` 的代码是一个名为 `String::aref`
    的 C++ 方法，位于 [图 11-7](ch11.html#rubinius_implements_built-in_classes_wit "图 11-7.
    Rubinius 使用 Ruby 和 C++ 代码的组合来实现内置类") 的右下方。
- en: Implementing Ruby Objects with C++ Objects
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 C++ 对象实现 Ruby 对象
- en: Ruby’s use of the object-oriented C++ allows its virtual machine to represent
    each Ruby object internally using a corresponding C++ object (see [Figure 11-8](ch11.html#rubinius_represents_classes_and_objects
    "Figure 11-8. Rubinius represents classes and objects using C++ objects.")).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用面向对象的 C++ 使其虚拟机能够通过相应的 C++ 对象在内部表示每个 Ruby 对象（见 [图 11-8](ch11.html#rubinius_represents_classes_and_objects
    "图 11-8. Rubinius 使用 C++ 对象表示类和对象")）。
- en: Rubinius uses C++ objects the way that MRI uses the `RClass` and `RObject` C
    structures. When you define a class, Rubinius creates an instance of the `Class`
    C++ class. When you create a Ruby object, Rubinius creates an instance of the
    `Object` C++ class. A `klass_` pointer in the `pythagoras` object indicates it
    is an instance of `Mathematician`, just as the `klass` pointer in the `RObject`
    C structure does in MRI.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 使用 C++ 对象，就像 MRI 使用 `RClass` 和 `RObject` C 结构体一样。当你定义一个类时，Rubinius
    会创建一个 `Class` C++ 类的实例。当你创建一个 Ruby 对象时，Rubinius 会创建一个 `Object` C++ 类的实例。`pythagoras`
    对象中的 `klass_` 指针表示它是 `Mathematician` 类的实例，就像 MRI 中 `RObject` C 结构体中的 `klass` 指针一样。
- en: '![Rubinius represents classes and objects using C++ objects.](httpatomoreillycomsourcenostarchimages1854331.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 使用 C++ 对象表示类和对象。](httpatomoreillycomsourcenostarchimages1854331.png)'
- en: Figure 11-8. Rubinius represents classes and objects using C++ objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-8. Rubinius 使用 C++ 对象表示类和对象。
- en: 'Experiment 11-1: Comparing Backtraces in MRI and Rubinius'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 11-1：比较 MRI 和 Rubinius 的回溯
- en: Recall that Ruby displays a backtrace when an exception occurs in order to help
    you find the problem. [Example 11-4](ch11.html#ruby_script_that_raises_an_exception
    "Example 11-4. A Ruby script that raises an exception") shows a simple example.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当异常发生时，Ruby 会显示回溯以帮助你找到问题。[示例 11-4](ch11.html#ruby_script_that_raises_an_exception
    "示例 11-4：抛出异常的 Ruby 脚本") 展示了一个简单的例子。
- en: Example 11-4. A Ruby script that raises an exception
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-4. 一个抛出异常的 Ruby 脚本
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We call `raise` to tell Ruby to stop the first time it executes the block after
    displaying the value of the parameter `n`. [Example 11-5](ch11.html#how_mri_displays_a_backtrace_for_an_exce
    "Example 11-5. How MRI displays a backtrace for an exception") shows the output
    from running [Example 11-4](ch11.html#ruby_script_that_raises_an_exception "Example 11-4. A
    Ruby script that raises an exception") with MRI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `raise` 来告诉 Ruby 在显示参数 `n` 的值后第一次执行块时停止。[示例 11-5](ch11.html#how_mri_displays_a_backtrace_for_an_exce
    "示例 11-5：MRI 如何显示异常的回溯") 展示了运行 [示例 11-4](ch11.html#ruby_script_that_raises_an_exception
    "示例 11-4：抛出异常的 Ruby 脚本") 时的输出，使用的是 MRI。
- en: Example 11-5. How MRI displays a backtrace for an exception
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-5. MRI 如何显示异常的回溯
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You probably see output like this many times while developing a Ruby program.
    However, one subtle detail is worth a closer look. [Figure 11-9](ch11.html#mri_displays_where_built-in_cfunc_method
    "Figure 11-9. MRI displays where built-in CFUNC methods are called, not where
    they are defined.") shows a diagram of the MRI backtrace output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Ruby 程序时，你可能多次看到类似的输出。然而，有一个微妙的细节值得仔细观察。 [图 11-9](ch11.html#mri_displays_where_built-in_cfunc_method
    "图 11-9. MRI 显示内置 CFUNC 方法的调用位置，而非定义位置") 展示了 MRI 回溯输出的示意图。
- en: '![MRI displays where built-in CFUNC methods are called, not where they are
    defined.](httpatomoreillycomsourcenostarchimages1854333.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![MRI 显示内置 CFUNC 方法的调用位置，而非定义位置。](httpatomoreillycomsourcenostarchimages1854333.png)'
- en: Figure 11-9. MRI displays where built-in CFUNC methods are called, not where
    they are defined.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9. MRI 显示内置 CFUNC 方法的调用位置，而非定义位置。
- en: Notice that line 3 of *iterate.rb*, containing the call to `raise`, is at the
    top of the call stack. At the bottom of the call stack, MRI displays `iterate.rb:1`,
    where the short script began.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，包含 `raise` 调用的 *iterate.rb* 第 3 行位于调用栈的顶部。在调用栈底部，MRI 显示了 `iterate.rb:1`，即脚本的起始位置。
- en: 'Notice, too, that MRI’s backtrace contains a broken link: *iterate.rb* doesn’t
    contain a definition for the method `times`. Instead, MRI refers to the line of
    code that *calls* the `times` method: `10.times do`. The actual `times` method
    is implemented with C code inside MRI—a CFUNC method. MRI displays the location
    of calls to CFUNC methods in backtraces, not the location of the actual C implementation
    of these methods.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，MRI 的回溯包含了一个断开的链接：*iterate.rb* 中没有定义 `times` 方法。相反，MRI 引用了 *调用* `times`
    方法的那行代码：`10.times do`。实际的 `times` 方法是用 C 代码在 MRI 内部实现的——一个 CFUNC 方法。MRI 在回溯中显示对
    CFUNC 方法的调用位置，而不是这些方法的实际 C 实现位置。
- en: Backtraces in Rubinius
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rubinius 中的回溯
- en: Unlike MRI, Rubinius implements built-in methods using Ruby, not C. This implementation
    allows Rubinius to include accurate source file and line number information about
    built-in methods in backtraces. To demonstrate, let’s run [Example 11-4](ch11.html#ruby_script_that_raises_an_exception
    "Example 11-4. A Ruby script that raises an exception") again using Rubinius.
    [Example 11-6](ch11.html#how_rubinius_displays_a_backtrace_for_an "Example 11-6. How
    Rubinius displays a backtrace for an exception") shows the result.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MRI 不同，Rubinius 使用 Ruby 而非 C 实现内置方法。该实现使得 Rubinius 在回溯中包含了内置方法的准确源文件和行号信息。为了演示这一点，我们再次使用
    Rubinius 运行 [示例 11-4](ch11.html#ruby_script_that_raises_an_exception "示例 11-4.
    一个抛出异常的 Ruby 脚本")。 [示例 11-6](ch11.html#how_rubinius_displays_a_backtrace_for_an
    "示例 11-6. Rubinius 如何显示异常的回溯") 显示了结果。
- en: Example 11-6. How Rubinius displays a backtrace for an exception
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-6. Rubinius 如何显示异常的回溯
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rubinius displays much more information! To understand this output a bit better,
    see [Figure 11-10](ch11.html#like_mricomma_rubinius_includes_informat "Figure 11-10. Like
    MRI, Rubinius includes information about your program in backtraces.") and [Figure 11-11](ch11.html#rubinius_includes_information_about_its
    "Figure 11-11. Rubinius includes information about its kernel in backtraces.").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 显示了更多信息！为了更好地理解这个输出，参见 [图 11-10](ch11.html#like_mricomma_rubinius_includes_informat
    "图 11-10. 像 MRI 一样，Rubinius 在回溯中包含程序信息") 和 [图 11-11](ch11.html#rubinius_includes_information_about_its
    "图 11-11. Rubinius 在回溯中包含其内核的信息")。
- en: At left in [Figure 11-10](ch11.html#like_mricomma_rubinius_includes_informat
    "Figure 11-10. Like MRI, Rubinius includes information about your program in backtraces.")
    is a simplified version of the backtrace information Rubinius displayed while
    running *iterate.rb*. Rubinius displays the two lines in the backtrace corresponding
    to *iterate.rb* just as MRI does. But Rubinius also includes new entries in the
    Ruby call stack that correspond to Ruby source code files inside the Rubinius
    kernel. We can guess that the *loader.rb* and *codeloader.rb* files contain code
    that load and execute our script.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-10](ch11.html#like_mricomma_rubinius_includes_informat "图 11-10. 像 MRI
    一样，Rubinius 在回溯中包含程序信息") 的左侧是 Rubinius 在运行 *iterate.rb* 时显示的回溯信息的简化版。Rubinius
    显示了与 *iterate.rb* 对应的两行回溯信息，正如 MRI 所做的那样。但 Rubinius 还在 Ruby 调用栈中包含了新的条目，这些条目对应于
    Rubinius 内核中的 Ruby 源代码文件。我们可以猜测，*loader.rb* 和 *codeloader.rb* 文件包含了加载和执行我们脚本的代码。
- en: '![Like MRI, Rubinius includes information about your program in backtraces.](httpatomoreillycomsourcenostarchimages1854335.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![像 MRI 一样，Rubinius 在回溯中包含程序信息。](httpatomoreillycomsourcenostarchimages1854335.png)'
- en: Figure 11-10. Like MRI, Rubinius includes information about your program in
    backtraces.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-10. 与 MRI 相似，Rubinius 在回溯中包含了你的程序信息。
- en: But the most interesting entry in the call stack is `kernel/common/integer.rb:83`.
    This entry tells us where the `Integer#times` method is implemented inside the
    Rubinius kernel, as shown in [Figure 11-11](ch11.html#rubinius_includes_information_about_its
    "Figure 11-11. Rubinius includes information about its kernel in backtraces.").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是调用栈中最有趣的条目是 `kernel/common/integer.rb:83`。这个条目告诉我们 `Integer#times` 方法在 Rubinius
    内核中的实现位置，如 [图 11-11](ch11.html#rubinius_includes_information_about_its "图 11-11.
    Rubinius 在回溯中包含其内核信息") 所示。
- en: '![Rubinius includes information about its kernel in backtraces.](httpatomoreillycomsourcenostarchimages1854337.png.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 在回溯中包含其内核信息。](httpatomoreillycomsourcenostarchimages1854337.png.jpg)'
- en: Figure 11-11. Rubinius includes information about its kernel in backtraces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-11. Rubinius 在回溯中包含其内核信息。
- en: The backtrace information on the left of the figure is the same as that in [Figure 11-10](ch11.html#like_mricomma_rubinius_includes_informat
    "Figure 11-10. Like MRI, Rubinius includes information about your program in backtraces.").
    The arrow points from the second level of the Ruby call stack to the code that
    calls the `puts n` block—the `yield` instruction in the `Integer#times` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图中左侧的回溯信息与 [图 11-10](ch11.html#like_mricomma_rubinius_includes_informat "图 11-10.
    与 MRI 相似，Rubinius 在回溯中包含了你的程序信息") 中的信息相同。箭头指向 Ruby 调用栈的第二级，指向调用 `puts n` 块的代码——`Integer#times`
    方法中的 `yield` 指令。
- en: 'Using Rubinius, *iterate.rb* becomes part of a larger Ruby program: the Rubinius
    kernel. When we call `10.times`, Rubinius calls the Ruby code shown at the right,
    which then executes our block using the `yield` keyword on line 83.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rubinius 时，*iterate.rb* 成为更大 Ruby 程序的一部分：Rubinius 内核。当我们调用 `10.times` 时，Rubinius
    调用右侧显示的 Ruby 代码，然后使用第 83 行的 `yield` 关键字执行我们的块。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The path* kernel/common/integer.rb *refers to a location in the Rubinius source
    code tree. If you installed Rubinius using a binary installer, you’ll need to
    download the source code from* [http://rubini.us/](http://rubini.us/) *or GitHub
    in order to read it.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径* kernel/common/integer.rb *指的是 Rubinius 源代码树中的一个位置。如果你是通过二进制安装程序安装 Rubinius，你需要从*
    [http://rubini.us/](http://rubini.us/) *或 GitHub 下载源代码，以便查看。*'
- en: Rubinius implements `Integer#times` by counting from 0 up to the specified integer
    (minus one), calling the block each time through the loop. Let’s take a closer
    look at `Integer#times`, as shown in [Example 11-7](ch11.html#rubinius_implementation_of_integerha
    "Example 11-7. The Rubinius implementation of Integer#times, from kernel/common/integer.rb").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 通过从 0 开始计数到指定的整数（减去 1），在每次循环中调用块来实现 `Integer#times`。让我们仔细看看 `Integer#times`，如
    [示例 11-7](ch11.html#rubinius_implementation_of_integerha "示例 11-7. Rubinius 实现
    Integer#times，来自 kernel/common/integer.rb") 所示。
- en: Example 11-7. *The Rubinius implementation of `Integer#times`, from* kernel/common/integer.rb
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-7. *来自* kernel/common/integer.rb 的 `Integer#times` 的 Rubinius 实现
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The definition of the `times` method starts at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) Rubinius returns
    the result of `to_enum` if a block is not provided, as shown below. (The `to_enum`
    method returns a new enumerator object, which allows you to perform the enumeration
    later if you prefer.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`times` 方法的定义从 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 开始。在
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处，如果没有提供块，Rubinius
    会返回 `to_enum` 的结果，如下所示。（`to_enum` 方法返回一个新的枚举器对象，允许你在以后需要时执行枚举。）'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rubinius continues to execute the rest of the method if you provide a block.
    At ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) Rubinius creates
    a counter `i` and initializes it to 0\. Next, it uses a while loop at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    to perform the iteration. Notice that the while loop condition `i < self` refers
    to the value of `self`. Inside `Integer#times`, `self` is set to the current integer
    object, or 10 in our script. At ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    Rubinius yields to (calls) the given block, passing in the current value of `i`.
    This calls our `puts n` block. Finally, at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    Rubinius returns `self`, which means the return value of `10.times` will be 10.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个块，Rubinius会继续执行方法的其余部分。 在![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)时，Rubinius创建了一个计数器`i`并将其初始化为0。接下来，它在![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)使用一个while循环来执行迭代。请注意，while循环条件`i
    < self`引用了`self`的值。在`Integer#times`内部，`self`设置为当前的整数对象，在我们的脚本中为10。 在![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)时，Rubinius将控制权传递给（调用）给定的块，传递当前的`i`值。这将调用我们的`puts
    n`块。最后，在![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)时，Rubinius返回`self`，这意味着`10.times`的返回值将是10。
- en: Arrays in Rubinius and MRI
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rubinius和MRI中的数组
- en: Arrays are so ubiquitous in Ruby that it’s easy to take them for granted. But
    how do they work inside Ruby? Where does Ruby save objects that you place into
    an array, and how does it represent array objects internally? In the following
    sections, we’ll look at the internal data structures that Rubinius and MRI use
    to hold values in an array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在Ruby中如此普遍，以至于我们容易理所当然地认为它们是理所当然的。但它们在Ruby内部是如何工作的呢？Ruby是如何保存你放入数组中的对象的，内部又是如何表示数组对象的呢？在接下来的章节中，我们将探讨Rubinius和MRI用于存储数组中值的内部数据结构。
- en: Arrays Inside of MRI
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MRI中的数组
- en: Suppose you put the first six numbers from the Fibonacci sequence into an array.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将斐波那契数列中的前六个数字放入一个数组中。
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As [Figure 11-12](ch11.html#mri_uses_the_rarray_c_structure_to_repre "Figure 11-12. MRI
    uses the RArray C structure to represent arrays.") illustrates, MRI creates a
    C structure for the array but saves its elements elsewhere.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图11-12](ch11.html#mri_uses_the_rarray_c_structure_to_repre "图11-12。MRI使用RArray
    C结构来表示数组。")所示，MRI为数组创建了一个C结构，但将其元素保存在其他地方。
- en: '![MRI uses the RArray C structure to represent arrays.](httpatomoreillycomsourcenostarchimages1854339.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![MRI使用RArray C结构来表示数组。](httpatomoreillycomsourcenostarchimages1854339.png.jpg)'
- en: Figure 11-12. MRI uses the `RArray` C structure to represent arrays.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-12。MRI使用`RArray` C结构来表示数组。
- en: MRI uses one `RArray` structure to represent each array you create. Like `RString`,
    `RObject`, and other C structures, `RArray` uses the inner `RBasic` structure
    to hold the `klass` pointer and other technical information. (In this case, the
    `klass` pointer points to the `RClass` structure for the `Array` class.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MRI使用一个`RArray`结构来表示你创建的每个数组。像`RString`、`RObject`和其他C结构一样，`RArray`使用内部的`RBasic`结构来保存`klass`指针和其他技术信息。（在这个例子中，`klass`指针指向`Array`类的`RClass`结构。）
- en: 'Below `RBasic` are a few additional values specific to arrays—`ptr`, `len`,
    and `capa`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RBasic`下方是一些特定于数组的附加值——`ptr`、`len`和`capa`：
- en: '`ptr` is a pointer to a memory segment Ruby allocates separately to store the
    array elements. The Fibonacci numbers appear in this memory segment at the right
    side of [Figure 11-12](ch11.html#mri_uses_the_rarray_c_structure_to_repre "Figure 11-12. MRI
    uses the RArray C structure to represent arrays.").'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptr`是指向Ruby单独分配的内存段的指针，用于存储数组元素。斐波那契数列出现在此内存段中，如[图11-12](ch11.html#mri_uses_the_rarray_c_structure_to_repre
    "图11-12。MRI使用RArray C结构来表示数组。")右侧所示。'
- en: '`len` is the length of the array—that is, the number of values saved in the
    separate memory segment.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`是数组的长度——即保存在独立内存段中的值的数量。'
- en: '`capa` tracks the capacity of the memory segment. This number is often larger
    than `len`. MRI avoids continually resizing the memory segment each time you change
    the size of the array; instead, as you add array elements, it occasionally increases
    the size of the separate memory segment, each time allocating more memory than
    the new elements require.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capa`跟踪内存段的容量。这个数字通常比`len`大。MRI避免在每次改变数组大小时不断调整内存段的大小；相反，当你添加数组元素时，它偶尔会增加独立内存段的大小，每次分配比新元素所需的更多内存。'
- en: Each value in the separate memory segment is actually a `VALUE` pointer to a
    Ruby object. In this case, the Fibonacci numbers would be saved directly inside
    the `VALUE` pointers because they are simple integers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 单独内存段中的每个值实际上是一个指向 Ruby 对象的 `VALUE` 指针。在这种情况下，斐波那契数列将直接保存在 `VALUE` 指针中，因为它们是简单的整数。
- en: The RArray C Structure Definition
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: RArray C 结构体定义
- en: '[Example 11-8](ch11.html#definition_of_rarray_left_parenthesi "Example 11-8. The
    definition of RArray (from include/ruby/ruby.h)") shows the definition of `RArray`
    from the MRI C source code.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-8](ch11.html#definition_of_rarray_left_parenthesi "示例 11-8. `RArray`
    的定义（来自 include/ruby/ruby.h）") 展示了来自 MRI C 源代码的 `RArray` 定义。'
- en: Example 11-8. *The definition of `RArray` (from* include/ruby/ruby.h*)*
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-8. *`RArray` 的定义（来自* include/ruby/ruby.h*)*
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This definition shows a few values that are missing from [Figure 11-12](ch11.html#mri_uses_the_rarray_c_structure_to_repre
    "Figure 11-12. MRI uses the RArray C structure to represent arrays."). First,
    at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg), notice that MRI
    uses a C `union` keyword to declare two alternative definitions for `RArray`.
    The first, an inner `struct`, defines `len` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg),
    `capa` at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg), `shared`
    at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg), and `ptr` at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg).
    As with strings, MRI uses copy-on-write optimization with arrays, allowing two
    or more arrays to share the same underlying data. For arrays that share data,
    the `shared` value at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    refers to another `RArray` that contains the shared data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义展示了 [图 11-12](ch11.html#mri_uses_the_rarray_c_structure_to_repre "图 11-12.
    MRI 使用 RArray C 结构来表示数组。") 中缺失的一些值。首先，在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，请注意，MRI
    使用 C `union` 关键字声明 `RArray` 的两个备选定义。第一个，是一个内部的 `struct`，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    定义了 `len`，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) 定义了 `capa`，在
    ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) 定义了 `shared`，在 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    定义了 `ptr`。与字符串类似，MRI 使用写时复制优化来处理数组，使得两个或更多数组可以共享相同的底层数据。对于共享数据的数组，位于 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    的 `shared` 值指向另一个包含共享数据的 `RArray`。
- en: 'The second half of the union at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    defines `ary`, a C array of `VALUE` pointers in `RArray`. This is an optimization
    that allows MRI to save the array data for arrays with three or fewer elements
    inside the `RArray` structure itself, avoiding the need to allocate the separate
    memory segment at all. MRI optimizes four other C structures in a similar way:
    `RString`, `RObject`, `RStruct` (used by the `Struct` class), and `RBignum` (used
    by the `Bignum` class).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体的后半部分在 ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg) 定义了 `ary`，这是
    `RArray` 中一个 `VALUE` 指针的 C 数组。这是一个优化，允许 MRI 将包含三项或更少元素的数组数据直接保存在 `RArray` 结构中，从而避免了为其分配单独的内存段。MRI
    以类似的方式优化了其他四个 C 结构体：`RString`、`RObject`、`RStruct`（由 `Struct` 类使用）和 `RBignum`（由
    `Bignum` 类使用）。
- en: Arrays Inside of Rubinius
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rubinius 内部的数组
- en: Now let’s see how Rubinius saves the same Fibonacci array internally. We learned
    earlier that Rubinius represents each Ruby object with a corresponding C++ object.
    This representation is true of arrays as well. For example, [Figure 11-13](ch11.html#rubinius_uses_cplusplus_objects_to_repre
    "Figure 11-13. Rubinius uses C++ objects to represent arrays.") shows the C++
    object that Rubinius would use to represent `fibonacci_sequence`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 Rubinius 如何在内部保存相同的斐波那契数组。我们之前学到，Rubinius 使用相应的 C++ 对象来表示每个 Ruby 对象。这种表示方式同样适用于数组。例如，[图
    11-13](ch11.html#rubinius_uses_cplusplus_objects_to_repre "图 11-13. Rubinius 使用
    C++ 对象来表示数组。") 展示了 Rubinius 用于表示 `fibonacci_sequence` 的 C++ 对象。
- en: '![Rubinius uses C++ objects to represent arrays.](httpatomoreillycomsourcenostarchimages1854341.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 使用 C++ 对象来表示数组。](httpatomoreillycomsourcenostarchimages1854341.png)'
- en: Figure 11-13. Rubinius uses C++ objects to represent arrays.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-13. Rubinius 使用 C++ 对象来表示数组。
- en: 'The combined four blocks represent an instance of the `Array` C++ class. Rubinius
    creates a C++ array object each time you create an array. From left to right,
    the fields are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 四个组合块代表了 `Array` C++ 类的一个实例。每当你创建一个数组时，Rubinius 会创建一个 C++ 数组对象。从左到右，字段如下：
- en: '`ObjectHeader` contains technical information that Rubinius keeps track of
    inside each object, including a class pointer and an array of instance variables.
    `ObjectHeader` corresponds to the `RBasic` C structure in MRI and is one of the
    C++ superclasses of the `Array` C++ class inside the Rubinius virtual machine.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectHeader` 包含 Rubinius 在每个对象内部跟踪的技术信息，包括类指针和实例变量数组。`ObjectHeader` 对应于 MRI
    中的 `RBasic` C 结构，并且是 Rubinius 虚拟机内 `Array` C++ 类的 C++ 超类之一。'
- en: '`total_` is the length of the array, which is 6 for `fibonacci_sequence`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total_` 是数组的长度，对于 `fibonacci_sequence` 来说，长度为 6。'
- en: '`tuple_` is a pointer to an instance of another C++ class, called `Tuple`,
    that contains the array data.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple_` 是指向另一个 C++ 类实例的指针，该类名为 `Tuple`，其中包含数组数据。'
- en: '`start_` indicates where the array data starts inside the tuple object. (The
    tuple may contain more data than your array needs.) Initially, Rubinius sets this
    to 0.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_` 表示元组对象内部数组数据的起始位置。（元组可能包含比数组所需更多的数据。）最初，Rubinius 将其设置为 0。'
- en: Rubinius doesn’t save the array data in the C++ array object. It saves it in
    a tuple object, as shown in [Figure 11-14](ch11.html#rubinius_saves_array_data_in_tuple_objec
    "Figure 11-14. Rubinius saves array data in tuple objects.").
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Rubinius 并不将数组数据保存在 C++ 数组对象中。它将数据保存在元组对象中，如 [图 11-14](ch11.html#rubinius_saves_array_data_in_tuple_objec
    "图 11-14. Rubinius 将数组数据保存在元组对象中。") 所示。
- en: '![Rubinius saves array data in tuple objects.](httpatomoreillycomsourcenostarchimages1854343.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Rubinius 将数组数据保存在元组对象中。](httpatomoreillycomsourcenostarchimages1854343.png)'
- en: Figure 11-14. Rubinius saves array data in tuple objects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-14. Rubinius 将数组数据保存在元组对象中。
- en: Each tuple contains the same object header information as arrays. Rubinius saves
    this header information in every C++ object. Following the object header, tuple
    objects contain a value called `full_size_`, which keeps track of the size of
    this tuple object in bytes. Following this value, Rubinius saves the actual data
    values in a C++ array called `fields`. These data values are our six Fibonacci
    numbers, as shown at the right of [Figure 11-14](ch11.html#rubinius_saves_array_data_in_tuple_objec
    "Figure 11-14. Rubinius saves array data in tuple objects.").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元组都包含与数组相同的对象头信息。Rubinius 会在每个 C++ 对象中保存此头信息。在对象头之后，元组对象包含一个名为 `full_size_`
    的值，用于跟踪该元组对象的字节大小。紧接着这个值，Rubinius 将实际的数据值保存在一个名为 `fields` 的 C++ 数组中。这些数据值就是我们的六个斐波那契数，如
    [图 11-14](ch11.html#rubinius_saves_array_data_in_tuple_objec "图 11-14. Rubinius
    将数组数据保存在元组对象中。") 右侧所示。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Array data values are saved in the tuple C++ object. If we had created a larger
    array, Rubinius would have used a larger tuple object. If we change the size of
    an array, Rubinius allocates another tuple of the appropriate size or, as we’ll
    see in [Experiment 11-2: Exploring the Rubinius Implementation of Array#shift](ch11.html#experiment_11-2_exploring_the_rubinius_i
    "Experiment 11-2: Exploring the Rubinius Implementation of Array#shift"), it can
    optimize certain array methods in order to avoid allocating new objects and speed
    up your program.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组数据值保存在元组 C++ 对象中。如果我们创建了一个更大的数组，Rubinius 将使用更大的元组对象。如果我们更改数组的大小，Rubinius
    会分配一个适当大小的新元组，或者正如我们将在 [实验 11-2：探索 Rubinius 实现的 Array#shift](ch11.html#experiment_11-2_exploring_the_rubinius_i
    "实验 11-2：探索 Rubinius 实现的 Array#shift") 中看到的那样，它可以优化某些数组方法，以避免分配新的对象并加速程序。*'
- en: 'Experiment 11-2: Exploring the Rubinius Implementation of Array#shift'
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 11-2：探索 Rubinius 实现的 Array#shift
- en: We’ve seen that Rubinius uses C++ objects to represent arrays, but remember
    that Rubinius uses a combination of Ruby and C++ code to implement methods in
    the `Array` class. In this experiment, we’ll learn more about how arrays work
    by looking at how Rubinius implements the `Array#shift` method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Rubinius 使用 C++ 对象表示数组，但请记住，Rubinius 结合了 Ruby 和 C++ 代码来实现 `Array` 类中的方法。在这个实验中，我们将通过观察
    Rubinius 如何实现 `Array#shift` 方法来更深入地了解数组的工作原理。
- en: But first a quick review of what `Array#shift` does. As you may know, calling
    `shift` removes one element from the beginning of an array and *shifts* the remaining
    elements to the left, as shown in [Example 11-9](ch11.html#arrayhashshift_removes_the_first_element
    "Example 11-9. Array#shift removes the first element from an array, shifting the
    remaining elements over.").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，快速回顾一下 `Array#shift` 的作用。正如你所知，调用 `shift` 会从数组的开头移除一个元素，并且将剩余的元素向左*移动*，如
    [示例 11-9](ch11.html#arrayhashshift_removes_the_first_element "示例 11-9. Array#shift
    从数组中移除第一个元素，向左移动其余元素。") 所示。
- en: Example 11-9. `Array#shift` removes the first element from an array, shifting
    the remaining elements over.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-9. `Array#shift` 从数组中移除第一个元素，并将剩余的元素向左移动。
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) `Array#shift`
    returns the first element of `fibonacci_sequence`. We can see from the output
    at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) that `Array#shift`
    also removes the first element from the array, shifting the other five elements.
    But how does Ruby implement `Array#shift` internally? Does it actually copy the
    remaining array elements to the left, or does it copy them into a new array?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) `Array#shift` 返回
    `fibonacci_sequence` 的第一个元素。从 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    的输出中可以看到，`Array#shift` 还会移除数组中的第一个元素，并将剩余的五个元素向左移动。但 Ruby 是如何在内部实现 `Array#shift`
    的呢？它是否真的将剩余的数组元素向左复制，还是将它们复制到一个新数组中？
- en: Reading Array#shift
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读 `Array#shift`
- en: 'First, let’s find out where the `Array#shift` method is located inside Rubinius.
    Because we don’t have a backtrace to refer to as in [Experiment 11-1: Comparing
    Backtraces in MRI and Rubinius](ch11.html#experiment_11-1_comparing_backtraces_in
    "Experiment 11-1: Comparing Backtraces in MRI and Rubinius"), we can ask Rubinius
    where to find the method using `source_location`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找出 `Array#shift` 方法在 Rubinius 中的位置。因为我们没有像[实验 11-1：比较 MRI 和 Rubinius 中的回溯](ch11.html#experiment_11-1_comparing_backtraces_in
    "实验 11-1：比较 MRI 和 Rubinius 中的回溯")那样可以参考的回溯信息，我们可以使用 `source_location` 来询问 Rubinius
    方法的位置。
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This output tells us that Rubinius defines the `Array#shift` method at line
    848 in the file *kernel/common/array.rb* in the Rubinius source tree. [Example 11-10](ch11.html#implementation_of_arrayhashshift_ins
    "Example 11-10. The implementation of Array#shift inside the Rubinius kernel")
    shows the Rubinius implementation of `Array#shift`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出告诉我们，Rubinius 在源代码树中的 `*kernel/common/array.rb*` 文件的第 848 行定义了 `Array#shift`
    方法。[示例 11-10](ch11.html#implementation_of_arrayhashshift_ins "示例 11-10. Rubinius
    内核中 `Array#shift` 的实现") 显示了 `Array#shift` 在 Rubinius 中的实现。
- en: Example 11-10. The implementation of `Array#shift` inside the Rubinius kernel
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-10. `Array#shift` 在 Rubinius 内核中的实现
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) `shift` takes
    an optional parameter `n`. If `shift` is called without a parameter `n`, as in
    [Example 11-9](ch11.html#arrayhashshift_removes_the_first_element "Example 11-9. Array#shift
    removes the first element from an array, shifting the remaining elements over."),
    it will remove the first element and shift the remaining elements by one position.
    If you provide a parameter `n` to `shift`, it will remove `n` elements and shift
    the remaining elements `n` positions to the left. At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    Rubinius checks whether the parameter `n` was supplied. If `n` was specified,
    it jumps to ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) and uses
    `Array#slice!` to remove the first `n` elements and return them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) `shift` 方法接受一个可选参数
    `n`。如果 `shift` 方法在没有参数 `n` 的情况下被调用，如在[示例 11-9](ch11.html#arrayhashshift_removes_the_first_element
    "示例 11-9. `Array#shift` 从数组中移除第一个元素，并将剩余的元素向左移动。")中所示，它将移除第一个元素并将剩余元素向左移动一个位置。如果你向
    `shift` 提供参数 `n`，它将移除 `n` 个元素，并将剩余元素向左移动 `n` 个位置。在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    中，Rubinius 会检查是否提供了参数 `n`。如果指定了 `n`，它将跳转到 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    并使用 `Array#slice!` 来移除前 `n` 个元素并返回它们。
- en: Modifying Array#shift
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 `Array#shift`
- en: Now let’s see what happens when you call `shift` with no parameters. How does
    Rubinius shift the array by one element? Unfortunately, the `Tuple#at` method
    called at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) is implemented
    by the C++ code inside the Rubinius virtual machine. (You won’t find a definition
    for `at` in the Ruby *kernel/common/tuple.rb* file.) This means we won’t be able
    to read the entire algorithm in Ruby.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当你不提供任何参数调用 `shift` 时会发生什么。Rubinius 如何将数组向左移动一个元素呢？不幸的是，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    调用的 `Tuple#at` 方法是由 Rubinius 虚拟机中的 C++ 代码实现的。（你在 Ruby 的 `*kernel/common/tuple.rb*`
    文件中找不到 `at` 的定义。）这意味着我们无法用 Ruby 阅读整个算法。
- en: We can, however, add Ruby code to Rubinius to display information about the
    array data when we call `shift`. Because the Rubinius kernel is written with Ruby,
    we can change it like any other Ruby program! First, we’ll add a few lines of
    code to `Array#shift`, as shown in [Example 11-11](ch11.html#adding_debug_code_to_the_rubinius_kernel
    "Example 11-11. Adding debug code to the Rubinius kernel").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，我们可以向Rubinius中添加Ruby代码，当我们调用`shift`时显示有关数组数据的信息。由于Rubinius内核是用Ruby编写的，我们可以像修改任何其他Ruby程序一样修改它！首先，我们将向`Array#shift`添加几行代码，如[示例11-11](ch11.html#adding_debug_code_to_the_rubinius_kernel
    "示例11-11. 向Rubinius内核添加调试代码")所示。  '
- en: Example 11-11. Adding debug code to the Rubinius kernel
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11-11. 向Rubinius内核添加调试代码
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we check whether
    this array is our Fibonacci array. Rubinius uses this method for every array in
    the system, but we want to display only information about our array. Then, at
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) we display the values
    of `@start`, `@total`, and `@tuple`. Under the hood, `@tuple` is a C++ object,
    but in Rubinius it also functions as a Ruby object, allowing us to call its `inspect`
    method. At ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) we display
    the same values once they’ve been changed by the `Array#shift` code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，我们检查这个数组是否是我们的斐波那契数组。Rubinius使用这种方法来处理系统中的每个数组，但我们只想显示有关我们数组的信息。然后，在![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，我们显示`@start`、`@total`和`@tuple`的值。底层，`@tuple`是一个C++对象，但在Rubinius中它也充当Ruby对象，允许我们调用其`inspect`方法。在![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)，我们显示了被`Array#shift`代码更改后的相同值。  '
- en: Now we need to rebuild Rubinius to include our code changes. [Example 11-12](ch11.html#rebuilding_rubinius
    "Example 11-12. Rebuilding Rubinius") shows the output produced by the `rake install`
    command. (Run this at the root of the Rubinius source code tree.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们需要重新构建Rubinius以包括我们的代码更改。[示例11-12](ch11.html#rebuilding_rubinius "示例11-12. 重新构建Rubinius")展示了通过`rake
    install`命令生成的输出。（在Rubinius源代码树的根目录下运行此命令。）  '
- en: Example 11-12. Rebuilding Rubinius
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '示例11-12. 重新构建Rubinius  '
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Rubinius build process recompiled the *array.rb* source code file at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    along with many other kernel files. (`RBC` refers to the Rubinius compiler.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rubinius构建过程重新编译了*array.rb*源代码文件，位于![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，以及其他许多内核文件。（`RBC`指的是Rubinius编译器。）  '
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '注意  '
- en: '*Don’t try to use this sort of code change in a production environment.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要在生产环境中尝试使用这种代码更改。*  '
- en: Now to rerun [Example 11-9](ch11.html#arrayhashshift_removes_the_first_element
    "Example 11-9. Array#shift removes the first element from an array, shifting the
    remaining elements over.") using our modified version of Rubinius. [Example 11-13](ch11.html#using_our_modified_version_of_arrayhashs
    "Example 11-13. Using our modified version of Array#shift") shows the output interspersed
    with our original code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，使用我们修改过的Rubinius版本重新运行[示例11-9](ch11.html#arrayhashshift_removes_the_first_element
    "示例11-9. Array#shift从数组中移除第一个元素，并将剩余的元素向左移动。")。 [示例11-13](ch11.html#using_our_modified_version_of_arrayhashs
    "示例11-13. 使用我们修改过的`Array#shift`版本")显示了与我们原始代码交替的输出。  '
- en: Example 11-13. Using our modified version of `Array#shift`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '示例11-13. 使用我们修改过的`Array#shift`  '
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) and ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    our new Ruby code inside `Array#shift` displays the internal contents of `fibonacci_sequence`:
    the `@start`, `@total`, and `@tuple` instance variables. Comparing ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    with ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg), we can see how
    `Array#shift` works internally. Rubinius hasn’t allocated a new array object;
    it’s reused the underlying tuple object. Rubinius has done the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)和![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，我们在`Array#shift`中的新Ruby代码展示了`fibonacci_sequence`的内部内容：`@start`、`@total`和`@tuple`实例变量。比较![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)和![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)，我们可以看到`Array#shift`的内部工作原理。Rubinius并没有分配一个新的数组对象，而是重用了底层的元组对象。Rubinius做了以下操作：  '
- en: Changed `@total` from 6 to 5 because the length of the array has decreased by
    1
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`@total`从6改为5，因为数组的长度减少了1  '
- en: Changed `@start` from 0 to 1, which allowed it to continue to use the same value
    for `@tuple`; now the array contents start at the second value (index 1) in `@tuple`,
    not the first (index 0)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`@start`从0改为1，这使得它能够继续使用相同的`@tuple`值；现在数组内容从`@tuple`中的第二个值（索引1）开始，而不是第一个值（索引0）  '
- en: Changed the first value in `@tuple` from 1 to `nil` because the first value
    is no longer used by the array
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `@tuple` 中的第一个值从 1 改为 `nil`，因为数组不再使用这个第一个值
- en: Creating new objects and allocating new memory can take a long time because
    Rubinius might have to ask for memory from the operating system. Its reuse of
    the underlying data in the tuple object, without copying or allocating memory
    for a new array, allows Rubinius to run faster.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新对象并分配新内存可能需要很长时间，因为 Rubinius 可能需要向操作系统请求内存。它对元组对象中底层数据的重用，而不是复制或为新数组分配内存，使得
    Rubinius 的运行速度更快。
- en: '[Figure 11-15](ch11.html#tuple_holding_our_fibonacci_numbers "Figure 11-15. The
    tuple holding our Fibonacci numbers before calling Array#shift") and [Figure 11-16](ch11.html#same_tuple_after_calling_arrayhashsh
    "Figure 11-16. The same tuple after calling Array#shift") summarize how `Array#shift`
    works. [Figure 11-15](ch11.html#tuple_holding_our_fibonacci_numbers "Figure 11-15. The
    tuple holding our Fibonacci numbers before calling Array#shift") shows the array
    before calling `Array#shift`: `@start` pointed to the first value in the tuple,
    and `@length` was 6.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-15](ch11.html#tuple_holding_our_fibonacci_numbers "图 11-15. 调用 Array#shift
    前保存斐波那契数的元组") 和 [图 11-16](ch11.html#same_tuple_after_calling_arrayhashsh "图 11-16.
    调用 Array#shift 后相同的元组") 总结了 `Array#shift` 的工作原理。[图 11-15](ch11.html#tuple_holding_our_fibonacci_numbers
    "图 11-15. 调用 Array#shift 前保存斐波那契数的元组") 显示了调用 `Array#shift` 前的数组：`@start` 指向元组中的第一个值，`@length`
    为 6。'
- en: '![The tuple holding our Fibonacci numbers before calling Array#shift](httpatomoreillycomsourcenostarchimages1854345.png.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![调用 Array#shift 前保存斐波那契数的元组](httpatomoreillycomsourcenostarchimages1854345.png.jpg)'
- en: Figure 11-15. The tuple holding our Fibonacci numbers before calling `Array#shift`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-15. 调用 `Array#shift` 前保存斐波那契数的元组
- en: '[Figure 11-16](ch11.html#same_tuple_after_calling_arrayhashsh "Figure 11-16. The
    same tuple after calling Array#shift") shows the tuple after calling `Array#shift`;
    Rubinius has simply changed the values of `@start` and `@length` and set the first
    value in the tuple to `nil`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-16](ch11.html#same_tuple_after_calling_arrayhashsh "图 11-16. 调用 Array#shift
    后相同的元组") 显示了调用 `Array#shift` 后的元组；Rubinius 仅仅更改了 `@start` 和 `@length` 的值，并将元组中的第一个值设为
    `nil`。'
- en: '![The same tuple after calling Array#shift](httpatomoreillycomsourcenostarchimages1854347.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![调用 Array#shift 后相同的元组](httpatomoreillycomsourcenostarchimages1854347.png)'
- en: Figure 11-16. The same tuple after calling `Array#shift`
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-16. 调用 `Array#shift` 后相同的元组
- en: As you might guess, MRI uses a similar optimization for `Array#shift` by keeping
    track of where the array data starts in the original array. However, the C code
    it uses is more complex and difficult to understand. The Rubinius kernel gives
    us a much clearer view of this algorithm.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测，MRI 通过跟踪数组数据在原始数组中的起始位置来对 `Array#shift` 进行类似的优化。然而，它使用的 C 代码更复杂且更难理解。Rubinius
    内核为我们提供了更清晰的算法视图。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve learned in this chapter that Rubinius uses a virtual machine implemented
    with C++ to run your Ruby code. Like YARV, the Rubinius virtual machine was custom
    designed to run Ruby programs, and it uses a compiler to convert your Ruby program
    into bytecode internally. We saw that these Rubinius instructions resemble YARV
    instructions; they operate on stack values in a similar way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中了解到，Rubinius 使用一个用 C++ 实现的虚拟机来运行你的 Ruby 代码。像 YARV 一样，Rubinius 虚拟机是专门设计来运行
    Ruby 程序的，它使用一个编译器将 Ruby 程序转换为字节码。我们看到，这些 Rubinius 指令类似于 YARV 指令；它们以类似的方式操作栈值。
- en: But what sets Rubinius apart from other Ruby implementations is its Ruby language
    kernel. The Rubinius kernel implements many built-in Ruby classes, such as `Array`,
    using Ruby code. This innovative design provides a window into Ruby internals`—you`
    can use Rubinius to learn how Ruby works internally without having to know C or
    Java. You can learn how Ruby implements strings, arrays, or other classes simply
    by reading the Ruby source code in the Rubinius kernel. Rubinius isn’t just a
    Ruby implementation; it’s a valuable learning resource for the Ruby community.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但与其他 Ruby 实现不同，Rubinius 的独特之处在于其 Ruby 语言内核。Rubinius 内核使用 Ruby 代码实现了许多内置的 Ruby
    类，例如 `Array`。这一创新设计提供了一个探索 Ruby 内部机制的窗口——你可以通过使用 Rubinius 学习 Ruby 如何在内部工作，而无需了解
    C 或 Java。你可以通过阅读 Rubinius 内核中的 Ruby 源代码，了解 Ruby 如何实现字符串、数组或其他类。Rubinius 不仅仅是一个
    Ruby 实现；它是 Ruby 社区一个宝贵的学习资源。
