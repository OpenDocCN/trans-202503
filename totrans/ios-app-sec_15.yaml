- en: '**12**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**INJECTION ATTACKS**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll discuss types of injection attacks, many of which apply
    both to iOS client applications and to their remote endpoints or APIs. While a
    thorough examination of all potential server-side flaws is outside the scope of
    this book, this chapter will give you an idea of how an iOS app and its complementary
    endpoint or web app can work together to prevent security flaws.
  prefs: []
  type: TYPE_NORMAL
- en: Injection attacks are standard for web applications, but client-side injection
    attacks are less common and go largely unnoticed by developers and security engineers.
    Client-side injection attacks happen when remotely supplied data is parsed by
    the program running on the device. The most notable examples of this are cross-site
    scripting, SQL injection, predicate injection, and XML injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Side Cross-Site Scripting**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Cross-site scripting (XSS)* is an issue most often found in web applications,
    but JavaScript can be injected into the content used by iOS applications, too.
    One prominent app reported to have an XSS vulnerability was the Skype mobile application.
    As security researcher Phil Purviance described on his Superevr blog, at the time,
    the app used a `UIWebView` to render content.^([1](footnote.html#fn105)) The full
    name of the remote user was not sanitized before display, which allowed an attacker
    to insert a malicious script into a remote user’s application by embedding the
    script in their username. In this case, the attack could steal sensitive data
    (the contents of the Address Book) from the device. Such attacks can also be used
    to, say, insert a fake login page that submits credentials to an attacker-controlled
    domain.'
  prefs: []
  type: TYPE_NORMAL
- en: If your application uses a `UIWebView`, then to avoid XSS vulnerability, be
    particularly vigilant that you don’t take any unsanitized user-supplied data from
    the server or other external sources and integrate it into the user interface.
    You can do this most effectively with a two-part approach, using both *input sanitization*
    and *output encoding*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Input Sanitization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Input sanitization involves stripping potentially harmful characters from external
    inputs, using either a *blacklist* or *whitelist* approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Blacklisting Bad Input**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a blacklist, you try to list every character that could cause a security
    problem if accepted as input and give that list to your application. Then, you
    write your application to either remove unacceptable characters or throw an error
    when they appear.
  prefs: []
  type: TYPE_NORMAL
- en: Blacklisting is a fragile approach, and it’s rarely effective. You need to know
    every conceivable way data could cause trouble, including every type of character
    encoding, every JavaScript event handler or SQL special character, and so on.
    For example, you might simply add `<` and `>` to a blacklist in hopes of preventing
    XSS via `<script>` tags, but you’re ignoring attacks that can be accomplished
    with only double quotes, parentheses, and an equal sign.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if your app or an app you’re testing relies on blacklisting characters,
    investigate whether the blacklist might be masking an underlying flaw. Such filters
    can be easily bypassed, and an app that relies on this technique probably also
    lacks effective output encoding, which I’ll discuss in “[Output Encoding](ch12.html#ch12lev2sec02)”
    on [page 201](ch12.html#page_201).
  prefs: []
  type: TYPE_NORMAL
- en: '**Whitelisting Allowable Input**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In a whitelist approach, you instead explicitly define the characters that
    are acceptable for a particular user input. Whitelisting is preferable to blacklisting
    because comprehensively specifying what characters should be allowed is easier
    than speculating about what might be bad. In a whitelist approach, you might define
    the characters that a phone number field should allow: 0 through 9 and possibly
    dashes and parentheses. Not only does this preclude most any malicious input,
    but it also keeps data clean in your database.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Balance**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s possible to be misguidedly zealous about input sanitization with either
    blacklisting or whitelisting. Some programs and websites actually disallow legitimate
    characters in some inputs (most notably, user passwords). You may have run across
    an app or site that refuses to accept a password containing special characters
    (such as `!`, `<`, `>`, `'`, or `;`). This is often an indication that the programmers
    are handling data on the backend in a remarkably incompetent way.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an application strips apostrophes or semicolons, the developers
    may not be using parameterized SQL statements, instead relying on removing “bad”
    special characters to prevent SQL injection. But this blacklisting of suspected
    bad characters just reduces user password complexity, and it’s unlikely to solve
    the problem of SQL injection in any comprehensive fashion.
  prefs: []
  type: TYPE_NORMAL
- en: For input sanitization to work correctly, it also needs to happen as close as
    possible to the point before the data is processed or stored. For example, when
    an iOS application talks to a remote API, the application can certainly try to
    strip out harmful characters or restrict input to a certain character range. This
    is fine, but it *only* results in increased usability for the user. The user can
    see immediately that their input won’t be accepted, rather than waiting until
    they fill out all the form data and try to submit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your typical users may appreciate that side effect, but there’s a problem here:
    the user controls the device and, ultimately, how your program behaves. If your
    UI won’t allow certain values as input, all an attacker needs to do is route the
    device’s traffic through a proxy, as I described in “[Network and Proxy Setup](ch04.html#ch04lev1sec04)”
    on [page 43](ch04.html#page_43). The user can then modify data after it leaves
    the app but before it reaches the server and add the harmful characters back.'
  prefs: []
  type: TYPE_NORMAL
- en: To counter this possibility, never trust a mobile app to supply good data. In
    a client-server app, always ensure that sanitization happens on the server.
  prefs: []
  type: TYPE_NORMAL
- en: With sane input sanitization in place, you should move on to encoding your output.
  prefs: []
  type: TYPE_NORMAL
- en: '***Output Encoding***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output encoding, sometimes known as HTML entity encoding, is the process of
    taking user input and replacing characters with their HTML representations. This
    process is necessary for any potentially untrusted data that might end up rendered
    in a WebView. For example, the characters `<` and `>` would be translated to `&lt;`
    and `&gt;`, respectively. When data is displayed to the user, those characters
    should appear in the UI as `<` and `>`, but because they’ve been encoded, the
    HTML engine doesn’t process them as metacharacters, which might be used in a `<script>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Output encoding is the last and most potent line of defense before delivering
    HTML that contains third-party input to a client. Even if you totally neglected
    to strip potentially harmful metacharacters during input sanitization, as long
    as you encode your output, you don’t have to worry about whether the data you
    send will be executed by the browser rather than just displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying Untrusted Data**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like input sanitization, output encoding is usually a process you should perform
    on the server side, not the client. But if you have to display data from domains
    outside your control that contain untrusted data, you’ll want to perform HTML
    entity encoding before displaying content to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google Toolbox for Mac includes two category methods of `NSString` that you
    could use to encode HTML entities on the client side: `gtm_string-ByEscapingForHTML`
    and `gtm_stringByEscapingForAsciiHTML`.^([2](footnote.html#fn106)) Including Google’s
    category for `NSString` in your project makes it so you can simply call a method
    on any `NSString` object to have it return an encoded representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After this escaping, `escaped` should contain the `NSString Meet &amp; greet`,
    which should be safe to render within HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t Over-Encode**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As with input sanitization, be careful not to get carried away with output encoding.
    Some applications entity-encode received characters before sending them to a server
    or storing them in a database and then end up reencoding the encoded data. You
    may have seen the results in mobile apps or web apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I once saw an application display a banner inviting me to “Meet
    &amp; greet.” In the underlying HTML source, this data would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The original input was already encoded (to `&amp;`) and would have rendered
    fine as `&` in the browser. Encoding it again causes it to show up as `&amp;`
    to the user. This doesn’t create a security problem, but it can cause your data
    to become messy and hard to deal with. Just remember that there’s a reason the
    technique is called *output encoding*: it needs to be done just before output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Injection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Client-side SQL injection results from parsing externally supplied data that
    injects valid SQL into a badly formed SQL statement. Statements that are constructed
    dynamically on execution, using unsanitized, externally supplied input, are vulnerable
    to SQL injection. Malicious input will contain SQL metacharacters and statements
    that subvert the intent of the original query.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a simple status message is posted to a website by a user.
    It then gets downloaded and added to a local data store. If the user posting the
    original content has basic security knowledge and malicious intent, the user could
    embed SQL into the message, which will be executed when parsed by the SQL engine.
    This malicious SQL could destroy or modify existing data in the data store.
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, the most commonly used SQL API is SQLite. [Listing 12-1](ch12.html#ch12ex1)
    shows an example of an incorrectly formed, dynamically constructed SQL statement
    for SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: An unparameterized SQL statement vulnerable to SQL injection*'
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the `uid` value is being taken from user-supplied input
    and inserted as is into a SQL statement using a format string. Any SQL in the
    user-supplied parameter will then become part of that statement when it ultimately
    gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent SQL injection, simply use parameterized statements to avoid the dynamic
    construction of SQL statements in the first place. Instead of constructing the
    statement dynamically and passing it to the SQL parser, a parameterized statement
    causes the statement to be evaluated and compiled independently of the parameters.
    The parameters themselves are supplied to the compiled statement upon execution.
  prefs: []
  type: TYPE_NORMAL
- en: Using parameterized statements, the correct way to structure the query in [Listing
    12-1](ch12.html#ch12ex1) is to use `?` as a placeholder character for the supplied
    parameter, as in [Listing 12-2](ch12.html#ch12ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: A properly parameterized SQL statement*'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL statement is constructed with the `?` placeholder at ➊. The code then
    compiles the SQL statement with `sqlite3_prepare_v2` at ➋ and lastly binds the
    user-supplied `uid` using `sqlite3_bind_int` at ➌. Since the SQL statement has
    already been constructed, no additional SQL provided in the `uid` parameter will
    be added to the SQL itself; it’s simply passed in by value.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to preventing SQL injection, using parameterized, prepared statements
    will improve application performance under most circumstances. You should use
    them for all SQL statements, even if a statement isn’t taking input from untrusted
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: '**Predicate Injection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Predicates* let you perform logical comparisons between data using a basic
    query language not dissimilar to SQL. In a basic `NSPredicate`, values are compared
    or filtered using format strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At ➊, an array of various types of fruit is created; this array will be the
    data source to evaluate against an expression. When creating a predicate at ➋,
    a query is created that checks whether the string `"Grape"` is contained in the
    item the predicate is being compared to. (The `[c]` makes this comparison case
    insensitive.) When a new array is instantiated at ➌ to contain the results of
    this comparison, the `filteredArrayUsingPredicate` method of the `fruit` array
    is used to pass in the predicate. The resulting `grapethings` array should now
    contain both `"Grape"` and `"grapefruit"`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good! But a few things can go wrong when you build a predicate query
    using externally supplied data. First, consider the case where a predicate is
    built using SQL’s `LIKE` operator, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example evaluates a PIN, perhaps a secondary form of authentication for
    my application. But the `LIKE` operator performs the evaluation, which means a
    simple entry of the wildcard character ([*]) from a user will cause the predicate
    to evaluate to true, effectively bypassing PIN protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This result may seem obvious to those familiar with SQL injection (since SQL
    also has a `LIKE` operator), but consider the more subtle case where you’re examining
    code that uses the predicate `MATCHES` operator, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code has the same issue as the `LIKE` example, but rather than just accepting
    wildcards, `MATCHES` expects a regular expression. Therefore, using `.*` as your
    PIN will be enough to bypass validation.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent predicate injection attacks, examine all uses of `NSPredicate` in
    your code and make sure that the operators being used make sense for the application.
    It’s also probably a good idea to limit the characters that are allowed in user-supplied
    data that gets passed to a predicate to ensure that characters like wildcards
    don’t get plugged in. Or, simply don’t use a predicate for security-sensitive
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**XML Injection**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: XML injection occurs when malicious XML is parsed by an XML parser instance.
    Typically, this type of attack is used to force an application to load external
    resources over the network or consume system resources. In the iOS world, the
    most commonly used XML parser is the Foundation `NSXMLParser` class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Injection Through XML External Entities***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One basic function of an XML parser is to handle XML entities. You can basically
    think of these as shortcuts or euphemisms. For example, say you have a simple
    string like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then reference the entity in other parts of an XML document, and
    the parser would insert the contents of the entity at that placeholder. To reference
    your defined entity, simply use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`NSXMLParser` instances have several configurable parameters that can be set
    after instantiation. If `shouldResolveExternalEntities` is set to `YES` on an
    `NSXMLParser` instance, the parser will honor *Document Type Definitions (DTDs)*,
    which can define entities fetched from external URLs. (That’s why these are called
    *external* entities.) When a defined entity is encountered later in the parsed
    XML, the URL will be requested, and the results of the query will be used to populate
    the XML, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, an XML parser is instantiated that reads data from an `NSURL` passed to
    the `initWithContentsOfURL` argument. But if the remote server decides to return
    huge amounts of data, or to simply hang, the client application may crash or hang
    in response.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, however, that an external entity can also refer to a local file, meaning
    the file’s contents could be included in your parsed XML. If that XML is stored
    and then later delivered to the server or another third party, the contents of
    the file will be disclosed along with the rest of the XML. To avoid such scenarios,
    ensure that any URL or filename passed to the XML parser is thoroughly sanitized,
    ideally by a using whitelisting approach, as I discussed in relation to cross-site
    scripting in “[Whitelisting Allowable Input](ch12.html#ch12lev3sec02)” on [page
    12](ch01.html#page_12).
  prefs: []
  type: TYPE_NORMAL
- en: Note that in iOS 7.0 and 7.1 the default behavior of the XML parser is to resolve
    external entities (the opposite of the parser’s intended behavior), and using
    `setShouldResolveExternalEntities:NO` doesn’t actually work.^([3](footnote.html#fn107))
    Unfortunately, there is no workaround to secure the XML parser for older versions
    of iOS, short of using an alternative XML parser. The issue was resolved in iOS
    8.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Contrary to what some have claimed,* `*NSXMLParser*` *is* not *vulnerable
    to recursive entity attacks, a type of denial of service otherwise known as the*
    billion laughs *attack. Vulnerable parsers will resolve recursive entities (entities
    that reference other entities) and chew up tons of system resources. However,
    if recursive entity declarations are given to* `*NSXMLParser*`*, an* `*NSXMLParserEntityRefLoopError*`
    *is thrown.*'
  prefs: []
  type: TYPE_NORMAL
- en: Misuse of official external entities isn’t the only element of XML injection
    to watch for in iOS code, however. Some apps incorporate third-party XML libraries,
    which bring their own set of problems.
  prefs: []
  type: TYPE_NORMAL
- en: '***Issues with Alternative XML Libraries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may encounter alternative XML libraries in various iOS projects, generally
    chosen for their improved performance characteristics over `NSXMLParser` and their
    support for features such as XPath. (Ray Wenderlich offers a good tutorial on
    choosing an XML parser on his blog.^([4](footnote.html#fn108))) When examining
    code that uses an alternate XML library, first ensure that external entity expansion
    is disabled using that library’s standard methods. Then, confirm that any XPath
    queries that integrate externally supplied input sanitize the input first, as
    you would when preventing cross-site scripting. XPath queries should also be parameterized
    in a manner similar to that of SQL queries (see “[SQL Injection](ch12.html#ch12lev1sec02)”
    on [page 203](ch12.html#page_203)), but the methods for doing this may vary depending
    on which third-party libraries are involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ultimately, handling most of the attacks in this chapter comes down to treating
    all external input as hostile: remove potentially malicious content and encode
    or prepare it, if possible, to prevent code execution. It’s a good idea to be
    specific about the content that is allowed for each parameter fetched from the
    UI or from a remote user-manipulated source and enforce this in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: Now I’ll turn away from shielding against malicious data and toward protecting
    good data with appropriate cryptography.
  prefs: []
  type: TYPE_NORMAL
