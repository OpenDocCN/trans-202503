<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_281"/><strong><span class="big">13</span><br/>FOREIGN FILESYSTEMS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">FreeBSD supports a variety of filesystems other than ZFS and UFS. You’ll need to be able to interoperate with other hosts by using optical media, flash drives, and the like. Additionally, FreeBSD uses the special-purpose filesystem devfs(5) to manage device nodes. Jail users might need the process filesystem procfs(5). For extremely fast storage that doesn’t need to survive a reboot, you can use system RAM as a filesystem. You can mount filesystems over the network, using either the Unix-style Network File System or Microsoft’s Common Internet File System (CIFS). And no matter how hard you try to avoid it, sometimes you’re stuck mounting ISO images.</p>
<p class="indent">Using any of these requires a deeper understanding of mounting filesystems.</p>
<h3 class="h3" id="lev471"><span epub:type="pagebreak" id="page_282"/><strong>FreeBSD Mount Commands</strong></h3>
<p class="noindent">We saw mount(8) earlier when discussing UFS filesystems, but you’ll also use it to attach other filesystems to the directory tree. The mount(8) command assumes that any local partitions use UFS. If you try to mount a non-UFS filesystem, you’ll get an error.</p>
<p class="programs"># <span class="codestrong1">mount /dev/cd0 /media</span><br/>mount: /dev/cd0: Invalid argument</p>
<p class="indent">The device node <em>/dev/cd0</em> represents an optical drive. I put a CD in the drive just for this test, so it should work. Trying to mount it gives an error, though. To mount a UFS filesystem, you need the device node and a mount point. Mounting foreign filesystems means adding the filesystem type with <span class="literal">-t</span>. CDs use the ISO 9660 filesystem, which FreeBSD calls cd9660. Here, I specify the filesystem to mount that CD on <em>/cdrom</em>:</p>
<p class="programs"># <span class="codestrong1">mount -t cd9660 /dev/cd0 /media</span></p>
<p class="indent">I can now go to the <em>/media</em> directory and view the contents. Simple enough, eh?</p>
<p class="indent">Many filesystems have their own custom variant of the mount(8) command. Get a full list by running <span class="literal">apropos mount_</span>. Yes, you need the trailing underscore; all of the mount(8) variants use that as a separator. You’ll find mount_cd9660(8), mount_msdosfs(8), mount_nfs(8), and more. Always use <span class="literal">mount -t</span> on filesystems without such a command.</p>
<p class="indent">Apply mount options with the <span class="literal">-o</span> flag. You’ll need to check each mount command’s man page to see what mount options the filesystem supports. Separate multiple mount options with commas. Here, I mount a FAT32 drive at device node <em>/dev/da1</em> read-only, assigning the owner and group to user <em>bert</em>:</p>
<p class="programs"># <span class="codestrong1">mount -t msdosfs -o ro,-gbert,-ubert /dev/da1 /media</span></p>
<p class="indent">You can unmount any mounted filesystem with umount(8):</p>
<p class="programs"># <span class="codestrong1">umount /media</span></p>
<p class="indent">The umount(8) command doesn’t care about the filesystem type. It just tries to disconnect the disk partition from the filesystem. It does care about whether someone is using the filesystem, however, and refuses to unmount it if even one process uses it. If you have an idle terminal with a shell prompt in the filesystem, umount(8) will refuse to unmount the filesystem.</p>
<p class="indent">If you’re constantly connecting and disconnecting filesystems, investigate autofs(5) to handle these mounts automatically.</p>
<h4 class="h4" id="lev472"><strong><em>Supported Foreign Filesystems</em></strong></h4>
<p class="noindent">Here are some of the most commonly used foreign filesystems, along with a brief description of each and the appropriate mount command.</p>
<h5 class="h5" id="lev473"><span epub:type="pagebreak" id="page_283"/><strong>FAT (MS-DOS)</strong></h5>
<p class="noindent">FreeBSD includes extensive support for FAT, the DOS/Windows 9<em>x</em> File Allocation Table filesystem, commonly used on removable media and some dual-boot systems. This support covers the FAT12, FAT16, and FAT32 varieties. You <em>can</em> format a thumb drive with a non-FAT filesystem, however, so don’t blindly assume that all thumb drives use FAT. As the most common use for a thumb drive these days is transferring files between machines, however, most are FAT32. The mount type is <span class="literal">msdosfs</span> (<span class="literal">mount -t msdosfs</span>).</p>
<p class="indent">If you handle a lot of FAT32 disks, investigate the <span class="literal">mtools</span> package, a collection of programs for working with FAT filesystems that offer greater flexibility than the default FreeBSD tools.</p>
<h5 class="h5" id="lev474"><strong>ISO 9660</strong></h5>
<p class="noindent">ISO 9660 is the standard filesystem for CDs and is occasionally used on DVDs. FreeBSD supports reading and writing CDs if you have a CD burner. Just about every CD you encounter is formatted with ISO 9660. The mount command is <span class="literal">mount -t cd9660</span>.</p>
<p class="indent">The <span class="literal">cdrtools</span> package, in <em>/usr/ports/sysutils/cdrtools</em>, contains many helpful tools for working with CD images, including tools that build an ISO image from files on disk.</p>
<h5 class="h5" id="lev475"><strong>UDF</strong></h5>
<p class="noindent">UDF, or Universal Disk Format, is a replacement for ISO 9660. You’ll find UDF on some DVDs and Blu-Ray disks and on a few thumb drives larger than the 32GB supported under FAT32. As the capacity of removable media increases, you’ll see more and more UDF filesystems. The mount command is <span class="literal">mount -t udf</span>.</p>
<h5 class="h5" id="lev476"><strong>EXT</strong></h5>
<p class="noindent">The standard Linux filesystems—EXT2, EXT3, and EXT4—support many of the same features as UFS. FreeBSD can safely read from and write to EXT2 and EXT3 filesystems without any problems but can mount EXT4 filesystems only as read-only.</p>
<p class="indent">Mounting Linux filesystems is most useful for disaster recovery, dual-boot systems, or system migrations. Despite the name, <span class="literal">mount -t ext2fs</span> supports mounting all versions of EXT.</p>
<p class="indent">Linux filesystem users might find the tools in <em>/usr/ports/sysutils/e2fsprogs</em> useful. They let you fsck(8) and assess Linux filesystems, among other things.</p>
<h4 class="h4" id="lev477"><strong><em>Permissions and Foreign Filesystems</em></strong></h4>
<p class="noindent">Permissions of a filesystem depend on the filesystem features and the person who mounts it. FreeBSD tries to support features that aren’t too different from those in UFS or ZFS.</p>
<p class="indent">Consider the Linux filesystem, EXT. EXT stores permissions in the filesystem and lets the kernel map them to UIDs. Since EXT permissions <span epub:type="pagebreak" id="page_284"/>behave much like UFS permissions and all the necessary permissions information is available within the filesystem, FreeBSD respects the permissions on these filesystems. EXT doesn’t support BSD file flags, however, so you can’t assign those flags to a file on EXT.</p>
<p class="indent">FAT has no permissions system. Even if you mount your FAT32 thumb drive in your FreeBSD host, you can’t apply permissions to files.</p>
<p class="indent">By default, only root can mount filesystems, and root owns all non-Unix filesystems. If that’s not your preference, you can use the <span class="literal">-u</span> and <span class="literal">-g</span> flags to set the user ID and group ID of the owner when you’re mounting a FAT32, ISO 9660, or UDF filesystem. For example, if you’re mounting a FAT32 USB device for the user <em>xistence</em> and want him to be able to edit the contents, use this command:</p>
<p class="programs"># <span class="codestrong1">mount -t msdosfs -u xistence -g xistence /dev/da5 /mnt</span></p>
<p class="indent">The user <em>xistence</em> now owns the files on the device.</p>
<p class="indent">You might get sick of mounting media for your users, especially in a facility with dozens of machines. To let users mount filesystems, set the sysctl <span class="literal">vfs.usermount</span> to <span class="literal">1</span>. Users can then mount any device they have permission to access on any mount point they own. While <em>xistence</em> couldn’t mount the removable device on <em>/media</em>, he could mount it on <em>/home/xistence/media</em>.</p>
<h3 class="h3" id="lev478"><strong>Using Removable Media</strong></h3>
<p class="noindent">You must be able to manage any removable media that might wander in through the door of your data center. Here, we’ll discuss optical disks and flash drives.</p>
<p class="indent">I recommend not plugging removable media willy-nilly into your production servers—for security reasons if nothing else. Who knows what’s actually on that vendor’s USB device? Worse, you can order “USB killer” devices that deliberately damage hardware. Mount suspicious devices on a disposable workstation, examine the contents, and then copy the desired data over to the FreeBSD machine. This isn’t guaranteed to be safe, as the many USB interfaces can inject data into the hardware beneath the OS layer, but it’s as safe as you’ll get. Removable media is just too easy for certain applications, however, and of course the rules change when it’s my personal USB device.</p>
<p class="indent">Using the device requires a filesystem type, a device node, and a mount point.</p>
<p class="indent">Figuring out a removable drive’s filesystem can require a bit of trial and error. CDs use the ISO 9660 filesystem, while DVDs and Blu-Rays use either a UDF or a combination of ISO 9660 and UDF. When in doubt, try CD9660 first. USB devices and floppy disks are usually FAT32. While it was once expected that large USB devices would use UDF, most of them still use FAT32. Run fstyp(8) on a device node to help identify the filesystem on it, or try <span class="literal">gpart show</span> on the disk’s device node.</p>
<p class="indent"><span epub:type="pagebreak" id="page_285"/>Removable devices can have a different device node each time you plug them in. Optical drives are a little easier to identify in that most hosts have very few optical drives. If you have one optical drive, it’s <em>/dev/cd0</em>. USB devices appear as the next available unit of <em>/dev/da</em>. When you insert a USB device, a message giving the device node and type appears on the console and in <em>/var/log/messages</em>, or you could check <span class="literal">camcontrol devlist</span> for the new device.</p>
<p class="indent">FreeBSD provides a <em>/media</em> mount point for general <em>removable media</em> mounts. You can create additional mount points as you like—they’re just directories. For miscellaneous short-term mounts, FreeBSD offers <em>/mnt</em>.</p>
<p class="indent">So, to mount your FAT32 USB device <em>/dev/da0</em> on <em>/media</em>, run:</p>
<p class="programs"># <span class="codestrong1">mount -t msdosfs /dev/da0 /media</span></p>
<p class="indent">Occasionally, you’ll find a thumb drive with a partition table. These devices will insist you mount <em>/dev/da0s1</em> or <em>/dev/da0p1</em> rather than <em>/dev/da0</em>. The device’s formatting dictates this, not anything in FreeBSD. The <span class="literal">gpart show</span> command can help you figure out which partitions are on a device and what filesystem is on each partition.</p>
<h4 class="h4" id="lev479"><strong><em>Ejecting Removable Media</em></strong></h4>
<p class="noindent">To disconnect removable media from your FreeBSD system, first unmount the filesystem. Your optical drive won’t open until you unmount the disk. You can pull a USB flash drive from its port, but doing so while the filesystem is mounted might damage data on the device. Use umount(8) just as you would for any other filesystem:</p>
<p class="programs"># <span class="codestrong1">umount /media</span></p>
<p class="indent">On many optical drives, <span class="literal">camcontrol eject</span> opens the drive tray.</p>
<h4 class="h4" id="lev480"><strong><em>Removable Media and /etc/fstab</em></strong></h4>
<p class="noindent">You can update <em>/etc/fstab</em> with entries for removable media to make system maintenance a little easier. If a removable filesystem has an entry in <em>/etc/fstab</em>, you can drop both the filesystem and the device name when mounting it. This means that you don’t have to remember the exact device name or filesystem to mount the device.</p>
<p class="indent">When listing removable media in <em>/etc/fstab</em>, be sure to include the <span class="literal">noauto</span> flag. Otherwise, whenever you don’t have the removable media in place, your boot will stop in single-user mode because a filesystem is missing.</p>
<p class="indent"><span epub:type="pagebreak" id="page_286"/>Here’s an <em>/etc/fstab</em>’s entry for an optical drive:</p>
<p class="programs">/dev/cd0   /cdrom   cd9660  ro,noauto       0       0</p>
<p class="indent">While I’m sure you’ve already memorized the meaning of every column in <em>/etc/fstab</em>, we’ll remind you that this entry means, “Mount <em>/dev/cd0</em> on <em>/cdrom</em>, using the ISO 9660 filesystem. Mount it as read-only, and don’t mount it automatically at boot.”</p>
<p class="indent">Here’s a similar entry for a thumb drive. I use the <span class="literal">large</span> option to support filesystems larger than 128GB, as discussed in mount_msdosfs(8).</p>
<p class="programs"><span class="ent">➊</span>/dev/da0    /media    msdosfs  rw,noauto,large     0       0</p>
<p class="indent">FreeBSD doesn’t provide these by default, but I find having them to be much easier on systems where I use removable media regularly. Confirm that your next available da device is <em>/dev/da0</em> <span class="ent">➊</span>, as trying to mount a hard drive that’s already mounted won’t work.</p>
<h4 class="h4" id="lev481"><strong><em>Formatting FAT32 Media</em></strong></h4>
<p class="noindent">Thumb drives use the FAT32 filesystem but always come preformatted. As thumb drives have a limited number of reads and writes directly proportional to their cheapness, do not reformat them capriciously.<sup><a href="footnote.xhtml#ch13fn1" id="ch13fn1a">1</a></sup> Only reformat thumb drives when their filesystem becomes corrupt. Use newfs_msdos(8) to create a FAT32 filesystem.</p>
<p class="programs"># <span class="codestrong1">newfs_msdos /dev/da0</span></p>
<p class="indent">You’ll get a couple lines of output, and you have a new filesystem.</p>
<h4 class="h4" id="lev482"><strong><em>Creating Optical Media</em></strong></h4>
<p class="noindent">FreeBSD will let you bundle up a bunch of files into an image suitable for burning onto a CD, DVD, or Blu-Ray, using either CD 9660 or UDF formats. You can burn either image onto disk. FreeBSD supports creating ISOs natively, but you’ll need programs from the <span class="literal">cdrtools</span> package to create UDF.</p>
<p class="indent">In either case, start by putting all of the files and directories you want to burn into a single directory. The image will contain these files and directories exactly as you arrange them. Remember, optical disk images are read-only. You can’t update an image; you can only create a new image, so be sure you have everything exactly as you want it. Later this chapter, you’ll learn to mount these images with mdconfig(8).</p>
<p class="indent">In both of these examples, we’re creating an image from the files contained in <em>/home/xistence/cdfiles</em>.</p>
<h5 class="h5" id="lev483"><strong>Creating ISOs</strong></h5>
<p class="noindent">Use makefs(8) to create an ISO.</p>
<p class="programs"># <span class="codestrong1">makefs</span> <span class="ent">➊</span><span class="codestrong1">-t cd9660</span> <span class="ent">➋</span><span class="codestrong1">-o allow-deep-trees,rockridge</span> <span class="ent">➌</span><span class="codestrongitalic1">image.iso</span> <span class="ent">➍</span><span class="codestrongitalic1">source-files</span></p>
<p class="indent">Start by using <span class="literal">-t</span> <span class="ent">➊</span> to specify the type of filesystem to create—in this case, CD 9660. The <span class="literal">-o</span> flag <span class="ent">➋</span> lets you specify filesystem-specific options. You <span epub:type="pagebreak" id="page_287"/>can get a whole list of options from the makefs(8) man page, but the ones shown here suffice for most images. We then need the filename <span class="ent">➌</span> for the created image and the source directory <span class="ent">➍</span> for those files.</p>
<p class="indent">To make an image containing the files in <em>/home/xistence/cdfiles</em> as <em>bert.iso</em>, run:</p>
<p class="programs"># <span class="codestrong1">makefs -t cd9660 -o allow-deep-trees,rockridge bert.iso /home/xistence/cdfiles</span></p>
<p class="indent">Bert can now wastefully burn his ISO to physical media.</p>
<h5 class="h5" id="lev484"><strong>Creating a UDF</strong></h5>
<p class="noindent">Creating a UDF requires using mkisofs(1) from the <span class="literal">cdrtools</span> package. Give the destination image file with <span class="literal">-o</span>. Enable the Joliet and Rock Ridge extensions with <span class="literal">-J</span> and <span class="literal">-R</span>, respectively. (I’m not going to go into what each of these do, but if you want your ISO to behave like a disk from this millennium, you need them.) Add the <span class="literal">-udf</span> and <span class="literal">-iso-level 3</span> flags.<sup><a href="footnote.xhtml#ch13fn2" id="ch13fn2a">2</a></sup></p>
<p class="programs"># <span class="codestrong1">mkisofs -R -J -udf -iso-level 3 -o bert.udf /home/xistence/cdfiles</span></p>
<p class="indent">You now have a UDF image based on what’s in <em>/home/xistence/cdfiles</em>.</p>
<p class="indent">Whichever format you create, I encourage you to mount it and double-check your work before burning a physical disk. If you’re lucky, you’ll remember the stuff you forgot to include on the image.</p>
<h5 class="h5" id="lev485"><strong>Burning ISOs to Optical Media</strong></h5>
<p class="noindent">Use cdrecord(1) from the <span class="literal">cdrtools</span> package to burn ISO images to the disk. Give the image file as an argument.</p>
<p class="programs"># <span class="codestrong1">cdrecord bert.iso</span></p>
<p class="indent">Depending on the drive speed and image size, this might take a while.</p>
<p class="indent">The cdrecord(1) program defaults to using <em>/dev/cd0</em>. If you have additional optical drives, use the <span class="literal">-dev</span> flag to give an alternate device name.</p>
<p class="programs"># <span class="codestrong1">cdrecord -dev=cd9 bert.iso</span></p>
<p class="indent">You now have a flimsy plastic disk that you’ll use twice before flinging it into the landfill. Congratulations!</p>
<h5 class="h5" id="lev486"><strong>Burning UDF to Optical Media</strong></h5>
<p class="noindent">While you <em>can</em> use cdrecord(1) to burn UDF images to media, the growisofs(1) command from the <span class="literal">dvd+rw-tools</span> package is generally recommended. You’ll need the <span class="literal">-dvd-compat</span> and <span class="literal">-Z</span> flags. Then, specify the device and the image file.</p>
<p class="programs"><span epub:type="pagebreak" id="page_288"/># <span class="codestrong1">growisofs -dvd-compat -Z /dev/burner=image.udf</span></p>
<p class="indent">Suppose I want to burn <em>bert.udf</em> to the Blu-Ray in <em>/dev/cd0</em>.</p>
<p class="programs"># <span class="codestrong1">growisofs -dvd-compat -Z /dev/cd0=bert.udf</span></p>
<p class="indent">UDF files can be huge. Go make some tea. Eventually, you’ll have a burned disk.</p>
<h4 class="h4" id="lev487"><strong><em>Writing Images to Thumb Drives</em></strong></h4>
<p class="noindent">USB thumb drives have increasingly supplanted optical disks, thanks in part to their reusability. FreeBSD supports writing disk images to thumb drives with dd(1).</p>
<p class="indent">Be very certain which device node is your thumb drive and which is your system hard drive. Thumb drives show up as <em>/dev/da</em> devices, exactly like many hard drives. Overwriting the wrong hard drive is embarrassing.<sup><a href="footnote.xhtml#ch13fn3" id="ch13fn3a">3</a></sup></p>
<p class="indent">The dd(1) command looks confusing at first glance.</p>
<p class="programs"># <span class="codestrong1">dd</span> <span class="ent">➊</span><span class="codestrong1">if=inputfile</span> <span class="ent">➋</span><span class="codestrong1">of=outputdevice</span> <span class="ent">➌</span><span class="codestrong1">bs=1M</span> <span class="ent">➍</span><span class="codestrong1">conv=sync</span></p>
<p class="indent">The <span class="literal">if=</span> argument <span class="ent">➊</span> gives the file you want to copy. The <span class="literal">of=</span> argument <span class="ent">➋</span> is the device node to copy to. The <span class="literal">bs=</span> flag <span class="ent">➌</span> gives the amount to copy at one time. Without this, dd(1) copies in 512-byte increments. The <span class="literal">conv=</span> argument <span class="ent">➍</span> gives dd(1) instructions about how to convert the incoming file. In this case, <em>sync</em> tells dd(1) to synchronize the size of the incoming and outgoing buffer. To burn <em>bertimage.udf</em> to thumb drive <em>/dev/da9</em>, I would run:</p>
<p class="programs"># <span class="codestrong1">dd if=bert.udf of=/dev/da9 bs=1m conv=sync</span></p>
<p class="indent">Wait a bit, and you’ll have an imaged thumb drive. Other uses of dd(1) might not need the <span class="literal">conv=</span> flag, but always use <span class="literal">bs</span>.</p>
<p class="indent">Now let’s look at some other filesystems you might find useful.</p>
<h3 class="h3" id="lev488"><strong>Memory Filesystems</strong></h3>
<p class="noindent">In addition to putting filesystems on disks or partitions, FreeBSD lets you create partitions from files, pure RAM, and a combination of the two. One of the most popular uses of this feature is for <em>memory filesystems</em>, or <em>memory disks</em>. Reading and writing files to and from memory is much faster than accessing files on disk, which makes a memory-backed filesystem a huge optimization for certain applications. As with everything else in memory, however, you lose the contents of your memory disk at system shutdown.</p>
<p class="indent"><span epub:type="pagebreak" id="page_289"/>FreeBSD supports two different memory-backed disks: <em>tmpfs</em> (pronounced “temp f s”) and <em>memory disks</em>. While they have similar concepts behind them, the underlying code is completely different, and they serve different roles. Use tmpfs(5) for memory-backed filesystems on long-running systems. Memory disks are more flexible but better suited for short-term use or mounting disk images.</p>
<h4 class="h4" id="lev489"><strong><em>tmpfs</em></strong></h4>
<p class="noindent">The <em>tmp</em> in tmpfs(5) doesn’t mean “temporary.” It literally means <em>tmp</em>, as in <em>/tmp</em>. Use tmpfs for a speedy memory-backed <em>/tmp</em> and similar filesystems. Don’t deploy tmpfs everywhere you see a path with <em>tmp</em> in it, though. While <em>/tmp</em> is supposed to be cleared at every boot, <em>/var/tmp</em> is supposed to survive a reboot. You might use tmpfs for application lock files and other ephemeral data where vastly increased speed would improve application performance. While tmpfs has a troubled history, as of FreeBSD 10, it’s widely deployed and considered ready for production.</p>
<p class="indent">Create a tmpfs by mounting it.</p>
<p class="programs"># <span class="codestrong1">mount -t tmpfs tmpfs /tmp</span></p>
<p class="indent">If your system has the sysctl <span class="literal">vfs.usermount</span> set to 1, users can create and mount tmpfs filesystems.</p>
<h5 class="h5" id="lev490"><strong>tmpfs Options</strong></h5>
<p class="noindent">A tmpfs defaults to the size of the system’s available RAM plus the available swap space. Repeatedly copying a file to <em>/tmp</em> could exhaust system memory. This would be bad. Set a maximum size for your tmpfs with the <span class="literal">size</span> option.</p>
<p class="programs"># <span class="codestrong1">mount -o size=1g -t tmpfs tmpfs /tmp</span></p>
<p class="indent">Control the ownership and permissions on a tmpfs with the <span class="literal">uid</span>, <span class="literal">gid</span>, and <span class="literal">mode</span> options. An actual <em>/tmp</em> directory needs to be world-writable with the sticky bit set, so be sure to use the option <span class="literal">mode=1777</span>.</p>
<p class="indent">If the tmpfs is for a specific user, even an unprivileged user that runs only a single application, assign that user ownership of the tmpfs.</p>
<h5 class="h5" id="lev491"><strong>tmpfs at Boot</strong></h5>
<p class="noindent">Now that you can set a maximum size and the proper permissions, it’s okay to use <em>/etc/fstab</em> to automatically create a tmpfs at boot.</p>
<p class="programs">tmpfs  /tmp  tmpfs  rw,mode=1777,size=1G  0  0</p>
<p class="indent">For more complicated memory-backed disks, consider a traditional memory disk.</p>
<h4 class="h4" id="lev492"><span epub:type="pagebreak" id="page_290"/><strong><em>Memory Disks</em></strong></h4>
<p class="noindent">A memory disk is an ephemeral storage device. Despite the name, a memory disk isn’t always a chunk of memory being treated as a disk. It can be such a device, but it might instead use a file or swap space or some other backing store. No matter what, the memory disk disappears at system shutdown.</p>
<h5 class="h5" id="lev493"><strong>Memory Disk Types</strong></h5>
<p class="noindent">Memory disks come in four types: malloc-backed, swap-backed, vnode-backed, and null.</p>
<p class="indent"><em>Malloc-backed</em> memory disks are pure memory. Even if your system runs short on memory, FreeBSD won’t swap out the malloc-backed disk. Much like tmpfs(5), using a large malloc-backed disk is a great way to exhaust system memory. Malloc-backed disks are most useful for swapless embedded devices.</p>
<p class="indent"><em>Swap-backed</em> memory disks are mostly memory, but they also access the system swap partition. If the system runs out of memory, it moves the least recently used parts of memory to swap, as discussed in <a href="ch21.xhtml#ch21">Chapter 21</a>. Swap-backed disks are usually the best compromise between speed and performance.</p>
<p class="indent"><em>Vnode-backed</em> memory disks are files on disk. While you can use a file as backing for your memory disk, this is mostly useful for mounting disk images and testing.</p>
<p class="indent">A <em>null</em> memory disk discards everything sent to it. Any writes are successful, while any reads return zero. If I didn’t mention null memory disks, someone would write to complain, but I’m not giving a disk guaranteed to lose all data any more coverage than this.</p>
<p class="indent">Once you know what you want to do, use mdmfs(8) to perform the action.</p>
<h5 class="h5" id="lev494"><strong>Creating and Mounting Memory Disks</strong></h5>
<p class="noindent">The mdmfs(8) utility is a handy frontend for several programs, such as mdconfig(8) and newfs(8). It handles the drudgery of configuring devices and creating filesystems on those devices, and makes creating memory disks as easy as possible. You need to know only the size of the disk you want to use, the type of the memory disk, and the mount point.</p>
<p class="indent">Swap-backed memory disks are the default. Just tell mdmfs(8) the size of the disk and the mount point. Here, we create a 48MB swap-backed memory disk on <em>/home/mwlucas/test</em>:</p>
<p class="programs"># <span class="codestrong1">mdmfs -t -s 48m md /home/mwlucas/test</span></p>
<p class="indent">The <span class="literal">-s</span> flag gives the size of the disk. If you run mount(8) without any arguments, you’ll see that you now have the memory disk device <em>/dev/md0</em> mounted on that directory.</p>
<p class="indent">The <span class="literal">-t</span> flag enables TRIM, which we’ll discuss in the following section, “Memory Disk Headaches.”</p>
<p class="indent"><span epub:type="pagebreak" id="page_291"/>To create and mount a malloc-backed disk, add the <span class="literal">-M</span> flag.</p>
<p class="indent">To mount a vnode-backed memory disk, use the <span class="literal">-F</span> flag and the path to the image file.</p>
<p class="programs"># <span class="codestrong1">mdmfs -F</span> <span class="codestrongitalic1">diskimage</span><span class="codestrong1">.file md /mnt</span></p>
<p class="indent">The <span class="literal">md</span> entry we’ve been using all along here means, “I don’t care what device name I get; just give me the next free one.” You can also specify a particular device name if you like. Here, I declare I want disk device <em>/dev/md9</em>:</p>
<p class="programs"># <span class="codestrong1">mdmfs -F</span> <span class="codestrongitalic1">diskimage</span><span class="codestrong1">.file md9 /mnt</span></p>
<h5 class="h5" id="lev495"><strong>Memory Disk Headaches</strong></h5>
<p class="noindent">Traditional swap-backed memory disks never returned used memory to the system. Once you wrote to a memory disk, that memory was used up. If you needed a larger memory disk, you had to permanently allocate memory for it. This was one reason FreeBSD included tmpfs(5).</p>
<p class="indent">If the filesystem on the memory disk supports <em>TRIM</em>, however, FreeBSD now returns unused memory to the system. TRIM is not an acronym but rather a protocol for telling a disk which sectors are no longer in use. UFS, the default memory disk format, supports TRIM. Enable TRIM in mdmfs with the <span class="literal">-t</span> flag. If you’re using a different filesystem on a memory disk, though, be sure it’s strictly temporary.</p>
<p class="indent">To free the memory from a memory disk, shut down the memory disk.</p>
<h5 class="h5" id="lev496"><strong>Memory Disk Shutdown</strong></h5>
<p class="noindent">To remove a memory disk, you must unmount the partition and destroy the disk device. Destroying the disk device frees the memory used by the device, which is useful when your system is heavily loaded. To find the disk device, run mount(8) and find your memory disk partition. Somewhere in the output, you’ll find a line like this:</p>
<p class="programs">/dev/md41 on /mnt (ufs, local, soft-updates)</p>
<p class="indent">Here, we see memory disk <em>/dev/md41</em> mounted on <em>/mnt</em>. Let’s unmount it and destroy it.</p>
<p class="programs"># <span class="ent">➊</span><span class="codestrong1">umount /mnt</span><br/># <span class="codestrong1">mdconfig</span> <span class="ent">➋</span><span class="codestrong1">-d</span> <span class="ent">➌</span><span class="codestrong1">-u 41</span></p>
<p class="indent">Unmounting with <span class="literal">umount</span> <span class="ent">➊</span> is done exactly as with other filesystems. The mdconfig(8) call is a new one, however. Use mdconfig(8) to directly manage memory devices. The <span class="literal">-d</span> flag <span class="ent">➋</span> means <em>destroy</em>, and the <span class="literal">-u</span> flag <span class="ent">➌</span> gives a device number. The above destroys the device <em>/dev/md41</em>, or the <span class="literal">md</span> device number 41. The memory used by this device is now freed for other uses.</p>
<h5 class="h5" id="lev497"><span epub:type="pagebreak" id="page_292"/><strong>Memory Disks and /etc/fstab</strong></h5>
<p class="noindent">If you list memory disks in <em>/etc/fstab</em>, FreeBSD automatically creates them at boot time. These entries look more complicated than the other entries but aren’t too bad if you understand the mdmfs(8) commands we’ve been using so far.</p>
<p class="indent">We’re allowed to use <em>md</em> as a device name to indicate a memory disk. Choose the mountpoint just as for any other device, and use the filesystem type <span class="literal">mfs</span>. Under <span class="literal">Options</span>, list <em>rw</em> (for read-write) and the command line options used to create this device. If this is a long-term mount, add <span class="literal">-t</span> to enable TRIM. To create our 48MB filesystem mounted at <em>/home/mwlucas/test</em>, use the following <em>/etc/fstab</em> entry:</p>
<p class="programs">md      /home/mwlucas/test      mfs      rw,-s48m,-t      0   0</p>
<p class="indent">Looks easy, doesn’t it? The only problem is that the long line messes up your nice and even <em>/etc/fstab</em> entry’s appearance. Well, they’re not the only things that will make this file ugly, as we’ll soon see.</p>
<h4 class="h4" id="lev498"><strong><em>Mounting Disk Images</em></strong></h4>
<p class="noindent">You can use mdmfs(8) to view UFS disk images, but most often you want to examine the contents of an ISO or UDF file without burning it to disk. (FreeBSD’s tar(1) can access the contents of an ISO, but not a UDF.) Just attach a memory disk to a file with the mdconfig(8) command’s <span class="literal">-a</span> flag. Here, I attach Bert’s ISO to a memory device:</p>
<p class="programs"># <span class="codestrong1">mdconfig</span> <span class="ent">➊</span><span class="codestrong1">-a -t</span> <span class="ent">➋</span><span class="codestrong1">vnode -f</span> <span class="ent">➌</span><span class="codestrong1">/home/mwlucas/bert.iso</span><br/><span class="ent">➍</span>md0</p>
<p class="indent">We tell mdconfig(8) to attach <span class="ent">➊</span> a vnode-backed <span class="ent">➋</span> memory device to the file specified <span class="ent">➌</span>. The mdconfig(8) command responds by telling us the device <span class="ent">➍</span> it’s attached to. Now we just mount the device with the proper mount command for the filesystem:</p>
<p class="programs"># <span class="codestrong1">mount -t cd9660 /dev/md0 /mnt</span></p>
<p class="indent">I can now verify that the ISO contains Bert’s files, so he doesn’t get to whine that the ISO is busted.</p>
<p class="indent">One common mistake people make at this point is mounting the image without specifying the filesystem type. You might get an error, or you might get a successful mount that contains no data—by default, mount(8) assumes that the filesystem is UFS!</p>
<p class="indent">When you’re done accessing the data, be sure to unmount the image and destroy the memory disk device just as you would for any other memory device. While vnode-backed memory disks don’t consume system memory, leaving unused memory devices around will confuse you months later when you wonder why they appear in <em>/dev</em>. If you’re not sure what memory devices a system has, use <span class="literal">mdconfig -l</span> to view all configured md(5) devices.</p>
<p class="programs"><span epub:type="pagebreak" id="page_293"/># <span class="codestrong1">mdconfig -l</span><br/>md0 md1</p>
<p class="indent">I have two memory devices? Add the <span class="literal">-u</span> flag and the device number to see what type of memory device it is. Let’s see what memory device 1 (<em>/dev/md1</em>) is:</p>
<p class="programs"># <span class="codestrong1">mdconfig -l -u 1</span><br/>md1     vnode     456M  /slice1/usr/home/mwlucas/iso/omsa-51-live.iso</p>
<p class="indent">I have an ISO image mounted on this system? Wow. I should probably reboot some month. Nah, that’s too much work; I’ll just unmount the filesystem and destroy the memory device.</p>
<h4 class="h4" id="lev499"><strong><em>Filesystems in Files</em></strong></h4>
<p class="noindent">One trick used in embedded systems is building complete filesystem images on a local file. In the previous section, we saw how we could use memory disks to mount and access CD disk images. You can use the same techniques to create, update, and access UFS disk images.</p>
<p class="indent">To use a filesystem in a file, you must create a file of the proper size, attach the file to a memory device, place a filesystem on the device, and mount the device.</p>
<h5 class="h5" id="lev500"><strong>Creating an Empty Filesystem File</strong></h5>
<p class="noindent">Use truncate(1) to create an empty file for a filesystem. These files are sparse files: they’re labeled as having a certain size but don’t actually take up any space until you put something in them. An empty sparse file takes up one filesystem block and grows when you put stuff in it. This means you can create an image for a disk of any size but use up only an amount of space equal to the stuff you put in the image.</p>
<p class="indent">Use the <span class="literal">-s</span> option and the file size to create an image file. Here, I create a 1GB file:</p>
<p class="programs"># <span class="codestrong1">truncate -s 1G</span> <span class="codestrongitalic1">filesystem.file</span></p>
<p class="indent">The resulting file claims to be pretty large.</p>
<p class="programs"># <span class="codestrong1">ls -l</span> <span class="codestrongitalic1">filesystem.file</span><br/>-rw-r--r--  1 mwlucas  mwlucas  1073741824 Aug 11 11:31 <span class="codeitalic1">filesystem.file</span></p>
<p class="indent">But if you check the disk usage, you’ll see something different.</p>
<p class="programs"># <span class="codestrong1">du</span> <span class="codestrongitalic1">filesystem.file</span><br/>1       <span class="codeitalic1">filesystem.file</span></p>
<p class="indent">This 1GB file uses one block on the disk.</p>
<p class="indent"><span epub:type="pagebreak" id="page_294"/>Sparse files never shrink. They can only grow. If you erase a bunch of files from your disk image, the image file still needs that space.</p>
<p class="indent">Also, not all filesystems support sparse files. UFS and ZFS do. If you’re trying to create a sparse file on a FAT32 filesystem, you’re probably solving the wrong problem.</p>
<h5 class="h5" id="lev501"><strong>Creating the Filesystem on the File</strong></h5>
<p class="noindent">To get a filesystem on the file, first associate the file with a device with a vnode-backed memory disk. We did exactly this in the last section:</p>
<p class="programs"># <span class="codestrong1">mdconfig -a -t vnode -f filesystem.file</span><br/>md0</p>
<p class="indent">Now, let’s make a filesystem on this device. This is much like creating a UFS filesystem on a thumb disk with the newfs(8) command. Soft updates journaling is exactly as useful on file-backed filesystems as on disk-backed ones, so enable them with <span class="literal">-j</span>.</p>
<p class="programs"># <span class="codestrong1">newfs -j /dev/md0</span> <br/>/dev/md0: 1024.0MB (2097152 sectors) block size 32768, fragment size 4096<br/>        using 4 cylinder groups of 256.03MB, 8193 blks, 32896 inodes.<br/>        with soft updates<br/>super-block backups (for fsck_ffs -b #) at:<br/> 192, 524544, 1048896, 1573248<br/>Using inode 4 in cg 0 for 8388608 byte journal<br/>newfs: soft updates journaling set</p>
<p class="indent">The newfs(8) program prints out basic information about the disk, such as its size, block and fragment sizes, and the inode count.</p>
<p class="indent">Now that you have a filesystem, mount it:</p>
<p class="programs"># <span class="codestrong1">mount /dev/md0 /mnt</span></p>
<p class="indent">Congratulations! You now have a 1GB file-backed filesystem. Copy files to it, dump it to tape, or use it in any way you would use any other filesystem. But in addition to that, you can move it just like any other file.</p>
<h5 class="h5" id="lev502"><strong>File-Backed Filesystems and /etc/fstab</strong></h5>
<p class="noindent">You can mount a file-backed filesystem automatically at boot with the proper entry in <em>/etc/fstab</em>, much like you can automatically mount any other memory disk. You simply have to specify the name of the file with <span class="literal">-F</span> and use <span class="literal">-P</span> to tell the system not to create a new filesystem on this file but just to use the one already there. Here, we mount the file-backed filesystem we created on <em>/mnt</em> automatically at boot time.</p>
<p class="programs">md    /mnt     mfs     rw,-P,-F/home/mwlucas/filesystem.file    0    0</p>
<p class="indent"><span epub:type="pagebreak" id="page_295"/>I told you we’d see <em>/etc/fstab</em> entries uglier than the one for generic memory disks, didn’t I?</p>
<h3 class="h3" id="lev503"><strong>devfs</strong></h3>
<p class="noindent">devfs(5) is a dynamic filesystem for managing device nodes. Remember, in a Unix-like operating system, <em>everything</em> is a file. This includes physical hardware. Almost all devices on the system have a device node under <em>/dev</em>. You’ve seen a bunch of device nodes for disks, but you’ll also see keyboards (<em>/dev/ukbd0</em> or <em>/dev/kbd0</em>), the console (<em>/dev/console</em>), sound mixers (<em>/dev/mixer0</em>), and more. You’ll also find device nodes for logical devices, like the random number generator (<em>/dev/random</em>), terminal sessions (<em>/dev/ttyv0</em>), and so on.</p>
<p class="indent">Once upon a time, the sysadmin was responsible for making these device node files. Lucky sysadmins managed an operating system that came with a shell script to handle device node creation and permissions. If the OS authors hadn’t provided such a shell script, or if the server had unusual hardware not included in that shell script, the sysadmin had to create the node with animal sacrifices and mknod(8). If any little thing went wrong, the device wouldn’t work. The other option was to ship the operating system with device nodes for every piece of hardware imaginable. Sysadmins could be confident—well, <em>mostly</em> confident—that the desired device nodes were available, somewhere, buried within the thousands of files under <em>/dev</em>.</p>
<p class="indent">Of course, the kernel knows exactly what characteristics each device node should have. With devfs(5), FreeBSD simply asks the kernel what device nodes the kernel thinks the system should have and provides exactly those—and no more. This works well for most people. You and I are not “most people,” however. We expect odd things from our computers. Perhaps we need to make device nodes available under different names, change device node ownership, or configure our hardware uniquely. FreeBSD breaks the problem of device node management into three pieces: configuring devices present at boot, global availability and permissions, and configuring devices that appear dynamically after boot with devd(8).</p>
<h4 class="h4" id="lev504"><strong><em>/dev at Boot</em></strong></h4>
<p class="noindent">When device nodes were permanent files on disk, the sysadmin could symlink to those nodes or change their permissions without worrying that his changes would vanish. With an automated, dynamic device filesystem, this assurance disappears. (Of course, you no longer have to worry about occult mknod(8) commands either, so you’re better off in the long run.) The device node changes could include, for example:</p>
<ul>
<li class="noindent">Making device nodes available under different names</li>
<li class="noindent">Changing ownership of device nodes</li>
<li class="noindent">Concealing device nodes from users</li>
</ul>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_296"/><strong>DEVICE MANAGEMENT AND SERVERS</strong></p>
<p class="spara">For the most part, device node management on servers works without any adjustment or intervention. The place I most often need to muck with device nodes is on laptops and the occasional workstation. FreeBSD’s device node management tools are very powerful and flexible, and include support for things I wouldn’t expect to use in a century. We’ll touch only upon the basics. Don’t think that you must master devfs(5) to get your server running well!</p>
</div>
<p class="indent">At boot time, devfs(8) creates device nodes in accordance with the rules in <em>/etc/devfs.conf</em>.</p>
<h5 class="h5" id="lev505"><strong>devfs.conf</strong></h5>
<p class="noindent">The <em>/etc/devfs.conf</em> file lets you create links, change ownership, and set permissions for devices available at boot. Each rule has the following format:</p>
<p class="programs">action      realdevice      desiredvalue</p>
<p class="indent">The valid actions are <span class="literal">link</span> (create a link), <span class="literal">perm</span> (set permissions), and <span class="literal">own</span> (set owner). The <span class="literal">realdevice</span> entry is a preexisting device node, while the last setting is your desired value. For example, here we create a new name for a device node:</p>
<p class="programs"><span class="ent">➊</span>link      <span class="ent">➋</span>cd0           <span class="ent">➌</span>cdrom</p>
<p class="indent">We want a symbolic link <span class="ent">➊</span> to the device node <em>/dev/cd0</em> <span class="ent">➋</span> (an optical drive), and we want this link to be named <em>/dev/cdrom</em> <span class="ent">➌</span>. If we reboot with this entry in <em>/etc/devfs.conf</em>, our optical drive <em>/dev/cd0</em> also appears as <em>/dev/cdrom</em>, as many desktop multimedia programs expect.</p>
<p class="indent">To change the permissions of a device node, give the desired permissions in octal form as the desired value:</p>
<p class="programs">perm        cd0            666</p>
<p class="indent">Here, we set the permissions on <em>/dev/cd0</em> (our CD device, again) so that any system user can read or write to the device. Remember, changing the permissions on the <em>/dev/cdrom</em> link won’t change the permissions on the device node, just the symlink.</p>
<p class="indent">Finally, we can also change the ownership of a device. Changing a device node’s owner usually indicates that you’re solving a problem the wrong way and that you may need to stop and think. FreeBSD happily lets you mess up your system if you insist, however. Here, we let a particular user have absolute control of the disk device <em>/dev/da20</em>:</p>
<p class="programs">own         da20            xistence:xistence</p>
<p class="indent"><span epub:type="pagebreak" id="page_297"/>This might not have the desired effect, however, as some programs still think that you must be root to carry out operations on devices. I’ve seen more than one piece of software shut itself down if it’s not run by root, without even trying to access its device nodes. Changing the device node permissions won’t stop those programs’ complaints when they’re run by a regular user.</p>
<p class="indent">Configuration with devfs.conf(5) solves many problems, but not all. If you want a device node to simply be invisible and inaccessible, you must use devfs rules.</p>
<h4 class="h4" id="lev506"><strong><em>Global devfs Rules</em></strong></h4>
<p class="noindent">Every devfs(5) instance behaves according to the rules defined in <em>devfs.rules</em>. The devfs rules apply to both devices present at boot and devices that appear and disappear dynamically. Rules allow you to set ownership and permissions on device nodes and make device nodes visible or invisible. You cannot create symlinks to device nodes with devfs rules.</p>
<p class="indent">Similar to <em>/etc/rc.conf</em> and <em>/etc/defaults/rc.conf</em>, FreeBSD uses <em>/etc/devfs.rules</em> and <em>/etc/defaults/devfs.rules</em>. Create an <em>/etc/defvs.rules</em> for your custom rules and leave the entries in the defaults file alone.</p>
<h5 class="h5" id="lev507"><strong>devfs Ruleset Format</strong></h5>
<p class="noindent">Each set of devfs rules starts with a name and a ruleset number between square brackets. For example, here’s a devfs rule from the default configuration:</p>
<p class="programs">[<span class="ent">➊</span>devfsrules_hide_all=<span class="ent">➋</span>1]<br/><span class="ent">➌</span>add hide</p>
<p class="indent">The first rule in <em>devfs.rules</em> is called <span class="literal">devfs_hide_all</span> <span class="ent">➊</span> and is ruleset number 1 <span class="ent">➋</span>. This ruleset contains only one rule <span class="ent">➌</span>.</p>
<p class="indent">Once you have a set of devfs rules you like, enable them at boot in <em>/etc/rc.conf</em>. Here, we activate the devfs ruleset named <span class="literal">laptoprules</span>:</p>
<p class="programs">devfs_system_rulesets="laptoprules"</p>
<p class="indent">Remember, devfs rules apply to the devices in the system at boot and the devices configured dynamically after startup.</p>
<h5 class="h5" id="lev508"><strong>Ruleset Content</strong></h5>
<p class="noindent">All devfs rules (in files) begin with the word <span class="literal">add</span>, to add a rule to the ruleset. You then have either a <span class="literal">path</span> keyword and a regex of device names, or a <span class="literal">type</span> keyword and a device type. At the end of the rule, you have an <em>action</em>, or a command to perform. Here’s an example of a devfs rule:</p>
<p class="programs">add path da* user mwlucas</p>
<p class="indent">This rule assigns the user <em>mwlucas</em> ownership of all device nodes with a node name beginning with <span class="literal">da</span>. This is probably a bad idea.</p>
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Devices specified by path use standard shell regular expressions. If you want to match a variety of devices, use an asterisk as a wildcard. For example, <span class="literal">path ada1s1</span> matches exactly the device <em>/dev/ada1s1</em>, but <span class="literal">path ada*s*</span> matches every device node with a name beginning with <span class="literal">ada</span>, a character, the letter <span class="literal">s</span>, and possibly more characters. You could tell exactly what devices are matched by a wildcard by using it at the command line.</p>
<p class="programs"># <span class="codestrong1">ls /dev/ada*s*</span></p>
<p class="indent">This lists all MBR slices and partitions on your SATA hard drives, but not the devices for the entire drive.</p>
<p class="indent">The <span class="literal">type</span> keyword indicates that you want the rule to apply to all devices of a given type. Valid keywords are <span class="literal">disk</span> (disk devices), <span class="literal">mem</span> (memory devices), <span class="literal">tape</span> (tape devices), and <span class="literal">tty</span> (terminal devices, including pseudoterminals). The <span class="literal">type</span> keyword is rarely used exactly because it’s so sweeping.</p>
<p class="indent">If you include neither a <span class="literal">path</span> nor a <span class="literal">type</span>, devfs applies the action at the end of the rule to all device nodes. In almost all cases, this is undesirable.</p>
<p class="indent">The ruleset action can be any one of <span class="literal">group</span>, <span class="literal">user</span>, <span class="literal">mode</span>, <span class="literal">hide</span>, and <span class="literal">unhide</span>. The <span class="literal">group</span> action lets you set the group owner of the device, given as an additional argument. Similarly, the <span class="literal">user</span> action assigns the device owner. Here, we set the ownership of <span class="literal">da</span> disks to the username <em>desktop</em> and the group <em>usb</em>:</p>
<p class="programs">add path da* user desktop<br/>add path da* group usb</p>
<p class="indent">The <span class="literal">mode</span> action lets you assign permissions to the device in standard octal form.</p>
<p class="programs">add path da* mode 664</p>
<p class="indent">The <span class="literal">hide</span> keyword lets you make device nodes disappear, and <span class="literal">unhide</span> makes them reappear. Since no program can use a device node if the device is invisible, this is of limited utility except when the system uses jail(8). Hiding and unhiding makes the most sense when including rules in rules.</p>
<h5 class="h5" id="lev509"><strong>Including Rules in Rules</strong></h5>
<p class="noindent">As in so many parts of systems administration, making devfs rules modular so they can be reused is a good way to reduce problems. The default jail rules show exactly how FreeBSD’s devfs supports reuse, through the <span class="literal">include</span> keyword.</p>
<p class="indent">Here’s the start of the default configuration:</p>
<p class="programs"><span class="ent">➊</span> [devfsrules_hide_all=1]<br/><span class="ent">➋</span> add hide<br/><br/><span class="ent">➌</span> [devfsrules_unhide_basic=2]<br/><span class="ent">➍</span> add path log unhide<br/><span class="ent">➎</span> add path null unhide<br/><span epub:type="pagebreak" id="page_299"/><span class="ent">➏</span> add path zero unhide<br/><span class="ent">➐</span> add path crypto unhide<br/>   --<span class="codeitalic1">snip</span>--</p>
<p class="indent">Rule number one, <span class="literal">devfsrules_hide_all</span> <span class="ent">➊</span>, conceals all device nodes <span class="ent">➋</span>.</p>
<p class="indent">Rule number two, <span class="literal">devfsrules_unhide_basic</span> <span class="ent">➌</span>, contains only a series of <span class="literal">unhide</span> statements. This rule does nothing but unhide critical Unix device nodes, like <em>/dev/log</em> <span class="ent">➍</span>, <em>/dev/null</em> <span class="ent">➎</span>, <em>/dev/zero</em> <span class="ent">➏</span>, <em>/dev/crypto</em> <span class="ent">➐</span>, and so on. Most processes won’t run without these devices. These device nodes are already exposed in a standard system, so why would you need a rule just to unhide them? Similarly, ruleset number three, <span class="literal">devfsrules_unhide_login</span>, does nothing but unhide device nodes for logged-in users.</p>
<p class="indent">The last ruleset leverages all of these.</p>
<p class="programs">[devfsrules_jail=4]<br/>add include $devfsrules_hide_all<br/>add include $devfsrules_unhide_basic<br/>add include $devfsrules_unhide_login<br/>add path zfs unhide</p>
<p class="indent">This ruleset, <span class="literal">devfsrules_jail</span>, uses <span class="literal">include</span> statements to pull in the previous rulesets by reference. The last statement also unhides <em>/dev/zfs</em>, allowing ZFS tools to work within jails.</p>
<p class="indent">If you want to make additional device nodes available within all of your jails, you could add that device node to the jails ruleset. Or you could define a new ruleset and use it for all your jails. Better still, you could define a ruleset for just the jails that absolutely need that device and assign that ruleset to those jails.</p>
<p class="indent">To finish up, let’s look at dynamic devices.</p>
<h4 class="h4" id="lev510"><strong><em>Dynamic Device Management with devd(8)</em></strong></h4>
<p class="noindent">Hot-swappable hardware is now routine. FreeBSD’s devfs dynamically creates new device nodes when this hardware is plugged in and erases the nodes when the hardware is removed, making using these dynamic devices much simpler. The devd(8) daemon takes this a step further by letting you run userland programs when hardware appears and disappears.</p>
<p class="indent">FreeBSD’s default configuration, <em>/etc/devd.conf</em>, handles most modern hardware just fine. If you need to customize devd(8), put your configuration files under <em>/usr/local/etc/devd/</em> to simplify upgrades. You could also add different rules files for different types of devices if you find your devd(8) configuration becoming very complicated.</p>
<h5 class="h5" id="lev511"><strong>devd Configuration</strong></h5>
<p class="noindent">You’ll find four types of devd(8) rules: <span class="literal">attach</span>, <span class="literal">detach</span>, <span class="literal">nomatch</span>, and <span class="literal">notify</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_300"/>The <span class="literal">attach</span> rules are triggered when matching hardware is attached to the system. When you plug in a network card, an <span class="literal">attach</span> rule configures the card with an IP address and brings up the network.</p>
<p class="indent">The <span class="literal">detach</span> rules are triggered when matching hardware is removed from the system. <span class="literal">detach</span> rules are uncommon, as the kernel automatically marks resources unavailable when the underlying hardware disappears, but you might find uses for them.</p>
<p class="indent">The <span class="literal">nomatch</span> rules are triggered when new hardware is installed but not attached to a device driver. These devices don’t have device drivers in the current kernel.</p>
<p class="indent">devd(8) applies <span class="literal">notify</span> rules when the kernel sends a matching event notice to userland. For example, the console message that a network interface has come up is a <span class="literal">notify</span> event. Notifications generally appear on the console or in <em>/var/log/messages</em>.</p>
<p class="indent">Rules also have priority, with 0 being the lowest. Only the highest matching rule is processed, while lower-priority matching rules are skipped. Here’s a sample devd(8) rule:</p>
<p class="programs"><span class="ent">➊</span>notify <span class="ent">➋</span>0 {<br/>          match "system"          <span class="ent">➌</span>"IFNET";<br/>          match "subsystem"       <span class="ent">➍</span>"!usbus[0-9]";<br/>          match "type"            <span class="ent">➎</span>"ATTACH";<br/>          action <span class="ent">➏</span>"/etc/pccard_ether $subsystem start";<br/>};</p>
<p class="indent">This is a <span class="literal">notify</span> rule <span class="ent">➊</span>, which means it activates when the kernel sends a message to userland. As a priority 0 rule <span class="ent">➋</span>, this rule can be triggered only if no rule of higher priority matches the criteria we specify. This rule is triggered only if the notification is on the network system <span class="literal">IFNET</span> <span class="ent">➌</span> (network) and only if the subsystem <span class="ent">➍</span> doesn’t match the expression <span class="literal">usbus[0-9]</span>. It excludes USB network cards. The notification type is <span class="literal">ATTACH</span> <span class="ent">➎</span>—in other words, this matches only when someone plugs in a network interface. If all three of these matches hit, devd(8) runs a command to configure the network interface <span class="ent">➏</span>.</p>
<p class="indent">Read the devd(8) man page to see about all the options you can put in rules. If you want to automatically mount a particular USB flash disk on a certain mount point, you can do that by checking the serial number of every USB device you put in. If you want to configure Intel network cards differently than Atheros network cards, you can do that by checking the vendor. Whatever you need to write a rule for, it’s probably in there somewhere.</p>
<h3 class="h3" id="lev512"><strong>Miscellaneous Filesystems</strong></h3>
<p class="noindent">FreeBSD supports several lesser-known filesystems. Most of them are useful only in bizarre circumstances, but bizarre circumstances arise daily in system administration.</p>
<p class="indent">The process filesystem, procfs(5), contains lots of information about processes. It’s considered a security risk and is officially deprecated on modern FreeBSD releases. You can learn a lot about processes from a mounted <span epub:type="pagebreak" id="page_301"/>process filesystem, however. A few older applications still require a process filesystem mounted on <em>/proc</em>; if a server application requires procfs, try to find a similar application that does the job without requiring it.</p>
<p class="indent">If you’re using Linux mode (see <a href="ch17.xhtml#ch17">Chapter 17</a>), you might need the Linux process filesystem linprocfs(5). Much Linux software requires a process filesystem, and FreeBSD suggests installing linprocfs at <em>/compat/linux/proc</em> when you install Linux mode. I’d recommend installing linprocfs only if a piece of software complains it’s not there.</p>
<p class="indent">The file descriptor filesystem fdesc(5) offers a filesystem view of file descriptors for each process. Some software, notably Java and the popular Bash shell, requires fdescfs(5). It’s less of a security risk than procfs, but still undesirable. You’ll get instructions on mounting fdescfs(5) when you install a package that requires it.</p>
<p class="indent">Now that we’ve talked about local filesystems, let’s look at the network.</p>
<h3 class="h3" id="lev513"><strong>The Network File System</strong></h3>
<p class="noindent">A network filesystem allows accessing files on another machine over the network. The two most commonly used network filesystems are the original Network File System (NFS) implemented in Unix and the CIFS (aka SMB) filesystem popularized by Microsoft Windows. We’ll touch on both of these, but start with the old Unix standard of NFS.</p>
<p class="indent">Sharing directories and partitions between Unix-like systems is perhaps the simplest Network File System you’ll find. FreeBSD supports the Unix standard Network File System out of the box. Configuring NFS intimidates many junior sysadmins, but after setting up a file share or two, you’ll find it not so terribly difficult.</p>
<p class="indent">NFS wasn’t designed as a secure protocol. Do not put NFS servers on the internet without a packet filter or firewall. Merely restricting access at the NFS level is completely inadequate—you must prevent random hosts from poking at the host’s remote procedure call (RPC) services. Restrict access to the host by IP address as well as port number.</p>
<p class="indent">Additionally, standard NFS isn’t encrypted. Anyone with a packet sniffer and access to your wire can see all filesystem activity. Once you deploy Kerberos, you can encrypt NFS, but Kerberos requires its own book.</p>
<p class="indent">Each NFS connection uses a client-server model. One computer is the server; it offers filesystems to other computers. This is called <em>NFS exporting</em>, and the filesystems offered are called <em>exports</em>. The clients can mount server exports in a manner almost identical to that used to mount local filesystems.</p>
<p class="indent">One interesting thing about NFS is its statelessness. NFS doesn’t keep track of the condition of a connection. You can reboot an NFS server and the client won’t crash. It won’t be able to access files on the server’s export while the server is down, but once it returns, you’ll pick up right where things left off. Other network file sharing systems aren’t always so resilient. Of course, statelessness also causes problems; for example, clients can’t know when a file they currently have open is modified by another client.</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_302"/><strong>NFS INTEROPERABILITY</strong></p>
<p class="spara">Every NFS implementation is slightly different. You’ll find minor NFS variations between Solaris, Linux, BSD, and other Unix-like systems. NFS should work between them all but might require the occasional tweak. If you’re having problems with another Unix-like operating system, check the <em>FreeBSD-net</em> mailing list archive; the issue has almost certainly been discussed there.</p>
</div>
<p class="indent">Both NFS servers and clients require kernel options, but the various NFS commands dynamically load the appropriate kernel modules. FreeBSD’s GENERIC kernel supports NFS, so this isn’t a concern for anyone who doesn’t customize their kernel.</p>
<p class="indent">NFS is one of those topics that has entire books written about it. We’re not going to go into the intimate details about NFS, but rather focus on getting basic NFS operations working. If you’re deploying complicated NFS setups, you’ll want to do further research. Even this basic setup lets you accomplish many complicated tasks.</p>
<h4 class="h4" id="lev514"><strong><em>NFS Versions</em></strong></h4>
<p class="noindent">Modern NFS comes in three versions: NFSv2, NFSv3, and NFSv4. FreeBSD can transparently autodetect and interoperate with versions 2 and 3.</p>
<p class="indent">NFSv2 is rather minimal, dating from the time when people were delighted to get file sharing working at all.</p>
<p class="indent">NFSv3 contains many incremental improvements over and much better performance than NFSv2. Most of these improvements don’t even require special configuration.</p>
<p class="indent">NFSv4 is an entirely different and highly complex protocol that breaks many of the long-standing rules of NFS. It was deliberately designed to resemble Microsoft’s file sharing. Understanding NFSv4 requires understanding filesystem extended ACLs, synchronizing user IDs across the network, and other headaches.</p>
<p class="indent">When people say “NFS” they almost always mean NFSv2 or NFSv3. Some folks call these protocols “traditional NFS.” Someone who means NFSv4 usually says “NFSv4.”</p>
<p class="indent">This book sticks with the commonly deployed NFSv2 and NFSv3. I devote a couple chapters to NFSv4 and related topics in <em>FreeBSD Mastery: Specialty Filesystems</em> (Tilted Windmill Press, 2016).</p>
<h4 class="h4" id="lev515"><strong><em>Configuring the NFS Server</em></strong></h4>
<p class="noindent">Turn on NFS server support with the following <em>rc.conf</em> options. While not all of these options are strictly necessary for all environments, turning them all on provides the broadest range of NFS compatibility and decent out-of-the-box performance.</p>
<p class="programs"><span epub:type="pagebreak" id="page_303"/><span class="ent">➊</span> nfs_server_enable="YES"<br/><span class="ent">➋</span> rpcbind_enable="YES"<br/><span class="ent">➌</span> mountd_enable="YES"<br/><span class="ent">➍</span> rpc_lockd_enable="YES"<br/><span class="ent">➎</span> rpc_statd_enable="YES"</p>
<p class="indent">First, tell FreeBSD to load the <em>nfsserver.ko</em> <span class="ent">➊</span> kernel module. Everything will fail if the kernel doesn’t support NFS. The rpcbind(8) <span class="ent">➋</span> daemon maps remote procedure calls (RPCs) into local network addresses. Each NFS client asks the server’s rpcbind(8) daemon where it can find a mountd(8) daemon to connect to. The mountd(8) <span class="ent">➌</span> daemon listens to high-numbered ports for mount requests from clients. Enabling the NFS server also starts nfsd(8), which handles the actual file request. NFS ensures smooth file locking with rpc.lockd(8) <span class="ent">➍</span>, and rpc.statd(8) <span class="ent">➎</span> monitors NFS clients so that the NFS server can free up resources when the host disappears.</p>
<p class="indent">While you can start all of these services at the command line, if you’re just learning NFS, it’s best to reboot your system after enabling the NFS server. Once NFS is running, the output of sockstat(1) will show <span class="literal">rpc.lockd</span>, <span class="literal">rpc.statd</span>, <span class="literal">nfsd</span>, <span class="literal">mountd</span>, and <span class="literal">rpcbind</span> listening. If you don’t see all of these daemons listening to the network, check <em>/var/log/messages</em> for errors.</p>
<p class="indent">The NFS server is designed to seamlessly interoperate a whole bunch of different NFS implementations. While it should transparently autonegotiate connections, you might find that you need to tweak your NFS server nfsd(8) to best fit your clients. Tune nfsd(8) at startup with the <em>rc.conf</em> option <span class="literal">nfs_server_flags</span>.</p>
<p class="indent">NFS can run over TCP or UDP. UDP is the traditional NFS transport protocol. TCP works better over lossy networks and can better cope with irregular network speeds. FreeBSD offers both protocols but defaults to using TCP mounts. Some clients behave better with one protocol or the other. You can explicitly enable only TCP with <span class="literal">-t</span> and only UDP with <span class="literal">-u</span>.</p>
<p class="indent">The NFS server defaults to listening to all IP addresses on a machine. When a server has multiple IP addresses, replies to a UDP request can come from any of those addresses. This can confuse NFS clients. If your NFS server has multiple IP addresses and you have clients that prefer UDP, tell the NFS server to use only a single address with <span class="literal">-h</span> and the server IP.</p>
<p class="indent">While nfsd(8) works well, highly loaded servers might need additional nfsd(8) processes. While FreeBSD starts four nfsd(8) processes by default, you can start additional processes with the <span class="literal">-n</span> flag and the desired number of processes.</p>
<p class="indent">This <em>rc.conf</em> entry tells NFS to use only UDP, bind to the IP address 198.51.100.71, and run six instances of nfsd(8).</p>
<p class="programs">nfs_server_flags="-uh 198.51.100.71 -n 6"</p>
<p class="indent">Before you start tweaking server behavior, though, you really should have some exports.</p>
<h4 class="h4" id="lev516"><span epub:type="pagebreak" id="page_304"/><strong><em>Configuring NFS Exports</em></strong></h4>
<p class="noindent">Now tell your server what it can share, or <em>export</em>. You could export all directories and filesystems on the entire server, but any competent security administrator would have a (justified) fit. As with all server configurations, permit as little access as possible while still letting the server fulfill its role. For example, in most environments, clients have no need to remotely mount the NFS server’s root filesystem.</p>
<p class="indent">FreeBSD lets you configure exports through two different paths. The traditional method is the file <em>/etc/exports</em>. A ZFS-based server can configure exports through each dataset’s <span class="literal">sharenfs</span> property. The server will create the ZFS exports file <em>/etc/zfs/exports</em> based on these properties. Both exports files have the same format.</p>
<p class="indent">Choose one method of managing your NFS exports. Either edit <em>/etc/exports</em>, or use zfs(8). Using both methods simultaneously might merely confuse you but will probably break everything. If you use the ZFS method, never edit <em>/etc/zfs/exports</em> by hand. Stick with one method.</p>
<p class="indent">No matter which method you choose, though, <em>/etc/exports</em> must exist. If you manage NFS through zfs(8), I recommend creating a one-line <em>/etc/exports</em> that contains only a comment telling people to use zfs(8).</p>
<h5 class="h5" id="lev517"><strong>Exports Entries</strong></h5>
<p class="noindent">So how do you configure an export? I’ll start with the exports file <em>/etc/exports</em>, but most everything also applies to using ZFS. I’ll discuss the differences in “<a href="ch13.xhtml#lev524">Managing NFS with zfs(8)</a>” on <a href="ch13.xhtml#page_308">page 308</a>, but understanding those limitations requires understanding <em>/etc/exports</em>.</p>
<p class="indent">Each exports entry has up to three parts:</p>
<ul>
<li class="noindent">Directories or partitions to be exported (mandatory)</li>
<li class="noindent">Options on that export</li>
<li class="noindent">Clients that can connect</li>
</ul>
<p class="indent">Each combination of clients and a disk device can only have one line in the exports file. This means that if <em>/usr/ports</em> and <em>/usr/home</em> are on the same partition and you want to export both of them to a particular client, they must both appear in the same line. You can’t export <em>/usr/ports</em> and <em>/usr/home</em> to one client with different permissions. You don’t have to export the entire disk device, mind you; you can export a single directory within a partition. This directory cannot contain either symlinks or double or single dots.</p>
<p class="indent">NFS mounts don’t cross partitions. If a host has separate UFS partitions for <em>/usr</em> and <em>/usr/src</em>, exporting <em>/usr</em> doesn’t automatically export <em>/usr/src</em>.</p>
<p class="indent">Of the three parts of the <em>/etc/exports</em> entry, only the directory is mandatory. An exports line cannot contain symlinks or periods. To export my home directory to every host on the internet, I could use an <em>/etc/exports</em> line consisting entirely of:</p>
<p class="programs">/home/mwlucas</p>
<p class="indent"><span epub:type="pagebreak" id="page_305"/>This has no options and no host restrictions. Such an export would be foolish, of course, but I could do it.<sup><a href="footnote.xhtml#ch13fn4" id="ch13fn4a">4</a></sup></p>
<p class="indent">After editing the <em>exports</em> file, tell mountd(8) to reread it:</p>
<p class="programs"># <span class="codestrong1">service mountd reload</span></p>
<p class="indent">Any problems with mountd(8) appear in <em>/var/log/messages</em>. The log messages are generally enigmatic: while mountd(8) informs you that a line is bad, it usually doesn’t say why. The most common errors I experience involve symlinks. Use pwd(1) in a directory to get a directory’s actual path.</p>
<h5 class="h5" id="lev518"><strong>NFS and Users</strong></h5>
<p class="noindent">NFSv2 and NFSv3 identify users by UID. (NFSv4 uses usernames because it assumes you’ve synchronized usernames across the entire network.) For example, on my laptop, the user <em>mwlucas</em> has the UID of 1001. On the NFS server, <em>mwlucas</em> also has the UID 1001. This makes my life easy, as I don’t have to worry too much about file ownership; I have the same privileges on the server as on my laptop.</p>
<p class="indent">This can be a problem on a large network, where users have root on their own machines. The best way around this is to create a central repository of authorized users via Kerberos. On a small network or on a network with a limited number of NFS users, this usually isn’t a problem; you can synchronize <em>/etc/master.passwd</em> on your systems or just assign the same UID to each user on each system.</p>
<p class="indent">The root user is handled slightly differently, however. An NFS server doesn’t trust root on other machines to execute commands as root on the server. After all, if an intruder breaks into an NFS client, you don’t want the server to automatically go down with it. NFS defaults to mapping requests from a client’s root account to the UID and GID of –2 on the server. This is where the highly unprivileged <em>nobody</em> account originated.</p>
<p class="indent">The authors of many other server programs thought the nobody account was a great idea, so they appropriated nobody for their own use. Multiple security entities simultaneously running as nobody creates security issues. FreeBSD’s packages create unprivileged users for all applications that need one. I consider the nobody user tainted and suggest you don’t permit its use.</p>
<p class="indent">You can map requests from root to any other username. For example, you might say that all requests from root on a client will run as the <em>nfsroot</em> user on the server. With careful use of groups, you could allow this nfsroot user to have limited file access. Use the <span class="literal">maproot</span> option to map root to another user. Here, we map UID 0 (root) on the client to UID 5000 on the server:</p>
<p class="programs">/usr/home/mwlucas -maproot=5000</p>
<p class="indent"><span epub:type="pagebreak" id="page_306"/>If you really want root on the client to have root privileges on the server, use <span class="literal">-maproot</span> to map root to UID 0. This might be suitable on your home network or on a test system.</p>
<p class="indent">You can’t arbitrarily remap user accounts to each other. In complex environments, be sure you synchronize user accounts and UIDs on all machines on your network.</p>
<p class="indent">NFS users can belong to no more than 16 groups. Some operating systems can break that limit, but they violate the NFS protocols in doing so. If a user can’t access files with group-based access control, check the number of groups that they’re in.</p>
<p class="indent">Remember to restart mountd(8) after editing the exports file.</p>
<h5 class="h5" id="lev519"><strong>Exporting Multiple Directories</strong></h5>
<p class="noindent">A standard FreeBSD UFS install puts all the files on one partition. You might want to export multiple directories on that partition. List all directories on the same partition on the same line in <em>/etc/exports</em>, right after the first exported directory, separated by spaces. Here’s a sample <em>/etc/exports</em> with multiple exports:</p>
<p class="programs">/usr/home/mwlucas /usr/src /var/log /usr/ports/distfiles -maproot=nfsroot</p>
<p class="indent">Clients can mount any of these directories, and requests from root get mapped to nfsroot.</p>
<p class="indent">There are no identifiers, separators, or delimiters between the parts of the line. Yes, it would be easier to read if we could put each shared directory on its own line, but we can’t—they’re all on the same partition. The FreeBSD team could rewrite this so that it had more structure, but then FreeBSD’s <em>/etc/exports</em> would be incompatible with that from any other Unix.</p>
<p class="indent">Perhaps you want clients to be able to mount any directory on a partition. Allow this with the <span class="literal">-alldirs</span> option. I wouldn’t do this on a host with a single partition.</p>
<p class="programs">/home -alldirs</p>
<p class="indent">You can only specify a partition mount point with <span class="literal">-alldirs</span>.</p>
<h5 class="h5" id="lev520"><strong>Long Lines</strong></h5>
<p class="noindent">As with many other configuration files, you can use a backslash to break a single line of configuration into multiple lines. You might find the preceding configuration more readable as:</p>
<p class="programs">/usr/home/mwlucas \<br/>    /usr/src \<br/>    /usr/obj \<br/>    /usr/ports/distfiles \<br/>    -maproot = 5000</p>
<p class="indent"><span epub:type="pagebreak" id="page_307"/>Once your exports line gets long enough, this style suddenly gets more readable than the alternative.</p>
<h5 class="h5" id="lev521"><strong>Restricting Clients</strong></h5>
<p class="noindent">To allow only particular clients to access an NFS export, list them at the end of the <em>/etc/exports</em> entry. Here, we restrict our preceding share to one IP address:</p>
<p class="programs">/usr/home/mwlucas /usr/src /usr/obj /usr/ports/distfiles \<br/>    -maproot=5000 203.0.113.200</p>
<p class="indent">You can also restrict file shares to clients on a particular network by using the <span class="literal">-network</span> and <span class="literal">-mask</span> qualifiers:</p>
<p class="programs">/usr/home/mwlucas /usr/src /usr/obj /usr/ports/distfiles \<br/>    -maproot=5000 -network 203.0.113 -mask 255.255.255.0</p>
<p class="indent">This lets any client with an IP address beginning in 203.0.113 access your NFS server. I use a setup much like this to upgrade clients quickly. I build a new world and kernel on the NFS server and then let the clients mount those partitions and install the binaries over NFS.</p>
<p class="indent">To export to an IPv6 network, include the slash in the address.</p>
<p class="programs">/usr/home/mwlucas -network 2001:db8:bad:c0de::/64</p>
<p class="indent">You can also list hostnames rather than IP addresses, but this creates a dependency on name resolution. If you lose DNS, you’d lose file sharing. Also, the NFS server looks up the IP address of each host when you start mountd. Changing a client’s IP means reloading both DNS and mountd(8). If you must list hostnames, put them at the end of the line.</p>
<p class="programs">/usr/home/mwlucas www1 www2 www3</p>
<p class="indent">Assigning NFS on a per-host basis is more labor. Assign NFS permissions as broadly as possible without compromising security.</p>
<h5 class="h5" id="lev522"><strong>Combinations of Clients and Exports</strong></h5>
<p class="noindent">Each line in <em>/etc/exports</em> specifies exports from one partition to one network, address, or set of hosts. Different hosts require entirely different export statements. You can change the options for each if you wish.</p>
<p class="programs">/usr/home/mwlucas /usr/src /usr/obj /usr/ports/distfiles \<br/>    -maproot=5000 203.0.113.200<br/>/usr -maproot=0 203.0.113.201</p>
<p class="indent">Here, I’ve exported several subdirectories of <em>/usr</em> to the NFS client at 203.0.113.200. The NFS client at 203.0.113.201 gets to mount the whole of <em>/usr</em> and may even do so as root.</p>
<h5 class="h5" id="lev523"><span epub:type="pagebreak" id="page_308"/><strong>NFS and Firewalls</strong></h5>
<p class="noindent">NFS is famous for not liking firewalls. The dynamic port assignment of services like mountd(8), rpc.lockd(8), and rpc.statd(8) makes packet filtering nearly impossible. You can use the <span class="literal">-p</span> flag to assign each of these services a specific TCP port. Here, I use <em>rc.conf</em> entries to nail mountd(8) to port 4046, rpc.lockd(8) to 4045, and rpc.statd(8) to 4047:</p>
<p class="programs">mountd_flags="-r -p 4046"<br/>rpc_lockd_flags="-p 4045"<br/>rpc_statd_flags="-p 4047"</p>
<p class="indent">I can use these ports in my packet filter rules, providing some protection to my NFS server.</p>
<h5 class="h5" id="lev524"><strong>Managing NFS with zfs(8)</strong></h5>
<p class="noindent">Using zfs(8) to manage NFS has advantages and disadvantages. You can configure NFS on a per-dataset basis, and you don’t need to manually restart mountd(8) after each change. Command line configuration is easier to automate, and many folks find it easier to type as well.</p>
<p class="indent">Use the <span class="literal">sharenfs</span> property to enable, disable, and configure NFS exports. Set this property to <span class="literal">on</span> to globally share a dataset and all its descendants. This is equivalent to listing the dataset on its own in <em>/etc/exports</em>. Anyone in the world can mount this dataset or any of its children, with no restrictions and no options, unless you have other access control, such as a firewall.</p>
<p class="programs"># <span class="codestrong1">zfs set sharenfs=on zroot/home</span></p>
<p class="indent">Similarly, set it to <span class="literal">off</span> to unshare the dataset.</p>
<p class="indent">You probably want some NFS options on an export, though. Set <span class="literal">sharenfs</span> to the desired options for the dataset. This example sets a maproot user and restricts clients to my local network. Put the options in quotes.</p>
<p class="programs"># <span class="codestrong1">zfs set sharenfs="-network 203.0.113.0/24 -maproot=nfsroot" zroot/home</span></p>
<p class="indent">The problem with using ZFS to manage your NFS exports is that all permitted hosts get the same options. That is, if most of your hosts need to mount <em>/home</em> with <span class="literal">-maproot=nfsroot</span> but you have one host that needs root to mount that dataset as root, you can’t use ZFS properties. Similarly, you can define only one permitted network with ZFS properties.</p>
<h4 class="h4" id="lev525"><strong><em>Enabling the NFS Client</em></strong></h4>
<p class="noindent">Configuring the NFS client is much simpler. In <em>/etc/rc.conf</em>, put:</p>
<p class="programs">nfs_client_enable="YES"</p>
<p class="indent">You can reboot or run <span class="literal">service nfsclient start</span>. Either starts NFS client functions.</p>
<h5 class="h5" id="lev526"><span epub:type="pagebreak" id="page_309"/><strong>Show Available Mounts</strong></h5>
<p class="noindent">One obvious question for an NFS client to ask would be, “What can I mount from that server?” The showmount(8) command lists all exports available to a client. Give the <span class="literal">-e</span> flag and the name of the NFS server. Here, I ask the storm server what exports it offers:</p>
<p class="programs"># <span class="codestrong1">showmount -e storm</span><br/>Exports list on storm:<br/>/usr/home                          203.0.113.0</p>
<p class="indent">This client is allowed to mount <em>/usr/home</em> under the rule that permits the network 203.0.113.0.</p>
<p class="indent">Running showmount(8) doesn’t offer any server-side options, like <span class="literal">-maproot</span>. These details aren’t readily available to clients, although touch(1) lets you easily test for read-only exports.</p>
<h5 class="h5" id="lev527"><strong>Mounting Exports</strong></h5>
<p class="noindent">Now you can mount directories or filesystems exported by NFS servers. Instead of using a device name, use the NFS server’s hostname and the directory you want to mount. For example, to mount the <em>/home/mwlucas</em> directory from my storm server onto the <em>/mnt</em> directory, I would run:</p>
<p class="programs"># <span class="codestrong1">mount storm:/usr/home/mwlucas /mnt</span></p>
<p class="indent">Afterward, test your mount with df(1).</p>
<p class="programs"># <span class="codestrong1">df -h</span><br/>Filesystem            Size    Used   Avail Capacity  Mounted on<br/>--<span class="codeitalic1">snip</span>--<br/>storm:/usr/home       891G    2.7G    888G     0%    /mnt</p>
<p class="indent">The NFS-mounted directory shows up as a normal partition, and I can read and write files on it as I please.</p>
<h5 class="h5" id="lev528"><strong>NFS Mount Options</strong></h5>
<p class="noindent">FreeBSD uses conservative NFS defaults so that it can interoperate with any other Unix-like operating system. You can use mount options to adjust how FreeBSD mounts NFS exports. Use these options at the command line with <span class="literal">-o</span> or add them to an <em>/etc/fstab</em> entry.</p>
<p class="indent">If you need to access a UDP-only NFS server, use the mount option <span class="literal">udp</span> to use UDP rather than the default TCP.</p>
<p class="indent">Programs expect the filesystem not to disappear, but when you’re using NFS, it’s possible that the server will vanish from the network. This makes programs on the client trying to access the NFS filesystem hang forever. By making your NFS mount <em>interruptible</em>, you’ll be able to interrupt processes hung on unavailable NFS mount with <small>CTRL</small>-C. Set interruptibility with <span class="literal">intr</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_310"/>By using a soft mount, FreeBSD will notify programs that the file they were working on is no longer available. What programs do with that information depends on the program, but they’ll no longer hang forever. Enable soft mounts with the <span class="literal">soft</span> option.</p>
<p class="indent">If you want a read-only mount, use the <span class="literal">ro</span> mount option.</p>
<p class="indent">Putting everything together, I might mount my home directory as an interruptible soft mount.<sup><a href="footnote.xhtml#ch13fn5" id="ch13fn5a">5</a></sup></p>
<p class="programs"># <span class="codestrong1">mount -o soft,intr storm:/usr/home/mwlucas /mnt</span></p>
<p class="indent">I could add this to <em>/etc/fstab</em> as follows:</p>
<p class="programs">storm:/usr/home/mwlucas  /mnt  nfs  rw,soft,intr  0  0</p>
<p class="indent">While NFS is pretty straightforward for simple uses, you can spend many hours adjusting, tuning, and enhancing it. If you wish to build a complicated NFS environment, don’t rely entirely on this brief introduction but spend time with a good book on the subject.</p>
<p class="indent">Now, let’s look at reading Windows shares.</p>
<h3 class="h3" id="lev529"><strong>The Common Internet File System</strong></h3>
<p class="noindent">If you’re on a typical office network, the standard network file sharing protocol is Microsoft’s <em>Common Internet File System (CIFS)</em>. You might know CIFS as Server Message Block (SMB), “Network Neighborhood,” or “Why can’t I mount that drive?” While originally provided only by Microsoft Windows systems, this protocol has become something of a pseudostandard.</p>
<p class="indent">FreeBSD includes the smbutil(8) program to find, mount, and use CIFS shares as a CIFS client. FreeBSD doesn’t include a CIFS server in the base system, but the open source CIFS server Samba (<em><a href="https://www.samba.org/">https://www.samba.org/</a></em>) works well on FreeBSD.</p>
<p class="indent">Use FreeBSD’s CIFS support to interoperate with existing Microsoft infrastructure. Don’t deploy CIFS to support Unix-like systems.</p>
<h4 class="h4" id="lev530"><strong><em>Prerequisites</em></strong></h4>
<p class="noindent">Before you begin working with Microsoft file shares, gather the following information about your Windows network:</p>
<ul>
<li class="noindent">Workgroup or Windows domain name</li>
<li class="noindent">Valid Windows username and password</li>
<li class="noindent">IP address of the Windows DNS server</li>
</ul>
<h4 class="h4" id="lev531"><span epub:type="pagebreak" id="page_311"/><strong><em>Kernel Support</em></strong></h4>
<p class="noindent">FreeBSD uses several kernel modules to support CIFS. The <em>smbfs.ko</em> module supports basic CIFS operations. The <em>libmchain.ko</em> and <em>libiconv.ko</em> modules provide supporting functions and load automatically when you load <em>smbfs.ko</em>. You can compile these statically in your kernel as:</p>
<p class="programs">options    NETSMB<br/>options    LIBMCHAIN<br/>options    LIBICONV<br/>options    SMBFS</p>
<p class="indent">You can load these automatically at boot time with a <em>boot/loader.conf</em> entry.</p>
<p class="programs">smbfs_load=YES</p>
<p class="indent">You can now configure CIFS.</p>
<h4 class="h4" id="lev532"><strong><em>Configuring CIFS</em></strong></h4>
<p class="noindent">CIFS relies on a configuration file, either <em>$HOME/.nsmbrc</em> or <em>/etc/nsmb.conf</em>. All settings in <em>/etc/nsmb.conf</em> override the settings in user home directories. The configuration file is divided into sections by labels in square brackets. For example, settings that apply to every CIFS connection are in the <span class="literal">[default]</span> section. Create your own sections to specify servers, users, and shares, in one of the following formats:</p>
<p class="programs">[<span class="codeitalic1">servername</span>]<br/>[<span class="codeitalic1">servername</span>:<span class="codeitalic1">username</span>]<br/>[<span class="codeitalic1">servername</span>:<span class="codeitalic1">username</span>:<span class="codeitalic1">sharename</span>]</p>
<p class="indent">Information that applies to an entire server goes into a section named after the server. Information that applies to a specific user is kept in a username section, and information that applies to only a single share is kept in a section that includes the sharename. You can lump the information for all the shares under a plain <span class="literal">[</span><span class="codeitalic1">servername</span><span class="literal">]</span> entry if you don’t have more specific per-user or per-share information.</p>
<p class="indent">Configuration entries use the values from the CIFS system—for example, Bert’s Windows username is <em>bertjw</em>, but his FreeBSD username is <em>xistence</em>, so I use <em>bertjw</em> in <em>nsmb.conf</em>.</p>
<h4 class="h4" id="lev533"><strong><em>nsmb.conf Keywords</em></strong></h4>
<p class="noindent">Specify a <em>nsmb.conf</em> configuration with keywords and values under the appropriate section. For example, servers have IP addresses and users don’t, so you would use only an IP address assignment in the server section. To use a keyword, assign a value with an equal sign, as in <em>keyword=value</em>. Here are the common keywords; for a full list, see nsmb.conf(5).</p>
<h5 class="h5" id="lev534"><span epub:type="pagebreak" id="page_312"/><strong>workgroup=string</strong></h5>
<p class="noindent">The <span class="literal">workgroup</span> keyword specifies the name of the Windows domain or workgroup you want to access. This is commonly a default setting used for all servers.</p>
<p class="programs">workgroup=MegaCorp</p>
<h5 class="h5" id="lev535"><strong>addr=a.b.c.d</strong></h5>
<p class="noindent">The <span class="literal">addr</span> keyword sets the IP address of a CIFS server. This keyword can appear only under a plain <span class="literal">[servername]</span> label. You shouldn’t need this if you have working CIFS name resolution, but reality sometimes disagrees.</p>
<h5 class="h5" id="lev536"><strong>nbns=a.b.c.d</strong></h5>
<p class="noindent">The <span class="literal">nbns</span> keyword sets the IP address of a NetBIOS (WINS) nameserver. You can put this line in the default section or under a particular server. If you have Active Directory (which is based on DNS), you can use DNS hostnames. Adding a WINS server won’t hurt your configuration, however, and helps in testing basic CIFS setup.</p>
<h5 class="h5" id="lev537"><strong>password=string</strong></h5>
<p class="noindent">The <span class="literal">password</span> keyword sets a clear-text password for a user or a share. If you must store passwords in <em>/etc/nsmb.conf</em>, be absolutely certain that only root can read the file. Storing a password in <em>$HOME/.nsmbrc</em> is a bad idea on a multiuser system.</p>
<p class="indent">You can scramble your Windows password with <span class="literal">smbutil crypt</span>, generating a string that you can use for this keyword. The scrambled string has double dollar signs (<span class="literal">$$</span>) in front of it. While this helps prevent someone accidentally discovering the password, a malicious user can unscramble it easily.</p>
<p class="programs"># <span class="codestrong1">smbutil crypt superSecretPassword</span><br/>$$1624a53302a6d</p>
<p class="indent">If the server needs access to a CIFS share to do its routine job, don’t use your account. Ask the Windows team for an account for your server so that problems with your account won’t interrupt the server’s functions.</p>
<h5 class="h5" id="lev538"><strong>Sample Configuration</strong></h5>
<p class="noindent">Here, I build an <em>nsmb.conf</em> allowing Bert access to his files on the corporate CIFS fileserver.</p>
<p class="programs">[default]<br/>nbns=203.0.113.12<br/>workgroup=BigCorp<br/>[FILESERVER:bertjw]<br/>password=$$1624a53302a6d</p>
<p class="indent"><span epub:type="pagebreak" id="page_313"/>With this configuration, Bert should be able to access whatever CIFS shares those tyrannical Windows admins permit.</p>
<h4 class="h4" id="lev539"><strong><em>CIFS Name Resolution</em></strong></h4>
<p class="noindent">Before FreeBSD can mount a CIFS share, it needs to identify the host the share is on. While Microsoft has used DNS for decades now, typical Windows environments often support a whole panoply of legacy protocols. Verify that smbutil(1) can find CIFS servers with <span class="literal">smbutil lookup</span>.</p>
<p class="programs"># <span class="codestrong1">smbutil lookup fileserver1</span><br/>Got response from 203.0.113.12<br/>IP address of ntserv1: 203.0.113.4</p>
<p class="indent">If this works, you have basic CIFS functionality.</p>
<h4 class="h4" id="lev540"><strong><em>Other smbutil(1) Functions</em></strong></h4>
<p class="noindent">You can view shares on a host at the command line. Start by logging into your host.</p>
<p class="programs"># <span class="codestrong1">smbutil login //unix@fileserver1</span><br/>Password:</p>
<p class="indent">So, our configuration is correct. Let’s see what resources this server offers with smbutil’s <span class="literal">view</span> command.</p>
<p class="programs"># <span class="codestrong1">smbutil view //unix@fileserver1</span><br/>Password:<br/>Share        Type       Comment<br/>-------------------------------<br/>IPC$         pipe       Remote IPC<br/>ADMIN$       disk       Remote Admin<br/>C$           disk       Default share<br/>unix         disk<br/>4 shares listed from 4 available</p>
<p class="indent">You’ll get a list of every shared resource on the CIFS server. Now, assuming you’re finished, log out of the server.</p>
<p class="programs"># <span class="codestrong1">smbutil logout //unix@fileserver</span></p>
<h4 class="h4" id="lev541"><strong><em>Mounting a Share</em></strong></h4>
<p class="noindent">Now that you’ve finished investigating, mount a share with mount_smbfs(8). The syntax is as follows:</p>
<p class="programs"><span class="codestrong1"># mount_smbfs //</span><span class="codeitalic1">username</span><span class="codestrong1">@</span><span class="codeitalic1">servername</span><span class="codestrong1">/</span><span class="codeitalic1">share</span> <span class="codestrong1">/</span><span class="codeitalic1">mount</span><span class="codestrong1">/</span><span class="codeitalic1">point</span></p>
<p class="indent"><span epub:type="pagebreak" id="page_314"/>I have a share on this Windows box called <em>MP3</em> that I want to access from my FreeBSD system. To mount this as <em>/home/mwlucas/smbmount</em>, I would do this:</p>
<p class="programs"># <span class="codestrong1">mount_smbfs //unix@fileserver1/MP3 /home/mwlucas/smbmount</span></p>
<p class="indent">The mount(8) and df(1) programs show this share attached to your system, and you can access documents on this server just as you could any other filesystem. Use umount(8) to disconnect from the server.</p>
<h4 class="h4" id="lev542"><strong><em>Other mount_smbfs Options</em></strong></h4>
<p class="noindent">mount_smbfs includes several options to tweak the behavior of mounted CIFS filesystems. Use the <span class="literal">-f</span> option to choose a different file permission mode and the <span class="literal">-d</span> option to choose a different directory permission mode. For example, to set a mount so that only I could access the contents of the directory, I would use <span class="literal">mount_smbfs -d 700</span>. This would make the FreeBSD permissions far more stringent than the Windows privileges, but that’s perfectly all right with me. I can change the owner of the files with the <span class="literal">-u</span> option and the group with the <span class="literal">-g</span> option.</p>
<p class="indent">Microsoft filesystems are case insensitive, but Unix-like operating systems are case sensitive. CIFS defaults to leaving the case as it finds it, but that may not be desirable. The <span class="literal">-c</span> flag makes mount_smbfs(8) change the case on the filesystem: <span class="literal">-c l</span> changes everything to lowercase and <span class="literal">-c u</span> changes everything to uppercase.</p>
<h4 class="h4" id="lev543"><strong><em>nsmb.conf Options</em></strong></h4>
<p class="noindent">Here are samples of <em>nsmb.conf</em> entries for different situations. They all assume they’re part of a configuration where you’ve already defined a workgroup, NetBIOS nameserver, and a username with privileges to access the CIFS shares.</p>
<h5 class="h5" id="lev544"><strong>Unique Password on a Standalone System</strong></h5>
<p class="noindent">You’d use something like the following if you have a machine named <em>desktop</em> with a password-protected share. Many standalone Windows systems have this sort of password-protection feature.</p>
<p class="programs">[desktop:<span class="codeitalic1">shareusername</span>]<br/>password=$$1789324874ea87</p>
<h5 class="h5" id="lev545"><strong>Accessing a Second Domain</strong></h5>
<p class="noindent">In this example, we’re accessing a second domain named <em>development</em>. This domain has a username and password different from those at our default domain.</p>
<p class="programs"><span epub:type="pagebreak" id="page_315"/>[development]<br/>workgroup=development<br/>username=support</p>
<h4 class="h4" id="lev546"><strong><em>CIFS File Ownership</em></strong></h4>
<p class="noindent">Ownership of files between Unix-like and Windows systems can be problematic. For one thing, your FreeBSD usernames probably won’t map to Windows usernames, and Unix has a very different permissions scheme compared to Windows.</p>
<p class="indent">Since you’re using a single Windows username to access the share, you have whatever access that account has to the Windows resources, but you must assign the proper FreeBSD permissions for that mounted share. By default, mount_smbfs(8) assigns the new share the same permissions as the mount point. In our earlier example, the directory <em>/home/mwlucas/smbmount</em> is owned by the user <em>mwlucas</em> and has permissions of 755. These permissions say that mwlucas can edit what’s in this directory but nobody else can. Even though FreeBSD says that this user can edit those files, Windows still might not let that particular user edit the files it’s sharing out.</p>
<h3 class="h3" id="lev547"><strong>Serving CIFS Shares</strong></h3>
<p class="noindent">Just as FreeBSD can access CIFS shares, it can also serve them to CIFS clients with Samba. You can find several recent versions of Samba in the packages collection. The Samba website at <em><a href="http://www.samba.org/">http://www.samba.org/</a></em> contains many useful tutorials. Serving CIFS shares from FreeBSD is much more complicated than accessing them, so we’ll end our discussion here before this book grows even thicker.</p>
<p class="indent">We’ve now finished our tour of FreeBSD filesystems. While I’ve spent a few chapters on the topic, FreeBSD has several additional filesystems options, an automounter, and even Filesystem in Userspace (FUSE) support for accessing NTFS, Linux’s extfs, and more. It has special iSCSI support and special filesystems like nullfs(5) that make managing jails at scale very powerful. If I spend any more time on filesystems, though, you’ll track me down and use a blunt instrument to express your displeasure, so let’s proceed to some of FreeBSD’s advanced security features.<span epub:type="pagebreak" id="page_316"/></p>
</body></html>