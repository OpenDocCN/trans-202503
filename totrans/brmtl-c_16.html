<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="237" id="Page_237"/>14</span><br/>
<span class="ChapterTitle">Buffered File I/O</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In the first part of this book, we struggled to get even the simplest output to the console. But for this part of the book, we have an operating system, and that makes dealing with output and input a lot easier. That’s because the operating system hides a great deal of the complexity from you: you just write <code>"Hello World\n"</code>, and the operating system sends the data to the appropriate place.</p>
<p>In this chapter you’ll learn about C’s I/O system, which includes not only the <code>printf</code> function but also functions to read and write disk files in a manner that is both efficient and very flexible.</p>
<h2 id="h1-501621c14-0001"><span epub:type="pagebreak" title="238" id="Page_238"/>The printf Function</h2>
<p class="BodyFirst">We’ve already used the <code>printf</code> function a couple of times for simple output. The basic format of the function is:</p>
<pre><code>printf(<var>format-string</var>, <var>argument</var>, ...)</code></pre>
<p>The format string tells <code>printf</code> what to print. Any character other than percent (<code>%</code>) is printed. The <code>%</code> character starts a field specification, which tells <code>printf</code> to go to the argument list and print the next argument according to the field specification that follows. For example:</p>
<pre><code>printf("Number: -&gt;%d&lt;-\n", 1234);   // Prints  -&gt;1234&lt;-</code></pre>
<p>The <code>%d</code> field specification can be modified with a number:</p>
<pre><code>printf("Number: -&gt;%3d&lt;-\n", 12);    // Prints  -&gt;.12&lt;- (using . for space)
printf("Number: -&gt;%-3d&lt;-\n", 12);   // Prints  -&gt;12.&lt;- (using . for space)
printf("Number: -&gt;%3d&lt;-\n", 1234);  // Prints  -&gt;1234&lt;-(at least 3 characters)</code></pre>
<p>In these examples, <code>%3d</code> tells <code>printf</code> to use at least three characters to print the number. The <code>%-3d</code> field tells <code>printf</code> to print the number with at least three characters and to left-justify it.</p>
<p>So far we’ve discussed only the <code>d</code> conversion character, which is used to covert an integer argument to text for printing. <a href="#table14-1" id="tableanchor14-1">Table 14-1</a> lists the major conversion characters.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table14-1">Table 14-1</a>: Major C Conversion Characters</p></figcaption>
<table id="table-501621c14-0001" border="1">
<thead>
<tr>
<td><b>Conversion character</b></td>
<td><b>Argument type</b></td>
<td><b>Notes</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>%d</code></td>
<td>Integer</td>
<td>The <code>char</code> and <code>short int</code> types are promoted to <code>int</code> when passed as parameters, so this format also works for those three types.</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>Character</td>
<td>Because of promotion, this conversion character actually takes an integer argument and prints it as a character.</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>Integer</td>
<td>Prints in octal.</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>Integer</td>
<td>Prints in hexadecimal.</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>Double</td>
<td>Works for both <code>float</code> and <code>double</code> types because all <code>float</code> parameters are promoted to <code>double</code> when passed as an argument.</td>
</tr>
<tr>
<td><code>%l</code></td>
<td>Long integer</td>
<td>The <code>long int</code> type requires its own conversion because the <code>int</code> type is not automatically promoted to <code>long int</code>.</td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-501621c14-0001"><span epub:type="pagebreak" title="239" id="Page_239"/>Writing the ASCII Table</h3>
<p class="BodyFirst">Let’s write a short program to create a table containing the printable characters with their hex and octal values, which will provide a practical demonstration of the formatting strings. This program (<a href="#listing14-1" id="listinganchor14-1">Listing 14-1</a>) gives us a chance to express the same data four different ways and to try out different formats inside a <code>printf</code> statement.</p>
<p class="CodeLabel"><b>ascii.c</b></p>
<pre><code>/**
 * Print ASCII character table (only printable characters).
 */

#include &lt;stdio.h&gt;

int main()
{
    for (char curChar = ' '; curChar &lt;= '~'; ++curChar) {
        printf("Char: %c Decimal %3d Hex 0x%02x Octal 0%03o\n",
               curChar, curChar, curChar, curChar);
    }
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing14-1">Listing 14-1</a>: A program to create an ASCII table</p>
<p>First, the <code>%c</code> format string prints out the character as a character. Next, we print out the character as a three-digit decimal number (<code>%3d</code>). To be precise, the type of the argument is a character, and it’s promoted to an integer. The number will be three characters long because of the <code>3</code> in the argument specification. After that, we print in hexadecimal using the <code>%02x</code> format. The zero (<code>0</code>) tells <code>printf</code> to pad the result with zeros if needed to match the desired width (the width is, of course, <code>2</code>). Finally, we print in octal with the <code>%03o</code> string.</p>
<p><a href="#listing14-2" id="listinganchor14-2">Listing 14-2</a> shows the output of this program.</p>
<pre><code>Char:   Decimal  32 Hex 0x20 Octal 0040
Char: ! Decimal  33 Hex 0x21 Octal 0041
Char: " Decimal  34 Hex 0x22 Octal 0042
Char: # Decimal  35 Hex 0x23 Octal 0043
Char: $ Decimal  36 Hex 0x24 Octal 0044
Char: % Decimal  37 Hex 0x25 Octal 0045
Char: &amp; Decimal  38 Hex 0x26 Octal 0046
Char: ' Decimal  39 Hex 0x27 Octal 0047
Char: ( Decimal  40 Hex 0x28 Octal 0050
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing14-2">Listing 14-2</a>: The output of <a href="#listing14-1">Listing 14-1</a> (<em>ascii.c</em>)</p>
<p>The <code>printf</code> function is the workhorse of the C I/O system. It helps us get lots of different types of data printed to the console. But that’s not the only place we can write, as we’ll see in the next few sections.</p>
<h3 id="h2-501621c14-0002"><span epub:type="pagebreak" title="240" id="Page_240"/>Writing to Predefined Files</h3>
<p class="BodyFirst">When a program starts, the operating system opens three predefined files:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>stdin</code></span></span>  Standard in, the normal input of the program</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>stdout</code></span></span>  Standard out, for normal program output</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>stderr</code></span></span>  Standard error, for error output</li>
</ol>
<p>By default these files are connected to the console, but your command line interpreter can connect them to disk files, pipes, or other things.</p>
<p>The <code>fprintf</code> function sends data to a given file. For example:</p>
<pre><code>fprintf(stdout, "Everything is OK\n");
fprintf(stderr, "ERROR: Something bad happened\n");</code></pre>
<p>The <code>printf</code> function is merely a convenience function that replaces <code>fprintf(stdout, ...)</code>.</p>
<h2 id="h1-501621c14-0002">Reading Data</h2>
<p class="BodyFirst">The functions that read data are designed to be simple, but unfortunately, they aren’t. The <code>printf</code> function has a counterpart called <code>scanf</code> that reads data. For example:</p>
<pre><code>// Reads two numbers (do not use this code)
scanf("%d %d", &amp;aInteger, &amp;anotherInteger);</code></pre>
<p>First, note the ampersands (<code>&amp;</code>) in front of the arguments, which are used because <code>scanf</code> needs to modify the arguments; therefore, the arguments must be passed by address.</p>
<p>The format string passed to <code>scanf</code> looks a lot like the one for <code>printf</code>, but there is one big problem with <code>scanf</code>: unless you are an extreme expert, you never know how it’s going to deal with whitespace. So, we don’t use it.</p>
<p>Instead, we use the <code>fgets</code> function to get a single line from the input, and then we use <code>sscanf</code> to parse the resulting string:</p>
<pre><code>fgets(line, sizeof(line), stdin);   // Read a line
sscanf(line, "%d %d", &amp;aInteger, &amp;anotherInteger);</code></pre>
<p>The general form of <code>fgets</code> is:</p>
<pre><code>char* <var>result</var> = fgets(<var>buffer</var>, <var>size</var>, <var>file</var>);</code></pre>
<p class="BodyContinued">where <var>result</var> is a pointer to the string that was just read (<var>buffer</var>), or <code>NULL</code> if we’ve reached the end of the file (EOF). The <var>buffer</var> is a character array where the line is to be placed, and <var>file</var> is a file handle indicating which file to read (<code>stdin</code> is the only file we know about at this point).</p>
<p><span epub:type="pagebreak" title="241" id="Page_241"/>The <var>buffer</var> will always be null-terminated (<code>\0</code>), so at most <var>size</var><code>-1</code> characters will be put in <var>buffer</var>. (An entire line will be read, even if <var>buffer</var> is not large enough to contain it.)</p>
<p>The <code>sscanf</code> function is much like the <code>scanf</code> function, only the first argument is now a string. The rest of the arguments are the same. The <code>sscanf</code> function returns the number of items it converted.</p>
<p>The preceding code assumes that everything works. Let’s rewrite it, and this time check for errors:</p>
<pre><code>if (fgets(line, sizeof(line), stdin) == NULL) {
    fprintf(stderr, "ERROR: Expected two integers, got EOF\ n");
    return (ERROR);
}
if (sscanf(line, "%d %d", &amp;aInteger, &amp;anotherInteger) != 2) {
    fprintf(stderr, "ERROR: Expected two integers.\n");
    return (ERROR)
}</code></pre>
<p>If the first call to <code>fgets</code> returns <code>NULL</code>, something went wrong. We then print an error message to the predefined file for errors (<code>stderr</code>) and return an error code to the caller. Next, we perform an <code>sscanf</code>, which should find two integers. If it doesn’t, we again print an error message and return an error code.</p>
<h2 id="h2-501621c14-0003">The Evil gets Function</h2>
<p class="BodyFirst">The <code>fgets</code> function has a corresponding shorthand function to read data from <code>stdin</code>. It’s called <code>gets</code> and has this general form:</p>
<pre><code><var>result</var> = gets(<var>buffer</var>);</code></pre>
<p>The <code>gets</code> function reads in a line of data and puts it in the <var>buffer</var>, <em>whether or not the </em><var>buffer</var><em> can hold it.</em></p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Warning</span></h2>
<p>	The <code>gets</code> function is dangerous to use. <em>Do not use it.</em> It was created in the very early days of computing when computers were rare, and you assumed anyone who used one was smart and honest. Things have changed since then, and people are a lot less honest. Hackers quickly discovered how to send programs that used <code>gets</code> more data than the buffer could handle, in what was called a <em>stack smashing attack</em>. For a time, <code>gets</code> was the most widely available security hole around.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The current GCC compiler makes <code>gets</code> hard to use. First, <em>stdio.h</em> won’t define it unless you properly define a conditional compilation macro. When you compile the program, the compiler will warn you, and then when the program is linked, the linker will warn you.</p>
<p><a href="#listing14-3" id="listinganchor14-3">Listing 14-3</a> shows what happens when you compile a program using <code>gets</code>.</p>
<pre><code>$ <b>gcc -Wall -Wextra -o gets gets.c</b>
Agets.c: In function 'main':
gets.c:17:5: warning: 'gets' is deprecated [-Wdeprecated-declarations]
     gets(line);
<span epub:type="pagebreak" title="242" id="Page_242"/>     ^~~~
In file included from gets.c:11:0:
/usr/include/stdio.h:577:14: note: declared here
 extern char *gets (char *__s) __wur __attribute_deprecated__;
              ^~~~
/tmp/cc5H1KMF.o: In function `main':
gets.c:(.text+0x1f): warning: the `gets' function is dangerous and should not be used.</code></pre>
<p class="CodeListingCaption"><a id="listing14-3">Listing 14-3</a>: Attempting to use <code>gets</code></p>
<p>From the volume of output, you can see how much trouble the GCC compiler goes to in order to persuade you not to use <code>gets</code>.</p>
<p>Now that we’ve taken a look at a few things we shouldn’t use, let’s look at some things we should.</p>
<h2 id="h1-501621c14-0003">Opening Files</h2>
<p class="BodyFirst">The predefined files <code>stdin</code>, <code>stdout</code>, and <code>stdout</code> are file handles. The <code>fopen</code> function allows you to create file handles. <a href="#listing14-4" id="listinganchor14-4">Listing 14-4</a> shows a simple example.</p>
<p class="CodeLabel"><b>file.c</b></p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> FILE* outFile = <span class="CodeAnnotationCode" aria-label="annotation2">2</span> fopen("hello.txt", "w");
    if (outFile == NULL) {
        fprintf(stderr, "ERROR: Unable to open 'hello.txt'\n");
        exit(8);
    }
    if (fprintf(outFile, "Hello World!\n") &lt;= 0) {
        fprintf(stderr, "ERROR: Unable to write to 'hello.txt'\n");
        exit(8);
    }
    if (fclose(outFile) != 0) {
        fprintf(outfile, “ERROR: Unable to close 'hello.txt'\n");
        exit(8);
    }
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing14-4">Listing 14-4</a>: A file version of “Hello World”</p>
<p>First, the <code>FILE*</code> declaration <span class="CodeAnnotation" aria-label="annotation1">1</span> declares a new file handle. All file operations require a file handle. Next we have the <code>fopen</code> call <span class="CodeAnnotation" aria-label="annotation2">2</span>, which has this general form:</p>
<pre><code><var>result</var> = fopen(<var>filename</var>, <var>mode</var>);</code></pre>
<p><span epub:type="pagebreak" title="243" id="Page_243"/>The <var>mode</var> can be one of the following:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>r</code></span></span>  Read only</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>w</code></span></span>  Write only</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>r+</code></span></span>  Read and write</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>a</code></span></span>  Append (write but start at the end of file)</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>b</code></span></span>  Used in combination with the other modes for binary files (discussed in the next section)</li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Beware Microsoft Filenames</h2>
<p class="BoxBodyFirst">Be careful of the Microsoft naming convention that uses the backslash (<code>\</code>) as a separator. If you want to write a file in the top-level directory named <em>root</em> with a filename of <em>file.txt</em> on Linux or macOS, you would use the statement:</p>
<pre><code>FILE* fopen("/root/file.txt", "w);</code></pre>
<p>On Microsoft systems, the following does <em>not</em> work:</p>
<pre><code>// Wrong
FILE* fopen("\root\file.txt", "w);</code></pre>
<p>That’s because the backslash (<code>\</code>) is the escape character, and since <code>\r</code> is the <code>&lt;return&gt;</code> character and <code>\f</code> is the <code>&lt;form-feed&gt;</code> character, you’re trying to write the file:</p>
<pre><code>&lt;return&gt;oot&lt;form-feed&gt;ile.txt</code></pre>
<p>What you want is:</p>
<pre><code>// Right
FILE* fopen("\\root\\file.txt", "w);</code></pre>
<p>By escaping the escape character, you get a literal backslash in the path.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Now that we have the files open, we can read and write to them. Text can be written by <code>fprintf</code> and read by <code>fgets</code>. Next, let’s take a look at the other type of file: binary files.</p>
<h2 id="h1-501621c14-0004"><span epub:type="pagebreak" title="244" id="Page_244"/>Binary I/O</h2>
<p class="BodyFirst">So far we’ve limited ourselves to text files, but the C I/O system can handle binary files through the use of the <code>fread</code> and <code>fwrite</code> functions. The general form of the <code>fread</code> function is:</p>
<pre><code><var>result</var> = fread(<var>buffer</var>, <var>elementSize</var>, <var>size</var>, <var>inFile</var>);</code></pre>
<p>Here, <var>buffer</var> is a pointer to the data buffer in which the data will be placed. The <var>elementSize</var> is always <code>1</code> (see the following box for an explanation). The <var>size</var> is the size of the buffer, which is usually <code>sizeof(</code><var>buffer</var><code>)</code>, and <var>inFile</var> is the file to read.</p>
<p>The function returns the number of items read, which because <var>elementSize</var> is <code>1</code> is the number of bytes read. It returns <code>0</code> for the end of file and a negative number if there is an I/O error.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>elementSize</h2>
<p class="BoxBodyFirst">The original intention was that <var>elementSize</var> would be the size of an element in the <var>buffer</var> array, and <var>size</var> would be the number of elements to read. The result would be the number of elements read. However, as things evolved, almost all programs wanted to read a given number of bytes, not a given number of elements. So, in the real world, <var>elementSize</var> is <code>1</code>, and <var>size</var> is the number of bytes to read.</p>
<p>I have seen code where <var>elementSize</var> was not <code>1</code>. Twice. In 40 years of programming. It is extremely rare for this to occur.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The <code>fwrite</code> function has a similar structure:</p>
<pre><code><var>result</var> = fwrite(<var>buffer</var>, <var>elementSize</var>, <var>size</var>, <var>inFile</var>);</code></pre>
<p class="BodyContinued">Everything is the same, except the data is written instead of read.</p>
<h2 id="h1-501621c14-0005">Copying a File</h2>
<p class="BodyFirst">We’ll use <code>fread</code> and <code>fwrite</code> calls to copy a file. Since we don’t know how to pass arguments on the command line yet (see <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>), the filenames are hardcoded to <em>infile.bin</em> and <em>outfile.bin</em>. <a href="#listing14-5" id="listinganchor14-5">Listing 14-5</a> contains the code.</p>
<p class="CodeLabel"><b>copy.c</b></p>
<pre><code>/**
 * Copy infile.bin to outfile.bin.
 */
  
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
<span epub:type="pagebreak" title="245" id="Page_245"/>
int main()
{
    // The input file
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> FILE* inFile = fopen("infile.bin", "rb");
    if (inFile == NULL) {
        fprintf(stderr, "ERROR: Could not open infile.bin\n");
        exit(8);
    }
    // The output file
    FILE* outFile = fopen("outfile.bin", "wb");
    if (outFile == NULL) {
        fprintf(stderr, "ERROR: Could not create outfile.bin\n");
        exit(8);
    }
    char buffer[512];   // A data buffer

    while (true) {
        // Read data, collect size
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> ssize_t readSize = fread(buffer, 1, sizeof(buffer), inFile);
        if (readSize &lt; 0) {
            fprintf(stderr, "ERROR: Read error seen\n");
            exit(8);
        }
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if (readSize == 0) {
            break;
        }
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if (fwrite(buffer, 1, readSize, outFile) !=(size_t)readSize) {
            fprintf(stderr, "ERROR: Write error seen\n");
            exit(8);
        }
    }
    fclose(inFile);
    fclose(outFile);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing14-5">Listing 14-5</a>: Copying a file</p>
<p>First, note the <code>fopen</code> call <span class="CodeAnnotation" aria-label="annotation1">1</span>. We open the file using the <code>rb</code> mode, which tells the system we’re going to read the file (<code>r</code>) and that the file is binary (<code>b</code>).</p>
<p>Next, let’s take a look at the <code>fread</code> call <span class="CodeAnnotation" aria-label="annotation2">2</span>. The return value for this function is <code>ssize_t</code>, which is a standard type that’s big enough to hold the size of the largest object (structure, array, union) that can possibly exist. It also can hold <code>–1</code> to indicate an error condition.</p>
<p>If we’ve read all the data from the file, <code>fread</code> returns <code>0</code>. When that happens, we’re done, so we exit the main loop <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Now we come to the <code>fwrite</code> call <span class="CodeAnnotation" aria-label="annotation4">4</span>, which returns a <code>size_t</code> value. This is an unsigned type that holds the size of the largest object you can put in a program, but because it’s unsigned, it cannot hold an error value. What happens when <code>fwrite</code> gets an error when writing something? It writes as much as it can and returns the number of bytes written, so it will never return an error code, just a short write.</p>
<p><span epub:type="pagebreak" title="246" id="Page_246"/>Note that <code>fread</code> returns an <code>ssize_t</code> result and <code>fwrite</code> returns a <code>size_t</code> result. There are good reasons for this, but it means that if we check to see whether the number of bytes we tried to write is the same as the number we actually asked <code>fwrite</code> to write, we get a compiler warning:</p>
<pre><code>35          if (fwrite(<var>buffer</var>, 1, <var>readSize</var>, <var>outFile</var>) != <var>readSize</var>) {
                                      Warning: signed vs. unsigned compare</code></pre>
<p>To get rid of the warning, we need to insert a cast, thus telling C, “Yes, I know we are mixing signed and unsigned types, but we have to do it because of the stupid way <code>fread</code> and <code>fwrite</code> are defined”:</p>
<pre><code>if (fwrite(<var>buffer</var>, 1, <var>readSize</var>, <var>outFile</var>) != (size_t)<var>readSize</var>) {</code></pre>
<p>Also note that on the last read we probably won’t get a full 512 bytes. That’s why we are using <var>readSize</var> in the <code>fwrite</code> statement instead of <code>sizeof(</code><var>buffer</var><code>)</code>.</p>
<h2 id="h1-501621c14-0006">Buffering and Flushing</h2>
<p class="BodyFirst">The C I/O system uses <em>buffered I/O</em>, which means that when you do a <code>printf</code> or <code>fwrite</code>, the data may not be sent to the output device immediately. Instead, it will be stored in memory until the system has enough data to make things efficient.</p>
<p>Data going to the console is <em>line buffered</em>, which means that if you print part of a line, it might not go out until the rest of the line is sent. Let’s see how this can get us into trouble with the program in <a href="#listing14-6" id="listinganchor14-6">Listing 14-6</a>.</p>
<pre><code>/**
 * Demonstrate how buffering can fool
 * us with a divide-by-zero bug.
 */
  
#include &lt;stdio.h&gt;

int main()
{
    int zero = 0;    // The constant zero, to trick the
                     // compiler into letting us divide by 0
    int result;      // Something to put a result in
     
    printf("Before divide ");
    result = 5 / zero;
    printf("Divide done\n");
    printf("Result is %d\n", result);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing14-6">Listing 14-6</a>: Dividing by zero</p>
<p><span epub:type="pagebreak" title="247" id="Page_247"/>When running this program, you would expect to see the following output:</p>
<pre><code>Before divide Floating point exception (core dumped)</code></pre>
<p>But what you actually see is this:</p>
<pre><code>Floating point exception (core dumped)</code></pre>
<p>Your first thought might be that <code>printf</code> did not execute, but it did. The data went into a buffer and was sitting in the buffer when the program aborted, giving a false indication that <code>printf</code> did not work.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Integer divide by zero results in a floating-point exception (core dumped) and aborts the program. Floating point divide by zero causes a <code>NaN</code> value to be assigned to the result, and the program will not abort. There’s a lot of history around this behavior. The term <em>core dumped</em> is a holdover from when computer memory actually consisted of ferrite cores. As to the floating-point exception for integer divides, it was an old oddity when I started programming, and I still don’t know why things were done this way.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To fix this problem, we need to tell the I/O system “write the buffered data out now,” which is done with the <code>fflush</code> function:</p>
<pre><code>    printf("Before divide ");   fflush(stdout);</code></pre>
<p>Flushing out the data ensures that we can see it. On the other hand, we don’t want to flush after every write, as that would defeat the purpose of buffering, which is to make I/O more efficient.</p>
<h2 id="h1-501621c14-0007">Closing Files</h2>
<p class="BodyFirst">Finally, after we’re done with a file, we need to tell C that we’re finished with it. We do this using the <code>fclose</code> function:</p>
<pre><code>int <var>result</var> = fclose(<var>file</var>);</code></pre>
<p class="BodyContinued">where <var>file</var> is the <code>FILE*</code> to close and <var>result</var> is <code>0</code> if it worked or nonzero if it didn’t.</p>
<h2 id="h1-501621c14-0008">Summary</h2>
<p class="BodyFirst">In the embedded world, I/O is difficult because you have to write code to deal directly with the device, and you need to write different code for every different type of device.</p>
<p><span epub:type="pagebreak" title="248" id="Page_248"/>The C I/O system is designed to hide all those details from you. It also provides a lot of nice features, such as formatting, buffering, and device independence. The buffered I/O system works well for most general applications.</p>
<h2 id="h1-501621c14-0009">Programming Problems</h2>
<ol class="decimal">
<li value="1">See what happens when you put too many or too few parameters in a <code>printf</code> statement. What happens when you put the wrong type (for example, <code>double</code> instead of <code>int</code>)?</li>
<li value="2">Write a program that asks the user for a temperature in Centigrade and converts it to Fahrenheit.</li>
<li value="3">Write a program that counts the number of words in a file. Be sure you document the definition of “word,” as some people’s idea of a word may be different from yours.</li>
<li value="4">Write a program that compares two files line by line and writes out the lines that differ.</li>
</ol>
</section>
</body></html>