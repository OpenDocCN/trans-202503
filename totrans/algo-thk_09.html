<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_331"/><strong><span class="big">9</span><br/>UNION-FIND</strong></h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindent">We used the adjacency list data structure—and algorithms on it—to solve graph problems in <a href="ch05.xhtml">Chapters 5</a> and <a href="ch06.xhtml">6</a>. That’s an efficient data structure that works no matter the graph problem. However, if we constrain the types of problems we want to solve, we can design an even more efficient data structure. Constrain the problems just a little, and we likely wouldn’t be able to do any better than an adjacency list. Constrain them too much, and few people would use our data structure because it would be unlikely to solve problems that they cared about solving. Constrain the problems just right and you have the union-find data structure, the topic of this chapter. It solves graph problems—not all, only some. For the ones it does solve, though, it’s much faster than a general-purpose graph data structure.</p>
<p class="indent">Keeping track of communities in a social network, maintaining groups of friends and enemies, and organizing items into specified drawers are all <span epub:type="pagebreak" id="page_332"/>graph problems. Importantly, they’re special graph problems, ones that can be solved with incredible speed by using union-find. Let’s do this!</p>
<h3 class="h3" id="lev57">Problem 1: Social Network</h3>
<p class="noindent">This is SPOJ problem <code>SOCNETC</code>.</p>
<h4 class="h4" id="sec137"><em>The Problem</em></h4>
<p class="noindent">You are asked to write a program that tracks the people and communities in a social network.</p>
<p class="indent">There are <em>n</em> people, numbered 1, 2, . . . , <em>n</em>.</p>
<p class="indent">A <em>community</em> is a person plus that person’s friends, their friends’ friends, their friends’ friends’ friends, and so on. For example, if Person 1 and Person 4 are friends, and Person 4 and Person 5 are friends, then this community consists of the three people, 1, 4, and 5. People in the same community are all friends with each other.</p>
<p class="indent">Each person starts in a community alone; the person’s community can get bigger as friendships between people are made.</p>
<p class="indent">Your program must support three operations:</p>
<p class="block"><strong>Add</strong>   Make the two provided people be friends. If this operation takes place, and if these people were not in the same community before, then they will be in the same (larger) community now.</p>
<p class="block"><strong>Examine</strong>   Report whether the two provided people are in the same community.</p>
<p class="block"><strong>Size</strong>   Report the number of people who are in the provided person’s community.</p>
<p class="indent">Your program will run on a computer with limited resources, so there is a parameter <em>m</em> that gives the maximum number of people in a community. We’re required to ignore any Add operation that would result in a community with more than <em>m</em> people.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing <em>n</em>, the number of people in the social network, and <em>m</em>, the maximum number of people allowed in a community. <em>n</em> and <em>m</em> are between 1 and 100,000.</li>
<li class="noindent">A line containing integer <em>q</em>, the number of operations to follow. <em>q</em> is between 1 and 200,000.</li>
<li class="noindent"> <em>q</em> lines, one for each operation.</li>
</ul>
<p class="indent">Each of the <em>q</em> lines can be one of the following operations:</p>
<ul>
<li class="noindent">An Add operation is of the form <code>A</code> <span class="codeitalic">x y</span>, where <span class="codeitalic">x</span> and <span class="codeitalic">y</span> are people.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_333"/>An Examine operation is of the form <code>E</code> <span class="codeitalic">x y</span>, where <span class="codeitalic">x</span> and <span class="codeitalic">y</span> are people.</li>
<li class="noindent">A Size operation is of the form <code>S</code> <span class="codeitalic">x</span>, where <span class="codeitalic">x</span> is a person.</li>
</ul>
<h5 class="h5"><strong>Output</strong></h5>
<p class="noindent">There is no output for an Add operation. The output for each Examine and Size operation is on its own line.</p>
<p class="block"><strong>Examine</strong>   For an Examine operation, output <code>Yes</code> if the two people are in the same community, and output <code>No</code> otherwise.</p>
<p class="block"><strong>Size</strong>   For a Size operation, output the number of people in the person’s community.</p>
<p class="indent">The time limit for solving the test case is one second.</p>
<h4 class="h4" id="sec138"><em>Modeling as a Graph</em></h4>
<p class="noindent">In <a href="ch05.xhtml">Chapters 5</a> and <a href="ch06.xhtml">6</a>, we practiced at length framing problems as graph explorations. We figured out what to use as the nodes and what to use as the edges and then used BFS or Dijkstra’s algorithm to explore the graph.</p>
<p class="indent">We can similarly model a social network as a graph. The nodes are the people in the social network. If the test case tells us that <em>x</em> and <em>y</em> are friends, then we can add an edge between node <em>x</em> and node <em>y</em>. The graph is undirected, because friendship between two people is mutual.</p>
<p class="indent">One key difference compared to the problems that we previously solved in <a href="ch05.xhtml">Chapters 5</a> and <a href="ch06.xhtml">6</a> is that the social network graph is dynamic. Each time we process an Add operation between two people that are not yet friends, we add a new edge to the graph. Compare that to <a href="ch05.xhtml">Chapter 5</a>’s Book Translation. There, we knew all of the languages and translators at the outset, so we could build the graph once and never have to update it.</p>
<p class="indent">Let’s use a test case to animate how our graph grows and to observe how the graph helps us implement the three required operations (Add, Examine, and Size). Here it is:</p>
<pre>7 6
11
A 1 4
A 4 5
A 3 6
E 1 5
E 2 5
A 1 5
A 2 5
A 4 3
S 4
A 7 6
S 4</pre>
<p class="indent"><span epub:type="pagebreak" id="page_334"/>We start with seven people and no friendship connections, like this:</p>
<div class="imagec"><img alt="image" src="../images/unch09fig01.jpg"/></div>
<p class="indent">The <code>A 1 4</code> operation makes People 1 and 4 friends, so we add an edge between those two nodes:</p>
<div class="imagec"><img alt="image" src="../images/unch09fig02.jpg"/></div>
<p class="indent">The <code>A 4 5</code> operation does similarly for People 4 and 5:</p>
<div class="imagec"><img alt="image" src="../images/unch09fig03.jpg"/></div>
<p class="indent">For <code>A 3 6</code>, we get:</p>
<div class="imagec"><img alt="image" src="../images/unch09fig04.jpg"/></div>
<p class="indent">The next operation is <code>E 1 5</code>, which asks us whether People 1 and 5 are in the same community. The graph answers this for us: if there is a path from Node 1 to Node 5 (or, equivalently, from Node 5 to Node 1), then they are in the same community; otherwise, they are not. In this case, they are; the path from Node 1 to Node 4 to Node 5 is a path from Node 1 to Node 5.</p>
<p class="indent">The next operation is <code>E 2 5</code>. There’s no path between Nodes 2 and 5, so these two people are not in the same community.</p>
<p class="indent">Next we have <code>A 1 5</code>, which will add an edge between Nodes 1 and 5. (Notice how we’re interleaving operations that modify the graph with operations that query the graph.) Here’s the result:</p>
<div class="imagec"><span epub:type="pagebreak" id="page_335"/><img alt="image" src="../images/unch09fig05.jpg"/></div>
<p class="indent">The addition of this edge caused a cycle, because it added a friendship link between two people who were already in the same community. Therefore, this new edge doesn’t have any impact on the number of communities or their size. We could have left it out, but I’ve decided here to include all allowed friendship links.</p>
<p class="indent">Now consider <code>A 2 5</code>, which does unite two communities:</p>
<div class="imagec"><img alt="image" src="../images/unch09fig06.jpg"/></div>
<p class="indent">Next we have <code>A 4 3</code>, which again unites two communities:</p>
<div class="imagec"><img alt="image" src="../images/unch09fig07.jpg"/></div>
<p class="indent">Now we have our first Size operation: <code>S 4</code>. How many people are in Person 4’s community? This amounts to determining the number of nodes reachable from Node 4. There are six such nodes, with the only unreachable node being Node 7, so the answer is <code>6</code>.</p>
<p class="indent">Now, consider <code>A 7 6</code>. We must add the edge between Nodes 7 and 6 . . . whoa there! This edge would cause the formation of a new community with all seven people, but the test case forces an upper limit of six people in any given community. We must ignore this Add operation.</p>
<p class="indent"><span epub:type="pagebreak" id="page_336"/>For that reason, the answer to the final operation, <code>S 4</code>, is the same as it was before: <code>6</code>.</p>
<p class="indent">The correct output for our test case is:</p>
<pre>Yes
No
6
6</pre>
<p class="indent">This example shows what is needed to implement each operation. For Add, we add a new edge to the graph, unless that edge would produce a community with too many people. For Examine, we determine whether there is a path between two nodes or, equivalently, whether one node is reachable from the other. We can use BFS for that! For Size, we determine the number of nodes reachable from a given node. We can use BFS again!</p>
<h4 class="h4" id="sec139"><em>Solution 1: BFS</em></h4>
<p class="noindent">Let’s take this graph-based solution in two steps. First, I’ll show the <code>main</code> function that processes the operations, progressively building the graph as it goes. Then, I’ll show the BFS code.</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">We need a constant and a struct to begin:</p>
<pre>#define MAX_PEOPLE 100000

typedef struct edge {
  int to_person;
  struct edge *next;
} edge;</pre>
<p class="indent">The <code>main</code> function is given in <a href="ch09.xhtml#ch09ex01">Listing 9-1</a>. It reads the input, and it responds to the operations by incrementally building and querying the graph.</p>
<pre>int main(void) {
  static edge *adj_list[MAX_PEOPLE + 1] = {NULL};
  static int min_moves[MAX_PEOPLE + 1];
  int num_people, num_community, num_ops, i;
  char op;
  int person1, person2;
  edge *e;
  int size1, size2, same_community;
  scanf("%d%d", &amp;num_people, &amp;num_community);
  scanf("%d", &amp;num_ops);

  for (i = 0; i &lt; num_ops; i++) {
    scanf(" %c", &amp;op);
<span epub:type="pagebreak" id="page_337"/>    <span class="ent">❶</span> if (op == 'A') {
         scanf("%d%d", &amp;person1, &amp;person2);
      <span class="ent">➋</span> find_distances(adj_list, person1, num_people, min_moves);
      <span class="ent">➌</span> size1 = size(num_people, min_moves);
         same_community = 0;
      <span class="ent">➍</span> if (min_moves[person2] != -1)
           same_community = 1;
      <span class="ent">➎</span> find_distances(adj_list, person2, num_people, min_moves);
      <span class="ent">➏</span> size2 = size(num_people, min_moves);
      <span class="ent">❼</span> if (same_community || size1 + size2 &lt;= num_community) {
           e = malloc(sizeof(edge));
           if (e == NULL) {
             fprintf(stderr, "malloc error\n");
             exit(1);
          }
          e-&gt;to_person = person2;
          e-&gt;next = adj_list[person1];
          adj_list[person1] = e;
          e = malloc(sizeof(edge));
          if (e == NULL) {
            fprintf(stderr, "malloc error\n");
            exit(1);
          }
          e-&gt;to_person = person1;
          e-&gt;next = adj_list[person2];
          adj_list[person2] = e;
        }
     }
 
   <span class="ent">❽</span> else if (op == 'E') {
        scanf("%d%d", &amp;person1, &amp;person2);
        find_distances(adj_list, person1, num_people, min_moves);
        if (min_moves[person2] != -1)
          printf("Yes\n");
        else
          printf("No\n");
     }
 
  <span class="ent">❾</span> else {
       scanf("%d", &amp;person1);
       find_distances(adj_list, person1, num_people, min_moves);
       printf("%d\n", size(num_people, min_moves));
     }
  }
  return 0;
}</pre>
<p class="excap" id="ch09ex01"><em>Listing 9-1: The</em> <span class="codeitalic1">main</span> <em>function for processing operations</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_338"/>As we did in Book Translation in <a href="ch05.xhtml">Chapter 5</a> and in the problems in <a href="ch06.xhtml">Chapter 6</a>, we use an adjacency list representation of the graph.</p>
<p class="indent">Let’s see how the code handles each of the three types of operations, starting with Add <span class="ent">❶</span>. We call the helper function <code>find_distances</code> <span class="ent">➋</span>. That function, as we’ll see shortly, implements the BFS: it fills <code>min_moves</code> with the shortest path in the graph from <code>person1</code> to each person, using a value of <code>-1</code> for any person that is not reachable. Then, we call helper function <code>size</code> <span class="ent">➌</span>, which uses distance information in <code>min_moves</code> to determine the size of <code>person1</code>’s community. We next determine whether <code>person1</code> and <code>person2</code> are in the same community: if <code>person2</code> is reachable from <code>person1</code>, then they’re in the same community <span class="ent">➍</span>. We need this information to determine whether to add the edge: if the people are already in the same community, then the edge can be safely added without worrying about creating a community that violates the constraint on the maximum number of people in a community.</p>
<p class="indent">Having found the size of <code>person1</code>’s community, we do the same for <code>person2</code>’s community: first invoking BFS for <code>person2</code> <span class="ent">➎</span> and then computing the community’s size <span class="ent">➏</span>.</p>
<p class="indent">Now, if there’s no new community, or if the new community is small enough <span class="ent">❼</span>, then we add the edge to the graph. Actually, we add two edges, because, remember, the graph is undirected.</p>
<p class="indent">The other operations take less code. For Examine <span class="ent">❽</span>, we run the BFS and check whether <code>person2</code> is reachable from <code>person1</code>. For Size <span class="ent">❾</span>, we run the BFS and then count the number of nodes reachable from <code>person1</code>.</p>
<h5 class="h5">The BFS Code</h5>
<p class="noindent">The BFS code we need here is very similar to the BFS code we wrote when solving Book Translation in <a href="ch05.xhtml">Chapter 5</a>, except without the book translation costs. See <a href="ch09.xhtml#ch09ex02">Listing 9-2</a>.</p>
<pre>void add_position(int from_person, int to_person,
                  int new_positions[], int *num_new_positions,
                  int min_moves[]) {
  if (min_moves[to_person] == -1) {
    min_moves[to_person] = 1 + min_moves[from_person];
    new_positions[*num_new_positions] = to_person;
    (*num_new_positions)++;
  }
}

void find_distances(edge *adj_list[], int person, int num_people,
                    int min_moves[]) {
  static int cur_positions[MAX_PEOPLE + 1], new_positions[MAX_PEOPLE + 1];
  int num_cur_positions, num_new_positions;
  int i, from_person;
  edge *e;
  for (i = 1; i &lt;= num_people; i++)
    min_moves[i] = -1;
  min_moves[person] = 0;<span epub:type="pagebreak" id="page_339"/>
  cur_positions[0] = person;
  num_cur_positions = 1;

  while (num_cur_positions &gt; 0) {
    num_new_positions = 0;
    for (i = 0; i &lt; num_cur_positions; i++) {
      from_person = cur_positions[i];
      e = adj_list[from_person];
   
      while (e) {
        add_position(from_person, e-&gt;to_person,
                     new_positions, &amp;num_new_positions, min_moves);
        e = e-&gt;next;
      }
    }
 
    num_cur_positions = num_new_positions;
    for (i = 0; i &lt; num_cur_positions; i++)
      cur_positions[i] = new_positions[i];
  }
}</pre>
<p class="excap" id="ch09ex02"><em>Listing 9-2: Minimum distance to people using BFS</em></p>
<h5 class="h5">Finding the Size of a Community</h5>
<p class="noindent">The last little helper function to write is <code>size</code>, which returns the number of people in a given person’s community. See <a href="ch09.xhtml#ch09ex03">Listing 9-3</a>.</p>
<pre>int size(int num_people, int min_moves[]) {
  int i, total = 0;
  for (i = 1; i &lt;= num_people; i++)
    if (min_moves[i] != -1)
      total++;
  return total;
}</pre>
<p class="excap" id="ch09ex03"><em>Listing 9-3: The size of a person’s community</em></p>
<p class="indent">In this function, it is assumed that <code>min_moves</code> has already been filled in by <code>find_distances</code>. Every person whose <code>min_moves</code> value is not <code>-1</code> is therefore reachable. We use <code>total</code> to add up those reachable people.</p>
<p class="indent">There we have it: a graph-based solution. For each of the <em>q</em> operations, we run one BFS. At worst, each operation adds one edge to the graph, so each BFS call does work proportional to at most <em>q</em>. We therefore have an <em>O</em>(<em>q</em><sup>2</sup>), or quadratic, algorithm.</p>
<p class="indent">In <a href="ch05.xhtml">Chapter 5</a>, I advised you that it’s important not to run BFS too many times. It’s best to make just one BFS call, if you can get away with that. Even a few calls can be okay. After all, we got away with making a BFS call for each pawn position when solving Knight Chase on <a href="ch05.xhtml#lev32">page 151</a>. The same sentiment <span epub:type="pagebreak" id="page_340"/>applies to Dijkstra’s algorithm from <a href="ch06.xhtml">Chapter 6</a>: make as few calls as possible. Here again, making a few calls is okay. We solved Mice Maze on <a href="ch06.xhtml#lev38">page 198</a> using about 100 calls of Dijkstra, and it was fast enough. Thriftless use of graph search hasn’t bitten us yet.</p>
<p class="indent">It does bite us now, though. If you submit your solution to the judge, you’ll get a “Time-Limit Exceeded” error—and it isn’t even close. I’m playing around with an example here on my laptop with 100,000 people in the social network and 200,000 operations. The operations are divided equally among Add, Examine, and Size operations. Our graph-based solution takes over two minutes to run. You’re about to learn a new data structure called union-find that, on the same example, runs 300 times faster. Union-find is an efficiency beast.</p>
<h4 class="h4" id="sec140"><em>Union-Find</em></h4>
<p class="noindent">For two reasons, BFS on a graph is not a satisfactory solution to the Social Network problem. First, it produces too much! It determines shortest paths between people. For example, it might tell us that the shortest path between People 1 and 5 is two, but who cares? All we want to know is whether or not two people are in the same community. How they ended up in the same community and the chain of friendships that connect them are not of interest.</p>
<p class="indent">Second, it remembers too little—or, rather, it remembers nothing: BFS starts afresh with each call. However, think about how wasteful this is. For example, an Add operation adds just one edge to the graph. The communities can’t be much different than they were before. BFS doesn’t use past information at all, instead reprocessing the complete graph on the next operation.</p>
<p class="indent">The goal, then, is to devise a data structure that doesn’t remember anything about shortest paths and that does only a little work when a new friendship is made.</p>
<h5 class="h5">Operations</h5>
<p class="noindent">The Add operation unites two communities into one. (Well, it does nothing when the resulting community would be too big or when two people are in the same community, but when it does something, it unites two communities.) This kind of operation is referred to in the algorithms world as a <em>Union</em>. In general, a Union replaces two sets by one larger set containing all of their elements.</p>
<p class="indent">The Examine operation tells us whether the two provided people are in the same community. One way to implement this is to designate one element of each community as its <em>representative</em> element. For example, a community with People 1, 4, and 5 might have 4 as its representative; a community with People 3 and 6 might have 3 as its representative. Are People 1 and 5 in the same community? Yes, because the representative of Person 1’s community (4) is the same as the representative of Person 5’s community (4). Are People 4 and 6 in the same community? No, because <span epub:type="pagebreak" id="page_341"/>the representative of Person 4’s community (4) is not the same as the representative of Person 6’s community (3).</p>
<p class="indent">Determining the representative of a person’s community is called a <em>Find</em>. We can implement Examine with two Finds: find the representative of the first person’s community, find the representative of the second person’s community, and compare them.</p>
<p class="indent">Since an Add is a Union and an Examine is a Find, data structures that implement these two operations are known as <em>union-find</em> data structures.</p>
<p class="indent">Once we have Union and Find working, we’ll be in great shape to support Size operations as well. All we’ll do is store the size of each community, being sure to keep sizes up to date whenever we do a Union. We’ll then be able to respond to each Size operation by returning the size of the appropriate community.</p>
<h5 class="h5" id="ch09lev2z">Array-Based Approach</h5>
<p class="noindent">One idea is to use an array <code>community_of</code> that indicates the representative for each person’s community. For example, if People 1, 2, 4, and 5 are in the same community, People 3 and 6 are in the same community, and Person 7 is in their own community, then the array might look like this:</p>
<div class="image1"><img alt="Image" src="../images/pg341-01.jpg"/></div>
<p class="indent">For a community of a single person, there is no choice for who is the representative. That’s why the representative for Person 7 is 7. In a community with multiple people, the representative is allowed to be any person in the community. For example, we’re using 6 as a representative this time, but we could have used 3 instead.</p>
<p class="indent">Using this scheme, we can implement Find in constant time. All we do is look up the representative of the desired person, like this:</p>
<pre>int find(int person, int community_of[]) {
  return community_of[person];
}</pre>
<p class="noindent">You can’t do better than that!</p>
<p class="indent">Unfortunately, this scheme breaks down when we implement Union. Our only option is to change all representatives for one community to the representative of the other community. It would look like this:</p>
<pre>void union_communities(int person1, int person2,
                       int community_of[], int num_people) {
  int community1, community2, i;
  community1 = find(person1, community_of);
  community2 = find(person2, community_of);
  for (i = 1; i &lt;= num_people; i++)
    if (community_of[i] == community1)
      community_of[i] = community2;
}</pre>
<p class="indent"><span epub:type="pagebreak" id="page_342"/>I’m ignoring the maximum size restriction on social-network communities here so as not to distract from the essentials. The code uses <code>find</code> to set <code>community1</code> and <code>community2</code> to the representatives of <code>person1</code>’s community and <code>person2</code>’s community, respectively. It then loops through all people, changing anyone in <code>community1</code> to <code>community2</code>. The effect is that <code>community1</code> is gone, having been absorbed into <code>community2</code>.</p>
<p class="indent">If you build and submit a full solution based on the code I’ve given here, you should see that it still receives a “Time-Limit Exceeded” error. We need a better way to union two communities than looping through all of the people.</p>
<h5 class="h5">Tree-Based Approach</h5>
<p class="noindent">The most efficient union-find data structures are based on trees. Each set is represented as its own tree, with the root of the tree serving as that set’s representative. I’ll describe how this works with the help of the example shown in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a>.</p>
<div class="image"><img alt="image" id="ch09fig01" src="../images/ch09fig01.jpg"/></div>
<p class="figcap"><em>Figure 9-1: A tree-based union-find data structure</em></p>
<p class="indent">There are three trees here, so there are three distinct communities: one has People 1, 2, 4, and 5; one has People 3 and 6; and one has Person 7. Each tree’s roots—People 5, 6, and 7—serve as community representatives.</p>
<p class="indent">I’ve drawn the tree edges with an arrow pointing from child to parent. You haven’t seen that before in this book. The reason I’m doing it now is to emphasize the way that we’ll be navigating these trees. As I describe how to support Find and Union in trees, we’ll see that it’s necessary to move up the tree (from child to parent) but never down.</p>
<p class="indent">Let’s start with Find. Given a person, we have to return that person’s representative. We can do that by moving up the appropriate tree until we reach its root element. For example, let’s find the representative of Person 1 in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a>. Since 1 is not a root, we move to 1’s parent. Person 4 is not a root, so we move to 4’s parent. Person 5 is a root, so we’re done: 5 is the representative of 1.</p>
<p class="indent">Compare this tree-hopping to what we were able to get away with in “Array-Based Approach” on <a href="ch09.xhtml#ch09lev2z">page 341</a>. Rather than simply looking up the representative in a single step, we have to move up the tree until we find the root. That sounds dicey—what if a tree gets really, really tall?—but we’ll soon see that this concern is unfounded, as we’ll be able to keep tree heights under control.</p>
<p class="indent"><span epub:type="pagebreak" id="page_343"/>Now let’s talk about Union. Given two people, we want to unite their two trees. In terms of correctness, it doesn’t matter how we jam the two trees together. However, as was just mentioned in the context of Find, it helps to keep tree heights small. If we insert one tree at the bottom of the other, we might unnecessarily increase the height of the resulting tree. To avoid that, we’ll insert one tree directly under the root of the other tree. To see how that looks, see <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>, where I’ve unioned the tree with root 5 and the tree with root 6.</p>
<div class="image"><img alt="image" id="ch09fig02" src="../images/ch09fig02.jpg"/></div>
<p class="figcap"><em>Figure 9-2: A tree-based union-find data structure after a union</em></p>
<p class="indent">I’ve chosen to make 6 the root of the combined tree. We could have also chosen to make 5 the root of the combined tree. (Here’s a teaser: Why will 5 turn out to be the better choice? We’ll see why when we discuss union-find optimizations.)</p>
<p class="indent">We now have enough to design a union-find solution to the Social Network problem.</p>
<h4 class="h4" id="sec141"><em>Solution 2: Union-Find</em></h4>
<p class="noindent">Primed by our discussion of heaps and segment trees in <a href="ch08.xhtml">Chapter 8</a>, you may not be surprised that we’re going to store the union-find data structure in an array!</p>
<p class="indent">Union-find trees are not necessarily binary trees, as their nodes can have any number of children. So we won’t be able to move around these trees by multiplying and dividing by 2, as we did in <a href="ch08.xhtml">Chapter 8</a>. We’re in luck, though, because the only travel we need to support is from a child to its parent. All we need is an array that maps from any given node to its parent. We can do that with the array <code>parent</code>, where <code>parent[i]</code> gives the parent of Node <code>i</code>.</p>
<p class="indent">Recall <a href="ch09.xhtml#ch09fig01">Figure 9-1</a>, where we had three communities: one that has People 1, 2, 4, and 5; one with People 3 and 6; and one with Person 7. Here’s the <code>parent</code> array corresponding to that figure:</p>
<div class="image1"><img alt="Image" src="../images/pg343-01.jpg"/></div>
<p class="indent">What if we want to find the representative of Person 1’s community? The value at index 1 is 4, which tells us that 4 is the parent of 1; the value at <span epub:type="pagebreak" id="page_344"/>index 4 is 5, which tells us that the parent of 4 is 5; and the value at index 5 is 5, which means that 5 is the . . . parent of 5? Certainly not! Whenever <code>parent[i]</code> is the same value as <code>i</code>, it means that we’ve reached the root of the tree. (The other common trick to distinguish roots is to use a value of <code>-1</code>, since that can’t be confused with a valid array index. I won’t use that in this book, but you may come across it in other code that you find.)</p>
<h5 class="h5">The main Function</h5>
<p class="noindent">Now we’re ready for some code. Let’s start with the <code>main</code> function as given in <a href="ch09.xhtml#ch09ex04">Listing 9-4</a>. (It’s far briefer than <a href="ch09.xhtml#ch09ex01">Listing 9-1</a>. In general, union-find code is compact.)</p>
<pre>int main(void) {
<span class="ent">❶</span> static int parent[MAX_PEOPLE + 1], size[MAX_PEOPLE + 1];
   int num_people, num_community, num_ops, i;
   char op;
   int person1, person2;
   scanf("%d%d", &amp;num_people, &amp;num_community);
<span class="ent">➋</span> for (i = 1; i &lt;= num_people; i++) {
     parent[i] = i;
     size[i] = 1;
   }
   scanf("%d", &amp;num_ops);

   for (i = 0; i &lt; num_ops; i++) {
     scanf(" %c", &amp;op);

     if (op == 'A') {
       scanf("%d%d", &amp;person1, &amp;person2);
     <span class="ent">➌</span> union_communities(person1, person2, parent, size, num_community);
     }
 
     else if (op == 'E') {
       scanf("%d%d", &amp;person1, &amp;person2);
     <span class="ent">➍</span> if (find(person1, parent) == find(person2, parent))
         printf("Yes\n");
       else
         printf("No\n");
     }
 
     else {
       scanf("%d", &amp;person1);
     <span class="ent">➎</span> printf("%d\n", size[find(person1, parent)]);
     }
  }
<span epub:type="pagebreak" id="page_345"/>  return 0;
}</pre>
<p class="excap" id="ch09ex04"><em>Listing 9-4: The</em> <span class="codeitalic1">main</span> <em>function for processing operations</em></p>
<p class="indent">In addition to the <code>parent</code> array that I’ve already described, there’s a <code>size</code> array <span class="ent">❶</span>. For each representative <code>i</code>, <code>size[i]</code> gives the number of people in its community. Never look up the size of a community using a nonrepresentative person. Once someone isn’t a representative, we won’t keep the <code>size</code> value updated anymore.</p>
<p class="indent">A <code>for</code> loop is used to initialize <code>parent</code> and <code>size</code> <span class="ent">➋</span>. For <code>parent</code>, we let each person be their own representative, which corresponds to having each person in their own set. Because each set has just one person, we set each <code>size</code> value to <code>1</code>.</p>
<p class="indent">To implement Add, we call the <code>union_communities</code> helper function <span class="ent">➌</span>. It unites the communities of <code>person1</code> and <code>person2</code>, subject to the <code>num_community</code> size constraint. We’ll see its code soon.</p>
<p class="indent">To implement Examine, we make two calls to <code>find</code> <span class="ent">➍</span>. If both calls return the same value, then the people are in the same community; otherwise, they are not.</p>
<p class="indent">Finally, to implement Size, we use the <code>size</code> array, looking up the representative of the person’s set <span class="ent">➎</span>.</p>
<p class="indent">I’ll next supply implementations of <code>find</code> and <code>union_communities</code>, and that will finish off this implementation.</p>
<h5 class="h5">The find Function</h5>
<p class="noindent">The <code>find</code> function takes a person as a parameter and returns that person’s representative. See <a href="ch09.xhtml#ch09ex05">Listing 9-5</a>.</p>
<pre>int find(int person, int parent[]) {
  int community = person;
  while (parent[community] !=  community)
    community = parent[community];
  return community;
}</pre>
<p class="excap" id="ch09ex05"><em>Listing 9-5: The</em> <span class="codeitalic1">find</span> <em>function</em></p>
<p class="indent">The <code>while</code> loop keeps moving up the tree, until it finds a root. That root person is the representative of the community, and so it is returned.</p>
<h5 class="h5">The union Function</h5>
<p class="noindent">The <code>union_communities</code> function takes two people—in addition to the <code>parent</code> array, <code>size</code> array, and <code>num_community</code> constraint—and joins their two communities. (I would have called this function <code>union</code>, but that’s not allowed because <code>union</code> is a C reserved word.) See <a href="ch09.xhtml#ch09ex06">Listing 9-6</a> for the code.</p>
<pre>void union_communities(int person1, int person2, int parent[],
                       int size[], int num_community) {
  int community1, community2;
<span epub:type="pagebreak" id="page_346"/>  <span class="ent">❶</span> community1 = find(person1, parent);
  <span class="ent">➋</span> community2 = find(person2, parent);
     if (community1 != community2 &amp;&amp;
         size[community1] + size[community2] &lt;= num_community) {
    <span class="ent">➌</span> parent[community1] = community2;
    <span class="ent">➍</span> size[community2] = size[community2] + size[community1];
  }
}</pre>
<p class="excap" id="ch09ex06"><em>Listing 9-6: The</em> <span class="codeitalic1">union_communities</span> <em>function</em></p>
<p class="noindent">First, we find the representative for each person’s community <span class="ent">❶</span> <span class="ent">➋</span>. Two conditions must be met for a Union to take place: first, the communities must be different; second, the sum of the sizes of the two communities must not exceed the maximum-allowed community size. If both of these conditions pass, then we perform the Union itself.</p>
<p class="indent">I’ve chosen to fold <code>community1</code> into <code>community2</code>. That is, <code>community1</code> will be gone, and <code>community2</code> will absorb <code>community1</code>. To make this happen, we must appropriately modify <code>parent</code> and <code>size</code>.</p>
<p class="indent">Before this Union, <code>community1</code> was the root of a community, but now we want <code>community1</code> to have <code>community2</code> as its parent. So, that’s precisely what we do <span class="ent">➌</span>! Any person whose representative was previously <code>community1</code> will now have <code>community2</code> as their representative.</p>
<p class="indent">In terms of <code>size</code>, <code>community2</code> has all of the people it had before plus all of the people that it inherited from <code>community1</code>. So the size is what it was before with the addition of the size of <code>community1</code> <span class="ent">➍</span>.</p>
<p class="indent">That’s all! Feel free to submit this solution to the judge. It should finish within the time limit and pass all test cases.</p>
<p class="indent">Somehow, though, I maybe had hoped that it didn’t pass within the time limit—because I’m sitting on two ace union-find optimizations here that I really want to teach you.</p>
<p class="indent">Hey, let’s just do them! This may be overkill for this problem, but they offer such a speed boost that we’ll apply them throughout this chapter and never worry about time limits again.</p>
<h4 class="h4" id="sec142"><em>Optimization 1: Union by Size</em></h4>
<p class="noindent">Our union-find solution generally runs fast, but test cases can be crafted to make it crawl. Here’s what the worst kind of test case looks like:</p>
<pre>7 7
7
A 1 2
A 2 3
A 3 4
A 4 5
A 5 6
A 6 7
E 1 2</pre>
<p class="indent"><span epub:type="pagebreak" id="page_347"/>Communities 1 and 2 are merged, that resulting community is merged with Community 3, that resulting community is merged with Community 4, and so on. After the six Unions, we have the tree as depicted in <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>.</p>
<div class="image"><img alt="image" id="ch09fig03" src="../images/ch09fig03.jpg"/></div>
<p class="figcap"><em>Figure 9-3: A bad case of a tree-based union-find data structure</em></p>
<p class="indent">We have a long chain of nodes and, unfortunately, Finds and Unions may end up traversing the entire chain. For example, <code>E 1 2</code> would invoke a Find on Person 1 and a Find on Person 2, each visiting almost every node. Of course, a seven-node chain is tiny, but we can replicate the unioning pattern to produce massive chains of whatever length we want. We can thereby force Find and Union operations to take linear time; with <em>q</em> operations in all, we can force our tree-based union-find algorithm to take <em>O</em>(<em>q</em><sup>2</sup>) time. This means that, in the worst case, the tree-based solution is not theoretically better than the BFS solution. It’s better than BFS in practice, because most test cases will not produce long chains of nodes . . . but some test cases might!</p>
<p class="indent">Hold on! Why are we letting these officious test cases bully us into producing these awful trees? We don’t care what the union-find data structure looks like. In particular, whenever a Union is requested, we have a choice of which old representative becomes the representative of the unioned community. Rather than always folding the first community into the second, we should make the choice that produces the best tree. Compare the nonsense in <a href="ch09.xhtml#ch09fig03">Figure 9-3</a> to the wonder that is <a href="ch09.xhtml#ch09fig04">Figure 9-4</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_348"/><img alt="image" id="ch09fig04" src="../images/ch09fig04.jpg"/></div>
<p class="figcap"><em>Figure 9-4: An optimized tree-based union-find data structure</em></p>
<p class="indent">Person 2 is the root, and everyone else is exactly one edge away. No matter what Union or Find comes next, we’ll be able to perform it very efficiently.</p>
<p class="indent">How can our code make <a href="ch09.xhtml#ch09fig04">Figure 9-4</a> instead of <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>? The optimization is called <em>union by size</em>. Whenever you’re about to union two communities together, union the community with fewer people into the community with more people.</p>
<p class="indent">In the test case that we’ve been discussing, we start with <code>A 1 2</code>. The two communities each have one person, so it doesn’t matter which we choose to keep; let’s keep Community 2. Now Community 2 has two people: the one that it had and the one from Community 1. To do <code>A 2 3</code>, we compare the size of Community 2 (two) to the size of Community 3 (one). We will keep Community 2 because it is larger than Community 3. Now Community 2 has three people. What about <code>A 3 4</code>? This gives us another person for Community 2. We then keep going, absorbing one person after another into Community 2.</p>
<p class="indent">Union by size certainly neutralizes the worst test cases, but there are still test cases whose trees need some work to go from nodes to roots. Here’s one:</p>
<pre>9 9
9
A 1 2
A 3 4
A 5 6
A 7 8
A 8 9
A 2 4
A 6 8
A 4 8
E 1 5</pre>
<p class="indent">Union by size produces <a href="ch09.xhtml#ch09fig05">Figure 9-5</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_349"/><img alt="image" id="ch09fig05" src="../images/ch09fig05.jpg"/></div>
<p class="figcap"><em>Figure 9-5: A bad case of union by size</em></p>
<p class="indent">Although it’s true that some nodes are right below the root, there are now nodes that are further away (the worst offender being Node 1). Still, the tree is quite balanced, and it’s certainly better than the long chain of nodes that we saw prior to the union-by-size optimization.</p>
<p class="indent">I’ll next show that the maximum height of a tree when using union by size is <em>O</em>(log <em>n</em>), where <em>n</em> is the total number of people. This means that a Find or Union takes <em>O</em>(log <em>n</em>) time, because a Find is just a traversal up the tree and a Union is just two Finds plus a change of parent.</p>
<p class="indent">Let’s choose some arbitrary node <em>x</em> and think about how many times the number of edges between <em>x</em> and its root can increase. When <em>x</em>’s community absorbs another community, the number of edges between <em>x</em> and its root doesn’t change, because the root of its community is the same as it was. However, when <em>x</em>’s community is absorbed by another community, then the number of edges between <em>x</em> and its new root is one more than it was before: the path from <em>x</em> to its new root is what it was before (to get to its old root) plus one more edge to get to its new root.</p>
<p class="indent">Therefore, putting an upper bound on the number of edges between <em>x</em> and its root amounts to determining the maximum number of times that <em>x</em>’s community can be absorbed into another community.</p>
<p class="indent">Say that <em>x</em> is in a community of size four. Could it be absorbed into a community that was size two? No way! We’re using union by size, remember. The only way <em>x</em>’s community can be absorbed into another community is if the other community is at least as large as <em>x</em>’s. In this example, the other community would have to be size four or greater. So we go from a community of size four to a community of at least size 4 + 4 = 4 × 2 = 8. That is, the size of <em>x</em>’s community at least doubles when it’s absorbed into another community.</p>
<p class="indent">Starting off in a community of size one, <em>x</em>’s community gets absorbed and now it’s in a community of at least size two. It gets absorbed again and now it’s in a community of at least size four. Getting absorbed again puts it in a community of at least size eight. This doubling can’t continue forever. It has to stop, at the latest, when <em>x</em>’s community contains all <em>n</em> people. Starting from one, how many times can we double it before we get to <em>n</em>? That’s log <em>n</em>, and that’s why the number of edges between any node and its root is capped at log <em>n</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_350"/>Using union by size cuts linear runtime to logarithmic runtime. Better still, we don’t need much new code to implement this optimization. In fact, for the Social Network problem, we’re already maintaining sizes of communities—we can just use these sizes to decide which community gets absorbed into the other. <a href="ch09.xhtml#ch09ex07">Listing 9-7</a> gives the new code. Compare the code to <a href="ch09.xhtml#ch09ex06">Listing 9-6</a> to confirm that we’re doing almost the same thing as before.</p>
<pre>void union_communities(int person1, int person2, int parent[],
                       int size[], int num_community) {
  int community1, community2, temp;
  community1 = find(person1, parent);
  community2 = find(person2, parent);
  if (community1 != community2 &amp;&amp;
      size[community1] + size[community2] &lt;= num_community) {
 <span class="ent">❶</span> if (size[community1] &gt; size[community2]) {
      temp = community1;
      community1 = community2;
      community2 = temp;
    }
 <span class="ent">➋</span> parent[community1] = community2;
    size[community2] = size[community2] + size[community1];
  }
}</pre>
<p class="excap" id="ch09ex07"><em>Listing 9-7: The</em> <span class="codeitalic1">union_communities</span> <em>function using union by size</em></p>
<p class="indent">By default, the code chooses <code>community2</code> to absorb <code>community1</code>. This is the right thing to do if <code>community2</code> is larger than or the same size as <code>community1</code>. If the size of <code>community1</code> is larger than <code>community2</code> <span class="ent">❶</span>, then we swap <code>community1</code> and <code>community2</code> to reverse their roles. After that, <code>community2</code> is guaranteed to be the bigger community, and we can proceed by absorbing <code>community1</code> into <code>community2</code> <span class="ent">➋</span>.</p>
<h4 class="h4" id="sec143"><em>Optimization 2: Path Compression</em></h4>
<p class="noindent">Let’s revisit the test case that produced <a href="ch09.xhtml#ch09fig05">Figure 9-5</a>. Only this time, let’s build the tree and then keep spamming the same Examine operation:</p>
<pre>9 9
13
A 1 2
A 3 4
A 5 6
A 7 8
A 8 9
A 2 4
A 6 8
A 4 8
E 1 5
<span epub:type="pagebreak" id="page_351"/>E 1 5
E 1 5
E 1 5
E 1 5</pre>
<p class="indent">The <code>E 1 5</code> operation is a little slow, each time requiring lengthy traversals to the root. To Find the representative of Person 1, for example, we go from Node 1 to Node 2 to Node 4 to Node 8. Now we know that Node 1’s representative is Node 8. We would do a similar traversal for Person 5, but that knowledge is short-lived, because we don’t remember that anywhere. Every single <code>E 1 5</code> operation causes us to redo the work to Find Person 1 and Person 5, just to relearn what we learned last time.</p>
<p class="indent">Here we have another opportunity to benefit by controlling the structure of the tree. Remember that the particular shape of the tree doesn’t matter: all that matters is that people in the same community are present in the same tree. Hence, as soon as we’ve determined the root of someone’s community, we might as well move that person to be a child of the root. While we’re at it, we might as well move that person’s ancestors right below the root, too.</p>
<p class="indent">Consider again <a href="ch09.xhtml#ch09fig05">Figure 9-5</a>, and suppose we next perform <code>E 1 5</code>. If we were using just the Union-by-size optimization, this Examine operation (like any Examine operation) would not change the structure of the tree. Watch what happens, though, if we use an optimization called <em>path compression</em>, as depicted in <a href="ch09.xhtml#ch09fig06">Figure 9-6</a>.</p>
<div class="image"><img alt="image" id="ch09fig06" src="../images/ch09fig06.jpg"/></div>
<p class="figcap"><em>Figure 9-6: An example of path compression</em></p>
<p class="indent">This is nice, right? Finding Node 1 leads to Nodes 1 and 2 becoming children of a root; finding Node 5 leads to Node 5 becoming a child of a root. In general, path compression takes every node along a path and puts it as a child of the root node. Finding any of those nodes will therefore be extremely fast.</p>
<p class="indent">To implement path compression in the <code>find</code> function, we can make two traversals from the provided person to the root of the tree. The first traversal locates the root of the tree; that’s the traversal that any <code>find</code> function does. The second traversal ensures that each node along the path has the root as its parent. <a href="ch09.xhtml#ch09ex08">Listing 9-8</a> implements the new code. Compare it to <a href="ch09.xhtml#ch09ex05">Listing 9-5</a> to see that what’s new is the second traversal.</p>
<pre>int find(int person, int parent[]) {
  int community = person, temp;
<span epub:type="pagebreak" id="page_352"/><span class="ent">❶</span> while (parent[community] !=  community)
     community = parent[community];
<span class="ent">➋</span> while (parent[person] != community) {
     temp = parent[person];
     parent[person] = community;
     person = temp;
   }
   return community;
}</pre>
<p class="excap" id="ch09ex08"><em>Listing 9-8: The</em> <span class="codeitalic1">find</span> <em>function with path compression implemented</em></p>
<p class="indent">This code works in two phases. The first phase is the first <code>while</code> loop <span class="ent">❶</span>, which results in <code>community</code> holding the representative (the root) of the community. With that representative in hand, the second phase, captured by the second <code>while</code> loop <span class="ent">➋</span>, retraces the path from <code>person</code> to just below the root of the tree, updating each node’s <code>parent</code> to be the tree’s root. The <code>temp</code> variable is used to store the old parent of the current node. In that way, we can still move to the current node’s old parent even after making it the root of the tree. (There’s a shockingly concise though cryptic way to code path compression that you might see in the wild. Brace yourself, and then check out “Compressing Path Compression” in <a href="app02.xhtml">Appendix B</a>.)</p>
<p class="indent">By using both union by size and path compression, it’s still possible that a single Union or Find operation takes <em>O</em>(log <em>n</em>) time. However, taking all Unions and Finds together, the average time taken per operation—while not technically constant—is essentially constant. The runtime analysis is based on a function called the <em>inverse Ackermann function</em>, which grows very, very, <em>very</em> slowly. I won’t define the inverse Ackermann function or show how it arises in the runtime analysis, but I’d like to give a sense of how strong this result is.</p>
<p class="indent">The logarithm function grows slowly, so let’s start there. Taking the log of a huge number gives back a very small number. For example, log 1,000,000,000 is only about 30. However, the log isn’t a constant: using a sufficiently large value of <em>n</em>, you can make log <em>n</em> as big as you want.</p>
<p class="indent">The inverse Ackermann function is similarly not constant, but, unlike the log function, you’ll never in practice get a value of 30 out of it. You can make <em>n</em> as big as you want, as big as the biggest number representable in your computer, and the inverse Ackermann of <em>n</em> will be at most 4. You can think of union-find with union by size and path compression as taking an average of just four steps per operation!</p>
<h3 class="h3" id="lev58">Union-Find</h3>
<p class="noindent">The union-find data structure turbocharges solutions to graph problems whose primary operations are Union and Find. This doesn’t help with problems such as those in <a href="ch05.xhtml">Chapters 5</a> and <a href="ch06.xhtml">6</a>, where we’re required to calculate distances between nodes. But when union-find does apply, adjacency lists and graph search are overkill and just too slow.</p>
<h4 class="h4" id="sec144"><span epub:type="pagebreak" id="page_353"/><em>Relationships: Three Requirements</em></h4>
<p class="noindent">Union-find works on a collection of objects, where each object begins in its own set. At all times, objects in the same set are equivalent, whatever “equivalent” means for the problem that we’re solving. For example, in the Social Network problem, people in the same set (community) are equivalent in the sense that they are all friends.</p>
<p class="indent">Union-find requires that the relationship between our objects satisfy three criteria. First, objects must be related to themselves. In terms of friendships from the Social Network, this just means that each person is one’s own friend. A relationship that meets this criterion is called <em>reflexive</em>.</p>
<p class="indent">Second, the relationship has to be directionless: we can’t have <em>x</em> as a friend of <em>y</em> and at the same time have <em>y</em> as not a friend of <em>x</em>. A relationship that meets this criterion is called <em>symmetric</em>.</p>
<p class="indent">Third, the relationship must cascade: if <em>x</em> is a friend of <em>y</em>, and <em>y</em> is a friend of <em>z</em>, then <em>x</em> is a friend of <em>z</em>. A relationship that meets this criterion is called <em>transitive</em>.</p>
<p class="indent">If any of these criteria is not met, then the Union operation we’ve been discussing is broken. For example, suppose that we have a friendship relationship where transitivity does not hold. If we learn that <em>x</em> is a friend of <em>y</em>, we have no idea whether <em>x</em>’s friends are <em>y</em>’s friends. We’re therefore not justified in uniting <em>x</em>’s community and <em>y</em>’s community; that might put people in the same set that are not in fact friends.</p>
<p class="indent">A relationship that is reflexive, symmetric, and transitive is called an <em>equivalence relation</em>.</p>
<h4 class="h4" id="sec145"><em>Choosing Union-Find</em></h4>
<p class="noindent">When deciding whether union-find might apply, ask yourself this: What is the relationship that I need to maintain between objects? Is it reflexive, symmetric, and transitive? If it is, and the primary operations can be mapped to Finds and Unions, then you should consider union-find as a viable solution strategy.</p>
<p class="indent">Beneath every union-find problem lies a graph problem that could be modeled (less efficiently!) using adjacency lists and graph search. Unlike what we did for the Social Network problem, for the remaining problems in this chapter, we won’t take the scenic route through graphs.</p>
<h4 class="h4" id="sec146"><em>Optimizations</em></h4>
<p class="noindent">I introduced two union-find optimizations: union by size and path compression. They offer protection against bad test cases and generally increase performance no matter what the test case. They each take only a few lines of code, so I recommend using them whenever you can.</p>
<p class="indent">“Whenever you can” is not to be confused with “always.” Unfortunately, there are some union-find problems where these optimizations are not appropriate. I haven’t yet encountered a problem where path compression is problematic, but sometimes we need to remember the order in which sets <span epub:type="pagebreak" id="page_354"/>are being united, and in those cases we can’t swap roots of trees using union by size. You’ll see in Problem 3 an example where we can’t use union by size.</p>
<h3 class="h3" id="lev59">Problem 2: Friends and Enemies</h3>
<p class="noindent">You might worry that the only kind of “Add” operation we can support is like that used in the Social Network problem: <em>x</em> and <em>y</em> are friends; <em>x</em> and <em>y</em> go to the same school; <em>x</em> and <em>y</em> live in the same city—that kind of thing. It turns out that we can support other types of Add information, too. <em>x</em> and <em>y</em> are <em>not</em> friends. Hmm . . . that one’s interesting, telling us not that <em>x</em> and <em>y</em> are in the same set but that they are <em>not</em> in the same set. How does union-find work now? Read on!</p>
<p class="indent">This is UVa problem <code>10158</code>.</p>
<h4 class="h4" id="sec147"><em>The Problem</em></h4>
<p class="noindent">Two countries are at war. You have been granted permission to attend their peace meetings, during which you can listen to pairs of people talking to each other. There are <em>n</em> people at these meetings, numbered 0, 1, . . . , <em>n</em> – 1. At first, you don’t know anything about who are friends (citizens of the same country) or enemies (citizens of opposing countries). Your job is to record information about who are friends or enemies and to respond to queries based on what you know so far.</p>
<p class="indent">You must support four operations:</p>
<p class="block"><strong>SetFriends</strong>   Record that the two provided people are friends.</p>
<p class="block"><strong>SetEnemies</strong>   Record that the two provided people are enemies.</p>
<p class="block"><strong>AreFriends</strong>   Report whether you know for sure that the two provided people are friends.</p>
<p class="block"><strong>AreEnemies</strong>   Report whether you know for sure that the two provided people are enemies.</p>
<p class="indent">Friendship is an equivalence relation: it’s reflexive (<em>x</em> is a friend of <em>x</em>), symmetric (if <em>x</em> is a friend of <em>y</em>, then <em>y</em> is a friend of <em>x</em>), and transitive (if <em>x</em> is a friend of <em>y</em> and <em>y</em> is a friend of <em>z</em>, then <em>x</em> is a friend of <em>z</em>).</p>
<p class="indent">Enemyship is not an equivalence relation. It’s symmetric: if <em>x</em> is an enemy of <em>y</em>, then <em>y</em> is likewise an enemy of <em>x</em>. It’s neither, however, reflexive nor transitive.</p>
<p class="indent">There’s a little more we need to know about friendship and enemyship. Suppose that <em>x</em> has some friends and enemies, <em>y</em> has some friends and enemies, and then we are told that <em>x</em> and <em>y</em> are enemies. What have we learned? Well, we learn directly that <em>x</em> and <em>y</em> are enemies—but that’s not all. We can also conclude that <em>x</em>’s enemies are friends with everyone in <em>y</em>’s set. (Suppose that Alice and Bob are enemies and that David and Eve are friends—and then we are told that Alice and David are enemies. We should conclude that Bob is friends with David and Eve.) Similarly, we can conclude that <em>y</em>’s <span epub:type="pagebreak" id="page_355"/>enemies are friends with everyone in <em>x</em>’s set. Here’s this paragraph in one aphorism: the enemy of an enemy is a friend.</p>
<p class="indent">Now suppose that <em>x</em> has some friends and enemies and that <em>y</em> has some friends and enemies—but that this time, we are told that <em>x</em> and <em>y</em> are friends. Here, we should additionally conclude that <em>x</em>’s enemies and <em>y</em>’s enemies are friends. (Hang in there. We’ll make all of this concrete as we work through some examples.)</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing <em>n</em>, the total number of people attending the meetings. <em>n</em> is less than 10,000.</li>
<li class="noindent">Zero or more lines, one for each operation.</li>
<li class="noindent">A line containing three integers, the first of which is 0. This signifies the end of the test case.</li>
</ul>
<p class="indent">Each operation line has the same format: an operation code followed by two people (<span class="codeitalic">x</span> and <span class="codeitalic">y</span>).</p>
<ul>
<li class="noindent">A SetFriends operation is of the form <code>1</code> <span class="codeitalic">x y</span>.</li>
<li class="noindent">A SetEnemies operation is of the form <code>2</code> <span class="codeitalic">x y</span>.</li>
<li class="noindent">An AreFriends operation is of the form <code>3</code> <span class="codeitalic">x y</span>.</li>
<li class="noindent">An AreEnemies operation is of the form <code>4</code> <span class="codeitalic">x y</span>.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">The output for each operation is on its own line.</p>
<ul>
<li class="noindent">If a SetFriends operation succeeds, then it produces no output. If it conflicts with information that is already known, then output <code>-1</code> and ignore the operation.</li>
<li class="noindent">If a SetEnemies operation succeeds, then it produces no output. If it conflicts with information that is already known, then output <code>-1</code> and ignore the operation.</li>
<li class="noindent">For an AreFriends operation, output <code>1</code> if the two people are known to be friends and output <code>0</code> otherwise.</li>
<li class="noindent">For an AreEnemies operation, output <code>1</code> if the two people are known to be enemies and output <code>0</code> otherwise.</li>
</ul>
<p class="indent">The time limit for solving the test case is three seconds.</p>
<h4 class="h4" id="sec148"><em>Augmenting Union-Find</em></h4>
<p class="noindent">If all we had to deal with were the SetFriends and AreFriends operations, then we could directly apply union-find as we did when solving the Social Network problem. We’d keep one set for each group of friends. Like Add in Social Network, SetFriends would be implemented as a Union and bring <span epub:type="pagebreak" id="page_356"/>together two sets of friends into a larger set. Like Examine in Social Network, AreFriends would be implemented as a Find on each of the two people to determine whether they’re in the same set.</p>
<p class="indent">We could start by solving the problem for just these two operations . . . actually, you know what? I’m confident you could solve that restricted problem, right now, without anything else from me. Where I may be helpful is in explaining the technique for incorporating SetEnemies and AreEnemies.</p>
<h5 class="h5">Augmentation: Enemies</h5>
<p class="noindent"><em>Augmenting</em> a data structure refers to storing additional information in that data structure to support new or faster operations. Maintaining the size of each set in a union-find data structure is an example of augmentation: you could implement the data structure without it, but with it you can quickly report set sizes and perform union by size.</p>
<p class="indent">You should consider augmentation when an existing data structure <em>almost</em> does what you want. The key is to identify a suitable augmentation that adds the desired functionality without appreciably slowing down other operations.</p>
<p class="indent">We already have a union-find data structure that supports SetFriends and AreFriends. It maintains the parent of each node as well as the size of each set. We’re going to augment that data structure to support SetEnemies and AreEnemies. Moreover, we’re going to do it without slowing down Set-Friends and AreFriends much at all.</p>
<p class="indent">Suppose we’re told that <em>x</em> and <em>y</em> are enemies. From the problem description, we know that we’re going to have to union <em>x</em>’s enemies with <em>y</em>’s set and union <em>y</em>’s enemies with <em>x</em>’s set. Who are <em>x</em>’s enemies? Who are <em>y</em>’s enemies? With the standard union-find data structure, we don’t know. This is why we need to augment the union-find data structure.</p>
<p class="indent">In addition to the parent of each node and the size of each set, we’re going to keep track of an enemy for each set. We’ll store those enemies in an array called <code>enemy_of</code>. Suppose that <code>s</code> is the representative of some set. If that set has no enemies, then we’ll arrange for <code>enemy_of[s]</code> to hold a special value that can’t be confused with a person. If that set has one or more enemies, then <code>enemy_of[s]</code> will give us one of them.</p>
<p class="indent">That’s right: <em>one</em> of them, not <em>all</em> of them. Knowing one enemy of each set is enough, because we can use that one enemy to find the representative of everyone in that enemy’s set.</p>
<p class="indent">Let’s now work through two test cases. They’ll prepare us for the implementation that follows. The diagrams I will show are conceptual and do not correspond exactly to what an implementation might do. In particular, I won’t use union by size or path compression in the diagrams, but we’ll throw those optimizations into our implementation in the interest of performance.</p>
<h5 class="h5">Test Case 1</h5>
<p class="noindent">Recall that the operation code for SetFriends is <code>1</code> and the code for SetEnemies is <code>2</code>.</p>
<p class="indent">Here’s our first test case:</p>
<span epub:type="pagebreak" id="page_357"/>
<pre>   9
   1 0 1
   1 1 2
   1 3 4
   1 5 6
<span class="ent">❶</span> 2 1 7
<span class="ent">➋</span> 2 5 8
<span class="ent">➌</span> 1 2 5
   0 0 0</pre>
<p class="indent">The first four operations are SetFriends operations. No one has any enemies yet, so these operations play out just as did Add operations in the Social Network problem. <a href="ch09.xhtml#ch09fig07">Figure 9-7</a> shows the state of the data structure after these operations.</p>
<div class="image"><img alt="image" id="ch09fig07" src="../images/ch09fig07.jpg"/></div>
<p class="figcap"><em>Figure 9-7: The data structure after four SetFriends operations</em></p>
<p class="indent">Next we have our first SetEnemies operation <span class="ent">❶</span>, and it indicates that People 1 and 7 are enemies. This means that everyone in 1’s set is enemies with everyone in 7’s set. To incorporate this into the data structure, we add links between roots of these two sets: a link from 2 (the root of 1’s set) to 7, and a link from 7 (the root of 7’s set) to 1. (You could have decided that the latter should instead be a link from 7 to 2; that would be fine as well.) The result of this operation is shown in <a href="ch09.xhtml#ch09fig08">Figure 9-8</a>. In this and subsequent figures, enemy links are realized as dashed lines; in our implementation, enemy links will be realized as the aforementioned <code>enemy_of</code> array.</p>
<div class="image"><img alt="image" id="ch09fig08" src="../images/ch09fig08.jpg"/></div>
<p class="figcap"><em>Figure 9-8: The data structure after a SetEnemies operation</em></p>
<p class="indent">Next is a SetEnemies operation between People 5 and 8 <span class="ent">➋</span>; performing this operation might result in <a href="ch09.xhtml#ch09fig09">Figure 9-9</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_358"/><img alt="image" id="ch09fig09" src="../images/ch09fig09.jpg"/></div>
<p class="figcap"><em>Figure 9-9: The data structure after another SetEnemies operation</em></p>
<p class="indent">Now it’s time for the final operation <span class="ent">➌</span>, which says that People 2 and 5 are friends. This unites 2’s set and 5’s set into one larger set of friends, as expected. The surprise, perhaps, is that we also unite two enemy sets. Specifically, we unite the enemies of Person 2’s set with the enemies of Person 5’s set. After all, if we know that two people are in the same country, then each of their enemy sets must be together in the other country. The result of performing these <em>two</em> Union operations is shown in <a href="ch09.xhtml#ch09fig010">Figure 9-10</a>.</p>
<div class="image"><img alt="image" id="ch09fig010" src="../images/ch09fig10.jpg"/></div>
<p class="figcap"><em>Figure 9-10: The data structure after a final SetFriends operation</em></p>
<p class="indent">The reason I haven’t drawn enemy links from Person 2 to Person 7 and from Person 7 to Person 1 is because we maintain enemy links only from root nodes. Once a node is no longer a root, we’ll never use it again to find enemies.</p>
<p class="indent">Two key things can be learned from this test case: that one enemy of a set is stored at that set’s root and that a SetFriends operation requires two Unions, not one. Now, what do we do when a set already has an enemy and then that set is involved in a SetEnemies operation? That’s where our next test case comes in.</p>
<h5 class="h5">Test Case 2</h5>
<p class="noindent">Our second test case differs from the first only in its final operation:</p>
<pre>   9
   1 0 1
   1 1 2
<span epub:type="pagebreak" id="page_359"/>   1 3 4
   1 5 6
   2 1 7
   2 5 8
<span class="ent">❶</span> 2 2 5
   0 0 0</pre>
<p class="indent">Prior to the final operation, the data structure appears as depicted in <a href="ch09.xhtml#ch09fig09">Figure 9-9</a>. The final operation <span class="ent">❶</span> is now a SetEnemies operation rather than a SetFriends operation. Person 2’s set already has an enemy, and now it has new enemies from Person 5’s set. Hence we need to unite Person 2’s enemies with Person 5’s set. Similarly, Person 5’s set already has an enemy and now has new enemies from Person 2’s set, so we need to unite Person 5’s enemies with Person 2’s set.</p>
<p class="indent">The result of these two Unions is shown in <a href="ch09.xhtml#ch09fig011">Figure 9-11</a>.</p>
<div class="image"><img alt="image" id="ch09fig011" src="../images/ch09fig11.jpg"/></div>
<p class="figcap"><em>Figure 9-11: The data structure after a final SetEnemies operation</em></p>
<p class="indent">Having laid this background, we’re ready for an implementation!</p>
<h4 class="h4" id="sec149"><em>The main Function</em></h4>
<p class="noindent">Let’s start with the <code>main</code> function, which is given in <a href="ch09.xhtml#ch09ex09">Listing 9-9</a>. It reads the input, and it calls one helper function for each of the four operations that we’re supporting.</p>
<pre>#define MAX_PEOPLE 9999

int main(void) {
  static int parent[MAX_PEOPLE], size[MAX_PEOPLE];
  static int enemy_of[MAX_PEOPLE];
  int num_people, i;
  int op, person1, person2;
  scanf("%d", &amp;num_people);
  for (i = 0; i &lt; num_people; i++) {
    parent[i] = i;
    size[i] = 1;
 <span class="ent">❶</span> enemy_of[i] = -1;
  }
<span epub:type="pagebreak" id="page_360"/>  scanf("%d%d%d", &amp;op, &amp;person1, &amp;person2);

  while (op != 0) {
 <span class="ent">➋</span> if (op == 1)
      if (are_enemies(person1, person2, parent, enemy_of))
        printf("-1\n");
      else
        set_friends(person1, person2, parent, size, enemy_of);

 <span class="ent">➌</span> else if (op == 2)
      if (are_friends(person1, person2, parent))
        printf("-1\n");
      else
        set_enemies(person1, person2, parent, size, enemy_of);

 <span class="ent">➍</span> else if (op == 3)
      if (are_friends(person1, person2, parent))
        printf("1\n");
      else
        printf("0\n");

 <span class="ent">➎</span> else if (op == 4)
      if (are_enemies(person1, person2, parent, enemy_of))
        printf("1\n");
      else
        printf("0\n");
 
    scanf("%d%d%d", &amp;op, &amp;person1, &amp;person2);
  }
  return 0;
}</pre>
<p class="excap" id="ch09ex09"><em>Listing 9-9: The</em> <span class="codeitalic1">main</span> <em>function for processing operations</em></p>
<p class="indent">Notice that, as part of the initialization, we set each <code>enemy_of</code> value to <code>-1</code> <span class="ent">❶</span>. That’s our special value to indicate “no enemy.”</p>
<p class="indent">To implement SetFriends <span class="ent">➋</span>, we first check whether the two people are already known to be enemies. If they are, we output <code>-1</code>; if they aren’t, we call the <code>set_friends</code> helper function. The implementation of SetEnemies <span class="ent">➌</span> follows the same pattern. For AreFriends <span class="ent">➍</span> and AreEnemies <span class="ent">➎</span>, we call a helper function to determine whether the condition is true or false, and we output <code>1</code> or <code>0</code> accordingly.</p>
<h4 class="h4" id="sec150"><em>Find and Union</em></h4>
<p class="noindent">I’ll present the Find and Union functions here; they’ll be called by our helper functions, <code>set_friends</code>, <code>set_enemies</code>, <code>are_friends</code>, and <code>are_enemies</code>. The Find function is given in <a href="ch09.xhtml#ch09ex010">Listing 9-10</a>. We’ve got path compression in there!</p>
<span epub:type="pagebreak" id="page_361"/>
<pre>int find(int person, int parent[]) {
  int set = person, temp;
  while (parent[set] !=  set)
    set = parent[set];
  while (parent[person] != set) {
    temp = parent[person];
    parent[person] = set;
    person = temp;
  }
  return set;
}</pre>
<p class="excap" id="ch09ex010"><em>Listing 9-10: The</em> <span class="codeitalic1">find</span> <em>function</em></p>
<p class="indent">The Union function is given in <a href="ch09.xhtml#ch09ex011">Listing 9-11</a>. Union by size: you better believe it!</p>
<pre>int union_sets(int person1, int person2, int parent[],
               int size[]) {
  int set1, set2, temp;
  set1 = find(person1, parent);
  set2 = find(person2, parent);
  if (set1 != set2) {
    if (size[set1] &gt; size[set2]) {
      temp = set1;
      set1 = set2;
      set2 = temp;
    }
    parent[set1] = set2;
    size[set2] = size[set2] + size[set1];
  }
<span class="ent">❶</span> return set2;
}</pre>
<p class="excap" id="ch09ex011"><em>Listing 9-11: The</em> <span class="codeitalic1">union_sets</span> <em>function</em></p>
<p class="indent">The Union function does have one feature not present in our prior Union code: it returns the representative of the resulting set <span class="ent">❶</span>. We’ll turn to the SetFriends operation next, and you’ll see there that we use this return value.</p>
<h4 class="h4" id="sec151"><em>SetFriends and SetEnemies</em></h4>
<p class="noindent">The SetFriends operation is implemented in <a href="ch09.xhtml#ch09ex012">Listing 9-12</a>.</p>
<pre>void set_friends(int person1, int person2, int parent[],
                 int size[], int enemy_of[]) {
  int set1, set2, bigger_set, other_set;
<span class="ent">❶</span> set1 = find(person1, parent);
<span epub:type="pagebreak" id="page_362"/><span class="ent">➋</span> set2 = find(person2, parent);
<span class="ent">➌</span> bigger_set = union_sets(person1, person2, parent, size);
<span class="ent">➍</span> if (enemy_of[set1] != -1 &amp;&amp; enemy_of[set2] != -1)
  <span class="ent">➎</span> union_sets(enemy_of[set1], enemy_of[set2], parent, size);
<span class="ent">➏</span> if (bigger_set == set1)
     other_set = set2;
   else
     other_set = set1;
<span class="ent">❼</span> if (enemy_of[bigger_set] == -1)
     enemy_of[bigger_set] = enemy_of[other_set];
}</pre>
<p class="excap" id="ch09ex012"><em>Listing 9-12: Recording that two people are friends</em></p>
<p class="indent">We begin by determining the representative of each of the two people: <code>set1</code> is the representative of <code>person1</code> <span class="ent">❶</span> and <code>set2</code> is the representative of <code>person2</code> <span class="ent">➋</span>. Since these two sets of people are now supposed to be all friends with each other, we unite them into a bigger set <span class="ent">➌</span>. We store the return value of <code>union_sets</code> in <code>bigger_set</code>; we’ll use that soon.</p>
<p class="indent">We’ve now unioned <code>person1</code>’s set and <code>person2</code>’s set, but we’re not done, because—remember this from our first test case—we might have to union some enemies together as well. Specifically, if <code>set1</code> has enemies and <code>set2</code> has enemies, then we need to union those enemies into a single, bigger set. That’s just what the code does: if both sets have enemies <span class="ent">➍</span>, we union those enemy sets <span class="ent">➎</span>.</p>
<p class="indent">It’s tempting to think that we’re done at this point. We’ve performed the required union of friends and union of enemies—what else is there to do? Well, imagine that <code>set1</code> has some enemies and that <code>set2</code> does not. The representative of <code>set2</code> therefore has an <code>enemy_of</code> value of <code>-1</code>. Now, maybe <code>set1</code> ends up being folded into <code>set2</code> so that <code>set2</code> is the bigger set. If we just call it a day here and do nothing else, then <code>set2</code> will not be able to find its enemies! The <code>enemy_of</code> value for <code>set2</code>’s representative is still <code>-1</code>—and that’s wrong, because <code>set2</code> <em>does</em> have enemies now.</p>
<p class="indent">Here’s how we handle this in the code. We already have <code>bigger_set</code>, indicating which set—<code>set1</code> or <code>set2</code>—resulted from unioning <code>set1</code> and <code>set2</code>. We use an if–else to set <code>other_set</code> to the other set <span class="ent">➏</span>: if <code>bigger_set</code> is <code>set1</code>, then <code>other_set</code> will be <code>set2</code>, and vice versa. Then, if <code>bigger_set</code> has no enemies <span class="ent">❼</span>, we copy over the enemy link from <code>other_set</code>. The result is that <code>bigger_set</code> is guaranteed to be able to find its enemies if <code>set1</code> or <code>set2</code> or both had enemies.</p>
<p class="indent">Now it’s time for SetEnemies. Check it out in <a href="ch09.xhtml#ch09ex013">Listing 9-13</a>.</p>
<pre>void set_enemies(int person1, int person2, int parent[],
                 int size[], int enemy_of[]) {
  int set1, set2, enemy;
  set1 = find(person1, parent);
  set2 = find(person2, parent);
<span class="ent">❶</span> enemy = enemy_of[set1];
   if (enemy == -1)
   <span class="ent">➋</span> enemy_of[set1] = person2;
<span epub:type="pagebreak" id="page_363"/>   else
  <span class="ent">➌</span> union_sets(enemy, person2, parent, size);
<span class="ent">➍</span> enemy = enemy_of[set2];
   if (enemy == -1)
     enemy_of[set2] = person1;
   else
     union_sets(enemy, person1, parent, size);
}</pre>
<p class="excap" id="ch09ex013"><em>Listing 9-13: Recording that two people are enemies</em></p>
<p class="indent">We again begin by finding the representatives of each set, storing them in <code>set1</code> and <code>set2</code>, respectively. We then look up an enemy of <code>set1</code> <span class="ent">❶</span>. If <code>set1</code> has no enemy, then we set <code>person2</code> to be its enemy <span class="ent">➋</span>. If <code>set1</code> does have an enemy, then we’re in the territory of our second test case. We union <code>set1</code>’s enemies with <code>person2</code>’s set <span class="ent">➌</span>, which ensures that <code>person2</code> and all of <code>person2</code>’s friends are all enemies of <code>person1</code>.</p>
<p class="indent">That takes care of <code>set1</code>. Now we do likewise for <code>set2</code> <span class="ent">➍</span>, setting its enemy to be <code>person1</code> if it doesn’t have an enemy yet or otherwise unioning its enemies with <code>person1</code>’s set.</p>
<p class="indent">Importantly, this function maintains the symmetry of the enemy relationship: if from <code>person1</code> we can find enemy <code>person2</code>, then from <code>person2</code> we can find enemy <code>person1</code>. Consider a given call of <code>set_enemies</code> on <code>person1</code> and <code>person2</code>. If <code>person1</code> has no enemies, then its enemy becomes <code>person2</code>, but if <code>person1</code> has enemies, its enemy set grows to include <code>person2</code>. Symmetrically, if <code>person2</code> has no enemies, then its enemy becomes <code>person1</code>, and if <code>person2</code> has enemies, then its enemy set grows to include <code>person1</code>.</p>
<h4 class="h4" id="sec152"><em>AreFriends and AreEnemies</em></h4>
<p class="noindent">The AreFriends operation amounts to checking whether the two people are in the same set or, equivalently, whether they have the same representative. This can be accomplished with two calls to Find, as shown in <a href="ch09.xhtml#ch09ex014">Listing 9-14</a>.</p>
<pre>int are_friends(int person1, int person2, int parent[]) {
  return find(person1, parent) == find(person2, parent);
}</pre>
<p class="excap" id="ch09ex014"><em>Listing 9-14: Determining whether two people are friends</em></p>
<p class="indent">We have just one more operation to go! We can implement AreEnemies by checking whether one person is in the other person’s set of enemies. The code is given in <a href="ch09.xhtml#ch09ex015">Listing 9-15</a>.</p>
<pre>int are_enemies(int person1, int person2, int parent[],
                int enemy_of[]) {
  int set1, enemy;
  set1 = find(person1, parent);
  enemy = enemy_of[set1];
<span epub:type="pagebreak" id="page_364"/><span class="ent">❶</span> return (enemy != -1) &amp;&amp;
          (find(enemy, parent) == find(person2, parent));
}</pre>
<p class="excap" id="ch09ex015"><em>Listing 9-15: Determining whether two people are enemies</em></p>
<p class="indent">Two things must be true for <code>person2</code> to be an enemy of <code>person1</code> <span class="ent">❶</span>. First, <code>person1</code> must have an enemy. Second, <code>person2</code> must be in its set of enemies.</p>
<p class="indent">Hey! Shouldn’t we also check whether <code>person1</code> is an enemy of <code>person2</code>? No, that’s not needed, because the enemy relationship is symmetric. If <code>person2</code> is not an enemy of <code>person1</code>, then there’s no point checking whether <code>person1</code> is an enemy of <code>person2</code>.</p>
<p class="indent">That’s it! We have successfully augmented the vanilla union-find data structure to incorporate both friend and enemy information. If you submit your code to the judge, you should pass all test cases. What about exceeding the time limit? With union by size and path compression in there, the time limit can’t stop us.</p>
<h3 class="h3" id="lev60">Problem 3: Drawer Chore</h3>
<p class="noindent">In the Social Network and Friends and Enemies problems, we were able to use both union by size and path compression to speed up our implementations. In this next problem, we’ll attach more meaning to the root of each set. We won’t be able to use union by size, because the choice of root matters. Think about why this is as you read the problem description!</p>
<p class="indent">This is DMOJ problem <code>coci13c5p6</code>.</p>
<h4 class="h4" id="sec153"><em>The Problem</em></h4>
<p class="noindent">Mirko has <em>n</em> items strewn around his room and <em>d</em> empty drawers. The items are numbered 1, 2, . . . , <em>n</em>; the drawers are numbered 1, 2, . . . , <em>d</em>. Each drawer can hold at most one item. Mirko’s goal is to consider each item in turn, placing it in a drawer if possible and throwing it away if not.</p>
<p class="indent">Each item has exactly two drawers in which it is allowed to be placed: Drawer A and Drawer B. (It’s for organizational purposes. We wouldn’t want to put the Halloween candy with the ants, after all.) For example, we might be allowed to place item 3 in Drawer 7 (A) or Drawer 5 (B).</p>
<p class="indent">To determine what happens with each item, we use the following five rules in order:</p>
<ol>
<li class="noindent">If Drawer A is empty, put the item in Drawer A and stop.</li>
<li class="noindent">If Drawer B is empty, put the item in Drawer B and stop.</li>
<li class="noindent">If Drawer A is full, move the existing item in Drawer A to its other drawer; if that drawer is full, too, move its existing item to its other drawer; and so on. If this process would terminate, place the item in Drawer A and stop.</li>
<li class="noindent">If Drawer B is full, move the existing item in Drawer B to its other drawer; if that drawer is full, too, move its existing item to its other <span epub:type="pagebreak" id="page_365"/>drawer; and so on. If this process would terminate, place the item in Drawer B and stop.</li>
<li class="noindent">If we have failed to place the item using the first four rules, we throw the item away.</li>
</ol>
<p class="indent">Because of Rules 3 and 4, placing an item may result in other items moving to their other drawers.</p>
<p class="indent">We need to output whether each item is kept or thrown away.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing <em>n</em>, the number of items, and <em>d</em>, the number of drawers. <em>n</em> and <em>d</em> are between 1 and 300,000.</li>
<li class="noindent"><em>n</em> lines, one for each item. Each line contains two integers <em>a</em> and <em>b</em>, indicating that this item’s Drawer A is <em>a</em> and Drawer B is <em>b</em>. <em>a</em> will not be the same integer as <em>b</em>.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">The output for each item is on its own line. For each item, output <code>LADICA</code> if it is placed in a drawer and <code>SMECE</code> if it is thrown away. (These words come from the original COCI problem description: <em>ladica</em> is the Croatian word for drawer and <em>smece</em> is the Croatian word for trash.)</p>
<p class="indent">The time limit for solving the test case is one second.</p>
<h4 class="h4" id="sec154"><em>Equivalent Drawers</em></h4>
<p class="noindent">Here’s an interesting scenario: We place a new item in Drawer 1—but, uh-oh, Drawer 1 happens to be full. Its existing item’s other drawer is Drawer 2. So we move that existing item to Drawer 2 and, uh-oh again, Drawer 2 is full. Its existing item’s other drawer is Drawer 6. Ugh—Drawer 6 is full, too! We move its existing item to its other drawer, Drawer 4. Phew! Drawer 4 is empty, so we stop.</p>
<p class="indent">In the process of ultimately filling Drawer 4, we moved three existing items: from Drawer 1 to 2, from Drawer 2 to 6, and finally from Drawer 6 to 4. However, those particular moves won’t matter to us. All we’ll need to know is that Drawer 4 ends up filled.</p>
<p class="indent">Prior to adding the new item, what Drawers 1, 2, 6, and 4 had in common is that if you try to place an item in any one of them, Drawer 4 ends up getting filled. This is the sense in which these four drawers are equivalent. For example, if you place an item in Drawer 4 directly, then Drawer 4 is filled right away. If you place an item in Drawer 6, Drawer 6’s existing item moves to Drawer 4 and again Drawer 4 is filled. This pattern also holds if you place an item in Drawer 2 and, as we saw at the start of this example, if you place an item in Drawer 1. Drawer 4 is an empty drawer where the chain of drawers terminates and, thinking ahead to our union-find data structure, we see that this will be the representative of its set. Our set representatives <span epub:type="pagebreak" id="page_366"/>will always be empty drawers; every other drawer in a set will be full.</p>
<p class="indent">To make all of this concrete, let’s work through two test cases. In the first one, we’ll have <code>LADICA</code> everywhere: we’ll be able to place each item in a drawer. In the second, we’ll see some <code>SMECE</code>: there are some items that we will not be able to place.</p>
<h5 class="h5">Test Case 1</h5>
<p class="noindent">Here’s our first test case:</p>
<pre>6 7
1 2
2 6
6 4
5 3
5 7
2 5</pre>
<p class="indent">We have seven drawers, each of which starts empty and in its own set. I’ll place each set on its own line and highlight each set’s representative in italics:</p>
<p class="center"><em>1</em><br/><em>2</em><br/><em>3</em><br/><em>4</em><br/><em>5</em><br/><em>6</em><br/><em>7</em></p>
<p class="indent">It’s a good time to refresh your memory of the rules from the problem description before continuing.</p>
<p class="indent">The first item is <code>1 2</code>; that’s a Drawer A of 1 and a Drawer B of 2. Since Drawer 1 is empty, this item is placed in Drawer 1 (using Rule 1). In addition, Drawers 1 and 2 end up in the same set: placing a new item into Drawer 1 or Drawer 2 would result in the same drawer, Drawer 2, being filled. Here’s our next snapshot of the sets:</p>
<p class="center">1 <em>2</em><br/><em>3</em><br/><em>4</em><br/><em>5</em><br/><em>6</em><br/><em>7</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_367"/>Notice the new set has Drawer 2 as its representative. Using Drawer 1 as its representative would be incorrect: it would erroneously indicate that Drawer 1 is empty! This is why we won’t use union by size: it might choose the wrong root to be the representative of the resulting set.</p>
<p class="indent">Now consider the second item: <code>2 6</code>. Drawer 2 is empty, so we place this item there (using Rule 1 again). Now placing an item in Drawer 1, 2, or 6 would result in Drawer 6 being filled, so we union Drawers 1 and 2 with Drawer 6:</p>
<p class="center">1 2 <em>6</em><br/><em>3</em><br/><em>4</em><br/><em>5</em><br/><em>7</em></p>
<p class="indent">Drawer 6 is empty, so placing an item in Drawer 6 fills it immediately. Placing an item in Drawer 2 causes that drawer’s existing item to move to Drawer 6, again filling Drawer 6. Placing an item in Drawer 1 causes its existing item to move to Drawer 2, and Drawer 2’s existing item to move to Drawer 6 . . . , so Drawer 6 is filled again. That’s why we’re justified in putting all three of these drawers in the same set, with Drawer 6 as its representative.</p>
<p class="indent">The next item is <code>6 4</code>. We know what to do (using Rule 1 again):</p>
<p class="center">1 2 6 <em>4</em><br/><em>3</em><br/><em>5</em><br/><em>7</em></p>
<p class="indent">The next item is <code>5 3</code>. Again, this poses no problem (using Rule 1):</p>
<p class="center">1 2 6 <em>4</em><br/>5 <em>3</em><br/><em>7</em></p>
<p class="indent">Every item we’ve processed so far has succeeded by using Rule 1. Of course, that need not be the case, as is evinced by the next item: <code>5 7</code>. Rule 1 does not apply, because Drawer 5 is already full. Rule 2 does apply, though, because Drawer 7 is empty. This item is therefore placed in Drawer 7. The empty drawer of the unioned set is Drawer 3, so that’s our representative, as shown in the next snapshot:</p>
<p class="center">1 2 6 <em>4</em><br/>5 7 <em>3</em></p>
<p class="indent">We have one more item to go, and it’s a fun one: <code>2 5</code>. Does Rule 1 apply? No, because Drawer 2 is full. Does Rule 2 apply? No, because Drawer 5 is full. Does Rule 3 apply? Yes! It applies because Drawer 2’s set has an empty drawer (Drawer 4). How do we proceed?</p>
<p class="indent"><span epub:type="pagebreak" id="page_368"/>The argument in this case is that Drawer 2’s set and Drawer 5’s set should be unioned, like this:</p>
<p class="center">1 2 6 4 5 7 <em>3</em></p>
<p class="indent">I’ll explain why this works. The <code>2 5</code> item ends up placed in Drawer 2: existing items move from Drawer 2 to Drawer 6 and move from Drawer 6 to Drawer 4. Drawer 4 is now filled, so it can’t be the representative of its set anymore. In fact, the only relevant, empty drawer is Drawer 3, so we’re really hoping that Drawer 3 can serve as the set representative. Drawers 5, 7, and 3 should certainly be in the same set: placing an item in any of them ultimately fills Drawer 3, because they were in the same set prior to us introducing the <code>2 5</code> item.</p>
<p class="indent">It remains to explain why Drawers 1, 2, 6, and 4 should be in Drawer 3’s set, as well. Drawer 2 is fine: placing an item in Drawer 2 moves its existing item to Drawer 5. Drawer 5 is in Drawer 3’s set, so we know what happens from here: Drawer 3 will end up filled.</p>
<p class="indent">Drawer 1 is fine, too: placing an item in Drawer 1 moves its existing item to Drawer 2, and from here we can use the previous paragraph to argue that Drawer 3 will be filled. Similar logic applies to Drawers 6 and 4. For example, if we place an item in Drawer 4 and then we “undo” the moves that occurred when we filled Drawer 2, Drawer 4’s existing item moves back to Drawer 6, Drawer 6’s existing item moves back to Drawer 2, and now we’re back in the case in the previous paragraph.</p>
<p class="indent">Each item in this test case is placed in a drawer, so the correct output is as follows:</p>
<pre>LADICA
LADICA
LADICA
LADICA
LADICA
LADICA</pre>
<p class="indent">Let’s extract a general principle from this test case. Say we’re processing item <code>x y</code> and that the item ends up in <code>x</code>’s set. Then we union <code>x</code>’s set and <code>y</code>’s set, keeping <code>y</code>’s representative as the representative of the union.</p>
<p class="indent">Why is this correct? Think about what happens when we try to place an item in the unioned set, whose components are <code>x</code>’s old set and <code>y</code>’s old set. Placing it in some drawer of <code>y</code>’s set still fills <code>y</code>’s representative, because we haven’t messed with <code>y</code>’s set at all. Placing it in drawer <code>x</code> fills <code>y</code>’s representative, too, because we move <code>x</code>’s existing item to <code>y</code>, and then we’re back in the case of placing an item in a drawer of <code>y</code>’s set. The only remaining option is that the new item is placed in drawer <code>z</code> (which is different from <code>x</code>) in <code>x</code>’s set. There is a chain of drawers from drawer <code>z</code> to drawer <code>x</code>; moving items along that chain will fill drawer <code>x</code>, and from there <code>y</code>’s representative will be filled.</p>
<p class="indent">What if we’re processing item <code>x y</code>, and the item ends up in <code>y</code>’s set? In this case, the roles of the two sets are reversed. In particular, we’ll keep the representative of <code>x</code>’s set as the representative of the union set.</p>
<h5 class="h5"><span epub:type="pagebreak" id="page_369"/>Test Case 2</h5>
<p class="noindent">Now let’s see how some <code>SMECE</code> can arise. Here’s our second test case:</p>
<pre>   7 7
   1 2
   2 6
   6 4
<span class="ent">❶</span> 1 4
   2 4
   1 7
   7 6</pre>
<p class="indent">The first three items are <code>LADICA</code>s and result in a familiar state:</p>
<p class="indenti">1 2 6 <em>4</em><br/><em>3</em><br/><em>5</em><br/><em>7</em></p>
<p class="indent">Now, here’s something different: item <code>1 4</code> <span class="ent">❶</span>. For the first time, we see an item whose Drawer A and Drawer B are in the <em>same</em> set. It therefore provides no new empty drawer for this set. That is, using Rule 2 fills Drawer 4 (so it’s a <code>LADICA</code>), but it gives us no set to union. Drawers 1, 2, 6, and 4 enter a new kind of state, whereby it becomes impossible to successfully place an item in any of them! If you try, you will cycle items around forever. For example, try to place an item in Drawer 1. We can push Drawer 1’s existing item to Drawer 2, then push Drawer 2’s existing item to Drawer 6, then push Drawer 6’s existing item to Drawer 4, Drawer 4’s existing item gets pushed to Drawer 1, Drawer 1’s existing item to Drawer 2, Drawer 2’s existing item to Drawer 6, and so on and so on, until I hit my book’s page limit.</p>
<p class="indent">In our implementation, we’re going to flag this state by giving this set a representative of 0:</p>
<p class="indenti">1 2 6 4 <em>0</em><br/><em>3</em><br/><em>5</em><br/><em>7</em></p>
<p class="indent">Now we’re dangerously close to a <code>SMECE</code>. If any item comes along, both of whose drawers are in this set, then there’s no way to place it. Look at our next item: <code>2 4</code>. Can we place it in Drawer 2? No; it’s full. What about Drawer 4? No; it’s also full. Can we follow a chain of drawers from Drawer 2 to find an empty drawer? No. Is there a chain of drawers from Drawer 4 to an empty drawer? No. Four strikes. <code>SMECE</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_370"/>Moving on, we have item <code>1 7</code>. This will be processed by using Rule 2. We therefore perform a Union (because it’s a <code>LADICA</code>)—but watch out: because it’s another Union that gives us a set without an empty drawer! Here’s the result:</p>
<p class="indenti">1 2 6 4 7 <em>0</em><br/><em>3</em><br/><em>5</em></p>
<p class="indent">The final item is <code>7 6</code>, and that’s another <code>SMECE</code> because none of the four <code>LADICA</code> rules apply: Drawers 7 and 6 are in the same set, and that set has no empty drawer.</p>
<p class="indent">The correct output for this test case is:</p>
<pre>LADICA
LADICA
LADICA
LADICA
SMECE
LADICA
SMECE</pre>
<p class="indent">The only rule we haven’t explored in our test cases is Rule 4. I encourage you to play around with Rule 4 a bit before continuing. In particular, you can verify that whenever you apply Rule 4, the representative of the unioned set will be 0.</p>
<p class="indent">Now it’s implementation time!</p>
<h4 class="h4" id="sec155"><em>The main Function</em></h4>
<p class="noindent">Let’s start with the <code>main</code> function, which reads each item from the input and processes it. The code is given in <a href="ch09.xhtml#ch09ex016">Listing 9-16</a>.</p>
<pre>#define MAX_DRAWERS 300000

int main(void) {
  static int parent[MAX_DRAWERS + 1];
  int num_items, num_drawers, i;
  int drawer_a, drawer_b;
  scanf("%d%d", &amp;num_items, &amp;num_drawers);
<span class="ent">❶</span> parent[0] = 0;
   for (i = 1; i &lt;= num_drawers; i++)
     parent[i] = i;

   for (i = 1; i &lt;= num_items; i++) {
     scanf("%d%d", &amp;drawer_a, &amp;drawer_b);

  <span class="ent">➋</span> if (find(drawer_a, parent) == drawer_a)
    <span class="ent">➌</span> union_sets(drawer_a, drawer_b, parent);
<span epub:type="pagebreak" id="page_371"/>  <span class="ent">➍</span> else if (find(drawer_b, parent) == drawer_b)
    <span class="ent">➎</span> union_sets(drawer_b, drawer_a, parent);

  <span class="ent">➏</span> else if (find(drawer_a, parent) &gt; 0)
    <span class="ent">❼</span> union_sets(drawer_a, drawer_b, parent);

  <span class="ent">❽</span> else if (find(drawer_b, parent) &gt; 0)
    <span class="ent">❾</span> union_sets(drawer_b, drawer_a, parent);

     else
       printf("SMECE\n");
  }
  return 0;
}</pre>
<p class="excap" id="ch09ex016"><em>Listing 9-16: The</em> <span class="codeitalic1">main</span> <em>function for processing items</em></p>
<p class="indent">As usual, the <code>parent</code> array records the parent of each node in the union-find data structure. Items are numbered starting from 1, so it’s safe for us to use a representative of 0 for the drawers that can never have a new item placed in them. We give 0 a representative of 0 <span class="ent">❶</span> to indicate that this set, like all other sets, starts out empty.</p>
<p class="indent">Now, let’s look at those five rules. We implement each of the four <code>LADICA</code> rules with one call to <code>find</code> and one call to <code>union</code>. If none of these rules applies, then we’re in the <code>SMECE</code> case. Let’s go through each <code>LADICA</code> rule in turn.</p>
<p class="indent">For Rule 1, we need to know whether <code>drawer_a</code> is empty. Remember that each set of drawers (not including the “0” set) has exactly one empty drawer and that this empty drawer is the representative of the set. The <code>find</code> function returns the representative of the given set. Putting these two facts together, we see that <code>find</code> returns <code>drawer_a</code> exactly when <code>drawer_a</code> is empty <span class="ent">➋</span>.</p>
<p class="indent">If we are in the Rule 1 case, then we need to union <code>drawer_a</code>’s set with <code>drawer_b</code>’s set. We therefore call <code>union_sets</code> <span class="ent">➌</span>. Careful, though: remember that we must make <code>drawer_b</code>’s representative be the representative of the new set, because <code>drawer_a</code>’s set has no empty drawers now that <code>drawer_a</code> is full. To make that happen, we’ll use an implementation of <code>union_sets</code> that does not perform union by size. It guarantees that the representative of the second parameter that we pass—<code>drawer_b</code> here—will be the representative of the unioned set. It’s also responsible for outputting the <code>LADICA</code> message. We’ll see that code in the next subsection.</p>
<p class="indent">For Rule 2, we need to know if <code>drawer_b</code> is empty. We again use <code>find</code> to check this <span class="ent">➍</span>, and we perform the Union operation if this rule applies <span class="ent">➎</span>. This time, we call <code>union_sets</code> with the drawers in the opposite order so that <code>drawer_a</code>’s representative becomes the representative of the unioned set.</p>
<p class="indent">For Rule 3, we need to know whether <code>drawer_a</code>’s set has an empty drawer. A set has an empty drawer unless the set’s representative is 0. We use <code>find</code> to check this condition <span class="ent">➏</span>: if <code>find</code> returns a representative other than 0, then this set has an empty drawer. If this rule applies, then we perform the <span epub:type="pagebreak" id="page_372"/>expected Union <span class="ent">❼</span>. We’ll see in the next subsection how <code>union_sets</code> is responsible for appropriately moving sets to the “0” set.</p>
<p class="indent">Finally, for Rule 4, we need to know whether <code>drawer_b</code>’s set has an empty drawer. The logic is the same as that for Rule 3: use <code>find</code> to check whether this set has an empty drawer <span class="ent">❽</span>; if it does, perform the Union <span class="ent">❾</span>.</p>
<h4 class="h4" id="sec156"><em>Find and Union</em></h4>
<p class="noindent">The Find function is given in <a href="ch09.xhtml#ch09ex017">Listing 9-17</a>. It uses path compression. That’s a good thing, because I just submitted a solution without path compression and I received a “Time-Limit Exceeded” error. #PathCompressionWins.</p>
<pre>int find(int drawer, int parent[]) {
  int set = drawer, temp;
  while (parent[set] !=  set)
    set = parent[set];
  while (parent[drawer] != set) {
    temp = parent[drawer];
    parent[drawer] = set;
    drawer = temp;
  }
  return set;
}</pre>
<p class="excap" id="ch09ex017"><em>Listing 9-17: The</em> <span class="codeitalic1">find</span> <em>function</em></p>
<p class="indent">The Union function is given in <a href="ch09.xhtml#ch09ex018">Listing 9-18</a>.</p>
<pre>void union_sets(int drawer1, int drawer2, int parent[]) {
  int set1, set2;
  set1 = find(drawer1, parent);
  set2 = find(drawer2, parent);
<span class="ent">❶</span> parent[set1] = set2;
<span class="ent">➋</span> if (set1 == set2)
  <span class="ent">➌</span> parent[set2] = 0; 
   printf("LADICA\n");
}</pre>
<p class="excap" id="ch09ex018"><em>Listing 9-18: The</em> <span class="codeitalic1">union_sets</span> <em>function</em></p>
<p class="indent">As promised, there’s no union by size here: we always use <code>set2</code>, the set of <code>drawer2</code>, as the new set <span class="ent">❶</span>.</p>
<p class="indent">In addition, whenever an item is placed whose drawers are in the same set <span class="ent">➋</span>, we set the representative of the resulting set to <code>0</code> <span class="ent">➌</span>. Whenever <code>find</code> is later called on any element of this resulting set, <code>0</code> will be returned, correctly indicating that no item can ever be placed in this set again.</p>
<p class="indent">There we have it: a 50-line union-find solution to one of the most challenging problems in this book. Please submit your code to the judge!</p>
<h3 class="h3" id="lev61"><span epub:type="pagebreak" id="page_373"/><strong>Summary</strong></h3>
<p class="noindent">In this chapter, we’ve learned how to efficiently implement the union-find data structure. Of all the data structures in this book, the union-find data structure is the one that surprises me most with the breadth of its applications. “Really? This is a union-find problem?” I frequently have that thought. Perhaps you similarly had that thought when we solved Friends and Enemies or Drawer Chore. In any case, you’re likely to encounter other problems, seemingly quite different from those that I presented here, where union-find nevertheless applies.</p>
<p class="indent">Happily, given its wide applicability and speedy performance, we don’t need huge amounts of code to implement union-find: just a few lines for Union and a few lines for Find. In addition, you may find that the code isn’t too tricky, once we’ve learned about the array representation for the trees. Even the optimizations, union by size and path compression, require little code.</p>
<h3 class="h3" id="lev62">Notes</h3>
<p class="noindent">Drawer Chore is originally from the 2013 Croatian Open Competition in Informatics, Round 5. I found the “0 representative” idea from the COCI website (see <em><a href="http://hsin.hr/coci/archive/2013_2014">http://hsin.hr/coci/archive/2013_2014</a></em>).<span epub:type="pagebreak" id="page_374"/></p>
</body></html>