<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="275" id="Page_275"/>15</span><br/>&#13;
<span class="ChapterTitle">Analyzing Spatial Data with PostGIS</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">We now turn to <em>spatial data</em>, defined as information about the location, shape, and attributes of objects—points, lines, or polygons, for example—within a geographical space. In this chapter, you’ll learn how to construct and query spatial data using SQL, and you’ll be introduced to the PostGIS extension for PostgreSQL that enables support for spatial data types and functions.</p>&#13;
<p>Spatial data has become a critical piece of our world’s data ecosystem. A phone app can find nearby coffee shops because it queries a spatial database, asking it to return a list of shops within a certain distance of your location. Governments use spatial data to track the footprints of residential and business parcels; epidemiologists use it to visualize the spread of diseases.</p>&#13;
<p>For our exercises, we’ll analyze the location of farmers’ markets across the United States as well as roads and waterways in Santa Fe, New Mexico. You’ll learn how to construct and query spatial data types and incorporate <span epub:type="pagebreak" title="276" id="Page_276"/>map projections and grid systems. You’ll receive tools to glean information from spatial data, similar to how you’ve analyzed numbers and text.</p>&#13;
<p>We’ll start by setting up PostGIS. All code and data for the exercises are available with the book’s resources at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>.</p>&#13;
<h2 id="h1-501065c15-0001">Enabling PostGIS and Creating a Spatial Database</h2>&#13;
<p class="BodyFirst">PostGIS is a free, open source project created by the Canadian geospatial company Refractions Research and maintained by an international team of developers under the Open Source Geospatial Foundation (OSGeo). The GIS portion of its name refers to <em>geographic information system</em>, defined as a system that allows for storing, editing, analyzing, and displaying spatial data. You’ll find documentation and updates at <a href="https://postgis.net/" class="LinkURL">https://postgis.net/</a>.</p>&#13;
<p>If you installed PostgreSQL following the steps for Windows, macOS, or the Ubuntu flavor of Linux in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, PostGIS should be on your machine. If you installed PostgreSQL some other way on Windows or macOS or if you’re on another Linux distribution, follow the installation instructions at <a href="https://postgis.net/install/" class="LinkURL">https://postgis.net/install/</a>.</p>&#13;
<p>To enable PostGIS on your <code>analysis</code> database, open pgAdmin’s Query Tool and run the statement in <a href="#listing15-1" id="listinganchor15-1">Listing 15-1</a>.</p>&#13;
<pre><code>CREATE EXTENSION postgis;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-1">Listing 15-1</a>: Loading the PostGIS extension</p>&#13;
<p>You’ll see the message <code>CREATE EXTENSION</code>, advising that your database has been updated to include spatial data types and analysis functions. Run <code class="bold">SELECT postgis_full_version();</code> to display the version number of PostGIS along with the versions of its installed components. The version won’t match your installed PostgreSQL version, and that’s okay.</p>&#13;
<h2 id="h1-501065c15-0002">Understanding the Building Blocks of Spatial Data</h2>&#13;
<p class="BodyFirst">Before you learn to query spatial data, let’s look at how it’s described in GIS and related data formats. This is important background, but if you want to dive straight into queries, you can skip to “Understanding PostGIS Data Types” later in the chapter and return here afterward.</p>&#13;
<p>A point on a grid is the smallest building block of spatial data. The grid might be marked with x- and y-axes, or longitude and latitude if we’re using a map. A grid could be flat with two dimensions, or it could describe a three-dimensional space such as a cube. In some data formats, such as the JavaScript-based <em>GeoJSON</em>, a point may have attributes in addition to its location. We could describe a grocery store with a point containing its <span epub:type="pagebreak" title="277" id="Page_277"/>longitude and latitude as well as attributes for the store’s name and hours of operation.</p>&#13;
<h2 id="h1-501065c15-0003">Understanding Two-Dimensional Geometries</h2>&#13;
<p class="BodyFirst">The Open Geospatial Consortium (OGC) and International Organization for Standardization (ISO) have created a <em>simple features access</em> model that describes standards for building and querying two- and three-dimensional shapes, sometimes referred to as <em>geometries</em>. PostGIS supports the standard.</p>&#13;
<p>The following are the more common features, starting with points and building in complexity:</p>&#13;
<p class="ListHead"><b>Point</b></p>&#13;
<ol class="none">&#13;
<li>A single location in a two- or three-dimensional plane. On maps, a Point is usually a dot marking a longitude and latitude.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>LineString</b></p>&#13;
<ol class="none">&#13;
<li>Two or more Points, each connected by straight lines. A LineString can represent features such as a road, biking trail, or stream.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>Polygon</b></p>&#13;
<ol class="none">&#13;
<li>A two-dimensional shape with three or more straight sides, each constructed from a LineString. On maps, Polygons represent objects such as nations, states, buildings, and bodies of water. A Polygon can have one or more interior Polygons that act as holes inside the larger Polygon.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>MultiPoint</b></p>&#13;
<ol class="none">&#13;
<li>A set of Points. A single MultiPoint object could represent multiple locations of a retailer with each store’s latitude and longitude.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>MultiLineString</b></p>&#13;
<ol class="none">&#13;
<li>A set of LineStrings. An example is a road that has several noncontinuous segments.</li>&#13;
</ol>&#13;
<p class="ListHead"><b>MultiPolygon</b></p>&#13;
<ol class="none">&#13;
<li>A set of Polygons. A parcel of land that’s divided into parts by a road could be grouped in one MultiPolygon object instead of separate polygons.</li>&#13;
</ol>&#13;
<p><a href="#figure15-1" id="figureanchor15-1">Figure 15-1</a> shows an example of each feature. PostGIS enables functions to build, edit, and analyze these objects. These functions take a variety of inputs depending on their purpose, including latitude and longitude, specialized text and binary formats, and simple features. Some functions also take an optional <em>spatial reference system identifier (SRID)</em> that specifies the grid on which to place the objects.</p>&#13;
<span epub:type="pagebreak" title="278" id="Page_278"/><figure>&#13;
<img src="Images/f15001.png" alt="f15001" class="" width="618" height="376"/>&#13;
<figcaption><p><a id="figure15-1">Figure 15-1</a>: Visual examples of geometries</p></figcaption>&#13;
</figure>&#13;
<p>I’ll explain the SRID shortly, but first, let’s look at examples of an input used by PostGIS functions called <em>well-known text (WKT)</em>—a text-based format that represents a geometry.</p>&#13;
<h3 id="h2-501065c15-0001">Well-Known Text Formats</h3>&#13;
<p class="BodyFirst">The OGC standard’s WKT format specifies a geometry type and its coordinates inside one or more sets of parentheses. The number of coordinates and parentheses varies depending on the type of geometry. <a href="#table15-1" id="tableanchor15-1">Table 15-1</a> shows examples of frequently used geometry types and their WKT formats. Longitude/latitude pairs are shown for the coordinates, but you might encounter grid systems that use other measures.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	WKT accepts coordinates in the order of (longitude, latitude), which is backward from Google Maps and some other software. Tom MacWright, formerly of the Mapbox software company, notes at <a href="https://macwright.com/lonlat/" class="LinkURL">https://macwright.com/lonlat/</a> that neither order is “right” and catalogs the “frustrating inconsistency” in which mapping-related code handles the order of coordinates.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table15-1">Table 15-1</a>: Well-Known Text Formats for Geometries</p></figcaption>&#13;
<table id="table-501065c15-0001" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Geometry</b></td>&#13;
<td><b>Format</b></td>&#13;
<td><b>Notes</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Point</td>&#13;
<td><code>POINT (-74.9 42.7)</code></td>&#13;
<td>A coordinate pair marking a point at −74.9 longitude and 42.7 latitude.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>LineString</td>&#13;
<td><code>LINESTRING (-74.9 42.7, -75.1 42.7)</code></td>&#13;
<td>A straight line with endpoints marked by two coordinate pairs.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>Polygon</td>&#13;
<td><code>POLYGON ((-74.9 42.7, -75.1 42.7, -75.1 42.6, -74.9 42.7))</code></td>&#13;
<td>A triangle outlined by three different pairs of coordinates. Although listed twice, the first and last pair are the same coordinates where we close the shape.</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span epub:type="pagebreak" title="279" id="Page_279"/>MultiPoint</td>&#13;
<td><code>MULTIPOINT (-74.9 42.7, -75.1 42.7)</code></td>&#13;
<td>Two Points, one for each pair of coordinates.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>MultiLineString</td>&#13;
<td><code>MULTILINESTRING ((-76.27 43.1, -76.06 43.08), (-76.2 43.3, -76.2 43.4, -76.4 43.1))</code></td>&#13;
<td>Two LineStrings. The first has two points; the second has three. </td>&#13;
</tr>&#13;
<tr>&#13;
<td>MultiPolygon</td>&#13;
<td><code>MULTIPOLYGON (((-74.92 42.7, -75.06 42.71, -75.07 42.64, -74.92 42.7), (-75.0 42.66, -75.0 42.64, -74.98 42.64, -74.98 42.66, -75.0 42.66)))</code></td>&#13;
<td>Two Polygons. The first is a triangle, and the second is a rectangle.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>These examples create simple shapes, as you’ll see when we construct them using PostGIS later in the chapter. In practice, complex geometries will comprise thousands of coordinates.</p>&#13;
<h3 id="h2-501065c15-0002">Projections and Coordinate Systems</h3>&#13;
<p class="BodyFirst">Representing Earth’s spherical surface on a two-dimensional map is not easy. Imagine peeling the outer layer of Earth from the globe and trying to spread it on a table while keeping all pieces of the continents and oceans connected. Inevitably, you’d have to stretch some parts of the map. That’s what happens when cartographers create a map<em> projection</em> with its own <em>projected coordinate system</em>. A projection is simply a flattened representation of the globe with its own two-dimensional coordinate system.</p>&#13;
<p>Some projections represent the entire world; others are specific to regions or purposes. The <em>Mercator projection</em> has properties useful for navigation; Google Maps and other online maps use a variant of called <em>Web Mercator</em>. The math behind its transformation distorts land areas close to the North and South Poles, making them appear much larger than reality. The US Census Bureau uses the <em>Albers projection</em>, which minimizes distortion and is the one you see on TV in the United States as votes are tallied on election night.</p>&#13;
<p>Projections are derived from <em>geographic coordinate systems</em>, which define the grid of latitude, longitude, and height of any point on the globe along with factors including Earth’s shape. Whenever you obtain geographic data, it’s critical to know the coordinate systems it references so you provide the correct information when writing queries. Often, user documentation will name the coordinate system. &#13;
Next, let’s look at how to specify the coordinate system in PostGIS.</p>&#13;
<h3 id="h2-501065c15-0003">Spatial Reference System Identifier</h3>&#13;
<p class="BodyFirst">When using PostGIS (and many GIS applications), you specify the coordinate system via its unique SRID. When you enabled the PostGIS extension at the beginning of this chapter, the process created the table <code/><span epub:type="pagebreak" title="280" id="Page_280"/>spatial_ref_sys, which contains SRIDs as its primary key. The table also contains the column <code>srtext</code>, which includes a WKT representation of the spatial reference system plus other metadata.</p>&#13;
<p>In this chapter, we’ll frequently use SRID <code>4326</code>, the ID for the geographic coordinate system WGS 84. That’s the most recent World Geodetic System (WGS) standard used by GPS, and you’ll encounter it often in spatial data. You can see the WKT representation for WGS 84 by running the code in <a href="#listing15-2" id="listinganchor15-2">Listing 15-2</a> that looks for its SRID, <code>4326</code>:</p>&#13;
<pre><code>SELECT srtext&#13;
FROM spatial_ref_sys&#13;
WHERE srid = 4326;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-2">Listing 15-2</a>: Retrieving the WKT for SRID <code>4326</code></p>&#13;
<p>Run the query and you should get the following result, indented for readability:</p>&#13;
<pre><code>GEOGCS["WGS 84",&#13;
    DATUM["WGS_1984",&#13;
        SPHEROID["WGS 84",6378137,298.257223563,&#13;
            AUTHORITY["EPSG","7030"]],&#13;
        AUTHORITY["EPSG","6326"]],&#13;
    PRIMEM["Greenwich",0,&#13;
        AUTHORITY["EPSG","8901"]],&#13;
    UNIT["degree",0.0174532925199433,&#13;
        AUTHORITY["EPSG","9122"]],&#13;
    AUTHORITY["EPSG","4326"]]</code></pre>&#13;
<p>You don’t need to use this information for any of this chapter’s exercises, but it’s helpful to know some of the variables and how they define the projection. The <code>GEOGCS</code> keyword provides the geographic coordinate system in use. Keyword <code>PRIMEM</code> specifies the location of the <em>prime meridian</em>, or longitude 0. To see definitions of all the variables, check the reference at <a href="https://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html" class="LinkURL">https://docs.geotools.org/stable/javadocs/org/opengis/referencing/doc-files/WKT.html</a>.</p>&#13;
<p>Conversely, if you ever need to find the SRID associated with a coordinate system, you can query the <code>srtext</code> column in <code>spatial_ref_sys</code> to find it.</p>&#13;
<h2 id="h1-501065c15-0004">Understanding PostGIS Data Types</h2>&#13;
<p class="BodyFirst">Installing PostGIS adds several data types to your database. We’ll use two: <code>geography</code> and <code>geometry</code>. Both types can store spatial data, such as the points, lines, polygons, and SRIDs you just learned about, but they have important distinctions:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>geography</code></span><span class="LiteralBold"><code>  </code></span></span>A data type based on a sphere, using the round-Earth coordinate system (longitude and latitude). All calculations occur on the globe, taking its curvature into account. This makes the math complex and limits the number of functions available to work with the <code>geography</code> type. But because Earth’s curvature is factored in, calculations for <span epub:type="pagebreak" title="281" id="Page_281"/>distance are more precise; you should use the <code>geography</code> data type when handling data that spans large areas. The results from calculations on the <code>geography</code> type will be expressed in meters.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>geometry</code></span><span class="LiteralBold"><code> </code></span></span>  A data type based on a plane, using the Euclidean coordinate system. Calculations occur on straight lines as opposed to along the curvature of a sphere, making calculations for geographical distance less precise than with the <code>geography</code> data type; the results of calculations are expressed in units of whichever coordinate system you’ve designated.</li>&#13;
</ol>&#13;
<p>The PostGIS documentation at <a href="https://postgis.net/docs/using_postgis_dbmanagement.html" class="LinkURL">https://postgis.net/docs/using_postgis_dbmanagement.html</a> offers guidance on when to use one or the other type. In short, if you’re working strictly with longitude/latitude data or if your data covers a large area, such as a continent or the globe, use the <code>geography</code> type, even though it limits the functions you can use. If your data covers a smaller area, the <code>geometry</code> type provides more functions and better performance. You can also convert one type to the other using <code>CAST</code>.</p>&#13;
<p>With the background you have now, we can start working with spatial objects.</p>&#13;
<h2 id="h1-501065c15-0005">Creating Spatial Objects with PostGIS Functions</h2>&#13;
<p class="BodyFirst">PostGIS has more than three dozen constructor functions that build spatial objects using WKT or coordinates. You can find a list at <a href="https://postgis.net/docs/reference.html#Geometry_Constructors" class="LinkURL">https://postgis.net/docs/reference.html#Geometry_Constructors</a>, but the following sections explain several that you’ll use in the exercises. Most PostGIS functions begin with the letters <em>ST</em>, which is an ISO naming standard that means <em>spatial type</em>.</p>&#13;
<h3 id="h2-501065c15-0004">Creating a Geometry Type from Well-Known Text</h3>&#13;
<p class="BodyFirst">The <code>ST_GeomFromText(</code><var>WKT</var><code>, </code><var>SRID</var><code>)</code> function creates a <code>geometry</code> data type from an input of a WKT string and an optional SRID. <a href="#listing15-3" id="listinganchor15-3">Listing 15-3</a> shows simple <code>SELECT</code> statements that generate <code>geometry</code> data types for each of the simple features described in <a href="#table15-1">Table 15-1</a>.</p>&#13;
<pre><code>SELECT ST_GeomFromText(<span class="CodeAnnotation" aria-label="annotation1">1</span>'POINT(-74.9233606 42.699992)', <span class="CodeAnnotation" aria-label="annotation2">2</span>4326);&#13;
&#13;
SELECT ST_GeomFromText('LINESTRING(-74.9 42.7, -75.1 42.7)', 4326);&#13;
&#13;
SELECT ST_GeomFromText('POLYGON((-74.9 42.7, -75.1 42.7,&#13;
                                 -75.1 42.6, -74.9 42.7))', 4326);&#13;
&#13;
SELECT ST_GeomFromText('MULTIPOINT (-74.9 42.7, -75.1 42.7)', 4326);&#13;
&#13;
SELECT ST_GeomFromText('MULTILINESTRING((-76.27 43.1, -76.06 43.08),&#13;
                                        (-76.2 43.3, -76.2 43.4,&#13;
                                         -76.4 43.1))', 4326);&#13;
&#13;
SELECT ST_GeomFromText('MULTIPOLYGON<span class="CodeAnnotation" aria-label="annotation3">3</span>((&#13;
                                       (-74.92 42.7, -75.06 42.71,&#13;
<span epub:type="pagebreak" title="282" id="Page_282"/>                                        -75.07 42.64, -74.92 42.7)<span class="CodeAnnotationCode" aria-label="annotation4">4</span>,&#13;
                                       (-75.0 42.66, -75.0 42.64,&#13;
                                        -74.98 42.64, -74.98 42.66,&#13;
                                        -75.0 42.66)))', 4326);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-3">Listing 15-3</a>: Using <code>ST_GeomFromText()</code> to create spatial objects</p>&#13;
<p>For each example, we give a WKT string as the first input and the SRID <code>4326</code> as the second. In the first example, we create a Point by inserting the WKT <code>POINT</code> string <span class="CodeAnnotation" aria-label="annotation1">1</span> as the first argument to <code>ST_GeomFromText()</code> with the SRID <span class="CodeAnnotation" aria-label="annotation2">2</span> as the optional second argument. We use the same format in the rest of the examples. Note that we don’t have to indent the coordinates. I do so here only to make the coordinate pairs more readable.</p>&#13;
<p>Be sure to mind the number of parentheses that segregate objects, particularly in complex structures such as the MultiPolygon. For example, we need to use two opening parentheses <span class="CodeAnnotation" aria-label="annotation3">3</span> and enclose each polygon’s coordinates within another set of parentheses <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>&#13;
<p>If you run each statement separately in pgAdmin, you can view both its data output and visual representation. Upon execution, each statement should return a single column of the <code>geometry</code> data type displayed as a string of characters that looks something like this truncated example:</p>&#13;
<pre><code>0101000020E61000008EDA0E5718BB52C017BB7D5699594540 ...</code></pre>&#13;
<p>The string is of the format <em>extended well-known binary (EWKB)</em>, which you typically won’t need to interpret directly. Instead, you’ll use columns of geometry (or geography) data as inputs to other functions. To see the visual representation, click the eye icon in the pgAdmin result column header. That should open a Geometry Viewer pane in pgAdmin that displays the geometry atop a map that uses OpenStreetMap as the base layer. For example, the <code>MULTIPOLYGON</code> example in <a href="#listing15-3">Listing 15-3</a> should look like <a href="#figure15-2" id="figureanchor15-2">Figure 15-2</a>, with a triangle and a rectangle.</p>&#13;
<figure>&#13;
<img src="Images/f15002.png" alt="f15002" class="keyline" width="694" height="368"/>&#13;
<figcaption><p><a id="figure15-2">Figure 15-2</a>: Viewing geometries in pgAdmin</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" title="283" id="Page_283"/>Try viewing each example in <a href="#listing15-3">Listing 15-3</a> to get to know the differences between objects.</p>&#13;
<h3 id="h2-501065c15-0005">Creating a Geography Type from Well-Known Text</h3>&#13;
<p class="BodyFirst">To create a <code>geography</code> data type, you can use <code>ST_GeogFromText(</code><var>WKT</var><code>)</code> to convert a WKT or <code>ST_GeogFromText(</code><var>EWKT</var><code>)</code> to convert a PostGIS-specific variation called <em>extended WKT</em> that includes the SRID. <a href="#listing15-4" id="listinganchor15-4">Listing 15-4</a> shows how to pass in the SRID as part of the extended WKT string to create a MultiPoint <code>geography</code> object with three points.</p>&#13;
<pre><code>SELECT&#13;
ST_GeogFromText('SRID=4326;MULTIPOINT(-74.9 42.7, -75.1 42.7, -74.924 42.6)')</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-4">Listing 15-4</a>: Using <code>ST_GeogFromText()</code> to create spatial objects</p>&#13;
<p>Again, you can view the Points on a map by clicking the eye icon in the geography column in the pgAdmin results grid.</p>&#13;
<p>Along with the all-purpose <code>ST_GeomFromText()</code> and <code>ST_GeogFromText()</code> functions, PostGIS includes several that are specific to creating certain spatial objects. I’ll cover those briefly next.</p>&#13;
<h3 id="h2-501065c15-0006">Using Point Functions</h3>&#13;
<p class="BodyFirst">The <code>ST_PointFromText()</code> and <code>ST_MakePoint()</code> functions will turn a WKT <code>POINT</code> or a collection of coordinates, respectively, into a <code>geometry</code> data type. Points mark coordinates, such as longitude and latitude, which you would use to identify locations or use as building blocks of other objects, such as LineStrings.</p>&#13;
<p><a href="#listing15-5" id="listinganchor15-5">Listing 15-5</a> shows how these functions work.</p>&#13;
<pre><code>SELECT <span class="CodeAnnotation" aria-label="annotation1">1</span>ST_PointFromText('POINT(-74.9233606 42.699992)', 4326);&#13;
&#13;
SELECT <span class="CodeAnnotation" aria-label="annotation2">2</span>ST_MakePoint(-74.9233606, 42.699992);&#13;
SELECT <span class="CodeAnnotation" aria-label="annotation3">3</span>ST_SetSRID(ST_MakePoint(-74.9233606, 42.699992), 4326);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-5">Listing 15-5</a>: Functions specific to making Points</p>&#13;
<p>The <code>ST_PointFromText(</code><var>WKT</var><code>, </code><var>SRID</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function creates a point <code>geometry</code> type from a WKT <code>POINT</code> and an optional SRID as the second input. The PostGIS docs note that the function includes validation of coordinates that makes it slower than the <code>ST_GeomFromText()</code> function.</p>&#13;
<p>The <code>ST_MakePoint(</code><var>x</var><code>, </code><var>y</var><code>, </code><var>z</var><code>, </code><var>m</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function creates a point <code>geometry</code> type on a two-, three-, and four-dimensional grid. The first two parameters, <var>x</var> and <var>y</var> in the example, represent longitude and latitude coordinates. You can use the optional <var>z</var> to represent altitude and <var>m</var> to represent a measure. That would allow you, for example, to mark a water fountain on a bike trail at a certain altitude and certain distance from the start of the trail. The <code>ST_MakePoint()</code> function is faster than <code>ST_GeomFromText()</code> and <code>ST_PointFromText()</code>, but if you want to specify an SRID, you’ll need to designate one by wrapping it inside the <code>ST_SetSRID()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function.</p>&#13;
<h3 id="h2-501065c15-0007"><span epub:type="pagebreak" title="284" id="Page_284"/>Using LineString Functions</h3>&#13;
<p class="BodyFirst">Now let’s examine some functions we use specifically for creating LineString <code>geometry</code> data types. <a href="#listing15-6" id="listinganchor15-6">Listing 15-6</a> shows how they work.</p>&#13;
<pre><code>SELECT <span class="CodeAnnotation" aria-label="annotation1">1</span>ST_LineFromText('LINESTRING(-105.90 35.67,-105.91 35.67)', 4326);&#13;
SELECT <span class="CodeAnnotation" aria-label="annotation2">2</span>ST_MakeLine(ST_MakePoint(-74.9, 42.7), ST_MakePoint(-74.1, 42.4));</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-6">Listing 15-6</a>: Functions specific to making LineStrings</p>&#13;
<p>The <code>ST_LineFromText(</code><var>WKT</var><code>, </code><var>SRID</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function creates a LineString from a WKT <code>LINESTRING</code> and an optional SRID as its second input. Like <code>ST_PointFromText()</code> earlier, this function includes validation of coordinates that makes it slower than <code>ST_GeomFromText()</code>.</p>&#13;
<p>The <code>ST_MakeLine(</code><var>geom</var><code>, </code><var>geom</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function creates a LineString from inputs that must be of the <code>geometry</code> data type. In <a href="#listing15-6">Listing 15-6</a>, the example uses two <code>ST_MakePoint()</code> functions as inputs to create the start and endpoint of the line. You can also pass in an <code>ARRAY</code> object with multiple points, perhaps generated by a subquery, to generate a more complex line.</p>&#13;
<h3 id="h2-501065c15-0008">Using Polygon Functions</h3>&#13;
<p class="BodyFirst">Let’s look at three Polygon functions: <code>ST_PolygonFromText()</code>, <code>ST_MakePolygon()</code>, and <code>ST_MPolyFromText()</code>. All create <code>geometry</code> data types. <a href="#listing15-7" id="listinganchor15-7">Listing 15-7</a> shows how you can create Polygons with each.</p>&#13;
<pre><code>SELECT <span class="CodeAnnotation" aria-label="annotation1">1</span>ST_PolygonFromText('POLYGON((-74.9 42.7, -75.1 42.7,&#13;
                                      -75.1 42.6, -74.9 42.7))', 4326);&#13;
&#13;
SELECT <span class="CodeAnnotation" aria-label="annotation2">2</span>ST_MakePolygon(&#13;
             ST_GeomFromText('LINESTRING(-74.92 42.7, -75.06 42.71,&#13;
                                         -75.07 42.64, -74.92 42.7)', 4326));&#13;
&#13;
SELECT <span class="CodeAnnotation" aria-label="annotation3">3</span>ST_MPolyFromText('MULTIPOLYGON((&#13;
                                         (-74.92 42.7, -75.06 42.71,&#13;
                                          -75.07 42.64, -74.92 42.7),&#13;
                                         (-75.0 42.66, -75.0 42.64,&#13;
                                          -74.98 42.64, -74.98 42.66,&#13;
                                          -75.0 42.66)&#13;
                                        ))', 4326);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-7">Listing 15-7</a>: Functions specific to making Polygons</p>&#13;
<p>The <code>ST_PolygonFromText(</code><var>WKT</var><code>, </code><var>SRID</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function creates a Polygon from a WKT <code>POLYGON</code> and an optional SRID. As with the similarly named functions for creating points and lines, it includes a validation step that makes it slower than <code>ST_GeomFromText()</code>.</p>&#13;
<p>The <code>ST_MakePolygon(</code><var>linestring</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function creates a Polygon from a LineString that must open and close with the same coordinates, ensuring the object is closed. This example uses <code>ST_GeomFromText()</code> to create the LineString geometry using a WKT <code>LINESTRING</code>.</p>&#13;
<p>The <code>ST_MPolyFromText(</code><var>WKT</var><code>, </code><var>SRID</var><code>)</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function creates a MultiPolygon from a WKT and an optional SRID.</p>&#13;
<p><span epub:type="pagebreak" title="285" id="Page_285"/>Now you have the building blocks to analyze spatial data. Next, we’ll use them to explore a set of data.</p>&#13;
<h2 id="h1-501065c15-0006">Analyzing Farmers’ Markets Data</h2>&#13;
<p class="BodyFirst">The National Farmers’ Market Directory from the US Department of Agriculture catalogs the location and offerings of more than 8,600 “markets that feature two or more farm vendors selling agricultural products directly to customers at a common, recurrent physical location,” according to the update page linked from the main directory site at <a href="https://www.ams.usda.gov/local-food-directories/farmersmarkets/" class="LinkURL">https://www.ams.usda.gov/local-food-directories/farmersmarkets/</a>. Attending these markets is a fun weekend activity, so let’s use SQL spatial queries to find the closest markets.</p>&#13;
<p>The <em>farmers_markets.csv</em> file contains a portion of the USDA data on each market, and it’s available along with the book’s resources at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>. Save the file to your computer and run the code in <a href="#listing15-8" id="listinganchor15-8">Listing 15-8</a> to create and load a <code>farmers_markets</code> table.</p>&#13;
<pre><code>CREATE TABLE farmers_markets (&#13;
    fmid bigint PRIMARY KEY,&#13;
    market_name text NOT NULL,&#13;
    street text,&#13;
    city text,&#13;
    county text,&#13;
    st text NOT NULL,&#13;
    zip text,&#13;
    longitude numeric(10,7),&#13;
    latitude numeric(10,7),&#13;
    organic text NOT NULL&#13;
);&#13;
&#13;
COPY farmers_markets&#13;
FROM '<var>C:\YourDirectory\</var>farmers_markets.csv'&#13;
WITH (FORMAT CSV, HEADER);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-8">Listing 15-8</a>: Creating and loading the <code>farmers_markets</code> table</p>&#13;
<p>The table contains routine address data plus the <code>longitude</code> and <code>latitude</code> for most markets. Twenty-nine of the markets were missing those values when I downloaded the file from the USDA. An <code>organic</code> column indicates whether the market offers organic products; a hyphen (<code>-</code>) in that column indicates an unknown value. After you import the data, count the rows using <code>SELECT count(*) FROM farmers_markets;</code>. If everything imported correctly, you should have 8,681 rows.</p>&#13;
<h3 id="h2-501065c15-0009">Creating and Filling a Geography Column</h3>&#13;
<p class="BodyFirst">To perform spatial queries on the markets’ longitude and latitude, we need to convert those coordinates into a single column with a spatial data type. Because we’re working with locations spanning the entire United States and an accurate measurement of a large spherical distance is important, we’ll use the <code>geography</code> type. After creating the column, we can update it using <span epub:type="pagebreak" title="286" id="Page_286"/>Points derived from the coordinates and then apply an index to speed up queries. <a href="#listing15-9" id="listinganchor15-9">Listing 15-9</a> contains the statements for doing these tasks.</p>&#13;
<pre><code>ALTER TABLE farmers_markets ADD COLUMN geog_point geography(POINT,4326); <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
&#13;
UPDATE farmers_markets&#13;
SET geog_point =&#13;
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> ST_SetSRID(&#13;
             <span class="CodeAnnotationCode" aria-label="annotation3">3</span> ST_MakePoint(longitude,latitude)<span class="CodeAnnotationCode" aria-label="annotation4">4</span>::geography,4326&#13;
              );&#13;
&#13;
CREATE INDEX market_pts_idx ON farmers_markets USING GIST (geog_point); <span class="CodeAnnotationCode" aria-label="annotation5">5</span>&#13;
&#13;
SELECT longitude,&#13;
       latitude,&#13;
       geog_point,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation6">6</span> ST_AsEWKT(geog_point)&#13;
FROM farmers_markets&#13;
WHERE longitude IS NOT NULL&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-9">Listing 15-9</a>: Creating and indexing a <code>geography</code> column</p>&#13;
<p>The <code>ALTER TABLE</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span> you learned in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span> with the <code>ADD COLUMN</code> option creates a column of the <code>geography</code> type called <code>geog_point</code> that will hold points and reference the WGS 84 coordinate system, which we denote using SRID <code>4326</code>.</p>&#13;
<p>Next, we run a standard <code>UPDATE</code> statement to fill the <code>geog_point</code> column. Nested inside an <code>ST_SetSRID()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function, the <code>ST_MakePoint()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function takes as input the <code>longitude</code> and <code>latitude</code> columns from the table. The output, which is the <code>geometry</code> type by default, must be cast to <code>geography</code> to match the <code>geog_point</code> column type. To do this, we add the PostgreSQL-specific double-colon syntax (<code>::</code>) <span class="CodeAnnotation" aria-label="annotation4">4</span> to the output of <code>ST_MakePoint()</code>.</p>&#13;
<h3 id="h2-501065c15-0010">Adding a Spatial Index</h3>&#13;
<p class="BodyFirst">Before you start analysis, it’s wise to add an index to the new column to speed up queries. In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you learned about PostgreSQL’s default index, the B-tree. A B-tree index is useful for data that you can order and search using equality and range operators, but it’s less useful for spatial objects. The reason is that you cannot easily sort GIS data along one axis. For example, the application has no way to determine which of these coordinate pairs is greatest: (0,0), (0,1), or (1,0).</p>&#13;
<p>Instead, the makers of PostGIS include support for an index designed for spatial data called <em>R-tree</em>. In an R-tree index, each spatial item is represented in the index as a rectangle that surrounds its boundaries, and the index itself is a hierarchy of rectangles. (Find a good overview at <a href="https://postgis.net/workshops/postgis-intro/indexing.html" class="LinkURL">https://postgis.net/workshops/postgis-intro/indexing.html</a>.)</p>&#13;
<p>We add a spatial index to the <code>geog_point</code> column by including the keywords <code>USING GIST</code> in the <code>CREATE INDEX</code> statement <span class="CodeAnnotation" aria-label="annotation5">5</span> in <a href="#listing15-9">Listing 15-9</a>. <code>GIST</code> refers to a generalized search tree (GiST), an interface to facilitate incorporating specialized indexes to the database. PostgreSQL core team member Bruce <span epub:type="pagebreak" title="287" id="Page_287"/>Momjian describes GiST as “a general indexing framework designed to allow indexing of complex data types.”</p>&#13;
<p>With the index in place, we use the <code>SELECT</code> statement to view the geography data to show the newly encoded <code>geog_points</code> column. To view the extended WKT version of <code>geog_point</code>, we wrap it in a <code>ST_AsEWKT()</code> function <span class="CodeAnnotation" aria-label="annotation6">6</span> to show the extended well-known text coordinates and SRID. The results should look similar to this, with <code>geog_point</code> truncated for brevity:</p>&#13;
<pre><code> longitude    latitude   geog_point           st_asewkt&#13;
------------ ---------- ------------ -----------------------------------&#13;
-105.5890000 47.4154000 01010000...  SRID=4326;POINT(-105.589 47.4154)&#13;
 -98.9530000 40.4998000 01010000...  SRID=4326;POINT(-98.953 40.4998)&#13;
-119.4280000 35.7610000 01010000...  SRID=4326;POINT(-119.428 35.761)&#13;
 -92.3063000 42.1718000 01010000...  SRID=4326;POINT(-92.3063 42.1718)&#13;
 -70.6868160 44.1129600 01010000...  SRID=4326;POINT(-70.686816 44.11296))</code></pre>&#13;
 &#13;
<p>Now we’re ready to perform calculations on the points.</p>&#13;
<h3 id="h2-501065c15-0011">Finding Geographies Within a Given Distance</h3>&#13;
<p class="BodyFirst">Several years ago, while reporting a story on farming in Iowa, I visited the massive Downtown Farmers’ Market in Des Moines. With hundreds of vendors, the market spanned several city blocks in the Iowa capital. Farming is big business there, and even though the downtown market is huge, it’s not the only one in the area. Let’s use PostGIS to find more farmers’ markets near downtown Des Moines.</p>&#13;
<p>The PostGIS function <code>ST_DWithin()</code> returns a Boolean value of <code>true</code> if one spatial object is within a specified distance of another object. If you’re working with the <code>geography</code> data type, as we are here, you need to use meters as the distance unit. If you’re using the <code>geometry</code> type, use the distance unit specified by the SRID.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	PostGIS distance measurements are on a straight line for geometry data, and on a sphere for geography data. Be careful not to confuse either with driving distance along roads, which is usually farther from point to point. To perform calculations related to driving distances, check out the extension pgRouting at <a href="https://pgrouting.org/" class="LinkURL">https://pgrouting.org/</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p><a href="#listing15-10" id="listinganchor15-10">Listing 15-10</a> uses the <code>ST_DWithin()</code> function to filter <code>farmers_markets</code> to show markets within 10 kilometers of the Downtown Farmers’ Market in Des Moines.</p>&#13;
<pre><code>SELECT market_name,&#13;
       city,&#13;
       st,&#13;
       geog_point&#13;
FROM farmers_markets&#13;
WHERE ST_DWithin(<span class="CodeAnnotationCode" aria-label="annotation1">1</span> geog_point,&#13;
                 <span class="CodeAnnotationCode" aria-label="annotation2">2</span> ST_GeogFromText('POINT(-93.6204386 41.5853202)'),&#13;
                 <span class="CodeAnnotationCode" aria-label="annotation3">3</span> 10000)&#13;
ORDER BY market_name;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-10">Listing 15-10</a>: Using <code>ST_DWithin()</code> to locate farmers’ markets within 10 km of a point</p>&#13;
<p><span epub:type="pagebreak" title="288" id="Page_288"/>The first input for <code>ST_DWithin()</code> is <code>geog_point</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which holds the location of each row’s market in the <code>geography</code> data type. The second input is the <code>ST_GeogFromText()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span> that returns a Point geography from WKT. The coordinates <code>-93.6204386</code> and <code>41.5853202</code> represent the longitude and latitude of the Downtown Farmers’ Market. The final input is <code>10000</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which is the number of meters in 10 kilometers. The database calculates the distance between each market in the table and the downtown market. If a market is within 10 kilometers, it is included in the results.</p>&#13;
<p>We’re using Points here, but this function works with any geography or geometry type. If you’re working with objects such as polygons, you can use the related <code>ST_DFullyWithin()</code> function to find objects that are completely within a specified distance.</p>&#13;
<p>Run the query; it should return nine rows (I’ve omitted the <code>geog_point</code> column for brevity):</p>&#13;
<pre><code>market_name                                city               st&#13;
---------------------------------------    ---------------    ----&#13;
Beaverdale Farmers Market                  Des Moines         Iowa&#13;
Capitol Hill Farmers Market                Des Moines         Iowa&#13;
Downtown Farmers' Market - Des Moines      Des Moines         Iowa&#13;
Drake Neighborhood Farmers Market          Des Moines         Iowa&#13;
Eastside Farmers Market                    Des Moines         Iowa&#13;
Highland Park Farmers Market               Des Moines         Iowa&#13;
Historic Valley Junction Farmers Market    West Des Moines    Iowa&#13;
LSI Global Greens Farmers' Market          Des Moines         Iowa&#13;
Valley Junction Farmers Market             West Des Moines    Iowa</code></pre>&#13;
<p>One of these nine markets is the Downtown Farmers’ Market in Des Moines, which makes sense because its location is at the point used for comparison. The rest are other markets in Des Moines or in nearby West Des Moines.</p>&#13;
<p>To see these points on a map, in pgAdmin’s results grid, click the eye icon in the <code>geog_point</code> column header. The geography viewer should display a map as shown in <a href="#figure15-3" id="figureanchor15-3">Figure 15-3</a>.</p>&#13;
<figure>&#13;
<img src="Images/f15003.png" alt="f15003" class="keyline" width="694" height="374"/>&#13;
<figcaption><p><a id="figure15-3">Figure 15-3</a>: Farmers’ markets near downtown Des Moines, Iowa</p></figcaption>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" title="289" id="Page_289"/>This operation should be familiar: it’s a standard feature on many online maps and product apps that let you locate stores or points of interest near you.</p>&#13;
<p>Although this list of nearby markets is helpful, it would be even better to know the exact distance of markets from downtown. We’ll use another function to report that.</p>&#13;
<h3 id="h2-501065c15-0012">Finding the Distance Between Geographies</h3>&#13;
<p class="BodyFirst">The <code>ST_Distance()</code> function returns the minimum distance between two geometries, providing meters for geographies and SRID units for geometries. For example, <a href="#listing15-11" id="listinganchor15-11">Listing 15-11</a> finds the distance in miles from Yankee Stadium in New York City’s Bronx borough to Citi Field in Queens, home of the New York Mets.</p>&#13;
<pre><code>SELECT ST_Distance(&#13;
                   ST_GeogFromText('POINT(-73.9283685 40.8296466)'),&#13;
                   ST_GeogFromText('POINT(-73.8480153 40.7570917)')&#13;
                   ) / 1609.344 AS mets_to_yanks;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-11">Listing 15-11</a>: Using <code>ST_Distance()</code> to calculate the miles between Yankee Stadium and Citi Field</p>&#13;
<p>To convert the distance units from meters to miles, we divide the result of <code>ST_Distance()</code> by 1609.344 (the number of meters in a mile) The result is about 6.5 miles.</p>&#13;
<pre><code>mets_to_yanks&#13;
-----------------&#13;
6.543861827875209</code></pre>&#13;
<p>Let’s apply this technique to the farmers’ market data using the code in <a href="#listing15-12" id="listinganchor15-12">Listing 15-12</a>. We’ll again find all farmers’ markets within 10 kilometers of the Downtown Farmers’ Market in Des Moines and show the distance in miles.</p>&#13;
<pre><code>SELECT market_name,&#13;
       city,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> round(&#13;
            (ST_Distance(geog_point,&#13;
                         ST_GeogFromText('POINT(-93.6204386 41.5853202)')&#13;
                         ) / 1609.344)<span class="CodeAnnotationCode" aria-label="annotation2">2</span>::numeric, 2&#13;
            ) AS miles_from_dt&#13;
FROM farmers_markets&#13;
WHERE<span class="CodeAnnotation" aria-label="annotation3">3</span> ST_DWithin(geog_point,&#13;
                 ST_GeogFromText('POINT(-93.6204386 41.5853202)'),&#13;
                 10000)&#13;
ORDER BY miles_from_dt ASC;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-12">Listing 15-12</a>: Using <code>ST_Distance()</code> for each row in <code>farmers_markets</code></p>&#13;
<p>The query is similar to <a href="#listing15-10">Listing 15-10</a>, which used <code>ST_DWithin()</code> to find markets 10 kilometers or closer to downtown, but adds the <code>ST_Distance()</code> function as a column to calculate and display the distance from downtown. I’ve wrapped the function inside <code>round()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to trim the output.</p>&#13;
<p><span epub:type="pagebreak" title="290" id="Page_290"/>We provide <code>ST_Distance()</code> with the same two inputs we gave <code>ST_DWithin()</code> in <a href="#listing15-10">Listing 15-10</a>: <code>geog_point</code> and the <code>ST_GeogFromText()</code> function. The <code>ST_Distance()</code> function then calculates the distance between the points specified by both inputs, returning the result in meters. To convert to miles, we divide by <code>1609.344</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, the approximate number of meters in a mile. Then, to provide the <code>round()</code> function with the correct input data type, we cast the column result to type <code>numeric</code>.</p>&#13;
<p>The <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation3">3</span> uses the same <code>ST_DWithin()</code> function and inputs as in <a href="#listing15-10">Listing 15-10</a>. You should see the following results, ordered by distance in ascending order:</p>&#13;
<pre><code>market_name                             city               miles_from_dt&#13;
-------------------------------------   ---------------    -------------&#13;
Downtown Farmers' Market - Des Moines   Des Moines                  0.00&#13;
Capitol Hill Farmers Market             Des Moines                  1.15&#13;
Drake Neighborhood Farmers Market       Des Moines                  1.70&#13;
LSI Global Greens Farmers' Market       Des Moines                  2.30&#13;
Highland Park Farmers Market            Des Moines                  2.93&#13;
Eastside Farmers Market                 Des Moines                  3.40&#13;
Beaverdale Farmers Market               Des Moines                  3.74&#13;
Historic Valley Junction Farmers Market West Des Moines             4.68&#13;
Valley Junction Farmers Market          West Des Moines             4.70</code></pre>&#13;
<p>Again, you see this type of result often when you’re searching online for a store or address. You might also find the technique helpful for other analysis scenarios, such as finding all the schools within a certain distance of a known source of pollution or all the homes within five miles of an airport.</p>&#13;
<h3 id="h2-501065c15-0013">Finding the Nearest Geographies</h3>&#13;
<p class="BodyFirst">Sometimes it’s helpful to have the database simply return the spatial objects that are in closest proximity to another object without specifying some arbitrary distance in which to search. For example, we may want to find the closest farmers’ market regardless of whether it’s 10 kilometers away or 100. To do that, we can instruct PostGIS to implement a <em>K-nearest neighbors</em> search algorithm by using the <code>&lt;-&gt;</code> distance operator in the <code>ORDER BY</code> clause of a query. Nearest neighbors algorithms solve a range of classification problems by identifying similar items—text recognition is an example. In this case, PostGIS will identify some number of spatial objects, represented by <code>K</code>, nearest to an object we specify.</p>&#13;
<p>For example, let’s say we’re planning to visit the vacation spot of Bar Harbor, Maine, and want to find the three farmer’s markets closest to town. We can use the code in <a href="#listing15-13" id="listinganchor15-13">Listing 15-13</a>.</p>&#13;
<pre><code>SELECT market_name,&#13;
       city,&#13;
       st,&#13;
       round(&#13;
           (ST_Distance(geog_point,&#13;
                        ST_GeogFromText('POINT(-68.2041607 44.3876414)')&#13;
<span epub:type="pagebreak" title="291" id="Page_291"/>                        ) / 1609.344)::numeric, 2&#13;
            ) AS miles_from_bh&#13;
FROM farmers_markets&#13;
ORDER BY geog_point &lt;-&gt;<span class="CodeAnnotation" aria-label="annotation1">1</span> ST_GeogFromText('POINT(-68.2041607 44.3876414)')&#13;
LIMIT 3;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-13">Listing 15-13</a>: Using the <code>&lt;-&gt;</code> distance operator for a nearest neighbors search</p>&#13;
<p>The query is similar to <a href="#listing15-12">Listing 15-12</a>, but instead of using a <code>WHERE</code> clause with <code>ST_DWithin()</code>, we provide an <code>ORDER BY</code> clause that contains the <code>&lt;-&gt;</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> distance operator. To the left of the operator, we place the <code>geog_point</code> column; to the right we supply the WKT for the Point locating downtown Bar Harbor inside <code>ST_GeogFromText()</code>. In effect, this syntax says, “Order the results by the distance from the geography to the Point.”</p>&#13;
<p>Adding <code>LIMIT 3</code> restricts the results to the three closest markets (the three nearest neighbors):</p>&#13;
<pre><code>          market_name                   city         st   miles_from_bh&#13;
--------------------------------  ----------------  ----- -------------&#13;
Bar Harbor Eden Farmers' Market   Bar Harbor        Maine          0.32&#13;
Northeast Harbor Farmers' Market  Northeast Harbor  Maine          7.65&#13;
Southwest Harbor Farmers' Market  Southwest Harbor  Maine          9.56</code></pre>&#13;
<p>You can, of course, change the number in the <code>LIMIT</code> clause to return more or fewer results. Using <code>LIMIT 1</code>, for example, will return only the closest market.</p>&#13;
<p>So far, you’ve learned how to work with spatial objects constructed from WKT. Next, I’ll show you a common data format used in GIS called the <em>shapefile</em> and how to bring it into PostGIS for analysis.</p>&#13;
<h2 id="h1-501065c15-0007">Working with Census Shapefiles</h2>&#13;
<p class="BodyFirst">A <em>shapefile</em> is a GIS data file format developed by Esri, a US company known for its ArcGIS mapping visualization and analysis platform. Shapefiles are a standard file format for GIS platforms—such as ArcGIS and the open source QGIS—and are used by governments, corporations, nonprofits, and technical organizations to display, analyze, and distribute data with geographic features.</p>&#13;
<p>Shapefiles hold information describing the shape of a feature (such as a county, a road, or a lake) plus a database with each feature’s attributes. Those attributes might include their name and other demographic descriptors. A single shapefile can contain only one type of shape, such as polygons or points, and when you load a shapefile into a GIS platform that supports visualization, you can view the shapes and query their attributes. PostgreSQL, with the PostGIS extension, lets you query the spatial data in the shapefile, which we’ll do in “Exploring the Census 2019 Counties Shapefile” and “Performing Spatial Joins” later in the chapter.</p>&#13;
<p>First, let’s examine the structure and contents of shapefiles.</p>&#13;
<h3 id="h2-501065c15-0014"><span epub:type="pagebreak" title="292" id="Page_292"/>Understanding the Contents of a Shapefile</h3>&#13;
<p class="BodyFirst">A shapefile comprises a collection of files with different extensions, each with a different purpose. Often, when you download a shapefile, it comes in a compressed archive, such as <em>.zip</em>. You’ll need to unzip it to access the individual files.</p>&#13;
<p>Per ArcGIS documentation, these are the most common extensions you’ll encounter:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>.shp</code></span></span>  Main file that stores the feature geometry.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>.shx</code></span></span>  Index file that stores the index of the feature geometry.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>.dbf</code></span></span>  Database table (in dBASE format) that stores the attribute information of features.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>.xml</code></span></span>  XML-format file that stores metadata about the shapefile.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>.prj</code></span></span>  Projection file that stores the coordinate system information. You can open this file with a text editor to view the geographic coordinate system and projection.</li>&#13;
</ol>&#13;
<p>According to the documentation, files with the first three extensions include necessary data required for working with a shapefile. The other file types are optional. You can load a shapefile into PostGIS to access its spatial objects and the attributes for each. Let’s do that next and explore some additional analysis functions.</p>&#13;
<p>I’ve included several shapefiles with the resources for this chapter at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>. We’ll start with TIGER/Line Shapefiles from the US Census that contain the boundaries for each county or county equivalent, such as parish or borough, as of 2019. You can learn more about this series of shapefiles at <a href="https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.html" class="LinkURL">https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-line-file.html</a>.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Many organizations provide data in shapefile format. Start with your national or local government agencies or check the Wikipedia entry “List of GIS data sources.”</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Save <em>tl_2019_us_county.zip</em> from the book’s resources for this chapter to your computer and unzip it; the archive should contain files including those with the extensions I listed earlier. </p>&#13;
<h3 id="h2-501065c15-0015">Loading Shapefiles</h3>&#13;
<p class="BodyFirst">If you’re using Windows, the PostGIS suite includes a Shapefile Import/Export Manager with a simple <em>graphical user interface (GUI)</em>. In recent years, builds of that GUI have become harder to find on macOS and Linux distributions, so for those operating systems we’ll instead use the command line application <code>shp2pgsql</code>.</p>&#13;
<p>We’ll start with the Windows GUI. If you’re on macOS or Linux, skip ahead to “Importing Shapefiles Using shp2pgsql.”</p>&#13;
<h4 id="h3-501065c15-0001"><span epub:type="pagebreak" title="293" id="Page_293"/>Windows Shapefile Importer/Exporter</h4>&#13;
<p class="BodyFirst">On Windows, if you followed the installation steps in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, you should find the Shapefile Import/Export Manager by selecting <b>Start</b><span class="MenuArrow">▶</span><b>PostGIS Bundle </b><var>x.y</var><b> for PostgreSQL x64 </b><var>x.y</var><span class="MenuArrow">▶</span><b> PostGIS Bundle </b><var>x.y </var><b>for PostgreSQL x64 </b><var>x.y</var><b> Shapefile and DBF Loader Exporter</b>.</p>&#13;
<p>Whatever you see in place of <var>x.y</var> should match your PostgreSQL and PostGIS versions. Click to launch the application.</p>&#13;
<p>To establish a connection between the app and your <code>analysis</code> database, follow these steps:</p>&#13;
<ol class="decimal">&#13;
<li value="1">Click <b>View connection details</b>.</li>&#13;
<li value="2">In the dialog that opens, enter <b>postgres</b> for the username, and enter a password if you added one for the server during initial setup.</li>&#13;
<li value="3">Ensure that Server Host has <code>localhost</code> and <code>5432</code> by default. Leave those as is unless you’re connecting to a different server or port.</li>&#13;
<li value="4">Enter <b>analysis</b><code/> for the database name. <a href="#figure15-4" id="figureanchor15-4">Figure 15-4</a> shows a screenshot of what the connection should look like.&#13;
<figure>&#13;
<img src="Images/f15004.png" alt="f15004" class="keyline" width="441" height="376"/>&#13;
<figcaption><p><a id="figure15-4">Figure 15-4</a>: Establishing the PostGIS connection in the shapefile loader</p></figcaption>&#13;
</figure>&#13;
</li>&#13;
<li value="5">Click <b>OK</b>. You should see the message <code>Connection Succeeded</code> in the log window. Now that you’ve successfully established the PostGIS connection, you can load your shapefile.</li>&#13;
<li value="6">Under Options, change <code>DBF file character encoding</code> to <b>Latin1</b>—we do this because the shapefile attributes include county names with characters that require this encoding. Keep the default checked boxes, including the one to create an index on the spatial column. Click <b>OK</b>.</li>&#13;
<li value="7">Click <b>Add File</b> and select <em>tl_2019_us_county.shp</em> from the location you saved it. Click <b>Open</b>. The file should appear in the Shapefile list in the loader, as shown in <a href="#figure15-5" id="figureanchor15-5">Figure 15-5</a>.&#13;
<span epub:type="pagebreak" title="294" id="Page_294"/><figure>&#13;
<img src="Images/f15005.png" alt="f15005" class="keyline" width="694" height="345"/>&#13;
<figcaption><p><a id="figure15-5">Figure 15-5</a>: Specifying upload details in the shapefile loader</p></figcaption>&#13;
</figure>&#13;
</li>&#13;
<li value="8">In the Table column, double-click to select the table name. Replace it with <b>us_counties_2019_shp</b>. Press <span class="KeyCaps">ENTER</span> to accept the value.</li>&#13;
<li value="9">In the SRID column, double-click and enter <b>4269</b>. That’s the ID for the North American Datum 1983 coordinate system, which is often used by US federal agencies including the US Census Bureau. Again, press <span class="KeyCaps">ENTER</span> to accept the value.</li>&#13;
<li value="10">Click <b>Import</b>.</li>&#13;
</ol>&#13;
<p>In the log window, you should see a message that ends with the following message:</p>&#13;
<pre><code>Shapefile type: Polygon&#13;
PostGIS type: MULTIPOLYGON[2]&#13;
Shapefile import completed.</code></pre>&#13;
<p>Switch to pgAdmin, and in the object browser, expand the <code>analysis</code> node and continue expanding by selecting <b>Schemas</b><span class="MenuArrow">▶</span><b>public</b><span class="MenuArrow">▶</span><b>Tables</b>. Refresh your tables by right-clicking <b>Tables</b> and selecting <b>Refresh</b> from the pop-up menu. You should see <code>us_counties_2019_shp</code> listed. Congrats! You’ve loaded your shapefile into a table. As part of the import, the shapefile loader also indexed the <code>geom</code> column. You can move ahead to the section “Exploring the Census 2019 Counties Shapefile.”</p>&#13;
<h4 id="h3-501065c15-0002">Importing Shapefiles using shp2pgsql</h4>&#13;
<p class="BodyFirst">The Shapefile Import/Export Manager isn’t available on all PostGIS distributions for macOS and Linux. For that reason, I’ll show you how to import shapefiles using the PostGIS command line tool <code>shp2pgsql</code>, which lets you accomplish the same thing using a single text command.</p>&#13;
<p><span epub:type="pagebreak" title="295" id="Page_295"/>On macOS and Linux, you execute command line tools in the Terminal application. If you’re not familiar with working on the command line, you may want to pause here and read <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>, “Using PostgreSQL from the Command Line,” to get set up. Otherwise, on macOS launch Terminal from your Applications folder (under Utilities); on Linux, open your distribution’s terminal.</p>&#13;
<p>At the command line, you use the following syntax to import a shapefile into a new table; the italicized code here are placeholders:</p>&#13;
<pre><code>shp2pgsql -I -s <var>SRID</var> -W <var>encoding shapefile_name</var> <var>table_name</var> | psql -d <var>database</var> -U <var>user</var></code></pre>&#13;
<p>A lot’s happening here. Let’s look at each argument following the command:</p>&#13;
<ol class="none">&#13;
<li><code>-I</code> adds an index on the new table’s geometry column using GiST.</li>&#13;
<li><code>-s</code> lets you specify an SRID for the geometric data.</li>&#13;
<li><code>-W</code> lets you specify file encoding, if necessary.</li>&#13;
<li><code>shapefile_name</code> is the name (including full path) of the file ending with the <em>.shp</em> extension.</li>&#13;
<li><code>table_name</code> indicates the new table you want the shapefile imported to.</li>&#13;
</ol>&#13;
<p>Following these arguments, you place a pipe symbol (<code>|</code>) to direct the output of <code>shp2pgsql</code> to <code>psql</code>, the PostgreSQL command line utility. That’s followed by arguments for naming the database and user. For example, to load the <em>tl_2019_us_county.shp</em> shapefile from the book’s resources into a <code>us_counties_2019_shp</code> table in the <code>analysis</code> database, in your terminal you would move to the directory containing the shapefile and run the following command (all on one line):</p>&#13;
<pre><code>shp2pgsql -I -s 4269 -W LATIN1 tl_2019_us_county.shp us_counties_2019_shp | psql -d analysis -U postgres</code></pre>&#13;
<p>The server should respond with a number of SQL <code>INSERT</code> statements before creating the index and returning you to the command line. It might take some time to construct the entire set of arguments the first time around. But after you’ve done one, subsequent imports should take less time because you can simply substitute file and table names into the syntax you already wrote.</p>&#13;
<p>Load your shapefile, and then you’ll be ready to explore the data with queries.</p>&#13;
<h3 id="h2-501065c15-0016">Exploring the Census 2019 Counties Shapefile</h3>&#13;
<p class="BodyFirst">Your new <code>us_counties_2019_shp</code> table contains columns including each county’s name as well as the <em>Federal Information Processing Standards (FIPS)</em> codes uniquely assigned to each state and county. The <code>geom</code> column contains the spatial data for each county’s boundary. To start, let’s check what kind of spatial object <code>geom</code> contains using the <code>ST_AsText()</code> function. Use the code <span epub:type="pagebreak" title="296" id="Page_296"/>in <a href="#listing15-14" id="listinganchor15-14">Listing 15-14</a> to show the WKT representation of the first <code>geom</code> value in the table.</p>&#13;
<pre><code>SELECT ST_AsText(geom)&#13;
FROM us_counties_2019_shp&#13;
ORDER BY gid&#13;
LIMIT 1;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-14">Listing 15-14</a>: Checking the <code>geom</code> column’s WKT representation</p>&#13;
<p>The result is a MultiPolygon with hundreds of coordinate pairs. Here’s a portion of the output:</p>&#13;
<pre><code>MULTIPOLYGON(((-97.019516 42.004097,-97.019519 42.004933,-97.019527 42.007501,-97.019529 42.009755,-97.019529 42.009776,-97.019529 42.009939,-97.019529 42.010163,-97.019538 42.013931,-97.01955 42.014546,-97.01955 42.014565,-97.019551 42.014608,-97.019551 42.014632,-97.01958 42.016158,-97.019622 42.018384,-97.019629 42.018545,-97.01963 42.019475,-97.01963 42.019553,-97.019644 42.020927, <var>--snip--</var> )))</code></pre>&#13;
<p>Each coordinate pair marks a Point on the boundary of the county, and remember that a <code>MULTIPOLYGON</code> object can contain a set of polygons. In the case of US counties, that will enable storage of counties whose boundaries contain more than one distinct, separated area. Now, you’re ready to analyze the data.</p>&#13;
<h4 id="h3-501065c15-0003">Finding the Largest Counties in Square Miles</h4>&#13;
<p class="BodyFirst">Which county can claim the title of largest in area? To find the answer, <a href="#listing15-15" id="listinganchor15-15">Listing 15-15</a> uses the <code>ST_Area()</code> function, which returns the area of a Polygon or MultiPolygon object. If you’re working with a <code>geography</code> data type, <code>ST_Area()</code> returns the result in square meters. With a <code>geometry</code> data type—as used with this shapefile—the function returns the area in SRID units. Typically, those units are not useful for practical analysis, so we’ll cast the <code>geometry</code> type to <code>geography</code> to obtain square meters. It’s an intensive calculation, so expect extra time for this query to complete.</p>&#13;
<pre><code>SELECT name,&#13;
       statefp AS st,&#13;
       round(&#13;
             ( ST_Area(<span class="CodeAnnotation" aria-label="annotation1">1</span>geom::geography) / <span class="CodeAnnotation" aria-label="annotation2">2</span>2589988.110336 )::numeric, 2&#13;
            )  AS <span class="CodeAnnotation" aria-label="annotation3">3</span>square_miles&#13;
FROM us_counties_2019_shp&#13;
ORDER BY square_miles <span class="CodeAnnotation" aria-label="annotation4">4</span>DESC&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-15">Listing 15-15</a>: Finding the largest counties by area using <code>ST_Area()</code></p>&#13;
<p>The <code>geom</code> column is data type <code>geometry</code>, so to find the area in square meters, we cast the <code>geom</code> column to a <code>geography</code> data type using the double-colon syntax <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then, to get square miles, we divide the area by 2589988.110336, which is the number of square meters in a square mile <span class="CodeAnnotation" aria-label="annotation2">2</span>. To make the result easier to read, I’ve wrapped it in a <code>round()</code> <span epub:type="pagebreak" title="297" id="Page_297"/>function and named the resulting column <code>square_miles</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. Finally, we list the results in descending order from the largest area to the smallest <span class="CodeAnnotation" aria-label="annotation4">4</span> and use <code>LIMIT 5</code> to show the first five results, which should look like this:</p>&#13;
<pre><code>name                st    square_miles&#13;
----------------    --    ------------&#13;
Yukon-Koyukuk       02       147871.00&#13;
North Slope         02        94827.92&#13;
Bethel              02        45559.08&#13;
Northwest Arctic    02        40619.78&#13;
Valdez-Cordova      02        40305.54</code></pre>&#13;
<p>Congratulations to Alaska, where the boroughs (the name for county equivalents up there) are big. The five largest are all in Alaska, denoted by the state FIPS code <code>02</code>. Yukon-Koyukuk, located in the heart of Alaska, is more than 147,800 square miles. (Keep that information in mind for the “Try It Yourself” exercise at the end of the chapter.)</p>&#13;
<p>Note that the shapefile doesn’t include a state name, just its FIPS code. Because the spatial data resides in a table, in the next section we’ll join to another census table to obtain the state name.</p>&#13;
<h4 id="h3-501065c15-0004">Finding a County by Longitude and Latitude</h4>&#13;
<p class="BodyFirst">If you’ve ever wondered how spammy online ads seem to know where you live (“This one trick helped a Boston man fix his old shoes!”), it’s thanks to <em>geolocation services</em> that use various means, such as your phone’s GPS, to find your longitude and latitude. Given your coordinates, a spatial query can then determine which geography (a city or town, for example) that point falls into.</p>&#13;
<p>You can replicate this technique using your census shapefile and the <code>ST_Within()</code> function, which returns <code>true</code> if one geometry is inside another on the coordinate grid. <a href="#listing15-16" id="listinganchor15-16">Listing 15-16</a> shows an example using the longitude and latitude of downtown Hollywood, California.</p>&#13;
<pre><code>SELECT sh.name,&#13;
       c.state_name&#13;
FROM us_counties_2019_shp sh JOIN us_counties_pop_est_2019 c&#13;
    ON sh.statefp = c.state_fips AND sh.countyfp = c.county_fips&#13;
WHERE <span class="CodeAnnotation" aria-label="annotation1">1</span>ST_Within(&#13;
         'SRID=4269;POINT(-118.3419063 34.0977076)'::geometry, geom&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-16">Listing 15-16</a>: Using <code>ST_Within()</code> to find the county belonging to a pair of coordinates</p>&#13;
<p>The <code>ST_Within()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> inside the <code>WHERE</code> clause requires two <code>geometry</code> inputs and evaluates whether the first is inside the second. For the function to work properly, both <code>geometry</code> inputs must have the same SRID. In this example, the first input is an extended WKT representation of a Point that includes the SRID <code>4269</code> (same as the census data), which is cast as a <code>geometry</code> type. The <code>ST_Within()</code> function doesn’t accept a separate SRID input, so <span epub:type="pagebreak" title="298" id="Page_298"/>to set it for the supplied WKT, you must prefix it to the string like this: <code>'SRID=4269;POINT(-118.3419063 34.0977076)'</code>. The second input is the <code>geom</code> column from the table.</p>&#13;
<p>Run the query; you should see the following result:</p>&#13;
<pre><code>name           state_name&#13;
-----------    -----------&#13;
Los Angeles    California</code></pre>&#13;
<p>It shows that the Point you supplied is within Los Angeles county in California. We also see how this technique can gain value (or raise privacy concerns) by relating a Point to data about its surrounding area—as we did here by joining to county population estimates. Suddenly, we can tell a lot about someone based on data describing where they spend time.</p>&#13;
<p>Try supplying other longitude and latitude pairs to see which US county they fall in. If you provide coordinates outside the United States, the query should return no results because the shapefile contains only US areas.</p>&#13;
<h3 id="h2-501065c15-0017">Examining Demographics Within a Distance</h3>&#13;
<p class="BodyFirst">A fundamental metric for planners trying to locate a new school, business, or other community amenity is the number of people who live within a certain distance of it. Will there be enough people nearby to make construction worthwhile? To find the answer, we can use spatial and demographics data to estimate the population contained in the geographies within a certain distance of the planned location.</p>&#13;
<p>Say we’re considering building a restaurant in downtown Lincoln, Nebraska, and we want to understand how many people live within 50 miles of the potential location. The code in <a href="#listing15-17" id="listinganchor15-17">Listing 15-17</a> uses the <code>ST_DWithin()</code> function to find counties that have any portion of their boundary within 50 miles of downtown Lincoln and sum their estimated 2019 population.</p>&#13;
<pre><code>SELECT sum(c.pop_est_2019) AS pop_est_2019&#13;
FROM us_counties_2019_shp sh JOIN us_counties_pop_est_2019 c&#13;
    ON sh.statefp = c.state_fips AND sh.countyfp = c.county_fips&#13;
WHERE ST_DWithin(sh.geom::geography,&#13;
          ST_GeogFromText('SRID=4269;POINT(-96.699656 40.811567)'),&#13;
          80467);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-17">Listing 15-17</a>: Using <code>ST_DWithin()</code> to count people near Lincoln, Nebraska</p>&#13;
<p>In <a href="#listing15-10">Listing 15-10</a>, we used <code>ST_DWithin()</code> to find farmers’ markets close to Des Moines, Iowa. Here, we apply the same technique. We pass three arguments to <code>ST_DWithin()</code>: the census shapefile’s <code>geom</code> column cast to the <code>geography</code> type; a point representing downtown Lincoln; and the distance of 50 miles using its equivalent in meters, 80,467.</p>&#13;
<p>The query should return a sum of 1,470,295, using the data from the joined census estimates table’s <code>pop_est_2019</code> column.</p>&#13;
<p><span epub:type="pagebreak" title="299" id="Page_299"/>Say we want to list the county names and visualize their borders in pgAdmin; we can modify our query, as in <a href="#listing15-18" id="listinganchor15-18">Listing 15-18</a>.</p>&#13;
<pre><code>SELECT sh.name,&#13;
       c.state_name,&#13;
       c.pop_est_2019,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> ST_Transform(sh.geom, 4326) AS geom&#13;
FROM us_counties_2019_shp sh JOIN us_counties_pop_est_2019 c&#13;
    ON sh.statefp = c.state_fips AND sh.countyfp = c.county_fips&#13;
WHERE ST_DWithin(geom::geography,&#13;
          ST_GeogFromText('SRID=4269;POINT(-96.699656 40.811567)'),&#13;
          80467);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-18">Listing 15-18</a>: Displaying counties near Lincoln, Nebraska</p>&#13;
<p>This query should return 25 rows with the county name and its population. If you click the eye icon in the header of the <code>geom</code> column, you should see the counties displayed on a map in pgAdmin’s Geometry Viewer, as in <a href="#figure15-6" id="figureanchor15-6">Figure 15-6</a>.</p>&#13;
<figure>&#13;
<img src="Images/f15006.png" alt="f15006" class="keyline" width="694" height="334"/>&#13;
<figcaption><p><a id="figure15-6">Figure 15-6</a>: Counties that have a portion of their boundaries within 50 miles of Lincoln</p></figcaption>&#13;
</figure>&#13;
<p>These queries show counties that have any portion of their boundaries within 50 miles of Lincoln. Because counties tend to be large in area, they’re a bit crude for determining an exact number of people within the distance of the point. For a more precise count, we could use smaller census geographies such as tracts or block groups, both of which are subcomponents of counties.</p>&#13;
<p>Finally, note that the pgAdmin Geometry Viewer’s base map is the free OpenStreetMap, which uses the WGS 84 coordinate system. Our census shapefiles use a different coordinate system: North American Datum 83. For our data to display properly against the base map, we must use the <code>ST_Transform()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> to convert the census geometry to the SRID of 4326. If we omit that function, the geographies will display on a blank canvas in the viewer because the coordinate systems don’t match.</p>&#13;
<h2 id="h1-501065c15-0008"><span epub:type="pagebreak" title="300" id="Page_300"/>Performing Spatial Joins</h2>&#13;
<p class="BodyFirst">Joining tables with spatial data opens up interesting opportunities for analysis. For example, you could join a table of coffee shops (which includes their longitude and latitude) to the counties table to find out how many shops exist in each county based on their location. In this section, we’ll explore spatial joins with a detailed look at roads and waterways using census data.</p>&#13;
<h3 id="h2-501065c15-0018">Exploring Roads and Waterways Data</h3>&#13;
<p class="BodyFirst">Much of the year, the Santa Fe River, which cuts through the New Mexico state capital, is a dry riverbed better described as an <em>intermittent stream</em>. According to the Santa Fe city website, the river is susceptible to flash flooding and was named the nation’s most endangered river in 2007. If you were an urban planner, it would help to know where the river intersects roadways so you could plan for emergency response when it floods.</p>&#13;
<p>You can find these locations using another set of US Census TIGER/Line shapefiles that has details on roads and waterways in Santa Fe County. These shapefiles are also included with the book’s resources. Download and unzip <em>tl_2019_35049_linearwater.zip</em> and <em>tl_2019_35049_roads.zip</em>, and then import both using the same steps from earlier in the chapter. Name the water table <code>santafe_linearwater_2019</code> and the roads table <code>santafe_roads_2019</code>.</p>&#13;
<p>Next, refresh your database and run a quick <code>SELECT * FROM</code> query on both tables to view the data. You should have 11,655 rows in the roads table and 1,148 in the linear water table.</p>&#13;
<p>As with the counties shapefile, both tables have an indexed <code>geom</code> column of type <code>geometry</code>. It’s helpful to check the type of spatial object in the column so you know the type of spatial feature you’re querying. You can do that using the <code>ST_AsText()</code> function or <code>ST_GeometryType()</code>, as shown in <a href="#listing15-19" id="listinganchor15-19">Listing 15-19</a>.</p>&#13;
<pre><code>SELECT ST_GeometryType(geom)&#13;
FROM santafe_linearwater_2019&#13;
LIMIT 1;&#13;
&#13;
SELECT ST_GeometryType(geom)&#13;
FROM santafe_roads_2019&#13;
LIMIT 1;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-19">Listing 15-19</a>: Using <code>ST_GeometryType()</code> to determine geometry</p>&#13;
<p>Both queries should return one row with the same value: <code>ST_MultiLineString</code>. That tell us that waterways and roads are stored as MultiLineString objects, a set of LineStrings that can be noncontinuous.</p>&#13;
<h3 id="h2-501065c15-0019">Joining the Census Roads and Water Tables</h3>&#13;
<p class="BodyFirst">To find all the roads in Santa Fe that intersect the Santa Fe River, we’ll join the roads and waterway tables with a query that tells us where the objects <span epub:type="pagebreak" title="301" id="Page_301"/>touch. We’ll do this using the <code>ST_Intersects()</code> function, which returns a Boolean <code>true</code> if two spatial objects contact each other. Inputs can be either <code>geometry</code> or <code>geography</code> types. <a href="#listing15-20" id="listinganchor15-20">Listing 15-20</a> joins the tables.</p>&#13;
<pre><code>SELECT water.fullname AS waterway, <span class="CodeAnnotationCode" aria-label="annotation1">1</span>&#13;
       roads.rttyp,&#13;
       roads.fullname AS road&#13;
FROM santafe_linearwater_2019 water JOIN santafe_roads_2019 roads <span class="CodeAnnotationCode" aria-label="annotation2">2</span>&#13;
     <span class="CodeAnnotationCode" aria-label="annotation3">3</span> ON ST_Intersects(water.geom, roads.geom)&#13;
WHERE water.fullname = <span class="CodeAnnotationCode" aria-label="annotation4">4</span>'Santa Fe Riv'&#13;
      AND roads.fullname IS NOT NULL&#13;
ORDER BY roads.fullname;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-20">Listing 15-20</a>: Spatial join with <code>ST_Intersects()</code> to find roads crossing the Santa Fe River</p>&#13;
<p>The <code>SELECT</code> column list <span class="CodeAnnotation" aria-label="annotation1">1</span> includes the <code>fullname</code> column from the <code>santafe_linearwater_2019</code> table, which gets <code>water</code> as its alias in the <code>FROM</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> clause. The column list includes the <code>rttyp</code> code, which represents the route type, and <code>fullname</code> columns from the <code>santafe_roads_2019 </code>table, aliased as <code>roads</code>.</p>&#13;
<p>In the <code>ON</code> portion <span class="CodeAnnotation" aria-label="annotation3">3</span> of the <code>JOIN</code> construct, we use the <code>ST_Intersects()</code> function with the <code>geom</code> columns from both tables as inputs. Here, the expression evaluates as <code>true</code> if the geometries intersect. We use <code>fullname</code> to filter the results to show only those that have the full string <code>'Santa Fe Riv'</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, which is how the Santa Fe River is listed in the water table. We also eliminate instances where road names are <code>NULL</code>. The query should return 37 rows; here are the first five:</p>&#13;
<pre><code>waterway        rttyp    road&#13;
------------    -----    ----------------&#13;
Santa Fe Riv       M     Baca Ranch Ln&#13;
Santa Fe Riv       M     Baca Ranch Ln&#13;
Santa Fe Riv       M     Caja del Oro Grant Rd&#13;
Santa Fe Riv       M     Caja del Oro Grant Rd&#13;
Santa Fe Riv       M     Cam Carlos Rael&#13;
<var>--snip--</var></code></pre>&#13;
<p>Each road in the results intersects with a portion of the Santa Fe River. The route type code for each of the first results is <code>M</code>, which indicates that the road name shown is its <em>common</em> name as opposed to a county or state recognized name, for example. Other road names in the complete results carry route types of <code>C</code>, <code>S</code>, or <code>U</code> (for unknown). The full route type code list is available at <a href="https://www.census.gov/library/reference/code-lists/route-type-codes.html" class="LinkURL">https://www.census.gov/library/reference/code-lists/route-type-codes.html</a>.</p>&#13;
<h3 id="h2-501065c15-0020">Finding the Location Where Objects Intersect</h3>&#13;
<p class="BodyFirst">We successfully identified roads that intersect the Santa Fe River. That’s good, but it would really help to know the precise location of each intersection. We can modify the query to include the <code>ST_Intersection()</code> function, which returns the location of the place where objects touch. I’ve added it as a column in <a href="#listing15-21" id="listinganchor15-21">Listing 15-21</a>.</p>&#13;
<pre><code><span epub:type="pagebreak" title="302" id="Page_302"/>SELECT water.fullname AS waterway,&#13;
       roads.rttyp,&#13;
       roads.fullname AS road,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> ST_AsText(ST_Intersection(<span class="CodeAnnotation" aria-label="annotation2">2</span>water.geom, roads.geom))&#13;
FROM santafe_linearwater_2019 water JOIN santafe_roads_2019 roads&#13;
    ON ST_Intersects(water.geom, roads.geom)&#13;
WHERE water.fullname = 'Santa Fe Riv'&#13;
      AND roads.fullname IS NOT NULL&#13;
ORDER BY roads.fullname;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing15-21">Listing 15-21</a>: Using <code>ST_Intersection()</code> to show where roads cross the river</p>&#13;
<p>The function returns a geometry object, so to view its WKT representation, we must wrap it in <code>ST_AsText()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. The <code>ST_Intersection()</code> function takes two inputs: the <code>geom</code> columns <span class="CodeAnnotation" aria-label="annotation2">2</span> from both the <code>water</code> and <code>roads</code> tables. Run the query, and the results should now include the exact coordinate location, or locations, where the river crosses the roads (I’ve rounded the Point coordinates for brevity).</p>&#13;
<pre><code>waterway       rttyp   road                  st_astext&#13;
------------   -----   ----------------      ----------------------------&#13;
Santa Fe Riv     M     Baca Ranch Ln         POINT(-106.049802 35.642638)&#13;
Santa Fe Riv     M     Baca Ranch Ln         POINT(-106.049743 35.643126)&#13;
Santa Fe Riv     M     Caja del Oro Grant Rd POINT(-106.024674 35.657624)&#13;
Santa Fe Riv     M     Caja del Oro Grant Rd POINT(-106.024692 35.657644)&#13;
Santa Fe Riv     M     Cam Carlos Rael       POINT(-105.986934 35.672342)&#13;
<var>--snip--</var></code></pre>&#13;
<p>Much better than poring over a map with a pencil, and this might prompt more ideas for analyzing spatial data. For example, if you have a shapefile of building footprints, you could find buildings near the river and in danger of flooding during heavy rains. Governments and private organizations regularly use these techniques as part of their planning process.</p>&#13;
<h2 id="h1-501065c15-0009">Wrapping Up</h2>&#13;
<p class="BodyFirst">Mapping is a powerful analysis tool, and the techniques you learned in this chapter give you a strong start toward exploring more with PostGIS. You may indeed want to visualize this data, and that’s entirely possible with a GIS application such as Esri’s ArcGIS (<a href="https://www.esri.com/" class="LinkURL">https://www.esri.com/</a>) or the free open source QGIS (<a href="https://qgis.org/" class="LinkURL">https://qgis.org/</a>). Both can use a PostGIS-enabled PostgreSQL database as a data source, allowing you to visualize shapefile data in your tables or the results of queries.</p>&#13;
<p>You’ve now added working with geographic data to your analysis skills. Next, we’ll explore another widely used data type called JavaScript Object Notation (JSON) and how PostgreSQL enables storing and querying it.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="303" id="Page_303"/>Try It Yourself</h2>&#13;
<p class="BoxBodyFirst">Use the spatial data you’ve imported in this chapter to try additional analysis:</p>&#13;
<ol>&#13;
<li value="1">Earlier, you found which US county has the largest area. Now, aggregate the county data to find the area of each state in square miles. (Use the <code>statefp</code> column in the <code>us_counties_2019_shp</code> table.) How many states are bigger than the Yukon-Koyukuk area?</li>&#13;
<li value="2">Using <code>ST_Distance()</code>, determine how many miles separate these two farmers’ markets: The Oakleaf Greenmarket (9700 Argyle Forest Blvd, Jacksonville, Florida) and Columbia Farmers Market (1701 West Ash Street, Columbia, Missouri). You’ll need to first find the coordinates for both in the <code>farmers_markets</code> table. Tip: you can also write this query using the Common Table Expression syntax you learned in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</li>&#13;
<li value="3">More than 500 rows in the <code>farmers_markets</code> table are missing a value in the <code>county</code> column, which is an example of dirty government data. Using the <code>us_counties_2019_shp</code> table and the <code>ST_Intersects()</code> function, perform a spatial join to find the missing county names based on the longitude and latitude of each market. Because <code>geog_point</code> in <code>farmers_markets</code> is of the <code>geography</code> type and its SRID is <code>4326</code>, you’ll need to cast <code>geom</code> in the census table to the <code>geography</code> type and change its SRID using <code>ST_SetSRID()</code>.</li>&#13;
<li value="4">The <code>nyc_yellow_taxi_trips</code> table you created in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span> contains the longitude and latitude where each trip began and ended. Use PostGIS functions to turn the drop-off coordinates into a <code>geometry</code> type and count the state/county pairs where each drop-off occurred. As with the previous exercise, you’ll need to join to the <code>us_counties_2019_shp</code> table and use its <code>geom</code> column for the spatial join.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>