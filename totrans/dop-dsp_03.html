<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="13" id="Page_13"/>2</span><br/>
<span class="ChapterTitle">Using Ansible to Manage Passwords, Users, and Groups</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Now that you’ve built your VM, let’s move on to performing administrative tasks like user management. The DevOps practice of automation is key to building and managing resources. To manage any Linux host, you need a basic understanding of the workings of passwords, users, and groups. Users and passwords are the building blocks of identity management, while groups allow you to manage a collection of users and control access to files, directories, and commands. Dividing up responsibilities between users and groups can be the difference between allowing unauthorized access and thwarting it.</p>
<p><span epub:type="pagebreak" title="14" id="Page_14"/>In this chapter, you’ll continue learning how to use Ansible, and you’ll also provision the VM you just created to improve your basic security policy. You’ll use some provided Ansible tasks to enforce complex passwords, manage users and groups, and control access to a shared directory and file. Once you have learned those security basics, you’ll be able to use them as the foundation of every playbook.</p>
<h2 id="h1-502482c02-0001">Enforcing Complex Passwords</h2>
<p class="BodyFirst">Letting users decide what a strong password is can be a recipe for disaster, so you’ll need to enforce complex passwords on every host that users can access. Since automation is one of our guiding principles, you’ll use code to enforce strong passwords for all users. To do this, you can use an Ansible task to install a plug-in for <em>Pluggable Authentication Modules</em> <em>(PAM)</em>, which is a user authentication framework that most Linux distributions employ. The plug-in to provide complex passwords is called <code>pam_pwquality</code>. This module validates passwords based on criteria you set. </p>
<h3 id="h2-502482c02-0001">Installing libpam-pwquality</h3>
<p class="BodyFirst">The <code>pwquality</code> PAM module is available in the Ubuntu software repository under the name <code>libpam-pwquality</code>. You’ll use the Ansible tasks provided with this book to install and configure this package. Remember, the goal is to automate everything you can, and tasks provide the mechanism to carry out administrative work. These tasks are located in the repository you cloned from the <span class="xref" itemid="xref_target_Introduction">Introduction</span>. Navigate to the <em>ansible/chapter2/</em> directory and open the <em>pam_pwquality.yml</em> file in your favorite editor. This file contains two tasks: <code>Install libpam-pwquality </code>and<code> Configure pam_pwquality</code>.</p>
<p>Let’s focus on the first task that uses the Ansible <code>package</code> module to install <code>libpam-pwquality</code> on the VM. At the top of the file, the install task should look like this:</p>
<pre><code>---
- name: <b>Install libpam-pwquality</b>
  package:
    name: "libpam-pwquality"
    state: present
<var>--snip--</var></code></pre>
<p>Each Ansible task should start with a <code>name</code> declaration that defines its goal. In this case, the <code>name</code> is <code>Install libpam-pwquality</code>. Next, the Ansible <code>package</code> module performs the software installation. The <code>package</code> module requires you to set two parameters: <code>name</code> and <code>state</code>. In this example, the package name (found in the Ubuntu repository) should be <code>libpam-pwquality</code>, and the <code>state</code> should be <code>present</code>. To remove a package, set the <code>state</code> to <code class="bold">absent</code>. This is a good example of declarative instruction, since you are telling Ansible to make sure this package is installed. You don’t need to worry how it gets installed, as long as it does. If you install the package (<code>present</code>) and then delete the task from Ansible, the package will still be installed on the <span epub:type="pagebreak" title="15" id="Page_15"/>next provision. You would have to explicitly set the package to <code>absent</code> if you wanted the host to represent your desired state.</p>
<p>As mentioned in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, Ansible modules (like the one above) perform common actions on an OS, such as enabling a firewall, managing users, or (in this case) installing software. Ansible allows your actions to be <em>idempotent</em>, which means you can do a specific action over and over again and the result will be the same as it was the last time you executed the action. Because of this, you should automate all you can! You’ll save time and avoid mistakes caused by manual fatigue. Imagine if you had to configure 1,000 machines a day. It would be almost impossible without automation!</p>
<h3 id="h2-502482c02-0002">Configuring pam_pwquality to Enforce a Stricter Password Policy</h3>
<p class="BodyFirst">On a default Ubuntu system, password complexity is not as strong as it could be. It requires a minimum password length of six characters and executes only some basic complexity checks. To enforce more complexity, you’ll want to configure <code>pam_pwquality</code> to set a stricter password policy.</p>
<p>A file named <em>/etc/pam.d/common-password</em> handles configuration of the <code>pam_pwquality</code> module. This file is where the Ansible task makes the necessary changes to validate passwords. All you need to do is change one line in that file. A common way to edit a line using Ansible is with the <code>lineinfile</code> module, which allows you to change a line in a file or check whether a line exists.</p>
<p>With the <code>pam_pwquality</code> task file still open, let’s review the second task from the top. It should look like this:</p>
<pre><code><var>--snip--</var>
- name: <b>Configure pam_pwquality</b>
  lineinfile:
    path: "/etc/pam.d/common-password"
    regexp: "pam_pwquality.so"

    line: "password required pam_pwquality.so minlen=12 lcredit=-1 ucredit=-1 
           dcredit=-1 ocredit=-1 retry=3 enforce_for_root”
    state: present
<var>--snip--</var></code></pre>
<p>Once again, the task starts with a name, <code>Configure pam_pwquality</code>, that describes its intent. Then it tells Ansible to use the <code>lineinfile</code> module to edit the PAM password file. The <code>lineinfile</code> module requires the <code>path</code> of the file to which you want to make changes. In this case, it is the PAM password file <em>/etc/pam.d/common-password</em>. Use a regular expression, or <em>regexp</em>, to find the line in the file you want to change. The regular expression locates the line that has <code>pam_pwquality.so</code> in it and replaces it with a new line. The replacement <code>line</code> parameter contains the <code>pwquality</code> configuration changes, which enforce more complexity. The options provided above enforce the following:</p>
<ul>
<li>A minimum password length of 12 characters</li>
<li>One lowercase letter</li>
<li>One uppercase letter</li>
<li><span epub:type="pagebreak" title="16" id="Page_16"/>One numeric character</li>
<li>One nonalphanumeric character</li>
<li>Three retries</li>
<li>Disable root override</li>
</ul>
<p>Adding these requirements will strengthen Ubuntu’s default password policy. Any new passwords will need to meet or exceed these requirements, which will make brute-forcing user passwords a bit harder for attackers.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p> 	The negative values in the configuration line above inform <code>pam_pwquality</code> that it must have at least “one of” for that category. See the <code>pam_pwquality</code> man page (enter <code class="bold">man</code> <code class="bold">pam_pwquality</code>) for further details.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Close the <em>pam_pwquality.yml</em> file so you can move on to creating users with an Ansible module.</p>
<h2 id="h1-502482c02-0002">Linux User Types</h2>
<p class="BodyFirst">When it comes to Linux, users come in three types: normal, system, and root. You can think of a <em>normal user</em> as a human account, and you’ll create one of those next. Every normal user is typically associated with a password, a group, and a username. Think of a <em>system user</em> as a nonhuman account, such as the user Nginx runs as. In fact, a system user is almost identical to a normal user, but it is located in a different user ID (UID) range for compartmental reasons. A <em>root user</em> (or <em>superuser</em>) account has unrestricted access to the operating system. You can tell the root user by its UID, which is always zero. As with all your configurations, you’ll use an Ansible module to do the heavy lifting when it comes to creating and configuring users.</p>
<h3 id="h2-502482c02-0003">Getting Started with the Ansible User Module</h3>
<p class="BodyFirst">Ansible comes with the <code>user</code> module, which makes managing users very easy. It handles all the messy details for accounts, like shells, keys, groups, and home directories. You’ll use the <code>user</code> module to create a new user called <em>bender</em><em>.</em> Feel free to name it something else if you want, but since the examples in this book use the <em>bender</em> username going forward, don’t forget to change the name in future chapters as well.</p>
<p>Open the <em>user_and_group.yml</em> file located in the <em>ansible/chapter2/</em> directory. This file contains the following five tasks:</p>
<ol class="decimal">
<li value="1">Ensure group <em>developers</em> exists.</li>
<li value="2">Create the user <em>bender</em>.</li>
<li value="3">Assign <em>bender</em> to the <em>developers</em> group.</li>
<li value="4">Create a directory named <em>engineering</em>.</li>
<li value="5">Create a file in the engineering directory.</li>
</ol>
<p><span epub:type="pagebreak" title="17" id="Page_17"/>These tasks will create a group and a user, assign a user to a group, and create a shared directory and file. </p>
<p>Though it’s counterintuitive, let’s start by focusing on the second task on the list, which creates the user <em>bender</em>. (We’ll get to the first task in the “Linux Groups” section on the next page.) It should look like this:</p>
<pre><code><var>--snip--</var>
- name: <b>Create the user 'bender'</b>
  user:
    name: bender
    shell: /bin/bash
    password: $6$...(truncated)
<var>--snip--</var></code></pre>
<p>This task, like all others, starts with a <code>name</code> that describes what it will do. In this case, it is <code>Create the user 'bender'</code>. You’ll use the Ansible <code>user</code> module to create a user. The <code>user</code> module has many options, but only the <code>name</code> parameter is required. In this example, the <code>name</code> is set to <code>bender</code>. Setting a user’s password at provision time can be useful, so set the optional <code>password</code> parameter field to a known password hash (more on this later). The <code>password</code> value, beginning with <code>$6</code>, is a cryptic hash that Linux supports. I have included a sample password hash for <em>bender</em> to show how you can automate this step. In the next section, I will walk through the process I used to generate it.</p>
<h3 id="h2-502482c02-0004">Generating a Complex Password</h3>
<p class="BodyFirst">You can use many different methods to generate a password to match the complexity you set in <code>pam_pwquality</code>. As mentioned earlier, I’ve supplied a password hash for you that matches this threshold to save time. I used a combination of two command line applications, <code>pwgen</code> and <code>mkpasswd</code>, to create the complex password. The <code>pwgen</code> command can generate secure passwords, and the <code>mkpasswd</code> command can generate passwords using different hashing algorithms. The <code>pwgen</code> application is provided by the <code>pwgen</code> package, and the <code>mkpasswd</code> application is provided by a package named <code>whois</code>. Together, these tools can generate the hash that Ansible and Linux expect.</p>
<p>Linux stores password hashes in a file called <em>shadow</em>. On an Ubuntu system, the password hashing algorithm is SHA-512 by default. To create your own SHA-512 hash for Ansible’s user module, use the commands below on an Ubuntu host:</p>
<pre><code>$ <b>sudo apt update</b>
$ <b>sudo apt install pwgen whois</b>
$ <b>pass=`pwgen --secure --capitalize --numerals --symbols 12 1`</b>
$<b> </b><b>echo $pass | mkpasswd --stdin --method=sha-512; echo $pass</b></code></pre>
<p>Since these packages are not installed by default, you’ll need to install them first with the APT package manager. The <code>pwgen</code> command generates a complex password that matches what you need to satisfy <code>pwquality</code> and saves it into a variable called <code>pass</code>. Next, the contents of the variable <code>pass</code> are piped into <code>mkpasswd</code> to be hashed using the <code>sha-512</code> algorithm. The final output <span epub:type="pagebreak" title="18" id="Page_18"/>should contain two lines. The first line contains the SHA-512 hash, and the second line contains the new password. You can take the hash string and set the <code>password</code> value in the user creation task to change it. Feel free to try it!</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">warning</span></h2>
<p>	In a real production environment, you won’t want to include a password hash in a version control system or inside an Ansible task, for obvious reasons. I included this example so you can have an easy way to create complex passwords that satisfy the <code>pam_pwquality</code> module. Use a tool like Ansible Vault to protect any sensitive information, like passwords or private keys. Ansible Vault stores these secrets in encrypted files instead of playbooks or tasks. Using this technique is beyond this book, but to learn more about Ansible Vault, visit <a href="https://docs.ansible.com/ansible/latest/user_guide/vault.html" class="LinkURL">https://docs.ansible.com/ansible/latest/user_guide/vault.html</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-502482c02-0003">Linux Groups</h2>
<p class="BodyFirst">Linux groups allow you to manage multiple users on a host. Creating groups is also an efficient way to limit access to resources on a host. It is much easier to administer changes to a group than to hundreds of users individually. For the next example, I’ve provided an Ansible task to create a group called <em>developers</em> that you will use to limit access to a directory and a file.</p>
<h3 id="h2-502482c02-0005">Getting Started with the Ansible Group Module</h3>
<p class="BodyFirst">Like the <code>user</code> module, Ansible has a <code>group</code> module that can manage creating and removing groups. Compared to other Ansible modules, the <code>group</code> module is very minimal; it can only create or delete a group.</p>
<p>Open the <em>user_and_group.yml</em> file in your editor to review the group creation task. The first task in the file should look like this:</p>
<pre><code>- name: <b>Ensure group 'developers' exists</b>
  group:
    name: developers
    state: present
<var>--snip--</var></code></pre>
<p>The <code>name</code> of the task states that you want to make sure a group exists. Use the <code>group</code> module to create the group. This module requires you to set the <code>name</code> parameter, which is set to <code>developers</code> here. The <code>state</code> parameter is set to <code>present</code>, so it will create the group if it does not already exist.</p>
<p>The group creation task is the first one in the file, and that is not by accident. You need to create the <em>developers</em> group before executing any other tasks. Tasks are run in order, so you need to make sure the group exists first. If you tried to reference the group before creating it, you would get an error message stating that the <em>developers </em>group doesn’t exist, and the provisioning would fail. Understanding Ansible’s task order of operations is key to performing more complex operations.</p>
<p>Keep the <em>user_and_group.yml</em> file open as you continue reviewing the other tasks.</p>
<h3 id="h2-502482c02-0006"><span epub:type="pagebreak" title="19" id="Page_19"/>Assigning a User to the Group</h3>
<p class="BodyFirst">To add a user to a group with Ansible, you’ll leverage the <code>user</code> module once again. In the <em>user_and_group.yml</em> file, locate the task that assigns <em>bender</em> to the <em>developers </em>group (the third task from the top in the file). It should look like this:</p>
<pre><code><var>--snip--</var>
- name: <b>Assign 'bender' to the 'developers' group</b>
  user:
    name: bender
    <b>groups: developers</b>
    append: yes
<var>--snip--</var></code></pre>
<p>First is the <code>name</code> of the task, which describes its intention. The <code>user</code> module appends <em>bender</em> to the <em>developers</em> group. The <code>groups</code> option can accept multiple groups in a comma-separated string. By using the <code>append</code> option, you leave <em>bender</em>’s previous groups intact and add only the <em>developers</em>. If you omit the <code>append</code> option, <em>bender</em> will be removed from all groups except its primary group and the one(s) listed in the <code>groups</code> parameter.</p>
<h3 id="h2-502482c02-0007">Creating Protected Resources</h3>
<p class="BodyFirst">With <em>bender</em>’s group affiliation sorted out, let’s visit the last two tasks in the <em>user_and_group.yml</em> file, which deal with creating a directory (<em>/opt/engineering/</em>) and a file (<em>/opt/engineering/private.txt</em>) on the VM. You’ll use this directory and file to test user access for <em>bender </em>later. </p>
<p>With the <em>user_and_group.yml</em> file still open, locate the two tasks. Start with the directory creation task (the fourth from the top in the file), which should look like this:</p>
<pre><code>- name: <b>Create a directory named 'engineering'</b>
  file:
    path: /opt/engineering
    state: directory
    mode: 0750
    group: developers</code></pre>
<p>First, as before, set the <code>name</code> to match the task’s intent. Use the <code>file</code> module to manage the directory and its attributes. The <code>path</code> parameter is where you want to create the directory. In this case, it’s set to <em>/opt/engineering/</em>. Since you want to create a directory, set the <code>state</code> parameter to the type of resource you want to create, which is <code>directory</code> in this example. You can use other types here, and you’ll see another one when you create the file later. The <code>mode</code>, or privilege, is set to <code>0750</code>. This number allows the owner (<em>root</em>) to read, write, and execute against this directory, while the group members are allowed only to read and execute. The execute permission is needed to enter the directory and list its contents. Linux uses octal numbers (<code>0750</code>, in this case) to define permissions on files and groups. See the <code>chmod</code> man page for more information on permission modes. Finally, set <span epub:type="pagebreak" title="20" id="Page_20"/>the <code>group</code> ownership of the directory to the <em>developers</em> group. This means only the users in the <em>developers</em> group can read or list the contents of this directory.</p>
<p>The last task in the <em>user_and_group.yml</em><em> </em>file creates an empty file inside the <em>/opt/engineering/</em> directory you just created. The task, located at the bottom of the file, should look like this:</p>
<pre><code>- name: <b>Create a file in the engineering directory</b>
  file:
    path: "/opt/engineering/private.txt"
    state: touch
    mode: 0770
    group: developers<b> </b></code></pre>
<p>Set the task <code>name</code> to what you want to do on the host. Use the <code>file</code> module again to create a file and set some attributes on it. The <code>path</code>, which is required, gives the file’s location on the VM. This example shows creating a file named <em>private.txt</em> inside the <em>/opt/engineering/</em> directory. The <code>state</code> parameter is set to <code>touch</code>, which means to create an empty file if it does not exist. If you need to create a nonempty file, you can use the <code>copy</code> or <code>template</code> Ansible modules. See the documentation for more details. The <code>mode</code>, or privileges, is set to read, write, and execute for any user in the group (<code>0770</code>). Finally, set the <code>group</code> ownership of the file to the <em>developers</em> group.</p>
<p>It is important to understand that there are many methods you can use to protect resources on a Linux host. Group restrictions are just a small piece of a larger authorization stack you would see in a production environment. I’ll discuss different access controls in a later chapter. But for now, just know that with Ansible’s tasks and modules, you can perform many common system configurations, such as securing files and directories across your whole environment.</p>
<h2 id="h1-502482c02-0004">Updating the VM</h2>
<p class="BodyFirst">So far, we’ve been describing Ansible modules and reviewing the tasks that will provision the VM. The next step actually uses them. To provision the VM, you’ll need to uncomment the tasks in the playbook under the <em>ansible/</em> directory. The <em>site.yml</em> file is the playbook you referenced in the provisioners section of your Vagrantfile.</p>
<p>Open the <em>site.yml</em> playbook file in your editor and locate the Chapter 2 tasks that look like this:</p>
<pre><code><var>--snip--</var>
tasks:
<b>  #- </b><b>import_tasks</b><b>: chapter2/</b><b>pam_pwquality.yml</b>
<b>  #- </b><b>import_tasks</b><b>: chapter2/</b><b>user_and_group.yml</b>
<var>--snip-- </var></code></pre>
<p>They are commented out. Remove the hash marks (<code>#</code>) at the start of the two lines to uncomment them so Ansible can execute the tasks. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="21" id="Page_21"/><h2><span class="NoteHead">Warning</span></h2>
<p>	Do not uncomment any other tasks, since that will cause unexpected consequences. You’ll use the other tasks later in this book. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The playbook should now look like this:</p>
<pre><code>---
- name: Provision VM
  hosts: all
  become: yes
  become_method: sudo
  remote_user: ubuntu
  tasks:
    - import_tasks: chapter2/pam_pwquality.yml
    - import_tasks: chapter2/user_and_group.yml
<var>--snip--</var></code></pre>
<p>Both Chapter 2 tasks, <code>pam_pwquality</code> and <code>user_and_group</code>, are now uncommented, so they will execute the next time you provision the VM. Save and close the playbook file for now.</p>
<p>You created the VM in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. If the VM is not running, however, enter the <code class="bold">vagrant up</code> command to start it again. With the VM running, all you need to do is issue the <code class="bold">vagrant</code> <code class="bold">provision</code> command from within the <em>vagrant/</em> directory to run the provisioner:</p>
<pre><code>$ <b>vagrant provision</b>
<var>--snip--</var>
PLAY RECAP *********************************************************************
Default : ok=8    changed=7   unreachable=0   failed=0   skipped=0    rescued=0   ignored=0</code></pre>
<p>The last line shows that the Ansible playbook ran and completed <code>8</code> actions. Think of <em>actions</em> as the tasks and other operations being run. Seven of those eight actions changed some state on the VM. The line shows that the provision is complete and had no errors or failed actions.</p>
<p>If your provision has failures, stop and try to troubleshoot them. Run the <code class="bold">provision</code> command again with the <code class="bold">--debug</code> flag, as shown in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>, to receive more information. You’ll need a successful provision to follow along with the examples in this book.</p>
<h2 id="h1-502482c02-0005">Testing User and Group Permissions</h2>
<p class="BodyFirst">To test the user and group permissions you just configured, you’ll issue the <code class="bold">ssh</code> command for <code>vagrant</code> to access the VM. Make sure you are in the <em>vagrant/</em> directory so you have access to the Vagrantfile. Once there, enter the command below in your terminal to log in to the VM:</p>
<pre><code>$ <b>vagrant ssh</b>
vagrant@dftd:~$</code></pre>
<p>You should be logged in as the <em>vagrant</em> user, which is the default user Vagrant creates.</p>
<p><span epub:type="pagebreak" title="22" id="Page_22"/>Next, to verify the user <em>bender</em> was created, you’ll use the <code class="bold">getent</code> command to query the <em>passwd</em> database for the user. This command allows you to query entries in files like <em>/etc/passwd</em>, <em>/etc/shadow</em>, and <em>/etc/group</em>. To check <em>bender</em>’s existence, enter the following command:</p>
<pre><code>$ <b>getent passwd bender</b>
bender:x:1002:1003::/home/bender:/bin/bash</code></pre>
<p>Your result should look similar to the output above. If the user was not created, the command will complete without any result.</p>
<p>Now, you should check whether the <em>developers</em> group exists and whether <em>bender</em> is a member of it. Query the <em>group</em> database for this information:</p>
<pre><code>$ <b>getent group developers</b>
developers:x:1002:bender</code></pre>
<p>The result should look like the output above, with a <em>developers</em> group and the user <em>bender </em>assigned to it. If the group did not exist, the command would have exited without any result.</p>
<p>For the final check, test that only members of the <em>developers </em>group can access the <em>/opt/engineering/</em> directory and the<em> private.txt</em> file. To do this, try to access the directory and file once as the <em>vagrant</em> user and then again as the <em>bender</em> user.</p>
<p>While logged in as <em>vagrant</em>, enter the command below to list the <em>/opt/engineering/</em> directory and its contents:</p>
<pre><code>$ <b>ls -al /opt/engineering/</b>
ls: cannot open directory '/opt/engineering/': Permission denied</code></pre>
<p>The output indicates that access is <code>denied</code> when trying to list files in <em>/opt/engineering</em> as the <em>vagrant</em> user. This is because the <em>vagrant </em>user is not a member of the <em>developers </em>group and thus does not have read access to the <code>directory</code>. </p>
<p>Now, to test the file permissions for <em>vagrant</em>, use the <code class="bold">cat</code> command to view the <em>/opt/engineering/private.txt </em>file:</p>
<pre><code>$ <b>cat /opt/engineering/private.txt</b>
cat: /opt/engineering/private.txt: Permission denied</code></pre>
<p>The same error occurs because the <em>vagrant</em> user does not have read permissions on the file.</p>
<p>The next test is to verify that <em>bender</em> has access to this same directory and file. To do this, you must be logged in as the <em>bender </em>user. Switch users from <em>vagrant </em>to <em>bender</em> using the <code class="bold">sudo</code> <code class="bold">su</code> command. (I’ll cover the <code>sudo</code> command in <span class="xref" itemid="xref_target_Chapter 4.">Chapter 4.</span>)</p>
<p>In your terminal, enter the following command to switch users:</p>
<pre><code>vagrant@dftd:~$ <b>sudo su - bender</b>
bender@dftd:~$</code></pre>
<p><span epub:type="pagebreak" title="23" id="Page_23"/>Once you have successfully switched users, try the command to list the directory again:</p>
<pre><code>$ <b>ls -al /opt/engineering/</b>
total 8
drwx<var>r</var>-<var>x</var>--- 2 root <var>developers</var>    4096 Jul  3 03:59 .
drwxr-xr-x 3 root root          4096 Jul  3 03:59 ..
-rwx<var>rwx</var>--- 1 root <var>developers</var>       0 Jul  3 04:02 private.txt</code></pre>
<p>Now, as you can see, you have successfully accessed the directory and its contents as <em>bender</em>, and the <em>private.txt</em> file is viewable. </p>
<p>Next, enter the following command to check whether <em>bender</em> can read the contents of the <em>/opt/engineering/private.txt</em> file:</p>
<pre><code>$<em> </em><b>cat</b><em> </em><b>/opt/engineering/private.txt</b></code></pre>
<p>You use the <code class="bold">cat</code> command again to view the contents of the file. Since the file is empty, there is no output. More importantly, there are no errors from <em>bender</em>’s attempt to access the file.</p>
<h2 id="h1-502482c02-0006">Summary</h2>
<p class="BodyFirst">In this chapter, you provisioned the VM using the following Ansible modules: <code>package</code>, <code>lineinfile</code>, <code>user</code>, <code>group</code>, and <code>file</code>. These modules configured the host to enforce complex passwords, manage a user and group, and secure access to a file and directory. These are common tasks a DevOps engineer would do in a typical environment. Not only did you expand your Ansible knowledge, but you learned how to automate basic security hygiene on the VM. In the next chapter, you’ll continue with the provided tasks and increase SSH security to limit access to the VM.</p>
</section>
</body></html>