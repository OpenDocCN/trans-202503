- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: DIFFIE–HELLMAN
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DIFFIE–HELLMAN
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In November 1976, Stanford researchers Whitfield Diffie and Martin Hellman published
    a research paper titled “New Directions in Cryptography” that revolutionized cryptography
    forever. In their paper, they introduced the notion of public-key encryption and
    signatures, though they didn’t actually have any of those schemes; they simply
    had what they termed a *public-key distribution scheme*, a protocol that allows
    two parties to establish a shared secret by exchanging information visible to
    an eavesdropper. This protocol is now known as the *Diffie–Hellman (DH) protocol*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1976 年 11 月，斯坦福大学的研究人员 Whitfield Diffie 和 Martin Hellman 发表了一篇名为《密码学的新方向》的研究论文，彻底改变了密码学。在他们的论文中，他们提出了公钥加密和签名的概念，尽管他们实际上没有这些方案；他们只是提出了他们所称的
    *公钥分配方案*，这是一种协议，允许两个当事方通过交换可被窃听者看到的信息来建立共享的秘密。这个协议现在被称为 *Diffie–Hellman（DH）协议*。
- en: Prior to Diffie–Hellman, establishing a shared secret required performing tedious
    procedures such as manually exchanging sealed envelopes. Once communicating parties
    have established a shared secret value with the DH protocol, that secret can be
    used to establish a *secure channel* by turning the secret into one or more symmetric
    keys that are then used to encrypt and authenticate subsequent communication.
    The DH protocol—and its variants—are therefore called key agreement protocols.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Diffie–Hellman 之前，建立共享秘密需要执行繁琐的程序，例如手动交换密封信封。一旦通信方通过 DH 协议建立了共享的秘密值，这个秘密可以用于通过将秘密转换为一个或多个对称密钥来建立
    *安全通道*，然后用这些密钥对后续通信进行加密和认证。因此，DH 协议及其变体被称为密钥协商协议。
- en: In the first part of this chapter, I review the mathematical foundations of
    the Diffie–Hellman protocol, including the computational problems that DH relies
    on to perform its magic. I then describe different versions of the Diffie–Hellman
    protocol used to create secure channels in the second part of this chapter. Finally,
    because Diffie–Hellman schemes are only secure when their parameters are well
    chosen, I conclude the chapter by examining scenarios where Diffie–Hellman can
    fail.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我回顾了 Diffie–Hellman 协议的数学基础，包括 DH 依赖于的计算问题，以便实现其神奇功能。然后，在本章的第二部分，我描述了用于创建安全通道的不同版本的
    Diffie–Hellman 协议。最后，由于 Diffie–Hellman 方案只有在参数选择得当时才是安全的，我通过检查 Diffie–Hellman
    可能失败的场景来结束本章。
- en: '**NOTE**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Diffie and Hellman received the prestigious Turing Award in 2015 for their
    invention of public-key cryptography and digital signatures, but others deserve
    credit as well. In 1974, two years before the seminal Diffie–Hellman paper, computer
    scientist Ralph Merkle introduced the idea of public-key cryptography with what
    are now called Merkle’s puzzles. Around that same year, researchers at GCHQ (Government
    Communications Headquarters), the British equivalent of the NSA, had also discovered
    the principles behind RSA and Diffie–Hellman key agreement, though that fact would
    only be declassified decades later.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*Diffie 和 Hellman 因发明了公钥密码学和数字签名而在 2015 年获得了声望卓著的图灵奖，但也有其他人应得的荣誉。早在 1974 年，即
    Diffie–Hellman 论文发表的两年前，计算机科学家 Ralph Merkle 就提出了公钥密码学的概念，并创造了现在称为 Merkle 迷题的东西。大约在同一时期，GCHQ（政府通信总部，英国相当于美国国家安全局）的一些研究人员也发现了
    RSA 和 Diffie–Hellman 密钥协商背后的原理，尽管这一事实直到数十年后才解密。*'
- en: The Diffie–Hellman Function
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Diffie–Hellman 函数
- en: In order to understand DH key agreement protocols, you must first understand
    their core operation, the *DH* *function*. The DH function will usually work with
    groups denoted **Z**[*p*]^*. Recall from [Chapter 9](ch09.xhtml#ch9) that these
    groups are formed of nonzero integer numbers modulo a prime number, denoted *p*.
    Another public parameter is the *base number*, *g*. All arithmetic operations
    are performed modulo *p*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 DH 密钥协商协议，你必须首先理解它们的核心操作，即 *DH* *函数*。DH 函数通常与以 **Z**[*p*]^* 表示的群体一起工作。回想一下[第
    9 章](ch09.xhtml#ch9)，这些群体是由模素数 *p* 的非零整数构成的。另一个公共参数是 *基数*，*g*。所有算术运算都是在 *p* 模下进行的。
- en: The DH function involves two private values chosen randomly by the two communicating
    parties from the group **Z**[*p*]^*, denoted *a* and *b*. A private value *a*
    has a public value associated with *A* = *g*^(*a*) mod *p*, or *g* raised to the
    power *a* modulo *p*. This value is sent to the other party through a message
    that is visible to eavesdroppers. The public value associated with *b* is *B*
    = *g*^(*b*) mod *p*, or *g* raised to the power *b* modulo *p*, which is sent
    to the owner of *a* through a publicly readable message.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: DH 函数涉及两个由通信双方从群体 **Z**[*p*]^* 随机选择的私有值，分别表示为 *a* 和 *b*。私有值 *a* 具有一个与之相关的公共值
    *A* = *g*^(*a*) mod *p*，即 *g* 的 *a* 次方模 *p*。这个值通过一个可被窃听者看到的消息发送给另一方。与 *b* 相关的公共值是
    *B* = *g*^(*b*) mod *p*，即 *g* 的 *b* 次方模 *p*，这个值通过一个公开可读的消息发送给 *a* 的拥有者。
- en: 'DH works its magic by combining either public value with the other private
    value, such that the result is the same in both cases: *A*^(*b*) = (*g*^(*a*))^(*b*)
    = *g*^(*ab*) and *B* ^(*a*) = (*g*^(*b*))^(*a*) = *g*^(*ba*) = *g*^(*ab*). The
    resulting value, *g*^(*ab*), is the *shared secret*; it is then passed to a *key
    derivation function (KDF)* in order to generate one or more shared symmetric keys.
    A KDF is a kind of hash function that will return a random-looking string the
    size of the desired key length.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: DH 的神奇之处在于将一个公共值与另一个私有值结合，从而使结果在两种情况下相同：*A*^(*b*) = (*g*^(*a*))^(*b*) = *g*^(*ab*)
    和 *B*^(*a*) = (*g*^(*b*))^(*a*) = *g*^(*ba*) = *g*^(*ab*)。得到的值 *g*^(*ab*) 就是 *共享秘密*；然后它被传递给
    *密钥派生函数 (KDF)*，以生成一个或多个共享的对称密钥。KDF 是一种哈希函数，它会返回一个随机看似的字符串，大小为所需密钥长度。
- en: And that’s it. Like many great scientific discoveries (gravity, relativity,
    quantum computing, or RSA), the Diffie–Hellman trick is terribly simple in hindsight.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了。像许多伟大的科学发现一样（如引力、相对论、量子计算或 RSA），Diffie–Hellman 的技巧事后看是极其简单的。
- en: Diffie–Hellman’s simplicity can be deceiving, however. For one thing, it won’t
    work with just any prime *p* or base number *g*. For example, some values of *g*
    will restrict the shared secrets *g*^(*ab*) to a small subset of possible values,
    whereas you’d expect to have about as many possible values as elements in **Z**[*p*]^*,
    and therefore as many possible values for the shared secret. To ensure the highest
    security, safe DH parameters should work with a prime *p* such that (*p* – 1)
    / 2 is also prime. Such a *safe prime* guarantees that the group doesn’t have
    small subgroups that would make DH easier to break. With a safe prime, DH can
    notably work with *g* = 2, which makes computations slightly faster. But generating
    a safe prime *p* takes more time than generating a totally random prime.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Diffie–Hellman 的简洁性可能具有误导性。例如，它不能与任何素数 *p* 或基数 *g* 一起工作。举例来说，一些 *g* 的值会将共享的秘密
    *g*^(*ab*) 限制在一小部分可能的值之内，而你期望的应该是与 **Z**[*p*]^* 中的元素数量大致相同的可能值，从而共享秘密的可能值也应该是如此。为了确保最高的安全性，安全的
    DH 参数应与一个素数 *p* 一起工作，使得 (*p* – 1) / 2 也是素数。这样的 *安全素数* 保证了该群体不会有小的子群，从而使 DH 更容易被破解。使用安全素数时，DH
    可以特别地与 *g* = 2 一起工作，这使得计算略微加快。但生成一个安全素数 *p* 的时间比生成一个完全随机的素数要长。
- en: For example, the `dhparam` command of the OpenSSL toolkit will only generate
    safe DH parameters, but the extra checks built into the algorithm result increase
    the execution time considerably, as shown in [Listing 11-1](ch11.xhtml#ch11list1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，OpenSSL 工具包的`dhparam`命令只会生成安全的 DH 参数，但算法中内置的额外检查会显著增加执行时间，正如[示例 11-1](ch11.xhtml#ch11list1)所示。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: Measuring the execution time of generating 2048-bit Diffie–Hellman
    parameters with the OpenSSL toolkit*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-1：使用 OpenSSL 工具包生成 2048 位 Diffie–Hellman 参数的执行时间测量*'
- en: As you can see in [Listing 11-1](ch11.xhtml#ch11list1), it took 154.53 seconds
    to generate the DH parameters using the OpenSSL toolkit. Now, for the sake of
    comparison, [Listing 11-2](ch11.xhtml#ch11list2) shows how long it takes on the
    same system to generate RSA parameters of the same size (that is, two prime numbers,
    *p* and *q*, each half the size of the *p* used for DH).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[示例 11-1](ch11.xhtml#ch11list1)中看到的，使用 OpenSSL 工具包生成 DH 参数花费了 154.53 秒。现在，为了进行比较，[示例
    11-2](ch11.xhtml#ch11list2) 显示了在相同系统上生成相同大小的 RSA 参数（即两个素数 *p* 和 *q*，每个素数的大小是用于
    DH 的 *p* 的一半）所需的时间。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Generating 2048-bit RSA parameters while measuring the execution
    time*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-2：生成 2048 位 RSA 参数并测量执行时间*'
- en: Generating DH parameters took about 1000 times longer than generating RSA parameters
    of the same security level, mainly due to the extra constraint imposed on the
    prime generated to create DH parameters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生成DH参数的时间大约是生成相同安全级别的RSA参数的1000倍，主要是由于在生成用于创建DH参数的素数时施加的额外约束。
- en: The Diffie–Hellman Problems
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Diffie–Hellman问题
- en: The security of DH protocols relies on the hardness of computational problems,
    especially on that of the discrete logarithm problem (DLP) introduced in [Chapter
    9](ch09.xhtml#ch9). Clearly, DH can be broken by recovering the private value
    *a* from its public value *g*^(*a*), which boils down to solving a DLP instance.
    But we don’t care only about the discrete logarithm problem when using DH to compute
    shared secrets. We also care about two DH-specific problems, as explained next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: DH协议的安全性依赖于计算问题的难度，特别是依赖于[第9章](ch09.xhtml#ch9)中介绍的离散对数问题(DLP)的难度。显然，通过从公共值 *g*^(*a*)
    中恢复私有值 *a*，可以破解DH协议，这本质上就是解决DLP实例。但当我们使用DH计算共享秘密时，我们不仅关心离散对数问题。我们还关心两个与DH特定相关的问题，如下所述。
- en: '*The Computational Diffie–Hellman Problem*'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*计算Diffie–Hellman问题*'
- en: The *computational Diffie–Hellman (CDH)* problem is that of computing the shared
    secret *g*^(*ab*) given only the public values *g*^(*a*) and *g*^(*b*), and not
    any of the secret values *a* or *b*. The motivation is obviously to ensure that
    even if an eavesdropper captures *g*^(*a*) and *g*^(*b*), they should not be able
    to determine the shared secret *g*^(*ab*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算Diffie–Hellman (CDH)*问题是指在仅知道公共值 *g*^(*a*) 和 *g*^(*b*)，而不知道任何秘密值 *a* 或 *b*
    的情况下，计算共享秘密 *g*^(*ab*) 的问题。其动机显然是确保即使窃听者捕获了 *g*^(*a*) 和 *g*^(*b*)，他们也无法确定共享秘密
    *g*^(*ab*)。'
- en: If you can solve DLP, then you can also solve CDH; to put it simply, if you
    can solve DLP, then given *g*^(*a*) and *g*^(*b*), you’ll be able to derive *a*
    and *b* to compute *g*^(*ab*). In other words, DLP is *at least* as hard as CDH.
    But we don’t know for sure whether CDH is at least as hard as DLP, which would
    make the problems equally hard. In other words, DLP is to CDH what the factoring
    problem is to the RSA problem. (Recall that factoring allows you to solve the
    RSA problem, but not necessarily the converse.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够解决DLP问题，那么你也能够解决CDH问题；简而言之，如果你能够解决DLP问题，那么在给定 *g*^(*a*) 和 *g*^(*b*) 的情况下，你将能够推导出
    *a* 和 *b*，从而计算出 *g*^(*ab*)。换句话说，DLP问题至少和CDH问题一样难。但我们并不确定CDH问题是否至少和DLP问题一样难，这将使得这两个问题具有相同的难度。换句话说，DLP问题对于CDH问题就像因式分解问题对于RSA问题一样。（回想一下，因式分解能够解决RSA问题，但不一定能够反过来解决。）
- en: 'Diffie–Hellman shares another similarity with RSA in that DH will deliver the
    same security level as RSA for a given modulus size. For example, the DH protocol
    with a 2048-bit prime *p* will get you about the same security that RSA with a
    2048-bit modulus *n* offers, which is about 90 bits. Indeed, the fastest way we
    know to break CDH is to solve DLP using an algorithm called the *number field
    sieve*, a method similar but not identical to the fastest one that breaks RSA
    by factoring its modulus: the general number field sieve (GNFS).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman与RSA有一个相似之处，即对于给定的模数大小，DH将提供与RSA相同的安全级别。例如，具有2048位素数 *p* 的DH协议将为你提供与具有2048位模数
    *n* 的RSA大致相同的安全性，即大约90位。事实上，破解CDH的最快方法是通过一种称为*数域筛法*的算法来解决DLP问题，这种方法类似但不完全相同于破解RSA的最快方法：一般数域筛法（GNFS）。
- en: '*The Decisional Diffie–Hellman Problem*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*决策Diffie–Hellman问题*'
- en: Sometimes we need something stronger than CDH’s hardness assumption. For example,
    imagine that an attacker can compute the first 32 bits of *g*^(*ab*) given the
    2048-bit values of *g*^(*a*) and *g*^(*b*), but that they can’t compute all 2048
    bits. Although CDH would still be unbroken because 32 bits aren’t enough to completely
    recover *g*^(*ab*), the attacker would still have learned something about the
    shared secret, which might still allow them to compromise an application’s security.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要比CDH难度假设更强的假设。例如，假设攻击者能够在给定2048位的 *g*^(*a*) 和 *g*^(*b*) 的情况下计算出 *g*^(*ab*)
    的前32位，但无法计算出所有2048位。虽然由于32位不足以完全恢复 *g*^(*ab*)，CDH仍然是安全的，但攻击者仍然可能已经学到了一些关于共享秘密的信息，这可能会让他们突破应用的安全性。
- en: To ensure that an attacker can’t learn anything about the shared secret *g*^(*ab*),
    this value needs only to be indistinguishable from a random group element, just
    as an encryption scheme is secure when ciphertexts are indistinguishable from
    random strings. The computational problem formalizing this intuition is called
    the *decisional Diffie–Hellman (DDH)* problem. Given *g*^(*a*), *g*^(*b*), and
    a value that is either *g*^(*ab*) or *g*^(*c*) for some random *c* (each of the
    two with a chance of 1/2), the DDH problem consists of determining whether *g*^(*ab*)
    (the shared secret corresponding to *g*^(*a*) and *g*^(*b*)) was chosen. The assumption
    that no attacker can solve DDH efficiently is called the *decisional Diffie–Hellman
    assumption**.*
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保攻击者无法得知任何关于共享密钥 *g*^(*ab*) 的信息，这个值只需要与一个随机群元素无法区分，就像加密方案在密文无法区分于随机字符串时才是安全的。正式化这一直觉的计算问题被称为
    *判定性Diffie–Hellman（DDH）* 问题。给定 *g*^(*a*), *g*^(*b*)，以及一个值，它是 *g*^(*ab*) 或 *g*^(*c*)，其中
    *c* 是一个随机数（每个有1/2的概率），DDH问题的任务是确定是否选择了 *g*^(*ab*)（对应于 *g*^(*a*) 和 *g*^(*b*) 的共享秘密）。假设没有攻击者可以高效地解决DDH，这个假设被称为
    *判定性Diffie–Hellman假设*。
- en: 'If DDH is hard, then CDH is also hard, and you can’t learn anything about *g*^(*ab*).
    But if you can solve CDH, you can also solve DDH: given a triplet (*g*^(*a*),
    *g*^(*b*), *g*^(*c*)), you would be able to derive *g*^(*ab*) from *g*^(*a*) and
    *g*^(*b*) and check whether the result is equal to the given *g*^(*c*). The bottom
    line is that DDH is fundamentally less hard than CDH, yet DDH hardness is a prime
    assumption in cryptography, and one of the most studied. We can be confident that
    both CDH and DDH are hard when Diffie–Hellman parameters are well chosen.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DDH是困难的，那么CDH也同样困难，你无法从中学到任何关于 *g*^(*ab*) 的信息。但如果你能解决CDH，那么你也能解决DDH：给定一个三元组
    (*g*^(*a*), *g*^(*b*), *g*^(*c*)), 你就可以从 *g*^(*a*) 和 *g*^(*b*) 中推导出 *g*^(*ab*)，并检查结果是否与给定的
    *g*^(*c*) 相等。底线是，DDH在本质上比CDH更简单，但DDH的难度是加密学中的一个基本假设，并且是最研究的课题之一。我们可以确信，当Diffie–Hellman参数选择得当时，CDH和DDH都很难。
- en: '*More Diffie–Hellman Problems*'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*更多的Diffie–Hellman问题*'
- en: Sometimes cryptographers devise new schemes and prove that they are at least
    as hard to break as it is to solve some problem related to CDH or DDH but not
    identical to either of these. Ideally, we’d like to demonstrate that breaking
    a cryptosystem is as hard as solving CDH or DDH, but this isn’t always possible
    with advanced cryptographic mechanisms, typically because such schemes involve
    more complex operations than basic Diffie–Hellman protocols.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，加密学家设计新的方案，并证明它们至少与解决与CDH或DDH相关的问题一样困难，但并不完全与这两者相同。理想情况下，我们希望证明破解一个加密系统的难度与解决CDH或DDH的难度相同，但这并不总是可以通过先进的加密机制实现，通常是因为这些方案涉及比基本的Diffie–Hellman协议更复杂的操作。
- en: For example, in one DH-like problem, given *g*^(*a*), an attacker would attempt
    to compute *g*^(1/*a*), where 1/*a* is the inverse of *a* in the group (typically
    **Z**[*p*]^* for some prime *p*). In another, an attacker might distinguish the
    pairs (*g*^(*a*), *g*^(*b*)) from the pairs (*g*^(*a*), *g*^(1/*a*)) for random
    *a* and *b*. Finally, in what is called the *twin Diffie–Hellman problem*, given
    *g*^(*a*), *g*^(*b*), and *g*^(*c*), an attacker would attempt to compute the
    two values *g*^(*ab*) and *g*^(*ac*). Sometimes such DH variants turn out to be
    as hard as CDH or DDH, and sometimes they’re fundamentally easier—and therefore
    provide lower security guarantees. As an exercise, try to find connections between
    the hardness of these problems and that of CDH and DDH. (Twin Diffie–Hellman is
    actually *as hard* as CDH, but that isn’t easy to prove!)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个类似于DH的问题中，给定 *g*^(*a*)，攻击者会尝试计算 *g*^(1/*a*)，其中1/*a*是群中*a*的逆元（通常是 **Z**[*p*]^*，其中
    *p* 是某个素数）。在另一个问题中，攻击者可能会区分 (*g*^(*a*), *g*^(*b*)) 和 (*g*^(*a*), *g*^(1/*a*))
    这两对随机的 *a* 和 *b*。最后，在所谓的 *双重Diffie–Hellman问题* 中，给定 *g*^(*a*), *g*^(*b*) 和 *g*^(*c*)，攻击者会尝试计算两个值
    *g*^(*ab*) 和 *g*^(*ac*)。有时这些DH变种与CDH或DDH一样困难，有时它们本质上更容易——因此提供的安全保障较低。作为练习，尝试找出这些问题的难度与CDH和DDH之间的关系。（双重Diffie–Hellman实际上与CDH
    *一样困难*，但这并不容易证明！）
- en: Key Agreement Protocols
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密钥协议
- en: The Diffie–Hellman problem is designed to build secure key agreement protocols—protocols
    designed to secure communication between two or more parties communicating over
    a network with the aid of a shared secret. This secret is turned into one or more
    *session keys*—symmetric keys used to encrypt and authenticate the information
    exchanged for the duration of the session. But before studying actual DH protocols,
    you should know what makes a key agreement protocol secure or insecure, and how
    simpler protocols work. We’ll begin our discussion with a widely used key agreement
    protocol that doesn’t rely on DH.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman 问题旨在构建安全的密钥协议——这些协议旨在保护通过网络进行通信的两个或多个参与方之间的通信，并利用共享秘密进行保护。这个秘密被转化为一个或多个
    *会话密钥*——用于加密和验证会话期间交换的信息的对称密钥。在研究实际的 DH 协议之前，你应该了解是什么使密钥协议安全或不安全，以及简单协议是如何工作的。我们将从一个广泛使用的密钥协议开始，它不依赖于
    DH。
- en: '*An Example of Non-DH Key Agreement*'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*非 DH 密钥协议示例*'
- en: To give you a sense of how a key agreement protocol works and what it means
    for it to be secure, let’s look at the protocol used in the 3G and 4G telecommunications
    standards to establish communication between a SIM card and a telecom operator.
    The protocol is often referred to as *AKA*, for *authenticated key agreement*.
    It doesn’t use the Diffie–Hellman function, but instead uses only symmetric-key
    operations. The details are a bit boring, but essentially the protocol works as
    shown in [Figure 11-1](ch11.xhtml#ch11fig1).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解密钥协议是如何工作的，以及它安全意味着什么，我们来看看在 3G 和 4G 电信标准中用于建立 SIM 卡与电信运营商之间通信的协议。这个协议通常被称为
    *AKA*，即 *认证密钥协议*。它不使用 Diffie–Hellman 函数，而是仅使用对称密钥操作。细节可能有点枯燥，但本质上，这个协议如[图 11-1](ch11.xhtml#ch11fig1)所示。
- en: '![image](../images/f11-01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-01.jpg)'
- en: '*Figure 11-1: The authenticated key agreement protocol in 3G and 4G telecommunication*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：3G 和 4G 电信中的认证密钥协议*'
- en: In this implementation of the protocol, the SIM card has a secret key, *K*,
    that the operator knows. The operator begins the session by selecting a random
    value, *R*, and then computes two values, *SK* and *V*[1], based on two pseudorandom
    functions, **PRF**0 and **PRF**1\. Next, the operator sends a message to the SIM
    card containing the values *R* and *V*[1], which are visible to attackers. Once
    the SIM card has *R*, it has what it needs in order to compute *SK* with **PRF**0,
    and it does so. The two parties in this session end up with a shared key, *SK*,
    that attackers are unable to determine by simply looking at the messages exchanged
    between the parties, or even by modifying them or injecting new ones. The SIM
    card verifies that it’s talking to the operator by recomputing *V*[1] with **PRF**1,
    *K*, and *R*, and then checking to make sure that the calculated *V*[1] matches
    the *V*[1] sent by the operator. The SIM card then computes a verification value,
    *V*[2], with a new function, **PRF**2, with *K* and *R* as input, and sends *V*[2]
    to the operator. The operator verifies that the SIM card knows *K* by computing
    *V*[2] and checking that the computed value matches the *V*[2] it received.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个协议的实现中，SIM 卡拥有一个秘密密钥 *K*，这是运营商所知道的。运营商通过选择一个随机值 *R* 开始会话，然后基于两个伪随机函数 **PRF**0
    和 **PRF**1 计算两个值 *SK* 和 *V*[1]。接下来，运营商向 SIM 卡发送一个包含 *R* 和 *V*[1] 的消息，这些值对攻击者可见。一旦
    SIM 卡获得 *R*，它就具备计算 *SK* 所需的信息，使用 **PRF**0 完成此操作。会话中的两个参与方最终共享一个密钥 *SK*，攻击者无法通过查看双方交换的消息，甚至修改消息或注入新消息来确定该密钥。SIM
    卡通过重新计算 *V*[1]，使用 **PRF**1、*K* 和 *R* 作为输入，来验证自己是否在与运营商通信，然后检查计算出的 *V*[1] 是否与运营商发送的
    *V*[1] 匹配。然后，SIM 卡使用新函数 **PRF**2、*K* 和 *R* 计算验证值 *V*[2]，并将 *V*[2] 发送给运营商。运营商通过计算
    *V*[2] 并检查计算结果是否与接收到的 *V*[2] 匹配，来验证 SIM 卡是否知道 *K*。
- en: 'But this protocol is not immune to all kinds of attacks: in principle there’s
    a way to fool the SIM card with a replay attack. Essentially, if an attacker captures
    a pair (*R*, *V*[1]), they may send it to the SIM card and trick the SIM into
    believing that the pair came from a legitimate operator that knows *K*. To prevent
    this attack, the protocol includes additional checks to ensure that the same *R*
    isn’t reused.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个协议并非对所有攻击免疫：原则上，有一种方法可以通过重放攻击欺骗 SIM 卡。基本上，如果攻击者捕获到一对 (*R*, *V*[1])，他们可能将其发送给
    SIM 卡，并欺骗 SIM 卡相信该对来自一个知道 *K* 的合法运营商。为了防止这种攻击，协议包括了额外的检查，以确保同一个 *R* 不会被重用。
- en: Problems can also arise if *K* is compromised. For example, an attacker who
    compromises *K* can perform a man-in-the-middle attack and listen to all cleartext
    communication. Such an attacker could send messages between the two parties while
    pretending to be both the legitimate SIM card operator and the SIM card. The greater
    risk is that an attacker can record communications and any messages exchanged
    during the key agreement, and later decrypt those communications by using the
    captured *R* values. An attacker could then determine the past session keys and
    use them to decrypt the recorded traffic.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*K*被泄露，也可能会出现问题。例如，攻击者如果掌握了*K*，就可以进行中间人攻击，并监听所有明文通信。这样的攻击者可能在两方之间发送消息，同时伪装成合法的SIM卡运营商和SIM卡。更大的风险是，攻击者可以记录通信内容以及在密钥协商过程中交换的任何消息，并且稍后可以使用捕获的*R*值解密这些通信。攻击者可以由此推算出过去的会话密钥，并使用它们解密录制的流量。
- en: '*Attack Models for Key Agreement Protocols*'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*密钥协商协议的攻击模型*'
- en: There is no single definition of security for key agreement protocols, and you
    can never say that a key protocol is completely secure without context and without
    considering the attack model and the security goals. You can, for example, argue
    that the previous 3G/4G protocol is secure because a passive attacker won’t find
    the session keys, but you could also argue that it’s insecure because once the
    key *K* leaks, then all previous and future communications are compromised.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于密钥协商协议，并没有单一的安全定义，无法在没有上下文和不考虑攻击模型以及安全目标的情况下说某个密钥协议是完全安全的。例如，你可以说之前的3G/4G协议是安全的，因为被动攻击者不会找到会话密钥，但你也可以说它不安全，因为一旦密钥*K*泄漏，那么所有以前和未来的通信都会受到威胁。
- en: 'There are different notions of security in key agreement protocols as well
    as three main attack models that depend on the information the protocol leaks.
    From weakest to strongest, these are the *eavesdropper*, the *data leak*, and
    the *breach*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在密钥协商协议中有不同的安全概念，以及三个主要的攻击模型，这些模型取决于协议泄露的信息。从最弱到最强，这些模型分别是*窃听者*、*数据泄漏*和*漏洞*：
- en: '**The eavesdropper** This attacker observes the messages exchanged between
    the two legitimate parties running a key agreement protocol and can record, modify,
    drop, or inject messages. To protect against an eavesdropper, a key agreement
    protocol must not leak any information on the shared secret established.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**窃听者** 这个攻击者观察两个合法方之间交换的消息，并可以记录、修改、丢弃或注入消息。为了防止窃听者，密钥协商协议必须确保不泄露任何关于共享秘密的信息。'
- en: '**The data leak** In this model, the attacker acquires the session key and
    all *temporary* secrets (such as *SK* in the telecom protocol example discussed
    previously) from one or more executions of the protocol, but not the long-term
    secrets (like *K* in that same protocol).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据泄漏** 在这个模型中，攻击者通过一次或多次协议执行获取会话密钥和所有*临时*秘密（例如前面讨论的电信协议示例中的*SK*），但没有获取长期密钥（例如同一协议中的*K*）。'
- en: '**The breach (or corruption)** In this model, the attacker learns the long-term
    key of one or more of the parties. Once a breach occurs, security is no longer
    attainable because the attacker can impersonate one or both parties in subsequent
    sessions of the protocol. Nonetheless, the attacker shouldn’t be able to recover
    secrets from sessions executed before gathering the key.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**漏洞（或破坏）** 在这个模型中，攻击者获得了一个或多个方的长期密钥。一旦发生漏洞，安全性就不再可得，因为攻击者可以在协议的后续会话中冒充一方或双方。然而，攻击者不应能够从收集密钥之前执行的会话中恢复秘密。'
- en: Now that we’ve looked at the attack models and seen what an attacker can do,
    let’s explore the security goals—that is, the security guarantees that the protocol
    should offer. A key agreement protocol can be designed to satisfy several security
    goals. The four most relevant ones are described here, in order from simplest
    to most sophisticated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过攻击模型并了解了攻击者可以做些什么，接下来我们来探讨安全目标——也就是协议应提供的安全保障。密钥协商协议可以设计来满足多个安全目标。这里描述了四个最相关的目标，按从简单到复杂的顺序排列。
- en: '**Authentication** Each party should be able to authenticate the other party.
    That is, the protocol should allow for *mutual authentication*. Authenticated
    key agreement (AKA) occurs when a protocol authen­ticates both parties.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证** 每一方都应该能够验证另一方的身份。也就是说，协议应允许进行*相互身份验证*。认证密钥协商（AKA）发生在协议认证了双方身份时。'
- en: '**Key control** Neither party should be able to choose the final shared secret
    or coerce it to be in a specific subset. The 3G/4G key agreement protocol discussed
    earlier lacks this property because the operator chooses the value for *R* that
    entirely determines the final shared key.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键控制** 无论哪一方都不应该能够选择最终的共享密钥或将其强迫在某个特定子集内。前面讨论的3G/4G密钥协商协议缺乏这一特性，因为运营商选择了*R*的值，这完全决定了最终共享密钥。'
- en: '**Forward secrecy** This is the assurance that even if all long-term secrets
    are exposed, shared secrets from previous executions of the protocol won’t be
    able to be computed, even if an attacker records all previous executions or is
    able to inject or modify messages from previous executions. A *forward-secret*
    protocol guarantees that even if you have to deliver your devices and their secrets
    to some authority or other, they won’t be able to decrypt your prior encrypted
    communications. (The 3G/4G key agreement protocol doesn’t provide forward secrecy.)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向保密性** 这是指即使所有长期密钥都被暴露，之前执行协议时的共享密钥也无法被计算出来，即使攻击者记录了所有之前的执行，或能够注入或修改之前执行中的消息。*前向保密*协议保证，即使你必须将设备和它们的秘密交给某个机构或其他地方，它们也无法解密你之前加密的通信。（3G/4G密钥协商协议不提供前向保密性。）'
- en: '**Resistance to key-compromise impersonation (KCI)** KCI occurs when an attacker
    compromises a party’s long-term key and is able to use it to impersonate another
    party. For example, the 3G/4G key agreement protocol allows trivial key-compromise
    impersonation because both parties share the same key *K*. A key agreement protocol
    should ideally prevent this kind of attack.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**抗密钥泄露伪装（KCI）** KCI发生在攻击者泄露了一方的长期密钥，并能够用它冒充另一方。例如，3G/4G密钥协商协议允许简单的密钥泄露伪装，因为双方共享相同的密钥*K*。理想的密钥协商协议应该防止这种攻击。'
- en: '*Performance*'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*性能*'
- en: To be useful, a key agreement protocol should be not only secure but also efficient.
    Several factors should be taken into account when considering a key agreement
    protocol’s efficiency, including the number of messages exchanged, the length
    and number of messages, the computational effort to implement the protocol, and
    whether precomputations can be made to save time. A protocol is generally more
    efficient if fewer, shorter messages are exchanged, and it’s best if interactivity
    is kept minimal so that neither party has to wait to receive a message before
    sending the next one. A common measure of a protocol’s efficiency is its duration
    in terms of *round trips*, or the time it takes to send a message and receive
    a response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要有用，一个密钥协商协议不仅应该是安全的，还应该是高效的。考虑到密钥协商协议的效率时，应该考虑多个因素，包括交换的消息数量、消息的长度和数量、实现协议的计算工作量，以及是否可以进行预计算以节省时间。如果交换的消息较少且较短，且最好保持最小的交互性，以便双方不必等待接收到消息后才发送下一个消息，那么协议通常会更高效。协议效率的常见衡量标准是以*往返*时间计算，或发送一条消息并接收回应的时间。
- en: Round-trip time is usually the main cause of latency in protocols, but the amount
    of computation to be carried out also counts; the fewer the computations required
    the better, and the more precomputations that can be done in advance, the better.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 往返时间通常是协议中延迟的主要原因，但要执行的计算量也很重要；所需的计算越少越好，并且可以提前完成的预计算越多越好。
- en: For example, the 3G/4G key agreement protocol discussed earlier exchanges two
    messages of a few hundred bits each, which must be sent in a certain order. Pre-computation
    can be used with this protocol to save time since the operator can pick many values
    of *R* in advance; precompute the matching values of *SK*, *V*[1], and *V*[2];
    and store them all in a database. In this case, precomputation has the advantage
    of reducing the exposure of the long-term key.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，前面讨论的3G/4G密钥协商协议交换了两条几百比特的消息，且必须按照特定顺序发送。此协议可以使用预计算来节省时间，因为运营商可以提前选择多个*R*值；预计算出匹配的*SK*、*V*[1]和*V*[2]值；并将它们存储在数据库中。在这种情况下，预计算的优势是减少了长期密钥的暴露。
- en: Diffie–Hellman Protocols
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迪菲-赫尔曼协议
- en: The Diffie–Hellman function is the core of most of the deployed public-key agreement
    protocols. However, there is no single Diffie–Hellman protocol, but rather a variety
    of ways to use the DH function in order to establish a shared secret. We’ll review
    three of those protocols in the sections that follow. In each discussion, I’ll
    stick to the usual crypto placeholder names and call the two parties Alice and
    Bob, and the attacker Eve. I’ll write *g* as the basis of the group used for arithmetic
    operations, a value fixed and known in advance to Alice and Bob.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman函数是大多数已部署的公钥协议的核心。然而，并没有单一的Diffie–Hellman协议，而是多种方式使用DH函数来建立共享密钥。接下来的章节中，我们将回顾其中三种协议。在每次讨论中，我将坚持使用常见的加密占位符名称，称两方为Alice和Bob，攻击者为Eve。我将写*g*为用于算术运算的群体基数，这是一个固定值，Alice和Bob事先都已知晓。
- en: '*Anonymous Diffie–Hellman*'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*匿名Diffie–Hellman*'
- en: '*Anonymous Diffie–Hellman* is the simplest of the Diffie–Hellman protocols.
    It’s called anonymous because it’s not authenticated; the participants have no
    identity that can be verified by either party, and neither party holds a long-term
    key. Alice can’t prove to Bob that she’s Alice, and vice versa.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*匿名Diffie–Hellman*是所有Diffie–Hellman协议中最简单的一种。之所以称为“匿名”，是因为它没有认证；参与者没有可以被另一方验证的身份，也没有持有长期密钥。Alice无法向Bob证明她就是Alice，反之亦然。'
- en: In anonymous Diffie–Hellman, each party picks a random value (*a* for Alice
    and *b* for Bob) to use as a private key, and sends the corresponding public key
    to the other peer. [Figure 11-2](ch11.xhtml#ch11fig2) shows the process in a bit
    more detail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名Diffie–Hellman协议中，每一方选择一个随机值（*a*为Alice，*b*为Bob）作为私钥，并将相应的公钥发送给另一方。[图11-2](ch11.xhtml#ch11fig2)展示了这个过程的详细情况。
- en: '![image](../images/f11-02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-02.jpg)'
- en: '*Figure 11-2: The anonymous Diffie–Hellman protocol*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：匿名Diffie–Hellman协议*'
- en: As you can see, Alice uses her exponent *a* and the group basis *g* to compute
    *A* = *g*^(*a*), which she sends to Bob. Bob receives *A* and computes *A*^(*b*),
    which is equal to (*g*^(*a*))^(*b*). Bob now obtains the value *g*^(*ab*) and
    computes *B* from his random exponent *b* and the value *g*. He then sends *B*
    to Alice and she uses it to compute *g*^(*ab*). Alice and Bob end up with the
    same value, *g*^(*ab*), after performing similar operations, which involve raising
    both *g* and the value received to their private exponent’s power. Pure, simple,
    but only secure against the laziest of attackers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Alice使用她的指数*a*和群体基数*g*计算*A* = *g*^(*a*)，并将其发送给Bob。Bob收到*A*后计算*A*^(*b*)，这等于(*g*^(*a*))^(*b*)。Bob现在获得了值*g*^(*ab*)，并通过他的随机指数*b*和基数*g*计算出*B*。然后，他将*B*发送给Alice，Alice利用它计算*g*^(*ab*)。经过类似的操作，Alice和Bob最终得到相同的值*g*^(*ab*)，这涉及将*g*和接收到的值分别升到各自私有指数的幂次。简单纯粹，但仅对最懒惰的攻击者有效。
- en: Anonymous DH can be taken down with a man-in-the-middle attack. An eavesdropper
    simply needs to intercept messages and pretend to be Bob (to Alice) and pretend
    to be Alice (to Bob), as shown in [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名DH协议可以通过中间人攻击被破解。窃听者只需要拦截消息并伪装成Bob（对Alice）或伪装成Alice（对Bob），如[图11-3](ch11.xhtml#ch11fig3)所示。
- en: '![image](../images/f11-03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f11-03.jpg)'
- en: '*Figure 11-3: A man-in-the-middle attack on the anonymous Diffie–Hellman protocol*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：中间人攻击在匿名Diffie–Hellman协议中的应用*'
- en: As in the previous exchange, Alice and Bob pick random exponents, *a* and *b*.
    Alice now computes and sends *A*, but Eve intercepts and drops the message. Eve
    then picks a random exponent, *c*, and computes *C* = *g*^(*c*) to send to Bob.
    Because this protocol has no authentication, Bob believes he is receiving *C*
    from Alice and goes on to compute *g*^(*bc*). Bob then computes *B* and sends
    that value to Alice, but Eve intercepts and drops the message again. Eve now computes
    *g*^(*bc*), picks a new exponent, *d*, computes *g*^(*ad*), computes *D* from
    *g*^(*d*), and sends *D* to Alice. Alice then computes *g*^(*ad*) as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的交换相似，Alice和Bob各自选择随机指数*a*和*b*。Alice现在计算并发送*A*，但Eve拦截并丢弃了消息。Eve接着选择一个随机指数*c*，并计算*C*
    = *g*^(*c*)，发送给Bob。由于这个协议没有认证，Bob认为他收到了Alice的*C*并继续计算*g*^(*bc*)。然后，Bob计算出*B*并将该值发送给Alice，但Eve再次拦截并丢弃了消息。Eve现在计算*g*^(*bc*)，选择一个新的指数*d*，计算*g*^(*ad*)，通过*g*^(*d*)计算出*D*，并将*D*发送给Alice。Alice随后也计算出*g*^(*ad*)。
- en: As a result of this attack, the attacker Eve ends up sharing a secret with Alice
    (*g*^(*ad*)) and another secret with Bob (*g*^(*bc*)), though Alice and Bob believe
    that they’re sharing a single secret with each other. After completing the protocol
    execution, Alice will derive symmetric keys from *g*^(*ad*) in order to encrypt
    data sent to Bob, but Eve will intercept the encrypted messages, decrypt them,
    and re-encrypt them to Bob using another set of keys derived from *g*^(*bc*)—after
    potentially modifying the cleartext. All of this happens with Alice and Bob unaware.
    That is, they’re doomed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To foil this attack, you need a way to authenticate the parties so that Alice
    can prove that she’s the real Alice and Bob can prove that he’s the real Bob.
    Fortunately, there is a way to do so.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '*Authenticated Diffie–Hellman*'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Authenticated Diffie–Hellman* was developed to address the sort of man-in-the-middle
    attacks that can affect anonymous DH. Authenticated DH equips the two parties
    with both a private and a public key, thereby allowing Alice and Bob to sign their
    messages in order to stop Eve from sending messages on their behalf. Here, the
    signatures aren’t computed with a DH function, but a public-key signature scheme
    such as RSA-PSS. As a result, in order to successfully send messages on behalf
    of Alice, an attacker would need to forge a valid signature, which is impossible
    with a secure signature scheme.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-4](ch11.xhtml#ch11fig4) shows how authenticated DH works.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f11-04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: The authenticated Diffie–Hellman protocol*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The **Alice** (*priv*[*A*], *pub*[*B*]) label on the first line means that Alice
    holds her own private key, *priv*[*A*], as well as Bob’s public key, *pub*[*B*].
    This sort of *priv*/*pub* key pair is called a *long-term key* because it’s fixed
    in advance and remains constant through consecutive runs of the protocol. Of course,
    these long-term private keys should be kept secret, while the public keys are
    considered to be known to an attacker.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob begin by picking random exponents, *a* and *b*, as in anonymous
    DH. Alice then calculates *A* and a signature *sig*[*A*] based on a combination
    of her signing function **sign**, her private key *priv*[*A*], and *A*. Now Alice
    sends *A* and *sig*[*A*] to Bob, who verifies *sig*[*A*] with her public key *pub*[*A*].
    If the signature is invalid, Bob knows that the message didn’t come from Alice,
    and he discards *A*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: If the signature is correct, Bob will compute *g*^(*ab*) from *A* and his random
    exponent *b*. He would then compute *B* and his own signature from a combination
    of the **sign** function, his private key *priv*[*B*], and *B*. Now he sends *B*
    and *sig*[*B*] to Alice, who attempts to verify *sig*[*B*] with Bob’s public key
    *pub*[*B*]. Alice will only compute *g*^(*ab*) if Bob’s signature is successfully
    verified.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Security Against Eavesdroppers
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Authenticated DH is secure against eavesdroppers because attackers can’t learn
    any bit of information on the shared secret *g*^(*ab*) since they ignore the DH
    exponents. Authenticated DH also provides forward secrecy: even if an attacker
    corrupts any of the parties at some point, as in the *breach* attack model discussed
    earlier, they would learn the private signing keys but not any of the ephemeral
    DH exponents; hence, they’d be unable to learn the value of any previously shared
    secrets.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Authenticated DH also prevents any party from controlling the value of the shared
    secret. Alice can’t craft a special value of *a* in order to predict the value
    of *g*^(*ab*) because she doesn’t control *b*, which influences *g*^(*ab*) as
    much as *a* does. (One exception would be if Alice were to choose *a* = 0, in
    which case we’d have *g*^(*ab*) = 1 for any *b*. But 0 isn’t an authorized value
    and should be rejected by the protocol.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: That said, authenticated DH isn’t secure against all types of attack. For one
    thing, Eve can record previous values of *A* and *sig*[*A*] and replay them later
    to Bob, in order to pretend to be Alice. Bob will then believe that he’s sharing
    a secret with Alice when he isn’t, even though Eve would not be able to learn
    that secret. This risk is eliminated in practice by adding a procedure called
    *key confirmation*, wherein Alice and Bob prove to each other that they own the
    shared secret. For example, Alice and Bob may perform key confirmation by sending
    respectively **Hash**(*pub*[*A*] || *pub*[*B*], *g*^(*ab*)) and **Hash**(*pub*[*B*]
    || *pub*[*A*], *g*^(*ab*)) for some hash function **Hash**; when Bob receives
    **Hash**(*pub*[*A*] || *pub*[*B*], *g*^(*ab*)) and Alice receives **Hash**(*pub*[*B*]
    || *pub*[*A*], *g*^(*ab*)), both can verify the correctness of these hash values
    using *pub*[*A*], *pub*[*B*], and *g*^(*ab*). The different order of public keys
    (*pub*[*A*] || *pub*[*B*] and *pub*[*B*] || *pub*[*A*]) ensures that Alice and
    Bob will send different values, and that an attacker can’t pretend to be Alice
    by copying Bob’s hash value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Security Against Data Leaks
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Authenticated DH’s vulnerability to data leak attackers is of greater concern.
    In this type of attack, the attacker learns the value of ephemeral, short-term
    secrets (namely, the exponents *a* and *b*) and uses that information to impersonate
    one of the communicating parties. If Eve is able to learn the value of an exponent
    *a* along with the matching values of *A* and *sig*[*A*] sent to Bob, she could
    initiate a new execution of the protocol and impersonate Alice, as shown in [Figure
    11-5](ch11.xhtml#ch11fig5).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f11-05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: An impersonation attack on the authenticated Diffie–Hellman protocol*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In this attack scenario, Eve learns the value of an *a* and replays the corresponding
    *A* and its signature *sig*[*A*], pretending to be Alice. Bob verifies the signature
    and computes *g*^(*ab*) from *A* and sends *B* and *sig*[*B*], which Eve then
    uses to compute *g*^(*ab*), using the stolen *a*. This results in the two having
    a shared secret. Bob now believes he is talking to Alice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: One way to make authenticated DH secure against the leak of ephemeral secrets
    is to integrate the long-term keys into the shared secret computation so that
    the shared secret can’t be determined without knowing the long-term secret.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '*Menezes–Qu–Vanstone (MQV)*'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Menezes–Qu–Vanstone (MQV)* protocol is a milestone in the history of DH-based
    protocols. Designed in 1998, MQV had been approved to protect most critical assets
    when the NSA included it in its Suite B, a portfolio of algorithms designed to
    protect classified information. (NSA eventually dropped MQV, allegedly because
    it wasn’t used. I’ll discuss the reasons why in a bit.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: MQV is Diffie–Hellman on steroids. It’s more secure than authenticated DH, and
    it improves on authenticated DH’s performance properties. In particular, MQV allows
    users to send only two messages, independently of each other, in arbitrary order.
    Other benefits are that users can send shorter messages than they would be able
    to with authenticated DH, and they don’t need to send explicit signature or verification
    messages. In other words, you don’t need to use a signature scheme in addition
    to the Diffie–Hellman function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'As with authenticated DH, in MQV Alice and Bob each hold a long-term private
    key as well as the long-term public key of the other party. The difference is
    that the MQV keys aren’t signing keys: the keys used in MQV are composed of a
    private exponent, *x*, and a public value, *g*^(*x*). [Figure 11-6](ch11.xhtml#ch11fig6)
    shows the operation of the MQV protocol.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f11-06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: The MQV protocol*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The *x* and *y* in [Figure 11-6](ch11.xhtml#ch11fig6) are Alice and Bob’s respective
    long-term private keys, and *X* and *Y* are their public keys. Bob and Alice start
    out with their own private keys and each other’s public keys, which are *g* to
    the power of a private key. Each chooses a random exponent, and then Alice calculates
    *A* and sends it to Bob. Bob then calculates *B* and sends it to Alice. Once Alice
    gets Bob’s ephemeral public key *B*, she combines it with her long-term private
    key *x*, her ephemeral private key *a*, and Bob’s long-term public key *Y* by
    calculating the result of (*B* × *Y*^(*B*))^((*a* + *xA*)), as defined in [Figure
    11-6](ch11.xhtml#ch11fig6). Developing this expression, we obtain the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: (*B* × *Y^B*)^((*a* + *xA*)) = (*g^b* × (*g^y*)^(*B*))^((*a* + *xA*)) = (*g*^(*b*
    + *yB*))^((*a* + *xA*)) = *g*^((*b* + *yB*)(*a* + *xA*))
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, Bob calculates the result of (*A* × *X*^(*A*))^((*b* + *yB*)), and
    we can verify that it’s equal to the value calculated by Alice:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: (*A* × *X^A*)^((*b* + *yB*)) = (*g^a* × (*g^x*)^(*A*))^((*b* + *yB*)) = (*g*^(*a*
    + *xA*))^((*b* + *yB*)) = *g*^((*a* + *xA*)(*b* + *yB*)) = *g*^((*b* + *yB*)(*a*
    + *xA*))
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (*A* × *X^A*)^((*b* + *yB*)) = (*g^a* × (*g^x*)^(*A*))^((*b* + *yB*)) = (*g*^(*a*
    + *xA*))^((*b* + *yB*)) = *g*^((*a* + *xA*)(*b* + *yB*)) = *g*^((*b* + *yB*)(*a*
    + *xA*))
- en: As you can see, we get the same value for both Alice and Bob, namely *g*^((*b*
    + *yB*)(*a* + *xA*)). This tells us that Alice and Bob share the same secret.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了 Alice 和 Bob 相同的值，即 *g*^((*b* + *yB*)(*a* + *xA*)）。这告诉我们 Alice 和 Bob
    共享相同的秘密。
- en: Unlike authenticated DH, MQV can’t be broken by a mere leak of the ephemeral
    secrets. Knowledge of *a* or *b* won’t let an attacker determine the final shared
    secret because they would need the long-term private keys to compute it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证 DH 不同，MQV 不能仅通过泄露临时秘密而被攻破。知道 *a* 或 *b* 不会让攻击者确定最终的共享秘密，因为他们还需要长期私钥来计算它。
- en: What happens in the strongest attack model, the breach model, where a long-term
    key is compromised? If Eve compromises Alice’s long-term private key *x*, the
    previously established shared secrets are safe because their computation also
    involved Alice’s ephemeral private keys.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在最强的攻击模型——泄密模型下，长期密钥被破解时会发生什么？如果 Eve 破解了 Alice 的长期私钥 *x*，先前建立的共享秘密是安全的，因为它们的计算也涉及了
    Alice 的临时私钥。
- en: However, MQV doesn’t provide *perfect* forward secrecy because of the following
    attack. Say, for example, that Eve intercepts Alice’s *A* message and replaces
    it with her *A* = *g*^(*a*) for some *a* that Eve has chosen. In the meantime,
    Bob sends *B* to Alice (and Eve records *B*’s value) and computes the shared key.
    If Eve later compromises Alice’s long-term private key *x*, she can determine
    the key that Bob had computed during this session. This breaks forward secrecy,
    since Eve has now recovered the shared secret of a previous execution of the protocol.
    In practice, however, the risk can be eliminated by a key-confirmation step that
    would have Alice and Bob realize that they don’t share the same key, and they
    would therefore abort the protocol before deriving any session keys.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MQV 并不能提供 *完美*的前向保密性，因为存在以下攻击。例如，假设 Eve 拦截了 Alice 的 *A* 消息，并将其替换为她的 *A* =
    *g*^(*a*)，其中 *a* 是 Eve 选择的一个值。与此同时，Bob 向 Alice 发送 *B*（Eve 记录了 *B* 的值）并计算共享密钥。如果
    Eve 后来破解了 Alice 的长期私钥 *x*，她就可以确定 Bob 在本次会话中计算出的密钥。这破坏了前向保密性，因为 Eve 现在恢复了协议之前一次执行的共享秘密。然而，实际上，通过一个密钥确认步骤可以消除这一风险，Alice
    和 Bob 会意识到他们不共享相同的密钥，因此会在派生任何会话密钥之前中止协议。
- en: Despite its elegance and security, MQV is rarely used in practice. One reason
    is because it used to be encumbered by patents, which hampered its widespread
    adoption. Another reason is that it’s harder than it looks to get MQV right in
    practice. In fact, when weighed against its increased complexity, MQV’s security
    benefits are often perceived as low in comparison to the simpler authenticated
    DH.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 MQV 在优雅性和安全性上有优势，但在实际中却很少使用。一个原因是它曾被专利限制，这阻碍了它的广泛应用。另一个原因是，实际应用中正确实现 MQV
    比看起来要困难。事实上，与其增加的复杂性相比，MQV 的安全性好处通常被认为低于更简单的认证 DH。
- en: How Things Can Go Wrong
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误的发生方式
- en: Diffie–Hellman protocols can fail spectacularly in a variety of ways. I highlight
    some of the most common ones in the next sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie–Hellman 协议可能以多种方式惨败。我将在接下来的章节中突出一些最常见的失败方式。
- en: '*Not Hashing the Shared Secret*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*不对共享秘密进行哈希处理*'
- en: I’ve alluded to the fact that the shared secret that concludes a DH session
    exchange (*g*^(*ab*) in our examples) is taken as input to derive session keys
    but is not a key itself. And it shouldn’t be. A symmetric key should look random,
    and each bit should either be 0 or 1 with the same probability. But *g*^(*ab*)
    is not a random string; it’s a random element within some mathematical group whose
    bits may be biased toward 0 or 1\. And a random group element is different from
    a random string of bits.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾提到，结束一个 DH 会话交换的共享秘密（我们例子中的 *g*^(*ab*)）被用作输入来派生会话密钥，但它本身并不是一个密钥，而且不应该是。对称密钥应该看起来是随机的，每一位应该有相同的概率为
    0 或 1。但 *g*^(*ab*) 不是一个随机字符串；它是某个数学群内的一个随机元素，其位可能偏向 0 或 1。而随机群元素与随机的位字符串是不同的。
- en: 'Imagine, for example, that we’re working within the multiplicative group **Z**[13]^*
    = {1, 2, 3, … , 12} using *g* = 2 as a generator of the group, meaning that *g*^(*i*)
    spans all values of **Z**[13]^* for *i* in 1, 2, … 12: *g*¹ = 2, *g*² = 4, *g*³
    = 8, *g*⁴ = 13, and so on. If *g*’s exponent is random, you’ll get a random element
    of **Z**[13]^*, but the encoding of a **Z**[13]^* element as a 4-bit string won’t
    be uniformly random: not all bits will have the same probability of being a 0
    or a 1\. In **Z**[13]^*, seven values have 0 as their most significant bit (the
    numbers from 1 to 7 in the group), but only five have 1 as their most significant
    bit (from 8 to 12). That is, this bit is 0 with probability 7 / 12 ≈ 0.58, whereas,
    ideally, a random bit should be 0 with probability 0.5\. Moreover, the 4-bit sequences
    1101, 1110, and 1111 will never appear.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To avoid such biases in the session keys derived from a DH shared secret, you
    should use a cryptographic hash function such as BLAKE2 or SHA-3—or, better yet,
    a key derivation function (KDF). An example of KDF construction is HKDF, or HMAC-based
    KDF (as specified in RFC 5869), but today BLAKE2 and SHA-3 feature dedicated modes
    to behave as KDFs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '*Legacy Diffie–Hellman in TLS*'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The TLS protocol is the security behind HTTPS secure websites as well as the
    secure mail transfer protocol (SMTP). TLS takes several parameters, including
    the type of Diffie–Hellman protocol it will use, though most TLS implementations
    still support anonymous DH for legacy reasons, despite its insecurity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '*Unsafe Group Parameters*'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In January 2016, the maintainers of the OpenSSL toolkit fixed a high-severity
    vulnerability (CVE-2016-0701) that allowed an attacker to exploit unsafe Diffie–Hellman
    parameters. The root cause of the vulnerability was that OpenSSL allowed users
    to work with unsafe DH group parameters (namely, an unsafe prime *p*) instead
    of throwing an error and aborting the protocol altogether before performing any
    arithmetic operation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, OpenSSL accepted a prime number *p* whose multiplicative group
    **Z**[*p*]^* (where all DH operations happen) contained small subgroups. As you
    learned at the beginning of this chapter, the existence of small subgroups within
    a larger group in a cryptographic protocol is bad because it confines shared secrets
    to a much smaller set of possible values than if it were to use the whole group
    **Z**[*p*]^*. Worse still, an attacker can craft a DH exponent *x* that, when
    combined with the victim’s public key *g*^(*y*), will reveal information on the
    private key *y* and eventually its entirety.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the actual vulnerability is from 2016, the principle the attack used
    dates back to the 1997 paper “A Key Recovery Attack on Discrete Log-based Schemes
    Using a Prime Order Subgroup” by Lim and Lee. The fix for the vulnerability is
    simple: when accepting a prime *p* as group modulus, the protocol must check that
    *p* is a safe prime by verifying that (*p* – 1) / 2 is prime as well in order
    to ensure that the group **Z**[*p*]^* won’t have small subgroups, and that an
    attack on this vulnerability will fail.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a rundown of some things that I didn’t cover in this chapter but are
    useful to learn about.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: You can dig deeper into the DH key agreement protocols by reading a number of
    standards and official publications, including ANSI X9.42, RFC 2631 and RFC 5114,
    IEEE 1363, and NIST SP 800-56A. These serve as references to ensure interoperability,
    and to provide recommendations for group parameters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about advanced DH protocols (such as MQV and its cousins HMQV
    and OAKE, among others) and their security notions (such as unknown-key share
    attacks and group representation attacks), read the 2005 article “HMQV: A High-Performance
    Secure Diffie–Hellman Protocol” by Hugo Krawczyk (*[https://eprint.iacr.org/2005/176/](https://eprint.iacr.org/2005/176/)*)
    and the 2011 article “A New Family of Implicitly Authenticated Diffie–Hellman
    Protocols” by by Andrew C. Yao and Yunlei Zhao (*[https://eprint.iacr.org/2011/035/](https://eprint.iacr.org/2011/035/)*).
    You’ll notice in these articles that Diffie–Hellman operations are expressed differently
    than in this chapter. For example, instead of *g*^(*x*), you’ll find the shared
    secret represented as *xP*. Generally, you’ll find multiplication replaced with
    addition and exponentiation replaced with multiplication. The reason is that those
    protocols are usually not defined over groups of integers, but over *elliptic
    curves*, as discussed in [Chapter 12](ch12.xhtml#ch12).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
