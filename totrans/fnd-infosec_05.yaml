- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRYPTOGRAPHY
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Cryptography*, the science of protecting the confidentiality and integrity
    of data, is a key part of the vast set of transactions that take place over your
    devices daily. You use cryptography when you have conversations on your cell phones,
    check your email, buy things from online retailers, and file your taxes, among
    other activities. Without the ability to protect the information you send over
    such channels, your Internet-based activities would be much riskier.'
  prefs: []
  type: TYPE_NORMAL
- en: In cryptography, *encryption* is the process of transforming readable data,
    called *plaintext* or *cleartext*, into an unreadable form, called *ciphertext.
    Decryption* is the process of recovering the plaintext message from the ciphertext.
    You encrypt the plaintext or decrypt the ciphertext using a specific computational
    procedure called a *cryptographic algorithm*. You’ll explore several examples
    of these in this chapter. Cryptographic algorithms generally use a *key*, or multiple
    keys, to encrypt or decrypt the message. You can think of a key as a password
    that you can apply to the algorithm to retrieve the message.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll look at some of the earliest examples of cryptography
    and then dive into modern cryptographic practices.
  prefs: []
  type: TYPE_NORMAL
- en: The History of Cryptography
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the oldest examples of cryptography date back to ancient Greece and
    Rome. To hide information, Greeks and Romans used codes, as well as unorthodox
    methods such as tattooing information on the shaved heads of messengers and allowing
    hair to grow over it. Enough historical information about cryptography exists
    to fill an entire volume, and indeed many books have been written on the subject,
    so I’ll go over just a few highlights.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Caesar Cipher*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Caesar cipher, a classic example of ancient cryptography, is said to have
    been used by Julius Caesar. The Caesar cipher involves shifting each letter of
    the plaintext message by a certain number of spaces in the alphabet, historically
    three, as shown in [Figure 5-1](#ch5fig1). After the shift, you would write the
    letter *A* as *D*, the letter *B* as *E*, and so on. To decrypt the ciphertext,
    you would apply the same number of shifts in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: Encrypting the phrase “secret message” with the Caesar cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: We call this type of encryption a *substitution cipher*, because it substitutes
    each letter in the alphabet with a different one. A more recent variation of the
    Caesar cipher is the ROT13 cipher, which uses the same mechanism as the Caesar
    cipher but moves each letter 13 places forward in the alphabet. Moving each letter
    by 13 places makes the message convenient to decrypt, because all you have to
    do to retrieve the original is apply another round of encryption with ROT13; two
    rotations will return each letter to its original starting place in the alphabet.
    Utilities for performing ROT13 are part of the basic set of tools that ship with
    many Linux and UNIX operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cryptographic Machines*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before the advent of the modern computer, people used machines to simplify encryption
    and make more complex encryption schemes feasible. Initially, such devices were
    basic mechanical machines, but as technology progressed, they began to include
    electronics and considerably more complex systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Jefferson Disk, invented by Thomas Jefferson in 1795, is a purely mechanical
    cryptographic machine. It is composed of 36 disks, each marked with the letters
    *A* through *Z* in a circle around its rim, as shown in [Figure 5-2](#ch5fig2).[¹](notes.xhtml#ch05fn1)
  prefs: []
  type: TYPE_NORMAL
- en: Each disk represents one character in a message. The letters on each disk are
    arranged in a different order, and each disk is marked with a unique identifier
    so you can tell them apart.
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt a message, you line up the characters in a row across the set of
    disks so they spell out the message in plaintext, like in row A of [Figure 5-3](#ch5fig3).
    Then you choose a different row of characters to use as the ciphertext, as shown
    in row B.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: The Jefferson Disk, one of the earliest crypto-graphic machines*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Encrypting the message “Meeting is a go” using the Jefferson Disk*'
  prefs: []
  type: TYPE_NORMAL
- en: The key to this cipher is in the order of the disks. If the encrypting and decrypting
    devices arrange their disks in the same order, all you need to do to decrypt the
    message is rewrite the ciphertext using the disks and then look at all the rows
    until you find the plaintext message. This is, of course, merely a more complex
    version of a substitution cipher, made possible using a mechanical aid, in which
    the substitution changes with each letter.
  prefs: []
  type: TYPE_NORMAL
- en: A more intricate example of a cryptographic machine is the German-made Enigma
    machine ([Figure 5-4](#ch5fig4)).[²](notes.xhtml#ch05fn2) Created by Arthur Scherbius
    in 1923, the Enigma secured German communications during World War II.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: An Enigma machine*'
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, the Enigma resembles the Jefferson Disk. It’s based on a series
    of wheels, or rotors, each with 26 letters and 26 electrical contacts. It also
    has a keyboard for entering the plaintext message and a set of 26 characters above
    the keyboard, which light up to indicate the encrypted equivalent. When you press
    a key on the Enigma keyboard, one or more of the rotors physically rotates, changing
    the orientation of the electrical contacts between them. Current flows through
    the entire series of disks and then back through them again to the original disk,
    lighting up the scrambled version of each letter on the series of characters above
    the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: For two Enigma machines to communicate during the war, they needed to have the
    same configuration. This took a lot of work since both the rotors and the rings
    marked with the alphabet on each rotor needed to be identical and in the same
    position, and any cables plugged in needed to be set up in the same fashion. Once
    the message was encrypted, it would be sent via Morse code to the receiving end.
    When the receiver got the encrypted Morse code message, they would enter the equivalent
    characters on the keyboard, and presuming everything was set up properly, the
    decrypted character would light up.
  prefs: []
  type: TYPE_NORMAL
- en: There were several models of Enigma machine and a variety of accessories and
    add-ons you could attach to them. To add further possible variations, some models
    had a patch panel, allowing you to swap some or all the letters by plugging cables
    into different positions. On each rotor, the ring containing the letters of the
    alphabet could also be rotated independently of the electrical contacts to change
    the relationship between the character selected and the character output.
  prefs: []
  type: TYPE_NORMAL
- en: Between the inherent strengths of the device and the knowledge of the required
    configuration needed for decryption, the Enigma posed quite a difficult task for
    those attempting to break the messages generated by it. But a large portion of
    the device’s strength was in the secrecy surrounding the equipment and the configurations
    used for specific messages; this is a strategy we call *security through obscurity*
    in the security field. Once these secrets became exposed, the encrypted messages
    were no longer as secure.
  prefs: []
  type: TYPE_NORMAL
- en: In 1939, when cryptographers at Bletchley Park, a British code-breaking base
    during World War II, were given an Enigma to study, they were able to construct
    a computer called the Bombe that decoded a large portion of the Germans’ messages,
    even though they didn’t have access to the Enigma settings rotated on a daily
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: '**MORE ON THE ENIGMA MACHINE**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyone interested in getting hands-on experience with a classic item of cryptographic
    history can interact with the Enigma in several ways. The DIY inclined can purchase
    a kit that re-creates the functionality of the Enigma using modern electronics
    components.[³](notes.xhtml#ch05fn3) Additionally, a variety of software-based
    Enigma simulators exist.[⁴](notes.xhtml#ch05fn4) These are particularly useful
    for representing the relationship between the rotors and the paths running through
    them, which change with each character entered. A great many books have also been
    written on this topic, but a particularly good one is *The German Enigma Cipher
    Machine: Beginnings, Success, and Ultimate Failure* by Brian J. Winkel, Cipher
    Deavours, David Kahn, and Louis Kruh. *Seizing the Enigma: The Race to Break the
    German U-Boat Codes, 1933–1945* by David Kahn is another excellent source for
    further detail on some of this work.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kerckhoffs’s Principles*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 1883, the *Journal des Sciences Militaires* published an article by Auguste
    Kerckhoffs, a Dutch linguist and cryptographer, titled “La cryptographie militaire.”
    In the article, Kerckhoffs outlined six principles he thought should serve as
    a basis for all cryptographic systems.[⁵](notes.xhtml#ch05fn5)
  prefs: []
  type: TYPE_NORMAL
- en: The system must be substantially, if not mathematically, undecipherable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system must not require secrecy; even if stolen by the enemy, the system
    should remain secure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The keys must be easy to communicate and remember without written notes, and
    they must be easy to change or modify to use with different participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system ought to be compatible with communication via telegraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system must be portable, and its use must not require more than one person.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the system must be easy to use, requiring neither complex thinking
    nor the knowledge of a long series of rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although several of these principles, such as requiring the system to support
    telegraph use or be physically portable, became outmoded once people started using
    computers for cryptography, the second principle remains a key tenet of modern
    cryptographic algorithms. Claude Shannon, an American mathematician and cryptographer,
    later restated the idea as “the enemy knows the system”;[⁶](notes.xhtml#ch05fn6)
    in other words, cryptographic algorithms should be robust enough that even if
    people know every bit of the encryption process except for the key itself, they
    should still not be able to break the encryption. This idea represents the opposite
    approach to security through obscurity.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Cryptographic Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although efficient electromechanical cryptographic systems like Enigma enabled
    highly secure means of communication for a period, the increasing complexity of
    computers quickly rendered these systems obsolete. One reason was that the systems
    were not completely compliant with Kerckhoffs’s second principle and still largely
    depended on security through obscurity to protect the data they processed.
  prefs: []
  type: TYPE_NORMAL
- en: Modern cryptographic algorithms used by computers are truly open, meaning you
    can understand the encryption process and still not be able to break the cipher.
    These algorithms depend on difficult mathematical problems, sometimes referred
    to as *one-way problems*. One-way problems are easy to perform in one direction
    but difficult to perform in the other direction. Factorization of large numbers
    is an example of a one-way problem; it’s easy to create an algorithm that returns
    a product of multiple integers, but it’s much more difficult to create one that
    does the inverse of that operation—finding the factors of a given integer—especially
    if that number is very large. Such problems form the basis of many modern cryptographic
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: '*Keyword Ciphers and One-Time Pads*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two technologies, keyword ciphers and one-time pads, helped bridge the gap between
    older cryptographic methods and modern ones. Although simpler than the algorithms
    used today, these techniques increasingly met the standard set by Kerckhoffs’s
    second principle.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Ciphers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Keyword ciphers* are substitution ciphers, like the Caesar cipher discussed
    earlier in the chapter. But, unlike the Caesar cipher, they use a key to determine
    what to substitute for each letter of the message. Rather than shifting all letters
    by the same number of spaces in the alphabet, you’d shift each letter to match
    the corresponding letter in the keyword. For example, if you use the keyword MYSECRET,
    you’d have the substitution shown in [Figure 5-5](#ch5fig5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: Encryption using a keyword cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: The letter *A* turns into the letter *M*, which is the first letter in the key;
    the letter *B* turns into the letter *Y*, which is the second letter in the key.
    You continue like this, removing any repeating letters in the key—notice the second
    *E* in SECRET is missing—and once the keyword ends, you assign the rest of the
    characters are in alphabetical order, minus any letter used in the key. If you
    started with the plaintext THE QUICK BROWN FOX, you’d get the ciphertext PAC LQBSF
    YNJVI RJW.
  prefs: []
  type: TYPE_NORMAL
- en: Ciphers such as this one have weaknesses. Like all the other historical ciphers
    we’ve discussed, they’re vulnerable to *frequency analysis*, which means you can
    make guesses about what the message contents might be based on the frequency of
    characters used, where those characters appear in words, and when they’re repeated.
    For example, the letter *E* is the most commonly used letter in the English alphabet,
    so you could assume that the most frequent letter in the substitution might be
    an *E*, as well, and work from there to decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this flaw, cryptographers invented the one-time pad.
  prefs: []
  type: TYPE_NORMAL
- en: One-Time Pads
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *one-time pad*, also known as the Vernam cipher, is an unbreakable cipher
    when used properly. To use it, you create two copies of the same pad of paper
    containing a completely random set of numbers, known as *shifts*, and give one
    copy to each party. These pads are the key. To encrypt the message, you use the
    shifts to move each letter of the message forward. Like with the keyword cipher,
    if the first number on the pad were 4, you’d shift the first letter of your message
    by 4 spots, and if the second number were 6, you’d shift the second letter of
    the message by 6 spots. [Figure 5-6](#ch5fig6) shows an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: Encryption using a one-time pad*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you’d send the message ATTACKATDAWN as EYGBPMOMJXEP. The receiving
    party would consult their one-time pad and then perform the relative shifts backward
    to decrypt the message.
  prefs: []
  type: TYPE_NORMAL
- en: The encrypted text could generate an infinite number of possible plaintext messages.
    In the case of the Caesar cipher, where you shift the entire message by the same
    number of characters, there are only 26 possible combinations. *Brute forcing*,
    or testing every possible key to retrieve the original message, takes little time,
    and you’ll likely have no trouble recognizing the correct message when you’ve
    succeeded. But since the one-time pad uses a different shift for each letter,
    the message could contain any combination of letters or words that fits the message
    length. From the previous example, you could just as easily decrypt the incorrect
    messages ATTACKATNOON or NODONTATTACK.
  prefs: []
  type: TYPE_NORMAL
- en: The one-time pad is a primitive version of a stream cipher, which we’ll come
    back to shortly. You can use it with more complex pads and mathematical operations,
    and modern methods of encryption and key exchange use some of these same concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '*Symmetric and Asymmetric Cryptography*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Today, we can separate most cryptographic algorithms into two types: symmetric
    and asymmetric. In this section, I will discuss each type, as well as a few specific
    examples of each.'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Cryptography
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Also known as private key cryptography, *symmetric key cryptography* uses a
    single key to both encrypt the plaintext and decrypt the ciphertext. Technically,
    the ciphers we’ve explored so far in this chapter use symmetric keys; to decode
    the Caesar cipher, for example, you would apply the same key to the message as
    the one used to encrypt it. That means you must share the key between the sender
    and the receiver. This process, known as *key exchange*, constitutes an entire
    subtopic of cryptography. I’ll discuss key exchange at greater length later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that you must share a single key among all users of the system is one
    of the chief weaknesses of symmetric key cryptography. If attackers gain access
    to the key, they could decrypt the message—or, worse yet, decrypt it, alter it,
    and then encrypt it once more and pass it on to the receiver in place of the original
    message (a tactic called a *man-in-the-middle attack*).
  prefs: []
  type: TYPE_NORMAL
- en: Block vs. Stream Ciphers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Symmetric key cryptography in the digital age makes use of two types of ciphers:
    block ciphers and stream ciphers. A *block cipher* takes a predetermined number
    of bits (or binary digits, which are either a 1 or a 0), known as a *block*, and
    encrypts that block. Blocks typically have 64 bits, but they can be larger or
    smaller depending on the algorithm used and the various modes the algorithm can
    operate in. A *stream cipher* encrypts each bit in the plaintext message one bit
    at a time. You can make a block cipher act as a stream cipher by setting the block
    size to one bit.'
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the encryption algorithms currently in use are block ciphers.
    Although block ciphers are often slower than stream ciphers, they tend to be more
    versatile. Since block ciphers operate on larger blocks of the message at a time,
    they’re usually more resource intensive and more complex to implement. They’re
    also more susceptible to errors in the encryption process. For example, an error
    in block cipher encryption would render a large segment of data unusable, whereas
    in a stream cipher, an error would corrupt only a single bit. You can generally
    use specific block modes to detect and compensate for such errors. A *block mode*
    defines the specific processes and operations that the cipher uses. You’ll learn
    more about these modes in the next section when I discuss the algorithms that
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, block ciphers work better with messages whose sizes are fixed or
    known in advance, such as files, or messages whose sizes are reported in protocol
    headers. It’s generally better to use stream ciphers when encrypting data of an
    unknown size or data in a continuous stream, such as information moving over a
    network, where the kind of data being sent and received is variable.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Key Algorithms
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some of the most well-known cryptographic algorithms are symmetric key algorithms.
    The US government has used several of these, such as DES, 3DES, and AES, as standard
    algorithms for protecting highly sensitive data. I’ll discuss these three examples
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '*DES* is a block cipher that uses a 56-bit key (meaning the key used by its
    cryptographic algorithm is 56 bits long). As you saw when discussing keyword ciphers,
    the length of the key determines the strength of the algorithm, because the longer
    the key is, the more possible keys there are. For example, an 8-bit key has a
    keyspace (range of possible keys) of 2⁸. DES has a keyspace of 2^(56)—that’s 72057594037927936
    possible keys attackers must test.'
  prefs: []
  type: TYPE_NORMAL
- en: DES first came into use in 1976 in the United States and has since spread globally.
    People considered it very secure until 1999, when a distributed computing project
    attempted to break a DES key by testing every possible key in the entire keyspace.
    They succeeded in a little more than 22 hours. It turned out the keyspace was
    too short; to compensate for this, cryptographers began using *3DES* (pronounced
    “triple DES”), which is simply DES used to encrypt each block three times, with
    three different keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the US government replaced DES with *AES*, a set of symmetric block
    ciphers. AES uses three different ciphers: one with a 128-bit key, one with a
    192-bit key, and one with a 256-bit key, all of which encrypt blocks of 128 bits.
    Briefly, there are a few key differences between AES and 3DES.'
  prefs: []
  type: TYPE_NORMAL
- en: 3DES is three rounds of DES, while AES uses a newer and completely different
    algorithm developed in 2000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AES uses longer and stronger keys than 3DES, as well as a longer block length,
    making AES harder to attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3DES is slower than AES.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hackers have attempted a variety of attacks against AES, most of them against
    the encryption using the 128-bit key. Most of these have either failed or had
    only partial success. At the time of this writing, the US government still considers
    AES to be secure.
  prefs: []
  type: TYPE_NORMAL
- en: Other well-known symmetric block ciphers include Twofish, Serpent, Blowfish,
    CAST5, RC6, and IDEA. Popular stream ciphers include RC4, ORYX, and SEAL.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Cryptography
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Martin Hellman and Whitfield Diffie first described asymmetric cryptography
    in their 1976 paper, “New Directions in Cryptography.”[⁷](notes.xhtml#ch05fn7)
    While symmetric key cryptography makes use of only one key, *asymmetric key cryptography*,
    also known as public key cryptography, uses two keys: a public key and a private
    key. You use the public key to encrypt data, and anyone can access the public
    key. You can see them included in email signatures or posted on servers that exist
    specifically to host public keys. Private keys, used to decrypt messages, are
    carefully guarded by the receiver. Cryptographers use complex mathematical operations
    to create the private and public keys. These operations—which typically involve
    factorizing very large prime numbers, as I discussed earlier in the chapter—are
    difficult enough that, currently, no method exists to discover the private key
    by using the public key.'
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of asymmetric key cryptography over symmetric key cryptography
    is that you no longer need to distribute the key. In symmetric key cryptography,
    as discussed, the message sender needs to find a way of sharing the key with whomever
    they want to communicate with. They might do this by exchanging keys in person,
    sending a key in an email, or repeating it verbally over the phone, but the method
    must be secure enough to ensure the key isn’t intercepted. But with asymmetric
    key cryptography, you don’t have to share a secret key. You simply make your public
    key available, and anyone who needs to send you an encrypted message can use it
    without compromising the security of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Key Algorithms
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *RSA* algorithm, named after the initials of its creators, Ron Rivest, Adi
    Shamir, and Leonard Adleman, is an asymmetric algorithm used across the world,
    including in the Secure Sockets Layer (SSL) protocol. (*Protocols* are the rules
    that define communication between devices. SSL secures many common transactions,
    such as web and email traffic.) Created in 1977, RSA is still one of the most
    widely used algorithms in the world to this day.
  prefs: []
  type: TYPE_NORMAL
- en: '*Elliptic curve cryptography (ECC)* is a class of cryptographic algorithms,
    although people sometimes refer to it as though it were a single algorithm. Named
    for the type of mathematical problem on which its cryptographic functions are
    based, elliptic curve cryptography has several advantages over other types of
    algorithms.'
  prefs: []
  type: TYPE_NORMAL
- en: ECC can use short keys while maintaining a higher cryptographic strength than
    many other types of algorithms. It’s also a fast and efficient type of algorithm
    that allows us to easily implement it on hardware that has less processing power
    and memory, such as a cell phone or portable device. A variety of cryptographic
    algorithms, including the Secure Hash Algorithm 2 (SHA-2) and Elliptic Curve Digital
    Signature Algorithm (ECDSA), use ECC.
  prefs: []
  type: TYPE_NORMAL
- en: Other asymmetric algorithms include ElGamal, Diffie–Hellman, and Digital Signature
    Standard (DSS). Many protocols and applications are based on asymmetric cryptography,
    including Pretty Good Privacy (PGP) for securing messages and files, SSL and Transport
    Layer Security (TLS) for common internet traffic, and some voice over IP (VoIP)
    protocols for voice conversations.
  prefs: []
  type: TYPE_NORMAL
- en: '**PGP**'
  prefs: []
  type: TYPE_NORMAL
- en: PGP, created by Phil Zimmerman, was one of the first strong encryption tools
    to reach the eye of the public and the media. Created in the early 1990s, the
    original release of PGP was based on a symmetric algorithm, and you could use
    it to secure data such as communications and files. The original version of PGP
    was given away as free software, including the source code. At the time of its
    release, PGP was regulated as munitions under the US International Traffic in
    Arms Regulations (ITAR) law. Zimmerman spent several years under investigation
    for criminal activities when he was suspected of exporting PGP out of the country,
    which was illegal at the time and considered to be arms trafficking.
  prefs: []
  type: TYPE_NORMAL
- en: '*Hash Functions*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Hash functions* represent a third type of modern cryptography, which we call
    keyless cryptography. Instead of using a key, hash functions, or message digests,
    convert the plaintext into a largely unique and fixed-length value, commonly referred
    to as a *hash*. You can think of these hash values as fingerprints because they’re
    unique identifiers of a message. Moreover, hashes of similar messages look completely
    different. [Figure 5-7](#ch5fig7) shows some hashes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A hash function generates a unique value for every message, no
    matter how similar the messages are.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the message we’re hashing in B differs from message A by only a
    single word, but it produces a completely different hash. The same is true for
    message C, which removes only a single space from the original message but still
    generates a unique hash. You can’t use hashes to discover the contents of the
    original message, or any of its other characteristics, but you can use it to determine
    whether the message has changed. This means that if you’re distributing files
    or sending communications, you can send the hash with the message so that the
    receiver can verify its integrity. To do this, the receiver simply hashes the
    message again using the same algorithm and then compares the two hashes. If the
    hashes match, the message has not changed. If they don’t match, the message has
    been altered.
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s theoretically possible to engineer a matching hash for two different
    sets of data, called a *collision*, this is difficult and generally happens only
    if you’re using a broken hashing algorithm. Some algorithms, such as Message-Digest
    algorithm 5 (MD5) and Secure Hash Algorithm 1 (SHA-1), have been attacked in this
    fashion, although it’s uncommon ([Figure 5-8](#ch5fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: In a hash collision, two distinct messages produce the same hash.*'
  prefs: []
  type: TYPE_NORMAL
- en: When collisions occur, you generally stop using the compromised algorithm. Those
    who require stringent hash security have mostly stopped using MD5 and replaced
    it with SHA-2 and SHA-3.
  prefs: []
  type: TYPE_NORMAL
- en: Other hash algorithms include MD2, MD4, and RACE.
  prefs: []
  type: TYPE_NORMAL
- en: '*Digital Signatures*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to use asymmetric algorithms and their associated public and private
    keys is to create digital signatures. A *digital signature* allows you to sign
    a message so that others can detect any changes to the message after you’ve sent
    it, ensure that the message was legitimately sent by the expected party, and prevent
    the sender from denying that they sent the message (a principle known as *nonrepudiation*,
    covered in [Chapter 4](ch04.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: To digitally sign a message, the sender generates a hash of the message and
    then uses their private key to encrypt the hash. The sender then sends this digital
    signature along with the message, usually by appending it to the message itself.
  prefs: []
  type: TYPE_NORMAL
- en: When the message arrives at the receiving end, the receiver uses the public
    key corresponding to the sender’s private key to decrypt the digital signature,
    thus restoring the original hash of the message. The receiver can then verify
    the message’s integrity by hashing the message again and comparing the two hashes.
    This may sound like a considerable amount of work just to verify the integrity
    of the message, but software applications usually do it for you, so the process
    is typically invisible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '*Certificates*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to hashes and digital signatures, you can use digital certificates
    to sign your messages. *Digital certificates*, as shown in [Figure 5-9](#ch5fig9),
    link a public key to an individual by validating that the key belongs to the proper
    owner, and they’re often used as a form of electronic identification for that
    person.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: A digital certificate*'
  prefs: []
  type: TYPE_NORMAL
- en: You typically create a certificate by taking the public key and identifying
    information, such as a name and address, and having them signed by a trusted entity
    that handles digital certificates, called a *certificate authority*. A certificate
    authority is the entity that issues certificates. It acts as a trusted third party
    to both sides of transactions that involve certificates by signing the certificate
    to begin with and later verifying that it is still valid. One well-known certificate
    authority is VeriSign. Some large organizations, such as the US Department of
    Defense, may choose to implement their own certificate authority to keep costs
    down.
  prefs: []
  type: TYPE_NORMAL
- en: A certificate allows you to verify that a public key is truly associated with
    an individual. In the case of the digital signature discussed in the preceding
    section, someone might have falsified the keys used to sign the message; maybe
    those keys did not actually belong to the original sender. If the sender had a
    digital certificate, you could easily check with the certificate authority to
    ensure that the public key for the sender is legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A certificate authority is only a small part of the infrastructure that you
    can put in place to handle certificates on a large scale. This infrastructure
    is known as a *public key infrastructure (PKI)*. A PKI usually has two main components:
    the certificate authorities that issue and verify certificates, and the registration
    authorities that verify the identity of the individual associated with the certificate,
    although some organizations may separate some functions out into more than just
    these.'
  prefs: []
  type: TYPE_NORMAL
- en: A PKI might also revoke certificates if they reach their expiration date, are
    compromised, or shouldn’t be used for some other reason. In this case, the certificate
    will likely be added to a certificate revocation list, which is generally a public
    list that holds all an organization’s revoked certificates for a time.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Data at Rest, in Motion, and in Use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can divide the practical uses of cryptography into three major categories:
    protecting data at rest, protecting data in motion, and protecting data in use.
    Data at rest includes the large amount of stored data on devices such as backup
    tapes, flash drives, and hard drives in portable devices such as laptops. Data
    in motion is the enormous amount of information sent over the internet, including
    financial transactions, medical information, tax filings, and other similarly
    sensitive exchanges. Data in use is data actively being accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Protecting Data at Rest*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: People often neglect to protect *data at rest*, which is data on a storage device
    of some kind that isn’t moving over a network, through a protocol, or across some
    other communication platform.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhat illogically, data at rest can also, technically, be in motion. For
    example, you might ship a load of backup tapes containing sensitive data, carry
    a flash drive containing a copy of your tax forms in your pocket, or leave a laptop
    containing the contents of a customer database in the back seat of your car.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers exploit this fact on a regular basis. For example, in 2017, someone
    found a USB flash drive in the street outside Heathrow Airport in London and discovered
    it contained information about the routes and security measures used to protect
    Queen Elizabeth II, as well as other high-ranking officials and dignitaries, when
    they move through the airport.[⁸](notes.xhtml#ch05fn8)
  prefs: []
  type: TYPE_NORMAL
- en: Had necessary steps been taken to protect the flash drive’s data at rest by
    encrypting it, the security incident would not have occurred (and authorities
    would not have had to publicly disclose that the incident had occurred, saving
    them from quite a bit of embarrassment).
  prefs: []
  type: TYPE_NORMAL
- en: Data Security
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We primarily use encryption to protect data at rest, particularly when we know
    that the device containing the data could be physically stolen.
  prefs: []
  type: TYPE_NORMAL
- en: An enormous number of commercial products provide encryption for portable devices.
    These often target hard drives and portable storage devices, including products
    from large companies such as Intel and Symantec, to name a few. These commercial
    products often encrypt entire hard disks (a process known as *full disk encryption*)
    and a variety of removable media, and they report back to centralized management
    servers or other security and administrative features. There are also several
    free or open source encryption products on the market, such as VeraCrypt,[⁹](notes.xhtml#ch05fn9)
    BitLocker[^(10)](notes.xhtml#ch05fn10) (which ships with some versions of Windows),
    and dm-crypt[^(11)](notes.xhtml#ch05fn11) (which is specific to Linux).
  prefs: []
  type: TYPE_NORMAL
- en: Physical Security
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Physical security, which I’ll discuss at length in [Chapter 9](ch09.xhtml),
    is an important part of protecting data at rest. If you make it more difficult
    for attackers to physically access or steal the storage media that contains sensitive
    data, you have solved a large portion of your problem.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, large businesses have databases, file servers, and workstations
    that contain customer information, sales forecasts, business strategy documents,
    network diagrams, and other kinds of data they want to keep from becoming public
    or falling into the hands of their competitors. If the physical security at the
    building that houses the data is weak, an attacker might be able to simply enter
    the building, steal a device, and walk right out with the data.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to be aware of the areas you cannot physically protect and limit
    the data that leaves your protected spaces. In an office building, you could apply
    extra layers of physical security to the data center containing your servers,
    for example. Once sensitive data leaves such areas, your ability to protect it
    becomes more limited. In the case of the Heathrow flash drive that I discussed
    earlier, officials might have kept this sensitive data from being copied to an
    external drive to prevent it from walking out the door and being lost in the street.
  prefs: []
  type: TYPE_NORMAL
- en: '*Protecting Data in Motion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often, data travels over networks, whether it be a closed wide area network
    (WAN) or local area network (LAN), a wireless network, or the internet. To protect
    data exposed on a network, you will usually choose to either encrypt the data
    itself or encrypt the entire connection.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the Data Itself
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can take a variety of approaches to encrypting the data you are sending
    over the network, depending on the kind of data you are sending and the protocols
    over which you are sending it.
  prefs: []
  type: TYPE_NORMAL
- en: You will often use SSL and TLS to encrypt a connection between two systems communicating
    over a network. SSL is TLS’s predecessor, although the terms are often used interchangeably,
    and they are nearly identical. SSL and TLS operate in conjunction with other protocols,
    such as Internet Message Access Protocol (IMAP) and Post Office Protocol (POP)
    for email, Hypertext Transfer Protocol (HTTP) for web traffic, and VoIP for voice
    conversations and instant messaging.
  prefs: []
  type: TYPE_NORMAL
- en: However, SSL and TLS protections generally apply to only a single application
    or protocol, so although you might be using them to encrypt your communications
    with the server that holds your email, this doesn’t necessarily mean the connections
    made through your web browser have the same level of security. Many common applications
    are capable of supporting SSL and TLS, but you generally need to configure them
    to do so independently.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the Connection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Another approach to protecting data in motion is encrypting all your network
    traffic with a virtual private network (VPN) connection. VPN connections use a
    variety of protocols to create a secure connection between two systems. You might
    use a VPN when you’re accessing data from a potentially insecure network, such
    as the wireless connection in a hotel.
  prefs: []
  type: TYPE_NORMAL
- en: The two most common protocols currently used to secure VPNs are Internet Protocol
    Security (IPsec) and SSL. You can configure these two types of VPN connections
    to have a nearly identical set of features and functionality, from the perspective
    of the user, but they require a slightly different set of hardware and software
    to set up.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an IPsec VPN requires a more complex hardware configuration on the
    back end, as well as a software client you have to install, whereas an SSL VPN
    often operates from a lightweight plug-in downloaded from a web page and a less
    complex hardware configuration on the back end. From a security standpoint, the
    two methods have relatively similar levels of encryption. One weakness of the
    SSL VPN client, however, is that you could download it to a public computer or
    other random insecure device and provide an avenue for data leakage or an attack.
  prefs: []
  type: TYPE_NORMAL
- en: '*Protecting Data in Use*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last category of data to protect is the data currently being used. Although
    we can use encryption to protect data while it’s stored or moving across a network,
    we are somewhat limited in our ability to protect data while legitimate entities
    have access to it. Authorized users can print files, move them to other machines
    or storage devices, email them, share them on peer-to-peer file-sharing networks,
    and generally make a mockery of our meticulous security measures.
  prefs: []
  type: TYPE_NORMAL
- en: In June 2013, the public discovered that a government contractor named Edward
    Snowden had deliberately leaked classified information containing details about
    the US National Security Agency PRISM program, which was ostensibly designed to
    collect and review terrorism-related communications.[^(12)](notes.xhtml#ch05fn12)
    Although this incident occurred more than five years ago at the time of this writing,
    the US intelligence community is still cleaning up after it and working to prevent
    another such incident.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cryptography has existed in one form or another for most of recorded history.
    Early cryptographic practices varied in complexity, from the simple substitution
    ciphers of the Roman era to the complex electromechanical machines used before
    the invention of modern computing systems. Although such primitive cryptographic
    methods would not protect against modern cryptographic attacks, they form the
    basis for our modern algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, you conduct cryptography by using computers to create complex algorithms
    that encrypt your data. There are three main kinds of cryptographic algorithms:
    symmetric key cryptography, asymmetric key cryptography, and hash functions. In
    symmetric key cryptography, you encrypt and decrypt data with the same key, to
    which all parties operating on the plaintext or ciphertext have access. In asymmetric
    cryptography, you use both a public and a private key. The sender encrypts the
    message with the receiver’s public key, and the receiver decrypts the message
    with their private key. This resolves the problem of having to find a secure way
    to share a single private key between the receiver and the sender. Hash functions
    don’t use a key at all; they create a (theoretically) unique fingerprint of the
    message so that we can tell if the message has been altered from its original
    form.'
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures are an extension of hash functions that allow you to not
    only create a hash to ensure that the message has not been altered but also encrypt
    the hash with the public key of an asymmetric algorithm to ensure that the message
    was sent by the expected party and to ensure nonrepudiation.
  prefs: []
  type: TYPE_NORMAL
- en: Certificates allow you to link a public key to an identity so that you can ensure
    that an encrypted message really represents a communication from a particular
    individual. The receiver can check with the issuer of the certificate—the certificate
    authority—to determine whether the certificate presented is, in fact, legitimate.
    Behind the certificate, you may find a PKI, which issues, verifies, and revokes
    certificates.
  prefs: []
  type: TYPE_NORMAL
- en: In general, cryptography provides a mechanism to protect data at rest, data
    in motion, and, to a certain extent, data in use. It provides the core of many
    of the basic security mechanisms that enable you to communicate and carry out
    transactions when the data involved is of a sensitive nature.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What type of cipher is a Caesar cipher?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a block and a stream cipher?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ECC is classified as which type of cryptographic algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the key point of Kerckhoffs’s second principle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a substitution cipher?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main differences between symmetric and asymmetric key cryptography?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how 3DES differs from DES.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does public key cryptography work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to decrypt this message using the information in this chapter: V qb abg
    srne pbzchgref. V srne gur ynpx bs gurz. —Vfnnp Nfvzbi.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is physical security important when discussing the cryptographic security
    of data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
