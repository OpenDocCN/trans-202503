- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 12 BIT MANIPULATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manipulating bits in memory is perhaps the feature for which assembly language
    is most famous. Even the C programming language, known for bit manipulation, doesn’t
    provide as complete a set of bit-manipulation operations.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to manipulate strings of bits in memory and registers
    by using ARM assembly language. It begins with a review of the bit-manipulation
    instructions covered thus far, introduces a few new instructions, then reviews
    information on packing and unpacking bit strings in memory, which is the basis
    for many bit-manipulation operations. Finally, this chapter discusses several
    bit-centric algorithms and their implementation in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 What Is Bit Data, Anyway?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bit manipulation* refers to working with *bit data*, data types consisting
    of strings of bits that are noncontiguous or are not multiples of 8 bits long.
    Generally, these bit objects will not represent numeric integers, although I will
    not place this restriction on bit strings.'
  prefs: []
  type: TYPE_NORMAL
- en: A *bit string* is a contiguous sequence of 1 or more bits. It does not have
    to start or end at any special point. For example, a bit string could start in
    bit 7 of one byte in memory and continue through to bit 6 of the next byte in
    memory. Likewise, a bit string could begin in bit 30 of W0, consume the upper
    2 bits of W0, and then continue from bit 0 through bit 17 of W1\. In memory, the
    bits must be physically contiguous (that is, bit numbers always increase except
    when crossing a byte boundary, and at byte boundaries the memory address increases
    by 1 byte). In registers, if a bit string crosses a register boundary, the application
    defines the continuation register, but the bit string always continues in bit
    0 of that second register.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit run* is a sequence of bits with all the same value. A *run of 0s* is
    a bit string that contains all 0s, and a *run of 1s* is a bit string containing
    all 1s. The *first set bit* in a bit string is the bit position of the first bit
    containing a 1 in a bit string—that is, the first 1 bit following a possible run
    of 0s. A similar definition exists for the *first clear bit*. The *last set bit*
    is the last bit position in a bit string that contains 1s; the remainder of the
    string forms an uninterrupted run of 0s. A similar definition exists for the *last
    clear bit*.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit set* is a collection of bits, not necessarily contiguous, within a larger
    data structure. For example, bits 0 to 3, 7, 12, 24, and 31 in a double word form
    a set of bits. Typically, we will deal with bit sets that are part of a *container
    object* (the data structure that encapsulates the bit set) that is no more than
    about 32 or 64 bits in size, though this limit is completely artificial. Bit strings
    are special cases of bit sets.
  prefs: []
  type: TYPE_NORMAL
- en: A *bit offset* is the number of bits from a boundary position (usually a byte
    boundary) to the specified bit. As noted in [Chapter 2](chapter2.xhtml), these
    bits are numbered starting from 0 at the boundary location.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *mask* is a sequence of bits used to manipulate certain bits in another value.
    For example, the bit string 0b0000_1111_0000, when used with the and instruction,
    masks away (clears) all bits except bits 4 through 7\. Likewise, if you use the
    same value with the orr instruction, it can set bits 4 through 7 in the destination
    operand. The term *mask* derives from the use of these bit strings with the and
    instruction, where the 1 and 0 bits behave like masking tape when you’re painting
    something: they pass through certain bits unchanged while masking out (clearing)
    the other bits.'
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these definitions, you’re ready to start manipulating some bits!
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Instructions That Manipulate Bits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin by reviewing the instructions this book has covered so far that
    manipulate bits, along with introducing a few additional bit-manipulation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bit manipulation generally consists of six activities: setting bits, clearing
    bits, inverting bits, testing and comparing bits, extracting bits from a bit string,
    and inserting bits into a bit string. The most basic bit-manipulation instructions
    are the and/ands bic, orr, orn, eor, mvn (not), tst, and shift and rotate instructions.
    This section discusses these instructions, concentrating on how to use them to
    manipulate bits in memory or registers.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### 12.2.1 Isolating, Clearing, and Testing Bits'
  prefs: []
  type: TYPE_NORMAL
- en: 'The and/ands instruction provides the ability to clear bits in a bit sequence.
    This instruction is especially useful for isolating a bit string or a bit set
    that is merged with other, unrelated data (or, at least, data that is not part
    of the bit string or bit set). For example, if a bit string consumes bit positions
    12 through 24 of the W0 register, you can isolate this bit string by using the
    following instruction to set all other bits in W0 to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-1](chapter12.xhtml#fig12-1) shows the result of this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: Isolating a bit string by using the and instruction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve cleared the unneeded bits in a set of bits, you can often operate
    on the bit set in place. For example, to see whether the string of bits in positions
    12 through 24 of W0 contains 0x2F3, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You cannot use the immediate constant 0x2F3000 with the cmp instruction, so
    this code first loads that constant into W1 and compares W0 against W1\. You also
    can’t use movz to load 0x2F3 preshifted to the left 12 bits because movz allows
    only shifts of 0, 16, 32, or 48 bits; likewise, 0x2F3 is not a logical immediate
    pattern, so you can’t use a mov instruction with 0x2F3000.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The instruction* mov w1, #logical_pattern *is equivalent to* orr w1, wzr,
    #logical_pattern*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the constants you use in conjunction with this value easier to deal
    with, you can use the lsr instruction to align the bit string with bit 0 after
    you’ve masked it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The plain and instruction does not affect any condition code flags. Use the
    ands variant if you would like to update the N and Z flags based on the result
    of the AND operation, remembering that this instruction always clears the carry
    and overflow flags.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to capture the result of the ands operation in the N and Z flags
    but don’t want to keep the logical result, you can use the tst instruction. This
    is equivalent to (and an alias of) ands supplying WZR or XZR as the destination
    register (which throws away the result).
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that you can also use the and instruction with the vector registers
    (both vector and scalar operations); just keep in mind that the vector and instruction
    doesn’t affect the flags (there is no ands variant).
  prefs: []
  type: TYPE_NORMAL
- en: Because tst is an alias of ands, and there is no vector ands instruction, the
    Neon instruction set provides this cmtst instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: where t is 8B, 16B, 4H, 8H, 2S, 4S, or 2D (8B, 4H, and 2S types operate on the
    LO 64 bits of V*n*, while the others operate on all 128 bits).
  prefs: []
  type: TYPE_NORMAL
- en: This instruction logically ANDs each lane in Vd.t with Vd.t. If the result is
    not 0, cmtst sets the destination lane to all 1s; if the result is 0, it sets
    the destination lane to all 0s. You can use the result as a bitmask for further
    vector (bit) operations.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.2 Setting and Inserting Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The orr instruction is especially useful for inserting a bit set into another
    bit string (in general-purpose or vector registers), using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Clear all the bits surrounding your bit set in the source operand.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Clear all the bits in the destination operand where you wish to insert the
    bit set.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  OR the bit set and destination operand together.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you have a value in bits 0 to 11 of W0 that you wish to
    insert into bits 12 to 23 of W1 without affecting any of the other bits in W1\.
    You would begin by stripping out bits 12 and higher from W0, then strip out bits
    12 to 23 in W1\. Next, you would shift the bits in W0 so the bit string occupied
    bits 12 to 23 of W0\. Finally, you’d OR the value in W0 into W1, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-2](chapter12.xhtml#fig12-2) shows the result of these four instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: Inserting bits 0 to 11 of W0 into bits 12 to 23 of W1'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 in [Figure 12-2](chapter12.xhtml#fig12-2) clears the U bits in W0\. After
    clearing the U bits, step 2 masks out the destination bit field (Y). Step 3 shifts
    the A bits (bits 0 to 11 in W0) 12 positions to the left to align them with the
    destination bit field. Step 4 ORs the value in W0 with the value in W1, leaving
    the final result in W1.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 12-2](chapter12.xhtml#fig12-2), the desired bits (AAAAAAAAAAAA) form
    a bit string. However, this algorithm still works fine even if you’re manipulating
    a noncontiguous set of bits—you just have to create a bitmask with 1s in the appropriate
    places.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with bitmasks, it is incredibly poor programming style to use
    literal numeric constants, as in the past few examples. I’ve used “magic numbers”
    thus far because the examples have been simple and using literal constants is
    clearer in this context. However, you should always create symbolic constants
    in Gas. Combining these with constant expressions allows you to produce code that
    is much easier to read and maintain. The previous example code is more properly
    written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The use of the compile time NOT operator (~) for the bitmask inversion saves
    having to create another constant in the program that must be changed anytime
    you modify the BitMask constant. Maintaining two separate symbols whose values
    are dependent on each other is not good practice.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in addition to merging one bit set with another, the orr instruction
    is also useful for forcing bits to 1 in a bit string. By setting various bits
    in a source operand to 1, you can use the orr instruction to force the corresponding
    bits in the destination operand to 1.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the orn (OR NOT) instruction to insert a 1 bit in a destination
    everywhere there is a 0 bit in the source. Other than that, the instruction behaves
    identically to orr.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the and w1, w1, #~BitMask cannot be assembled because Gas will not accept
    the immediate constant, use bic w1, w1, #BitMask instead, as described in the
    next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.3 Clearing Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whereas the orr instruction is useful for setting bits in a register, the bic
    instruction clears them
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: where Rd, Rl, and Rr are all W*n* or X*n*. The bics instruction sets the N and
    Z condition codes based on the value left in Rd. Everywhere a 1 bit appears in
    Rr, the bic instruction will clear the corresponding bit in Rl (storing the result
    into Rd).
  prefs: []
  type: TYPE_NORMAL
- en: The vector version of this instruction allows you to clear arbitrary bits in
    a 64- or 128-bit vector register
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: where t = 8B for 64 bits and t = 16B for 128 bits. This instruction also has
    an immediate version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: where t = 4H for 64 bits and t = 8H for 128 bits, or t = 2S for 64 bits and
    t = 4S for 128 bits. The optional shift value can be 0 or 8 for half-word lanes,
    or 0, 8, 16, or 24 for word lanes.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.4 Inverting Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The eor instruction allows you to invert selected bits in a bit set (in general-purpose
    or vector registers). If you want to invert all the bits in a destination operand,
    the mvn (not) instruction is more appropriate; however, to invert selected bits
    while not affecting others, eor is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: The eor instruction lets you manipulate known data in just about any way imaginable.
    For example, if you know that a field contains 0b1010, you can force that field
    to 0 by XORing it with 0b1010\. Similarly, you can force it to 0b1111 by XORing
    it with 0b0101.
  prefs: []
  type: TYPE_NORMAL
- en: Although this might seem like a waste because you can easily force this 4-bit
    string to 0 or all 1s by using and or orr, the eor instruction has two advantages.
    First, you are not limited to forcing the field to all 0s or all 1s; you can set
    these bits to any of the 16 valid combinations via eor. Second, if you need to
    manipulate other bits in the destination operand at the same time, and or orr
    may not be able to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose one field contains 0b1010, which you want to force to
    0, while another field in the same operand contains 0b1000, and you wish to increment
    that field by 1 (that is, set it to 0b1001). You cannot accomplish both operations
    with a single and or orr instruction, but you can do so with a single eor instruction:
    just XOR the first field with 0b1010 and the second field with 0b0001\. However,
    note that this trick works only if you know the current value of a bit set within
    the destination operand.'
  prefs: []
  type: TYPE_NORMAL
- en: The eon (exclusive–OR NOT) works just like eor, except that it inverts bits
    in the destination wherever a 0 bit appears in the right source operand.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.5 Shift and Rotate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The shift and rotate instructions are another group you can use to manipulate
    and test bits. The standard and Neon instruction sets provide a wide range of
    shift and rotate instructions that allow you to rearrange bit data as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: asr    Integer arithmetic shift right
  prefs: []
  type: TYPE_NORMAL
- en: lsl    Integer logical shift left
  prefs: []
  type: TYPE_NORMAL
- en: lsr    Integer logical shift right
  prefs: []
  type: TYPE_NORMAL
- en: ror    Integer rotate right
  prefs: []
  type: TYPE_NORMAL
- en: shl    Vector or scalar shift left or right
  prefs: []
  type: TYPE_NORMAL
- en: ushl**,** sshl**,** ushr**, and** sshr    Vector or scalar shift right
  prefs: []
  type: TYPE_NORMAL
- en: sli    Vector or scalar shift left and insert
  prefs: []
  type: TYPE_NORMAL
- en: sri    Vector or scalar shift right and insert
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these generic shifts and rotates, specialized variants saturate,
    round, narrow, and extend. Generally, those specialized instructions aren’t as
    useful for bit manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: The integer shift and rotate instructions (those that operate on general-purpose
    registers) are quite useful for moving bits into their final position when constructing
    bit strings from multiple sources. As you saw in section 2.12, “Bit Fields and
    Packed Data,” on [page 85](chapter2.xhtml#pg_85), you can use the shift and rotate
    instructions (along with the logical instructions) to pack and unpack data.
  prefs: []
  type: TYPE_NORMAL
- en: However, the biggest problem with the shift and rotate instructions is that
    they don’t provide an option to set the condition codes. For example, on many
    other CPUs (including the 32-bit ARM instruction set), the last bit shifted out
    of a register during a shift or rotate instruction winds up in the carry flag.
    The instructions typically set the Z and N flags, based on the final result. This
    is convenient for many operations, particularly those that use a loop to process
    each bit in the register; you could, for example, shift the bits out of a register
    by using a shift-right instruction, capture the output bit in the carry (using
    bcc or bcs to test the bit), and also be able to test the zero flag to see whether
    any more (set) bits are left in the register. This is not possible (with a single
    shift or rotate instruction) on the ARM.
  prefs: []
  type: TYPE_NORMAL
- en: This rule has one exception. Although the shifts do not affect the carry flag,
    the adds instruction does. Using an instruction such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to a shift left (by 1 bit) on W0, setting all the condition code
    flags (including capturing the bit shifted out of bit 31 in the carry flag). The
    adcs instruction behaves like a “rotate through carry by 1 bit” instruction (see
    section 8.1.11.1, “Shift Left,” on [page 467](chapter8.xhtml#pg_467)). Because
    [Chapters 2](chapter2.xhtml) and [8](chapter8.xhtml) covered the use of the shift
    instructions to insert and extract bit data (packed fields), this chapter doesn’t
    consider that further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector shift instructions warrant further discussion because they include
    interesting variants (sli and sri) and don’t provide rotate instructions. Simulating
    a vector rotate left takes three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The biggest problem with this code is that it takes an extra register to hold
    a temporary result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the instructions to implement a vector rotate right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See section 11.6.4, “Shift and Insert,” on [page 652](chapter11.xhtml#pg_652)
    for more information about the sli and sri instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the vector shift instructions operate only on lanes, you cannot directly
    shift all 128 bits of a vector register with a single instruction. With five instructions,
    however, you can pull it off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I’ll leave it up to you to do the shift-right operation, which is just a straightforward
    modification of the shl code.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.6 Conditional Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The csel, csinc/cinc, csinv/cinv, cset, and csetm instructions are also useful
    for manipulating bits. In particular, cset and csetm can help you initialize a
    register with 0, 1, or all 1 bits based on the condition codes. All these instructions
    are useful for dealing with operations that have set the condition codes (see
    section 12.3, “Flag Modification by Arithmetic and Logical Instructions,” on [page
    715](chapter12.xhtml#pg_715)). These conditional instructions have no vector equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.7 Counting Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The cls and clz instructions allow you to count leading 1 and 0 bits (*leading*
    means from the HO bit position down to the LO bit position). The cnt instruction
    (population count) counts all the set bits in the byte lanes in a (vector) register.
    The syntax for these instructions is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are W*n* or X*n;* t1 is 8B, 16B, 4H, 8H, 2S, or 4S; and t2 is
    8B or 16B. For the vector instructions, if the operand is 8B, 4H, or 2S, the instruction
    operates only on the LO 64 bits of the vector register.
  prefs: []
  type: TYPE_NORMAL
- en: The cls instruction (general-purpose register form) counts the number of leading
    sign bits in Rs and stores this count into Rd. This instruction counts the number
    of bits (below the HO bit) that match the HO bit. Note that the sign (HO) bit
    is not included in the count.
  prefs: []
  type: TYPE_NORMAL
- en: The clz instruction works the same way but counts the number of leading 0 bits
    including the sign bit. To count the actual number of leading 1 bits (including
    the HO sign bit), invert the source register value and use the clz instruction
    to count 0 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The vector versions of the cls and clz instructions count the number of leading
    1s or 0s in each lane of the source register, in the same manner as the scalar
    versions, and stores this count into the corresponding lane of the destination
    register.
  prefs: []
  type: TYPE_NORMAL
- en: The cnt instruction counts the number of set bits in each byte (lane) of the
    source register and stores the bit count into the corresponding lane of the destination
    register. To find the total population (bit) count for the vector register (64
    or 128 bits), use the addv instruction to sum up all the bytes within the destination
    register. To compute the population count for hwords, words, or dwords, use an
    addp instruction to add the pairs of bytes (to produce hword counts). You can
    use a second addp instruction (again, on pairs of bytes, producing an array of
    byte results) to count the pairs of hwords, producing word counts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.8 Bit Reversal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The rbit instruction reverses the bits in its source operand and stores the
    reversed result into the destination operand. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With 32-bit register operands, this instruction swaps the bits in positions
    0 and 31, 1 and 30, 2 and 29, ..., and 15 and 16\. With 64-bit operands, rbit
    swaps the bits in positions 0 and 63, 1 and 62, 2 and 61, ..., and 31 and 32\.
    With vector operands, it reverses the bits in each byte lane of the source vector
    register, storing the results into the corresponding byte lane in the destination
    vector register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector variant of this instruction reverses only the bits in byte lanes.
    To reverse the bits in a 16-, 32-, or 64-bit object, also execute an 8-bit lane
    rev16, rev32, or rev64 instruction (before or) after the rbit. For example, the
    following two instructions reverse all the bits in a 64-bit vector register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You would use similar code (with rev32) to reverse the bits in two double-words
    in a vector register.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.9 Bit Insertion and Selection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The bif (bit insert if false), bit (bit insert if true), and bsl (bit select)
    instructions allow you to manipulate individual bits in a vector register. These
    instructions have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The bif instruction first considers the mask register; everywhere a 0 bit appears
    in Vm, the instruction copies the corresponding bit in Vs (source) to the same
    bit position in Vd (destination). Everywhere a 1 appears in Vm, the bif instruction
    leaves the corresponding bit in Vd unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The bit instruction does the same thing as bif, except it copies bits on the
    opposite condition (where there is a 1 in Vm).
  prefs: []
  type: TYPE_NORMAL
- en: The bsl instruction uses the (original) bits in Vd to select the corresponding
    bit in Vs1 or Vs0. Everywhere a 1 appears in Vd, bsl will copy the corresponding
    bit from Vs1 to Vd; everywhere a 0 appears in Vd, bsl will copy the corresponding
    bit from Vs0 to Vd.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.10 Bit Extraction with ubfx
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ubfx instruction allows you to extract any number of bits from a position
    in a source register, moving those bits to bit 0 in the destination register.
    The syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are both either W*n* or X*n*, lsb is the starting bit position
    for the extraction, and len is the size of the bit string to extract. The sum
    of lsb and len must not exceed the register size.
  prefs: []
  type: TYPE_NORMAL
- en: The ubfx instruction extracts len bits from Rs, starting at bit position lsb.
    It stores this bit string into Rd (at bit 0) and zeros out the HO bits of Rd.
    For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: copies bits 8 through 23 from X1 to bits 0 through 15 in X0 (and zeros out bits
    16 through 63 in X0).
  prefs: []
  type: TYPE_NORMAL
- en: '#### 12.2.11 Bit Movement with ubfiz'
  prefs: []
  type: TYPE_NORMAL
- en: The ubfiz (unsigned bit field insert in zero) copies bits from the LO bits of
    a source register to any other position in the destination register, as the converse
    of the ubfx instruction. The syntax for this instruction is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are both either W*n* or X*n*, posn is the destination location
    where bit 0 from Rs will be moved, and len is the size of the bit string. For
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: copies bits 0 through 7 from W0 to bits 12 through 19 in W1.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.12 Bit Movement with ubfm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ubfm instruction (unsigned bit field move) copies the LO bits from a source
    register to an arbitrary position in the destination register (and puts 0s everywhere
    else in the destination register). The syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'where Rd and Rs are both either W*n* or X*n*, immr and imms are values in the
    range 0 to 31 for 32-bit operations or 0 to 63 for 64-bit operations. This instruction
    does one of two operations based on the values of immr and imms:'
  prefs: []
  type: TYPE_NORMAL
- en: If immr ≤ imms, take bits immr through imms and rotate right by immr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If immr > imms, take imms + 1 LO bits and rotate right by immr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ubfm instruction is the basis for many instructions (aliases) in the ARM
    instruction set: lsl Rd, Rs, #shift is equivalent to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: where Rsize is the register size (32 or 64).
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, lsr Rd, Rs, #shift is equivalent to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'and ubfiz Rd, Rs, #lsb, #width is equivalent to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'where Rsize is the register size (32 or 64). Finally, ubfx Rd, Rs, #lsb, #width
    is equivalent to'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: where lsb is the LO bit of the bit string to move and width is the number of
    bits to move.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.13 Bit Extraction with extr
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The extr instruction allows you to extract a bit string across a pair of registers,
    using the syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: where Rd, Rl, and Rr are all W*n* or X*n*, and posn is a constant in the range
    0 to the register size – 1 (31 or 63).
  prefs: []
  type: TYPE_NORMAL
- en: This instruction begins by concatenating the Rl and Rr registers to form a 64-
    or 128-element bit string. It then extracts 32 or 64 bits (depending on the register
    sizes) from this string, starting at bit position posn.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* ror *(immediate) instruction is an alias of* extr *obtained by setting*
    Rl *and* Rr *to the same register.*'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2.14 Bit Testing with tbz and tbnz
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The tbz (test bit zero) and tbnz (test bit not zero) instructions allow you
    to branch to a location based on whether a particular bit is set in a register,
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These instructions test the bit specified by imm in Rs to see if it is a 0 or
    a 1\. The tbz instruction transfers control to the specified target label if it
    is 0 (falling through if it is 1), while tbnz transfers control to the specified
    target label if it is 1 (falling through if it is 0).
  prefs: []
  type: TYPE_NORMAL
- en: You can use these instructions to turn any register into a 32- or 64-bit “pseudo
    condition code register,” allowing you to branch based on whether a particular
    bit in that register is set or clear. Though no instructions will automatically
    set or clear these “condition codes,” you can use any of the bit-manipulation
    instructions in this chapter to manipulate those pseudo condition codes.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that you can also use the cbz (compare and branch if zero) and
    cbnz (compare and branch if not zero) instructions to compare a register against
    0 and transfer control if it is (cbz), or is not (cbnz), equal to 0\. This is
    useful after instructions such as addv, orr, or other instructions that don’t
    set the Z flag, to see if they’ve produced a zero (or nonzero) result.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Flag Modification by Arithmetic and Logical Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, the instructions manipulated bits in general-purpose
    and vector registers. Although the PSR is not a general-purpose register, remember
    that the ands, bics, and tst instructions set the N and Z flags based on the computed
    result. If the HO (sign) bit of the result is 1, these instructions set the N
    flag; if the result is 0, these instructions set the Z flag. Otherwise, they clear
    the flags.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the adds, adcs, subs, sbcs, negs, ngcs, cmp, ccmp, and ccmn
    instructions to set the flags. In particular, keep in mind that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: shifts the value in Rn to the left one bit and moves the (original) HO bit into
    the carry flag. This instruction sets the overflow flag if the two original HO
    bits contain 0b01 or 0b10\. It sets the negative flag if the resulting HO bit
    is 1\. Finally, of course, it sets the zero flag if the result of the addition
    is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to a “rotate left Rn 1 bit through the carry flag” instruction.
    You can use this to set the carry flag based on the HO bit of Rn and capture the
    previous carry flag value into the LO bit of Rn.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that only the arithmetic and logical instructions that operate
    on general-purpose registers (and have the s suffix) affect the flags. In particular,
    the vector instructions do not affect the flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it’s not an arithmetic or logical instruction, the mrs (move register
    to status) instruction, with the destination field NZCV, sets all the flags to
    the values found in bits 28–31 of the general-purpose register. This provides
    a quick way to create a multiway branch from 4 bits. Consider the following code
    (taken from section 11.10.4, “Vector Comparison Results,” on [page 691](chapter11.xhtml#pg_691)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now you can test N, Z, C, and V flags to see if lanes 3, 2, 1, or 0 (respectively)
    in V1 were equal to the corresponding lanes in V2.
  prefs: []
  type: TYPE_NORMAL
- en: This section has provided a generic introduction to setting the condition code
    flags to capture a bit value. Because instructions with an s suffix affect the
    flags differently, it is important to discuss how instructions affect the individual
    condition code flags; the following sections handle that task.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.1 The Zero Flag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The zero flag (Z) setting is one of the most important results produced by the
    ands instruction. Indeed, programs reference this flag so often after the ands
    instruction that ARM added a separate tst instruction whose main purpose is to
    logically AND two results and set the flags without otherwise affecting either
    instruction operand.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Technically,* tst *is not a new instruction, but rather an alias for* ands
    *when the destination register is WZR or XZR.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The zero flag can be used to check three things after the execution of an ands
    or tst instruction: whether a particular bit in an operand is set, whether at
    least one of several bits in a bit set is 1, and whether an operand is 0\. The
    first use case is actually a special instance of the second, in which the bit
    set contains only a single bit. The following paragraphs explore each of these
    uses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether a particular bit is set in a given operand, ands or tst an
    operand with a constant value containing a single set bit you wish to test. This
    clears all the other bits in the operand, leaving a 0 in the bit position under
    test if the operand contained a 0 in that bit position and a 1 if it contained
    a 1\. Because all other bits in the result are 0, the entire result will be 0
    if that particular bit is 0; the entire result will be nonzero if that bit position
    contains a 1\. The ARM CPU reflects this status in the zero flag (Z = 1 indicates
    a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence demonstrates
    how to test if bit 4 is set in W0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the ands and tst instructions to see whether any one of several
    bits is set. Simply supply a constant that has a 1 in all the positions you want
    to test (and 0s everywhere else). ANDing an operand with such a constant will
    produce a nonzero value if one or more of the bits in the operand under test contain
    a 1\. The following example tests whether the value in W0 contains a 1 in bit
    positions 1 and 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot use a single ands or tst instruction to see whether all the corresponding
    bits in the bit set are equal to 1\. To accomplish this, you must first mask out
    the bits that are not in the set and then compare the result against the mask
    itself. If the result is equal to the mask, all the bits in the bit set contain
    1s. You must use the ands instruction for this operation because the tst instruction
    does not modify the result. The following example checks whether all the bits
    in a bit set (bitMask) are equal to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of course, once you stick the cmp instruction in there, you don’t really have
    to check whether all the bits in the bit set contain 1s. You can check for any
    combination of values by specifying the appropriate value as the operand to cmp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tst and ands instructions will set the zero flag in the preceding code
    sequences only if all the bits in W0 (or other destination operand) have 0s in
    the positions where 1s appear in the constant operand. This suggests another way
    to check for all 1s in the bit set: invert the value in W0 prior to using the
    ands or tst instruction. In this case, if the zero flag is set, you know that
    the (original) bit set contained all 1s. For example, the following code checks
    whether any bits specified by 1s in a bitmask are nonzero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The previous paragraphs all suggest that the bitMask (the source operand) is
    a constant, but you can use a variable or other register too. Simply load that
    variable or register with the appropriate bitmask before you execute the tst,
    ands, or cmp instructions in the preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2 The Negative Flag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tst and ands instructions will also set the negative flag (N, also known
    as the sign flag) if the HO bit of the result is set. This allows you to test
    two individual bits in a register, assuming one of those bits is the HO bit. When
    using these instructions, the mask value must contain a 1 in the HO bit as well
    as in the bit position of the other bit you want to test. After executing the
    tst or ands instruction, you must check the N flag before testing the Z flag (as
    the Z flag will be clear if the HO bit was set).
  prefs: []
  type: TYPE_NORMAL
- en: If the HO bit is set and you also want to see whether the other bit is set,
    you must test that other bit again (or use the cmp instruction, as in the previous
    section).
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.3 The Carry and Overflow Flags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The logical instructions (ands and tst) that affect the flags always clear the
    carry and overflow flags. However, the arithmetic instructions (adds, adcs, subs,
    sbcs, negs, ngcs, cmp, ccmp, and ccmn) modify these flags. In particular, when
    the two source operands are the same, adds and adcs shift the HO bit of the (original)
    source into the carry flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Negating the most negative value (for example, the word value 0x80000000) will
    set the overflow flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the ARM AARCH64 documentation to determine how the various instructions
    affect the carry and overflow flags. Note that many instructions will not affect
    these two flags (especially the overflow flag) even though they affect the N and
    Z flags.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Packing and Unpacking Bit Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inserting a bit string into an operand and extracting a bit string from an operand
    are common operations. [Chapter 2](chapter2.xhtml) provided simple examples of
    packing and unpacking such data; this section formally describes how to do this,
    now that you’ve learned more instructions and have more tools to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1 Inserting One Bit String into Another
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the purposes of this chapter, I will assume that we’re dealing with bit
    strings that fit within a byte, half-word, word, or double-word operand. Large
    bit strings that cross object boundaries require additional processing; I discuss
    bit strings that cross double-word boundaries later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: When packing and unpacking a bit string, you must consider its starting bit
    position and length. The *starting bit position* is the bit number of the LO bit
    of the string in the operand. The *length* is the number of bits in the string.
  prefs: []
  type: TYPE_NORMAL
- en: To insert (pack) data into a destination operand, start with a bit string of
    the appropriate length that is right-justified (starts in bit position 0) and
    zero-extended to 8, 16, 32, or 64 bits. Next, insert this data at the appropriate
    starting position in another operand that is 8, 16, 32, or 64 bits wide. The destination
    bit positions are not guaranteed to contain any particular value.
  prefs: []
  type: TYPE_NORMAL
- en: The first two steps (which can occur in any order) are to clear out the corresponding
    bits in the destination operand and shift a copy of the bit string so that the
    LO bit begins at the appropriate bit position. The third step is to OR the shifted
    result with the destination operand. This inserts the bit string into the destination
    operand. [Figure 12-3](chapter12.xhtml#fig12-3) diagrams this process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: Inserting a bit string into a destination operand'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three instructions insert a bit string of known length into a
    destination operand, as shown in [Figure 12-3](chapter12.xhtml#fig12-3). These
    instructions assume that the source bit string is in W1 (with 0s in positions
    outside the bit string) and the destination operand is in W0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For the special case when the destination bit position and bit string length
    are constants (known at assembly time), the ARM CPU provides an instruction to
    handle bit insertion for you: bfi (bit field insert). It has the following syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are both either W*n* or X*n*. The sum of posn and len must not
    exceed the register size (32 for W*n* and 64 for X*n*).
  prefs: []
  type: TYPE_NORMAL
- en: The bfi instruction takes the LO len bits of Rs and inserts them into the destination
    register (Rd) starting at bit position posn. Consider the instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: assuming W0 contained 0x33333333 (the destination value) and W1 contained 0x1200
    (the insertion value). This would leave 0x31200333 in W0.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t know the length and the starting position while writing the program
    (that is, you have to calculate them at runtime), you must use several instructions
    to do a bit-string insertion. Suppose you have two values—a starting bit position
    for the field you’re inserting and a nonzero length value—and that the source
    operand is in W1 and the destination operand is in W0\. The mergeBits procedure
    in Listing 12-1 demonstrates how to insert a bit string from W1 into W0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The mergeBits function is where the merging occurs. This code begins by generating
    a mask containing all 1 bits from location 0 to *n* – 1, where *n* is the length
    of the bit string to insert ❶. The code uses a simple mathematical trick to generate
    these bits: if you compute 2*^n* and then subtract 1 from this value, the resulting
    value contains 1 bits in positions 0 to *n* – 1\. After generating this mask,
    the code positions the mask bits to the position where mergeBits will insert the
    bit string ❷. It then masks out (sets to 0) those bit positions in the destination
    location ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: To complete the merge, mergeBits moves the bits to merge to the proper position
    and ORs those bits into the destination location (which contains 0s at that point)
    ❹. The mergeBits function assumes that the source bits (the bits to merge) form
    a bit string that is exactly *n* bits long (*n* being the value passed in X3)
    and is located in bit positions 0 to *n* – 1\. Note that if you need to handle
    bit-insertion values that might have 1 bits in positions *n* or greater, you should
    logically AND the value to merge (passed in X1) with the bitmask after shifting
    it ❹. The version of mergeBits in Listing 12-1 assumes that the val2Merge argument
    (X1) doesn’t contain any extra 1 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The asmMain function ❺ is a loop that steps through the ValueToMerge, MergeInto,
    LenInBits, and StartPosn arrays. This loop fetches these four values, prints them,
    and then calls the mergeBits function to merge the ValueToMerge entry into MergeInto.
    The LenInBits element contains the size (in bits) to merge, and the value from
    the StartPosn array is the bit position where the merger should take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and sample output for Listing 12-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The mergeBits function is very general, allowing you to specify the bit string
    length and the destination position as variable parameter values. If the length
    and destination position values are constants within your code (a common special
    case), you can use a more efficient way to insert bits from one register into
    another: the bfm (bit field move) instruction. This instruction has the syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are both either W*n* or X*n*, rotate is the number of rotate-right
    positions, and bitposn is the leftmost bit in the source (starting at bit 0) to
    move.
  prefs: []
  type: TYPE_NORMAL
- en: This instruction rotates (a copy of) the LO bitposn bits in Rs the specified
    number of bit positions, then replaces the corresponding bits in Rd with these
    rotated bits.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The* bfi *instruction is an alias of* bfm *with a slight modification to the
    meaning of the two immediate operands (see the ARM documentation for more details).*'
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this section assume that the bit string appears completely within
    a double-word (or smaller) object. This will always be the case if the bit string
    is less than or equal to 64 bits in length. However, if the length of the bit
    string plus its starting position (modulo 8) within an object is greater than
    64, the bit string will cross a double-word boundary within the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inserting such bit strings requires up to three operations: one to extract
    the start of the bit string (up to the first double-word boundary), one to copy
    whole double words (assuming the bit string is so long it consumes several double
    words), and one to copy leftover bits in the last double word at the end of the
    bit string. I’ll leave the implementation of this operation as an exercise for
    you.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.2 Extracting a Bit String
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The previous section described how to insert one bit string into another. This
    section covers the converse operation: extracting a bit string from a larger string.'
  prefs: []
  type: TYPE_NORMAL
- en: The bfxil (bit field extract and insert at low end) instruction extracts any
    number of bits (at any position) from a source register and copies those bits
    to the LO bit positions of a destination register. Its syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: where Rd and Rs are either W*n* or X*n* . The sum of posn and len must not exceed
    the register size (32 for W*n* and 64 for X*n*), and posn must be less than the
    register size.
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction extracts len bits, starting at bit number posn, from Rs and
    inserts them into the LO len bits of Rd. It does not affect the other bits (at
    bit positions len and higher) in Rd. Generally, you’ll want to set Rd to 0 before
    using this instruction, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the bfi instruction, bfxil supports only immediate constants for the posn
    and len operands. If you need to specify variables for either (or both) of these
    arguments, you must write an extractBits function (similar to mergeBits in the
    previous section). The following instructions do the actual bit extraction in
    extractBits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This leaves the extracted bits in the LO bit positions of X0.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3 Clearing a Bit Field
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Gas assembler provides an alias of the bfm instruction that you can use
    to clear bits in a register: bfc (bit field clear). Its syntax is'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: where Rd is W*n* or X*n* and posn and len have the same meanings and restrictions
    as the bfi instruction. If you supply a len field of 1, you can clear individual
    bits (specified by a bit number) with bfc.
  prefs: []
  type: TYPE_NORMAL
- en: The bfc instruction zeros out len bits starting at bit position posn in Rd.
    It is equivalent to the following instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: where Rd is W*d* or X*d*, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The bfc instruction is available only on ARMv8.2-a and later CPUs, not on Raspberry
    Pi (3 and 4) and other lower-end systems. (Note that the Raspberry Pi 5 does support
    this instruction.)
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.4 Using bfm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The bfxil and bfi (as well as bfc) instructions are actually aliases for the
    instruction bfm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the ubfm instruction, they do two operations based on the values of immr
    and imms:'
  prefs: []
  type: TYPE_NORMAL
- en: If immr ≤ imms, take bits immr through imms from Rs and rotate right by immr,
    merging with the existing bits in Rd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If immr > imms, take imms + 1 LO bits from Rs and rotate right by immr, merging
    with the existing bits in Rd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: produces 0xAFFFFFFF in W0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bfi instruction is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The bfxil instruction is equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you would use these aliases rather than the bfm mnemonic.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Common Bit Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll encounter many bit-manipulation design patterns in assembly language
    programs. This section covers some of the more common algorithms and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 12.5.1 Coalescing Bit Sets and Distributing Bit Strings'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting and extracting bit sets is only a little different from inserting
    and extracting bit strings if the “shape” of the bit set you’re inserting (or
    resulting bit set you’re extracting) is the same as the shape of the bit set in
    the main object. The *shape* of a bit set is the distribution of the bits in the
    set, ignoring the starting bit position of the set. A bit set that includes bits
    0, 4, 5, 6, and 7 has the same shape as a bit set that includes bits 12, 16, 17,
    18, and 19 because the distribution of the bits is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to insert or extract this bit set is nearly identical to that of the
    previous sections; the only difference is the mask value you use. For example,
    to insert this bit set starting at bit 0 in W0 into the corresponding bit set
    starting at position 12 in W1, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: However, suppose you have five bits in bit positions 0 through 4 in W0 and want
    to merge them into bits 12, 16, 17, 18, and 19 in W1\. Somehow you have to *distribute*
    the bits in W0 prior to logically ORing the values into W1; that is, you have
    to move the bits from positions 0 to 4 into positions 12, 16, 17, 18, and 19.
  prefs: []
  type: TYPE_NORMAL
- en: 'The converse operation, *coalescing bits*, extracts the bits from various bit
    positions and packs them (coalesces them) into the LO bit positions of a destination
    location. The following code demonstrates how to distribute the bits in a bit
    string according to the values in a bitmask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The main entry point to this loop is DistLoop. It begins by decrementing the
    loop counter held in W2 ❶. This code will check the value in W2 to see if the
    loop is done a little later. Next, the tst instruction checks whether bit 0 of
    the bitmap contains a 1\. If it does, the code needs to copy a bit from the LO
    bit position of W1 into W0; otherwise, it keeps the current bit value.
  prefs: []
  type: TYPE_NORMAL
- en: The bne instruction transfers control to CopyToW0 if it needs to copy a bit
    from W1; otherwise, it falls through to ❷ if it’s going to keep the current bit
    in W0\. The ror instruction rotates the existing W0 LO bit into the HO bit position
    (after 32 iterations of this loop, the bit winds up back in its original position).
    After the ror, the code checks whether the loop has executed 32 times (the cbnz
    instruction). If so, the code exits; otherwise, it repeats.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the LO bit of W3 was a 1, control transfers to the CopyToW0 label, which
    is responsible for shifting the (current) LO bit of W1 into W0\. The code at CopyToW0
    uses the extr instruction to grab bit 0 from W1 and place it in bit 31 of W0 (shifting
    bits 1 to 31 in W0 down 1 bit). The lsr w1, w1, #1 instruction removes the used
    bit from W1 and places the next bit to merge into W1 in bit position 0\. After
    a quick check to see whether the loop is complete, the code falls down into DistLoop
    and repeats.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This code would be a bit simpler if the ARM had an instruction that would
    rotate a register right by one bit through the carry flag. However, since no such
    instruction exists, this code has to simulate it by using* extr*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general algorithm for coalescing bits is a tad more efficient than general
    distribution. Here’s the code that will extract bits from W1 via the bitmask in
    W3 and leave the result in W0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As with the distribution code, the coalescing code loops through the bits, copying
    one bit at a time from W1 to W0 wherever there are 1 bits in the bitmap ❷. The
    extr instruction creates a 32-bit string from bit 31 of W1 and bits 0 to 30 of
    W0, then puts the result into W0\. On each loop iteration, the code shifts the
    bits in W1 one position to the left ❶ ❸ so that the next bit to (possibly) move
    into W0 is in the HO bit position. Unlike the distribution code, this code will
    terminate after it processes all the 1 bits present in the bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to coalesce bits is via table lookup. By grabbing a byte of data
    at a time (so your tables don’t get too large), you can use that byte’s value
    as an index into a lookup table that coalesces all the bits down to bit 0\. Finally,
    you can merge the bits at the low end of each byte together. This may produce
    a more efficient coalescing algorithm in certain cases. The implementation is
    left to you.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.2 Creating Packed Arrays of Bit Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Though far less efficient, it is possible to create arrays of elements whose
    size is not a multiple of 8 bits. The drawback is that calculating the “address”
    of an array element and manipulating it involves a lot of extra work. This section
    presents a few examples of packing and unpacking array elements that are an arbitrary
    number of bits long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would you want arrays of bit objects? The answer is simple: space. If an
    object consumes only 3 bits, you can get 2.67 times as many elements into the
    same space if you pack the data rather than allocating a whole byte for each object.
    For very large arrays, this can result in substantial savings. Of course, the
    cost of saving space is speed: you must execute extra instructions to pack and
    unpack the data, slowing access to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation for locating the bit offset of an array element in a large
    block of bits is almost identical to the standard array access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you calculate the element’s address in bits, you must convert it to a
    byte address (because you must use byte addresses when accessing memory) and extract
    the specified element. Because the base address of an array almost always starts
    on a byte boundary, you can use the following equations to simplify this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, suppose you have an array of 200 3-bit objects declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The constant expression in the preceding dimension reserves space for enough
    bytes to hold 600 bits (200 elements, each 3 bits long). As the comment notes,
    the expression adds 2 extra bytes at the end to ensure you don’t lose any odd
    bits and to allow you to access 1 byte beyond the end of the array when storing
    data to the array. (Losing odd bits wouldn’t occur in this example because 600
    is evenly divisible by 8, but in general you can’t count on this; adding 2 extra
    bytes usually won’t hurt.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose you want to access the *i*th 3-bit element of this array. You can
    extract these bits with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Inserting an element into the array is a little more difficult. In addition
    to computing the base address and bit offset of the array element, you must also
    create a mask to clear out the bits in the destination where you’re going to insert
    the new data. The following code inserts the LO 3 bits of W0 into the *i*th element
    of the AO3Bobjects array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Assuming AO3Bobjects contained all 0s, i contained 5, and W0 (the value to insert)
    was 7 upon executing this code, the first couple of bytes would contain 0x38000
    after the execution of this code sequence. Because each element is 3 bits, the
    array looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: where bit 0 is the leftmost bit. Flipping the 32 bits around to make them more
    readable, and grouping them in blocks of 4 bits to make it easy to convert to
    hexadecimal, we get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: which is 0x38000.
  prefs: []
  type: TYPE_NORMAL
- en: This code uses a lookup table (Masks) to generate the masks needed to clear
    out the appropriate position in the array. Each element of this array contains
    all 1s, except for three 0s in the position you need to clear for a given bit
    offset. Note the use of the NOT operator (~) to invert the constants in the table.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.3 Searching for Bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common bit operation is to locate the end of a run of bits. A special case
    of this operation is to locate the first (or last) set or clear bit in a 16-,
    32-, or 64-bit value. This section explores ways to handle this special case.
  prefs: []
  type: TYPE_NORMAL
- en: '*First set bit* means the first bit in a value, scanning from bit 0 toward
    the high-order bit, which contains a 1\. A similar definition exists for the *first
    clear bit*. The *last set bit* is the first bit in a value, scanning from the
    high-order bit toward bit 0, which contains a 1\. Likewise, a similar definition
    exists for the *last clear bit*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One obvious way to scan for the first or last bit is to use a shift instruction
    in a loop and count the number of iterations before you shift out a 1 (or 0).
    The number of iterations specifies the position. Here’s some sample code that
    checks for the first set bit (from bit 0) in W0 and returns that bit position
    in W1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that this code returns –1 in W1 if W0 has no set bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for the first (or last) set bit is such a common operation that Arm
    added an instruction specifically to accelerate this process: clz (count leading
    0 bits). In particular, the clz instruction counts the number of leading 0s, which
    tells you the position of the most significant set bit. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This code computes the bit position of the 1 in the highest position in W0 (leaving
    the result in W0). This produces –1 if W0 contains 0 (no leading set bits).
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget that cls doesn’t count leading *set* bits but leading *sign* bits.
    To count the number of leading (HO) bits containing 1s, invert the number and
    use clz to count the leading 0 bits. To count the number of trailing 0 or 1 bits
    (that is, a bit run of 0s or 1s starting at the LO bit position), use the rbit
    instruction to reverse the bits and then count the HO bits you’re interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 12.5.4 Merging Bit Strings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common bit string operation is to produce a single bit string by merging,
    or interleaving, bits from two sources. For example, the following code sequence
    creates a 32-bit string by merging alternate bits from two 16-bit strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This particular example merges two 16-bit values together, alternating their
    bits in the result value. For a faster implementation of this code, unroll the
    loop to eliminate one-third of the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few slight modifications, you can merge four 8-bit values together,
    or merge other bit sets from the source strings. For example, the following code
    copies bits 0 to 5 from W0, bits 0 to 4 from W1, bits 6 to 11 from W0, bits 5
    to 15 from W1, and finally bits 12 to 15 from W0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This code produces the result in W3, extracting the bits from W0 and W1.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.5 Scattering Bits from a Bit String
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also extract and distribute bits in a bit string among multiple destinations,
    known as *scattering bits*. The following code takes the 32-bit value in W0 and
    distributes alternate bits among the LO 16 bits in the W1 and W3 registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This code produces 0xffff in W1 and 0x0000 in W0.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.6 Searching for a Bit Pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another bit-related operation you may need is the ability to search for a particular
    bit pattern in a string of bits. For example, you might want to locate the bit
    index of the first occurrence of 0b1011 starting at a particular position in a
    bit string. This section explores simple algorithms to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search for a particular bit pattern, you must know four details:'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of that pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bit string to search through, known as the *source*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the bit string that you’re searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic idea behind the search is to create a mask based on the length of
    the pattern and to mask a copy of the source with this value. You can then directly
    compare the pattern with the masked source for equality. If they are equal, you’re
    finished; if not, increment a bit position counter, shift the source one position
    to the right, and try again. You repeat the operation [*length*(*source*) – *length*(*pattern*)]
    times. The algorithm fails if it does not detect the bit pattern after that number
    of attempts, because it has exhausted all the bits in the source operand that
    could match the pattern’s length.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 12-2 searches for a 4-bit pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the build command and sample output for Listing 12-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this program properly located the bit pattern in the source.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Moving On
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assembly language is well known for its powerful bit-manipulation capabilities,
    difficult to replicate in an HLL. This chapter described those capabilities for
    the 64-bit ARM CPU. It began with definitions useful for describing bit operations,
    then introduced a bevy of instructions that manipulate bit data. This chapter
    also discussed using the condition code flags in the PSR as bit data, along with
    the instructions to manipulate those flags, specifically the negative (N), zero
    (Z), carry (C), and overflow (V) flags.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the basic set of bit-manipulation instructions, this chapter
    covered applications of those instructions, including packing and unpacking bit
    strings, inserting one bit string into another, extracting a bit string from a
    source string, coalescing and distributing bits, working with packed arrays of
    bits, searching for bit strings, merging bit strings, and scattering bits from
    a bit string.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, this chapter concludes the discussion of new ARM assembly
    language instructions. The remaining chapters discuss the application of these
    instructions and various software-engineering topics. The next chapter, for example,
    focuses on macros you can use to simplify your assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: '### 12.7 For More Information'
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate book on bit twiddling is *Hacker’s Delight*, 2nd edition, by Henry
    S. Warren Jr. (Addison-Wesley Professional, 2012). While this book uses the C
    programming language for examples, almost all the concepts it discusses apply
    to assembly language programs as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
