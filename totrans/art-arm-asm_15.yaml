- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 BIT MANIPULATION
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12 位操作
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Manipulating bits in memory is perhaps the feature for which assembly language
    is most famous. Even the C programming language, known for bit manipulation, doesn’t
    provide as complete a set of bit-manipulation operations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中操作比特可能是汇编语言最著名的特点。即使是以位操作著称的 C 编程语言，也没有提供如此完整的位操作指令集。
- en: This chapter discusses how to manipulate strings of bits in memory and registers
    by using ARM assembly language. It begins with a review of the bit-manipulation
    instructions covered thus far, introduces a few new instructions, then reviews
    information on packing and unpacking bit strings in memory, which is the basis
    for many bit-manipulation operations. Finally, this chapter discusses several
    bit-centric algorithms and their implementation in assembly language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何使用 ARM 汇编语言操作内存和寄存器中的比特串。首先回顾到目前为止涵盖的位操作指令，引入一些新的指令，然后回顾内存中比特串的打包和解包信息，这为许多位操作提供了基础。最后，本章讨论了几种以位为中心的算法及其在汇编语言中的实现。
- en: 12.1 What Is Bit Data, Anyway?
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1 什么是比特数据？
- en: '*Bit manipulation* refers to working with *bit data*, data types consisting
    of strings of bits that are noncontiguous or are not multiples of 8 bits long.
    Generally, these bit objects will not represent numeric integers, although I will
    not place this restriction on bit strings.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*位操作*是指操作*比特数据*，这是一种由不连续或不是 8 位整数倍的比特串组成的数据类型。通常，这些比特对象不会表示数值整数，尽管我不会对比特串做出此限制。'
- en: A *bit string* is a contiguous sequence of 1 or more bits. It does not have
    to start or end at any special point. For example, a bit string could start in
    bit 7 of one byte in memory and continue through to bit 6 of the next byte in
    memory. Likewise, a bit string could begin in bit 30 of W0, consume the upper
    2 bits of W0, and then continue from bit 0 through bit 17 of W1\. In memory, the
    bits must be physically contiguous (that is, bit numbers always increase except
    when crossing a byte boundary, and at byte boundaries the memory address increases
    by 1 byte). In registers, if a bit string crosses a register boundary, the application
    defines the continuation register, but the bit string always continues in bit
    0 of that second register.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特串*是由一个或多个比特组成的连续序列。它不一定要从特定的位置开始或结束。例如，比特串可以从内存中某字节的第 7 位开始，并延续到下一个字节的第
    6 位。同样，比特串可以从 W0 寄存器的第 30 位开始，消耗 W0 的高 2 位，然后继续从 W1 寄存器的第 0 位到第 17 位。在内存中，比特必须是物理上连续的（也就是说，位编号总是递增，除非跨越字节边界，且字节边界处内存地址增加
    1 字节）。在寄存器中，如果比特串跨越寄存器边界，应用程序定义继续使用的寄存器，但比特串总是从该第二个寄存器的第 0 位继续。'
- en: A *bit run* is a sequence of bits with all the same value. A *run of 0s* is
    a bit string that contains all 0s, and a *run of 1s* is a bit string containing
    all 1s. The *first set bit* in a bit string is the bit position of the first bit
    containing a 1 in a bit string—that is, the first 1 bit following a possible run
    of 0s. A similar definition exists for the *first clear bit*. The *last set bit*
    is the last bit position in a bit string that contains 1s; the remainder of the
    string forms an uninterrupted run of 0s. A similar definition exists for the *last
    clear bit*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*位运行*是指所有位值相同的比特序列。*0 的连续运行*是包含所有 0 的比特串，而*1 的连续运行*是包含所有 1 的比特串。*第一个置位比特*是比特串中第一个包含
    1 的位的位置——即，在可能存在的 0 连续运行后第一个 1 位。*第一个清除位*也有类似的定义。*最后一个置位比特*是比特串中最后一个包含 1 的比特位置；该位置之后的比特构成一个不间断的
    0 连续运行。*最后一个清除位*也有类似的定义。'
- en: A *bit set* is a collection of bits, not necessarily contiguous, within a larger
    data structure. For example, bits 0 to 3, 7, 12, 24, and 31 in a double word form
    a set of bits. Typically, we will deal with bit sets that are part of a *container
    object* (the data structure that encapsulates the bit set) that is no more than
    about 32 or 64 bits in size, though this limit is completely artificial. Bit strings
    are special cases of bit sets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*比特集*是指在一个更大的数据结构内，可能不连续的一组比特。例如，双字中的第 0 到第 3 位、第 7 位、第 12 位、第 24 位和第 31 位构成一个比特集。通常，我们会处理作为*容器对象*（封装比特集的数据结构）一部分的比特集，容器的大小通常不超过
    32 或 64 位，尽管这个限制是完全人为的。比特串是比特集的特殊情况。'
- en: A *bit offset* is the number of bits from a boundary position (usually a byte
    boundary) to the specified bit. As noted in [Chapter 2](chapter2.xhtml), these
    bits are numbered starting from 0 at the boundary location.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*位偏移* 是从边界位置（通常是字节边界）到指定位的位数。如[第2章](chapter2.xhtml)所述，这些位从边界位置的 0 开始编号。'
- en: 'A *mask* is a sequence of bits used to manipulate certain bits in another value.
    For example, the bit string 0b0000_1111_0000, when used with the and instruction,
    masks away (clears) all bits except bits 4 through 7\. Likewise, if you use the
    same value with the orr instruction, it can set bits 4 through 7 in the destination
    operand. The term *mask* derives from the use of these bit strings with the and
    instruction, where the 1 and 0 bits behave like masking tape when you’re painting
    something: they pass through certain bits unchanged while masking out (clearing)
    the other bits.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*掩码* 是一个位串，用来操作另一个值中的某些位。例如，位串 0b0000_1111_0000，当与 and 指令一起使用时，会掩蔽（清除）除了第 4
    到 7 位之外的所有位。同样，如果你使用相同的值与 orr 指令一起使用，它可以设置目标操作数中的第 4 到 7 位。术语 *掩码* 源自这些位串与 and
    指令的使用，其中 1 和 0 位就像画画时用的遮蔽胶带：它们让某些位保持不变，同时掩蔽掉（清除）其他位。'
- en: Armed with these definitions, you’re ready to start manipulating some bits!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些定义后，你已准备好开始操作位了！
- en: 12.2 Instructions That Manipulate Bits
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2 操作位的指令
- en: Let’s begin by reviewing the instructions this book has covered so far that
    manipulate bits, along with introducing a few additional bit-manipulation instructions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾本书迄今为止介绍的操作位的指令开始，同时介绍一些额外的位操作指令。
- en: 'Bit manipulation generally consists of six activities: setting bits, clearing
    bits, inverting bits, testing and comparing bits, extracting bits from a bit string,
    and inserting bits into a bit string. The most basic bit-manipulation instructions
    are the and/ands bic, orr, orn, eor, mvn (not), tst, and shift and rotate instructions.
    This section discusses these instructions, concentrating on how to use them to
    manipulate bits in memory or registers.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 位操作通常包括六个活动：设置位、清除位、反转位、测试和比较位、从位串中提取位以及将位插入到位串中。最基本的位操作指令有 and/ands bic、orr、orn、eor、mvn（非）、tst
    以及移位和旋转指令。本节讨论这些指令，重点讲解如何使用它们在内存或寄存器中操作位。
- en: '#### 12.2.1 Isolating, Clearing, and Testing Bits'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 12.2.1 隔离、清除和测试位'
- en: 'The and/ands instruction provides the ability to clear bits in a bit sequence.
    This instruction is especially useful for isolating a bit string or a bit set
    that is merged with other, unrelated data (or, at least, data that is not part
    of the bit string or bit set). For example, if a bit string consumes bit positions
    12 through 24 of the W0 register, you can isolate this bit string by using the
    following instruction to set all other bits in W0 to 0:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: and/ands 指令提供了清除位序列中位的功能。此指令对于隔离一个与其他无关数据（或者至少是与位串或位集无关的数据）合并的位串或位集特别有用。例如，如果一个位串占用了
    W0 寄存器中的第 12 到 24 位，你可以通过以下指令将 W0 中的其他所有位清零，从而隔离这个位串：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Figure 12-1](chapter12.xhtml#fig12-1) shows the result of this instruction.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](chapter12.xhtml#fig12-1)展示了此指令的结果。'
- en: '![](../images/Figure12-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-1.jpg)'
- en: 'Figure 12-1: Isolating a bit string by using the and instruction'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-1：使用 and 指令隔离位串
- en: 'Once you’ve cleared the unneeded bits in a set of bits, you can often operate
    on the bit set in place. For example, to see whether the string of bits in positions
    12 through 24 of W0 contains 0x2F3, you could use the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你清除了位集中的不需要的位，通常可以就地对位集进行操作。例如，要检查 W0 中第 12 到 24 位的位串是否包含 0x2F3，可以使用以下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You cannot use the immediate constant 0x2F3000 with the cmp instruction, so
    this code first loads that constant into W1 and compares W0 against W1\. You also
    can’t use movz to load 0x2F3 preshifted to the left 12 bits because movz allows
    only shifts of 0, 16, 32, or 48 bits; likewise, 0x2F3 is not a logical immediate
    pattern, so you can’t use a mov instruction with 0x2F3000.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在 cmp 指令中使用立即数 0x2F3000，因此此代码首先将该常数加载到 W1 中，并将 W0 与 W1 进行比较。同样，你也不能使用 movz
    将 0x2F3 左移 12 位后加载，因为 movz 只允许 0、16、32 或 48 位的移位；此外，0x2F3 也不是一个逻辑立即数模式，因此不能使用
    mov 指令与 0x2F3000 一起使用。
- en: NOTE
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The instruction* mov w1, #logical_pattern *is equivalent to* orr w1, wzr,
    #logical_pattern*.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令* mov w1, #logical_pattern *等同于* orr w1, wzr, #logical_pattern*。'
- en: 'To make the constants you use in conjunction with this value easier to deal
    with, you can use the lsr instruction to align the bit string with bit 0 after
    you’ve masked it, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使与此值一起使用的常数更容易处理，你可以使用 lsr 指令将位串对齐到第 0 位，方法是先屏蔽掉其他位，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The plain and instruction does not affect any condition code flags. Use the
    ands variant if you would like to update the N and Z flags based on the result
    of the AND operation, remembering that this instruction always clears the carry
    and overflow flags.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的 and 指令不会影响任何条件码标志。如果你希望根据 AND 操作的结果更新 N 和 Z 标志，请使用 ands 变体，记住该指令会始终清除进位标志和溢出标志。
- en: If you want to capture the result of the ands operation in the N and Z flags
    but don’t want to keep the logical result, you can use the tst instruction. This
    is equivalent to (and an alias of) ands supplying WZR or XZR as the destination
    register (which throws away the result).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将 ands 操作的结果捕获到 N 和 Z 标志中，但又不想保留逻辑结果，你可以使用 tst 指令。这相当于（并且是）使用 WZR 或 XZR
    作为目标寄存器的 ands 指令（该操作会丢弃结果）。
- en: Don’t forget that you can also use the and instruction with the vector registers
    (both vector and scalar operations); just keep in mind that the vector and instruction
    doesn’t affect the flags (there is no ands variant).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了你还可以使用 and 指令与向量寄存器一起使用（无论是向量操作还是标量操作）；不过请记住，向量 and 指令不会影响标志位（没有 ands 变体）。
- en: Because tst is an alias of ands, and there is no vector ands instruction, the
    Neon instruction set provides this cmtst instruction
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 tst 是 ands 的别名，并且没有向量 ands 指令，Neon 指令集提供了 cmtst 指令。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: where t is 8B, 16B, 4H, 8H, 2S, 4S, or 2D (8B, 4H, and 2S types operate on the
    LO 64 bits of V*n*, while the others operate on all 128 bits).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 t 为 8B、16B、4H、8H、2S、4S 或 2D（8B、4H 和 2S 类型操作 V*n* 的低 64 位，而其他类型则操作所有 128 位）。
- en: This instruction logically ANDs each lane in Vd.t with Vd.t. If the result is
    not 0, cmtst sets the destination lane to all 1s; if the result is 0, it sets
    the destination lane to all 0s. You can use the result as a bitmask for further
    vector (bit) operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令逻辑与（AND）Vd.t 中的每一条 lane 和 Vd.t 本身。如果结果不为 0，cmtst 会将目标 lane 设置为全 1；如果结果为 0，则将目标
    lane 设置为全 0。你可以使用结果作为进一步向量（位）操作的位掩码。
- en: 12.2.2 Setting and Inserting Bits
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2 设置和插入位
- en: 'The orr instruction is especially useful for inserting a bit set into another
    bit string (in general-purpose or vector registers), using the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: orr 指令对于将一个位集插入到另一个位串中尤其有用（无论是在通用寄存器还是向量寄存器中），可以通过以下步骤实现：
- en: 1.  Clear all the bits surrounding your bit set in the source operand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  清除源操作数中位集周围的所有位。
- en: 2.  Clear all the bits in the destination operand where you wish to insert the
    bit set.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  清除目标操作数中你希望插入位集的所有位。
- en: 3.  OR the bit set and destination operand together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  将位集和目标操作数进行 OR 操作。
- en: 'For example, suppose you have a value in bits 0 to 11 of W0 that you wish to
    insert into bits 12 to 23 of W1 without affecting any of the other bits in W1\.
    You would begin by stripping out bits 12 and higher from W0, then strip out bits
    12 to 23 in W1\. Next, you would shift the bits in W0 so the bit string occupied
    bits 12 to 23 of W0\. Finally, you’d OR the value in W0 into W1, as shown in the
    following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个值位于 W0 的第 0 到 11 位，你希望将其插入到 W1 的第 12 到 23 位中，而不影响 W1 中的其他位。你将首先从 W0
    中清除第 12 位及更高位，然后从 W1 中清除第 12 到 23 位。接下来，你会将 W0 中的位向左移，使得位串占据 W0 的第 12 到 23 位。最后，你会使用
    OR 操作将 W0 中的值与 W1 中的值合并，如下代码所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 12-2](chapter12.xhtml#fig12-2) shows the result of these four instructions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](chapter12.xhtml#fig12-2) 显示了这四条指令的结果。'
- en: '![](../images/Figure12-2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-2.jpg)'
- en: 'Figure 12-2: Inserting bits 0 to 11 of W0 into bits 12 to 23 of W1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：将 W0 的第 0 到 11 位插入到 W1 的第 12 到 23 位中
- en: Step 1 in [Figure 12-2](chapter12.xhtml#fig12-2) clears the U bits in W0\. After
    clearing the U bits, step 2 masks out the destination bit field (Y). Step 3 shifts
    the A bits (bits 0 to 11 in W0) 12 positions to the left to align them with the
    destination bit field. Step 4 ORs the value in W0 with the value in W1, leaving
    the final result in W1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](chapter12.xhtml#fig12-2) 中的步骤 1 清除了 W0 中的 U 位。清除 U 位后，步骤 2 屏蔽目标位字段（Y）。步骤
    3 将 A 位（W0 中的第 0 到 11 位）左移 12 位，将它们与目标位字段对齐。步骤 4 将 W0 中的值与 W1 中的值进行 OR 操作，最终结果保留在
    W1 中。'
- en: In [Figure 12-2](chapter12.xhtml#fig12-2), the desired bits (AAAAAAAAAAAA) form
    a bit string. However, this algorithm still works fine even if you’re manipulating
    a noncontiguous set of bits—you just have to create a bitmask with 1s in the appropriate
    places.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 12-2](chapter12.xhtml#fig12-2)中，所需的位（AAAAAAAAAAAA）形成了一个位串。然而，即使你操作的是一个非连续的位集合，这个算法仍然有效——你只需要创建一个在适当位置上有
    1 的位掩码。
- en: 'When working with bitmasks, it is incredibly poor programming style to use
    literal numeric constants, as in the past few examples. I’ve used “magic numbers”
    thus far because the examples have been simple and using literal constants is
    clearer in this context. However, you should always create symbolic constants
    in Gas. Combining these with constant expressions allows you to produce code that
    is much easier to read and maintain. The previous example code is more properly
    written as the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理位掩码时，使用字面数字常量是非常不好的编程风格，正如前面几个示例所示。到目前为止，我使用了“魔法数字”，因为示例很简单，使用字面常量在这种情况下更清晰。然而，你应该始终在
    Gas 中创建符号常量。将这些常量与常量表达式结合使用，可以生成更易于阅读和维护的代码。之前的示例代码应该更恰当地写成以下形式：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The use of the compile time NOT operator (~) for the bitmask inversion saves
    having to create another constant in the program that must be changed anytime
    you modify the BitMask constant. Maintaining two separate symbols whose values
    are dependent on each other is not good practice.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译时的 NOT 操作符（~）进行位掩码反转，可以避免在程序中创建另一个常量，该常量在修改 BitMask 常量时需要一起更改。维护两个相互依赖的符号不是一个好的实践。
- en: Of course, in addition to merging one bit set with another, the orr instruction
    is also useful for forcing bits to 1 in a bit string. By setting various bits
    in a source operand to 1, you can use the orr instruction to force the corresponding
    bits in the destination operand to 1.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了将一个位集与另一个合并外，orr 指令还可以用于将位强制设置为 1。在源操作数中将不同的位设置为 1，你可以使用 orr 指令将目标操作数中相应的位强制设置为
    1。
- en: You can use the orn (OR NOT) instruction to insert a 1 bit in a destination
    everywhere there is a 0 bit in the source. Other than that, the instruction behaves
    identically to orr.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 orn（OR NOT）指令在目标中插入 1 位，只要源中有 0 位。在其他方面，此指令与 orr 行为相同。
- en: 'If the and w1, w1, #~BitMask cannot be assembled because Gas will not accept
    the immediate constant, use bic w1, w1, #BitMask instead, as described in the
    next section.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 and w1, w1, #~BitMask 无法组装，因为 Gas 不接受立即数常量，请改用 bic w1, w1, #BitMask，如下一节所述。'
- en: 12.2.3 Clearing Bits
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3 清除位
- en: Whereas the orr instruction is useful for setting bits in a register, the bic
    instruction clears them
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而 orr 指令适用于设置寄存器中的位，bic 指令则用于清除它们。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: where Rd, Rl, and Rr are all W*n* or X*n*. The bics instruction sets the N and
    Z condition codes based on the value left in Rd. Everywhere a 1 bit appears in
    Rr, the bic instruction will clear the corresponding bit in Rl (storing the result
    into Rd).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd、Rl 和 Rr 都是 W*n* 或 X*n*。bics 指令根据 Rd 中的值设置 N 和 Z 条件码。在 Rr 中出现 1 位的每个位置，bic
    指令会清除 Rl 中相应的位（并将结果存储到 Rd 中）。
- en: The vector version of this instruction allows you to clear arbitrary bits in
    a 64- or 128-bit vector register
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令的向量版本允许你在 64 位或 128 位向量寄存器中清除任意的位。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where t = 8B for 64 bits and t = 16B for 128 bits. This instruction also has
    an immediate version
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当 t = 8B 时为 64 位，t = 16B 时为 128 位。此指令还有一个立即数版本。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: where t = 4H for 64 bits and t = 8H for 128 bits, or t = 2S for 64 bits and
    t = 4S for 128 bits. The optional shift value can be 0 or 8 for half-word lanes,
    or 0, 8, 16, or 24 for word lanes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当 t = 4H 时为 64 位，t = 8H 时为 128 位，或者 t = 2S 时为 64 位，t = 4S 时为 128 位。可选的移位值可以是
    0 或 8 用于半字道，或者 0、8、16 或 24 用于字道。
- en: 12.2.4 Inverting Bits
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.4 翻转位
- en: The eor instruction allows you to invert selected bits in a bit set (in general-purpose
    or vector registers). If you want to invert all the bits in a destination operand,
    the mvn (not) instruction is more appropriate; however, to invert selected bits
    while not affecting others, eor is the way to go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: eor 指令允许你翻转位集（通用寄存器或向量寄存器）中选定的位。如果你想翻转目标操作数中的所有位，mvn（非）指令更合适；然而，要翻转选定的位而不影响其他位，eor
    是更合适的选择。
- en: The eor instruction lets you manipulate known data in just about any way imaginable.
    For example, if you know that a field contains 0b1010, you can force that field
    to 0 by XORing it with 0b1010\. Similarly, you can force it to 0b1111 by XORing
    it with 0b0101.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`eor` 指令让你几乎可以用任何你能想象的方式操控已知数据。例如，如果你知道一个字段包含 `0b1010`，你可以通过与 `0b1010` 进行异或操作将该字段强制设置为
    0。同样，你也可以通过与 `0b0101` 进行异或操作将其强制设置为 `0b1111`。'
- en: Although this might seem like a waste because you can easily force this 4-bit
    string to 0 or all 1s by using and or orr, the eor instruction has two advantages.
    First, you are not limited to forcing the field to all 0s or all 1s; you can set
    these bits to any of the 16 valid combinations via eor. Second, if you need to
    manipulate other bits in the destination operand at the same time, and or orr
    may not be able to do the job.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来像是浪费，因为你可以通过使用 `and` 或 `orr` 指令轻松将这个 4 位字符串强制设置为 0 或全 1，但 `eor` 指令有两个优点。首先，你不仅限于将字段强制设置为全
    0 或全 1；你可以通过 `eor` 将这些位设置为 16 种有效组合中的任意一种。其次，如果你需要同时操作目标操作数中的其他位，`and` 或 `orr`
    可能无法完成这项工作。
- en: 'For example, suppose one field contains 0b1010, which you want to force to
    0, while another field in the same operand contains 0b1000, and you wish to increment
    that field by 1 (that is, set it to 0b1001). You cannot accomplish both operations
    with a single and or orr instruction, but you can do so with a single eor instruction:
    just XOR the first field with 0b1010 and the second field with 0b0001\. However,
    note that this trick works only if you know the current value of a bit set within
    the destination operand.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个字段包含 `0b1010`，你希望将其强制设置为 0，而同一操作数中的另一个字段包含 `0b1000`，你希望将该字段递增 1（即设置为
    `0b1001`）。你无法通过单一的 `and` 或 `orr` 指令同时完成这两个操作，但你可以通过一条 `eor` 指令实现：只需将第一个字段与 `0b1010`
    进行异或操作，将第二个字段与 `0b0001` 进行异或操作。然而，请注意，这个技巧仅在你知道目标操作数中某个位的当前值时才有效。
- en: The eon (exclusive–OR NOT) works just like eor, except that it inverts bits
    in the destination wherever a 0 bit appears in the right source operand.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`eon`（异或非）与 `eor` 的工作原理相同，只不过它在目标操作数中，当右侧源操作数为 0 时，会反转目标操作数中的位。'
- en: 12.2.5 Shift and Rotate
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.5 移位与旋转
- en: 'The shift and rotate instructions are another group you can use to manipulate
    and test bits. The standard and Neon instruction sets provide a wide range of
    shift and rotate instructions that allow you to rearrange bit data as needed:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 移位和旋转指令是另一组可以用来操控和测试位的指令。标准和 Neon 指令集提供了多种移位和旋转指令，允许你根据需要重新排列位数据：
- en: asr    Integer arithmetic shift right
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: asr    整数算术右移
- en: lsl    Integer logical shift left
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: lsl    整数逻辑左移
- en: lsr    Integer logical shift right
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: lsr    整数逻辑右移
- en: ror    Integer rotate right
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ror    整数右旋
- en: shl    Vector or scalar shift left or right
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: shl    向量或标量向左或向右移位
- en: ushl**,** sshl**,** ushr**, and** sshr    Vector or scalar shift right
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ushl**,** sshl**,** ushr**, 和** sshr    向量或标量右移
- en: sli    Vector or scalar shift left and insert
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: sli    向左移位向量或标量并插入
- en: sri    Vector or scalar shift right and insert
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: sri    向量或标量右移并插入
- en: In addition to these generic shifts and rotates, specialized variants saturate,
    round, narrow, and extend. Generally, those specialized instructions aren’t as
    useful for bit manipulation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些通用的移位和旋转指令，还有一些专用变体，如饱和、舍入、狭窄和扩展。通常，这些专用指令对于位操作并不那么有用。
- en: The integer shift and rotate instructions (those that operate on general-purpose
    registers) are quite useful for moving bits into their final position when constructing
    bit strings from multiple sources. As you saw in section 2.12, “Bit Fields and
    Packed Data,” on [page 85](chapter2.xhtml#pg_85), you can use the shift and rotate
    instructions (along with the logical instructions) to pack and unpack data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 整数移位和旋转指令（那些作用于通用寄存器的指令）在将位移到最终位置时非常有用，尤其是在从多个源构造位字符串时。如你在第 2.12 节《位字段和打包数据》中看到的，在
    [第 85 页](chapter2.xhtml#pg_85)，你可以使用移位和旋转指令（配合逻辑指令）来打包和解包数据。
- en: However, the biggest problem with the shift and rotate instructions is that
    they don’t provide an option to set the condition codes. For example, on many
    other CPUs (including the 32-bit ARM instruction set), the last bit shifted out
    of a register during a shift or rotate instruction winds up in the carry flag.
    The instructions typically set the Z and N flags, based on the final result. This
    is convenient for many operations, particularly those that use a loop to process
    each bit in the register; you could, for example, shift the bits out of a register
    by using a shift-right instruction, capture the output bit in the carry (using
    bcc or bcs to test the bit), and also be able to test the zero flag to see whether
    any more (set) bits are left in the register. This is not possible (with a single
    shift or rotate instruction) on the ARM.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，移位和旋转指令的最大问题是它们没有提供设置条件码的选项。例如，在许多其他 CPU（包括 32 位 ARM 指令集）中，移位或旋转指令将最后移出寄存器的比特存储在进位标志中。这些指令通常根据最终结果设置
    Z 和 N 标志。这对于许多操作非常方便，特别是那些使用循环处理寄存器中每个比特的操作；例如，你可以通过使用右移指令将比特从寄存器中移出，将输出比特捕获到进位标志（使用
    bcc 或 bcs 测试该比特），并且还能测试零标志以检查寄存器中是否还有更多（设置）比特。这在 ARM 上是不可能的（通过单个移位或旋转指令）。
- en: This rule has one exception. Although the shifts do not affect the carry flag,
    the adds instruction does. Using an instruction such as
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个例外。虽然移位不会影响进位标志，但 adds 指令会。使用像这样的指令：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: is equivalent to a shift left (by 1 bit) on W0, setting all the condition code
    flags (including capturing the bit shifted out of bit 31 in the carry flag). The
    adcs instruction behaves like a “rotate through carry by 1 bit” instruction (see
    section 8.1.11.1, “Shift Left,” on [page 467](chapter8.xhtml#pg_467)). Because
    [Chapters 2](chapter2.xhtml) and [8](chapter8.xhtml) covered the use of the shift
    instructions to insert and extract bit data (packed fields), this chapter doesn’t
    consider that further.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于对 W0 执行左移（1 位），设置所有条件码标志（包括将从第 31 位移出的位捕获到进位标志中）。adcs 指令的行为类似于“通过进位旋转 1 位”指令（请参见第
    8.1.11.1 节，“左移”，在[第467页](chapter8.xhtml#pg_467)）。由于[第 2 章](chapter2.xhtml)和[第
    8 章](chapter8.xhtml)已经涵盖了使用移位指令插入和提取比特数据（打包字段），本章不再进一步讨论。
- en: 'The vector shift instructions warrant further discussion because they include
    interesting variants (sli and sri) and don’t provide rotate instructions. Simulating
    a vector rotate left takes three instructions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 向量移位指令值得进一步讨论，因为它们包括有趣的变体（sli 和 sri），并且没有提供旋转指令。模拟向量左旋转需要三条指令：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The biggest problem with this code is that it takes an extra register to hold
    a temporary result.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码的最大问题是它需要一个额外的寄存器来保存临时结果。
- en: 'Here are the instructions to implement a vector rotate right:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现向量右旋转的指令：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See section 11.6.4, “Shift and Insert,” on [page 652](chapter11.xhtml#pg_652)
    for more information about the sli and sri instructions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 sli 和 sri 指令的更多信息，请参阅第 11.6.4 节，“移位与插入”，在[第652页](chapter11.xhtml#pg_652)。
- en: 'Because the vector shift instructions operate only on lanes, you cannot directly
    shift all 128 bits of a vector register with a single instruction. With five instructions,
    however, you can pull it off:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量移位指令仅作用于通道，因此无法通过单个指令直接对所有 128 位的向量寄存器进行移位。然而，通过五条指令，你可以完成它：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I’ll leave it up to you to do the shift-right operation, which is just a straightforward
    modification of the shl code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我将留给你去执行右移操作，它只是对 shl 代码的简单修改。
- en: 12.2.6 Conditional Instructions
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.6 条件指令
- en: The csel, csinc/cinc, csinv/cinv, cset, and csetm instructions are also useful
    for manipulating bits. In particular, cset and csetm can help you initialize a
    register with 0, 1, or all 1 bits based on the condition codes. All these instructions
    are useful for dealing with operations that have set the condition codes (see
    section 12.3, “Flag Modification by Arithmetic and Logical Instructions,” on [page
    715](chapter12.xhtml#pg_715)). These conditional instructions have no vector equivalents.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: csel、csinc/cinc、csinv/cinv、cset 和 csetm 指令对于操作比特也非常有用。特别是，cset 和 csetm 可以根据条件码帮助你初始化寄存器为
    0、1 或全 1 比特。所有这些指令对于处理已设置条件码的操作非常有用（请参见第 12.3 节，“算术与逻辑指令对标志的修改”，在[第715页](chapter12.xhtml#pg_715)）。这些条件指令没有向量等效指令。
- en: 12.2.7 Counting Bits
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.7 计数比特
- en: The cls and clz instructions allow you to count leading 1 and 0 bits (*leading*
    means from the HO bit position down to the LO bit position). The cnt instruction
    (population count) counts all the set bits in the byte lanes in a (vector) register.
    The syntax for these instructions is
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: cls 和 clz 指令允许你计算前导 1 位和 0 位（*前导*指从 HO 位位置到 LO 位位置）。cnt 指令（人口计数）计算（向量）寄存器中字节通道中的所有已设置位。这些指令的语法如下：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where Rd and Rs are W*n* or X*n;* t1 is 8B, 16B, 4H, 8H, 2S, or 4S; and t2 is
    8B or 16B. For the vector instructions, if the operand is 8B, 4H, or 2S, the instruction
    operates only on the LO 64 bits of the vector register.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 和 Rs 是 W*n* 或 X*n*；t1 是 8B、16B、4H、8H、2S 或 4S；t2 是 8B 或 16B。对于向量指令，如果操作数是
    8B、4H 或 2S，指令仅在向量寄存器的 LO 64 位上操作。
- en: The cls instruction (general-purpose register form) counts the number of leading
    sign bits in Rs and stores this count into Rd. This instruction counts the number
    of bits (below the HO bit) that match the HO bit. Note that the sign (HO) bit
    is not included in the count.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: cls 指令（通用寄存器形式）计算 Rs 中前导符号位的数量，并将该计数存储到 Rd 中。该指令计算与 HO 位匹配的位数（HO 位以下的位）。请注意，符号（HO）位不包括在计数中。
- en: The clz instruction works the same way but counts the number of leading 0 bits
    including the sign bit. To count the actual number of leading 1 bits (including
    the HO sign bit), invert the source register value and use the clz instruction
    to count 0 bits.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: clz 指令的作用相同，但会计算包括符号位在内的前导 0 位的数量。要计算实际的前导 1 位数量（包括 HO 符号位），请反转源寄存器的值并使用 clz
    指令计算 0 位。
- en: The vector versions of the cls and clz instructions count the number of leading
    1s or 0s in each lane of the source register, in the same manner as the scalar
    versions, and stores this count into the corresponding lane of the destination
    register.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: cls 和 clz 指令的向量版本以与标量版本相同的方式计算源寄存器中每个通道的前导 1 或 0 位的数量，并将此计数存储到目标寄存器的相应通道中。
- en: The cnt instruction counts the number of set bits in each byte (lane) of the
    source register and stores the bit count into the corresponding lane of the destination
    register. To find the total population (bit) count for the vector register (64
    or 128 bits), use the addv instruction to sum up all the bytes within the destination
    register. To compute the population count for hwords, words, or dwords, use an
    addp instruction to add the pairs of bytes (to produce hword counts). You can
    use a second addp instruction (again, on pairs of bytes, producing an array of
    byte results) to count the pairs of hwords, producing word counts, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: cnt 指令计算源寄存器中每个字节（通道）中已设置位的数量，并将该位数存储到目标寄存器的相应通道中。要查找向量寄存器（64 位或 128 位）的总人口（位）计数，请使用
    addv 指令将目标寄存器中的所有字节求和。要计算 hwords、words 或 dwords 的人口计数，请使用 addp 指令将字节对加起来（以生成 hword
    计数）。你可以使用第二个 addp 指令（同样是在字节对上，生成字节结果数组）来计数 hwords 对，生成 word 计数，依此类推。
- en: 12.2.8 Bit Reversal
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.8 位反转
- en: 'The rbit instruction reverses the bits in its source operand and stores the
    reversed result into the destination operand. The syntax is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: rbit 指令会反转源操作数中的位，并将反转后的结果存储到目标操作数中。其语法如下：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With 32-bit register operands, this instruction swaps the bits in positions
    0 and 31, 1 and 30, 2 and 29, ..., and 15 and 16\. With 64-bit operands, rbit
    swaps the bits in positions 0 and 63, 1 and 62, 2 and 61, ..., and 31 and 32\.
    With vector operands, it reverses the bits in each byte lane of the source vector
    register, storing the results into the corresponding byte lane in the destination
    vector register.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 32 位寄存器操作数，该指令交换位置 0 和 31 的位，1 和 30 的位，2 和 29 的位，...，以及 15 和 16 的位。对于 64
    位操作数，rbit 会交换位置 0 和 63 的位，1 和 62 的位，2 和 61 的位，...，以及 31 和 32 的位。对于向量操作数，它会反转源向量寄存器中每个字节通道的位，并将结果存储到目标向量寄存器的相应字节通道中。
- en: 'The vector variant of this instruction reverses only the bits in byte lanes.
    To reverse the bits in a 16-, 32-, or 64-bit object, also execute an 8-bit lane
    rev16, rev32, or rev64 instruction (before or) after the rbit. For example, the
    following two instructions reverse all the bits in a 64-bit vector register:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令的向量变体仅反转字节通道中的位。要反转 16 位、32 位或 64 位对象中的位，还需要执行 8 位通道的 rev16、rev32 或 rev64
    指令（在 rbit 之前或之后）。例如，以下两个指令会反转 64 位向量寄存器中的所有位：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You would use similar code (with rev32) to reverse the bits in two double-words
    in a vector register.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的代码（使用 rev32）来反转向量寄存器中两个双字的位。
- en: 12.2.9 Bit Insertion and Selection
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.9 位插入与选择
- en: 'The bif (bit insert if false), bit (bit insert if true), and bsl (bit select)
    instructions allow you to manipulate individual bits in a vector register. These
    instructions have the following syntax:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: bif（如果为假则插入位）、bit（如果为真则插入位）和 bsl（位选择）指令允许你操作向量寄存器中的单个位。这些指令的语法如下：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The bif instruction first considers the mask register; everywhere a 0 bit appears
    in Vm, the instruction copies the corresponding bit in Vs (source) to the same
    bit position in Vd (destination). Everywhere a 1 appears in Vm, the bif instruction
    leaves the corresponding bit in Vd unchanged.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: bif 指令首先考虑掩码寄存器；Vm 中出现 0 位的地方，指令将对应的位从 Vs（源）复制到 Vd（目标）的相同位置。Vm 中出现 1 位的地方，bif
    指令保持 Vd 中对应的位不变。
- en: The bit instruction does the same thing as bif, except it copies bits on the
    opposite condition (where there is a 1 in Vm).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: bit 指令与 bif 指令相同，唯一不同的是它在相反的条件下复制位（当 Vm 中为 1 时）。
- en: The bsl instruction uses the (original) bits in Vd to select the corresponding
    bit in Vs1 or Vs0. Everywhere a 1 appears in Vd, bsl will copy the corresponding
    bit from Vs1 to Vd; everywhere a 0 appears in Vd, bsl will copy the corresponding
    bit from Vs0 to Vd.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: bsl 指令使用 Vd 中的（原始）位来选择 Vs1 或 Vs0 中对应的位。Vd 中出现 1 的位置，bsl 将从 Vs1 中复制相应的位到 Vd；Vd
    中出现 0 的位置，bsl 将从 Vs0 中复制相应的位到 Vd。
- en: 12.2.10 Bit Extraction with ubfx
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.10 使用 ubfx 的位提取
- en: The ubfx instruction allows you to extract any number of bits from a position
    in a source register, moving those bits to bit 0 in the destination register.
    The syntax is
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ubfx 指令允许你从源寄存器中的某一位置提取任意数量的位，并将这些位移至目标寄存器的第 0 位。语法为：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: where Rd and Rs are both either W*n* or X*n*, lsb is the starting bit position
    for the extraction, and len is the size of the bit string to extract. The sum
    of lsb and len must not exceed the register size.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 和 Rs 都可以是 W*n* 或 X*n*，lsb 是提取的起始位位置，len 是要提取的位串大小。lsb 和 len 的总和不得超过寄存器的大小。
- en: The ubfx instruction extracts len bits from Rs, starting at bit position lsb.
    It stores this bit string into Rd (at bit 0) and zeros out the HO bits of Rd.
    For example
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ubfx 指令从 Rs 中提取 len 位，从 lsb 位开始。它将该位串存储到 Rd（从位 0 开始），并将 Rd 的高位清零。例如：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: copies bits 8 through 23 from X1 to bits 0 through 15 in X0 (and zeros out bits
    16 through 63 in X0).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将 X1 中的第 8 到 23 位复制到 X0 中的第 0 到 15 位（并将 X0 中的第 16 到 63 位清零）。
- en: '#### 12.2.11 Bit Movement with ubfiz'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 12.2.11 使用 ubfiz 的位移动'
- en: The ubfiz (unsigned bit field insert in zero) copies bits from the LO bits of
    a source register to any other position in the destination register, as the converse
    of the ubfx instruction. The syntax for this instruction is
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ubfiz（无符号位域插入零）将来自源寄存器的低位复制到目标寄存器的任何位置，作为 ubfx 指令的反向操作。该指令的语法为：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: where Rd and Rs are both either W*n* or X*n*, posn is the destination location
    where bit 0 from Rs will be moved, and len is the size of the bit string. For
    example
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 和 Rs 都可以是 W*n* 或 X*n*，posn 是目标位置，Rs 中的第 0 位将被移动到该位置，len 是位串的大小。例如：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: copies bits 0 through 7 from W0 to bits 12 through 19 in W1.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将 W0 中的第 0 到 7 位复制到 W1 中的第 12 到 19 位。
- en: 12.2.12 Bit Movement with ubfm
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.12 使用 ubfm 的位移动
- en: The ubfm instruction (unsigned bit field move) copies the LO bits from a source
    register to an arbitrary position in the destination register (and puts 0s everywhere
    else in the destination register). The syntax is
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ubfm 指令（无符号位域移动）将源寄存器中的低位复制到目标寄存器中的任意位置（并将目标寄存器中的其他位置填充为 0）。该指令的语法为：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'where Rd and Rs are both either W*n* or X*n*, immr and imms are values in the
    range 0 to 31 for 32-bit operations or 0 to 63 for 64-bit operations. This instruction
    does one of two operations based on the values of immr and imms:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 和 Rs 都可以是 W*n* 或 X*n*，immr 和 imms 的值范围是 32 位操作为 0 到 31，64 位操作为 0 到 63。此指令根据
    immr 和 imms 的值执行以下两种操作之一：
- en: If immr ≤ imms, take bits immr through imms and rotate right by immr.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 immr ≤ imms，则取 immr 到 imms 之间的位，并向右旋转 immr 位。
- en: If immr > imms, take imms + 1 LO bits and rotate right by immr.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 immr > imms，则取 imms + 1 个低位并向右旋转 immr 位。
- en: 'The ubfm instruction is the basis for many instructions (aliases) in the ARM
    instruction set: lsl Rd, Rs, #shift is equivalent to'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 'ubfm 指令是许多 ARM 指令集中的基础指令（别名）：lsl Rd, Rs, #shift 等价于'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: where Rsize is the register size (32 or 64).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rsize 是寄存器的大小（32 位或 64 位）。
- en: 'Meanwhile, lsr Rd, Rs, #shift is equivalent to'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '与此同时，lsr Rd, Rs, #shift 等价于'
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'and ubfiz Rd, Rs, #lsb, #width is equivalent to'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '并且 ubfiz Rd, Rs, #lsb, #width 等价于'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'where Rsize is the register size (32 or 64). Finally, ubfx Rd, Rs, #lsb, #width
    is equivalent to'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '其中 Rsize 是寄存器的大小（32 或 64）。最后，ubfx Rd, Rs, #lsb, #width 等价于'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where lsb is the LO bit of the bit string to move and width is the number of
    bits to move.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 lsb 是要移动的位串的 LO 位，width 是要移动的位数。
- en: 12.2.13 Bit Extraction with extr
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.13 使用 extr 进行位提取
- en: The extr instruction allows you to extract a bit string across a pair of registers,
    using the syntax
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: extr 指令允许你从一对寄存器中提取一个位串，语法为
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where Rd, Rl, and Rr are all W*n* or X*n*, and posn is a constant in the range
    0 to the register size – 1 (31 or 63).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd、Rl 和 Rr 都是 W*n* 或 X*n*，而 posn 是一个常数，范围从 0 到寄存器大小减 1（31 或 63）。
- en: This instruction begins by concatenating the Rl and Rr registers to form a 64-
    or 128-element bit string. It then extracts 32 or 64 bits (depending on the register
    sizes) from this string, starting at bit position posn.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令首先将 Rl 和 Rr 寄存器连接起来，形成一个 64 位或 128 位的位串。然后，它从该位串中提取 32 或 64 位（具体取决于寄存器大小），从位位置
    posn 开始。
- en: NOTE
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* ror *(immediate) instruction is an alias of* extr *obtained by setting*
    Rl *and* Rr *to the same register.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*ror*（立即数）指令是*extr*的别名，获取方法是将*Rl*和*Rr*设置为相同的寄存器。'
- en: 12.2.14 Bit Testing with tbz and tbnz
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.14 使用 tbz 和 tbnz 进行位测试
- en: 'The tbz (test bit zero) and tbnz (test bit not zero) instructions allow you
    to branch to a location based on whether a particular bit is set in a register,
    using the following syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: tbz（测试位零）和 tbnz（测试位非零）指令允许你根据寄存器中是否设置了特定的位来分支到某个位置，使用以下语法：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These instructions test the bit specified by imm in Rs to see if it is a 0 or
    a 1\. The tbz instruction transfers control to the specified target label if it
    is 0 (falling through if it is 1), while tbnz transfers control to the specified
    target label if it is 1 (falling through if it is 0).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令测试 Rs 中由 imm 指定的位，看它是 0 还是 1。tbz 指令会将控制转移到指定的目标标签（如果位为 0 时），而 tbnz 则在位为
    1 时将控制转移到指定目标标签（如果位为 0 时则继续执行）。
- en: You can use these instructions to turn any register into a 32- or 64-bit “pseudo
    condition code register,” allowing you to branch based on whether a particular
    bit in that register is set or clear. Though no instructions will automatically
    set or clear these “condition codes,” you can use any of the bit-manipulation
    instructions in this chapter to manipulate those pseudo condition codes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些指令将任何寄存器变成一个 32 位或 64 位的“伪条件码寄存器”，使你可以根据该寄存器中特定位是否被设置或清除来进行分支。尽管没有指令会自动设置或清除这些“条件码”，你可以使用本章中的任何位操作指令来操作这些伪条件码。
- en: Don’t forget that you can also use the cbz (compare and branch if zero) and
    cbnz (compare and branch if not zero) instructions to compare a register against
    0 and transfer control if it is (cbz), or is not (cbnz), equal to 0\. This is
    useful after instructions such as addv, orr, or other instructions that don’t
    set the Z flag, to see if they’ve produced a zero (or nonzero) result.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了你还可以使用 cbz（如果为零则比较并分支）和 cbnz（如果不为零则比较并分支）指令，将寄存器与 0 进行比较，并在其等于 0 时（cbz）或不等于
    0 时（cbnz）转移控制。这在 addv、orr 或其他不设置 Z 标志的指令之后特别有用，用来查看它们是否产生了零（或非零）结果。
- en: 12.3 Flag Modification by Arithmetic and Logical Instructions
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3 算术和逻辑指令对标志的修改
- en: In the previous sections, the instructions manipulated bits in general-purpose
    and vector registers. Although the PSR is not a general-purpose register, remember
    that the ands, bics, and tst instructions set the N and Z flags based on the computed
    result. If the HO (sign) bit of the result is 1, these instructions set the N
    flag; if the result is 0, these instructions set the Z flag. Otherwise, they clear
    the flags.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，指令操作了通用寄存器和向量寄存器中的位。尽管 PSR 不是通用寄存器，但请记住，ands、bics 和 tst 指令会根据计算结果设置
    N 和 Z 标志。如果结果的 HO（符号）位为 1，这些指令会设置 N 标志；如果结果为 0，这些指令会设置 Z 标志。否则，它们会清除这些标志。
- en: You can also use the adds, adcs, subs, sbcs, negs, ngcs, cmp, ccmp, and ccmn
    instructions to set the flags. In particular, keep in mind that
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 adds、adcs、subs、sbcs、negs、ngcs、cmp、ccmp 和 ccmn 指令来设置标志。特别要记住的是
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: shifts the value in Rn to the left one bit and moves the (original) HO bit into
    the carry flag. This instruction sets the overflow flag if the two original HO
    bits contain 0b01 or 0b10\. It sets the negative flag if the resulting HO bit
    is 1\. Finally, of course, it sets the zero flag if the result of the addition
    is 0.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Rn 中的值向左移动一位，并将（原始的）HO 位移入进位标志。如果两个原始的 HO 位包含 0b01 或 0b10，则该指令会设置溢出标志。如果结果的
    HO 位是 1，则会设置负数标志。最后，如果加法结果为 0，当然会设置零标志。
- en: Also note that the instruction
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请注意，指令
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: is equivalent to a “rotate left Rn 1 bit through the carry flag” instruction.
    You can use this to set the carry flag based on the HO bit of Rn and capture the
    previous carry flag value into the LO bit of Rn.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于“将 Rn 向左旋转 1 位通过进位标志”指令。您可以使用此指令根据 Rn 的 HO 位设置进位标志，并将先前的进位标志值捕获到 Rn 的 LO
    位。
- en: Keep in mind that only the arithmetic and logical instructions that operate
    on general-purpose registers (and have the s suffix) affect the flags. In particular,
    the vector instructions do not affect the flags.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有对通用寄存器进行操作的算术和逻辑指令（并且带有 s 后缀）才会影响标志位。特别地，向量指令不会影响标志位。
- en: 'While it’s not an arithmetic or logical instruction, the mrs (move register
    to status) instruction, with the destination field NZCV, sets all the flags to
    the values found in bits 28–31 of the general-purpose register. This provides
    a quick way to create a multiway branch from 4 bits. Consider the following code
    (taken from section 11.10.4, “Vector Comparison Results,” on [page 691](chapter11.xhtml#pg_691)):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不是算术或逻辑指令，但 mrs（将寄存器值移入状态寄存器）指令，通过目标字段 NZCV，将所有标志设置为通用寄存器第 28 到第 31 位的值。这提供了一种快速的方式，通过
    4 位创建多重分支。考虑以下代码（取自第 11.10.4 节，“向量比较结果”，见 [第 691 页](chapter11.xhtml#pg_691)）：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now you can test N, Z, C, and V flags to see if lanes 3, 2, 1, or 0 (respectively)
    in V1 were equal to the corresponding lanes in V2.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以测试 N、Z、C 和 V 标志，看看 V1 中的第 3、2、1 或 0 号通道是否与 V2 中对应的通道相等。
- en: This section has provided a generic introduction to setting the condition code
    flags to capture a bit value. Because instructions with an s suffix affect the
    flags differently, it is important to discuss how instructions affect the individual
    condition code flags; the following sections handle that task.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一个通用的介绍，说明如何设置条件码标志以捕获位值。由于带有 s 后缀的指令对标志位的影响不同，因此讨论指令如何影响各个条件码标志非常重要；接下来的章节将处理这一任务。
- en: 12.3.1 The Zero Flag
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1 零标志
- en: The zero flag (Z) setting is one of the most important results produced by the
    ands instruction. Indeed, programs reference this flag so often after the ands
    instruction that ARM added a separate tst instruction whose main purpose is to
    logically AND two results and set the flags without otherwise affecting either
    instruction operand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志（Z）设置是 ands 指令生成的最重要结果之一。事实上，程序在 ands 指令执行后非常频繁地引用此标志，因此 ARM 添加了一个单独的 tst
    指令，其主要目的是逻辑与两个结果并设置标志，而不会影响任何指令的操作数。
- en: NOTE
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Technically,* tst *is not a new instruction, but rather an alias for* ands
    *when the destination register is WZR or XZR.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，* tst *并不是一条新指令，而是* ands *的别名，当目标寄存器为 WZR 或 XZR 时。*'
- en: 'The zero flag can be used to check three things after the execution of an ands
    or tst instruction: whether a particular bit in an operand is set, whether at
    least one of several bits in a bit set is 1, and whether an operand is 0\. The
    first use case is actually a special instance of the second, in which the bit
    set contains only a single bit. The following paragraphs explore each of these
    uses.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 零标志可用于检查执行 ands 或 tst 指令后的三件事：操作数中的某一特定位是否被设置，多个位集合中是否至少有一个位为 1，以及操作数是否为 0。第一种用法实际上是第二种用法的一个特例，其中位集合仅包含一个位。接下来的段落将探讨这些用途的每一种。
- en: 'To test whether a particular bit is set in a given operand, ands or tst an
    operand with a constant value containing a single set bit you wish to test. This
    clears all the other bits in the operand, leaving a 0 in the bit position under
    test if the operand contained a 0 in that bit position and a 1 if it contained
    a 1\. Because all other bits in the result are 0, the entire result will be 0
    if that particular bit is 0; the entire result will be nonzero if that bit position
    contains a 1\. The ARM CPU reflects this status in the zero flag (Z = 1 indicates
    a 0 bit; Z = 0 indicates a 1 bit). The following instruction sequence demonstrates
    how to test if bit 4 is set in W0:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试某一特定的位是否在给定操作数中被设置，可以使用 `ands` 或 `tst` 指令将操作数与包含单个设置位的常数值进行按位与运算。这样可以清除操作数中的所有其他位，如果操作数中该位位置为0，则测试位的结果为0，如果为1，则结果为1。因为结果中的所有其他位都是0，所以如果该特定位为0，则整个结果为0；如果该位为1，则结果为非零。ARM
    CPU 会在零标志位（Z = 1 表示位为0；Z = 0 表示位为1）中反映这一状态。以下指令序列演示了如何测试 W0 中的第4位是否被设置：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also use the ands and tst instructions to see whether any one of several
    bits is set. Simply supply a constant that has a 1 in all the positions you want
    to test (and 0s everywhere else). ANDing an operand with such a constant will
    produce a nonzero value if one or more of the bits in the operand under test contain
    a 1\. The following example tests whether the value in W0 contains a 1 in bit
    positions 1 and 2:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `ands` 和 `tst` 指令来检查多个位中的任何一个是否被设置。只需提供一个常数，该常数在你想要测试的所有位置上为1，其他位置为0。将操作数与这种常数进行按位与运算，如果操作数中被测试的位包含1，则结果为非零值。以下示例测试
    W0 中的值在第1位和第2位是否包含1：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You cannot use a single ands or tst instruction to see whether all the corresponding
    bits in the bit set are equal to 1\. To accomplish this, you must first mask out
    the bits that are not in the set and then compare the result against the mask
    itself. If the result is equal to the mask, all the bits in the bit set contain
    1s. You must use the ands instruction for this operation because the tst instruction
    does not modify the result. The following example checks whether all the bits
    in a bit set (bitMask) are equal to 1:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能仅使用一条 `ands` 或 `tst` 指令来检查位集中的所有对应位是否都等于1。要实现这一点，必须先屏蔽掉不在位集中的位，然后将结果与掩码本身进行比较。如果结果等于掩码，则位集中的所有位都包含1。你必须使用
    `ands` 指令来完成此操作，因为 `tst` 指令不会修改结果。以下示例检查位集（bitMask）中的所有位是否都等于1：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, once you stick the cmp instruction in there, you don’t really have
    to check whether all the bits in the bit set contain 1s. You can check for any
    combination of values by specifying the appropriate value as the operand to cmp.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦你在其中使用了 `cmp` 指令，就不需要检查位集中所有位是否都是1。你可以通过指定适当的值作为 `cmp` 的操作数来检查任何组合的值。
- en: 'The tst and ands instructions will set the zero flag in the preceding code
    sequences only if all the bits in W0 (or other destination operand) have 0s in
    the positions where 1s appear in the constant operand. This suggests another way
    to check for all 1s in the bit set: invert the value in W0 prior to using the
    ands or tst instruction. In this case, if the zero flag is set, you know that
    the (original) bit set contained all 1s. For example, the following code checks
    whether any bits specified by 1s in a bitmask are nonzero:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 W0（或其他目标操作数）中在常数操作数中为1的位置上的所有位都为0时，`tst` 和 `ands` 指令才会设置零标志。这表明另一种检查位集中的所有位是否为1的方法：在使用
    `ands` 或 `tst` 指令之前，先对 W0 的值进行取反。在这种情况下，如果零标志被设置，就知道（原始的）位集包含了所有的1。例如，以下代码检查位掩码中由1指定的任何位是否非零：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The previous paragraphs all suggest that the bitMask (the source operand) is
    a constant, but you can use a variable or other register too. Simply load that
    variable or register with the appropriate bitmask before you execute the tst,
    ands, or cmp instructions in the preceding examples.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落都建议位掩码（源操作数）是常数，但你也可以使用变量或其他寄存器。只需在执行前面的 `tst`、`ands` 或 `cmp` 指令之前，将该变量或寄存器加载适当的位掩码。
- en: 12.3.2 The Negative Flag
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2 负标志
- en: The tst and ands instructions will also set the negative flag (N, also known
    as the sign flag) if the HO bit of the result is set. This allows you to test
    two individual bits in a register, assuming one of those bits is the HO bit. When
    using these instructions, the mask value must contain a 1 in the HO bit as well
    as in the bit position of the other bit you want to test. After executing the
    tst or ands instruction, you must check the N flag before testing the Z flag (as
    the Z flag will be clear if the HO bit was set).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: tst 和 ands 指令如果结果的 HO 位被设置，还会设置负数标志（N，也称为符号标志）。这允许你测试寄存器中的两个独立位，假设其中一个是 HO 位。使用这些指令时，掩码值必须在
    HO 位和你想要测试的另一个位位置上都包含 1。执行 tst 或 ands 指令后，你必须先检查 N 标志，再测试 Z 标志（因为如果 HO 位被设置，Z
    标志会被清除）。
- en: If the HO bit is set and you also want to see whether the other bit is set,
    you must test that other bit again (or use the cmp instruction, as in the previous
    section).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HO 位被设置，并且你还想查看另一个位是否被设置，你必须再次测试该位（或者使用 cmp 指令，如前一节所述）。
- en: 12.3.3 The Carry and Overflow Flags
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3 进位标志和溢出标志
- en: The logical instructions (ands and tst) that affect the flags always clear the
    carry and overflow flags. However, the arithmetic instructions (adds, adcs, subs,
    sbcs, negs, ngcs, cmp, ccmp, and ccmn) modify these flags. In particular, when
    the two source operands are the same, adds and adcs shift the HO bit of the (original)
    source into the carry flag.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 影响标志的逻辑指令（ands 和 tst）会清除进位标志和溢出标志。然而，算术指令（adds、adcs、subs、sbcs、negs、ngcs、cmp、ccmp
    和 ccmn）会修改这些标志。特别地，当两个源操作数相同时，adds 和 adcs 会将（原始）源的 HO 位移入进位标志。
- en: 'Negating the most negative value (for example, the word value 0x80000000) will
    set the overflow flag:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对最小负值（例如，字值 0x80000000）取反将设置溢出标志：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Refer to the ARM AARCH64 documentation to determine how the various instructions
    affect the carry and overflow flags. Note that many instructions will not affect
    these two flags (especially the overflow flag) even though they affect the N and
    Z flags.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 ARM AARCH64 文档，以确定各种指令如何影响进位标志和溢出标志。请注意，许多指令不会影响这两个标志（特别是溢出标志），即使它们会影响 N
    标志和 Z 标志。
- en: 12.4 Packing and Unpacking Bit Strings
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4 打包和解包位字符串
- en: Inserting a bit string into an operand and extracting a bit string from an operand
    are common operations. [Chapter 2](chapter2.xhtml) provided simple examples of
    packing and unpacking such data; this section formally describes how to do this,
    now that you’ve learned more instructions and have more tools to work with.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将位字符串插入操作数中或从操作数中提取位字符串是常见操作。[第2章](chapter2.xhtml)提供了简单的打包和解包数据的例子；这一节正式描述了如何执行这些操作，现在你已经学会了更多指令并拥有更多工具。
- en: 12.4.1 Inserting One Bit String into Another
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1 将一个位字符串插入另一个位字符串
- en: For the purposes of this chapter, I will assume that we’re dealing with bit
    strings that fit within a byte, half-word, word, or double-word operand. Large
    bit strings that cross object boundaries require additional processing; I discuss
    bit strings that cross double-word boundaries later in this section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的讨论假设我们处理的是适合于字节、半字、字或双字操作数的位字符串。跨越对象边界的大型位字符串需要额外的处理；我将在本节稍后讨论跨越双字边界的位字符串。
- en: When packing and unpacking a bit string, you must consider its starting bit
    position and length. The *starting bit position* is the bit number of the LO bit
    of the string in the operand. The *length* is the number of bits in the string.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包和解包位字符串时，你必须考虑它的起始位位置和长度。*起始位位置*是字符串在操作数中的 LO 位的位号。*长度*是字符串中的位数。
- en: To insert (pack) data into a destination operand, start with a bit string of
    the appropriate length that is right-justified (starts in bit position 0) and
    zero-extended to 8, 16, 32, or 64 bits. Next, insert this data at the appropriate
    starting position in another operand that is 8, 16, 32, or 64 bits wide. The destination
    bit positions are not guaranteed to contain any particular value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据插入（打包）到目标操作数中，首先使用一个合适长度的位字符串，它是右对齐的（从位位置 0 开始），并且扩展为 8、16、32 或 64 位。接下来，将此数据插入到另一个宽度为
    8、16、32 或 64 位的操作数中的适当起始位置。目标位位置的值没有保证。
- en: The first two steps (which can occur in any order) are to clear out the corresponding
    bits in the destination operand and shift a copy of the bit string so that the
    LO bit begins at the appropriate bit position. The third step is to OR the shifted
    result with the destination operand. This inserts the bit string into the destination
    operand. [Figure 12-3](chapter12.xhtml#fig12-3) diagrams this process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure12-3.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: Inserting a bit string into a destination operand'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three instructions insert a bit string of known length into a
    destination operand, as shown in [Figure 12-3](chapter12.xhtml#fig12-3). These
    instructions assume that the source bit string is in W1 (with 0s in positions
    outside the bit string) and the destination operand is in W0:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For the special case when the destination bit position and bit string length
    are constants (known at assembly time), the ARM CPU provides an instruction to
    handle bit insertion for you: bfi (bit field insert). It has the following syntax'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: where Rd and Rs are both either W*n* or X*n*. The sum of posn and len must not
    exceed the register size (32 for W*n* and 64 for X*n*).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The bfi instruction takes the LO len bits of Rs and inserts them into the destination
    register (Rd) starting at bit position posn. Consider the instruction
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: assuming W0 contained 0x33333333 (the destination value) and W1 contained 0x1200
    (the insertion value). This would leave 0x31200333 in W0.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t know the length and the starting position while writing the program
    (that is, you have to calculate them at runtime), you must use several instructions
    to do a bit-string insertion. Suppose you have two values—a starting bit position
    for the field you’re inserting and a nonzero length value—and that the source
    operand is in W1 and the destination operand is in W0\. The mergeBits procedure
    in Listing 12-1 demonstrates how to insert a bit string from W1 into W0.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The mergeBits function is where the merging occurs. This code begins by generating
    a mask containing all 1 bits from location 0 to *n* – 1, where *n* is the length
    of the bit string to insert ❶. The code uses a simple mathematical trick to generate
    these bits: if you compute 2*^n* and then subtract 1 from this value, the resulting
    value contains 1 bits in positions 0 to *n* – 1\. After generating this mask,
    the code positions the mask bits to the position where mergeBits will insert the
    bit string ❷. It then masks out (sets to 0) those bit positions in the destination
    location ❸.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: To complete the merge, mergeBits moves the bits to merge to the proper position
    and ORs those bits into the destination location (which contains 0s at that point)
    ❹. The mergeBits function assumes that the source bits (the bits to merge) form
    a bit string that is exactly *n* bits long (*n* being the value passed in X3)
    and is located in bit positions 0 to *n* – 1\. Note that if you need to handle
    bit-insertion values that might have 1 bits in positions *n* or greater, you should
    logically AND the value to merge (passed in X1) with the bitmask after shifting
    it ❹. The version of mergeBits in Listing 12-1 assumes that the val2Merge argument
    (X1) doesn’t contain any extra 1 bits.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成合并，mergeBits 将要合并的位移到正确的位置，并将这些位与目标位置（此时该位置包含 0）进行 OR 操作 ❹。mergeBits 函数假定源位（即要合并的位）形成一个正好长
    *n* 位的位串（*n* 是传递给 X3 的值），并位于 0 到 *n* - 1 的位位置。请注意，如果你需要处理可能在 *n* 或更大位置有 1 位的位插入值，你应该在将其与位掩码进行逻辑与运算后再移位
    ❹。第 12-1 列表中的 mergeBits 版本假定 val2Merge 参数（X1）不包含额外的 1 位。
- en: The asmMain function ❺ is a loop that steps through the ValueToMerge, MergeInto,
    LenInBits, and StartPosn arrays. This loop fetches these four values, prints them,
    and then calls the mergeBits function to merge the ValueToMerge entry into MergeInto.
    The LenInBits element contains the size (in bits) to merge, and the value from
    the StartPosn array is the bit position where the merger should take place.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: asmMain 函数 ❺ 是一个循环，遍历 ValueToMerge、MergeInto、LenInBits 和 StartPosn 数组。该循环获取这四个值，打印它们，然后调用
    mergeBits 函数将 ValueToMerge 的条目合并到 MergeInto 中。LenInBits 元素包含要合并的大小（以位为单位），而来自
    StartPosn 数组的值是合并应发生的位置。
- en: 'Here’s the build command and sample output for Listing 12-1:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第 12-1 列表的构建命令和示例输出：
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The mergeBits function is very general, allowing you to specify the bit string
    length and the destination position as variable parameter values. If the length
    and destination position values are constants within your code (a common special
    case), you can use a more efficient way to insert bits from one register into
    another: the bfm (bit field move) instruction. This instruction has the syntax'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: mergeBits 函数非常通用，允许你将位串长度和目标位置指定为可变参数。如果位串长度和目标位置在代码中是常量（这是一种常见的特殊情况），你可以使用更高效的方法将一个寄存器的位插入另一个寄存器：bfm（位域移动）指令。该指令的语法如下：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: where Rd and Rs are both either W*n* or X*n*, rotate is the number of rotate-right
    positions, and bitposn is the leftmost bit in the source (starting at bit 0) to
    move.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 和 Rs 都可以是 W*n* 或 X*n*，rotate 是旋转右移的位数，bitposn 是源中要移动的最左边的位（从位 0 开始）。
- en: This instruction rotates (a copy of) the LO bitposn bits in Rs the specified
    number of bit positions, then replaces the corresponding bits in Rd with these
    rotated bits.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将 Rs 中 LO 位的位置的位复制旋转指定数量的位位置，然后将这些旋转后的位替换到 Rd 中相应的位置。
- en: NOTE
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* bfi *instruction is an alias of* bfm *with a slight modification to the
    meaning of the two immediate operands (see the ARM documentation for more details).*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*bfi* 指令是 *bfm* 的别名，区别在于两个立即数操作数的含义略有不同（更多细节请参考 ARM 文档）。'
- en: The examples in this section assume that the bit string appears completely within
    a double-word (or smaller) object. This will always be the case if the bit string
    is less than or equal to 64 bits in length. However, if the length of the bit
    string plus its starting position (modulo 8) within an object is greater than
    64, the bit string will cross a double-word boundary within the object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例假设位串完全出现在一个双字（或更小）对象中。如果位串的长度小于或等于 64 位，这种情况总是成立。然而，如果位串的长度加上它在对象中起始位置的值（模
    8）大于 64，位串将跨越对象内的双字边界。
- en: 'Inserting such bit strings requires up to three operations: one to extract
    the start of the bit string (up to the first double-word boundary), one to copy
    whole double words (assuming the bit string is so long it consumes several double
    words), and one to copy leftover bits in the last double word at the end of the
    bit string. I’ll leave the implementation of this operation as an exercise for
    you.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 插入这样的位串需要最多三步操作：一是提取位串的起始部分（直到第一个双字边界），二是复制完整的双字（假设位串非常长，跨越多个双字），三是复制位串最后一个双字中的剩余位。我将把这个操作的实现留给你自己去完成。
- en: 12.4.2 Extracting a Bit String
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2 提取位串
- en: 'The previous section described how to insert one bit string into another. This
    section covers the converse operation: extracting a bit string from a larger string.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章节描述了如何将一个位串插入到另一个位串中。本节讨论相反的操作：从一个较大的位串中提取出一个位串。
- en: The bfxil (bit field extract and insert at low end) instruction extracts any
    number of bits (at any position) from a source register and copies those bits
    to the LO bit positions of a destination register. Its syntax is
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: bfxil（低端位提取和插入）指令从源寄存器提取任意数量的位（可以是任意位置的位），并将这些位复制到目标寄存器的低位位置。其语法为：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: where Rd and Rs are either W*n* or X*n* . The sum of posn and len must not exceed
    the register size (32 for W*n* and 64 for X*n*), and posn must be less than the
    register size.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 和 Rs 是 W*n* 或 X*n*。posn 和 len 的和不得超过寄存器大小（对于 W*n* 为 32，X*n* 为 64），且 posn
    必须小于寄存器大小。
- en: 'This instruction extracts len bits, starting at bit number posn, from Rs and
    inserts them into the LO len bits of Rd. It does not affect the other bits (at
    bit positions len and higher) in Rd. Generally, you’ll want to set Rd to 0 before
    using this instruction, as shown in the following example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令从 Rs 中提取从 posn 位开始的 len 个位，并将它们插入到 Rd 的低位 len 个位置中。它不会影响 Rd 中其他位（posn 位及更高位）。通常，你会在使用此指令之前将
    Rd 设置为 0，如下例所示：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Like the bfi instruction, bfxil supports only immediate constants for the posn
    and len operands. If you need to specify variables for either (or both) of these
    arguments, you must write an extractBits function (similar to mergeBits in the
    previous section). The following instructions do the actual bit extraction in
    extractBits:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 和 bfi 指令类似，bfxil 仅支持对 posn 和 len 操作数使用立即数。如果你需要为其中一个（或两个）参数指定变量，则必须编写一个 extractBits
    函数（类似于前面章节中的 mergeBits）。以下指令执行 extractBits 中的实际位提取：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This leaves the extracted bits in the LO bit positions of X0.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会将提取的位保留在 X0 的低位位置。
- en: 12.4.3 Clearing a Bit Field
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3 清除位域
- en: 'The Gas assembler provides an alias of the bfm instruction that you can use
    to clear bits in a register: bfc (bit field clear). Its syntax is'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 汇编器提供了 bfm 指令的别名，你可以用它来清除寄存器中的位：bfc（位域清除）。其语法为：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: where Rd is W*n* or X*n* and posn and len have the same meanings and restrictions
    as the bfi instruction. If you supply a len field of 1, you can clear individual
    bits (specified by a bit number) with bfc.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Rd 是 W*n* 或 X*n*，posn 和 len 的含义与 bfi 指令相同，并具有相同的限制。如果你提供 len 字段为 1，可以使用 bfc
    清除单个位（由位号指定）。
- en: The bfc instruction zeros out len bits starting at bit position posn in Rd.
    It is equivalent to the following instruction
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: bfc 指令将 Rd 中从 posn 位开始的 len 个位清零。它等价于以下指令：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: where Rd is W*d* or X*d*, as appropriate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，Rd 是 W*d* 或 X*d*，视情况而定。
- en: The bfc instruction is available only on ARMv8.2-a and later CPUs, not on Raspberry
    Pi (3 and 4) and other lower-end systems. (Note that the Raspberry Pi 5 does support
    this instruction.)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: bfc 指令仅在 ARMv8.2-a 及更高版本的 CPU 上可用，不适用于 Raspberry Pi（3 和 4 版）及其他低端系统。（注意，Raspberry
    Pi 5 支持该指令。）
- en: 12.4.4 Using bfm
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.4 使用 bfm
- en: 'The bfxil and bfi (as well as bfc) instructions are actually aliases for the
    instruction bfm:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: bfxil 和 bfi（以及 bfc）指令实际上是 bfm 指令的别名：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Like the ubfm instruction, they do two operations based on the values of immr
    and imms:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 和 ubfm 指令一样，它们基于 immr 和 imms 的值执行两项操作：
- en: If immr ≤ imms, take bits immr through imms from Rs and rotate right by immr,
    merging with the existing bits in Rd.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 immr ≤ imms，从 Rs 中取出 immr 到 imms 位的值，并将其右移 immr 位，与 Rd 中现有的位进行合并。
- en: If immr > imms, take imms + 1 LO bits from Rs and rotate right by immr, merging
    with the existing bits in Rd.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 immr > imms，从 Rs 中取出 imms + 1 个低位，并将其右移 immr 位，与 Rd 中现有的位合并。
- en: For example
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: produces 0xAFFFFFFF in W0.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 W0 中的 0xAFFFFFFF。
- en: 'The bfi instruction is equivalent to the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: bfi 指令等价于以下内容：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The bfxil instruction is equivalent to this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: bfxil 指令等价于以下内容：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Generally, you would use these aliases rather than the bfm mnemonic.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用这些别名而不是 bfm 助记符。
- en: 12.5 Common Bit Operations
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5 常见的位操作
- en: You’ll encounter many bit-manipulation design patterns in assembly language
    programs. This section covers some of the more common algorithms and patterns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言程序中，你会遇到许多位操作设计模式。本节介绍了一些常见的算法和模式。
- en: '#### 12.5.1 Coalescing Bit Sets and Distributing Bit Strings'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 12.5.1 合并位集合与分配位串'
- en: Inserting and extracting bit sets is only a little different from inserting
    and extracting bit strings if the “shape” of the bit set you’re inserting (or
    resulting bit set you’re extracting) is the same as the shape of the bit set in
    the main object. The *shape* of a bit set is the distribution of the bits in the
    set, ignoring the starting bit position of the set. A bit set that includes bits
    0, 4, 5, 6, and 7 has the same shape as a bit set that includes bits 12, 16, 17,
    18, and 19 because the distribution of the bits is the same.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to insert or extract this bit set is nearly identical to that of the
    previous sections; the only difference is the mask value you use. For example,
    to insert this bit set starting at bit 0 in W0 into the corresponding bit set
    starting at position 12 in W1, you could use the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: However, suppose you have five bits in bit positions 0 through 4 in W0 and want
    to merge them into bits 12, 16, 17, 18, and 19 in W1\. Somehow you have to *distribute*
    the bits in W0 prior to logically ORing the values into W1; that is, you have
    to move the bits from positions 0 to 4 into positions 12, 16, 17, 18, and 19.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The converse operation, *coalescing bits*, extracts the bits from various bit
    positions and packs them (coalesces them) into the LO bit positions of a destination
    location. The following code demonstrates how to distribute the bits in a bit
    string according to the values in a bitmask:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The main entry point to this loop is DistLoop. It begins by decrementing the
    loop counter held in W2 ❶. This code will check the value in W2 to see if the
    loop is done a little later. Next, the tst instruction checks whether bit 0 of
    the bitmap contains a 1\. If it does, the code needs to copy a bit from the LO
    bit position of W1 into W0; otherwise, it keeps the current bit value.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The bne instruction transfers control to CopyToW0 if it needs to copy a bit
    from W1; otherwise, it falls through to ❷ if it’s going to keep the current bit
    in W0\. The ror instruction rotates the existing W0 LO bit into the HO bit position
    (after 32 iterations of this loop, the bit winds up back in its original position).
    After the ror, the code checks whether the loop has executed 32 times (the cbnz
    instruction). If so, the code exits; otherwise, it repeats.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'If the LO bit of W3 was a 1, control transfers to the CopyToW0 label, which
    is responsible for shifting the (current) LO bit of W1 into W0\. The code at CopyToW0
    uses the extr instruction to grab bit 0 from W1 and place it in bit 31 of W0 (shifting
    bits 1 to 31 in W0 down 1 bit). The lsr w1, w1, #1 instruction removes the used
    bit from W1 and places the next bit to merge into W1 in bit position 0\. After
    a quick check to see whether the loop is complete, the code falls down into DistLoop
    and repeats.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This code would be a bit simpler if the ARM had an instruction that would
    rotate a register right by one bit through the carry flag. However, since no such
    instruction exists, this code has to simulate it by using* extr*.*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The general algorithm for coalescing bits is a tad more efficient than general
    distribution. Here’s the code that will extract bits from W1 via the bitmask in
    W3 and leave the result in W0:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As with the distribution code, the coalescing code loops through the bits, copying
    one bit at a time from W1 to W0 wherever there are 1 bits in the bitmap ❷. The
    extr instruction creates a 32-bit string from bit 31 of W1 and bits 0 to 30 of
    W0, then puts the result into W0\. On each loop iteration, the code shifts the
    bits in W1 one position to the left ❶ ❸ so that the next bit to (possibly) move
    into W0 is in the HO bit position. Unlike the distribution code, this code will
    terminate after it processes all the 1 bits present in the bitmap.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Another way to coalesce bits is via table lookup. By grabbing a byte of data
    at a time (so your tables don’t get too large), you can use that byte’s value
    as an index into a lookup table that coalesces all the bits down to bit 0\. Finally,
    you can merge the bits at the low end of each byte together. This may produce
    a more efficient coalescing algorithm in certain cases. The implementation is
    left to you.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.2 Creating Packed Arrays of Bit Strings
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Though far less efficient, it is possible to create arrays of elements whose
    size is not a multiple of 8 bits. The drawback is that calculating the “address”
    of an array element and manipulating it involves a lot of extra work. This section
    presents a few examples of packing and unpacking array elements that are an arbitrary
    number of bits long.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Why would you want arrays of bit objects? The answer is simple: space. If an
    object consumes only 3 bits, you can get 2.67 times as many elements into the
    same space if you pack the data rather than allocating a whole byte for each object.
    For very large arrays, this can result in substantial savings. Of course, the
    cost of saving space is speed: you must execute extra instructions to pack and
    unpack the data, slowing access to it.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'The calculation for locating the bit offset of an array element in a large
    block of bits is almost identical to the standard array access:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once you calculate the element’s address in bits, you must convert it to a
    byte address (because you must use byte addresses when accessing memory) and extract
    the specified element. Because the base address of an array almost always starts
    on a byte boundary, you can use the following equations to simplify this task:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For example, suppose you have an array of 200 3-bit objects declared as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The constant expression in the preceding dimension reserves space for enough
    bytes to hold 600 bits (200 elements, each 3 bits long). As the comment notes,
    the expression adds 2 extra bytes at the end to ensure you don’t lose any odd
    bits and to allow you to access 1 byte beyond the end of the array when storing
    data to the array. (Losing odd bits wouldn’t occur in this example because 600
    is evenly divisible by 8, but in general you can’t count on this; adding 2 extra
    bytes usually won’t hurt.)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose you want to access the *i*th 3-bit element of this array. You can
    extract these bits with the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inserting an element into the array is a little more difficult. In addition
    to computing the base address and bit offset of the array element, you must also
    create a mask to clear out the bits in the destination where you’re going to insert
    the new data. The following code inserts the LO 3 bits of W0 into the *i*th element
    of the AO3Bobjects array:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Assuming AO3Bobjects contained all 0s, i contained 5, and W0 (the value to insert)
    was 7 upon executing this code, the first couple of bytes would contain 0x38000
    after the execution of this code sequence. Because each element is 3 bits, the
    array looks like
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: where bit 0 is the leftmost bit. Flipping the 32 bits around to make them more
    readable, and grouping them in blocks of 4 bits to make it easy to convert to
    hexadecimal, we get
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: which is 0x38000.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: This code uses a lookup table (Masks) to generate the masks needed to clear
    out the appropriate position in the array. Each element of this array contains
    all 1s, except for three 0s in the position you need to clear for a given bit
    offset. Note the use of the NOT operator (~) to invert the constants in the table.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.3 Searching for Bits
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common bit operation is to locate the end of a run of bits. A special case
    of this operation is to locate the first (or last) set or clear bit in a 16-,
    32-, or 64-bit value. This section explores ways to handle this special case.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '*First set bit* means the first bit in a value, scanning from bit 0 toward
    the high-order bit, which contains a 1\. A similar definition exists for the *first
    clear bit*. The *last set bit* is the first bit in a value, scanning from the
    high-order bit toward bit 0, which contains a 1\. Likewise, a similar definition
    exists for the *last clear bit*.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'One obvious way to scan for the first or last bit is to use a shift instruction
    in a loop and count the number of iterations before you shift out a 1 (or 0).
    The number of iterations specifies the position. Here’s some sample code that
    checks for the first set bit (from bit 0) in W0 and returns that bit position
    in W1:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that this code returns –1 in W1 if W0 has no set bits.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for the first (or last) set bit is such a common operation that Arm
    added an instruction specifically to accelerate this process: clz (count leading
    0 bits). In particular, the clz instruction counts the number of leading 0s, which
    tells you the position of the most significant set bit. Consider the following
    code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找第一个（或最后一个）设置的比特是一个非常常见的操作，因此Arm专门添加了一条指令来加速这个过程：clz（计数前导0比特）。特别地，clz指令计数前导0的数量，这可以告诉你最重要的设置比特的位置。考虑以下代码：
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This code computes the bit position of the 1 in the highest position in W0 (leaving
    the result in W0). This produces –1 if W0 contains 0 (no leading set bits).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码计算W0中最高位置上的1的比特位置（并将结果保留在W0中）。如果W0包含0（没有前导的设置位），则返回-1。
- en: Don’t forget that cls doesn’t count leading *set* bits but leading *sign* bits.
    To count the number of leading (HO) bits containing 1s, invert the number and
    use clz to count the leading 0 bits. To count the number of trailing 0 or 1 bits
    (that is, a bit run of 0s or 1s starting at the LO bit position), use the rbit
    instruction to reverse the bits and then count the HO bits you’re interested in.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，cls并不是计数前导的*设置*比特，而是前导的*符号*比特。为了计数包含1的前导（HO）比特，反转该数值并使用clz来计数前导0比特。为了计数尾随的0或1比特（即从最低位位置开始的0或1比特序列），使用rbit指令来反转比特，然后计数你感兴趣的HO比特。
- en: '#### 12.5.4 Merging Bit Strings'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 12.5.4 合并位字符串'
- en: 'Another common bit string operation is to produce a single bit string by merging,
    or interleaving, bits from two sources. For example, the following code sequence
    creates a 32-bit string by merging alternate bits from two 16-bit strings:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的位字符串操作是通过合并或交错来自两个源的比特，生成一个单一的位字符串。例如，以下代码序列通过交替合并两个16位字符串的比特，创建一个32位字符串：
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This particular example merges two 16-bit values together, alternating their
    bits in the result value. For a faster implementation of this code, unroll the
    loop to eliminate one-third of the instructions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个具体的例子将两个16位值合并在一起，交替排列它们的比特，生成结果值。为了更快地实现此代码，可以展开循环，去掉三分之一的指令。
- en: 'With a few slight modifications, you can merge four 8-bit values together,
    or merge other bit sets from the source strings. For example, the following code
    copies bits 0 to 5 from W0, bits 0 to 4 from W1, bits 6 to 11 from W0, bits 5
    to 15 from W1, and finally bits 12 to 15 from W0:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些小的修改，你可以将四个8位值合并在一起，或者合并来自源字符串的其他比特集合。例如，以下代码将W0中的比特0到5、W1中的比特0到4、W0中的比特6到11、W1中的比特5到15，最后W0中的比特12到15进行复制：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code produces the result in W3, extracting the bits from W0 and W1.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将结果存储在W3中，从W0和W1中提取比特。
- en: 12.5.5 Scattering Bits from a Bit String
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.5 从位字符串中分散比特
- en: 'You can also extract and distribute bits in a bit string among multiple destinations,
    known as *scattering bits*. The following code takes the 32-bit value in W0 and
    distributes alternate bits among the LO 16 bits in the W1 and W3 registers:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从位字符串中提取并分配比特到多个目标，这被称为*分散比特*。以下代码从W0中取出32位值，并将交替的比特分配到W1和W3寄存器的低16位中：
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This code produces 0xffff in W1 and 0x0000 in W0.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在W1中生成0xffff，在W0中生成0x0000。
- en: 12.5.6 Searching for a Bit Pattern
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.6 搜索比特模式
- en: Another bit-related operation you may need is the ability to search for a particular
    bit pattern in a string of bits. For example, you might want to locate the bit
    index of the first occurrence of 0b1011 starting at a particular position in a
    bit string. This section explores simple algorithms to accomplish this task.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能需要的与比特相关的操作是能够在一串比特中搜索特定的比特模式。例如，你可能想要找到从位字符串中的特定位置开始，第一个出现0b1011的比特索引。本节将探讨一些简单的算法来完成这个任务。
- en: 'To search for a particular bit pattern, you must know four details:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定的比特模式，你必须知道四个细节：
- en: The pattern
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: The length of that pattern
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模式的长度
- en: The bit string to search through, known as the *source*
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要搜索的位字符串，称为*源*
- en: The length of the bit string that you’re searching
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在搜索的位字符串的长度
- en: The basic idea behind the search is to create a mask based on the length of
    the pattern and to mask a copy of the source with this value. You can then directly
    compare the pattern with the masked source for equality. If they are equal, you’re
    finished; if not, increment a bit position counter, shift the source one position
    to the right, and try again. You repeat the operation [*length*(*source*) – *length*(*pattern*)]
    times. The algorithm fails if it does not detect the bit pattern after that number
    of attempts, because it has exhausted all the bits in the source operand that
    could match the pattern’s length.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Listing 12-2 searches for a 4-bit pattern.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here’s the build command and sample output for Listing 12-2:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, this program properly located the bit pattern in the source.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Moving On
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assembly language is well known for its powerful bit-manipulation capabilities,
    difficult to replicate in an HLL. This chapter described those capabilities for
    the 64-bit ARM CPU. It began with definitions useful for describing bit operations,
    then introduced a bevy of instructions that manipulate bit data. This chapter
    also discussed using the condition code flags in the PSR as bit data, along with
    the instructions to manipulate those flags, specifically the negative (N), zero
    (Z), carry (C), and overflow (V) flags.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: After discussing the basic set of bit-manipulation instructions, this chapter
    covered applications of those instructions, including packing and unpacking bit
    strings, inserting one bit string into another, extracting a bit string from a
    source string, coalescing and distributing bits, working with packed arrays of
    bits, searching for bit strings, merging bit strings, and scattering bits from
    a bit string.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, this chapter concludes the discussion of new ARM assembly
    language instructions. The remaining chapters discuss the application of these
    instructions and various software-engineering topics. The next chapter, for example,
    focuses on macros you can use to simplify your assembly language programs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '### 12.7 For More Information'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate book on bit twiddling is *Hacker’s Delight*, 2nd edition, by Henry
    S. Warren Jr. (Addison-Wesley Professional, 2012). While this book uses the C
    programming language for examples, almost all the concepts it discusses apply
    to assembly language programs as well.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
