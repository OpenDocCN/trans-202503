<html><head></head><body>
<h2 class="h2" id="ch5"><span epub:type="pagebreak" id="page_61"/><span class="big">5</span><br/>ERROR HANDLING</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">You’ve seen how to use variables and control flow structures to write flexible code that can respond to the imperfections of the real world—servers that aren’t up when they should be, files that are in the wrong place, and the like. Some of these things you know to expect and can</span> handle accordingly. But you’ll never be able to anticipate every error. There’s always something that will break your code. The best you can do is write code that breaks responsibly.</p>&#13;
<p class="indent">That’s the basic premise behind <em>error handling</em>, the techniques that developers use to ensure that their code expects and takes care of—or <em>handles</em>—errors. In this chapter, you’ll learn a few of the most basic error-handling techniques. First, you’ll drill down into errors themselves, looking at the difference between terminating and nonterminating errors. Then, you’ll learn how to use the <code>try/catch/finally</code> construct, and last, you’ll examine PowerShell’s automatic error variables.</p>&#13;
<h3 class="h3" id="ch5lev1"><span epub:type="pagebreak" id="page_62"/>Working with Exceptions and Errors</h3>&#13;
<p class="noindent">In <a href="ch04.xhtml#ch4">Chapter 4</a>, you looked at control flow and how to introduce different paths of execution into your code. When your code encounters a problem, it disrupts the normal flow; we call this flow-disrupting event an <em>exception</em>. Mistakes such as dividing by zero, trying to access an element outside the bounds of an array, or trying to open a missing file will all cause PowerShell to <em>throw</em> an exception.</p>&#13;
<p class="indent">Once an exception is thrown, if you do nothing to stop it, it will be wrapped with additional information and sent to the user as an <em>error</em>. PowerShell has two types of errors. The first is a <em>terminating error</em>: any error that stops execution of the code. For example, say you have a script called <em>Get-Files.ps1</em> that finds a list of files in a certain folder and then performs the same action for each of those files. If the script can’t find the folder—someone has moved it or named it something unexpected—you’ll want to return a terminating error, as the code cannot do anything without access to all the files. But what happens if only one of the files is corrupted?</p>&#13;
<p class="indent">When you try to access the corrupted file, you’ll get another exception. But because you’re performing the same independent action on each file, there’s no reason that one broken file should stop the rest from running. In that case, you’ll write code that treats the exception caused by the single broken file as a <em>nonterminating error</em>, one not severe enough to halt the rest of the code.</p>&#13;
<p class="indent">The general error-handling behavior for nonterminating errors is to output a useful error message and proceed with the rest of the program. You can see this in several of PowerShell’s built-in commands. For example, say you want to check the status of the Windows services <code>bits</code>, <code>foo</code>, and <code>lanmanserver</code>. You could use a single <code>Get-Service</code> command to check them all at the same time, as in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Service bits,foo,lanmanserver</span>&#13;
Get-Service : Cannot find any service with service name 'foo'.&#13;
At line:1 char:1&#13;
+ Get-Service bits,foo,lanmanserver&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
+ CategoryInfo          : ObjectNotFound: (foo:String) [Get-Service], ServiceCommandException&#13;
+ FullyQualifiedErrorId : NoServiceFoundForGivenName,&#13;
                          Microsoft.PowerShell.Commands.GetServiceCommand&#13;
&#13;
Status   Name               DisplayName&#13;
------   ----               -----------&#13;
Running  bits               Background Intelligent Transfer Ser...&#13;
Running  lanmanserver       Server</pre>&#13;
<p class="caption" id="ch5list1"><em>Listing 5-1: A nonterminating error</em></p>&#13;
<p class="indent">Of course, there is no <code>foo</code> service, and PowerShell tells you as much. But notice that PowerShell gets the status for the other services; it doesn’t stop executing when it runs into that error. This nonterminating error can be converted to a terminating error to prevent execution of the rest of the code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>It’s important to understand that the decision to turn an exception into a nonterminating error or a terminating error is made by a developer. Often, as in <a href="ch05.xhtml#ch5list1">Listing 5-1</a>, this decision will be made for you by whoever wrote the cmdlet you’re using. In many cases, if the cmdlet encounters an exception, it will return a nonterminating error, writing error output to the console and allowing your script to continue executing. In the next section, you’ll see a few ways to turn nonterminating errors into terminating errors.</p>&#13;
<h3 class="h3" id="ch5lev2">Handling Nonterminating Errors</h3>&#13;
<p class="noindent">Let’s say you want to write a simple script that will go into a folder that you know contains several text files and prints out the first line of every text file. If the folder doesn’t exist, you want the script to end immediately and report the error; otherwise, if you encounter any other errors, you want the script to keep running and report the error.</p>&#13;
<p class="indent">You’ll start by writing a script that should return a terminating error. <a href="ch05.xhtml#ch5list2">Listing 5-2</a> shows a first attempt at this code. (Though I could’ve condensed the code into something more succinct, for teaching purposes, I’ve tried to make each step here as clear as possible.)</p>&#13;
<pre>$folderPath = '.\bogusFolder'&#13;
$files = Get-ChildItem -Path $folderPath &#13;
Write-Host "This shouldn't run."&#13;
$files.foreach({&#13;
    $fileText = Get-Content $files&#13;
    $fileText[0]&#13;
})</pre>&#13;
<p class="caption" id="ch5list2"><em>Listing 5-2: A first attempt at our</em> Get-Files.ps1 <em>script</em></p>&#13;
<p class="indent">Here, you use <code>Get-ChildItem</code> to return all the files contained inside the path you pass it—in this case, a bogus folder. If you run this script, you should get output like the following:</p>&#13;
<pre>Get-ChildItem : Cannot find path 'C:\bogusFolder' because it does not exist.&#13;
At C:\Get-Files.ps1:2 char:10&#13;
+ $files = Get-ChildItem -Path $folderPath&#13;
+          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
+ CategoryInfo : ObjectNotFound: (C:\bogusFolder:String) [Get-ChildItem], ItemNotFoundException&#13;
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetChildItemCommand&#13;
This shouldn't run.</pre>&#13;
<p class="indent">As you can see, two things happen: PowerShell returns an error, which specifies the type of exception encountered (<code>ItemNotFoundException</code>), and the call to <code>Write-Host</code> runs. This means that the error you get is nonterminating.</p>&#13;
<p class="indent">To turn this error into a terminating error, you’ll use the <code>ErrorAction</code> parameter. This is a <em>common parameter</em>, meaning that it’s built into every PowerShell cmdlet. The <code>ErrorAction</code> parameter determines what action to <span epub:type="pagebreak" id="page_64"/>take if the cmdlet in question encounters a nonterminating error. This parameter has five main options:</p>&#13;
<p class="noindenti"><strong>Continue</strong> Outputs the error message and continues to execute the cmdlet. This is the default value.</p>&#13;
<p class="noindenti"><strong>Ignore</strong> Continues to execute the cmdlet without outputting an error or recording it in the <code>$Error</code> variable.</p>&#13;
<p class="noindenti"><strong>Inquire</strong> Outputs the error message and prompts the user for input before continuing.</p>&#13;
<p class="noindenti"><strong>SilentlyContinue</strong> Continues to execute the cmdlet without outputting an error, but records it in the <code>$Error</code> variable.</p>&#13;
<p class="noindentib"><strong>Stop</strong> Outputs the error message and stops the cmdlet from executing.</p>&#13;
<p class="indent">You’ll look more at the <code>$Error</code> variable later in the chapter. For now, you want to pass <code>Stop</code> to <code>Get-ChildItem</code>. Update your script and run the code again. You should get the same output without <code>This shouldn't run.</code></p>&#13;
<p class="indent">The <code>ErrorAction</code> parameter is useful for controlling error behavior on a case-by-case basis. To change how PowerShell handles all nonterminating errors, you can use the <code>$ErrorActionPreference</code> variable, an automatic variable that controls the default nonterminating error behavior. By default, <code>$ErrorActionPreference</code> is set to <code>Continue</code>. Note that the <code>ErrorAction</code> parameter overrides the value of <code>$ErrorActionPreference</code>.</p>&#13;
<p class="indent">In general, I consider the best practice is to always set <code>$ErrorAction</code><code>Preference</code> to <code>Stop</code> to remove the concept of nonterminating errors altogether. This allows you to catch all types of exceptions, and spare yourself the work of knowing in advance which errors are terminating and which are nonterminating. You can accomplish the same task by using the <code>ErrorAction</code> parameter on each command to get more granular with defining which commands return terminating errors, but I’d rather set the rule once and forget it than have to remember to add the <code>ErrorAction</code> parameter to every command I call.</p>&#13;
<p class="indent">Now let’s look at how to handle terminating errors by using the <code>try/catch/finally</code> construct.</p>&#13;
<h3 class="h3" id="ch5lev3">Handling Terminating Errors</h3>&#13;
<p class="noindent">To prevent terminating errors from stopping a program, you need to <em>catch</em> them. You do so with the <code>try/catch/finally</code> construct. <a href="ch05.xhtml#ch5list3">Listing 5-3</a> shows the syntax.</p>&#13;
<pre>try {&#13;
    # initial code&#13;
} catch {&#13;
    # code that runs if terminating error found&#13;
} finally {&#13;
    # code that runs at the end&#13;
}</pre>&#13;
<p class="caption" id="ch5list3"><em>Listing 5-3: Syntax for the <span class="codeitalic">try/catch/finally</span> construct</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_65"/>Using <code>try/catch/finally</code> essentially sets up an error-handling safety net. The <code>try</code> block contains the original code you want to run; if a terminating error happens, PowerShell will redirect flow to the code in the <code>catch</code> block. Regardless of whether the code in <code>catch</code> runs, the code in <code>finally</code> will always run—note that the <code>finally</code> block is optional, unlike <code>try</code> or <code>catch</code>.</p>&#13;
<p class="indent">To get a better sense of what <code>try/catch/finally</code> can and can’t do, let’s revisit our <em>Get-Files.ps1</em> script. You’ll use a <code>try/catch</code> statement to provide a cleaner error message, as in <a href="ch05.xhtml#ch5list4">Listing 5-4</a>.</p>&#13;
<pre>$folderPath = '.\bogusFolder'&#13;
try {&#13;
    $files = Get-ChildItem -Path $folderPath –ErrorAction Stop&#13;
    $files.foreach({&#13;
        $fileText = Get-Content $files&#13;
        $fileText[0]&#13;
    })&#13;
} catch {&#13;
    $_.Exception.Message&#13;
}</pre>&#13;
<p class="caption" id="ch5list4"><em>Listing 5-4: Using a <span class="codeitalic">try/catch</span> statement to handle terminating errors</em></p>&#13;
<p class="indent">When a terminating error is caught in the <code>catch</code> block, the error object is stored in the <code>$_</code> variable. In this example, you use <code>$_.Exception.Message</code> to return just the exception message. In this case, the code should return something like <code>Cannot find path 'C:\ bogusFolder' because it does not exist</code>. Error objects also contain other information, including the type of exception that was thrown, a stack trace that shows the execution history of the code that occurred before the exception was thrown, and more. However, for now, the most useful piece of information for you is the <code>Message</code> property, as this typically contains the basic information you need in order to see what happened in your code.</p>&#13;
<p class="indent">By now, your code should work as you expect. By passing <code>Stop</code> into <code>ErrorAction</code>, you ensure that a missing folder will return a terminating error and catch the error. But what will happen if you encounter an error when you try to use <code>Get-Content</code> to access the file?</p>&#13;
<p class="indent">As an experiment, try running the following code:</p>&#13;
<pre>$filePath = '.\bogusFile.txt'&#13;
try {&#13;
    Get-Content $filePath&#13;
} catch {&#13;
    Write-Host "We found an error"&#13;
}</pre>&#13;
<p class="indent">You should get an error message from PowerShell, not the custom one you wrote in the <code>catch</code> block. This is because <code>Get-Content</code> returns a nonterminating error when an item is not found—and <code>try/catch</code> can find only <span epub:type="pagebreak" id="page_66"/>terminating errors. This means that the code in <a href="ch05.xhtml#ch5list4">Listing 5-4</a> will work as intended—any errors accessing the files themselves will not halt execution of the program, and will simply return to the console.</p>&#13;
<p class="indent">Notice that you have not used a <code>finally</code> block in this code. The <code>finally</code> block is a great place to put code that performs necessary cleanup tasks such as disconnecting open database connections, cleaning up PowerShell remoting sessions, and so on. Here, nothing of that sort is necessary.</p>&#13;
<h3 class="h3" id="ch5lev4">Exploring the $Error Automatic Variable</h3>&#13;
<p class="noindent">Throughout this chapter, you’ve forced PowerShell to return a lot of errors. Terminating or nonterminating, each one has been stored in a PowerShell automatic variable called <code>$Error</code>. The <code>$Error</code> variable is a built-in variable that stores an array of all the errors returned in the current PowerShell session, ordered by the time they appear.</p>&#13;
<p class="indent">To demonstrate the <code>$Error</code> variable, let’s go to the console and run a command that you know will return a nonterminating error (<a href="ch05.xhtml#ch5list5">Listing 5-5</a>).</p>&#13;
<pre>PS&gt;<span class="codestrong1"> Get-Item -Path C:\NotFound.txt</span>&#13;
Get-Item : Cannot find path 'C:\NotFound.txt' because it does not exist.&#13;
At line:1 char:1&#13;
+ Get-Item -Path C:\NotFound.txt&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
+ CategoryInfo : ObjectNotFound: (C:\NotFound.txt:String) [Get-Item], ItemNotFoundException&#13;
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand</pre>&#13;
<p class="caption" id="ch5list5"><em>Listing 5-5: Example error</em></p>&#13;
<p class="indent">Now, in the same PowerShell session, examine the <code>$Error</code> variable (<a href="ch05.xhtml#ch5list6">Listing 5-6</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$Error</span>&#13;
Get-Item : Cannot find path 'C:\NotFound.txt' because it does not exist.&#13;
At line:1 char:1&#13;
+ Get-Item -Path C:\NotFound.txt&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
+ CategoryInfo : ObjectNotFound: (C:\NotFound.txt:String) [Get-Item], ItemNotFoundException&#13;
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch5list6"><em>Listing 5-6: The <span class="codeitalic">$Error</span> variable</em></p>&#13;
<p class="indent">Unless you’re working in a brand-new session, chances are you see a long list of errors. To access a specific one, you can use index notation just as you would with any other array. The errors in <code>$Error</code> are added to the front of the array, so <code>$Error[0]</code> is the most recent, <code>$Error[1]</code> the second most recent, and so forth.</p>&#13;
<h3 class="h3" id="ch5lev5"><span epub:type="pagebreak" id="page_67"/>Summary</h3>&#13;
<p class="noindent">Error handling in PowerShell is a massive topic, and this chapter covered only the basics. If you’d like to dive deeper, check out the <code>about_try_catch_finally</code> help topic by running <code>Get-Help about_try_catch_finally</code>. Another great resource is the <em>Big Book of PowerShell Error Handling</em> by Dave Wyatt from the DevOps Collective (<a href="https://leanpub.com/thebigbookofpowershellerrorhandling"><em>https://leanpub.com/thebigbookofpowershellerrorhandling</em></a><em>/</em>).</p>&#13;
<p class="indent">The main takeaways here are understanding the difference between terminating and nonterminating errors, the uses of the <code>try/catch</code> statement, and the various <code>ErrorAction</code> options that will help you build the skills you need to handle any errors your code might throw at you.</p>&#13;
<p class="indent">So far, you’ve been doing everything in a single block of code. In the next chapter, you’ll see how to organize your code into discrete, executable units called <em>functions</em>.<span epub:type="pagebreak" id="page_68"/></p>&#13;
</body></html>