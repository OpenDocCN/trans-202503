<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_279"/><span class="big">11</span><br/>PRACTICAL DYNAMIC TAINT ANALYSIS WITH LIBDFT</h2>&#13;
<p class="startpara">In <a href="ch10.xhtml#ch10">Chapter 10</a>, you learned the principles of dynamic taint analysis. In this chapter, you will learn how to build your own DTA tools with <span class="literal">libdft</span>, a popular open source DTA library. I’ll cover two practical examples: a tool that prevents remote control-hijacking attacks and a tool that automatically detects information leaks. But first, let’s take a look at the internals and API of <span class="literal">libdft</span>.</p>&#13;
<h3 class="h3" id="ch11_1">11.1 Introducing libdft</h3>&#13;
<p class="noindent">Because DTA is the subject of ongoing research, existing binary-level taint tracking libraries are research tools; don’t expect production quality from them. The same is true for <span class="literal">libdft</span>, developed at Columbia University, which you’ll use in the remainder of this chapter.</p>&#13;
<p class="indent">A byte-granularity taint-tracking system built on Intel Pin, <span class="literal">libdft</span> is one of the easiest to use DTA libraries available at the moment. In fact, it’s the tool of choice of many security researchers because you can use it to easily build DTA tools that are both accurate and fast. I’ve preinstalled <span class="literal">libdft</span> <span epub:type="pagebreak" id="page_280"/>on the VM in the directory <em>/home/binary/libdft</em>. You can also download it at <em><a href="https://www.cs.columbia.edu/~vpk/research/libdft/">https://www.cs.columbia.edu/~vpk/research/libdft/</a></em>.</p>&#13;
<p class="indent">Like all binary-level DTA libraries available at the time of writing, <span class="literal">libdft</span> has several shortcomings. The most obvious one is that <span class="literal">libdft</span> supports only 32-bit x86. You can still use it on a 64-bit platform, but only to analyze 32-bit processes. It also relies on legacy versions of Pin (versions between 2.11 and 2.14 should work). Another limitation is that <span class="literal">libdft</span> implements support only for “regular” x86 instructions, not extended instruction sets like MMX or SSE. This means <span class="literal">libdft</span> may suffer from undertainting if taint flows through such instructions. If you’re building the program you’re analyzing from source, use <span class="literal">gcc</span>’s compilation options <span class="literal">-mno-{mmx, sse, sse2, sse3}</span> to ensure that the binary won’t contain MMX or SSE instructions.</p>&#13;
<p class="indent">Despite its limitations, <span class="literal">libdft</span> is still an excellent DTA library you can use to build solid tools. Also, because it’s open source, it’s relatively easy to extend it with 64-bit support or support for more instructions. To help you get the most out of <span class="literal">libdft</span>, let’s take a look at its most important implementation details.</p>&#13;
<h4 class="h4" id="ch11_1_1"><em>11.1.1 Internals of libdft</em></h4>&#13;
<p class="noindent">Because <span class="literal">libdft</span> is based on Intel Pin, <span class="literal">libdft</span>-based DTA tools are just Pin tools like the ones you saw in <a href="ch09.xhtml#ch09">Chapter 9</a>, except they’re linked with <span class="literal">libdft</span>, which provides the DTA functionality. On the VM, I’ve installed a dedicated legacy version of Intel Pin (v2.13) you can use with <span class="literal">libdft</span>. Pin is used by <span class="literal">libdft</span> to instrument instructions with taint propagation logic. Taint itself is stored in shadow memory, which is accessible through the <span class="literal">libdft</span> API. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows an overview of <span class="literal">libdft</span>’s most important components.</p>&#13;
<h3 class="h3">Shadow Memory</h3>&#13;
<p class="noindent">As you can see in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>, <span class="literal">libdft</span> comes in two variants, each with a different kind of shadow memory (called the <em>tagmap</em> in <span class="literal">libdft</span> parlance). First, there’s a bitmap-based variant <span class="ent">➊</span>, which supports only one taint color but is slightly faster and has less memory overhead than the other variant. In the <span class="literal">libdft</span> source archive available from the Columbia University website,<sup><a id="ch11fn_1a" href="footnote.xhtml#ch11fn_1">1</a></sup> this variant is in the directory called <em>libdft_linux-i386</em>. The second variant implements an eight-color shadow memory <span class="ent">➋</span>, and you can find it in the directory <em>libdft-ng_linux-i386</em> in the source archive. This second variant is the one I’ve preinstalled on the VM and the one I’ll use here.</p>&#13;
<p class="indent">To minimize the memory requirements of the eight-color shadow memory, <span class="literal">libdft</span> implements it using an optimized data structure, called the <em>segment translation table (STAB)</em>. The STAB contains one entry for every memory page. Each entry contains an <em>addend</em> value, which is just a 32-bit offset that you add to a virtual memory address to obtain the address of the corresponding shadow byte.</p>&#13;
<div class="image"><a id="ch11fig1"/><img src="Images/f281-01.jpg" alt="image" width="623" height="598"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_281"/><em>Figure 11-1: Internals of</em> <span class="literal">libdft</span> <em>: shadow memory and virtual CPU implementation, instrumentation, and API</em></p>&#13;
<p class="indent">For example, to read the shadow memory for virtual address <span class="literal">0x1000</span>, you can look up the corresponding addend in the STAB, which turns out to be <span class="literal">438</span>. That means you’ll find the shadow byte containing the taint information for address <span class="literal">0x1000</span> at address <span class="literal">0x1438</span>.</p>&#13;
<p class="indent">The STAB provides a level of indirection that allows <span class="literal">libdft</span> to allocate shadow memory on demand, whenever the application allocates a region of virtual memory. Shadow memory is allocated in page-sized chunks, keeping memory overhead to a minimum. Since each allocated memory page corresponds to exactly one shadow page, the same addend can be used for all addresses in a page. For virtual memory regions with multiple adjacent pages, <span class="literal">libdft</span> ensures that the shadow memory pages are also adjacent, simplifying shadow memory access. Each chunk of adjacent shadow map pages is called a <em>tagmap segment (tseg)</em>. As an additional memory usage optimization, <span class="literal">libdft</span> maps all read-only memory pages to the same zeroed-out shadow page.</p>&#13;
<h3 class="h3">Virtual CPU</h3>&#13;
<p class="noindent">To keep track of the taint status of CPU registers, <span class="literal">libdft</span> keeps a special structure in memory called the <em>virtual CPU</em>. The virtual CPU is a sort of mini-shadow memory with 4 shadow bytes for each of the 32-bit general-purpose <span epub:type="pagebreak" id="page_282"/>CPU registers available on x86: <span class="literal">edi</span>, <span class="literal">esi</span>, <span class="literal">ebp</span>, <span class="literal">esp</span>, <span class="literal">ebx</span>, <span class="literal">edx</span>, <span class="literal">ecx</span>, and <span class="literal">eax</span>. In addition, there’s a special scratch register on the virtual CPU, which <span class="literal">libdft</span> uses to store taint for any unrecognized register. In the preinstalled <span class="literal">libdft</span> version on the VM, I’ve made some modifications to the virtual CPU so that it has room for all registers supported by Intel Pin.</p>&#13;
<h3 class="h3">Taint-Tracking Engine</h3>&#13;
<p class="noindent">Recall that <span class="literal">libdft</span> uses Pin’s API to inspect all instructions in a binary and then instruments these instructions with the relevant taint propagation functions. If you’re interested, you can find the implementations of <span class="literal">libdft</span>’s taint propagation functions in the file <em>/home/binary/libdft/libdft-ng_linux-i386/src/ libdft_core.c</em> on the VM, but I won’t cover them all here. Together, the taint propagation functions implement <span class="literal">libdft</span>’s taint policy, which I’ll describe in <a href="ch11.xhtml#ch11_1_2">Section 11.1.2</a>.</p>&#13;
<h3 class="h3">The libdft API and I/O Interface</h3>&#13;
<p class="noindent">Ultimately, the goal of <span class="literal">libdft</span> is to function as a library for building your own DTA tools. For this purpose, <span class="literal">libdft</span> provides a taint-tracking API, which provides several classes of functions. The two most important classes of functions for building DTA tools are those that manipulate the tagmap and those that add callbacks and instrumentation code.</p>&#13;
<p class="indent">The tagmap API is defined in the header file <em>tagmap.h</em>. It provides functions such as <span class="literal">tagmap_setb</span> to mark a memory byte as tainted and <span class="literal">tagmap_getb</span> to retrieve the taint information for a memory byte.</p>&#13;
<p class="indent">The API for adding callbacks and instrumentation code is split over the header files <em>libdft_api.h</em> and <em>syscall_desc.h</em>. It allows you to register callbacks for syscall events using the functions <span class="literal">syscall_set_pre</span> and <span class="literal">syscall_set_post</span>. To store all these callbacks, <span class="literal">libdft</span> uses a dedicated array called <span class="literal">syscall_desc</span>, which keeps track of all the syscall pre- and post-handlers you install. Similarly, you can register instruction callbacks with <span class="literal">ins_set_pre</span> and <span class="literal">ins_set_post</span>. You’ll learn about these and other <span class="literal">libdft</span> API functions in more detail from the DTA tools later in this chapter.</p>&#13;
<h4 class="h4" id="ch11_1_2"><em>11.1.2 Taint Policy</em></h4>&#13;
<p class="noindent">The <span class="literal">libdft</span> taint propagation policy defines the following five classes of instructions.<sup><a id="ch11fn_2a" href="footnote.xhtml#ch11fn_2">2</a></sup> Each of these classes propagates and merges taint in a different way.</p>&#13;
<p class="li"><strong>ALU</strong> These are arithmetic and logic instructions with two or three operands, such as <span class="literal">add</span>, <span class="literal">sub</span>, <span class="literal">and</span>, <span class="literal">xor</span>, <span class="literal">div</span>, and <span class="literal">imul</span>. For these operations, <span class="literal">libdft</span> merges taint in the same way as the <span class="literal">add</span> and <span class="literal">xor</span> examples in <a href="ch10.xhtml#ch10tab1">Table 10-1</a> on page 273—the output taint is the union (∪) of the input operands’ taint. Also as in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>, <span class="literal">libdft</span> considers immediate values untainted since there’s no way an attacker can influence them.</p>&#13;
<p class="li"><span epub:type="pagebreak" id="page_283"/><strong>XFER</strong> The XFER class contains all the instructions that copy a value to another register or memory location, such as the <span class="literal">mov</span> instruction. Again, it’s handled like the <span class="literal">mov</span> example in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>, using the assignment operation (:=). For these instructions, <span class="literal">libdft</span> simply copies the taint from the source operand to the destination.</p>&#13;
<p class="li"><strong>CLR</strong> As the name implies, instructions in this class always cause their output operands to become untainted. In other words, <span class="literal">libdft</span> sets the output taint to the empty set (ø). This class includes some special cases of instructions from other classes, such as <span class="literal">xor</span>-ing an operand with itself or subtracting an operand from itself. It also includes instructions such as <span class="literal">cpuid</span>, where an attacker has no control over the outputs.</p>&#13;
<p class="li"><strong>SPECIAL</strong> These are instructions that require special rules for taint propagation not covered by other classes. Among others, this class includes <span class="literal">xchg</span> and <span class="literal">cmpxchg</span> (where the taint of two operands is swapped) and <span class="literal">lea</span> (where the taint results from a memory address computation).</p>&#13;
<p class="li"><strong>FPU, MMX, SSE</strong> This class includes instructions that <span class="literal">libdft</span> doesn’t currently support, such as FPU, MMX, and SSE instructions. When taint flows through such instructions, <span class="literal">libdft</span> cannot track it, so the taint information doesn’t propagate to the output operands of the instructions, resulting in undertainting.</p>&#13;
<p class="indent">Now that you’re acquainted with <span class="literal">libdft</span>, let’s build some DTA tools with <span class="literal">libdft</span>!</p>&#13;
<h3 class="h3" id="ch11_2">11.2 Using DTA to Detect Remote Control-Hijacking</h3>&#13;
<p class="noindent">The first DTA tool you’ll see is designed to detect some types of remote control-hijacking attacks. Specifically, it detects attacks where data received from the network is used to control the arguments of an <span class="literal">execve</span> call. Thus, the taint sources will be the network receive functions <span class="literal">recv</span> and <span class="literal">recvfrom</span>, while the <span class="literal">execve</span> syscall will be the taint sink. As usual, you can find the complete source code on the VM, in <em>~/code/chapter11</em>.</p>&#13;
<p class="indent">I tried to make this example tool as simple as possible to keep the discussion easy to understand. That means it necessarily makes simplifying assumptions and will not catch all types of control-hijacking attacks. In a real, fully fledged DTA tool, you’ll want to define additional taint sources and sinks to prevent more types of attacks. For instance, in addition to data received with <span class="literal">recv</span> and <span class="literal">recvfrom</span>, you’ll want to consider data read from the network using the <span class="literal">read</span> syscall. Moreover, to prevent tainting innocent file reads, you’ll need to keep track of which file descriptors are reading from the network by hooking network calls like <span class="literal">accept</span>.</p>&#13;
<p class="indent">When you understand how the following example tool works, you should be able to refine it on your own. Additionally, <span class="literal">libdft</span> comes with a more elaborate example DTA tool that implements many of these refinements for reference. You can find it in the file <em>tools/libdft-dta.c</em> in the <em>libdft</em> directory if you’re interested.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>Many <span class="literal">libdft</span>-based DTA tools hook syscalls to use as taint sources and sinks. On Linux, every syscall has its own <em>syscall number</em>, which <span class="literal">libdft</span> uses to index the <span class="literal">syscall_desc</span> array. For a list of available syscalls and their associated syscall numbers, refer to <em>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</em> for x86 (32 bit) or to <em>/usr/include/asm-generic/unistd.h</em> for x64.<sup><a id="ch11fn_3a" href="footnote.xhtml#ch11fn_3">3</a></sup></p>&#13;
<p class="indent">Now, let’s take a look at the example tool called <span class="literal">dta-execve</span>. <a href="ch11.xhtml#ch11list1">Listing 11-1</a> shows the first part of the source code.</p>&#13;
<p class="listing1" id="ch11list1"><em>Listing 11-1:</em> dta-execve.cpp</p>&#13;
<p class="programs">    /* some #includes omitted for brevity */<br/><br/><span class="ent">➊</span>  #include "pin.H"<br/><br/><span class="ent">➋</span>  #include "branch_pred.h"<br/>   #include "libdft_api.h"<br/>   #include "syscall_desc.h"<br/>   #include "tagmap.h"<br/><br/><span class="ent">➌</span>  extern syscall_desc_t syscall_desc[SYSCALL_MAX];<br/><br/>   void alert(uintptr_t addr, const char *source, uint8_t tag);<br/>   void check_string_taint(const char *str, const char *source);<br/>   static void post_socketcall_hook(syscall_ctx_t *ctx);<br/>   static void pre_execve_hook(syscall_ctx_t *ctx);<br/><br/>   int<br/>   main(int argc, char **argv)<br/>   {<br/><span class="ent">➍</span>    PIN_InitSymbols();<br/><span class="ent">➎</span>    if(unlikely(PIN_Init(argc, argv))) {<br/>        return 1;<br/>     }<br/><br/><span class="ent">➏</span>    if(unlikely(libdft_init() != 0)) {<br/><span class="ent">➐</span>       libdft_die();<br/>        return 1;<br/>     }<br/><br/><span class="ent">➑</span>    syscall_set_post(&amp;syscall_desc[__NR_socketcall], post_socketcall_hook);<br/><span class="ent">➒</span>    syscall_set_pre (&amp;syscall_desc[__NR_execve], pre_execve_hook);<br/><br/><span class="ent">➒</span>    PIN_StartProgram();<br/><br/>     return 0;<br/>   }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_285"/>Here, I show only the header files that are specific to <span class="literal">libdft</span>-based DTA tools, but you can see the omitted code in the source on the VM if you’re interested.</p>&#13;
<p class="indent">The first header file is <em>pin.H</em> <span class="ent">➊</span> because all <span class="literal">libdft</span> tools are just Pin tools linked with the <span class="literal">libdft</span> library. Next, there are several header files that together provide access to the <span class="literal">libdft</span> API <span class="ent">➋</span>. The first of these, <em>branch_pred.h</em>, contains the macros <span class="literal">likely</span> and <span class="literal">unlikely</span>, which you can use to provide the compiler with hints for branch prediction, as I’ll explain in a moment. Next, <em>libdft_api.h</em>, <em>syscall_desc.h</em>, and <em>tagmap.h</em> provide access to the <span class="literal">libdft</span> base API, syscall hooking interface, and tagmap (shadow memory), respectively.</p>&#13;
<p class="indent">After the includes, there’s an <span class="literal">extern</span> declaration of the <span class="literal">syscall_desc</span> array <span class="ent">➌</span>, which is the data structure <span class="literal">libdft</span> uses to keep track of syscall hooks. You’ll need access to it to hook your taint sources and sinks. The actual definition of <span class="literal">syscall_desc</span> is in <span class="literal">libdft</span>’s source file <em>syscall_desc.c</em>.</p>&#13;
<p class="indent">Now let’s take a look at the <span class="literal">main</span> function of the <span class="literal">dta-execve</span> tool. It starts by initializing Pin’s symbol processing <span class="ent">➍</span> in case symbols are present in the binary, followed by Pin itself <span class="ent">➎</span>. You saw Pin initialization code in <a href="ch09.xhtml#ch09">Chapter 9</a>, but this time the return value of <span class="literal">PIN_Init</span> is checked using an optimized branch, marked with the <span class="literal">unlikely</span> macro to tell the compiler it’s unlikely that <span class="literal">PIN_Init</span> will fail. This knowledge can help the compiler with branch prediction, which may allow it to output slightly faster code.</p>&#13;
<p class="indent">Next, the <span class="literal">main</span> function initializes <span class="literal">libdft</span> itself using the <span class="literal">libdft_init</span> function <span class="ent">➏</span>, again with an optimized check of the return value. This initialization allows <span class="literal">libdft</span> to set up crucial data structures, such as the tagmap. If this setup fails, <span class="literal">libdft_init</span> returns a nonzero value, in which case you call <span class="literal">libdft_die</span> to deallocate any resources <span class="literal">libdft</span> may have allocated <span class="ent">➐</span>.</p>&#13;
<p class="indent">Once Pin and <span class="literal">libdft</span> are both initialized, you can install your syscall hooks, which serve as taint sources and taint sinks. Keep in mind that the appropriate hook will be called whenever the instrumented application (the program you’re protecting with your DTA tool) executes the corresponding syscall. Here, <span class="literal">dta-execve</span> installs two hooks: a post-handler called <span class="literal">post_socketcall_hook</span> that runs right after every <span class="literal">socketcall</span> syscall <span class="ent">➑</span> and a pre-handler that runs before <span class="literal">execve</span> syscalls, called <span class="literal">pre_execve_hook</span> <span class="ent">➒</span>. The <span class="literal">socketcall</span> syscall captures all socket-related events on x86-32 Linux, including <span class="literal">recv</span> and <span class="literal">recvfrom</span> events. The <span class="literal">socketcall</span> handler (<span class="literal">post_socketcall_hook</span>) differentiates between the different types of socket events, as I’ll explain in a moment.</p>&#13;
<p class="indent">To install a syscall handler, you call <span class="literal">syscall_set_post</span> (for post-handlers) or <span class="literal">syscall_set_pre</span> (for pre-handlers). Both of these functions take a pointer to the entry in <span class="literal">libdft</span>’s <span class="literal">syscall_desc</span> array in which to install the handler, and a function pointer to the handler to install. To get the appropriate <span class="literal">syscall_desc</span> entry, you index <span class="literal">syscall_desc</span> with the syscall number of the syscall you’re hooking. In this case, the relevant syscall numbers are represented by the symbolic names <span class="literal">__NR_socketcall</span> and <span class="literal">__NR_execve</span>, which you can find in <em>/usr/include/i386-linux-gnu/asm/unistd_32.h</em> for x86-32.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_286"/>Finally, you call <span class="literal">PIN_StartProgram</span> to begin running the instrumented application <span class="ent">➓</span>. Recall from <a href="ch09.xhtml#ch09">Chapter 9</a> that <span class="literal">PIN_StartProgram</span> never returns, so the <span class="literal">return 0</span> at the end of <span class="literal">main</span> is never reached.</p>&#13;
<p class="indent">Although I don’t use it in this example, <span class="literal">libdft</span> does provide the ability to hook instructions in nearly the same way as syscalls, as shown in the following listing:</p>&#13;
<p class="programs"><span class="ent">➊</span>  extern ins_desc_t ins_desc[XED_ICLASS_LAST];<br/>   /* ... */<br/><span class="ent">➋</span>  ins_set_post(&amp;ins_desc[XED_ICLASS_RET_NEAR], dta_instrument_ret);</p>&#13;
<p class="indent">To hook instructions, you globally declare the <span class="literal">extern ins_desc</span> array <span class="ent">➊</span> (analogous to <span class="literal">syscall_desc</span>) in your DTA tool and then use <span class="literal">ins_set_pre</span> or <span class="literal">ins_set_post</span> <span class="ent">➋</span> to install instruction pre- or post-handlers, respectively. Instead of syscall numbers, you index the <span class="literal">ins_desc</span> array using symbolic names provided by Intel’s x86 encoder/decoder library (XED), which comes with Pin. XED defines these names in an <span class="literal">enum</span> called <span class="literal">xed_iclass_enum_t</span>, and each name denotes an instruction class such as <span class="literal">X86_ICLASS_RET_NEAR</span>. The names of the classes correspond to instruction mnemonics. You can find a list of all the instruction class names online at <em><a href="https://intelxed.github.io/ref-manual/">https://intelxed.github.io/ref-manual/</a></em> or in the header file <em>xed-iclass-enum.h</em> that ships with Pin.<sup><a id="ch11fn_4a" href="footnote.xhtml#ch11fn_4">4</a></sup></p>&#13;
<h4 class="h4" id="ch11_2_1"><em>11.2.1 Checking Taint Information</em></h4>&#13;
<p class="noindent">In the previous section, you saw how the <span class="literal">dta-execve</span> tool’s <span class="literal">main</span> function performs all the necessary initialization, sets up the appropriate syscall hooks to serve as taint sources and sinks, and then starts the application. In this case, the taint sink is a syscall hook called <span class="literal">pre_execve_hook</span>, which checks whether any of the <span class="literal">execve</span> arguments are tainted, indicating a control hijacking attack. If so, it raises an alert and stops the attack by aborting the application. Because the taint checking is done repeatedly for every <span class="literal">execve</span> argument, I’ve implemented it in a separate function called <span class="literal">check_string_taint</span>.</p>&#13;
<p class="indent">I’ll discuss <span class="literal">check_string_taint</span> first, and then I’ll move on to the code for <span class="literal">pre_execve_hook</span> in <a href="ch11.xhtml#ch11_2_3">Section 11.2.3</a>. <a href="ch11.xhtml#ch11list2">Listing 11-2</a> shows the <span class="literal">check_string_taint</span> function, as well as the <span class="literal">alert</span> function that is called if an attack is detected.</p>&#13;
<p class="listing1" id="ch11list2"><em>Listing 11-2:</em> dta-execve.cpp <em>(continued)</em></p>&#13;
<p class="programs">   void<br/><span class="ent">➊</span>  alert(uintptr_t addr, const char *source, uint8_t tag)<br/>   {<br/>     fprintf(stderr,<br/>       "\n(dta-execve) !!!!!!! ADDRESS 0x%x IS TAINTED (%s, tag=0x%02x), ABORTING !!!!!!!\n",<br/>       addr, source, tag);<br/>     exit(1);<br/>   }<br/><span epub:type="pagebreak" id="page_287"/>   void<br/><span class="ent">➋</span>  check_string_taint(const char *str, const char *source)<br/>   {<br/>     uint8_t tag;<br/>     uintptr_t start = (uintptr_t)str;<br/>     uintptr_t end   = (uintptr_t)str+strlen(str);<br/><br/>     fprintf(stderr, "(dta-execve) checking taint on bytes 0x%x -- 0x%x (%s)... ",<br/>             start, end, source);<br/><br/><span class="ent">➌</span>   for(uintptr_t addr = start; addr &lt;= end; addr++) {<br/><span class="ent">➍</span>      tag = tagmap_getb(addr);<br/><span class="ent">➎</span>      if(tag != 0) alert(addr, source, tag);<br/>     }<br/><br/>     fprintf(stderr, "OK\n");<br/>   }</p>&#13;
<p class="indent">The <span class="literal">alert</span> function <span class="ent">➊</span> simply prints an alert message with details about the tainted address and then calls <span class="literal">exit</span> to stop the application and prevent the attack. The actual taint-checking logic is implemented in <span class="literal">check_string_taint</span> <span class="ent">➋</span>, which takes two strings as input. The first string (<span class="literal">str</span>) is the one to check for taint, while the second (<span class="literal">source</span>) is a diagnostic string that’s passed to and printed by <span class="literal">alert</span>, specifying the source of the first string, which is the <span class="literal">execve</span> path, an <span class="literal">execve</span> parameter, or an environment parameter.</p>&#13;
<p class="indent">To check the taint of <span class="literal">str</span>, <span class="literal">check_string_taint</span> loops over all of <span class="literal">str</span>’s bytes <span class="ent">➌</span>. For each byte, it checks the taint status using <span class="literal">libdft</span>’s <span class="literal">tagmap_getb</span> function <span class="ent">➍</span>. If the byte is tainted, <span class="literal">alert</span> is called to print an error and exit <span class="ent">➎</span>.</p>&#13;
<p class="indent">The <span class="literal">tagmap_getb</span> function takes the memory address of a byte (in the form of a <span class="literal">uintptr_t</span>) as input and returns the shadow byte containing the taint color for that address. The taint color (called <span class="literal">tag</span> in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>) is a <span class="literal">uint8_t</span> since <span class="literal">libdft</span> keeps one shadow byte per memory byte. If <span class="literal">tag</span> is zero, then the memory byte is untainted. If it’s not zero, the byte is tainted, and the <span class="literal">tag</span> color can be used to find out what the taint source was. Because this DTA tool has only one taint source (network receives), it uses only a single taint color.</p>&#13;
<p class="indent">Sometimes you may want to fetch the taint tag of multiple memory bytes at once. For this purpose, <span class="literal">libdft</span> provides the <span class="literal">tagmap_getw</span> and <span class="literal">tagmap_getl</span> functions, which are analogous to <span class="literal">tagmap_getb</span> but return two or four consecutive shadow bytes at once, in the form of a <span class="literal">uint16_t</span> or a <span class="literal">uint32_t</span>, respectively.</p>&#13;
<h4 class="h4" id="ch11_2_2"><span epub:type="pagebreak" id="page_288"/><em>11.2.2 Taint Sources: Tainting Received Bytes</em></h4>&#13;
<p class="noindent">Now that you know how to check the taint color for a given memory address, let’s discuss how to taint bytes in the first place. <a href="ch11.xhtml#ch11list3">Listing 11-3</a> shows the code of <span class="literal">post_socketcall_hook</span>, which is the taint source called right after each <span class="literal">socketcall</span> syscall and that taints bytes received from the network.</p>&#13;
<p class="listing1" id="ch11list3"><em>Listing 11-3:</em> dta-execve.cpp <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   post_socketcall_hook(syscall_ctx_t *ctx)<br/>   {<br/>     int fd;<br/>     void *buf;<br/>     size_t len;<br/><br/><span class="ent">➊</span>   int call            =            (int)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>   unsigned long *args = (unsigned long*)ctx-&gt;arg[SYSCALL_ARG1];<br/><br/>     switch(call) {<br/><span class="ent">➌</span>   case SYS_RECV:<br/>     case SYS_RECVFROM:<br/><span class="ent">➍</span>      if(unlikely(ctx-&gt;ret &lt;= 0)) {<br/>          return;<br/>       }<br/><br/><span class="ent">➎</span>     fd =     (int)args[0];<br/><span class="ent">➏</span>     buf =  (void*)args[1];<br/><span class="ent">➐</span>     len = (size_t)ctx-&gt;ret;<br/><br/>       fprintf(stderr, "(dta-execve) recv: %zu bytes from fd %u\n", len, fd);<br/><br/>       for(size_t i = 0; i &lt; len; i++) {<br/>         if(isprint(((char*)buf)[i])) fprintf(stderr, "%c", ((char*)buf)[i]);<br/>         else                         fprintf(stderr, "\\x%02x", ((char*)buf)[i]);<br/>       }<br/>       fprintf(stderr, "\n");<br/><br/>       fprintf(stderr, "(dta-execve) tainting bytes %p -- 0x%x with tag 0x%x\n",<br/>               buf, (uintptr_t)buf+len, 0x01);<br/><br/><span class="ent">➑</span>      tagmap_setn((uintptr_t)buf, len, 0x01);<br/><br/>       break;<br/><span epub:type="pagebreak" id="page_289"/>     default:<br/>       break;<br/>     }<br/>   }</p>&#13;
<p class="indent">In <span class="literal">libdft</span>, syscall hooks like <span class="literal">post_socketcall_hook</span> are <span class="literal">void</span> functions that take a <span class="literal">syscall_ctx_t*</span> as their only input argument. In <a href="ch11.xhtml#ch11list3">Listing 11-3</a>, I’ve called that input argument <span class="literal">ctx</span>, and it acts as a descriptor of the syscall that just took place. Among other things, it contains the arguments that were passed to the syscall and the return value of the syscall. The hook inspects <span class="literal">ctx</span> to determine which bytes (if any) to taint.</p>&#13;
<p class="indent">The <span class="literal">socketcall</span> syscall takes two arguments, which you can verify by reading <span class="literal">man socketcall</span>. The first is an <span class="literal">int</span> called <span class="literal">call</span>, and it tells you what kind of <span class="literal">socketcall</span> this is, for example, whether it’s a <span class="literal">recv</span> or <span class="literal">recvfrom</span>. The second, called <span class="literal">args</span>, contains a block of arguments for the <span class="literal">socketcall</span> in the form of an <span class="literal">unsigned long*</span>. The <span class="literal">post_socketcall_hook</span> begins by parsing <span class="literal">call</span> <span class="ent">➊</span> and <span class="literal">args</span> <span class="ent">➋</span> from the syscall <span class="literal">ctx</span>. To get an argument from the syscall <span class="literal">ctx</span>, you read the appropriate entry from its <span class="literal">arg</span> field (for example, <span class="literal">ctx-&gt;arg[SYSCALL_ARG0]</span>) and cast it to the correct type.</p>&#13;
<p class="indent">Next, <span class="literal">dta-execve</span> uses a <span class="literal">switch</span> to differentiate between the different possible <span class="literal">call</span> types. If <span class="literal">call</span> indicates that this is a <span class="literal">SYS_RECV</span> or <span class="literal">SYS_RECVFROM</span> event <span class="ent">➌</span>, then <span class="literal">dta-execve</span> inspects it more closely to find out which bytes were received and need to be tainted. It simply ignores any other event in the <span class="literal">default</span> case.</p>&#13;
<p class="indent">If the current event is a receive, then the next thing <span class="literal">dta-execve</span> does is check the return value of the <span class="literal">socketcall</span> by inspecting <span class="literal">ctx-&gt;ret</span> <span class="ent">➍</span>. If it’s less than or equal to zero, then no bytes were received, so nothing is tainted and the syscall hook simply returns. Inspecting the return value is possible only in a post-handler, since in a pre-handler the syscall you’re hooking hasn’t happened yet.</p>&#13;
<p class="indent">If bytes were received, then you need to parse the <span class="literal">args</span> array to access the <span class="literal">recv</span> or <span class="literal">recvfrom</span> argument and find the address of the receive buffer. The <span class="literal">args</span> array contains the arguments in the same order as the socket function corresponding to the <span class="literal">call</span> type. For <span class="literal">recv</span> and <span class="literal">recvfrom</span>, that means <span class="literal">args[0]</span> contains the socket file descriptor number <span class="ent">➎</span>, and <span class="literal">args[1]</span> contains the receive buffer address <span class="ent">➏</span>. The rest of the arguments aren’t needed here, so <span class="literal">post_socketcall_hook</span> doesn’t parse them. Given the receive buffer address and the <span class="literal">socketcall</span> return value (which indicates the number of received bytes <span class="ent">➐</span>), <span class="literal">post_socketcall_hook</span> can now taint all the received bytes.</p>&#13;
<p class="indent">After some diagnostic prints of the received bytes, <span class="literal">post_socketcall_hook</span> finally taints the received bytes by calling <span class="literal">tagmap_setn</span> <span class="ent">➑</span>, a <span class="literal">libdft</span> function that can taint an arbitrary number of bytes at once. It takes a <span class="literal">uintptr_t</span> representing a memory address as its first parameter, which is the first address that will be tainted. The next parameter is a <span class="literal">size_t</span> that specifies the number of bytes to taint and then a <span class="literal">uint8_t</span> containing the taint color. In this case, I’ve set the taint color to <span class="literal">0x01</span>. Now, all the received bytes are tainted, so if they ever influence any of <span class="literal">execve</span>’s inputs, <span class="literal">dta-execve</span> will notice and raise an alert.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>To taint only a small fixed number of bytes, <span class="literal">libdft</span> also provides functions called <span class="literal">tagmap_setb</span>, <span class="literal">tagmap_setw</span>, and <span class="literal">tagmap_setl</span>, which taint one, two, or four consecutive bytes, respectively. These have arguments equivalent to <span class="literal">tagmap_setn</span>, except that they omit the length parameter.</p>&#13;
<h4 class="h4" id="ch11_2_3"><em>11.2.3 Taint Sinks: Checking execve Arguments</em></h4>&#13;
<p class="noindent">Finally, let’s take a look at <span class="literal">pre_execve_hook</span>, the syscall hook that runs just before every <span class="literal">execve</span> and makes sure the <span class="literal">execve</span> inputs aren’t tainted. <a href="ch11.xhtml#ch11list4">Listing 11-4</a> shows the code of <span class="literal">pre_execve_hook</span>.</p>&#13;
<p class="listing1" id="ch11list4"><em>Listing 11-4:</em> dta-execve.cpp <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   pre_execve_hook(syscall_ctx_t *ctx)<br/>   {<br/><span class="ent">➊</span>   const char *filename = (const char*)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>   char * const *args   = (char* const*)ctx-&gt;arg[SYSCALL_ARG1];<br/><span class="ent">➌</span>   char * const *envp   = (char* const*)ctx-&gt;arg[SYSCALL_ARG2];<br/><br/>     fprintf(stderr, "(dta-execve) execve: %s (@%p)\n", filename, filename);<br/><br/><span class="ent">➍</span>    check_string_taint(filename, "execve command");<br/><span class="ent">➎</span>    while(args &amp;&amp; *args) {<br/>        fprintf(stderr, "(dta-execve) arg: %s (@%p)\n", *args, *args);<br/><span class="ent">➏</span>       check_string_taint(*args, "execve argument");<br/>        args++;<br/>     }<br/><span class="ent">➐</span>    while(envp &amp;&amp; *envp) {<br/>        fprintf(stderr, "(dta-execve) env: %s (@%p)\n", *envp, *envp);<br/><span class="ent">➑</span>       check_string_taint(*envp, "execve environment parameter");<br/>        envp++;<br/>     }<br/>   }</p>&#13;
<p class="indent">The first thing <span class="literal">pre_execve_hook</span> does is parse the inputs of the <span class="literal">execve</span> from its <span class="literal">ctx</span> parameter. These inputs are the filename of the program the <span class="literal">execve</span> is about to run <span class="ent">➊</span> and then the argument array <span class="ent">➋</span> and environment array <span class="ent">➌</span> passed to <span class="literal">execve</span>. If any of these inputs are tainted, <span class="literal">pre_execve_hook</span> will raise an alert.</p>&#13;
<p class="indent">To check each input for taint, <span class="literal">pre_execve_hook</span> uses the <span class="literal">check_string_taint</span> function I previously described in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>. First, it uses this function to verify that the <span class="literal">execve</span> filename parameter is untainted <span class="ent">➍</span>. Subsequently, it loops over all the <span class="literal">execve</span> arguments <span class="ent">➎</span> and checks each of these for taint <span class="ent">➏</span>. Finally, <span class="literal">pre_execve_hook</span> loops over the environment array <span class="ent">➐</span> and checks that each environment parameter is untainted <span class="ent">➑</span>. If none of the inputs is tainted, <span class="literal">pre_execve_hook</span> runs to completion, and the <span class="literal">execve</span> syscall proceeds without <span epub:type="pagebreak" id="page_291"/>any alert. On the other hand, if any tainted input is found, then the program is aborted, and an error message is printed.</p>&#13;
<p class="indent">That’s all of the code in the <span class="literal">dta-execve</span> tool! As you can see, <span class="literal">libdft</span> allows you to implement DTA tools in a concise way. In this case, the example tool consists of only 165 lines of code, including all comments and diagnostic prints. Now that you’ve explored all of <span class="literal">dta-execve</span>’s code, let’s test how well it can detect attacks.</p>&#13;
<h4 class="h4" id="ch11_2_4"><em>11.2.4 Detecting a Control-Flow Hijacking Attempt</em></h4>&#13;
<p class="noindent">To test <span class="literal">dta-execve</span>’s ability to detect network-borne control-hijacking attacks, I’ll use a test program called <span class="literal">execve-test-overflow</span>. <a href="ch11.xhtml#ch11list5">Listing 11-5</a> shows the first part of its source, containing the <span class="literal">main</span> function. To save space, I omit error-checking code and unimportant functions in the listings of the test programs. As usual, you can find the full programs on the VM.</p>&#13;
<p class="listing1" id="ch11list5"><em>Listing 11-5:</em> execve-test-overflow.c</p>&#13;
<p class="programs">   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     char buf[4096];<br/>     struct sockaddr_storage addr;<br/><br/><span class="ent">➊</span>   int sockfd = open_socket("localhost", "9999");<br/><br/>     socklen_t addrlen = sizeof(addr);<br/><span class="ent">➋</span>   recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr*)&amp;addr, &amp;addrlen);<br/><br/><span class="ent">➌</span>   int child_fd = exec_cmd(buf);<br/><span class="ent">➍</span>   FILE *fp = fdopen(child_fd, "r");<br/><br/>     while(fgets(buf, sizeof(buf), fp)) {<br/><span class="ent">➎</span>       sendto(sockfd, buf, strlen(buf)+1, 0, (struct sockaddr*)&amp;addr, addrlen);<br/>     }<br/><br/>     return 0;<br/>   }</p>&#13;
<p class="indent">As you can see, <span class="literal">execve-test-overflow</span> is a simple server program that opens a network socket (using the <span class="literal">open_socket</span> function omitted from the listing) and listens on <span class="literal">localhost</span> at port 9999 <span class="ent">➊</span>. Next, it receives a message from the socket <span class="ent">➋</span> and passes that message to a function called <span class="literal">exec_cmd</span> <span class="ent">➌</span>. As I’ll explain in the next listing, <span class="literal">exec_cmd</span> is a vulnerable function that executes a command using <span class="literal">execv</span> and can be influenced by an attacker who sends a malicious message to the server. When <span class="literal">exec_cmd</span> completes, it returns <span epub:type="pagebreak" id="page_292"/>a file descriptor that the server uses to read the output of the executed command <span class="ent">➍</span>. Finally, the server writes the command output to the network socket <span class="ent">➎</span>.</p>&#13;
<p class="indent">Normally, the <span class="literal">exec_cmd</span> function executes a program called <span class="literal">date</span> to get the current time and date, and the server then echoes this output over the network, prefixing it with the message previously received from the socket. However, <span class="literal">exec_cmd</span> contains a vulnerability that allows attackers to run a command of their choosing, as shown in <a href="ch11.xhtml#ch11list6">Listing 11-6</a>.</p>&#13;
<p class="listing1" id="ch11list6"><em>Listing 11-6:</em> execve-test-overflow.c <em>(continued)</em></p>&#13;
<p class="programs"><span class="ent">➊</span>  static struct __attribute__((packed)) {<br/><span class="ent">➋</span>   char prefix[32];<br/>     char datefmt[32];<br/>     char cmd[64];<br/>   } cmd = { "date: ", "\%Y-\%m-\%d \%H:\%M:\%S",<br/>             "/home/binary/code/chapter11/date" };<br/><br/>   int<br/>   exec_cmd(char *buf)<br/>   {<br/>     int pid;<br/>     int p[2];<br/>     char *argv[3];<br/><br/><span class="ent">➌</span>   for(size_t i = 0; i &lt; strlen(buf); i++) { /* Buffer overflow! */<br/>       if(buf[i] == '\n') {<br/>         cmd.prefix[i] = '\0';<br/>         break;<br/>       }<br/>       cmd.prefix[i] = buf[i];<br/>    }<br/><br/><span class="ent">➍</span>   argv[0] = cmd.cmd;<br/>    argv[1] = cmd.datefmt;<br/>    argv[2] = NULL;<br/><br/><span class="ent">➎</span>   pipe(p);<br/><span class="ent">➏</span>   switch(pid = fork()) {<br/>    case -1: /* Error */<br/>      perror("(execve-test) fork failed");<br/>      return -1;<br/><span class="ent">➐</span>   case 0: /* Child */<br/>       printf("(execve-test/child) execv: %s %s\n", argv[0], argv[1]);<br/><br/><span class="ent">➑</span>     close(1);<br/>       dup(p[1]);<br/>       close(p[0]);<br/><br/><span epub:type="pagebreak" id="page_293"/>       printf("%s", cmd.prefix);<br/>       fflush(stdout);<br/><span class="ent">➒</span>     execv(argv[0], argv);<br/>       perror("(execve-test/child) execv failed");<br/>       kill(getppid(), SIGINT);<br/>       exit(1);<br/>     default: /* Parent */<br/>       close(p[1]);<br/>       return p[0];<br/>     }<br/><br/>     return -1;<br/>  }</p>&#13;
<p class="indent">The server uses a global <span class="literal">struct</span> called <span class="literal">cmd</span> to keep track of the command and its associated parameters <span class="ent">➊</span>. It contains a <span class="literal">prefix</span> for the command output (the message previously received from the socket) <span class="ent">➋</span>, as well as a date format string and a buffer containing the <span class="literal">date</span> command itself. While Linux comes with a default <span class="literal">date</span> utility, I’ve implemented my own for this test, which you’ll find in <em>~/code/chapter11/date</em>. This is necessary because the default <span class="literal">date</span> utility on the VM is 64-bit, which <span class="literal">libdft</span> does not support.</p>&#13;
<p class="indent">Now let’s take a look at the <span class="literal">exec_cmd</span> function, which begins by copying the message received from the network (stored in <span class="literal">buf</span>) into <span class="literal">cmd</span>’s <span class="literal">prefix</span> field <span class="ent">➌</span>. As you can see, the copy lacks proper bound checks, which means attackers could send a malicious message that would overflow <span class="literal">prefix</span>, allowing them to overwrite the adjacent fields in <span class="literal">cmd</span>, containing the date format and the command path.</p>&#13;
<p class="indent">Next, <span class="literal">exec_cmd</span> copies the command and date format argument from the <span class="literal">cmd</span> structure into an <span class="literal">argv</span> array to use for the <span class="literal">execv</span> <span class="ent">➍</span>. Then, it opens a pipe <span class="ent">➎</span> and uses <span class="literal">fork</span> <span class="ent">➏</span> to start a child process <span class="ent">➐</span>, which will execute the command and report the output to the parent process. The child process redirects <span class="literal">stdout</span> over the pipe <span class="ent">➑</span> so that the parent process can read the <span class="literal">execv</span> output from the pipe and forward it over the socket. Finally, the child calls the <span class="literal">execv</span> with the possibly attacker-controlled command and arguments as input <span class="ent">➒</span>.</p>&#13;
<p class="indent">Let’s now run <span class="literal">execve-test-overflow</span> to see how an attacker can abuse the <span class="literal">prefix</span> overflow vulnerability to hijack control in practice. I’ll first run it without the protection of the <span class="literal">dta-execve</span> tool so that you can see the attack succeed. After that, I’ll enable <span class="literal">dta-execve</span> so you can see how it detects and stops the attack.</p>&#13;
<h3 class="h3">A Successful Control Hijack Without DTA</h3>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11list7">Listing 11-7</a> shows a benign run of <span class="literal">execve-test-overflow</span>, followed by an example of how to exploit the buffer overflow to execute a command of the attacker’s choice instead of <span class="literal">date</span>. I’ve replaced some repetitive parts of the output with “...” to keep the code lines from becoming too wide.</p>&#13;
<p class="listing1" id="ch11list7"><span epub:type="pagebreak" id="page_294"/><em>Listing 11-7: Control hijacking in</em> <span class="codeitalic">execve-test-overflow</span></p>&#13;
<p class="programs">   $ <span class="codestrong1">cd /home/binary/code/chapter11/</span><br/><span class="ent">➊</span> $ <span class="codestrong1">./execve-test-overflow &amp;</span><br/>   [1] 2506<br/><span class="ent">➋</span> $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➌</span> foobar:<br/>   (execve-test/child) execv: /home/binary/code/chapter11/date %Y-%m-%d %H:%M:%S<br/><span class="ent">➍</span> foobar: 2017-12-06 15:25:08<br/>   <span class="codestrong1">ˆC</span><br/>   [1]+ Done                     ./execve-test-overflow<br/><span class="ent">➎</span> $ <span class="codestrong1">./execve-test-overflow &amp;</span><br/>   [1] 2533<br/><span class="ent">➏</span> $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➐</span> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB/home/binary/code/chapter11/echo<br/>   (execve-test/child) execv: /home/binary/code/chapter11/echo BB...BB/home/binary/.../echo<br/><span class="ent">➑</span> AA...AABB...BB/home/binary/code/chapter11/echo BB...BB/home/binary/code/chapter11/echo<br/>   <span class="codestrong1">ˆC</span><br/>   [1]+ Done                     ./execve-test-overflow</p>&#13;
<p class="indent">For the benign run, I start the <span class="literal">execve-test-overflow</span> server as a background process <span class="ent">➊</span> and then use <span class="literal">netcat</span> (<span class="literal">nc</span>) to connect to the server <span class="ent">➋</span>. In <span class="literal">nc</span>, I enter the string “<span class="literal">foobar:</span> ” <span class="ent">➌</span> and send it to the server, which will use it as the output prefix. The server runs the <span class="literal">date</span> command and echoes back the current date, prefixed with “<span class="literal">foobar:</span> ” <span class="ent">➍</span>.</p>&#13;
<p class="indent">Now to demonstrate the buffer overflow vulnerability, I restart the server <span class="ent">➎</span> and connect to it again with <span class="literal">nc</span> <span class="ent">➏</span>. This time, the string I send is much longer <span class="ent">➐</span>, long enough to overflow the <span class="literal">prefix</span> field in the global <span class="literal">cmd</span> structure. It consists of 32 <span class="literal">A</span>s to fill up the 32-byte <span class="literal">prefix</span> buffer, followed by 32 <span class="literal">B</span>s, which overflow into the <span class="literal">datefmt</span> buffer and again fill it up completely. The last part of the string overflows into the <span class="literal">cmd</span> buffer, and it’s a path to the program to run instead of <span class="literal">date</span>, namely, <em>~/code/chapter11/echo</em>. At this point, the contents of the global <span class="literal">cmd</span> struct look as follows:</p>&#13;
<p class="programs">static struct __attribute__((packed)) {<br/>  char prefix[32];  /* AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA */<br/>  char datefmt[32]; /* BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB */<br/>  char cmd[64];     /* /home/binary/code/chapter11/echo */<br/>} cmd;</p>&#13;
<p class="indent">Recall that the server copies the contents of the <span class="literal">cmd</span> structure into the <span class="literal">argv</span> array used for the <span class="literal">execv</span>. Thus, as a result of the overflow, the <span class="literal">execv</span> runs the <span class="literal">echo</span> program instead of <span class="literal">date</span>! The <span class="literal">datefmt</span> buffer is passed to <span class="literal">echo</span> as a command line argument, but because it doesn’t contain a terminating <span class="literal">NULL</span>, the real command line argument that <span class="literal">echo</span> sees is <span class="literal">datefmt</span> concatenated with the <span class="literal">cmd</span> buffer. Finally, after running <span class="literal">echo</span>, the server writes the output back <span epub:type="pagebreak" id="page_295"/>to the socket <span class="ent">➑</span>, which consists of the concatenation of <span class="literal">prefix</span>, <span class="literal">datefmt</span>, and <span class="literal">cmd</span> as the prefix, followed by the output of the <span class="literal">echo</span> command.</p>&#13;
<p class="indent">Now that you know how to coax the <span class="literal">execve-test-overflow</span> program into executing an unintended command by supplying it with a malicious input from the network, let’s see whether the <span class="literal">dta-execve</span> tool will succeed in stopping this attack!</p>&#13;
<h3 class="h3">Using DTA to Detect the Hijacking Attempt</h3>&#13;
<p class="noindent">To test whether <span class="literal">dta-execve</span> can stop the attack in the previous section, I’ll run the same attack again. Only this time, <span class="literal">execve-test-overflow</span> will be protected by the <span class="literal">dta-execve</span> tool. <a href="ch11.xhtml#ch11list8">Listing 11-8</a> shows the results.</p>&#13;
<p class="listing1" id="ch11list8"><em>Listing 11-8: Detecting an attempted control hijack with</em> <span class="codeitalic">dta-execve</span></p>&#13;
<p class="programs">   $ <span class="codestrong1">cd /home/binary/libdft/pin-2.13-61206-gcc.4.4.7-linux/</span><br/><span class="ent">➊</span>  $ <span class="codestrong1">./pin.sh -follow_execv -t /home/binary/code/chapter11/dta-execve.so \</span><br/>              <span class="codestrong1">-- /home/binary/code/chapter11/execve-test-overflow &amp;</span><br/>   [1] 2994<br/><span class="ent">➋</span>  $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➌</span>  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB/home/binary/code/chapter11/echo<br/><span class="ent">➍</span>  (dta-execve) recv: 97 bytes from fd 4<br/>    AA...AABB...BB/home/binary/code/chapter11/echo\x0a<br/><span class="ent">➎</span>  (dta-execve) tainting bytes 0xffa231ec -- 0xffa2324d with tag 0x1<br/><span class="ent">➏</span>  (execve-test/child) execv: /home/binary/code/chapter11/echo BB...BB/home/binary/.../echo<br/><span class="ent">➐</span>  (dta-execve) execve: /home/binary/code/chapter11/echo (@0x804b100)<br/><span class="ent">➑</span>  (dta-execve) checking taint on bytes 0x804b100 -- 0x804b120 (execve command)...<br/><span class="ent">➒</span>  (dta-execve) !!!!!!! ADDRESS 0x804b100 IS TAINTED (execve command, tag=0x01), ABORTING !!!!!!!<br/><span class="ent">➓</span>   AA...AABB...BB/home/binary/code/chapter11/echo<br/>    [1]+ Done ./pin.sh -follow_execv ...</p>&#13;
<p class="indent">Because <span class="literal">libdft</span> is based on Pin, you’ll need to run Pin using <span class="literal">dta-execve</span> as the Pin tool <span class="ent">➊</span> to protect <span class="literal">execve-test-overflow</span> with <span class="literal">dta-execve</span>. As you can see, I’ve added <span class="literal">-follow_execv</span> to the Pin options so that Pin will instrument all child processes of <span class="literal">execve-test-overflow</span> the same way as the parent process. This is important because the vulnerable <span class="literal">execv</span> is called in a child process.</p>&#13;
<p class="indent">After starting the <span class="literal">execve-test-overflow</span> server protected with <span class="literal">dta-execve</span>, I run <span class="literal">nc</span> again to connect to the server <span class="ent">➋</span>. Then, I send the same exploit string used in the previous section <span class="ent">➌</span> to overflow the <span class="literal">prefix</span> buffer and change the <span class="literal">cmd</span>. Keep in mind that <span class="literal">dta-execve</span> uses network receives as taint sources. You can see this in <a href="ch11.xhtml#ch11list8">Listing 11-8</a> because the <span class="literal">socketcall</span> handler prints a diagnostic message showing that it has intercepted the received message <span class="ent">➍</span>. The <span class="literal">socketcall</span> handler then taints all the bytes received from the network <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, a diagnostic print from the server tells you that it’s about to execute the attacker-controlled <span class="literal">echo</span> command <span class="ent">➏</span>. Fortunately, this time <span class="literal">dta-execve</span> intercepts the <span class="literal">execv</span> before it’s too late <span class="ent">➐</span>. It checks the taint on all of the <span class="literal">execv</span> arguments, starting with the <span class="literal">execv</span> command <span class="ent">➑</span>. Since this command is controlled by the attacker via the network-borne buffer overflow, <span class="literal">dta-execve</span> notices that the command is tainted with color <span class="literal">0x01</span>. It raises an <span epub:type="pagebreak" id="page_296"/>alert and then stops the child process that’s about to execute the attacker’s command, thereby successfully preventing the attack <span class="ent">➒</span>. The only server output that’s written back to the attacker is the prefix string they themselves supplied <span class="ent">➓</span>, since it was printed before the <span class="literal">execv</span> that caused <span class="literal">dta-execve</span> to abort the child process.</p>&#13;
<h3 class="h3" id="ch11_3">11.3 Circumventing DTA with Implicit Flows</h3>&#13;
<p class="noindent">So far so good: <span class="literal">dta-execve</span> successfully detected and stopped the control-hijacking attack from the previous section. Unfortunately, <span class="literal">dta-execve</span> is not entirely foolproof because practical DTA systems like <span class="literal">libdft</span> can’t track data propagated through <em>implicit flows</em>. <a href="ch11.xhtml#ch11list9">Listing 11-9</a> shows a modified version of the <span class="literal">execve-test-overflow</span> server, which contains an implicit flow that prevents <span class="literal">dta-execve</span> from detecting the attack. For brevity, the listing shows only the parts of the code that are different from the original server.</p>&#13;
<p class="listing1" id="ch11list9"><em>Listing 11-9:</em> execve-test-overflow-implicit.c</p>&#13;
<p class="programs">  int<br/>  exec_cmd(char *buf)<br/>  {<br/>    int pid;<br/>    int p[2];<br/>    char *argv[3];<br/><br/><span class="ent">➊</span>   for(size_t i = 0; i &lt; strlen(buf); i++) {<br/>       if(buf[i] == '\n') {<br/>         cmd.prefix[i] = '\0';<br/>         break;<br/>       }<br/><span class="ent">➋</span>      char c = 0;<br/><span class="ent">➌</span>      while(c &lt; buf[i]) c++;<br/><span class="ent">➍</span>      cmd.prefix[i] = c;<br/>    }<br/><br/>    /* Set up argv and continue with execv */<br/>  }</p>&#13;
<p class="indent">The only changed parts of the code are in the <span class="literal">exec_cmd</span> function, which contains a vulnerable <span class="literal">for</span> loop that copies all of the bytes from the receive buffer <span class="literal">buf</span> into the global <span class="literal">prefix</span> buffer <span class="ent">➊</span>. As before, the loop lacks bounds checking, so <span class="literal">prefix</span> will overflow if the message in <span class="literal">buf</span> is too long. Now, however, the bytes are copied <em>implicitly</em> in such a way that the overflow isn’t detected by the DTA tool!</p>&#13;
<p class="indent">As explained in <a href="ch10.xhtml#ch10">Chapter 10</a>, implicit flows are the result of <em>control dependencies</em>, meaning that the data propagation depends on control structures instead of explicit data operations. In <a href="ch11.xhtml#ch11list9">Listing 11-9</a>, that control structure is a <span class="literal">while</span> loop. For each byte, the modified <span class="literal">exec_cmd</span> function initializes a <span class="literal">char c</span> <span epub:type="pagebreak" id="page_297"/>to zero <span class="ent">➋</span> and then uses the <span class="literal">while</span> loop to increment <span class="literal">c</span> until it has the same value as <span class="literal">buf[i]</span> <span class="ent">➌</span>, effectively copying <span class="literal">buf[i]</span> into <span class="literal">c</span> without ever explicitly copying any data. Finally, <span class="literal">c</span> is copied into <span class="literal">prefix</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Ultimately, the effect of this code is the same as in the original version of <span class="literal">execve-test-overflow</span>: <span class="literal">buf</span> is copied into <span class="literal">prefix</span>. However, the key is that <em>there’s no explicit data flow between</em> <span class="literal"><em>buf</em></span> <em>and</em> <em><span class="literal">prefix</span></em> because the copy from <span class="literal">buf[i]</span> into <span class="literal">c</span> is implemented using that <span class="literal">while</span> loop, avoiding an explicit data copy. This introduces a control dependency between <span class="literal">buf[i]</span> and <span class="literal">c</span> (and thus, transitively, between <span class="literal">buf[i]</span> and <span class="literal">prefix[i]</span>), which <span class="literal">libdft</span> cannot track.</p>&#13;
<p class="indent">When you retry <a href="ch11.xhtml#ch11list8">Listing 11-8</a>’s attack by replacing <span class="literal">execve-test-overflow</span> with <span class="literal">execve-test-overflow-implicit</span>, you’ll see that the attack now succeeds despite <span class="literal">dta-execve</span>’s protection!</p>&#13;
<p class="indent">You may remark that if you’re using DTA to prevent attacks against a server that you control, you can just write the server in such a way that it doesn’t contain implicit flows that confuse <span class="literal">libdft</span>. While this may be possible (though not trivial) in most cases, in malware analysis you’ll find it difficult to get around the problem of implicit flows, because you don’t control the malware’s code and the malware may contain deliberately crafted implicit flows to confuse taint analysis.</p>&#13;
<h3 class="h3" id="ch11_4">11.4 A DTA-Based Data Exfiltration Detector</h3>&#13;
<p class="noindent">The previous example tool requires only a single taint color because bytes are either attacker controlled or not. Now let’s build a tool that uses multiple taint colors to detect file-based information leaks so that when a file leaks, you can tell <em>which</em> file. The idea behind this tool is similar to the taint-based defense against the Heartbleed bug you saw in <a href="ch10.xhtml#ch10">Chapter 10</a>, except that here the tool uses file reads instead of memory buffers as the taint source.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11list10">Listing 11-10</a> shows the first part of this new tool, which I’ll call <span class="literal">dta -dataleak</span>. Again, I omit includes of standard C header files for brevity.</p>&#13;
<p class="listing1" id="ch11list10"><em>Listing 11-10:</em> dta-dataleak.cpp</p>&#13;
<p class="programs"><span class="ent">➊</span>  #include "pin.H"<br/><br/>   #include  "branch_pred.h"<br/>   #include  "libdft_api.h"<br/>   #include  "syscall_desc.h"<br/>   #include  "tagmap.h"<br/><br/><span class="ent">➋</span>  extern syscall_desc_t syscall_desc[SYSCALL_MAX];<br/><span class="ent">➌</span>  static std::map&lt;int, uint8_t&gt; fd2color;<br/><span class="ent">➍</span>  static std::map&lt;uint8_t, std::string&gt; color2fname;<br/><br/><span class="ent">➎</span>  #define MAX_COLOR 0x80<br/><br/>   void alert(uintptr_t addr, uint8_t tag);<br/>   static void post_open_hook(syscall_ctx_t *ctx);<br/>   static void post_read_hook(syscall_ctx_t *ctx);<br/>   static void pre_socketcall_hook(syscall_ctx_t *ctx);<br/><br/>   int<br/>   main(int argc, char **argv)<br/>   {<br/>     PIN_InitSymbols();<br/><br/>     if(unlikely(PIN_Init(argc, argv))) {<br/>       return 1;<br/>     }<br/><br/>     if(unlikely(libdft_init() != 0)) {<br/>       libdft_die();<br/>       return 1;<br/>     }<br/><br/><span class="ent">➏</span>  syscall_set_post(&amp;syscall_desc[__NR_open], post_open_hook);<br/><span class="ent">➐</span>  syscall_set_post(&amp;syscall_desc[__NR_read], post_read_hook);<br/><span class="ent">➑</span>  syscall_set_pre (&amp;syscall_desc[__NR_socketcall], pre_socketcall_hook);<br/><br/>   PIN_StartProgram();<br/><br/>   return 0;<br/> }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Just as in the previous DTA tool, <span class="literal">dta-dataleak</span> includes <em>pin.H</em> and all the relevant <span class="literal">libdft</span> header files <span class="ent">➊</span>. It also includes the now familiar <span class="literal">extern</span> declaration of the <span class="literal">syscall_desc</span> array <span class="ent">➋</span> to hook syscalls for the taint sources and sinks. In addition, <span class="literal">dta-dataleak</span> defines some data structures that weren’t there in <span class="literal">dta-execve</span>.</p>&#13;
<p class="indent">The first of these, <span class="literal">fd2color</span>, is a C++ <span class="literal">map</span> that maps file descriptors to taint colors <span class="ent">➌</span>. The second is also a C++ map, called <span class="literal">color2fname</span>, and it maps taint colors to filenames <span class="ent">➍</span>. You’ll see why these data structures are needed in the next few listings.</p>&#13;
<p class="indent">There’s also a <span class="literal">#define</span> of a constant called <span class="literal">MAX_COLOR</span> <span class="ent">➎</span>, which is the maximum possible taint color value, <span class="literal">0x80</span>.</p>&#13;
<p class="indent">The <span class="literal">main</span> function of <span class="literal">dta-dataleak</span> is almost identical to that of <span class="literal">dta-execve</span> in that it initializes Pin and <span class="literal">libdft</span> and then starts the application. The only difference is in which taint sources and sinks <span class="literal">dta-dataleak</span> defines. It installs two post-handlers, called <span class="literal">post_open_hook</span> <span class="ent">➏</span> and <span class="literal">post_read_hook</span> <span class="ent">➐</span>, which run just after the <span class="literal">open</span> and <span class="literal">read</span> syscalls, respectively. The <span class="literal">open</span> hook keeps track of which file descriptors are open, while the <span class="literal">read</span> hook is the actual taint source, which taints bytes read from open files, as I’ll explain in a moment.</p>&#13;
<p class="indent">In addition, <span class="literal">dta-dataleak</span> installs a pre-handler for the <span class="literal">socketcall</span> syscall, called <span class="literal">pre_socketcall_hook</span> <span class="ent">➑</span>. The <span class="literal">pre_socketcall_hook</span> is the taint sink, which intercepts any data that’s about to be sent over the network so that it can <span epub:type="pagebreak" id="page_299"/>make sure the data isn’t tainted before allowing the send. If any tainted data is about to be leaked, <span class="literal">pre_socketcall_hook</span> raises an alert, using a function called <span class="literal">alert</span>, which I’ll explain next.</p>&#13;
<p class="indent">Keep in mind that this example tool is simplified. In a real tool, you’ll want to hook additional taint sources (such as the <span class="literal">readv</span> syscall) and sinks (such as <span class="literal">write</span> syscalls on a socket) for completeness. You’ll also want to implement some rules that determine which files are okay to leak over the network and which aren’t, rather than assuming all file leaks are malicious.</p>&#13;
<p class="indent">Now let’s take a look at the <span class="literal">alert</span> function, shown in <a href="ch11.xhtml#ch11list11">Listing 11-11</a>, which is called if any tainted data is about to leak over the network. Because it’s similar to <span class="literal">dta-execve</span>’s <span class="literal">alert</span> function, I’ll describe it only briefly here.</p>&#13;
<p class="listing1" id="ch11list11"><em>Listing 11-11:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<p class="programs">   void<br/>   alert(uintptr_t addr, uint8_t tag)<br/>   {<br/><span class="ent">➊</span>   fprintf(stderr,<br/>       "\n(dta-dataleak) !!!!!!! ADDRESS 0x%x IS TAINTED (tag=0x%02x), ABORTING !!!!!!!\n",<br/>       addr, tag);<br/><br/><span class="ent">➋</span>   for(unsigned c = 0x01; c &lt;= MAX_COLOR; c &lt;&lt;= 1) {<br/><span class="ent">➌</span>     if(tag &amp; c) {<br/><span class="ent">➍</span>       fprintf(stderr, " tainted by color = 0x%02x (%s)\n", c, color2fname[c].c_str());<br/>      }<br/>    }<br/><span class="ent">➎</span>   exit(1);<br/>  }</p>&#13;
<p class="indent">The <span class="literal">alert</span> function starts by displaying an alert message, detailing which address is tainted and with which colors <span class="ent">➊</span>. It’s possible that the data leaked over the network is influenced by multiple files and therefore tainted with multiple colors. So, <span class="literal">alert</span> loops over all possible taint colors <span class="ent">➋</span> and checks which of them are present in the tag of the tainted byte that caused the alert <span class="ent">➌</span>. For each color that’s enabled in the tag, <span class="literal">alert</span> prints the color and the corresponding filename <span class="ent">➍</span>, which it reads from the <span class="literal">color2fname</span> data structure. Finally, <span class="literal">alert</span> calls <span class="literal">exit</span> to stop the application and prevent the data leak <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, let’s examine the taint sources for the <span class="literal">dta-dataleak</span> tool.</p>&#13;
<h4 class="h4" id="ch11_4_1"><em>11.4.1 Taint Sources: Tracking Taint for Open Files</em></h4>&#13;
<p class="noindent">As I just mentioned, <span class="literal">dta-dataleak</span> installs two syscall post-handlers: a hook for the <span class="literal">open</span> syscall that keeps track of open files and a hook for <span class="literal">read</span> that taints bytes read from open files. Let’s first look at the code for the <span class="literal">open</span> hook and then look at the <span class="literal">read</span> handler.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_300"/>Tracking Open Files</h3>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11list12">Listing 11-12</a> shows the code for <span class="literal">post_open_hook</span>, the post-handler for the <span class="literal">open</span> syscall.</p>&#13;
<p class="listing1" id="ch11list12"><em>Listing 11-12:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   post_open_hook(syscall_ctx_t *ctx)<br/>   {<br/><span class="ent">➊</span>   static uint8_t next_color = 0x01;<br/>     uint8_t color;<br/><span class="ent">➋</span>   int fd            =         (int)ctx-&gt;ret;<br/><span class="ent">➌</span>   const char *fname = (const char*)ctx-&gt;arg[SYSCALL_ARG0];<br/>   <br/><span class="ent">➍</span>   if(unlikely((int)ctx-&gt;ret &lt; 0)) {<br/>       return;<br/>     }<br/>   <br/><span class="ent">➎</span>   if(strstr(fname, ".so") || strstr(fname, ".so.")) {<br/>       return;<br/>     }<br/>   <br/>     fprintf(stderr, "(dta-dataleak) opening %s at fd %u with color 0x%02x\n",<br/>            fname, fd, next_color);<br/>   <br/><span class="ent">➏</span>    if(!fd2color[fd]) {<br/>        color = next_color;<br/>        fd2color[fd] = color;<br/><span class="ent">➐</span>      if(next_color &lt; MAX_COLOR) next_color &lt;&lt;= 1;<br/><span class="ent">➑</span>    } else {<br/>       /* reuse color of file with same fd that was opened previously */<br/>       color = fd2color[fd];<br/>     }<br/>   <br/>     /* multiple files may get the same color if the same fd is reused<br/>     * or we run out of colors */<br/><span class="ent">➒</span>   if(color2fname[color].empty()) color2fname[color] = std::string(fname);<br/><span class="ent">➓</span>   else color2fname[color] += " | " + std::string(fname);<br/>  }</p>&#13;
<p class="indent">Recall that the purpose of <span class="literal">dta-dataleak</span> is to detect information leak attempts that leak data read from a file. For <span class="literal">dta-dataleak</span> to tell <em>which</em> file is being leaked, it assigns a different color to each open file. The purpose of the <span class="literal">open</span> syscall handler, <span class="literal">post_open_hook</span>, is to assign a taint color to each file descriptor when it’s opened. It also filters out some uninteresting files, such <span epub:type="pagebreak" id="page_301"/>as shared libraries. In a real-world DTA tool, you’ll likely want to implement more filters to control which files to protect against information leaks.</p>&#13;
<p class="indent">To keep track of the next available taint color, <span class="literal">post_open_hook</span> uses a <span class="literal">static</span> variable called <span class="literal">next_color</span>, which is initialized to the color <span class="literal">0x01</span> <span class="ent">➊</span>. Next, it parses the syscall context (<span class="literal">ctx</span>) of the <span class="literal">open</span> syscall that just occurred to obtain the file descriptor <span class="literal">fd</span> <span class="ent">➋</span> and the filename <span class="literal">fname</span> <span class="ent">➌</span> of the just opened file. If the <span class="literal">open</span> failed <span class="ent">➍</span> or the opened file is a shared library that’s not interesting to track <span class="ent">➎</span>, <span class="literal">post_open_hook</span> returns without assigning any color to the file. To determine whether the file is a shared library, <span class="literal">post_open_hook</span> simply checks whether the filename contains a file extension indicative of a shared library, such as <em>.so</em>. In a real tool, you’ll want to use more robust checks by opening a suspected shared library and verifying that it starts with the ELF magic bytes, for instance (see also <a href="ch02.xhtml#ch02">Chapter 2</a>).</p>&#13;
<p class="indent">If the file is interesting enough to assign it a taint color, <span class="literal">post_open_hook</span> distinguishes two cases:</p>&#13;
<ol>&#13;
<li class="noindent">If there is no color assigned to the file descriptor yet (in other words, there is no entry for <span class="literal">fd</span> in the <span class="literal">fd2color</span> map), then <span class="literal">post_open_hook</span> assigns <span class="literal">next_color</span> to this file descriptor <span class="ent">➏</span> and advances <span class="literal">next_color</span> by shifting it left by 1 bit.<br/>     Note that since <span class="literal">libdft</span> supports only eight colors, you might run out of colors if the application opens too many files. Therefore, <span class="literal">post_open_hook</span> advances <span class="literal">next_color</span> only until it reaches the maximum color <span class="literal">0x80</span> <span class="ent">➐</span>. After that, the color <span class="literal">0x80</span> will be used for all subsequently opened files. What this means in practice is that the color <span class="literal">0x80</span> might correspond not just to one file but to a whole list of files. Thus, when a byte with color <span class="literal">0x80</span> leaks, you might not know exactly which file the byte came from, only that it’s from one of the files in the list. Unfortunately, that’s the price you have to pay for keeping the shadow memory small by supporting only eight colors.</li>&#13;
<li class="noindent">Sometimes a file descriptor is closed at some point, and then the same file descriptor number is reused to open another file. In that case, <span class="literal">fd2color</span> will already contain an assigned color for that file descriptor number <span class="ent">➑</span>. To keep things simple, I simply reuse the existing color for the repurposed file descriptor, meaning that that color will now correspond to a list of files instead of just one, exactly as when you run out of colors.</li>&#13;
</ol>&#13;
<p class="indent">At the end of <span class="literal">post_open_hook</span>, the <span class="literal">color2fname</span> map is updated with the filename of the just opened file <span class="ent">➒</span>. This way, when data leaks, you can use the taint color of the leaked data to look up the name of the corresponding file, as you just saw in the <span class="literal">alert</span> function. If the taint color was reused for multiple files because of one of these reasons, then the <span class="literal">color2fname</span> entry for that color will be a list of filenames separated with a pipe (|) <span class="ent">➓</span>.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_302"/>Tainting File Reads</h3>&#13;
<p class="noindent">Now that every opened file is associated with a taint color, let’s look at the <span class="literal">post_read_hook</span> function, which taints bytes read from a file with that file’s assigned color. <a href="ch11.xhtml#ch11list13">Listing 11-13</a> shows the relevant code.</p>&#13;
<p class="listing1" id="ch11list13"><em>Listing 11-13:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   post_read_hook(syscall_ctx_t *ctx)<br/>   {<br/><span class="ent">➊</span>    int fd     =    (int)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>    void *buf  =  (void*)ctx-&gt;arg[SYSCALL_ARG1];<br/><span class="ent">➌</span>    size_t len = (size_t)ctx-&gt;ret;<br/>     uint8_t color;<br/><br/><span class="ent">➍</span>    if(unlikely(len &lt;= 0)) {<br/>       return;<br/>     }<br/><br/>     fprintf(stderr, "(dta-dataleak) read: %zu bytes from fd %u\n", len, fd);<br/><br/><span class="ent">➎</span>    color = fd2color[fd];<br/><span class="ent">➏</span>    if(color) {<br/>        fprintf(stderr, "(dta-dataleak) tainting bytes %p -- 0x%x with color 0x%x\n",<br/>               buf, (uintptr_t)buf+len, color);<br/><span class="ent">➐</span>      tagmap_setn((uintptr_t)buf, len, color);<br/><span class="ent">➑</span>    } else {<br/>       fprintf(stderr, "(dta-dataleak) clearing taint on bytes %p -- 0x%x\n",<br/>               buf, (uintptr_t)buf+len);<br/><span class="ent">➒</span>      tagmap_clrn((uintptr_t)buf, len);<br/>     }<br/>   }</p>&#13;
<p class="indent">First, <span class="literal">post_read_hook</span> parses the relevant arguments and return value from the syscall context to obtain the file descriptor that’s being read (<span class="literal">fd</span>) <span class="ent">➊</span>, the buffer into which bytes are read (<span class="literal">buf</span>) <span class="ent">➋</span>, and the number of bytes read (<span class="literal">len</span>) <span class="ent">➌</span>. If <span class="literal">len</span> is less than or equal to zero, no bytes were read, so <span class="literal">post_read_hook</span> returns without tainting anything <span class="ent">➍</span>.</p>&#13;
<p class="indent">Otherwise, it obtains <span class="literal">fd</span>’s taint color by reading it from <span class="literal">fd2color</span> <span class="ent">➎</span>. If <span class="literal">fd</span> has an associated taint color <span class="ent">➏</span>, <span class="literal">post_read_hook</span> uses <span class="literal">tagmap_setn</span> to taint all of the read bytes with that color <span class="ent">➐</span>. It may also happen that <span class="literal">fd</span> has no associated color <span class="ent">➑</span>, meaning that it refers to an uninteresting file such as a shared library. In that case, we clear any taint from the addresses overwritten by the <span class="literal">read</span> syscall <span class="ent">➒</span> by using the <span class="literal">libdft</span> function <span class="literal">tagmap_clrn</span>. This clears the taint from any previously tainted buffer that’s reused to read untainted bytes.</p>&#13;
<h4 class="h4" id="ch11_4_2"><span epub:type="pagebreak" id="page_303"/><em>11.4.2 Taint Sinks: Monitoring Network Sends for Data Exfiltration</em></h4>&#13;
<p class="noindent">Finally, <a href="ch11.xhtml#ch11list14">Listing 11-14</a> shows <span class="literal">dta-dataleak</span>’s taint sink, the <span class="literal">socketcall</span> handler that intercepts network sends to check them for data exfiltration attempts. It’s similar to the <span class="literal">socketcall</span> handler you saw in the <span class="literal">dta-execve</span> tool, except that it checks sent bytes for taint instead of applying taint to received bytes.</p>&#13;
<p class="listing1" id="ch11list14"><em>Listing 11-14:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<p class="programs">   static void<br/>   pre_socketcall_hook(syscall_ctx_t *ctx)<br/>   {<br/>     int fd;<br/>     void *buf;<br/>     size_t i, len;<br/>     uint8_t tag;<br/>     uintptr_t start, end, addr;<br/><br/><span class="ent">➊</span>   int call            =            (int)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>   unsigned long *args = (unsigned long*)ctx-&gt;arg[SYSCALL_ARG1];<br/><br/>     switch(call) {<br/><span class="ent">➌</span>    case SYS_SEND:<br/>     case SYS_SENDTO:<br/><span class="ent">➍</span>     fd  =    (int)args[0];<br/>       buf =  (void*)args[1];<br/>       len = (size_t)args[2];<br/><br/>       fprintf(stderr, "(dta-dataleak) send: %zu bytes to fd %u\n", len, fd);<br/><br/>       for(i = 0; i &lt; len; i++) {<br/>         if(isprint(((char*)buf)[i])) fprintf(stderr, "%c", ((char*)buf)[i]);<br/>         else                         fprintf(stderr, "\\x%02x", ((char*)buf)[i]);<br/>       }<br/>       fprintf(stderr, "\n");<br/><br/>       fprintf(stderr, "(dta-dataleak) checking taint on bytes %p -- 0x%x...",<br/>              buf, (uintptr_t)buf+len);<br/><br/>       start = (uintptr_t)buf;<br/>       end   = (uintptr_t)buf+len;<br/><span class="ent">➎</span>     for(addr = start; addr &lt;= end; addr++) {<br/><span class="ent">➏</span>        tag = tagmap_getb(addr);<br/><span class="ent">➐</span>        if(tag != 0) alert(addr, tag);<br/>       }<br/><br/>       fprintf(stderr, "OK\n");<br/><span epub:type="pagebreak" id="page_304"/>          break;<br/><br/>       default:<br/>          break;<br/>       }<br/>    }</p>&#13;
<p class="indent">First, <span class="literal">pre_socketcall_hook</span> obtains the <span class="literal">call</span> <span class="ent">➊</span> and <span class="literal">args</span> <span class="ent">➋</span> parameters for the <span class="literal">socketcall</span>. It then uses a switch on <span class="literal">call</span> just like the one you saw in the <span class="literal">socketcall</span> handler for <span class="literal">dta-execve</span>, except that this new switch inspects <span class="literal">SYS_SEND</span> and <span class="literal">SYS_SENDTO</span> <span class="ent">➌</span> instead of <span class="literal">SYS_RECV</span> and <span class="literal">SYS_RECVFROM</span>. If it intercepts a send event, it parse the send’s arguments: the socket file descriptor, send buffer, and number of bytes to send <span class="ent">➍</span>. After some diagnostic prints, the code loops over all of the bytes in the send buffer <span class="ent">➎</span> and gets each byte’s taint status using <span class="literal">tagmap_getb</span> <span class="ent">➏</span>. If a byte is tainted, <span class="literal">pre_socketcall_hook</span> calls the <span class="literal">alert</span> function to print an alert and stop the application <span class="ent">➐</span>.</p>&#13;
<p class="indent">That covers the entire code for the <span class="literal">dta-dataleak</span> tool. In the next section, you’ll see how <span class="literal">dta-dataleak</span> detects a data exfiltration attempt and how taint colors combine when exfiltrated data depends on multiple taint sources.</p>&#13;
<h4 class="h4" id="ch11_4_3"><em>11.4.3 Detecting a Data Exfiltration Attempt</em></h4>&#13;
<p class="noindent">To demonstrate <span class="literal">dta-dataleak</span>’s ability to detect data leaks, I’ve implemented another simple server called <span class="literal">dataleak-test-xor</span>. For simplicity, this server “leaks” tainted files to the socket voluntarily, but <span class="literal">dta-dataleak</span> can detect files leaked through an exploit in the same way. <a href="ch11.xhtml#ch11list15">Listing 11-15</a> shows the relevant code for the server.</p>&#13;
<p class="listing1" id="ch11list15"><em>Listing 11-15:</em> dataleak-test-xor.c</p>&#13;
<p class="programs">   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     size_t i, j, k;<br/>     FILE *fp[10];<br/>     char buf[4096], *filenames[10];<br/>     struct sockaddr_storage addr;<br/>   <br/>     srand(time(NULL));<br/>   <br/><span class="ent">➊</span>   int sockfd = open_socket("localhost", "9999");<br/>   <br/>     socklen_t addrlen = sizeof(addr);<br/><span class="ent">➋</span>   recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr*)&amp;addr, &amp;addrlen);<br/>   <br/><span class="ent">➌</span>   size_t fcount = split_filenames(buf, filenames, 10);<br/>   <br/><span epub:type="pagebreak" id="page_305"/><span class="ent">➍</span>   for(i = 0; i &lt; fcount; i++) {<br/>       fp[i] = fopen(filenames[i], "r");<br/>     }<br/>   <br/><span class="ent">➎</span>   i = rand() % fcount;<br/>     do { j = rand() % fcount; } while(j == i);<br/>   <br/>     memset(buf1, '\0', sizeof(buf1));<br/>     memset(buf2, '\0', sizeof(buf2));<br/>   <br/><span class="ent">➏</span>   while(fgets(buf1, sizeof(buf1), fp[i]) &amp;&amp; fgets(buf2, sizeof(buf2), fp[j])) {<br/>       /* sizeof(buf)-1 ensures that there will be a final NULL character<br/>        * regardless of the XOR-ed values */<br/>       for(k = 0; k &lt; sizeof(buf1)-1 &amp;&amp; k &lt; sizeof(buf2)-1; k++) {<br/><span class="ent">➐</span>       buf1[k] ˆ= buf2[k];<br/>       }<br/><span class="ent">➑</span>     sendto(sockfd, buf1, strlen(buf1)+1, 0, (struct sockaddr*)&amp;addr, addrlen);<br/>     }<br/><br/>     return 0;<br/>   }</p>&#13;
<p class="indent">The server opens a socket on <span class="literal">localhost</span> port 9999 <span class="ent">➊</span> and uses it to receive a message <span class="ent">➋</span> containing a list of filenames. It splits this list into individual filenames using a function called <span class="literal">split_filenames</span>, which is omitted from the listing <span class="ent">➌</span>. Next, it opens all the requested files <span class="ent">➍</span> and then chooses two of the opened files at random <span class="ent">➎</span>. Note that in a realistic use case for <span class="literal">dta-dataleak</span>, the files would be accessed through an exploit rather than released voluntarily by the server. For the purposes of this example, the server reads the contents of the two randomly chosen files line by line <span class="ent">➏</span>, combining each pair of lines (one line from each file) using an XOR operation <span class="ent">➐</span>. Combining the lines will cause <span class="literal">dta-dataleak</span> to merge their taint colors, demonstrating taint merging for the purposes of this example. Finally, the result of the two XOR-ed lines is sent over the network <span class="ent">➑</span>, providing a “data leak” for <span class="literal">dta-dataleak</span> to detect.</p>&#13;
<p class="indent">Now, let’s see how <span class="literal">dta-dataleak</span> detects a data leak attempt and specifically how taint colors are merged when the leaked data depends on multiple files. <a href="ch11.xhtml#ch11list16">Listing 11-16</a> shows the output of running the <span class="literal">dataleak-test-xor</span> program while protected with <span class="literal">dta-dataleak</span>. I’ve abbreviated repetitive parts of the output with “<span class="literal">...</span>”.</p>&#13;
<p class="listing1" id="ch11list16"><em>Listing 11-16: Detecting a data exfiltration attempt with</em> <span class="codeitalic">dta-dataleak</span></p>&#13;
<p class="programs">   $ <span class="codestrong1">cd ~/libdft/pin-2.13-61206-gcc.4.4.7-linux/</span><br/><span class="ent">➊</span> $<span class="codestrong1">./pin.sh -follow_execv -t ~/code/chapter11/dta-dataleak.so \</span><br/>             <span class="codestrong1">-- ~/code/chapter11/dataleak-test-xor &amp;</span><br/><br/><span epub:type="pagebreak" id="page_306"/><span class="ent">➋</span> (dta-dataleak) read: 512 bytes from fd 4<br/>   (dta-dataleak) clearing taint on bytes 0xff8b34d0 -- 0xff8b36d0<br/>   [1] 22713<br/><span class="ent">➌</span> $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➍</span> /home/binary/code/chapter11/dta-execve.cpp .../dta-dataleak.cpp .../date.c .../echo.c<br/><span class="ent">➎</span> (dta-dataleak) opening /home/binary/code/chapter11/dta-execve.cpp at fd 5 with color 0x01<br/>   (dta-dataleak) opening /home/binary/code/chapter11/dta-dataleak.cpp at fd 6 with color 0x02<br/>   (dta-dataleak) opening /home/binary/code/chapter11/date.c at fd 7 with color 0x04<br/>   (dta-dataleak) opening /home/binary/code/chapter11/echo.c at fd 8 with color 0x08<br/><span class="ent">➏</span> (dta-dataleak) read: 155 bytes from fd 8<br/>   (dta-dataleak) tainting bytes 0x872a5c0 -- 0x872a65b with color 0x8<br/><span class="ent">➐</span> (dta-dataleak) read: 3923 bytes from fd 5<br/>   (dta-dataleak) tainting bytes 0x872b5c8 -- 0x872c51b with color 0x1<br/><span class="ent">➑</span> (dta-dataleak) send: 20 bytes to fd 4<br/>   \x0cCdclude &lt;stdio.h&gt;\x0a\x00<br/><span class="ent">➒</span> (dta-dataleak) checking taint on bytes 0xff8b19cc -- 0xff8b19e0...<br/><span class="ent">➓</span> (dta-dataleak) !!!!!!! ADDRESS 0xff8b19cc IS TAINTED (tag=0x09), ABORTING !!!!!!!<br/>     tainted by color = 0x01 (/home/binary/code/chapter11/dta-execve.cpp)<br/>     tainted by color = 0x08 (/home/binary/code/chapter11/echo.c)<br/>   [1]+ Exit 1 ./pin.sh -follow_execv -t ~/code/chapter11/dta-dataleak.so ...</p>&#13;
<p class="indent">This example runs the <span class="literal">dataleak-test-xor</span> server with Pin, using <span class="literal">dta -dataleak</span> as the Pin tool to protect against data leaks <span class="ent">➊</span>. Immediately, there’s a first <span class="literal">read</span> syscall that’s related to the loading process of <span class="literal">dataleak-test-xor</span> <span class="ent">➋</span>. Because these bytes are read from a shared library, which doesn’t have an associated taint color, <span class="literal">dta-dataleak</span> ignores the read.</p>&#13;
<p class="indent">Next, the example starts a <span class="literal">netcat</span> session to connect to the server <span class="ent">➌</span> and send it a list of filenames to open <span class="ent">➍</span>. The <span class="literal">dta-dataleak</span> tool intercepts the <span class="literal">open</span> events for all those files and assigns each of them a taint color <span class="ent">➎</span>. Then, the server randomly chooses two files that it’s going to leak. In this case, these turn out to be the files with file descriptor 8 <span class="ent">➏</span> and 5 <span class="ent">➐</span>, respectively.</p>&#13;
<p class="indent">For both files, <span class="literal">dta-dataleak</span> intercepts the <span class="literal">read</span> events and taints the read bytes with the files’ associated taint color (<span class="literal">0x08</span> and <span class="literal">0x01</span>, respectively). Next, <span class="literal">dta-dataleak</span> intercepts the server’s attempt to send the file contents, which are now XOR-ed together, over the network <span class="ent">➑</span>.</p>&#13;
<p class="indent">It checks the taint on the bytes the server is about to send <span class="ent">➒</span>, notices that they’re tainted with the tag <span class="literal">0x09</span> <span class="ent">➓</span>, and therefore prints an alert and aborts the program. Tag <span class="literal">0x09</span> is the combination of the two taint colors <span class="literal">0x01</span> and <span class="literal">0x08</span>. From the alert, you can see that these colors correspond to the files <em>dta-execve.cpp</em> and <em>echo.c</em>, respectively.</p>&#13;
<p class="indent">As you can see, taint analysis makes it easy to spot information leaks and to know exactly which files are leaked. Also, you can use merged taint colors to tell which taint sources contributed to a byte’s value. Even with just eight taint colors, there are endless ways to build powerful DTA tools!</p>&#13;
<h3 class="h3" id="ch11_5">11.5 Summary</h3>&#13;
<p class="noindent">In this chapter, you learned about the internals of <span class="literal">libdft</span>, a popular open source DTA library. You also saw practical examples of using <span class="literal">libdft</span> to detect two types of common attacks: control hijacking and data exfiltration. You should now be ready to start building your own DTA tools!</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch11_6">Exercise</p>&#13;
<p class="boxhead1">1. Implementing a Format String Exploit Detector</p>&#13;
<p class="noindent">Use <span class="literal">libdft</span> to implement the format string exploit detection tool you designed in the previous chapter. Create an exploitable program and a format string exploit to test your detector. Also, create a program with an implicit flow that allows a format string exploit to succeed despite your detection tool.</p>&#13;
<p class="indent">Hint: You can’t directly hook <span class="literal">printf</span> with <span class="literal">libdft</span> because it’s not a syscall. Instead, you’ll have to find another way, such as with an instruction-level hook (<span class="literal">libdft</span>’s <span class="literal">ins_set_pre</span>) that checks for calls to the <span class="literal">printf</span> PLT stub. For the purposes of this exercise, you’re allowed to make simplifying assumptions, such as no indirect calls to <span class="literal">printf</span> and a fixed, hard-coded address for the PLT stub.</p>&#13;
<p class="indent">If you’re looking for a practical example of instruction-level hooking, check out the <em>libdft-dta.c</em> tool that ships with <span class="literal">libdft</span>!<span epub:type="pagebreak" id="page_308"/></p>&#13;
</div>&#13;
</div></body></html>