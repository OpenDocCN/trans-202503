<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_279"/><span class="big">11</span><br/>PRACTICAL DYNAMIC TAINT ANALYSIS WITH LIBDFT</h2>&#13;
<p class="startpara">In <a href="ch10.xhtml#ch10">Chapter 10</a>, you learned the principles of dynamic taint analysis. In this chapter, you will learn how to build your own DTA tools with <code>libdft</code>, a popular open source DTA library. I’ll cover two practical examples: a tool that prevents remote control-hijacking attacks and a tool that automatically detects information leaks. But first, let’s take a look at the internals and API of <code>libdft</code>.</p>&#13;
<h3 class="h3" id="ch11_1">11.1 Introducing libdft</h3>&#13;
<p class="noindent">Because DTA is the subject of ongoing research, existing binary-level taint tracking libraries are research tools; don’t expect production quality from them. The same is true for <code>libdft</code>, developed at Columbia University, which you’ll use in the remainder of this chapter.</p>&#13;
<p class="indent">A byte-granularity taint-tracking system built on Intel Pin, <code>libdft</code> is one of the easiest to use DTA libraries available at the moment. In fact, it’s the tool of choice of many security researchers because you can use it to easily build DTA tools that are both accurate and fast. I’ve preinstalled <code>libdft</code> <span epub:type="pagebreak" id="page_280"/>on the VM in the directory <em>/home/binary/libdft</em>. You can also download it at <em><a href="https://www.cs.columbia.edu/~vpk/research/libdft/">https://www.cs.columbia.edu/~vpk/research/libdft/</a></em>.</p>&#13;
<p class="indent">Like all binary-level DTA libraries available at the time of writing, <code>libdft</code> has several shortcomings. The most obvious one is that <code>libdft</code> supports only 32-bit x86. You can still use it on a 64-bit platform, but only to analyze 32-bit processes. It also relies on legacy versions of Pin (versions between 2.11 and 2.14 should work). Another limitation is that <code>libdft</code> implements support only for “regular” x86 instructions, not extended instruction sets like MMX or SSE. This means <code>libdft</code> may suffer from undertainting if taint flows through such instructions. If you’re building the program you’re analyzing from source, use <code>gcc</code>’s compilation options <code>-mno-{mmx, sse, sse2, sse3}</code> to ensure that the binary won’t contain MMX or SSE instructions.</p>&#13;
<p class="indent">Despite its limitations, <code>libdft</code> is still an excellent DTA library you can use to build solid tools. Also, because it’s open source, it’s relatively easy to extend it with 64-bit support or support for more instructions. To help you get the most out of <code>libdft</code>, let’s take a look at its most important implementation details.</p>&#13;
<h4 class="h4" id="ch11_1_1"><em>11.1.1 Internals of libdft</em></h4>&#13;
<p class="noindent">Because <code>libdft</code> is based on Intel Pin, <code>libdft</code>-based DTA tools are just Pin tools like the ones you saw in <a href="ch09.xhtml#ch09">Chapter 9</a>, except they’re linked with <code>libdft</code>, which provides the DTA functionality. On the VM, I’ve installed a dedicated legacy version of Intel Pin (v2.13) you can use with <code>libdft</code>. Pin is used by <code>libdft</code> to instrument instructions with taint propagation logic. Taint itself is stored in shadow memory, which is accessible through the <code>libdft</code> API. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows an overview of <code>libdft</code>’s most important components.</p>&#13;
<h3 class="h3">Shadow Memory</h3>&#13;
<p class="noindent">As you can see in <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>, <code>libdft</code> comes in two variants, each with a different kind of shadow memory (called the <em>tagmap</em> in <code>libdft</code> parlance). First, there’s a bitmap-based variant <span class="ent">➊</span>, which supports only one taint color but is slightly faster and has less memory overhead than the other variant. In the <code>libdft</code> source archive available from the Columbia University website,<sup><a id="ch11fn_1a" href="footnote.xhtml#ch11fn_1">1</a></sup> this variant is in the directory called <em>libdft_linux-i386</em>. The second variant implements an eight-color shadow memory <span class="ent">➋</span>, and you can find it in the directory <em>libdft-ng_linux-i386</em> in the source archive. This second variant is the one I’ve preinstalled on the VM and the one I’ll use here.</p>&#13;
<p class="indent">To minimize the memory requirements of the eight-color shadow memory, <code>libdft</code> implements it using an optimized data structure, called the <em>segment translation table (STAB)</em>. The STAB contains one entry for every memory page. Each entry contains an <em>addend</em> value, which is just a 32-bit offset that you add to a virtual memory address to obtain the address of the corresponding shadow byte.</p>&#13;
<div class="image"><a id="ch11fig1"/><img src="Images/f281-01.jpg" alt="image" width="623" height="598"/></div>&#13;
<p class="fig-caption"><span epub:type="pagebreak" id="page_281"/><em>Figure 11-1: Internals of</em> <code>libdft</code> <em>: shadow memory and virtual CPU implementation, instrumentation, and API</em></p>&#13;
<p class="indent">For example, to read the shadow memory for virtual address <code>0x1000</code>, you can look up the corresponding addend in the STAB, which turns out to be <code>438</code>. That means you’ll find the shadow byte containing the taint information for address <code>0x1000</code> at address <code>0x1438</code>.</p>&#13;
<p class="indent">The STAB provides a level of indirection that allows <code>libdft</code> to allocate shadow memory on demand, whenever the application allocates a region of virtual memory. Shadow memory is allocated in page-sized chunks, keeping memory overhead to a minimum. Since each allocated memory page corresponds to exactly one shadow page, the same addend can be used for all addresses in a page. For virtual memory regions with multiple adjacent pages, <code>libdft</code> ensures that the shadow memory pages are also adjacent, simplifying shadow memory access. Each chunk of adjacent shadow map pages is called a <em>tagmap segment (tseg)</em>. As an additional memory usage optimization, <code>libdft</code> maps all read-only memory pages to the same zeroed-out shadow page.</p>&#13;
<h3 class="h3">Virtual CPU</h3>&#13;
<p class="noindent">To keep track of the taint status of CPU registers, <code>libdft</code> keeps a special structure in memory called the <em>virtual CPU</em>. The virtual CPU is a sort of mini-shadow memory with 4 shadow bytes for each of the 32-bit general-purpose <span epub:type="pagebreak" id="page_282"/>CPU registers available on x86: <code>edi</code>, <code>esi</code>, <code>ebp</code>, <code>esp</code>, <code>ebx</code>, <code>edx</code>, <code>ecx</code>, and <code>eax</code>. In addition, there’s a special scratch register on the virtual CPU, which <code>libdft</code> uses to store taint for any unrecognized register. In the preinstalled <code>libdft</code> version on the VM, I’ve made some modifications to the virtual CPU so that it has room for all registers supported by Intel Pin.</p>&#13;
<h3 class="h3">Taint-Tracking Engine</h3>&#13;
<p class="noindent">Recall that <code>libdft</code> uses Pin’s API to inspect all instructions in a binary and then instruments these instructions with the relevant taint propagation functions. If you’re interested, you can find the implementations of <code>libdft</code>’s taint propagation functions in the file <em>/home/binary/libdft/libdft-ng_linux-i386/src/ libdft_core.c</em> on the VM, but I won’t cover them all here. Together, the taint propagation functions implement <code>libdft</code>’s taint policy, which I’ll describe in <a href="ch11.xhtml#ch11_1_2">Section 11.1.2</a>.</p>&#13;
<h3 class="h3">The libdft API and I/O Interface</h3>&#13;
<p class="noindent">Ultimately, the goal of <code>libdft</code> is to function as a library for building your own DTA tools. For this purpose, <code>libdft</code> provides a taint-tracking API, which provides several classes of functions. The two most important classes of functions for building DTA tools are those that manipulate the tagmap and those that add callbacks and instrumentation code.</p>&#13;
<p class="indent">The tagmap API is defined in the header file <em>tagmap.h</em>. It provides functions such as <code>tagmap_setb</code> to mark a memory byte as tainted and <code>tagmap_getb</code> to retrieve the taint information for a memory byte.</p>&#13;
<p class="indent">The API for adding callbacks and instrumentation code is split over the header files <em>libdft_api.h</em> and <em>syscall_desc.h</em>. It allows you to register callbacks for syscall events using the functions <code>syscall_set_pre</code> and <code>syscall_set_post</code>. To store all these callbacks, <code>libdft</code> uses a dedicated array called <code>syscall_desc</code>, which keeps track of all the syscall pre- and post-handlers you install. Similarly, you can register instruction callbacks with <code>ins_set_pre</code> and <code>ins_set_post</code>. You’ll learn about these and other <code>libdft</code> API functions in more detail from the DTA tools later in this chapter.</p>&#13;
<h4 class="h4" id="ch11_1_2"><em>11.1.2 Taint Policy</em></h4>&#13;
<p class="noindent">The <code>libdft</code> taint propagation policy defines the following five classes of instructions.<sup><a id="ch11fn_2a" href="footnote.xhtml#ch11fn_2">2</a></sup> Each of these classes propagates and merges taint in a different way.</p>&#13;
<p class="li"><strong>ALU</strong> These are arithmetic and logic instructions with two or three operands, such as <code>add</code>, <code>sub</code>, <code>and</code>, <code>xor</code>, <code>div</code>, and <code>imul</code>. For these operations, <code>libdft</code> merges taint in the same way as the <code>add</code> and <code>xor</code> examples in <a href="ch10.xhtml#ch10tab1">Table 10-1</a> on page 273—the output taint is the union (∪) of the input operands’ taint. Also as in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>, <code>libdft</code> considers immediate values untainted since there’s no way an attacker can influence them.</p>&#13;
<p class="li"><span epub:type="pagebreak" id="page_283"/><strong>XFER</strong> The XFER class contains all the instructions that copy a value to another register or memory location, such as the <code>mov</code> instruction. Again, it’s handled like the <code>mov</code> example in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>, using the assignment operation (:=). For these instructions, <code>libdft</code> simply copies the taint from the source operand to the destination.</p>&#13;
<p class="li"><strong>CLR</strong> As the name implies, instructions in this class always cause their output operands to become untainted. In other words, <code>libdft</code> sets the output taint to the empty set (ø). This class includes some special cases of instructions from other classes, such as <code>xor</code>-ing an operand with itself or subtracting an operand from itself. It also includes instructions such as <code>cpuid</code>, where an attacker has no control over the outputs.</p>&#13;
<p class="li"><strong>SPECIAL</strong> These are instructions that require special rules for taint propagation not covered by other classes. Among others, this class includes <code>xchg</code> and <code>cmpxchg</code> (where the taint of two operands is swapped) and <code>lea</code> (where the taint results from a memory address computation).</p>&#13;
<p class="li"><strong>FPU, MMX, SSE</strong> This class includes instructions that <code>libdft</code> doesn’t currently support, such as FPU, MMX, and SSE instructions. When taint flows through such instructions, <code>libdft</code> cannot track it, so the taint information doesn’t propagate to the output operands of the instructions, resulting in undertainting.</p>&#13;
<p class="indent">Now that you’re acquainted with <code>libdft</code>, let’s build some DTA tools with <code>libdft</code>!</p>&#13;
<h3 class="h3" id="ch11_2">11.2 Using DTA to Detect Remote Control-Hijacking</h3>&#13;
<p class="noindent">The first DTA tool you’ll see is designed to detect some types of remote control-hijacking attacks. Specifically, it detects attacks where data received from the network is used to control the arguments of an <code>execve</code> call. Thus, the taint sources will be the network receive functions <code>recv</code> and <code>recvfrom</code>, while the <code>execve</code> syscall will be the taint sink. As usual, you can find the complete source code on the VM, in <em>~/code/chapter11</em>.</p>&#13;
<p class="indent">I tried to make this example tool as simple as possible to keep the discussion easy to understand. That means it necessarily makes simplifying assumptions and will not catch all types of control-hijacking attacks. In a real, fully fledged DTA tool, you’ll want to define additional taint sources and sinks to prevent more types of attacks. For instance, in addition to data received with <code>recv</code> and <code>recvfrom</code>, you’ll want to consider data read from the network using the <code>read</code> syscall. Moreover, to prevent tainting innocent file reads, you’ll need to keep track of which file descriptors are reading from the network by hooking network calls like <code>accept</code>.</p>&#13;
<p class="indent">When you understand how the following example tool works, you should be able to refine it on your own. Additionally, <code>libdft</code> comes with a more elaborate example DTA tool that implements many of these refinements for reference. You can find it in the file <em>tools/libdft-dta.c</em> in the <em>libdft</em> directory if you’re interested.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>Many <code>libdft</code>-based DTA tools hook syscalls to use as taint sources and sinks. On Linux, every syscall has its own <em>syscall number</em>, which <code>libdft</code> uses to index the <code>syscall_desc</code> array. For a list of available syscalls and their associated syscall numbers, refer to <em>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</em> for x86 (32 bit) or to <em>/usr/include/asm-generic/unistd.h</em> for x64.<sup><a id="ch11fn_3a" href="footnote.xhtml#ch11fn_3">3</a></sup></p>&#13;
<p class="indent">Now, let’s take a look at the example tool called <code>dta-execve</code>. <a href="ch11.xhtml#ch11list1">Listing 11-1</a> shows the first part of the source code.</p>&#13;
<p class="listing1" id="ch11list1"><em>Listing 11-1:</em> dta-execve.cpp</p>&#13;
<pre>    /* some #includes omitted for brevity */<br/><br/><span class="ent">➊</span>  #include "pin.H"<br/><br/><span class="ent">➋</span>  #include "branch_pred.h"<br/>   #include "libdft_api.h"<br/>   #include "syscall_desc.h"<br/>   #include "tagmap.h"<br/><br/><span class="ent">➌</span>  extern syscall_desc_t syscall_desc[SYSCALL_MAX];<br/><br/>   void alert(uintptr_t addr, const char *source, uint8_t tag);<br/>   void check_string_taint(const char *str, const char *source);<br/>   static void post_socketcall_hook(syscall_ctx_t *ctx);<br/>   static void pre_execve_hook(syscall_ctx_t *ctx);<br/><br/>   int<br/>   main(int argc, char **argv)<br/>   {<br/><span class="ent">➍</span>    PIN_InitSymbols();<br/><span class="ent">➎</span>    if(unlikely(PIN_Init(argc, argv))) {<br/>        return 1;<br/>     }<br/><br/><span class="ent">➏</span>    if(unlikely(libdft_init() != 0)) {<br/><span class="ent">➐</span>       libdft_die();<br/>        return 1;<br/>     }<br/><br/><span class="ent">➑</span>    syscall_set_post(&amp;syscall_desc[__NR_socketcall], post_socketcall_hook);<br/><span class="ent">➒</span>    syscall_set_pre (&amp;syscall_desc[__NR_execve], pre_execve_hook);<br/><br/><span class="ent">➒</span>    PIN_StartProgram();<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_285"/>Here, I show only the header files that are specific to <code>libdft</code>-based DTA tools, but you can see the omitted code in the source on the VM if you’re interested.</p>&#13;
<p class="indent">The first header file is <em>pin.H</em> <span class="ent">➊</span> because all <code>libdft</code> tools are just Pin tools linked with the <code>libdft</code> library. Next, there are several header files that together provide access to the <code>libdft</code> API <span class="ent">➋</span>. The first of these, <em>branch_pred.h</em>, contains the macros <code>likely</code> and <code>unlikely</code>, which you can use to provide the compiler with hints for branch prediction, as I’ll explain in a moment. Next, <em>libdft_api.h</em>, <em>syscall_desc.h</em>, and <em>tagmap.h</em> provide access to the <code>libdft</code> base API, syscall hooking interface, and tagmap (shadow memory), respectively.</p>&#13;
<p class="indent">After the includes, there’s an <code>extern</code> declaration of the <code>syscall_desc</code> array <span class="ent">➌</span>, which is the data structure <code>libdft</code> uses to keep track of syscall hooks. You’ll need access to it to hook your taint sources and sinks. The actual definition of <code>syscall_desc</code> is in <code>libdft</code>’s source file <em>syscall_desc.c</em>.</p>&#13;
<p class="indent">Now let’s take a look at the <code>main</code> function of the <code>dta-execve</code> tool. It starts by initializing Pin’s symbol processing <span class="ent">➍</span> in case symbols are present in the binary, followed by Pin itself <span class="ent">➎</span>. You saw Pin initialization code in <a href="ch09.xhtml#ch09">Chapter 9</a>, but this time the return value of <code>PIN_Init</code> is checked using an optimized branch, marked with the <code>unlikely</code> macro to tell the compiler it’s unlikely that <code>PIN_Init</code> will fail. This knowledge can help the compiler with branch prediction, which may allow it to output slightly faster code.</p>&#13;
<p class="indent">Next, the <code>main</code> function initializes <code>libdft</code> itself using the <code>libdft_init</code> function <span class="ent">➏</span>, again with an optimized check of the return value. This initialization allows <code>libdft</code> to set up crucial data structures, such as the tagmap. If this setup fails, <code>libdft_init</code> returns a nonzero value, in which case you call <code>libdft_die</code> to deallocate any resources <code>libdft</code> may have allocated <span class="ent">➐</span>.</p>&#13;
<p class="indent">Once Pin and <code>libdft</code> are both initialized, you can install your syscall hooks, which serve as taint sources and taint sinks. Keep in mind that the appropriate hook will be called whenever the instrumented application (the program you’re protecting with your DTA tool) executes the corresponding syscall. Here, <code>dta-execve</code> installs two hooks: a post-handler called <code>post_socketcall_hook</code> that runs right after every <code>socketcall</code> syscall <span class="ent">➑</span> and a pre-handler that runs before <code>execve</code> syscalls, called <code>pre_execve_hook</code> <span class="ent">➒</span>. The <code>socketcall</code> syscall captures all socket-related events on x86-32 Linux, including <code>recv</code> and <code>recvfrom</code> events. The <code>socketcall</code> handler (<code>post_socketcall_hook</code>) differentiates between the different types of socket events, as I’ll explain in a moment.</p>&#13;
<p class="indent">To install a syscall handler, you call <code>syscall_set_post</code> (for post-handlers) or <code>syscall_set_pre</code> (for pre-handlers). Both of these functions take a pointer to the entry in <code>libdft</code>’s <code>syscall_desc</code> array in which to install the handler, and a function pointer to the handler to install. To get the appropriate <code>syscall_desc</code> entry, you index <code>syscall_desc</code> with the syscall number of the syscall you’re hooking. In this case, the relevant syscall numbers are represented by the symbolic names <code>__NR_socketcall</code> and <code>__NR_execve</code>, which you can find in <em>/usr/include/i386-linux-gnu/asm/unistd_32.h</em> for x86-32.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_286"/>Finally, you call <code>PIN_StartProgram</code> to begin running the instrumented application <span class="ent">➓</span>. Recall from <a href="ch09.xhtml#ch09">Chapter 9</a> that <code>PIN_StartProgram</code> never returns, so the <code>return 0</code> at the end of <code>main</code> is never reached.</p>&#13;
<p class="indent">Although I don’t use it in this example, <code>libdft</code> does provide the ability to hook instructions in nearly the same way as syscalls, as shown in the following listing:</p>&#13;
<pre><span class="ent">➊</span>  extern ins_desc_t ins_desc[XED_ICLASS_LAST];<br/>   /* ... */<br/><span class="ent">➋</span>  ins_set_post(&amp;ins_desc[XED_ICLASS_RET_NEAR], dta_instrument_ret);</pre>&#13;
<p class="indent">To hook instructions, you globally declare the <code>extern ins_desc</code> array <span class="ent">➊</span> (analogous to <code>syscall_desc</code>) in your DTA tool and then use <code>ins_set_pre</code> or <code>ins_set_post</code> <span class="ent">➋</span> to install instruction pre- or post-handlers, respectively. Instead of syscall numbers, you index the <code>ins_desc</code> array using symbolic names provided by Intel’s x86 encoder/decoder library (XED), which comes with Pin. XED defines these names in an <code>enum</code> called <code>xed_iclass_enum_t</code>, and each name denotes an instruction class such as <code>X86_ICLASS_RET_NEAR</code>. The names of the classes correspond to instruction mnemonics. You can find a list of all the instruction class names online at <em><a href="https://intelxed.github.io/ref-manual/">https://intelxed.github.io/ref-manual/</a></em> or in the header file <em>xed-iclass-enum.h</em> that ships with Pin.<sup><a id="ch11fn_4a" href="footnote.xhtml#ch11fn_4">4</a></sup></p>&#13;
<h4 class="h4" id="ch11_2_1"><em>11.2.1 Checking Taint Information</em></h4>&#13;
<p class="noindent">In the previous section, you saw how the <code>dta-execve</code> tool’s <code>main</code> function performs all the necessary initialization, sets up the appropriate syscall hooks to serve as taint sources and sinks, and then starts the application. In this case, the taint sink is a syscall hook called <code>pre_execve_hook</code>, which checks whether any of the <code>execve</code> arguments are tainted, indicating a control hijacking attack. If so, it raises an alert and stops the attack by aborting the application. Because the taint checking is done repeatedly for every <code>execve</code> argument, I’ve implemented it in a separate function called <code>check_string_taint</code>.</p>&#13;
<p class="indent">I’ll discuss <code>check_string_taint</code> first, and then I’ll move on to the code for <code>pre_execve_hook</code> in <a href="ch11.xhtml#ch11_2_3">Section 11.2.3</a>. <a href="ch11.xhtml#ch11list2">Listing 11-2</a> shows the <code>check_string_taint</code> function, as well as the <code>alert</code> function that is called if an attack is detected.</p>&#13;
<p class="listing1" id="ch11list2"><em>Listing 11-2:</em> dta-execve.cpp <em>(continued)</em></p>&#13;
<pre>   void<br/><span class="ent">➊</span>  alert(uintptr_t addr, const char *source, uint8_t tag)<br/>   {<br/>     fprintf(stderr,<br/>       "\n(dta-execve) !!!!!!! ADDRESS 0x%x IS TAINTED (%s, tag=0x%02x), ABORTING !!!!!!!\n",<br/>       addr, source, tag);<br/>     exit(1);<br/>   }<br/><span epub:type="pagebreak" id="page_287"/>   void<br/><span class="ent">➋</span>  check_string_taint(const char *str, const char *source)<br/>   {<br/>     uint8_t tag;<br/>     uintptr_t start = (uintptr_t)str;<br/>     uintptr_t end   = (uintptr_t)str+strlen(str);<br/><br/>     fprintf(stderr, "(dta-execve) checking taint on bytes 0x%x -- 0x%x (%s)... ",<br/>             start, end, source);<br/><br/><span class="ent">➌</span>   for(uintptr_t addr = start; addr &lt;= end; addr++) {<br/><span class="ent">➍</span>      tag = tagmap_getb(addr);<br/><span class="ent">➎</span>      if(tag != 0) alert(addr, source, tag);<br/>     }<br/><br/>     fprintf(stderr, "OK\n");<br/>   }</pre>&#13;
<p class="indent">The <code>alert</code> function <span class="ent">➊</span> simply prints an alert message with details about the tainted address and then calls <code>exit</code> to stop the application and prevent the attack. The actual taint-checking logic is implemented in <code>check_string_taint</code> <span class="ent">➋</span>, which takes two strings as input. The first string (<code>str</code>) is the one to check for taint, while the second (<code>source</code>) is a diagnostic string that’s passed to and printed by <code>alert</code>, specifying the source of the first string, which is the <code>execve</code> path, an <code>execve</code> parameter, or an environment parameter.</p>&#13;
<p class="indent">To check the taint of <code>str</code>, <code>check_string_taint</code> loops over all of <code>str</code>’s bytes <span class="ent">➌</span>. For each byte, it checks the taint status using <code>libdft</code>’s <code>tagmap_getb</code> function <span class="ent">➍</span>. If the byte is tainted, <code>alert</code> is called to print an error and exit <span class="ent">➎</span>.</p>&#13;
<p class="indent">The <code>tagmap_getb</code> function takes the memory address of a byte (in the form of a <code>uintptr_t</code>) as input and returns the shadow byte containing the taint color for that address. The taint color (called <code>tag</code> in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>) is a <code>uint8_t</code> since <code>libdft</code> keeps one shadow byte per memory byte. If <code>tag</code> is zero, then the memory byte is untainted. If it’s not zero, the byte is tainted, and the <code>tag</code> color can be used to find out what the taint source was. Because this DTA tool has only one taint source (network receives), it uses only a single taint color.</p>&#13;
<p class="indent">Sometimes you may want to fetch the taint tag of multiple memory bytes at once. For this purpose, <code>libdft</code> provides the <code>tagmap_getw</code> and <code>tagmap_getl</code> functions, which are analogous to <code>tagmap_getb</code> but return two or four consecutive shadow bytes at once, in the form of a <code>uint16_t</code> or a <code>uint32_t</code>, respectively.</p>&#13;
<h4 class="h4" id="ch11_2_2"><span epub:type="pagebreak" id="page_288"/><em>11.2.2 Taint Sources: Tainting Received Bytes</em></h4>&#13;
<p class="noindent">Now that you know how to check the taint color for a given memory address, let’s discuss how to taint bytes in the first place. <a href="ch11.xhtml#ch11list3">Listing 11-3</a> shows the code of <code>post_socketcall_hook</code>, which is the taint source called right after each <code>socketcall</code> syscall and that taints bytes received from the network.</p>&#13;
<p class="listing1" id="ch11list3"><em>Listing 11-3:</em> dta-execve.cpp <em>(continued)</em></p>&#13;
<pre>   static void<br/>   post_socketcall_hook(syscall_ctx_t *ctx)<br/>   {<br/>     int fd;<br/>     void *buf;<br/>     size_t len;<br/><br/><span class="ent">➊</span>   int call            =            (int)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>   unsigned long *args = (unsigned long*)ctx-&gt;arg[SYSCALL_ARG1];<br/><br/>     switch(call) {<br/><span class="ent">➌</span>   case SYS_RECV:<br/>     case SYS_RECVFROM:<br/><span class="ent">➍</span>      if(unlikely(ctx-&gt;ret &lt;= 0)) {<br/>          return;<br/>       }<br/><br/><span class="ent">➎</span>     fd =     (int)args[0];<br/><span class="ent">➏</span>     buf =  (void*)args[1];<br/><span class="ent">➐</span>     len = (size_t)ctx-&gt;ret;<br/><br/>       fprintf(stderr, "(dta-execve) recv: %zu bytes from fd %u\n", len, fd);<br/><br/>       for(size_t i = 0; i &lt; len; i++) {<br/>         if(isprint(((char*)buf)[i])) fprintf(stderr, "%c", ((char*)buf)[i]);<br/>         else                         fprintf(stderr, "\\x%02x", ((char*)buf)[i]);<br/>       }<br/>       fprintf(stderr, "\n");<br/><br/>       fprintf(stderr, "(dta-execve) tainting bytes %p -- 0x%x with tag 0x%x\n",<br/>               buf, (uintptr_t)buf+len, 0x01);<br/><br/><span class="ent">➑</span>      tagmap_setn((uintptr_t)buf, len, 0x01);<br/><br/>       break;<br/><span epub:type="pagebreak" id="page_289"/>     default:<br/>       break;<br/>     }<br/>   }</pre>&#13;
<p class="indent">In <code>libdft</code>, syscall hooks like <code>post_socketcall_hook</code> are <code>void</code> functions that take a <code>syscall_ctx_t*</code> as their only input argument. In <a href="ch11.xhtml#ch11list3">Listing 11-3</a>, I’ve called that input argument <code>ctx</code>, and it acts as a descriptor of the syscall that just took place. Among other things, it contains the arguments that were passed to the syscall and the return value of the syscall. The hook inspects <code>ctx</code> to determine which bytes (if any) to taint.</p>&#13;
<p class="indent">The <code>socketcall</code> syscall takes two arguments, which you can verify by reading <code>man socketcall</code>. The first is an <code>int</code> called <code>call</code>, and it tells you what kind of <code>socketcall</code> this is, for example, whether it’s a <code>recv</code> or <code>recvfrom</code>. The second, called <code>args</code>, contains a block of arguments for the <code>socketcall</code> in the form of an <code>unsigned long*</code>. The <code>post_socketcall_hook</code> begins by parsing <code>call</code> <span class="ent">➊</span> and <code>args</code> <span class="ent">➋</span> from the syscall <code>ctx</code>. To get an argument from the syscall <code>ctx</code>, you read the appropriate entry from its <code>arg</code> field (for example, <code>ctx-&gt;arg[SYSCALL_ARG0]</code>) and cast it to the correct type.</p>&#13;
<p class="indent">Next, <code>dta-execve</code> uses a <code>switch</code> to differentiate between the different possible <code>call</code> types. If <code>call</code> indicates that this is a <code>SYS_RECV</code> or <code>SYS_RECVFROM</code> event <span class="ent">➌</span>, then <code>dta-execve</code> inspects it more closely to find out which bytes were received and need to be tainted. It simply ignores any other event in the <code>default</code> case.</p>&#13;
<p class="indent">If the current event is a receive, then the next thing <code>dta-execve</code> does is check the return value of the <code>socketcall</code> by inspecting <code>ctx-&gt;ret</code> <span class="ent">➍</span>. If it’s less than or equal to zero, then no bytes were received, so nothing is tainted and the syscall hook simply returns. Inspecting the return value is possible only in a post-handler, since in a pre-handler the syscall you’re hooking hasn’t happened yet.</p>&#13;
<p class="indent">If bytes were received, then you need to parse the <code>args</code> array to access the <code>recv</code> or <code>recvfrom</code> argument and find the address of the receive buffer. The <code>args</code> array contains the arguments in the same order as the socket function corresponding to the <code>call</code> type. For <code>recv</code> and <code>recvfrom</code>, that means <code>args[0]</code> contains the socket file descriptor number <span class="ent">➎</span>, and <code>args[1]</code> contains the receive buffer address <span class="ent">➏</span>. The rest of the arguments aren’t needed here, so <code>post_socketcall_hook</code> doesn’t parse them. Given the receive buffer address and the <code>socketcall</code> return value (which indicates the number of received bytes <span class="ent">➐</span>), <code>post_socketcall_hook</code> can now taint all the received bytes.</p>&#13;
<p class="indent">After some diagnostic prints of the received bytes, <code>post_socketcall_hook</code> finally taints the received bytes by calling <code>tagmap_setn</code> <span class="ent">➑</span>, a <code>libdft</code> function that can taint an arbitrary number of bytes at once. It takes a <code>uintptr_t</code> representing a memory address as its first parameter, which is the first address that will be tainted. The next parameter is a <code>size_t</code> that specifies the number of bytes to taint and then a <code>uint8_t</code> containing the taint color. In this case, I’ve set the taint color to <code>0x01</code>. Now, all the received bytes are tainted, so if they ever influence any of <code>execve</code>’s inputs, <code>dta-execve</code> will notice and raise an alert.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>To taint only a small fixed number of bytes, <code>libdft</code> also provides functions called <code>tagmap_setb</code>, <code>tagmap_setw</code>, and <code>tagmap_setl</code>, which taint one, two, or four consecutive bytes, respectively. These have arguments equivalent to <code>tagmap_setn</code>, except that they omit the length parameter.</p>&#13;
<h4 class="h4" id="ch11_2_3"><em>11.2.3 Taint Sinks: Checking execve Arguments</em></h4>&#13;
<p class="noindent">Finally, let’s take a look at <code>pre_execve_hook</code>, the syscall hook that runs just before every <code>execve</code> and makes sure the <code>execve</code> inputs aren’t tainted. <a href="ch11.xhtml#ch11list4">Listing 11-4</a> shows the code of <code>pre_execve_hook</code>.</p>&#13;
<p class="listing1" id="ch11list4"><em>Listing 11-4:</em> dta-execve.cpp <em>(continued)</em></p>&#13;
<pre>   static void<br/>   pre_execve_hook(syscall_ctx_t *ctx)<br/>   {<br/><span class="ent">➊</span>   const char *filename = (const char*)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>   char * const *args   = (char* const*)ctx-&gt;arg[SYSCALL_ARG1];<br/><span class="ent">➌</span>   char * const *envp   = (char* const*)ctx-&gt;arg[SYSCALL_ARG2];<br/><br/>     fprintf(stderr, "(dta-execve) execve: %s (@%p)\n", filename, filename);<br/><br/><span class="ent">➍</span>    check_string_taint(filename, "execve command");<br/><span class="ent">➎</span>    while(args &amp;&amp; *args) {<br/>        fprintf(stderr, "(dta-execve) arg: %s (@%p)\n", *args, *args);<br/><span class="ent">➏</span>       check_string_taint(*args, "execve argument");<br/>        args++;<br/>     }<br/><span class="ent">➐</span>    while(envp &amp;&amp; *envp) {<br/>        fprintf(stderr, "(dta-execve) env: %s (@%p)\n", *envp, *envp);<br/><span class="ent">➑</span>       check_string_taint(*envp, "execve environment parameter");<br/>        envp++;<br/>     }<br/>   }</pre>&#13;
<p class="indent">The first thing <code>pre_execve_hook</code> does is parse the inputs of the <code>execve</code> from its <code>ctx</code> parameter. These inputs are the filename of the program the <code>execve</code> is about to run <span class="ent">➊</span> and then the argument array <span class="ent">➋</span> and environment array <span class="ent">➌</span> passed to <code>execve</code>. If any of these inputs are tainted, <code>pre_execve_hook</code> will raise an alert.</p>&#13;
<p class="indent">To check each input for taint, <code>pre_execve_hook</code> uses the <code>check_string_taint</code> function I previously described in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>. First, it uses this function to verify that the <code>execve</code> filename parameter is untainted <span class="ent">➍</span>. Subsequently, it loops over all the <code>execve</code> arguments <span class="ent">➎</span> and checks each of these for taint <span class="ent">➏</span>. Finally, <code>pre_execve_hook</code> loops over the environment array <span class="ent">➐</span> and checks that each environment parameter is untainted <span class="ent">➑</span>. If none of the inputs is tainted, <code>pre_execve_hook</code> runs to completion, and the <code>execve</code> syscall proceeds without <span epub:type="pagebreak" id="page_291"/>any alert. On the other hand, if any tainted input is found, then the program is aborted, and an error message is printed.</p>&#13;
<p class="indent">That’s all of the code in the <code>dta-execve</code> tool! As you can see, <code>libdft</code> allows you to implement DTA tools in a concise way. In this case, the example tool consists of only 165 lines of code, including all comments and diagnostic prints. Now that you’ve explored all of <code>dta-execve</code>’s code, let’s test how well it can detect attacks.</p>&#13;
<h4 class="h4" id="ch11_2_4"><em>11.2.4 Detecting a Control-Flow Hijacking Attempt</em></h4>&#13;
<p class="noindent">To test <code>dta-execve</code>’s ability to detect network-borne control-hijacking attacks, I’ll use a test program called <code>execve-test-overflow</code>. <a href="ch11.xhtml#ch11list5">Listing 11-5</a> shows the first part of its source, containing the <code>main</code> function. To save space, I omit error-checking code and unimportant functions in the listings of the test programs. As usual, you can find the full programs on the VM.</p>&#13;
<p class="listing1" id="ch11list5"><em>Listing 11-5:</em> execve-test-overflow.c</p>&#13;
<pre>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     char buf[4096];<br/>     struct sockaddr_storage addr;<br/><br/><span class="ent">➊</span>   int sockfd = open_socket("localhost", "9999");<br/><br/>     socklen_t addrlen = sizeof(addr);<br/><span class="ent">➋</span>   recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr*)&amp;addr, &amp;addrlen);<br/><br/><span class="ent">➌</span>   int child_fd = exec_cmd(buf);<br/><span class="ent">➍</span>   FILE *fp = fdopen(child_fd, "r");<br/><br/>     while(fgets(buf, sizeof(buf), fp)) {<br/><span class="ent">➎</span>       sendto(sockfd, buf, strlen(buf)+1, 0, (struct sockaddr*)&amp;addr, addrlen);<br/>     }<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent">As you can see, <code>execve-test-overflow</code> is a simple server program that opens a network socket (using the <code>open_socket</code> function omitted from the listing) and listens on <code>localhost</code> at port 9999 <span class="ent">➊</span>. Next, it receives a message from the socket <span class="ent">➋</span> and passes that message to a function called <code>exec_cmd</code> <span class="ent">➌</span>. As I’ll explain in the next listing, <code>exec_cmd</code> is a vulnerable function that executes a command using <code>execv</code> and can be influenced by an attacker who sends a malicious message to the server. When <code>exec_cmd</code> completes, it returns <span epub:type="pagebreak" id="page_292"/>a file descriptor that the server uses to read the output of the executed command <span class="ent">➍</span>. Finally, the server writes the command output to the network socket <span class="ent">➎</span>.</p>&#13;
<p class="indent">Normally, the <code>exec_cmd</code> function executes a program called <code>date</code> to get the current time and date, and the server then echoes this output over the network, prefixing it with the message previously received from the socket. However, <code>exec_cmd</code> contains a vulnerability that allows attackers to run a command of their choosing, as shown in <a href="ch11.xhtml#ch11list6">Listing 11-6</a>.</p>&#13;
<p class="listing1" id="ch11list6"><em>Listing 11-6:</em> execve-test-overflow.c <em>(continued)</em></p>&#13;
<pre><span class="ent">➊</span>  static struct __attribute__((packed)) {<br/><span class="ent">➋</span>   char prefix[32];<br/>     char datefmt[32];<br/>     char cmd[64];<br/>   } cmd = { "date: ", "\%Y-\%m-\%d \%H:\%M:\%S",<br/>             "/home/binary/code/chapter11/date" };<br/><br/>   int<br/>   exec_cmd(char *buf)<br/>   {<br/>     int pid;<br/>     int p[2];<br/>     char *argv[3];<br/><br/><span class="ent">➌</span>   for(size_t i = 0; i &lt; strlen(buf); i++) { /* Buffer overflow! */<br/>       if(buf[i] == '\n') {<br/>         cmd.prefix[i] = '\0';<br/>         break;<br/>       }<br/>       cmd.prefix[i] = buf[i];<br/>    }<br/><br/><span class="ent">➍</span>   argv[0] = cmd.cmd;<br/>    argv[1] = cmd.datefmt;<br/>    argv[2] = NULL;<br/><br/><span class="ent">➎</span>   pipe(p);<br/><span class="ent">➏</span>   switch(pid = fork()) {<br/>    case -1: /* Error */<br/>      perror("(execve-test) fork failed");<br/>      return -1;<br/><span class="ent">➐</span>   case 0: /* Child */<br/>       printf("(execve-test/child) execv: %s %s\n", argv[0], argv[1]);<br/><br/><span class="ent">➑</span>     close(1);<br/>       dup(p[1]);<br/>       close(p[0]);<br/><br/><span epub:type="pagebreak" id="page_293"/>       printf("%s", cmd.prefix);<br/>       fflush(stdout);<br/><span class="ent">➒</span>     execv(argv[0], argv);<br/>       perror("(execve-test/child) execv failed");<br/>       kill(getppid(), SIGINT);<br/>       exit(1);<br/>     default: /* Parent */<br/>       close(p[1]);<br/>       return p[0];<br/>     }<br/><br/>     return -1;<br/>  }</pre>&#13;
<p class="indent">The server uses a global <code>struct</code> called <code>cmd</code> to keep track of the command and its associated parameters <span class="ent">➊</span>. It contains a <code>prefix</code> for the command output (the message previously received from the socket) <span class="ent">➋</span>, as well as a date format string and a buffer containing the <code>date</code> command itself. While Linux comes with a default <code>date</code> utility, I’ve implemented my own for this test, which you’ll find in <em>~/code/chapter11/date</em>. This is necessary because the default <code>date</code> utility on the VM is 64-bit, which <code>libdft</code> does not support.</p>&#13;
<p class="indent">Now let’s take a look at the <code>exec_cmd</code> function, which begins by copying the message received from the network (stored in <code>buf</code>) into <code>cmd</code>’s <code>prefix</code> field <span class="ent">➌</span>. As you can see, the copy lacks proper bound checks, which means attackers could send a malicious message that would overflow <code>prefix</code>, allowing them to overwrite the adjacent fields in <code>cmd</code>, containing the date format and the command path.</p>&#13;
<p class="indent">Next, <code>exec_cmd</code> copies the command and date format argument from the <code>cmd</code> structure into an <code>argv</code> array to use for the <code>execv</code> <span class="ent">➍</span>. Then, it opens a pipe <span class="ent">➎</span> and uses <code>fork</code> <span class="ent">➏</span> to start a child process <span class="ent">➐</span>, which will execute the command and report the output to the parent process. The child process redirects <code>stdout</code> over the pipe <span class="ent">➑</span> so that the parent process can read the <code>execv</code> output from the pipe and forward it over the socket. Finally, the child calls the <code>execv</code> with the possibly attacker-controlled command and arguments as input <span class="ent">➒</span>.</p>&#13;
<p class="indent">Let’s now run <code>execve-test-overflow</code> to see how an attacker can abuse the <code>prefix</code> overflow vulnerability to hijack control in practice. I’ll first run it without the protection of the <code>dta-execve</code> tool so that you can see the attack succeed. After that, I’ll enable <code>dta-execve</code> so you can see how it detects and stops the attack.</p>&#13;
<h3 class="h3">A Successful Control Hijack Without DTA</h3>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11list7">Listing 11-7</a> shows a benign run of <code>execve-test-overflow</code>, followed by an example of how to exploit the buffer overflow to execute a command of the attacker’s choice instead of <code>date</code>. I’ve replaced some repetitive parts of the output with “...” to keep the code lines from becoming too wide.</p>&#13;
<p class="listing1" id="ch11list7"><span epub:type="pagebreak" id="page_294"/><em>Listing 11-7: Control hijacking in</em> <span class="codeitalic">execve-test-overflow</span></p>&#13;
<pre>   $ <span class="codestrong1">cd /home/binary/code/chapter11/</span><br/><span class="ent">➊</span> $ <span class="codestrong1">./execve-test-overflow &amp;</span><br/>   [1] 2506<br/><span class="ent">➋</span> $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➌</span> foobar:<br/>   (execve-test/child) execv: /home/binary/code/chapter11/date %Y-%m-%d %H:%M:%S<br/><span class="ent">➍</span> foobar: 2017-12-06 15:25:08<br/>   <span class="codestrong1">ˆC</span><br/>   [1]+ Done                     ./execve-test-overflow<br/><span class="ent">➎</span> $ <span class="codestrong1">./execve-test-overflow &amp;</span><br/>   [1] 2533<br/><span class="ent">➏</span> $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➐</span> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB/home/binary/code/chapter11/echo<br/>   (execve-test/child) execv: /home/binary/code/chapter11/echo BB...BB/home/binary/.../echo<br/><span class="ent">➑</span> AA...AABB...BB/home/binary/code/chapter11/echo BB...BB/home/binary/code/chapter11/echo<br/>   <span class="codestrong1">ˆC</span><br/>   [1]+ Done                     ./execve-test-overflow</pre>&#13;
<p class="indent">For the benign run, I start the <code>execve-test-overflow</code> server as a background process <span class="ent">➊</span> and then use <code>netcat</code> (<code>nc</code>) to connect to the server <span class="ent">➋</span>. In <code>nc</code>, I enter the string “<code>foobar:</code> ” <span class="ent">➌</span> and send it to the server, which will use it as the output prefix. The server runs the <code>date</code> command and echoes back the current date, prefixed with “<code>foobar:</code> ” <span class="ent">➍</span>.</p>&#13;
<p class="indent">Now to demonstrate the buffer overflow vulnerability, I restart the server <span class="ent">➎</span> and connect to it again with <code>nc</code> <span class="ent">➏</span>. This time, the string I send is much longer <span class="ent">➐</span>, long enough to overflow the <code>prefix</code> field in the global <code>cmd</code> structure. It consists of 32 <code>A</code>s to fill up the 32-byte <code>prefix</code> buffer, followed by 32 <code>B</code>s, which overflow into the <code>datefmt</code> buffer and again fill it up completely. The last part of the string overflows into the <code>cmd</code> buffer, and it’s a path to the program to run instead of <code>date</code>, namely, <em>~/code/chapter11/echo</em>. At this point, the contents of the global <code>cmd</code> struct look as follows:</p>&#13;
<pre>static struct __attribute__((packed)) {<br/>  char prefix[32];  /* AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA */<br/>  char datefmt[32]; /* BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB */<br/>  char cmd[64];     /* /home/binary/code/chapter11/echo */<br/>} cmd;</pre>&#13;
<p class="indent">Recall that the server copies the contents of the <code>cmd</code> structure into the <code>argv</code> array used for the <code>execv</code>. Thus, as a result of the overflow, the <code>execv</code> runs the <code>echo</code> program instead of <code>date</code>! The <code>datefmt</code> buffer is passed to <code>echo</code> as a command line argument, but because it doesn’t contain a terminating <code>NULL</code>, the real command line argument that <code>echo</code> sees is <code>datefmt</code> concatenated with the <code>cmd</code> buffer. Finally, after running <code>echo</code>, the server writes the output back <span epub:type="pagebreak" id="page_295"/>to the socket <span class="ent">➑</span>, which consists of the concatenation of <code>prefix</code>, <code>datefmt</code>, and <code>cmd</code> as the prefix, followed by the output of the <code>echo</code> command.</p>&#13;
<p class="indent">Now that you know how to coax the <code>execve-test-overflow</code> program into executing an unintended command by supplying it with a malicious input from the network, let’s see whether the <code>dta-execve</code> tool will succeed in stopping this attack!</p>&#13;
<h3 class="h3">Using DTA to Detect the Hijacking Attempt</h3>&#13;
<p class="noindent">To test whether <code>dta-execve</code> can stop the attack in the previous section, I’ll run the same attack again. Only this time, <code>execve-test-overflow</code> will be protected by the <code>dta-execve</code> tool. <a href="ch11.xhtml#ch11list8">Listing 11-8</a> shows the results.</p>&#13;
<p class="listing1" id="ch11list8"><em>Listing 11-8: Detecting an attempted control hijack with</em> <span class="codeitalic">dta-execve</span></p>&#13;
<pre>   $ <span class="codestrong1">cd /home/binary/libdft/pin-2.13-61206-gcc.4.4.7-linux/</span><br/><span class="ent">➊</span>  $ <span class="codestrong1">./pin.sh -follow_execv -t /home/binary/code/chapter11/dta-execve.so \</span><br/>              <span class="codestrong1">-- /home/binary/code/chapter11/execve-test-overflow &amp;</span><br/>   [1] 2994<br/><span class="ent">➋</span>  $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➌</span>  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB/home/binary/code/chapter11/echo<br/><span class="ent">➍</span>  (dta-execve) recv: 97 bytes from fd 4<br/>    AA...AABB...BB/home/binary/code/chapter11/echo\x0a<br/><span class="ent">➎</span>  (dta-execve) tainting bytes 0xffa231ec -- 0xffa2324d with tag 0x1<br/><span class="ent">➏</span>  (execve-test/child) execv: /home/binary/code/chapter11/echo BB...BB/home/binary/.../echo<br/><span class="ent">➐</span>  (dta-execve) execve: /home/binary/code/chapter11/echo (@0x804b100)<br/><span class="ent">➑</span>  (dta-execve) checking taint on bytes 0x804b100 -- 0x804b120 (execve command)...<br/><span class="ent">➒</span>  (dta-execve) !!!!!!! ADDRESS 0x804b100 IS TAINTED (execve command, tag=0x01), ABORTING !!!!!!!<br/><span class="ent">➓</span>   AA...AABB...BB/home/binary/code/chapter11/echo<br/>    [1]+ Done ./pin.sh -follow_execv ...</pre>&#13;
<p class="indent">Because <code>libdft</code> is based on Pin, you’ll need to run Pin using <code>dta-execve</code> as the Pin tool <span class="ent">➊</span> to protect <code>execve-test-overflow</code> with <code>dta-execve</code>. As you can see, I’ve added <code>-follow_execv</code> to the Pin options so that Pin will instrument all child processes of <code>execve-test-overflow</code> the same way as the parent process. This is important because the vulnerable <code>execv</code> is called in a child process.</p>&#13;
<p class="indent">After starting the <code>execve-test-overflow</code> server protected with <code>dta-execve</code>, I run <code>nc</code> again to connect to the server <span class="ent">➋</span>. Then, I send the same exploit string used in the previous section <span class="ent">➌</span> to overflow the <code>prefix</code> buffer and change the <code>cmd</code>. Keep in mind that <code>dta-execve</code> uses network receives as taint sources. You can see this in <a href="ch11.xhtml#ch11list8">Listing 11-8</a> because the <code>socketcall</code> handler prints a diagnostic message showing that it has intercepted the received message <span class="ent">➍</span>. The <code>socketcall</code> handler then taints all the bytes received from the network <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, a diagnostic print from the server tells you that it’s about to execute the attacker-controlled <code>echo</code> command <span class="ent">➏</span>. Fortunately, this time <code>dta-execve</code> intercepts the <code>execv</code> before it’s too late <span class="ent">➐</span>. It checks the taint on all of the <code>execv</code> arguments, starting with the <code>execv</code> command <span class="ent">➑</span>. Since this command is controlled by the attacker via the network-borne buffer overflow, <code>dta-execve</code> notices that the command is tainted with color <code>0x01</code>. It raises an <span epub:type="pagebreak" id="page_296"/>alert and then stops the child process that’s about to execute the attacker’s command, thereby successfully preventing the attack <span class="ent">➒</span>. The only server output that’s written back to the attacker is the prefix string they themselves supplied <span class="ent">➓</span>, since it was printed before the <code>execv</code> that caused <code>dta-execve</code> to abort the child process.</p>&#13;
<h3 class="h3" id="ch11_3">11.3 Circumventing DTA with Implicit Flows</h3>&#13;
<p class="noindent">So far so good: <code>dta-execve</code> successfully detected and stopped the control-hijacking attack from the previous section. Unfortunately, <code>dta-execve</code> is not entirely foolproof because practical DTA systems like <code>libdft</code> can’t track data propagated through <em>implicit flows</em>. <a href="ch11.xhtml#ch11list9">Listing 11-9</a> shows a modified version of the <code>execve-test-overflow</code> server, which contains an implicit flow that prevents <code>dta-execve</code> from detecting the attack. For brevity, the listing shows only the parts of the code that are different from the original server.</p>&#13;
<p class="listing1" id="ch11list9"><em>Listing 11-9:</em> execve-test-overflow-implicit.c</p>&#13;
<pre>  int<br/>  exec_cmd(char *buf)<br/>  {<br/>    int pid;<br/>    int p[2];<br/>    char *argv[3];<br/><br/><span class="ent">➊</span>   for(size_t i = 0; i &lt; strlen(buf); i++) {<br/>       if(buf[i] == '\n') {<br/>         cmd.prefix[i] = '\0';<br/>         break;<br/>       }<br/><span class="ent">➋</span>      char c = 0;<br/><span class="ent">➌</span>      while(c &lt; buf[i]) c++;<br/><span class="ent">➍</span>      cmd.prefix[i] = c;<br/>    }<br/><br/>    /* Set up argv and continue with execv */<br/>  }</pre>&#13;
<p class="indent">The only changed parts of the code are in the <code>exec_cmd</code> function, which contains a vulnerable <code>for</code> loop that copies all of the bytes from the receive buffer <code>buf</code> into the global <code>prefix</code> buffer <span class="ent">➊</span>. As before, the loop lacks bounds checking, so <code>prefix</code> will overflow if the message in <code>buf</code> is too long. Now, however, the bytes are copied <em>implicitly</em> in such a way that the overflow isn’t detected by the DTA tool!</p>&#13;
<p class="indent">As explained in <a href="ch10.xhtml#ch10">Chapter 10</a>, implicit flows are the result of <em>control dependencies</em>, meaning that the data propagation depends on control structures instead of explicit data operations. In <a href="ch11.xhtml#ch11list9">Listing 11-9</a>, that control structure is a <code>while</code> loop. For each byte, the modified <code>exec_cmd</code> function initializes a <code>char c</code> <span epub:type="pagebreak" id="page_297"/>to zero <span class="ent">➋</span> and then uses the <code>while</code> loop to increment <code>c</code> until it has the same value as <code>buf[i]</code> <span class="ent">➌</span>, effectively copying <code>buf[i]</code> into <code>c</code> without ever explicitly copying any data. Finally, <code>c</code> is copied into <code>prefix</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Ultimately, the effect of this code is the same as in the original version of <code>execve-test-overflow</code>: <code>buf</code> is copied into <code>prefix</code>. However, the key is that <em>there’s no explicit data flow between</em> <code><em>buf</em></code> <em>and</em> <em><code>prefix</code></em> because the copy from <code>buf[i]</code> into <code>c</code> is implemented using that <code>while</code> loop, avoiding an explicit data copy. This introduces a control dependency between <code>buf[i]</code> and <code>c</code> (and thus, transitively, between <code>buf[i]</code> and <code>prefix[i]</code>), which <code>libdft</code> cannot track.</p>&#13;
<p class="indent">When you retry <a href="ch11.xhtml#ch11list8">Listing 11-8</a>’s attack by replacing <code>execve-test-overflow</code> with <code>execve-test-overflow-implicit</code>, you’ll see that the attack now succeeds despite <code>dta-execve</code>’s protection!</p>&#13;
<p class="indent">You may remark that if you’re using DTA to prevent attacks against a server that you control, you can just write the server in such a way that it doesn’t contain implicit flows that confuse <code>libdft</code>. While this may be possible (though not trivial) in most cases, in malware analysis you’ll find it difficult to get around the problem of implicit flows, because you don’t control the malware’s code and the malware may contain deliberately crafted implicit flows to confuse taint analysis.</p>&#13;
<h3 class="h3" id="ch11_4">11.4 A DTA-Based Data Exfiltration Detector</h3>&#13;
<p class="noindent">The previous example tool requires only a single taint color because bytes are either attacker controlled or not. Now let’s build a tool that uses multiple taint colors to detect file-based information leaks so that when a file leaks, you can tell <em>which</em> file. The idea behind this tool is similar to the taint-based defense against the Heartbleed bug you saw in <a href="ch10.xhtml#ch10">Chapter 10</a>, except that here the tool uses file reads instead of memory buffers as the taint source.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11list10">Listing 11-10</a> shows the first part of this new tool, which I’ll call <code>dta -dataleak</code>. Again, I omit includes of standard C header files for brevity.</p>&#13;
<p class="listing1" id="ch11list10"><em>Listing 11-10:</em> dta-dataleak.cpp</p>&#13;
<pre><span class="ent">➊</span>  #include "pin.H"<br/><br/>   #include  "branch_pred.h"<br/>   #include  "libdft_api.h"<br/>   #include  "syscall_desc.h"<br/>   #include  "tagmap.h"<br/><br/><span class="ent">➋</span>  extern syscall_desc_t syscall_desc[SYSCALL_MAX];<br/><span class="ent">➌</span>  static std::map&lt;int, uint8_t&gt; fd2color;<br/><span class="ent">➍</span>  static std::map&lt;uint8_t, std::string&gt; color2fname;<br/><br/><span class="ent">➎</span>  #define MAX_COLOR 0x80<br/><br/>   void alert(uintptr_t addr, uint8_t tag);<br/>   static void post_open_hook(syscall_ctx_t *ctx);<br/>   static void post_read_hook(syscall_ctx_t *ctx);<br/>   static void pre_socketcall_hook(syscall_ctx_t *ctx);<br/><br/>   int<br/>   main(int argc, char **argv)<br/>   {<br/>     PIN_InitSymbols();<br/><br/>     if(unlikely(PIN_Init(argc, argv))) {<br/>       return 1;<br/>     }<br/><br/>     if(unlikely(libdft_init() != 0)) {<br/>       libdft_die();<br/>       return 1;<br/>     }<br/><br/><span class="ent">➏</span>  syscall_set_post(&amp;syscall_desc[__NR_open], post_open_hook);<br/><span class="ent">➐</span>  syscall_set_post(&amp;syscall_desc[__NR_read], post_read_hook);<br/><span class="ent">➑</span>  syscall_set_pre (&amp;syscall_desc[__NR_socketcall], pre_socketcall_hook);<br/><br/>   PIN_StartProgram();<br/><br/>   return 0;<br/> }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Just as in the previous DTA tool, <code>dta-dataleak</code> includes <em>pin.H</em> and all the relevant <code>libdft</code> header files <span class="ent">➊</span>. It also includes the now familiar <code>extern</code> declaration of the <code>syscall_desc</code> array <span class="ent">➋</span> to hook syscalls for the taint sources and sinks. In addition, <code>dta-dataleak</code> defines some data structures that weren’t there in <code>dta-execve</code>.</p>&#13;
<p class="indent">The first of these, <code>fd2color</code>, is a C++ <code>map</code> that maps file descriptors to taint colors <span class="ent">➌</span>. The second is also a C++ map, called <code>color2fname</code>, and it maps taint colors to filenames <span class="ent">➍</span>. You’ll see why these data structures are needed in the next few listings.</p>&#13;
<p class="indent">There’s also a <code>#define</code> of a constant called <code>MAX_COLOR</code> <span class="ent">➎</span>, which is the maximum possible taint color value, <code>0x80</code>.</p>&#13;
<p class="indent">The <code>main</code> function of <code>dta-dataleak</code> is almost identical to that of <code>dta-execve</code> in that it initializes Pin and <code>libdft</code> and then starts the application. The only difference is in which taint sources and sinks <code>dta-dataleak</code> defines. It installs two post-handlers, called <code>post_open_hook</code> <span class="ent">➏</span> and <code>post_read_hook</code> <span class="ent">➐</span>, which run just after the <code>open</code> and <code>read</code> syscalls, respectively. The <code>open</code> hook keeps track of which file descriptors are open, while the <code>read</code> hook is the actual taint source, which taints bytes read from open files, as I’ll explain in a moment.</p>&#13;
<p class="indent">In addition, <code>dta-dataleak</code> installs a pre-handler for the <code>socketcall</code> syscall, called <code>pre_socketcall_hook</code> <span class="ent">➑</span>. The <code>pre_socketcall_hook</code> is the taint sink, which intercepts any data that’s about to be sent over the network so that it can <span epub:type="pagebreak" id="page_299"/>make sure the data isn’t tainted before allowing the send. If any tainted data is about to be leaked, <code>pre_socketcall_hook</code> raises an alert, using a function called <code>alert</code>, which I’ll explain next.</p>&#13;
<p class="indent">Keep in mind that this example tool is simplified. In a real tool, you’ll want to hook additional taint sources (such as the <code>readv</code> syscall) and sinks (such as <code>write</code> syscalls on a socket) for completeness. You’ll also want to implement some rules that determine which files are okay to leak over the network and which aren’t, rather than assuming all file leaks are malicious.</p>&#13;
<p class="indent">Now let’s take a look at the <code>alert</code> function, shown in <a href="ch11.xhtml#ch11list11">Listing 11-11</a>, which is called if any tainted data is about to leak over the network. Because it’s similar to <code>dta-execve</code>’s <code>alert</code> function, I’ll describe it only briefly here.</p>&#13;
<p class="listing1" id="ch11list11"><em>Listing 11-11:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<pre>   void<br/>   alert(uintptr_t addr, uint8_t tag)<br/>   {<br/><span class="ent">➊</span>   fprintf(stderr,<br/>       "\n(dta-dataleak) !!!!!!! ADDRESS 0x%x IS TAINTED (tag=0x%02x), ABORTING !!!!!!!\n",<br/>       addr, tag);<br/><br/><span class="ent">➋</span>   for(unsigned c = 0x01; c &lt;= MAX_COLOR; c &lt;&lt;= 1) {<br/><span class="ent">➌</span>     if(tag &amp; c) {<br/><span class="ent">➍</span>       fprintf(stderr, " tainted by color = 0x%02x (%s)\n", c, color2fname[c].c_str());<br/>      }<br/>    }<br/><span class="ent">➎</span>   exit(1);<br/>  }</pre>&#13;
<p class="indent">The <code>alert</code> function starts by displaying an alert message, detailing which address is tainted and with which colors <span class="ent">➊</span>. It’s possible that the data leaked over the network is influenced by multiple files and therefore tainted with multiple colors. So, <code>alert</code> loops over all possible taint colors <span class="ent">➋</span> and checks which of them are present in the tag of the tainted byte that caused the alert <span class="ent">➌</span>. For each color that’s enabled in the tag, <code>alert</code> prints the color and the corresponding filename <span class="ent">➍</span>, which it reads from the <code>color2fname</code> data structure. Finally, <code>alert</code> calls <code>exit</code> to stop the application and prevent the data leak <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, let’s examine the taint sources for the <code>dta-dataleak</code> tool.</p>&#13;
<h4 class="h4" id="ch11_4_1"><em>11.4.1 Taint Sources: Tracking Taint for Open Files</em></h4>&#13;
<p class="noindent">As I just mentioned, <code>dta-dataleak</code> installs two syscall post-handlers: a hook for the <code>open</code> syscall that keeps track of open files and a hook for <code>read</code> that taints bytes read from open files. Let’s first look at the code for the <code>open</code> hook and then look at the <code>read</code> handler.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_300"/>Tracking Open Files</h3>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11list12">Listing 11-12</a> shows the code for <code>post_open_hook</code>, the post-handler for the <code>open</code> syscall.</p>&#13;
<p class="listing1" id="ch11list12"><em>Listing 11-12:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<pre>   static void<br/>   post_open_hook(syscall_ctx_t *ctx)<br/>   {<br/><span class="ent">➊</span>   static uint8_t next_color = 0x01;<br/>     uint8_t color;<br/><span class="ent">➋</span>   int fd            =         (int)ctx-&gt;ret;<br/><span class="ent">➌</span>   const char *fname = (const char*)ctx-&gt;arg[SYSCALL_ARG0];<br/>   <br/><span class="ent">➍</span>   if(unlikely((int)ctx-&gt;ret &lt; 0)) {<br/>       return;<br/>     }<br/>   <br/><span class="ent">➎</span>   if(strstr(fname, ".so") || strstr(fname, ".so.")) {<br/>       return;<br/>     }<br/>   <br/>     fprintf(stderr, "(dta-dataleak) opening %s at fd %u with color 0x%02x\n",<br/>            fname, fd, next_color);<br/>   <br/><span class="ent">➏</span>    if(!fd2color[fd]) {<br/>        color = next_color;<br/>        fd2color[fd] = color;<br/><span class="ent">➐</span>      if(next_color &lt; MAX_COLOR) next_color &lt;&lt;= 1;<br/><span class="ent">➑</span>    } else {<br/>       /* reuse color of file with same fd that was opened previously */<br/>       color = fd2color[fd];<br/>     }<br/>   <br/>     /* multiple files may get the same color if the same fd is reused<br/>     * or we run out of colors */<br/><span class="ent">➒</span>   if(color2fname[color].empty()) color2fname[color] = std::string(fname);<br/><span class="ent">➓</span>   else color2fname[color] += " | " + std::string(fname);<br/>  }</pre>&#13;
<p class="indent">Recall that the purpose of <code>dta-dataleak</code> is to detect information leak attempts that leak data read from a file. For <code>dta-dataleak</code> to tell <em>which</em> file is being leaked, it assigns a different color to each open file. The purpose of the <code>open</code> syscall handler, <code>post_open_hook</code>, is to assign a taint color to each file descriptor when it’s opened. It also filters out some uninteresting files, such <span epub:type="pagebreak" id="page_301"/>as shared libraries. In a real-world DTA tool, you’ll likely want to implement more filters to control which files to protect against information leaks.</p>&#13;
<p class="indent">To keep track of the next available taint color, <code>post_open_hook</code> uses a <code>static</code> variable called <code>next_color</code>, which is initialized to the color <code>0x01</code> <span class="ent">➊</span>. Next, it parses the syscall context (<code>ctx</code>) of the <code>open</code> syscall that just occurred to obtain the file descriptor <code>fd</code> <span class="ent">➋</span> and the filename <code>fname</code> <span class="ent">➌</span> of the just opened file. If the <code>open</code> failed <span class="ent">➍</span> or the opened file is a shared library that’s not interesting to track <span class="ent">➎</span>, <code>post_open_hook</code> returns without assigning any color to the file. To determine whether the file is a shared library, <code>post_open_hook</code> simply checks whether the filename contains a file extension indicative of a shared library, such as <em>.so</em>. In a real tool, you’ll want to use more robust checks by opening a suspected shared library and verifying that it starts with the ELF magic bytes, for instance (see also <a href="ch02.xhtml#ch02">Chapter 2</a>).</p>&#13;
<p class="indent">If the file is interesting enough to assign it a taint color, <code>post_open_hook</code> distinguishes two cases:</p>&#13;
<ol>&#13;
<li class="noindent">If there is no color assigned to the file descriptor yet (in other words, there is no entry for <code>fd</code> in the <code>fd2color</code> map), then <code>post_open_hook</code> assigns <code>next_color</code> to this file descriptor <span class="ent">➏</span> and advances <code>next_color</code> by shifting it left by 1 bit.<br/>     Note that since <code>libdft</code> supports only eight colors, you might run out of colors if the application opens too many files. Therefore, <code>post_open_hook</code> advances <code>next_color</code> only until it reaches the maximum color <code>0x80</code> <span class="ent">➐</span>. After that, the color <code>0x80</code> will be used for all subsequently opened files. What this means in practice is that the color <code>0x80</code> might correspond not just to one file but to a whole list of files. Thus, when a byte with color <code>0x80</code> leaks, you might not know exactly which file the byte came from, only that it’s from one of the files in the list. Unfortunately, that’s the price you have to pay for keeping the shadow memory small by supporting only eight colors.</li>&#13;
<li class="noindent">Sometimes a file descriptor is closed at some point, and then the same file descriptor number is reused to open another file. In that case, <code>fd2color</code> will already contain an assigned color for that file descriptor number <span class="ent">➑</span>. To keep things simple, I simply reuse the existing color for the repurposed file descriptor, meaning that that color will now correspond to a list of files instead of just one, exactly as when you run out of colors.</li>&#13;
</ol>&#13;
<p class="indent">At the end of <code>post_open_hook</code>, the <code>color2fname</code> map is updated with the filename of the just opened file <span class="ent">➒</span>. This way, when data leaks, you can use the taint color of the leaked data to look up the name of the corresponding file, as you just saw in the <code>alert</code> function. If the taint color was reused for multiple files because of one of these reasons, then the <code>color2fname</code> entry for that color will be a list of filenames separated with a pipe (|) <span class="ent">➓</span>.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_302"/>Tainting File Reads</h3>&#13;
<p class="noindent">Now that every opened file is associated with a taint color, let’s look at the <code>post_read_hook</code> function, which taints bytes read from a file with that file’s assigned color. <a href="ch11.xhtml#ch11list13">Listing 11-13</a> shows the relevant code.</p>&#13;
<p class="listing1" id="ch11list13"><em>Listing 11-13:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<pre>   static void<br/>   post_read_hook(syscall_ctx_t *ctx)<br/>   {<br/><span class="ent">➊</span>    int fd     =    (int)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>    void *buf  =  (void*)ctx-&gt;arg[SYSCALL_ARG1];<br/><span class="ent">➌</span>    size_t len = (size_t)ctx-&gt;ret;<br/>     uint8_t color;<br/><br/><span class="ent">➍</span>    if(unlikely(len &lt;= 0)) {<br/>       return;<br/>     }<br/><br/>     fprintf(stderr, "(dta-dataleak) read: %zu bytes from fd %u\n", len, fd);<br/><br/><span class="ent">➎</span>    color = fd2color[fd];<br/><span class="ent">➏</span>    if(color) {<br/>        fprintf(stderr, "(dta-dataleak) tainting bytes %p -- 0x%x with color 0x%x\n",<br/>               buf, (uintptr_t)buf+len, color);<br/><span class="ent">➐</span>      tagmap_setn((uintptr_t)buf, len, color);<br/><span class="ent">➑</span>    } else {<br/>       fprintf(stderr, "(dta-dataleak) clearing taint on bytes %p -- 0x%x\n",<br/>               buf, (uintptr_t)buf+len);<br/><span class="ent">➒</span>      tagmap_clrn((uintptr_t)buf, len);<br/>     }<br/>   }</pre>&#13;
<p class="indent">First, <code>post_read_hook</code> parses the relevant arguments and return value from the syscall context to obtain the file descriptor that’s being read (<code>fd</code>) <span class="ent">➊</span>, the buffer into which bytes are read (<code>buf</code>) <span class="ent">➋</span>, and the number of bytes read (<code>len</code>) <span class="ent">➌</span>. If <code>len</code> is less than or equal to zero, no bytes were read, so <code>post_read_hook</code> returns without tainting anything <span class="ent">➍</span>.</p>&#13;
<p class="indent">Otherwise, it obtains <code>fd</code>’s taint color by reading it from <code>fd2color</code> <span class="ent">➎</span>. If <code>fd</code> has an associated taint color <span class="ent">➏</span>, <code>post_read_hook</code> uses <code>tagmap_setn</code> to taint all of the read bytes with that color <span class="ent">➐</span>. It may also happen that <code>fd</code> has no associated color <span class="ent">➑</span>, meaning that it refers to an uninteresting file such as a shared library. In that case, we clear any taint from the addresses overwritten by the <code>read</code> syscall <span class="ent">➒</span> by using the <code>libdft</code> function <code>tagmap_clrn</code>. This clears the taint from any previously tainted buffer that’s reused to read untainted bytes.</p>&#13;
<h4 class="h4" id="ch11_4_2"><span epub:type="pagebreak" id="page_303"/><em>11.4.2 Taint Sinks: Monitoring Network Sends for Data Exfiltration</em></h4>&#13;
<p class="noindent">Finally, <a href="ch11.xhtml#ch11list14">Listing 11-14</a> shows <code>dta-dataleak</code>’s taint sink, the <code>socketcall</code> handler that intercepts network sends to check them for data exfiltration attempts. It’s similar to the <code>socketcall</code> handler you saw in the <code>dta-execve</code> tool, except that it checks sent bytes for taint instead of applying taint to received bytes.</p>&#13;
<p class="listing1" id="ch11list14"><em>Listing 11-14:</em> dta-dataleak.cpp <em>(continued)</em></p>&#13;
<pre>   static void<br/>   pre_socketcall_hook(syscall_ctx_t *ctx)<br/>   {<br/>     int fd;<br/>     void *buf;<br/>     size_t i, len;<br/>     uint8_t tag;<br/>     uintptr_t start, end, addr;<br/><br/><span class="ent">➊</span>   int call            =            (int)ctx-&gt;arg[SYSCALL_ARG0];<br/><span class="ent">➋</span>   unsigned long *args = (unsigned long*)ctx-&gt;arg[SYSCALL_ARG1];<br/><br/>     switch(call) {<br/><span class="ent">➌</span>    case SYS_SEND:<br/>     case SYS_SENDTO:<br/><span class="ent">➍</span>     fd  =    (int)args[0];<br/>       buf =  (void*)args[1];<br/>       len = (size_t)args[2];<br/><br/>       fprintf(stderr, "(dta-dataleak) send: %zu bytes to fd %u\n", len, fd);<br/><br/>       for(i = 0; i &lt; len; i++) {<br/>         if(isprint(((char*)buf)[i])) fprintf(stderr, "%c", ((char*)buf)[i]);<br/>         else                         fprintf(stderr, "\\x%02x", ((char*)buf)[i]);<br/>       }<br/>       fprintf(stderr, "\n");<br/><br/>       fprintf(stderr, "(dta-dataleak) checking taint on bytes %p -- 0x%x...",<br/>              buf, (uintptr_t)buf+len);<br/><br/>       start = (uintptr_t)buf;<br/>       end   = (uintptr_t)buf+len;<br/><span class="ent">➎</span>     for(addr = start; addr &lt;= end; addr++) {<br/><span class="ent">➏</span>        tag = tagmap_getb(addr);<br/><span class="ent">➐</span>        if(tag != 0) alert(addr, tag);<br/>       }<br/><br/>       fprintf(stderr, "OK\n");<br/><span epub:type="pagebreak" id="page_304"/>          break;<br/><br/>       default:<br/>          break;<br/>       }<br/>    }</pre>&#13;
<p class="indent">First, <code>pre_socketcall_hook</code> obtains the <code>call</code> <span class="ent">➊</span> and <code>args</code> <span class="ent">➋</span> parameters for the <code>socketcall</code>. It then uses a switch on <code>call</code> just like the one you saw in the <code>socketcall</code> handler for <code>dta-execve</code>, except that this new switch inspects <code>SYS_SEND</code> and <code>SYS_SENDTO</code> <span class="ent">➌</span> instead of <code>SYS_RECV</code> and <code>SYS_RECVFROM</code>. If it intercepts a send event, it parse the send’s arguments: the socket file descriptor, send buffer, and number of bytes to send <span class="ent">➍</span>. After some diagnostic prints, the code loops over all of the bytes in the send buffer <span class="ent">➎</span> and gets each byte’s taint status using <code>tagmap_getb</code> <span class="ent">➏</span>. If a byte is tainted, <code>pre_socketcall_hook</code> calls the <code>alert</code> function to print an alert and stop the application <span class="ent">➐</span>.</p>&#13;
<p class="indent">That covers the entire code for the <code>dta-dataleak</code> tool. In the next section, you’ll see how <code>dta-dataleak</code> detects a data exfiltration attempt and how taint colors combine when exfiltrated data depends on multiple taint sources.</p>&#13;
<h4 class="h4" id="ch11_4_3"><em>11.4.3 Detecting a Data Exfiltration Attempt</em></h4>&#13;
<p class="noindent">To demonstrate <code>dta-dataleak</code>’s ability to detect data leaks, I’ve implemented another simple server called <code>dataleak-test-xor</code>. For simplicity, this server “leaks” tainted files to the socket voluntarily, but <code>dta-dataleak</code> can detect files leaked through an exploit in the same way. <a href="ch11.xhtml#ch11list15">Listing 11-15</a> shows the relevant code for the server.</p>&#13;
<p class="listing1" id="ch11list15"><em>Listing 11-15:</em> dataleak-test-xor.c</p>&#13;
<pre>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     size_t i, j, k;<br/>     FILE *fp[10];<br/>     char buf[4096], *filenames[10];<br/>     struct sockaddr_storage addr;<br/>   <br/>     srand(time(NULL));<br/>   <br/><span class="ent">➊</span>   int sockfd = open_socket("localhost", "9999");<br/>   <br/>     socklen_t addrlen = sizeof(addr);<br/><span class="ent">➋</span>   recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr*)&amp;addr, &amp;addrlen);<br/>   <br/><span class="ent">➌</span>   size_t fcount = split_filenames(buf, filenames, 10);<br/>   <br/><span epub:type="pagebreak" id="page_305"/><span class="ent">➍</span>   for(i = 0; i &lt; fcount; i++) {<br/>       fp[i] = fopen(filenames[i], "r");<br/>     }<br/>   <br/><span class="ent">➎</span>   i = rand() % fcount;<br/>     do { j = rand() % fcount; } while(j == i);<br/>   <br/>     memset(buf1, '\0', sizeof(buf1));<br/>     memset(buf2, '\0', sizeof(buf2));<br/>   <br/><span class="ent">➏</span>   while(fgets(buf1, sizeof(buf1), fp[i]) &amp;&amp; fgets(buf2, sizeof(buf2), fp[j])) {<br/>       /* sizeof(buf)-1 ensures that there will be a final NULL character<br/>        * regardless of the XOR-ed values */<br/>       for(k = 0; k &lt; sizeof(buf1)-1 &amp;&amp; k &lt; sizeof(buf2)-1; k++) {<br/><span class="ent">➐</span>       buf1[k] ˆ= buf2[k];<br/>       }<br/><span class="ent">➑</span>     sendto(sockfd, buf1, strlen(buf1)+1, 0, (struct sockaddr*)&amp;addr, addrlen);<br/>     }<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent">The server opens a socket on <code>localhost</code> port 9999 <span class="ent">➊</span> and uses it to receive a message <span class="ent">➋</span> containing a list of filenames. It splits this list into individual filenames using a function called <code>split_filenames</code>, which is omitted from the listing <span class="ent">➌</span>. Next, it opens all the requested files <span class="ent">➍</span> and then chooses two of the opened files at random <span class="ent">➎</span>. Note that in a realistic use case for <code>dta-dataleak</code>, the files would be accessed through an exploit rather than released voluntarily by the server. For the purposes of this example, the server reads the contents of the two randomly chosen files line by line <span class="ent">➏</span>, combining each pair of lines (one line from each file) using an XOR operation <span class="ent">➐</span>. Combining the lines will cause <code>dta-dataleak</code> to merge their taint colors, demonstrating taint merging for the purposes of this example. Finally, the result of the two XOR-ed lines is sent over the network <span class="ent">➑</span>, providing a “data leak” for <code>dta-dataleak</code> to detect.</p>&#13;
<p class="indent">Now, let’s see how <code>dta-dataleak</code> detects a data leak attempt and specifically how taint colors are merged when the leaked data depends on multiple files. <a href="ch11.xhtml#ch11list16">Listing 11-16</a> shows the output of running the <code>dataleak-test-xor</code> program while protected with <code>dta-dataleak</code>. I’ve abbreviated repetitive parts of the output with “<code>...</code>”.</p>&#13;
<p class="listing1" id="ch11list16"><em>Listing 11-16: Detecting a data exfiltration attempt with</em> <span class="codeitalic">dta-dataleak</span></p>&#13;
<pre>   $ <span class="codestrong1">cd ~/libdft/pin-2.13-61206-gcc.4.4.7-linux/</span><br/><span class="ent">➊</span> $<span class="codestrong1">./pin.sh -follow_execv -t ~/code/chapter11/dta-dataleak.so \</span><br/>             <span class="codestrong1">-- ~/code/chapter11/dataleak-test-xor &amp;</span><br/><br/><span epub:type="pagebreak" id="page_306"/><span class="ent">➋</span> (dta-dataleak) read: 512 bytes from fd 4<br/>   (dta-dataleak) clearing taint on bytes 0xff8b34d0 -- 0xff8b36d0<br/>   [1] 22713<br/><span class="ent">➌</span> $ <span class="codestrong1">nc -u 127.0.0.1 9999</span><br/><span class="ent">➍</span> /home/binary/code/chapter11/dta-execve.cpp .../dta-dataleak.cpp .../date.c .../echo.c<br/><span class="ent">➎</span> (dta-dataleak) opening /home/binary/code/chapter11/dta-execve.cpp at fd 5 with color 0x01<br/>   (dta-dataleak) opening /home/binary/code/chapter11/dta-dataleak.cpp at fd 6 with color 0x02<br/>   (dta-dataleak) opening /home/binary/code/chapter11/date.c at fd 7 with color 0x04<br/>   (dta-dataleak) opening /home/binary/code/chapter11/echo.c at fd 8 with color 0x08<br/><span class="ent">➏</span> (dta-dataleak) read: 155 bytes from fd 8<br/>   (dta-dataleak) tainting bytes 0x872a5c0 -- 0x872a65b with color 0x8<br/><span class="ent">➐</span> (dta-dataleak) read: 3923 bytes from fd 5<br/>   (dta-dataleak) tainting bytes 0x872b5c8 -- 0x872c51b with color 0x1<br/><span class="ent">➑</span> (dta-dataleak) send: 20 bytes to fd 4<br/>   \x0cCdclude &lt;stdio.h&gt;\x0a\x00<br/><span class="ent">➒</span> (dta-dataleak) checking taint on bytes 0xff8b19cc -- 0xff8b19e0...<br/><span class="ent">➓</span> (dta-dataleak) !!!!!!! ADDRESS 0xff8b19cc IS TAINTED (tag=0x09), ABORTING !!!!!!!<br/>     tainted by color = 0x01 (/home/binary/code/chapter11/dta-execve.cpp)<br/>     tainted by color = 0x08 (/home/binary/code/chapter11/echo.c)<br/>   [1]+ Exit 1 ./pin.sh -follow_execv -t ~/code/chapter11/dta-dataleak.so ...</pre>&#13;
<p class="indent">This example runs the <code>dataleak-test-xor</code> server with Pin, using <code>dta -dataleak</code> as the Pin tool to protect against data leaks <span class="ent">➊</span>. Immediately, there’s a first <code>read</code> syscall that’s related to the loading process of <code>dataleak-test-xor</code> <span class="ent">➋</span>. Because these bytes are read from a shared library, which doesn’t have an associated taint color, <code>dta-dataleak</code> ignores the read.</p>&#13;
<p class="indent">Next, the example starts a <code>netcat</code> session to connect to the server <span class="ent">➌</span> and send it a list of filenames to open <span class="ent">➍</span>. The <code>dta-dataleak</code> tool intercepts the <code>open</code> events for all those files and assigns each of them a taint color <span class="ent">➎</span>. Then, the server randomly chooses two files that it’s going to leak. In this case, these turn out to be the files with file descriptor 8 <span class="ent">➏</span> and 5 <span class="ent">➐</span>, respectively.</p>&#13;
<p class="indent">For both files, <code>dta-dataleak</code> intercepts the <code>read</code> events and taints the read bytes with the files’ associated taint color (<code>0x08</code> and <code>0x01</code>, respectively). Next, <code>dta-dataleak</code> intercepts the server’s attempt to send the file contents, which are now XOR-ed together, over the network <span class="ent">➑</span>.</p>&#13;
<p class="indent">It checks the taint on the bytes the server is about to send <span class="ent">➒</span>, notices that they’re tainted with the tag <code>0x09</code> <span class="ent">➓</span>, and therefore prints an alert and aborts the program. Tag <code>0x09</code> is the combination of the two taint colors <code>0x01</code> and <code>0x08</code>. From the alert, you can see that these colors correspond to the files <em>dta-execve.cpp</em> and <em>echo.c</em>, respectively.</p>&#13;
<p class="indent">As you can see, taint analysis makes it easy to spot information leaks and to know exactly which files are leaked. Also, you can use merged taint colors to tell which taint sources contributed to a byte’s value. Even with just eight taint colors, there are endless ways to build powerful DTA tools!</p>&#13;
<h3 class="h3" id="ch11_5">11.5 Summary</h3>&#13;
<p class="noindent">In this chapter, you learned about the internals of <code>libdft</code>, a popular open source DTA library. You also saw practical examples of using <code>libdft</code> to detect two types of common attacks: control hijacking and data exfiltration. You should now be ready to start building your own DTA tools!</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch11_6">Exercise</p>&#13;
<p class="boxhead1">1. Implementing a Format String Exploit Detector</p>&#13;
<p class="noindent">Use <code>libdft</code> to implement the format string exploit detection tool you designed in the previous chapter. Create an exploitable program and a format string exploit to test your detector. Also, create a program with an implicit flow that allows a format string exploit to succeed despite your detection tool.</p>&#13;
<p class="indent">Hint: You can’t directly hook <code>printf</code> with <code>libdft</code> because it’s not a syscall. Instead, you’ll have to find another way, such as with an instruction-level hook (<code>libdft</code>’s <code>ins_set_pre</code>) that checks for calls to the <code>printf</code> PLT stub. For the purposes of this exercise, you’re allowed to make simplifying assumptions, such as no indirect calls to <code>printf</code> and a fixed, hard-coded address for the PLT stub.</p>&#13;
<p class="indent">If you’re looking for a practical example of instruction-level hooking, check out the <em>libdft-dta.c</em> tool that ships with <code>libdft</code>!<span epub:type="pagebreak" id="page_308"/></p>&#13;
</div>&#13;
</div></body></html>