["```\n$ go get github.com/google/gopacket\n```", "```\n$ sudo apt-get install libpcap-dev\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    \"github.com/google/gopacket/pcap\"\n)\n\nfunc main() {\n ❶ devices, err := pcap.FindAllDevs()\n    if err != nil {\n        log.Panicln(err)\n    }\n ❷ for _, device := range devices {\n        fmt.Println(device.Name❸)\n     ❹ for _, address := range device.Addresses {\n         ❺ fmt.Printf(\"    IP:      %s\\n\", address.IP)\n            fmt.Printf(\"    Netmask: %s\\n\", address.Netmask)\n        }  \n    }\n}\n```", "```\n$ go run main.go\nenp0s5\n    IP:      10.0.1.20\n    Netmask: ffffff00\n    IP:      fe80::553a:14e7:92d2:114b\n    Netmask: ffffffffffffffff0000000000000000\nany\nlo\n    IP:      127.0.0.1\n    Netmask: ff000000\n    IP:      ::1\n    Netmask: ffffffffffffffffffffffffffffffff\n```", "```\n   package main\n\n   import (\n       \"fmt\"\n       \"log\"\n\n       \"github.com/google/gopacket\"\n       \"github.com/google/gopacket/pcap\"\n   )\n\n❶ var (\n       iface    = \"enp0s5\"\n       snaplen  = int32(1600)\n       promisc  = false\n       timeout  = pcap.BlockForever\n       filter   = \"tcp and port 80\"\n       devFound = false\n   )  \n\n   func main() {\n       devices, err := pcap.FindAllDevs()❷\n       if err != nil {\n           log.Panicln(err)\n       }\n\n    ❸ for _, device := range devices {\n           if device.Name == iface {\n               devFound = true\n           }\n       }\n       if !devFound {\n           log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n       }\n\n     ❹ handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n       if err != nil {\n           log.Panicln(err)\n       }\n       defer handle.Close()\n\n    ❺ if err := handle.SetBPFFilter(filter); err != nil {\n           log.Panicln(err)\n       }\n\n    ❻ source := gopacket.NewPacketSource(handle, handle.LinkType())\n       for packet := range source.Packets()❼ {\n           fmt.Println(packet)\n       }\n   }\n```", "```\n$ go build -o filter && sudo ./filter\nPACKET: 74 bytes, wire length 74 cap length 74 @ 2020-04-26 08:44:43.074187 -0500 CDT\n- Layer 1 (14 bytes) = Ethernet   {Contents=[..14..] Payload=[..60..]\nSrcMAC=00:1c:42:cf:57:11 DstMAC=90:72:40:04:33:c1 EthernetType=IPv4 Length=0}\n- Layer 2 (20 bytes) = IPv4       {Contents=[..20..] Payload=[..40..] Version=4 IHL=5\nTOS=0 Length=60 Id=998 Flags=DF FragOffset=0 TTL=64 Protocol=TCP Checksum=55712\nSrcIP=10.0.1.20 DstIP=54.164.27.126 Options=[] Padding=[]}\n- Layer 3 (40 bytes) = TCP        {Contents=[..40..] Payload=[] SrcPort=51064\nDstPort=80(http) Seq=3543761149 Ack=0 DataOffset=10 FIN=false SYN=true RST=false\nPSH=false ACK=false URG=false ECE=false CWR=false NS=false Window=29200\nChecksum=23908 Urgent=0 Options=[..5..] Padding=[]}\n\nPACKET: 74 bytes, wire length 74 cap length 74 @ 2020-04-26 08:44:43.086706 -0500 CDT\n- Layer 1 (14 bytes) = Ethernet   {Contents=[..14..] Payload=[..60..]\nSrcMAC=00:1c:42:cf:57:11 DstMAC=90:72:40:04:33:c1 EthernetType=IPv4 Length=0}\n- Layer 2 (20 bytes) = IPv4       {Contents=[..20..] Payload=[..40..] Version=4 IHL=5\nTOS=0 Length=60 Id=23414 Flags=DF FragOffset=0 TTL=64 Protocol=TCP Checksum=16919\nSrcIP=10.0.1.20 DstIP=204.79.197.203 Options=[] Padding=[]}\n- Layer 3 (40 bytes) = TCP        {Contents=[..40..] Payload=[] SrcPort=37314\nDstPort=80(http) Seq=2821118056 Ack=0 DataOffset=10 FIN=false SYN=true RST=false\nPSH=false ACK=false URG=false ECE=false CWR=false NS=false Window=29200\nChecksum=40285 Urgent=0 Options=[..5..] Padding=[]}\n```", "```\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/google/gopacket\"\n    \"github.com/google/gopacket/pcap\"\n)\n\nvar (\n    iface    = \"enp0s5\"\n    snaplen  = int32(1600)\n    promisc  = false\n    timeout  = pcap.BlockForever\n ❶ filter   = \"tcp and dst port 21\"\n    devFound = false\n)\n func main() {\n    devices, err := pcap.FindAllDevs()\n    if err != nil {\n        log.Panicln(err)\n    }\n\n    for _, device := range devices {\n        if device.Name == iface {\n            devFound = true\n        }\n    }\n    if !devFound {\n        log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n    }\n\n    handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n    if err != nil {\n        log.Panicln(err)\n    }\n    defer handle.Close()\n\n    if err := handle.SetBPFFilter(filter); err != nil {\n        log.Panicln(err)\n    }\n\n    source := gopacket.NewPacketSource(handle, handle.LinkType())\n    for packet := range source.Packets() {\n     ❷ appLayer := packet.ApplicationLayer()\n        if appLayer == nil {\n            continue\n        }  \n     ❸ payload := appLayer.Payload()\n     ❹ if bytes.Contains(payload, []byte(\"USER\")) {\n            fmt.Print(string(payload))\n        } else if bytes.Contains(payload, []byte(\"PASS\")) {\n            fmt.Print(string(payload))\n        }  \n    }\n}\n```", "```\n$ go build -o ftp && sudo ./ftp\nUSER someuser\nPASS passw0rd\n```", "```\ntcp[13] == 0x11 or tcp[13] == 0x10 or tcp[13] == 0x18\n```", "```\nvar ( ❶\n    snaplen  = int32(320)\n    promisc  = true\n    timeout  = pcap.BlockForever\n    filter   = \"tcp[13] == 0x11 or tcp[13] == 0x10 or tcp[13] == 0x18\"\n    devFound = false\n    results  = make(map[string]int)\n)\n\nfunc capture(iface, target string) { ❷\n    handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n    if err != nil {\n        log.Panicln(err)\n    }\n\n    defer handle.Close()\n\n    if err := handle.SetBPFFilter(filter); err != nil {\n        log.Panicln(err)\n    }  \n\n    source := gopacket.NewPacketSource(handle, handle.LinkType())\n    fmt.Println(\"Capturing packets\")\n    for packet := range source.Packets() {\n        networkLayer := packet.NetworkLayer() ❸\n        if networkLayer == nil {\n            continue\n        }\n        transportLayer := packet.TransportLayer()\n        if transportLayer == nil {\n            continue\n        }\n\n        srcHost := networkLayer.NetworkFlow().Src().String() ❹\n        srcPort := transportLayer.TransportFlow().Src().String()\n\n        if srcHost != target { ❺\n            continue\n        }\n        results[srcPort] += 1 ❻\n    }  \n}\n\nfunc main() {\n\n    if len(os.Args) != 4 {\n        log.Fatalln(\"Usage: main.go <capture_iface> <target_ip> <port1,port2,port3>\")\n    }  \n\n    devices, err := pcap.FindAllDevs()\n    if err != nil {\n        log.Panicln(err)\n    }  \n\n    iface := os.Args[1]\n    for _, device := range devices {\n        if device.Name == iface {\n            devFound = true\n        }\n    }  \n    if !devFound {\n        log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n    }  \n\n    ip := os.Args[2]\n    go capture(iface, ip) ❼\n    time.Sleep(1 * time.Second)\n\n    ports, err := explode(os.Args[3])\n    if err != nil {\n        log.Panicln(err)\n    }  \n\n    for _, port := range ports { ❽\n        target := fmt.Sprintf(\"%s:%s\", ip, port)\n        fmt.Println(\"Trying\", target)\n        c, err := net.DialTimeout(\"tcp\", target, 1000*time.Millisecond) ❾\n        if err != nil {\n            continue\n        }\n        c.Close()\n    }\n    time.Sleep(2 * time.Second)\n\n    for port, confidence := range results { ❿\n        if confidence >= 1 {\n            fmt.Printf(\"Port %s open (confidence: %d)\\n\", port, confidence)\n        }\n    }\n}\n\n/* Extraneous code omitted for brevity */\n```", "```\n$ go build -o syn-flood && sudo ./syn-flood enp0s5 10.1.100.100\n80,443,8123,65530\nCapturing packets\nTrying 10.1.100.100:80\nTrying 10.1.100.100:443\nTrying 10.1.100.100:8123\nTrying 10.1.100.100:65530\nPort 80 open (confidence: 1)\nPort 443 open (confidence: 1)\n```"]