["```\npermutation_sort <items> <limit> [<kind> | <kind> <seed>]\n\n  <items> - number of items in the list\n  <limit> - number of passes maximum (0=Las Vegas else Monte Carlo)\n  <kind>  - randomness source\n  <seed>  - seed value\n```", "```\n> python3 permutation_sort.py 6 0 minstd 42\nsorted: 0  25  44  57  65  96  (268 iterations)\n```", "```\n> python3 permutation_sort.py 6 100 minstd 42\npartially: 0  57  25  44  65  96  (score = 0.16667, 100 iterations)\n```", "```\n> python3 permutation_sort.py 6 268 minstd 42\nsorted: 0  25  44  57  65  96  (268 iterations)\n```", "```\nv = np.array([int(rng.random()*100) for i in range(N)], dtype=\"uint8\")\nk = 0\nscore = Score(v)\nwhile (score != 0) and (k < limit):\n    k += 1\n    i = np.argsort(rng.random(len(v)))\n    s = Score(v[i])\n    if (s < score):\n        score = s\n        v = v[i]\n```", "```\ndef Score(arg):\n    n = 0\n    for i in range(len(arg)-1):\n        if (arg[i] > arg[i+1]):\n            n += 1\n    return n / len(arg)\n```", "```\n 2:  0.127855 +/- 0.002026\n 3:  0.128128 +/- 0.001737\n 4:  0.129859 +/- 0.002469\n 5:  0.131369 +/- 0.002483\n 6:  0.136637 +/- 0.003704\n 7:  0.172775 +/- 0.008236\n 8:  0.534369 +/- 0.081601\n 9:  1.987567 +/- 0.488691\n10: 44.133984 +/- 10.929158\n```", "```\n>>> A = np.array([[1,2],[3,4]])\n>>> B = np.array([[1,0],[2,3]])\n>>> A*B\narray([[ 1,  0],\n       [ 6, 12]])\n```", "```\ndef mmult(A,B):\n    n,m = A.shape\n    p = B.shape[1]\n    C = np.zeros((n,p), dtype=A.dtype)\n    for i in range(n):\n        for j in range(p):\n            for k in range(m):\n                C[i,j] += A[i,k]*B[k,j]\n    return C\n```", "```\nfreivalds <N> <mode> <reps> [<kind> | <kind> <seed>]\n\n  <N>     - matrix size (always square)\n  <mode>  - 0=Freivalds', 1=naive\n  <reps>  - reps of Freivalds' (ignored for others)\n  <kind>  - randomness source\n  <seed>  - seed\n```", "```\n> python3 freivalds.py 3 0 1 mt19937 19937\n0.08598161 0.132\n```", "```\n> python3 freivalds.py 3 1 1 mt19937 19937\n0.05456829 0.000\n```", "```\n> python3 freivalds.py 3 0 2 mt19937 19937\n0.14664984 0.016\n```", "```\n> python3 freivalds.py 3 0 4 mt19937 19937\n0.26030445 0.000\n```", "```\ndef array_equal(a,b, eps=1e-7):\n    return np.abs(a-b).max() <= eps\n\nk = 0\nm = 1000\ns = time.time()\nfor i in range(m):\n    A = 100*rng.random(N*N).reshape((N,N))\n    B = 100*rng.random(N*N).reshape((N,N))\n    C = A@B + 0.1*rng.random(N*N).reshape((N,N))\n    if (mode == 0):\n        t = True\n        for j in range(reps):\n            r = (2*rng.random(N)).astype(\"uint8\").reshape((N,1))\n            t &= array_equal(mmult(A,mmult(B,r)), mmult(C,r))\n    else:\n        t = array_equal(mmult(A,B), C)\n    k += 1 if t else 0\nprint(\"%0.8f %0.3f\" % (time.time()-s, k/m))\n```", "```\n> python3 mark_recapture.py\nmark_recapture <pop> <mark> <reps> [<kind> | <kind> <seed>]\n  <pop>  - population size (e.g. 1000)\n  <mark> - number to mark (< pop)\n  <reps> - number of repetitions \n  <kind> - randomness source\n  <seed> - seed\n```", "```\n> python3 mark_recapture.py 1000 100 1 mt19937 11\nLincoln-Petersen population estimate = 1250\nChapman population estimate          = 1132\nBayesian population estimate         = 1633\n\n> python3 mark_recapture.py 1000 100 1 mt19937 12\nLincoln-Petersen population estimate = 666\nChapman population estimate          = 636\nBayesian population estimate         = 753\n\n> python3 mark_recapture.py 1000 100 1 mt19937 13\nLincoln-Petersen population estimate = 833\nChapman population estimate          = 783\nBayesian population estimate         = 980\n```", "```\n> python3 mark_recapture.py 1000 100 25 mt19937 11\nLincoln-Petersen population estimate = 1028.4713 +/-  78.4623\nChapman population estimate          =  940.0367 +/-  61.6982\nBayesian population estimate         = 1345.2015 +/- 166.3078\n\n> python3 mark_recapture.py 1000 100 25 mt19937 12\nLincoln-Petersen population estimate = 1052.0985 +/-  61.3198\nChapman population estimate          =  963.4317 +/-  49.9620\nBayesian population estimate         = 1345.9986 +/- 108.4192\n\n> python3 mark_recapture.py 1000 100 25 mt19937 13\nLincoln-Petersen population estimate = 1112.8340 +/-  80.5759\nChapman population estimate          = 1009.5146 +/-  63.3742\nBayesian population estimate         = 1485.2546 +/- 169.0492\n```", "```\nlincoln = []\nchapman = []\nbayes = []\n\nfor j in range(nreps):\n    pop = np.zeros(npop, dtype=\"uint8\")\n    idx = np.argsort(rng.random(npop))[:nmark]\n    pop[idx] = 1\n\n    K = nmark\n    while (True):\n        idx = np.argsort(rng.random(npop))[:K]\n        k = pop[idx].sum()\n        if (k > 2):\n            break\n        K += 5\n\n    lincoln.append(nmark*K/k)\n    chapman.append((nmark+1)*(K+1)/(k+1) - 1)\n    bayes.append((nmark-1)*(K-1)/(k-2))\n```", "```\ndef MillerRabin(n, rounds=5):\n    if (n==2):\n        return True\n    if (n%2 == 0):\n        return False\n\n    s = 0\n    d = n-1\n    while (d%2 == 0):\n        s += 1\n        d //= 2\n\n    for k in range(rounds):\n        a = int(rng.random()) # [1,n-1]\n        x = pow(a,d,n)\n        if (x==1) or (x == n-1):\n            continue\n        b = False\n        for j in range(s-1):\n            x = pow(x,2,n)\n            if (x == n-1):\n                b = True\n                break\n        if (b):\n            continue\n        return False\n    return True\n```", "```\n> python3 miller_rabin.py\nmiller_rabin <n> <rounds> [<kind> | <kind> <seed>]\n  <n>      - number to test\n  <rounds> - number of rounds\n  <kind>   - randomness source\n  <seed>   - seed\n```", "```\n> python3 miller_rabin.py 73939133 1\n73939133 is probably prime\n> python3 miller_rabin.py 73939134 1\n73939134 is composite\n```", "```\n> python3 miller_rabin.py 8675309 1\n8675309 is probably prime\n> python3 miller_rabin.py 8675311 1\n8675311 is probably prime\n```", "```\ndef QuicksortRandom(arr):\n    if (len(arr) < 2):\n        return arr\n    pivot = arr[np.random.randint(0, len(arr))]\n    low  = arr[np.where(arr < pivot)]\n    same = arr[np.where(arr == pivot)]\n    high = arr[np.where(arr > pivot)]\n    return np.hstack((QuicksortRandom(low), same, QuicksortRandom(high)))\n\ndef Quicksort (arr):\n    if (len(arr) < 2):\n        return arr\n    pivot = arr[0]\n    low  = arr[np.where(arr < pivot)]\n    same = arr[np.where(arr == pivot)]\n    high = arr[np.where(arr > pivot)]\n    return np.hstack((Quicksort(low), same, Quicksort(high)))\n```", "```\n    > python3 count.py 1_000_000_000 40 pcg64 6502\n    N = 1023827699, iterations 41414, total 1656576\n    ```"]