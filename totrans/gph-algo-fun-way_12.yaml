- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TOPOLOGICAL
    SORT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to their physical corollaries, such as one-way streets, we can use
    directed edges in a graph to specify a *dependency* or *ordering* between nodes.
    Incoming edges to a node represent links from actions that must be completed before
    reaching the current node. Meanwhile, outgoing edges point to actions enabled
    by the completion of the current node.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example of a recipe for chocolate chip cookies. Each node represents
    a step in the recipe, including instructions such as “Add the flour” and “Stir
    the mixture.” Some of the steps have a clear and non-negotiable ordering. We wouldn’t
    want to stir the mixture before adding anything to the bowl or add ingredients
    before we measure them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces algorithms for *topological sort*, which orders a graph’s
    nodes in the order specified by directed edges. After discussing the concepts
    behind topological ordering and presenting several real-world use cases and algorithms
    for sorting, we’ll explore the importance of graphs without loops for topological
    sort and consider why instruction manuals are not drawn as graphs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Topological Sort Algorithms Work</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A topological sort algorithm finds an ordering of nodes such that if there exists
    a directed edge from node *u* to node *v*, then node *u* must precede node *v*
    in the ordering. In other words, each directed edge represents a *dependency*.
    Some graphs have multiple valid orderings. For example, [Figure 9-1](#fig9-1)
    shows a graph with valid topological orderings [0, 1, 2, 4, 3] and [0, 2, 1, 4,
    3].
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and directed edges (0, 1), (0, 2), (1, 3), (1, 4),
    (2, 4), and (4, 3).](../images/f09001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: A directed graph
    with two valid topological orderings</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A key constraint for topological sort is that the graph must be *acyclic*, meaning
    it does not contain any *cycles*. A directed graph has a cycle if it is possible
    to define a path from a node such that the path returns to that same node, as
    shown in [Figure 9-2](#fig9-2) (a slight modification of the graph in [Figure
    9-1](#fig9-1)). Starting from node 1, we can travel back to node 1 through nodes
    4 and 3 via the path [1, 4, 3, 1].
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with five nodes and directed edges (0, 1), (0, 2), (1, 4), (2, 4),
    (3, 1), and (4, 3).](../images/f09002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: A directed graph
    with a cycle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A graph with cycles will not have a valid topological ordering because it contains
    at least one node with a path that leads back to itself. That means this node
    must precede itself in the sorted list, which is obviously impossible. No matter
    how we order nodes 1, 3, and 4 in [Figure 9-2](#fig9-2), we’ll always have an
    edge pointing from a later to an earlier node. We call a directed graph with no
    cycles a *directed acyclic graph* or *DAG*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test whether a topological ordering is valid by checking the relative
    ordering of each pair of nodes with a directed edge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by checking that the ordering contains the same number of nodes
    as the graph ❶. If not, the ordering cannot be valid, and the function returns
    <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Next, a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop builds an inverted index mapping each node to its location in the sorted
    array ❷. This will allow it to easily look up the relative ordering of any two
    nodes given their indices. During this loop, the code also checks for duplicate
    nodes in the ordering by testing if <samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>
    is already set. If it finds a node listed twice, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    to indicate an invalid ordering.
  prefs: []
  type: TYPE_NORMAL
- en: The code then iterates through each node and each of its outgoing edges using
    a nested pair of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops
    ❸. For each of these directed edges, the code checks that the nodes are ordered
    correctly by comparing their positions in <samp class="SANS_TheSansMonoCd_W5Regular_11">ordering</samp>
    (using <samp class="SANS_TheSansMonoCd_W5Regular_11">index_to_pos</samp>). The
    function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> as
    soon as it finds a single pairing out of order. Finally, if the code has made
    it through this gauntlet of checks, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Topological sort has a variety of real-world use cases. This section describes
    how to represent several of these cases as graphs to which we could apply the
    topological sort.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Code Dependencies</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Programmers often break large programs into a series of modules or libraries
    to facilitate understandability, maintainability, and extensibility. Instead of
    a single file with a million lines of code, a programmer might create three modules:
    one for representing and processing graphs, another for handling the user interface,
    and a third for reading and writing files. Ideally, they would design the modules
    to build off one other, allowing them to reuse core library functions throughout
    the code. For example, the graph library and user interface code might rely on
    the file module to read and write configuration files.'
  prefs: []
  type: TYPE_NORMAL
- en: Such code dependencies mean that the code is processed in a particular order.
    We can represent these dependencies as a directed graph where each module is a
    node in the graph and each <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">include</samp> statement represents
    an incoming edge to that node. The topological sort of this graph tells the computer
    the order in which it needs to process the files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Task Lists</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can extend the importance of following a recipe in a particular order to
    a wide range of tasks, from writing to cleaning to assembling furniture. In each
    of these cases, nodes represent steps on our task list and edges represent dependencies
    between them. For example, we need to get out the mop and bucket before we can
    wash the floor. As another example, [Figure 9-3](#fig9-3) shows a graph representing
    the steps for making a peanut-butter-and-jelly sandwich.
  prefs: []
  type: TYPE_NORMAL
- en: '![Seven boxes represent steps of making a sandwich. On the left are boxes for
    “Get two pieces of bread,” “Get jar of peanut butter,” and “Get jar of jelly or
    jam.” The box for “Get two pieces of bread” has an arrow to the box for “Place
    bread on plate.” The box for “Spread peanut butter onto one piece of bread” has
    arrows from the boxes “Place bread on plate” and “Get jar of peanut butter.” The
    box for “Spread jelly onto the other piece of bread” has arrows from the boxes
    “Spread peanut butter onto one piece of bread” and “Get jar of jelly or jam.”
    The box for “Place the bread with the peanut butter on top of the bread with jelly
    to make a sandwich” has an arrow from the box “Spread jelly onto the other piece
    of bread.”](../images/f09003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The task graph
    for making a peanut-butter-and-jelly sandwich</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although most instruction manuals are written as a linear series of instructions,
    there is often some flexibility in the order, meaning the graph is not necessarily
    a straight line of nodes. For example, consider the process of assembling a prefabricated
    chair. It might not matter whether you attach the left or right arm first. However,
    it could be vital that you finish the body of the chair before attaching the seat
    cushion.
  prefs: []
  type: TYPE_NORMAL
- en: Representing instructions as a graph clearly offers opportunities for parallelism.
    Two people working on a single recipe could theoretically complete it more quickly
    than one alone; one baker can measure out the flour while another measures out
    the sugar, and so on. Unfortunately, this parallel representation would likely
    cause more rather than fewer problems. I personally struggle to remember which
    step I’m on when using linear instructions, spending minutes trying to remember
    whether I’ve added the salt to the bowl. Tracking which steps have been completed
    through a branching graph of tasks is almost guaranteed to result in me missing
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, while humans struggle to track this type of state, computers excel
    at it, using graph structures to find opportunities for parallelism. In fact,
    there are entire systems that structure workflows as graphs. Distributed workflow
    systems are often built around the concept of task graphs, where multiple tasks
    are executed in an order determined by their dependency. The design and optimization
    of such workflows is an active area of development, and the topic could fill its
    own book.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Teaching and
    Learning</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Many academic subjects consist of a large set of interrelated concepts, some
    of which must be understood before moving on to the next. A math teacher would
    find it difficult to explain the concept of exponents before their students have
    learned how to multiply. Other concepts can be covered in parallel, however. When
    learning a foreign language, the student might be able to learn vocabulary related
    to coffee shops regardless of whether they know computer science terminology.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify the recommended order for teaching or learning concepts as a
    graph. Nodes represent concepts, such as the French word for coffee or the idea
    of recursion, while edges represent dependencies between the concepts. In the
    case of computer science, we might put an edge from the concept of functions to
    that of recursion to indicate that a student should learn about functions before
    venturing into the world of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on this graph representation, we can use topological sort to determine
    which courses in a college curriculum we need to take first. Consider the graph
    in [Figure 9-4](#fig9-4) built from hypothetical course prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: '![Seven boxes represent different computer science classes. The box for CS300:
    Advanced Algorithms lists prerequisites CS200 and CS201 and has incoming arrows
    from both of those boxes.](../images/f09004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: A graph representing
    the prerequisites of computer science courses</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'To take CS450: Advanced AI, a student would need to complete the chain of prerequisites
    for this course, all the way back to CS100: Introduction to Programming.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Kahn’s Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computer scientist Arthur B. Kahn developed one approach, now called *Kahn’s
    algorithm*, for performing topological sort on a directed acyclic graph. This
    algorithm operates by finding nodes with no incoming edges, removing them from
    the list of pending nodes, adding them to a sorted list, and then removing the
    outbound edges from that node. The algorithm repeats until it has added every
    node to the sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, the Kahn’s algorithm sort mirrors how we might perform a complex
    task in the real world. We perform a subtask that we can accomplish without completing
    any other steps first, then move on to another subtask. Any action that requires
    us to have performed an as-yet-uncompleted task must wait until we have finished
    all its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When implementing Kahn’s algorithm, we don’t need to modify the graph we’re
    working with by removing nodes or edges. Instead, we can use an additional array
    <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> to track the number
    of incoming edges to each node and decrease those counts whenever we “remove”
    a node. Since we don’t have to modify the graph data structure, we can avoid making
    an initial copy, re-adding the removed edges, or leaving the structure altered.
  prefs: []
  type: TYPE_NORMAL
- en: The code for Kahn’s algorithm uses a stack and multiple loops, as shown in [Listing
    9-1](#list9-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: Kahn’s algorithm
    for topological sorting</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by creating the helper data structures used by the algorithm.
    The array <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> stores the
    count of *incoming* nodes for each edge and will be used to check for nodes without
    any incoming edges. The stack <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    (implemented as a list) stores the indices of unprocessed nodes without incoming
    edges. These will be the nodes that the code can remove from the graph. Finally,
    the list <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> will hold
    the topologically sorted list of node indices.
  prefs: []
  type: TYPE_NORMAL
- en: The code uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loops to count the number of incoming edges for each node ❶. In the first loop,
    since the algorithm is working on a directed graph, the code must iterate over
    all nodes (outer loop) and their outgoing edges (inner loop) and increment the
    count of incoming edges for the edge’s destination (<samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>).
    The next <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates
    over the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> array, finds
    nodes that have no incoming edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">count[current.index]</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>),
    and inserts their index into the stack <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>.
    The function has now set up all the initial information it needs to perform the
    topological sort.
  prefs: []
  type: TYPE_NORMAL
- en: The main body of the code is a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that processes each item in the stack ❷. At each iteration, the code pops
    a node index from <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>. It retrieves
    the corresponding node and adds this index to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    array. The function then virtually removes the node and its outgoing edges by
    iterating over each outgoing edge and decreasing the count of edges going to the
    destination ❸. In the process, it checks whether any node falls to zero incoming
    edges and, if so, adds that node’s index to the stack. The code completes by returning
    the array of sorted node indices with <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    result</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration focuses on a single node and its outgoing edges, meaning the
    running time of the algorithm scales linearly with the number of nodes plus the
    number of outgoing edges.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9-5](#fig9-5) shows how to run Kahn’s algorithm on an example graph,
    where each subfigure represents a step in the algorithm’s progression. The figure
    displays the count of the incoming edges (the values in <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>)
    above each node and grays out removed nodes and edges.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm initializes the counts of incoming edges based on the input graph
    and stores the two nodes without any incoming edges (nodes 0 and 1) in the stack,
    as shown in [Figure 9-5(a)](#fig9-5). During the first step of the sort in [Figure
    9-5(b)](#fig9-5), the algorithm takes the top element (node 1) off the next stack
    and “removes” it and its outgoing edges from the graph, resulting in decreased
    counts for nodes 3 and 4\. Since neither destination node’s count decreases to
    zero, the code adds neither to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 9-5(c)](#fig9-5), the sort continues by popping node 0 from the stack
    and removing its edges to nodes 2 and 3\. This reduces the count in incoming edges
    to both nodes 2 and 3 down to zero, allowing the sort to add them to the stack.
    The process continues, node by node, until every node in the stack has been exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: '![The seven steps of Kahn’s algorithm. (A) shows a directed graph with edges
    (0, 2), (0, 3), (1, 3), (1, 4), (2, 4), (3, 4), and (4, 5). In (B), node 1 is
    grayed out along with its edges to nodes 3 and 4\. The count to above node 3 is
    1.](../images/f09005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: Running Kahn’s
    algorithm on an example graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can picture Kahn’s algorithm in the context of a careful baker following
    a complex recipe. Before they start, the baker writes down all the tasks and which
    ones are the necessary prerequisites. Task 5a, “Add two cups of flour,” must come
    after Task 4, “Mix the wet ingredients in a large bowl,” and Task 1a, “Measure
    two cups of flour.” However, the baker can complete Task 5a either before or after
    Task 5b, “Add a tablespoon of baking soda,” because the order in which the flour
    and baking soda are added does not matter. The baker counts the number of prerequisites
    for each task and writes those numbers next to their respective tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The baker begins by choosing one task with no outstanding prerequisites, performing
    that task, and checking it off the list. They then go through the list of tasks
    and update the count of unsatisfied prerequisites for all future tasks that depended
    on the one they just completed. After measuring out two cups of flour, for example,
    they can update the dependency count of Task 5a, “Add two cups of flour,” from
    2 to 1—they’ve measured the flour but still need to mix the wet ingredients before
    proceeding. Once they’ve completed Task 4, “Mix the wet ingredients in a large
    bowl,” they can put Task 5a on their list of next steps.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond Kahn’s algorithm, an alternative approach to sorting the nodes in a directed
    acyclic graph is to use the trusty multipurpose tool of depth-first search. Depth-first
    search starts at a given node *u*, then explores the nodes after *u* in topological
    order. We can modify depth-first search to track the order in which we complete
    processing of each node. By saving the order in which the search finishes exploring
    each node, depth-first search can reconstruct the *inverse* ordering of nodes.
    The last nodes in topological ordering will be the first to finish in a depth-first
    search and thus will appear at the start of the list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The code for topological sort based on depth-first search largely mirrors the
    other depth-first search implementations that we have used throughout the book,
    as shown in [Listing 9-2](#list9-2). However, we maintain one additional piece
    of information: a list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    to track the order in which the search completes its visits to each node.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: The depth-first
    search algorithm for topological sorting</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 9-2](#list9-2) consists of two functions. The outer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">topological _dfs()</samp> function sets
    up the data structures, calls depth-first search on different starting nodes,
    and processes the results. It starts by creating an empty list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    and a list <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> with all
    entries set to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. The
    function then loops through each node. If it finds a node that has not yet been
    visited, the function starts a depth-first search from that node ❶. Finally, the
    function takes the list of node indices and outputs them to the result list in
    reverse order ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs_recursive()</samp>
    function that follows is a recursive implementation of depth-first search with
    one modification: it appends each completed node onto a list. This function starts
    by marking the current node as seen, then iterates through the neighbors via the
    list of edges and recursively explores any unseen neighbors. Finally, it inserts
    the current node index at the end of the list <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp>
    to track the order in which it finished visiting the nodes ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9-6](#fig9-6) shows an example topological sort by depth-first search,
    where the current node being visited is circled by a dashed line and the seen
    nodes are shaded.'
  prefs: []
  type: TYPE_NORMAL
- en: The search begins in [Figure 9-6(a)](#fig9-6) on node 0 and explores down the
    path of node 2 in [Figure 9-6(b)](#fig9-6), node 4 in [Figure 9-6(c)](#fig9-6),
    and node 5 in [Figure 9-6(d)](#fig9-6). At each node, the algorithm marks the
    node as seen and recursively explores its unseen neighbors. It isn’t until the
    search finishes processing a node and backtracks to its predecessor that it inserts
    the node into the sorted list, as shown in [Figure 9-6(d)](#fig9-6), where the
    search hits a dead end at node 5 and is forced to backtrack. Inserting a node
    into the inversely sorted list means that node must come after all nodes that
    preceded it in the search.
  prefs: []
  type: TYPE_NORMAL
- en: '![Twelve steps of the depth-first search algorithm on a graph with directed
    edges (0, 2), (0, 3), (1, 3), (1, 4), (2, 4), (3, 4), and (4, 5). In (D), nodes
    0, 2, 4, and 5 are grayed out with node 5 circled. In (E), node 4 is circled and
    the list s now includes 5.](../images/f09006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: Running a depth-first
    search for topological sort on an example graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As the search backtracks through node 4 in [Figure 9-6(e)](#fig9-6) and node
    2 in [Figure 9-6(f)](#fig9-6), it checks for other outgoing edges. Finding none,
    it adds the current node to the list and backtracks. When it returns to node 0
    in [Figure 9-6(g)](#fig9-6), the depth-first search can continue before backtracking
    once more. It recursively explores node 3 in [Figure 9-6(h)](#fig9-6).
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 9-6(j)](#fig9-6), we might not be done after our initial
    depth-first search completes. Node 1 did not lie on any paths out of node 0 and
    thus has not been explored. The search continues by checking whether all the nodes
    have been seen and, if not, starting a depth-first search from that unseen node.
    At the end of the algorithm, the search has visited all nodes and assembled a
    list of nodes in inverse topological order, as shown in [Figure 9-6(l)](#fig9-6).
  prefs: []
  type: TYPE_NORMAL
- en: We can picture this search in the context of a college student planning out
    a series of courses to take. They list the courses they want to take as nodes
    in a graph and use directed edges to represent the prerequisites. The depth-first
    search starts at a node with the question, “What courses will this course allow
    me to take?” When the search reaches a dead end, the student knows they have found
    a course that is not a prerequisite for anything else in their curriculum
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the course list in [Figure 9-4](#fig9-4), consider what happens
    when the student starts with CS200 and follows the path through CS350 to CS450\.
    CS450 is fully explored, so they turn to their list of unexplored courses. The
    student returns to CS350, which is not a prerequisite for any other classes, and
    adds it to the list. Ultimately, they build up the list [CS450, CS350, CS300,
    CS201, CS200]. They continue to the next unvisited course (perhaps CS100 in this
    case) and continue building out their study plan.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Order of Starting
    Nodes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One counterintuitive aspect of the depth-first search approach to topological
    sort is that the <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp>
    base function in [Listing 9-2](#list9-2) starts the recursive searches on each
    node according to that node’s index in the graph. It does not bother to sort the
    nodes according to number of incoming edges or any other aspect of its location.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to cases where the search might begin at a node that has incoming
    edges, as with the graph in [Figure 9-7](#fig9-7). After all, we naturally think
    of depth-first search as starting at the beginning of a chain of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with four nodes and three edges: (1, 0), (0,2), and (3, 2)](../images/f09007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: A graph where node
    0 has an incoming connection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, depth-first search works perfectly well in situations where node
    0 is not the start of the topological ordering. In [Figure 9-7](#fig9-7), the
    depth-first search algorithm will start at node 0 and find nodes 0 and 2 in the
    initial recursive depth-first search. At the end of the first recursive depth-first
    search, the list containing the reversed ordering is <samp class="SANS_TheSansMonoCd_W5Regular_11">[2,
    0]</samp>. While it may seem like we are making an error in skipping node 1, we
    will add it to the correct location during the next search.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm next starts a search at node 1 and adds that to the end of the
    list. Since the list is in *reverse* topological ordering, node 1 is in the correct
    location *after* node 0\. After the search starts at node 1, the list is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1]</samp>. After starting at node
    3, the list becomes <samp class="SANS_TheSansMonoCd_W5Regular_11">[2, 0, 1, 3]</samp>.
    When the function concludes, it reverses the list using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">reverse()</samp>
    function and returns the correct ordering <samp class="SANS_TheSansMonoCd_W5Regular_11">[3,
    1, 0, 2]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Detecting Cycles</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As noted earlier, a key constraint of topological sort is that the graph must
    be acyclic. Consider the hypothetical course sequence shown in [Figure 9-8](#fig9-8).
    All students must begin by taking CS100: Introduction to Programming, which has
    no prerequisites. However, things get more complex in the next semester. In an
    attempt to cover more material, the instructor of CS200: Introduction to Algorithms
    wants their students to know both programming and the basics of graphs. They require
    both CS100 and CS202: Introduction to Graphs as prerequisites. At the same time,
    the instructor for CS202 wants their students to know data structures, so they
    require CS201: Introduction to Data Structures as a prerequisite. Unfortunately,
    the instructor for CS201 wants their students to already know basic algorithms,
    so they require CS200 as a prerequisite.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Five boxes represent different computer science classes. The box for “CS200:
    Introduction to algorithms” lists prerequisites CS100 and CS202 and has incoming
    arrows from both of those boxes.](../images/f09008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-8: A set of course
    prerequisites with a cycle</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When a student completes CS100, they look at the courses they can now take and
    run into a problem. Each of the 200 level courses requires a different 200 level
    course as a prerequisite. There are no 200 level courses the student can take
    without missing a prerequisite.
  prefs: []
  type: TYPE_NORMAL
- en: We can adapt the algorithms presented in this chapter to detect whether a graph
    has cycles, providing a useful tool for vetting school requirements, instruction
    manuals, recipes, or any other graph representation of a sequence of events. One
    easy approach to doing this is to look at what happens when we run Kahn’s algorithm
    from [Listing 9-1](#list9-1) on a graph with cycles. This algorithm relies on
    incoming connections dropping to zero when it has removed all the preceding nodes.
    To remove a node that is part of a cycle, the algorithm would first need to remove
    its predecessors, including the node itself. Thus, the count for a node in a cycle
    will never drop to zero, and the node will never be added to the sorted list.
    We therefore know that if the algorithm’s returned list does not contain all the
    nodes from the graph, at least one node must be part of a cycle and thus be unremovable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wrap Kahn’s algorithm in a function called <samp class="SANS_TheSansMonoCd_W5Regular_11">check_cycle_kahns()</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code for this check requires one additional <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement to test the length of the returned list. If the list is the same size
    as the graph, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>
    to indicate no cycles. Otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reordering Lists</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s consider a task that uses *topological sort*: reordering a list of items
    with forward dependencies. As an example, we’ll use topological sort to carry
    out the practical task of sorting the pages of a choose-your-own-adventure book
    so that you never need to flip backward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 9-9](#fig9-9), we can visualize a choose-your-own-adventure
    book with *N* pages as a graph with *N* nodes. Because the reader must turn most
    pages consecutively to follow individual storylines, the corresponding nodes for
    most pages have one incoming edge from the previous page and one outgoing edge
    to the next page. However, what makes these books exciting are the decision points.
    [Figure 9-9](#fig9-9) shows transitions around page *k*. The reader has two options:
    they can either turn to page *i* to explore the haunted house or turn to page
    *j* to climb the rain-soaked cliffs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A linear graph. Node k has an incoming edge from node K-1 and outgoing edges
    to nodes i and j.](../images/f09009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-9: A graph representing
    a choose-your-own-adventure book in page order</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Topological sort allows us to rearrange the pages into story order, as shown
    in [Figure 9-10](#fig9-10). The story starts on page 1\. The narrative paths progress
    from left to right. They branch off at decision points, with some decisions leading
    to an unfortunate early end (represented by shaded nodes).
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with all edges moving to the node on the right, with decision points
    branching to higher or lower lines of nodes.](../images/f09010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-10: Reorganizing the
    book into story order</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the two algorithms in this chapter to do the sorting for us. As input,
    we take a list of lists that maps each page to its corresponding options. The
    list <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [3, 4], [-1], [-1], [2]]</samp>
    represents a five-page story with the index in the list corresponding to the current
    page. Page 0 leads deterministically to page 1\. Page 1 has an option to proceed
    to page 3 or 4\. Both pages 2 and 3 represent the end of the story (as represented
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>). Finally, page 4 leads
    deterministically back to page 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-3](#list9-3) shows the code to sort the story by transforming the
    list into a graph and, for the purposes of this example, calling Kahn’s algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Sorting forward
    pointers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code creates a graph with one node for each page. It then uses one <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to iterate through each
    page and a second <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    to iterate through the outgoing options for that page. It checks whether the page
    represents a terminal state (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_index</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>);
    if not, the code adds an edge to the following page in story order. Finally, the
    code calls Kahn’s algorithm to perform the topological sort and returns the result
    ❶. (Alternatively, the code could use <samp class="SANS_TheSansMonoCd_W5Regular_11">topological_dfs()</samp>
    from [Listing 9-2](#list9-2).)
  prefs: []
  type: TYPE_NORMAL
- en: As an example implementation of this code, let’s apply it to the 10-page adventure
    shown in [Figure 9-11](#fig9-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with 10 nodes and edges (0,1), (1, 2), (2, 4), (2, 6), (6, 7), (4,
    5), (5, 3), (5, 8), (8, 9). Nodes 3, 7, and 9 are shaded.](../images/f09011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-11: A story graph
    with 10 pages</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We represent the options as a list of lists, with option <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    indicating the end of a narrative line, whether it’s a positive or negative conclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[[1], [2], [4, 6], [-1], [5],
    [3, 8], [7], [-1], [9], [-1]]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the input through the <samp class="SANS_TheSansMonoCd_W5Regular_11">sort_forward_pointers()</samp>
    function from [Listing 9-2](#list9-2), the code returns the following ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2, 6, 7, 4, 5, 8, 9, 3]</samp>
  prefs: []
  type: TYPE_NORMAL
- en: Comparing this result to [Figure 9-11](#fig9-11), we can see that if we were
    to reorder the pages to begin with page 0, then turn to pages 1, 2, 6, and so
    on, we would never need to flip backward while following a narrative line.
  prefs: []
  type: TYPE_NORMAL
- en: While sorting choose-your-own-adventure books might not be a typical problem
    you need to handle in your everyday workflow, it’s easy to extrapolate from this
    example and apply the same techniques to other use cases. You can simply construct
    dependency graphs from either forward pointers (for choose-your-own-adventure
    books or recipes) or backward pointers (course prerequisites or code dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Topological sort demonstrates how to use directed edges in graphs to enforce
    more abstract constraints like the ordering of items. We can transform a range
    of dependency and ordering problems into graphs by modeling the items as nodes
    and the dependency between them as directed edges.
  prefs: []
  type: TYPE_NORMAL
- en: As shown throughout the chapter, topological sort has a range of real-world
    use cases. We often perform topological sort in our day-to-day lives without even
    realizing it. Before we brew coffee, we fill the kettle with water. We know the
    correct series of steps for this particular operation without needing to represent
    it as a graph, of course. However, transforming topological sort into a graph
    problem greatly scales up the types of problems we can solve using this algorithm.
    Compilers can use topological sort to determine the order in which to compile
    thousands of source files in a project, for example. Cloud-based workflow systems
    can likewise use it to determine which computation to perform next. Once you start
    looking for it, topological sort arises throughout both the computational and
    everyday domains. Knowing how to model such problems and sort the tasks is the
    first step in implementing efficient solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter considers connectivity within graphs and how to choose a subset
    of edges that makes the graph fully connected. Specifically, we examine the problem
    of finding the minimum cost set of edges that connect all of the nodes.
  prefs: []
  type: TYPE_NORMAL
