["```\nmov( *`source`*, *`destination`* );\n```", "```\nmov( bx, ax );          // Copies the value from bx into ax\n     mov( al, dl );          // Copies the value from al into dl\n     mov( edx, esi );        // Copies the value from edx into esi\n     mov( bp, sp );          // Copies the value from bp into sp\n     mov( cl, dh );          // Copies the value from cl into dh\n     mov( ax, ax );          // Yes, this is legal!\n```", "```\nmov( [eax], al );\n          mov( [ebx], al );\n          mov( [ecx], al );\n          mov( [edx], al );\n          mov( [edi], al );\n          mov( [esi], al );\n          mov( [ebp], al );\n          mov( [esp], al );\n```", "```\nmov( $1234_5678, ebx );\n          mov( [ebx], al );     // Attempts to access location $1234_5678.\n```", "```\nmov( &j, ebx );               // Load address of j into ebx.\n     mov( eax, [ebx] );            // Store eax into j.\n```", "```\nmov( *`VarName`*[ eax ], al );\n     mov( *`VarName`*[ ebx ], al );\n     mov( *`VarName`*[ ecx ], al );\n     mov( *`VarName`*[ edx ], al );\n     mov( *`VarName`*[ edi ], al );\n     mov( *`VarName`*[ esi ], al );\n     mov( *`VarName`*[ ebp ], al );\n     mov( *`VarName`*[ esp ], al );\n```", "```\nmov( [ ebx + *`constant`* ], al );\n     mov( [ ebx - *`constant`* ], al );\n```", "```\nmov( *`VarName`*[ ebx + *`constant`* ], al );\n     mov( *`VarName`*[ ebx - *`constant`* ], al );\n```", "```\nmov( *`VarName`*[ ebx + *`constant`*], al );\n```", "```\nmov( *`constant1`*[ ebx + *`constant2`*], al );\n```", "```\nmov( [ebx + (*`constant1`* + *`constant2`*)], al );\n```", "```\nmov( [ebx + *`constant_sum`*], al );\n```", "```\n*`VarName`*[ *`IndexReg32`***`scale`* ]\n     *`VarName`*[ *`IndexReg32`***`scale`* + *`displacement`* ]\n     *`VarName`*[ *`IndexReg32`***`scale`* - *`displacement`* ]\n\n     [ *`BaseReg32`* + *`IndexReg32`***`scale`* ]\n     [ *`BaseReg32`* + *`IndexReg32`***`scale`* + *`displacement`* ]\n     [ *`BaseReg32`* + *`IndexReg32`***`scale`* - *`displacement`* ]\n\n     *`VarName`*[ *`BaseReg32`* + *`IndexReg32`***`scale`* ]\n     *`VarName`*[ *`BaseReg32`* + *`IndexReg32`***`scale`* + *`displacement`* ]\n     *`VarName`*[ *`BaseReg32`* + *`IndexReg32`***`scale`* - *`displacement`* ]\n```", "```\nmov( *`VarName`*[ ebx + esi*4 + 4 ], al );\n```", "```\nbyte *`comma_separated_list_of_byte_constants`* ;\n```", "```\nboolean     true;\n     char        'A';\n     byte        0, 1, 2;\n     byte        \"Hello\", 0\n     word        0, 2;\n     int8        âˆ’5;\n     uns32       356789, 0;\n```", "```\nmov( 0, ax );\n          byte 0,1,2,3;\n          add( bx, cx );\n```", "```\nstatic\n     b:   byte := 0;\n          byte 1,2,3;\n\n     u:   uns32 := 1;\n          uns32 5,2,10;\n\n     c:   char;\n          char 'a', 'b', 'c', 'd', 'e', 'f';\n\n     bn:  boolean;\n          boolean true;\n```", "```\nreadonly\n     pi:              real32 := 3.14159;\n     e:               real32 := 2.71;\n     MaxU16:          uns16 := 65_535;\n     MaxI16:          int16 := 32_767;\n```", "```\nreadonly\n     roArray: byte := 0;\n              byte 1, 2, 3, 4, 5;\n     qwVal:   qword := 1;\n              qword 0;\n```", "```\nstorage\n     UninitUns32:     uns32;\n     i:               int32;\n     character:       char;\n     b:               byte;\n```", "```\n*`variableName`*: *`varType`*; @nostorage;\n```", "```\nreadonly\n     abcd: dword; nostorage;\n           byte 'a', 'b', 'c', 'd';\n```", "```\nvar\n     vInt:      int32;\n     vChar:     char;\n```", "```\nprogram demoDeclarations;\n\nstatic\n     i_static:     int32;\n\nvar\n     i_auto:       int32;\n\nstorage\n     i_uninit:     int32;\n\nreadonly\n     i_readonly:   int32 := 5;\n\nstatic\n     j:            uns32;\n\nvar\n     k:            char;\n\nreadonly\n     i2:           uns8 := 9;\n\nstorage\n     c:            char;\n\nstorage\n     d:            dword;\n\nbegin demoDeclarations;\n\n     << Code goes here. >>\n\nend demoDeclarations;\n```", "```\nstatic\n     b     :byte;                    // Location counter = 0, size = 1\n     w     :word;                    // Location counter = 1, size = 2\n     d     :dword;                   // Location counter = 3, size = 4\n     q     :qword;                   // Location counter = 7, size = 8\n     l     :lword;                   // Location counter = 15, size = 16\n                                     // Location counter is now 31.\n```", "```\nstatic\n     b     :byte;\nreadonly\n     w     :word := $1234;\nstorage\n     d     :dword;\n```", "```\nstatic\n     b     :byte;\nstatic\n     w     :word := $1234;\nstatic\n     d     :dword;\n```", "```\nstatic\n     dw:    dword;\n     b:     byte;\n     w:     word;\n     dw2:   dword;\n     w2:    word;\n     b2:    byte;\n     dw3:   dword;\n```", "```\n//  Start Adrs              Length\n     dw:    dword;       //     4096                    4\n     b:     byte;        //     4100                    1\n     w:     word;        //     4101                    2\n     dw2:   dword;       //     4103                    4\n     w2:    word;        //     4107                    2\n     b2:    byte;        //     4109                    1\n     dw3:   dword;       //     4110                    4\n```", "```\nstatic\n     dw:    dword;\n     dw2:   dword;\n     dw3:   dword;\n     w:     word;\n     w2:    word;\n     b:     byte;\n     b2:    byte;\n```", "```\n//  Start Adrs          Length\n     dw:    dword;     //     4096                4\n     dw2:   dword;     //     4100                4\n     dw3:   dword;     //     4104                4\n     w:     word;      //     4108                2\n     w2:    word;      //     4110                2\n     b:     byte;      //     4112                1\n     b2:    byte;      //     4113                1\n```", "```\nalign( *`integer_constant`* );\n```", "```\nstatic\n     align( 4 );\n     dw:     dword;\n     b:      byte;\n     align( 2 );\n     w:      word;\n     align( 4 );\n     dw2:    dword;\n     w2:     word;\n     b2:     byte;\n     align( 4 );\n     dw3:    dword;\n```", "```\n*`VarName`*[ *`Reg32`* ]\n*`VarName`*[ *`Reg32`* + *`offset`* ]\n*`VarName`*[ *`RegNotESP32`***`scale`* ]\n*`VarName`*[ *`Reg32`* + *`RegNotESP32`***`scale`* ]\n*`VarName`*[ *`RegNotESP32`***`scale`* + *`offset`* ]\n*`VarName`*[ *`Reg32`* + *`RegNotESP32`***`scale`* + *`offset`* ]\n```", "```\n*`VarName`*[ *`offset`* ]\n```", "```\n[ *`Reg32`* + *`offset`* ]\n[ *`Reg32`* + *`RegNotESP32`***`scale`* + *`offset`* ]\n```", "```\n[ *`Reg32`* ]\n[ *`Reg32`* + *`RegNotESP32`*\n**`scale`* ]\n```", "```\nmov( X[ 2*4+1 ], al );\n```", "```\nprogram adrsExpressions;\n#include( \"stdlib.hhf\" )\nstatic\n  i: int8; @nostorage;\n     byte 0, 1, 2, 3;\n\nbegin adrsExpressions;\n\n  stdout.put\n  (\n    \"i[0]=\", i[0], nl,\n    \"i[1]=\", i[1], nl,\n    \"i[2]=\", i[2], nl,\n    \"i[3]=\", i[3], nl\n  );\n\nend adrsExpressions;\n```", "```\nprogram hasErrors;\nstatic\n     i8:     int8;\n     i16:    int16;\n     i32:    int32;\nbegin hasErrors;\n\n     mov( i8, eax );\n     mov( i16, al );\n     mov( i32, ax );\n\nend hasErrors;\n```", "```\nstatic\n     byte_values: byte; @nostorage;\n                  byte  0, 1;\n\n     ...\n\n          mov( byte_values, ax );\n```", "```\n(type *`newTypeName addressExpression`*)\n```", "```\nmov( (type word *`byte_values`*), ax );\n```", "```\nnot( [ebx] );\n```", "```\nnot( (type byte [ebx]) );\nnot( (type dword [ebx]) );\n```", "```\nmov( eax, (type dword *`byteVar`*) );\n```", "```\nif( eax < 0 ) then\n\n     stdout.put( \"EAX is negative!\", nl );\n\nendif;\n```", "```\nif( (type int32 eax) < 0 ) then\n\n     stdout.put( \"EAX is negative!\", nl );\n\nendif;\n```", "```\nstdout.put( \"AL printed as a char = '\", (type char al), \"'\", nl );\n```", "```\npush( *`reg16`* );\npush( *`reg32`* );\npush( *`memory16`* );\npush( *`memory32`* );\npushw( *`constant`* );\npushd( *`constant`* );\n```", "```\nESP := ESP - *`Size_of_Register_or_Memory_Operand`* (2 or 4)\n[ESP] := *`Operand's_Value`*\n```", "```\npop( *`reg16`* );\n                 pop( *`reg32`* );\n                 pop( *`memory16`* );\n                 pop( *`memory32`* );\n```", "```\n*`Operand`* := [ESP]\nESP := ESP + *`Size_of_Operand`* (2 or 4)\n```", "```\n<< Some sequence of instructions that use the eax register >>\n\n     << Some sequence of instructions that need to use eax, for a\n          different purpose than the above instructions >>\n\n     << Some sequence of instructions that need the original value in eax >>\n```", "```\n<< Some sequence of instructions that use the eax register >>\n     push( eax );\n     << Some sequence of instructions that need to use eax, for a\n          different purpose than the above instructions >>\n     pop( eax );\n     << Some sequence of instructions that need the original value in eax >>\n```", "```\npush( eax );\n          push( ebx );\n          << Code that uses eax and ebx goes here. >>\n          pop( eax );\n          pop( ebx );\n```", "```\npush( eax );\n          push( ebx );\n          << Code that uses eax and ebx goes here. >>\n          pop( ebx );\n          pop( eax );\n```", "```\nax\ncx\ndx\nbx\nsp\nbp\nsi\ndi\n```", "```\neax\necx\nedx\nebx\nesp\nebp\nesi\nedi\n```", "```\npush( eax );\n          push( ebx );\n\n          << Some code that winds up computing some values we want to keep\n               into eax and ebx >>\n\n          if( *`Calculation_was_performed`* ) then\n\n               // Whoops, we don't want to pop eax and ebx!\n               // What to do here?\n\n          else\n\n               // No calculation, so restore eax, ebx.\n\n               pop( ebx );\n               pop( eax );\n\n          endif;\n```", "```\npush( eax );\n          push( ebx );\n\n          << Some code that winds up computing some values we want to keep\n               into eax and ebx >>\n\n          if( *`Calculation_was_performed`* ) then\n\n              add( 8, ESP ); // Remove unneeded eax/ebx values from the stack.\n\n          else\n\n               // No calculation, so restore eax, ebx.\n\n               pop( ebx );\n               pop( eax );\n\n          endif;\n```", "```\npush( eax );\n          push( ebx );\n```", "```\nmov( [esp+4], eax );\n```", "```\npush( eax );\n          push( ebx );\n\n          << Some code that winds up computing some values we want to keep\n             into eax and ebx >>\n\n          if( *`Calculation_was_performed`* ) then\n\n             << Overwrite saved values on stack with new eax/ebx values\n                (so the pops that follow won't change the values in eax/ebx). >>\n\n               mov( eax, [esp+4] );\n               mov( ebx, [esp] );\n\n          endif;\n          pop( ebx );\n          pop( eax );\n```", "```\nmem.alloc( *`Number_of_Bytes_Requested`* );\n```", "```\nmem.alloc( 4 );\n```", "```\n@size( *`variable_or_type_name`* )\n```", "```\nmem.alloc( @size( uns32 ));\n```", "```\nmem.alloc( @size( uns32 ));\nmov( 1234, (type uns32 [eax]));\n```", "```\nmem.alloc( @size( uns32));\n\n               << Use the storage pointed at by eax. >>\n               << Note: This code must not modify eax. >>\n\n          mem.free( eax );\n```", "```\nmem.alloc( @size( char ) * 8 );\n```", "```\nmem.alloc( 128 );\n          for( mov( 0, ebx ); ebx < 128; add( 1, ebx ) ) do\n\n               mov( 0, (type byte [eax+ebx]) );\n\n          endfor;\n```", "```\ninc( *`mem/reg`* );\ndec( *`mem/reg`* );\n```", "```\nmem.alloc( 128 );\n          for( mov( 0, ebx ); ebx < 128; inc( ebx ) ) do\n\n               mov( 0, (type byte [eax+ebx]) );\n\n          endfor;\n```", "```\nlea( *`reg32`*, *`Memory_operand`* );\n```", "```\nstatic\n     b:byte; @nostorage;\n       byte 7, 0, 6, 1, 5, 2, 4, 3;\n               .\n               .\n               .\n     lea( ebx, b );\n     for( mov( 0, ecx ); ecx < 8; inc( ecx )) do\n\n          stdout.put( \"[ebx+ecx] = \", (type byte [ebx+ecx]), nl );\n\n     endfor;\n```"]