- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: 'IPL BOOTKITS: ROVNIX AND CARBERP**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: IPL引导工具：ROVNIX和CARBERP**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Distribution of Rovnix, the first known bootkit to infect the IPL code of the
    active partition on a bootable hard drive, began at the end of 2011\. Security
    products at that time had already evolved to monitor the MBR, as discussed in
    [Chapter 10](ch10.xhtml#ch10), to protect against bootkits such as TDL4 and Olmasco.
    The appearance of Rovnix in the wild was therefore a challenge for security software.
    Because Rovnix went further in the boot process and infected the IPL code that
    executed after the VBR code (see [Chapter 5](ch05.xhtml#ch05)), it stayed under
    the radar for a few months until the security industry managed to catch up.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix的分发始于2011年底，这是第一个已知的感染可启动硬盘的活动分区IPL代码的引导工具。当时的安全产品已经进化到能够监控MBR，如[第10章](ch10.xhtml#ch10)中所讨论的，用以防御如TDL4和Olmasco等引导工具。因此，Rovnix的出现对安全软件构成了挑战。由于Rovnix进一步深入了引导过程，感染了在VBR代码之后执行的IPL代码（见[第5章](ch05.xhtml#ch05)），它在几个月内未被察觉，直到安全行业跟进。
- en: 'In this chapter, we’ll focus on the technical details of the Rovnix bootkit
    framework by studying how it infects target systems and bypasses the Kernel-Mode
    Signing Policy to load the malicious kernel-mode driver. We’ll pay special attention
    to the malicious IPL code, and we’ll debug it using VMware and the IDA Pro GDB,
    as discussed in [Chapter 9](ch09.xhtml#ch09). Finally, we’ll see an implementation
    of Rovnix in the wild: the Carberp banking trojan, which used a modification of
    Rovnix to persist on victims’ machines.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过研究Rovnix如何感染目标系统并绕过内核模式签名策略来加载恶意内核模式驱动程序，专注于Rovnix引导工具框架的技术细节。我们将特别关注恶意IPL代码，并使用VMware和IDA
    Pro GDB进行调试，如[第9章](ch09.xhtml#ch09)所讨论的。最后，我们将看到Rovnix在野外的实现：Carberp银行木马，它使用了Rovnix的修改版本在受害者机器上保持持久性。
- en: '**Rovnix’s Evolution**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Rovnix的演变**'
- en: Rovnix was first advertised on a private underground forum, shown in [Figure
    11-1](ch11.xhtml#ch11fig01), as a new Ring0 bundle with extensive functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix首次在一个私人地下论坛上广告宣传，如[图11-1](ch11.xhtml#ch11fig01)所示，作为一个具有广泛功能的新Ring0捆绑软件。
- en: '![image](../images/11fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig01.jpg)'
- en: '*Figure 11-1: Rovnix advertisement on a private underground forum*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：Rovnix在私人地下论坛上的广告*'
- en: It had a modular architecture that made it very attractive for malware developers
    and distributors. It seems likely that its developers were more focused on selling
    the framework than on distributing and using the malware.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有模块化架构，这使其对恶意软件开发者和分发者非常有吸引力。开发者似乎更专注于销售该框架，而不是分发和使用恶意软件。
- en: Since its first appearance in the wild, Rovnix has gone through multiple iterations.
    This chapter will focus on the latest generation at the time of this writing,
    but we’ll touch on the earlier versions to give you an idea of its development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自首次在野外出现以来，Rovnix经历了多个迭代。本章将重点介绍撰写时的最新版本，但我们也会提及早期版本，以帮助你了解其发展过程。
- en: The first iterations of Rovnix used a simple IPL infector to inject a payload
    into the user-mode address space of the boot processes. The malicious IPL code
    was the same in all early iterations, so the security industry was able to quickly
    develop detection methods using simple static signatures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix的早期版本使用简单的IPL感染器，将有效负载注入到引导进程的用户模式地址空间中。所有早期版本的恶意IPL代码相同，因此安全行业能够迅速开发出使用简单静态签名的检测方法。
- en: 'The next versions of Rovnix rendered these detection methods ineffectual by
    implementing *polymorphic* malicious IPL code. Rovnix also added another new feature:
    a hidden filesystem to secretly store its configuration data, payload modules,
    and so on. Inspired by TDL4-like bootkits, Rovnix also began implementing functionality
    that monitored read and write requests to the infected hard drive, making it harder
    to remove the malware from the system.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix的后续版本通过实施*多态*恶意IPL代码，使这些检测方法变得无效。Rovnix还增加了一个新特性：一个隐藏的文件系统，用于秘密存储其配置数据、有效负载模块等。受到类似TDL4引导工具的启发，Rovnix还开始实现监控对感染硬盘的读写请求的功能，从而使得从系统中移除恶意软件变得更加困难。
- en: A later iteration added a hidden communication channel to allow Rovnix to exchange
    data with remote C&C servers and bypass the traffic monitoring performed by personal
    firewalls and Host Intrusion Prevention Systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 后来的一个版本添加了一个隐藏的通信通道，使Rovnix能够与远程C&C服务器交换数据，并绕过个人防火墙和主机入侵防护系统（HIPS）执行的流量监控。
- en: At this point, we’ll turn our attention to the latest known modifications of
    Rovnix (also known as Win32/Rovnix.D) at the time of this writing and discuss
    its features in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将把注意力转向本写作时已知的最新 Rovnix 修改版本（也称为 Win32/Rovnix.D），并详细讨论其特性。
- en: '**The Bootkit Architecture**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Bootkit 架构**'
- en: First we’ll consider the Rovnix architecture from a high-level point of view.
    [Figure 11-2](ch11.xhtml#ch11fig02) shows the main components of Rovnix and how
    they relate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从高层次角度考虑 Rovnix 的架构。[图 11-2](ch11.xhtml#ch11fig02)展示了 Rovnix 的主要组件及其相互关系。
- en: '![image](../images/11fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig02.jpg)'
- en: '*Figure 11-2: Rovnix architecture*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：Rovnix 架构*'
- en: At the heart of Rovnix lies a malicious kernel-mode driver, the main purpose
    of which is to inject payload modules into processes in the system. Rovnix can
    hold multiple payloads for injection into different processes. An example of such
    a payload is a banking trojan that creates fake transactions, like the Carberp
    trojan discussed later in this chapter. Rovnix has a default payload module hardcoded
    into the malicious kernel-mode driver, but it is capable of downloading additional
    modules from remote C&C servers through the hidden network channel (discussed
    in “[The Hidden Communication Channel](ch11.xhtml#ch11lev1sec7)” on [page 169](ch11.xhtml#page_169)).
    The kernel-mode driver also implements hidden storage to store downloaded payloads
    and configuration information (covered in detail in “[The Hidden Filesystem](ch01.xhtml#ch01lev1sec4)”
    on [page 167](ch11.xhtml#page_167)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 的核心是一种恶意的内核模式驱动程序，其主要目的是将有效负载模块注入系统中的进程。Rovnix 可以持有多个有效负载，以便注入到不同的进程中。一个这样的有效负载示例是银行木马，它创建伪造交易，如本章后面讨论的
    Carberp 木马。Rovnix 默认在恶意内核模式驱动程序中硬编码了一个有效负载模块，但它能够通过隐藏的网络通道（在 “[隐藏通信通道](ch11.xhtml#ch11lev1sec7)”
    章节的 [第169页](ch11.xhtml#page_169)中讨论）从远程 C&C 服务器下载额外的模块。内核模式驱动程序还实现了隐藏存储，用于存储下载的有效负载和配置信息（在
    “[隐藏文件系统](ch01.xhtml#ch01lev1sec4)” 章节的 [第167页](ch11.xhtml#page_167)中有详细讨论）。
- en: '**Infecting the System**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**感染系统**'
- en: Let’s continue our analysis of Rovnix by dissecting its infection algorithm,
    depicted in [Figure 11-3](ch11.xhtml#ch11fig03).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续分析 Rovnix，通过剖析其感染算法，如[图 11-3](ch11.xhtml#ch11fig03)所示。
- en: '![image](../images/11fig03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig03.jpg)'
- en: '*Figure 11-3: Rovnix dropper infection algorithm*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：Rovnix 投放器感染算法*'
- en: Rovnix first checks if the system has already been infected by accessing the
    system registry key *HKLM\Software\Classes\CLSID\<XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX>*,
    where *X* is generated from the filesystem volume serial number. If this registry
    key exists, it means the system is already infected with Rovnix, so the malware
    terminates and deletes itself from the system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 首先通过访问系统注册表项 *HKLM\Software\Classes\CLSID\<XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX>*
    来检查系统是否已被感染，其中 *X* 是根据文件系统卷序列号生成的。如果此注册表项存在，则意味着系统已经被 Rovnix 感染，恶意软件会终止并从系统中删除自身。
- en: If the system is not already infected, Rovnix queries the version of the operating
    system. To gain low-level access to the hard drive, the malware requires administrator
    privileges. In Windows XP, the regular user is granted administrator rights by
    default, so if the OS is XP, Rovnix can proceed as a regular user without having
    to check privileges.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统尚未感染，Rovnix 会查询操作系统的版本。为了获得硬盘的低级访问权限，恶意软件需要管理员权限。在 Windows XP 中，普通用户默认被授予管理员权限，因此如果操作系统是
    XP，Rovnix 可以作为普通用户继续运行，而无需检查权限。
- en: However, in Windows Vista, Microsoft introduced a new security feature—*User
    Account Control (UAC)*—that demotes the privileges of applications running under
    the administrator account, so if the OS is Vista or above, Rovnix has to check
    administrative privileges. If the dropper is running without administrative privileges,
    Rovnix tries to elevate the privileges by relaunching itself with the `ShellExecuteEx`
    API using the `runas` command. The dropper’s manifest contains a `requireAdministrator`
    property, so `runas` attempts to execute the dropper with elevated privileges.
    On systems with UAC enabled, a dialog displays, asking the user whether they authorize
    the program to run with administrator privileges. If the user chooses Yes, the
    malware starts with elevated privileges and infects the system. If the user chooses
    No, the malware will not be executed. If there is no UAC on a system or if UAC
    is disabled, the malware just runs with the privileges of the current account.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Windows Vista 中，微软引入了一个新的安全功能——*用户帐户控制（UAC）*——它会降低以管理员帐户运行的应用程序的权限。因此，如果操作系统是
    Vista 或更高版本，Rovnix 需要检查管理员权限。如果没有管理员权限运行，Rovnix 会通过使用 `ShellExecuteEx` API 和 `runas`
    命令重新启动自身以提升权限。启动器的清单包含一个 `requireAdministrator` 属性，因此 `runas` 尝试以提升的权限执行启动器。在启用了
    UAC 的系统上，会弹出一个对话框，询问用户是否授权程序以管理员权限运行。如果用户选择“是”，恶意软件将以提升的权限启动并感染系统。如果用户选择“否”，恶意软件将不会执行。如果系统没有启用
    UAC 或 UAC 被禁用，恶意软件将以当前帐户的权限运行。
- en: Once it has the required privileges, Rovnix gains low-level access to the hard
    drive by using the native API functions `ZwOpenFile`, `ZwReadFile`, and `ZwWriteFile`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得所需的权限，Rovnix 通过使用本地 API 函数 `ZwOpenFile`、`ZwReadFile` 和 `ZwWriteFile` 获取对硬盘的低级访问权限。
- en: First the malware calls `ZwOpenFile` using *\??\PhysicalDrive0* as a filename,
    which returns a handle corresponding to the hard drive. Rovnix then uses the returned
    handle with the `ZwReadFile` and `ZwWriteFile` routines to read data from and
    write data to the hard drive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先使用 `ZwOpenFile` 调用 *\??\PhysicalDrive0* 作为文件名，返回一个与硬盘对应的句柄。然后，Rovnix 使用返回的句柄与
    `ZwReadFile` 和 `ZwWriteFile` 函数来读取和写入硬盘上的数据。
- en: To infect the system, the malware scans the partition table in the MBR of the
    hard drive, and then reads the IPL of the active partition and reduces its size
    with the aPlib compression library. Next, Rovnix creates a new malicious IPL by
    prepending the compressed legitimate IPL with malicious loader code, as shown
    in [Figure 11-4](ch11.xhtml#ch11fig04).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感染系统，恶意软件扫描硬盘的 MBR 中的分区表，然后读取活动分区的 IPL，并通过 aPlib 压缩库减小其大小。接下来，Rovnix 通过将恶意加载程序代码附加到压缩后的合法
    IPL 前面，创建一个新的恶意 IPL，如 [图 11-4](ch11.xhtml#ch11fig04) 所示。
- en: '![image](../images/11fig04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig04.jpg)'
- en: '*Figure 11-4: Hard drive layout before and after Rovnix infection*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：Rovnix 感染前后的硬盘布局*'
- en: After modifying the IPL, Rovnix writes a malicious kernel-mode driver at the
    end of the hard drive to be loaded by the malicious IPL code during system start-up.
    The malware reserves some space at the end of the hard drive for the hidden filesystem,
    which we’ll describe later in the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改 IPL 后，Rovnix 将一个恶意的内核模式驱动程序写入硬盘的末尾，供恶意的 IPL 代码在系统启动时加载。该恶意软件在硬盘的末尾保留了一些空间，用于隐藏的文件系统，稍后我们将在本章中详细描述。
- en: '**APLIB**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**APLIB**'
- en: aPlib is a small compression library used primarily for compressing executable
    code. It’s based on the compression algorithm used in aPack software for packing
    executable files. One of the library’s distinguishing features is a good compression:speed
    ratio and tiny depacker footprint, which is especially important in the preboot
    environment since it has only a small amount of memory. The aPlib compression
    library is also frequently used in malware to pack and obfuscate the payload.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: aPlib 是一个小型压缩库，主要用于压缩可执行代码。它基于用于打包可执行文件的 aPack 软件中的压缩算法。该库的一个显著特点是具有良好的压缩：速度比，并且解压器占用空间小，这在启动前环境中尤其重要，因为该环境内存较小。aPlib
    压缩库在恶意软件中也被广泛用于打包和混淆有效载荷。
- en: Finally, Rovnix creates the system registry key to mark the system as infected
    and initiates a restart by calling `ExitWindowsEx` Win32 API with the parameters
    `EWX_REBOOT | EWX_FORCE`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rovnix 创建了系统注册表项，以标记系统为已感染，并通过调用 `ExitWindowsEx` Win32 API，并使用参数 `EWX_REBOOT
    | EWX_FORCE` 发起重启。
- en: '**Post-Infection Boot Process and IPL**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**感染后启动过程与 IPL**'
- en: Once Rovnix infects the machine and forces a reboot, the BIOS boot code carries
    on as usual, loading and executing the bootable hard drive’s unmodified MBR. The
    MBR finds an active partition on the hard drive and executes the legitimate, unmodified
    VBR. The VBR then loads and executes the infected IPL code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Rovnix 感染了机器并强制重启，BIOS 启动代码照常继续，加载并执行启动硬盘上未修改的 MBR。MBR 找到硬盘上的活动分区，并执行合法且未修改的
    VBR。VBR 随后加载并执行感染的 IPL 代码。
- en: '***Implementing the Polymorphic Decryptor***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现多态解密器***'
- en: The infected IPL begins with a small decryptor whose purpose is to decrypt the
    rest of the malicious IPL code and execute it ([Figure 11-5](ch11.xhtml#ch11fig05)).
    The fact that the decryptor is polymorphic means that each instance of Rovnix
    comes with custom decryptor code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 被感染的 IPL 以一个小的解密器开始，其目的是解密其余的恶意 IPL 代码并执行它（[图 11-5](ch11.xhtml#ch11fig05)）。解密器的多态性意味着每个
    Rovnix 实例都带有定制的解密器代码。
- en: '![image](../images/11fig05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig05.jpg)'
- en: '*Figure 11-5: Layout of the infected IPL*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：感染的 IPL 布局*'
- en: 'Let’s take a look at how the decryptor is implemented. We’ll give a general
    description of the decryption algorithm before analyzing the actual polymorphic
    code. The decryptor follows this process to decrypt the content of the malicious
    IPL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解密器是如何实现的。在分析实际的多态代码之前，我们将先给出解密算法的一般描述。解密器按以下流程解密恶意 IPL 的内容：
- en: Allocate a memory buffer to store decrypted code.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配内存缓冲区来存储解密后的代码。
- en: Initialize the decryption key and decryption counters—the offset and size of
    the encrypted data, respectively.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化解密密钥和解密计数器——分别是加密数据的偏移量和大小。
- en: Decrypt the IPL code into the allocated buffer.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 IPL 代码解密到已分配的缓冲区中。
- en: Initialize registers before executing the decrypted code.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行解密后的代码之前初始化寄存器。
- en: Transfer control to the decrypted code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制权转移到解密后的代码。
- en: In order to customize the decryption routine, Rovnix randomly splits it into
    *basic blocks* (sets of continuous instructions with no branches), each of which
    contains a small number of assembly instructions for the routine. Rovnix then
    shuffles the basic blocks and reorders them randomly, connecting them using `jmp`
    instructions, as shown in [Figure 11-6](ch11.xhtml#ch11fig06). The result is a
    custom decryption code for every instance of Rovnix.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定制解密例程，Rovnix 随机将其拆分成 *基本块*（一组没有分支的连续指令），每个基本块包含少量的汇编指令。然后 Rovnix 将这些基本块进行洗牌并随机重新排序，通过
    `jmp` 指令连接它们，如[图 11-6](ch11.xhtml#ch11fig06)所示。结果是每个 Rovnix 实例都有一个定制的解密代码。
- en: '![image](../images/11fig06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig06.jpg)'
- en: '*Figure 11-6: Generation of polymorphic decryptor*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：多态解密器的生成*'
- en: This polymorphic mechanism is actually quite simple compared to some other code
    obfuscation techniques employed in modern malware, but because the byte pattern
    of the routine changes with every instance of Rovnix, it’s sufficient for avoiding
    detection by security software that uses static signatures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多态机制与一些现代恶意软件中采用的代码混淆技术相比其实相当简单，但由于每次 Rovnix 的实例中例程的字节模式都会变化，它足以避免使用静态签名的安全软件检测。
- en: Polymorphism is not invulnerable, though, and one of the most common approaches
    to defeating it is software emulation. In emulation, security software applies
    behavioral patterns to detect malware.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性并非无懈可击，其中一种最常见的应对方法是软件仿真。在仿真中，安全软件应用行为模式来检测恶意软件。
- en: '***Decrypting the Rovnix Bootloader with VMware and IDA Pro***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 VMware 和 IDA Pro 解密 Rovnix 启动加载程序***'
- en: Let’s take a look at the actual implementation of the decryption routine using
    a VMware virtual machine and IDA Pro. All the necessary information on how to
    set up VMware with IDA Pro can be found in [Chapter 9](ch09.xhtml#ch09). In this
    demonstration, we’ll use a VMware image preinfected with the Win32/Rovnix.D bootkit,
    which you can download from *[https://nostarch.com/rootkits](https://nostarch.com/rootkits)*
    as the file *bootkit_files.zip.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用 VMware 虚拟机和 IDA Pro 的实际解密例程实现。关于如何设置 VMware 和 IDA Pro 的所有必要信息，可以在[第9章](ch09.xhtml#ch09)中找到。在本示范中，我们将使用一个已感染
    Win32/Rovnix.D 启动木马的 VMware 镜像，你可以从 *[https://nostarch.com/rootkits](https://nostarch.com/rootkits)*
    下载该文件 *bootkit_files.zip*。
- en: Our goal is to obtain the decrypted malicious IPL code using dynamic analysis.
    We’ll walk you through the debugging process, skipping quickly through the MBR
    and VBR steps to focus on analyzing the polymorphic IPL decryptor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过动态分析获取解密后的恶意 IPL 代码。我们将引导你完成调试过程，快速跳过 MBR 和 VBR 步骤，重点分析多态 IPL 解密程序。
- en: '**Observing the MBR and VBR Code**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**观察 MBR 和 VBR 代码**'
- en: Flip back to “[Combining VMware GDB with IDA](ch09.xhtml#ch09lev2sec7)” on [page
    126](ch09.xhtml#page_126) and follow the steps there to decrypt the MBR from *bootkit_files.zip*.
    You’ll find the MBR code located at address 0000:7c00h. In [Figure 11-7](ch11.xhtml#ch11fig07),
    the address 0000:7c00h is denoted as `MEMORY:7c00h` because IDA Pro displays the
    segment name (in our case, `MEMORY`) instead of the segment base address 0000h.
    Because Rovnix infects the IPL code and not the MBR, the MBR code shown in the
    debugger is legitimate and we won’t dig into it very deeply.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 “[将 VMware GDB 与 IDA 结合使用](ch09.xhtml#ch09lev2sec7)” 第[126页](ch09.xhtml#page_126)，并按照那里的步骤解密来自
    *bootkit_files.zip* 的 MBR。你会在地址 0000:7c00h 处找到 MBR 代码。在[图 11-7](ch11.xhtml#ch11fig07)中，地址
    0000:7c00h 被表示为 `MEMORY:7c00h`，因为 IDA Pro 显示的是段名（在我们的例子中是 `MEMORY`），而不是段基址 0000h。由于
    Rovnix 感染的是 IPL 代码而不是 MBR，调试器中显示的 MBR 代码是合法的，我们不需要深入研究它。
- en: '![image](../images/11fig07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig07.jpg)'
- en: '*Figure 11-7: The beginning of the MBR code*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：MBR 代码的开头*'
- en: This routine code relocates the MBR to another memory address to recycle the
    memory located at 0000:7c00h, in order to read and store the VBR of the active
    partition. Register `si` ➋ is initialized with the value `7C1h`, which corresponds
    to the source address, and register `di` ➌ is initialized with the value `61Bh`,
    the destination address. Register `cx` ➍ is initialized with `1E5h`, the number
    of bytes to copy, and the `rep movsb` instruction ➎ copies the bytes. The `retf`
    instruction ➏ transfers control to the copied code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序代码将 MBR 移动到另一个内存地址，以回收位于 0000:7c00h 的内存，用于读取和存储活动分区的 VBR。寄存器 `si` ➋ 被初始化为值
    `7C1h`，对应源地址，寄存器 `di` ➌ 被初始化为值 `61Bh`，对应目标地址。寄存器 `cx` ➍ 被初始化为 `1E5h`，即要复制的字节数，`rep
    movsb` 指令 ➎ 执行字节复制。`retf` 指令 ➏ 将控制转移到复制后的代码。
- en: At this point, the instruction pointer register `ip` points at address 0000:7c00h
    ➊. Execute each instruction in the listing by pressing **F8** until you reach
    the last `retf` instruction ➏. Once `retf` is executed, control is transferred
    to the code that has just been copied to address 0000:061Bh—namely, the main MBR
    routine, whose purpose is to find the active partition in the MBR’s partition
    table and load its very first sector, the VBR.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，指令指针寄存器 `ip` 指向地址 0000:7c00h ➊。通过按 **F8** 执行列出的每条指令，直到到达最后一条 `retf` 指令 ➏。执行
    `retf` 后，控制转移到刚刚复制到地址 0000:061Bh 的代码——即主 MBR 程序，其目的是查找 MBR 分区表中活动分区并加载其第一个扇区，即
    VBR。
- en: The VBR also remains unchanged, so we’ll proceed to the next step by setting
    up a breakpoint right at the end of the routine. The `retf` instruction located
    at address 0000:069Ah transfers control directly to the VBR code of the active
    partition, so we’ll put the breakpoint at the `retf` instruction (highlighted
    in [Figure 11-8](ch11.xhtml#ch11fig08)). Move your cursor to this address and
    press **F2** to toggle the breakpoint. If you see a dialog upon pressing F2, just
    click **OK** to use the default values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 也保持不变，因此我们将继续下一步，直接在该程序的末尾设置断点。位于地址 0000:069Ah 的 `retf` 指令将控制直接转移到活动分区的
    VBR 代码，因此我们将在 `retf` 指令处设置断点（如[图 11-8](ch11.xhtml#ch11fig08)所示）。将光标移动到该地址，按 **F2**
    切换断点。如果按 F2 后出现对话框，只需点击 **OK** 以使用默认值。
- en: '![image](../images/11fig08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig08.jpg)'
- en: '*Figure 11-8: Setting a breakpoint at the end of the MBR code*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：在 MBR 代码的末尾设置断点*'
- en: Once you’ve set the breakpoint, press **F9** to continue the analysis up to
    the breakpoint. This will execute the main MBR routine. When execution reaches
    the breakpoint, the VBR is already read into memory and we can get to it by executing
    the `retf` (F8) instruction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点后，按 **F9** 继续分析，直到达到断点。这将执行主 MBR 程序。当执行到达断点时，VBR 已经被读取到内存中，我们可以通过执行 `retf`（F8）指令来进入
    VBR。
- en: The VBR code starts with a `jmp` instruction, which transfers control to the
    routine that reads the IPL into memory and executes it. The disassembly of the
    routine is shown in [Figure 11-9](ch11.xhtml#ch11fig09). To go directly to the
    malicious IPL code, set a breakpoint at the last instruction of the VBR routine
    at address 0000:7C7Ah ➊ and press **F9** again to release control. Once execution
    reaches the breakpoint, the debugger breaks on the `retf` instruction. Execute
    this instruction with **F8** to get to the malicious IPL code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 代码以 `jmp` 指令开始，该指令将控制转移到读取 IPL 代码到内存并执行它的例程。该例程的反汇编显示在 [图 11-9](ch11.xhtml#ch11fig09)
    中。为了直接跳转到恶意 IPL 代码，请在 VBR 例程的最后一条指令（地址 0000:7C7Ah ➊）设置断点，然后再次按 **F9** 释放控制。一旦执行到达断点，调试器会在
    `retf` 指令处中断。执行此指令（按 **F8**）以跳转到恶意 IPL 代码。
- en: '![image](../images/11fig09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig09.jpg)'
- en: '*Figure 11-9: VBR code*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：VBR 代码*'
- en: '**Dissecting the IPL Polymorphic Decryptor**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解剖 IPL 多态解密器**'
- en: The malicious IPL code starts with a series of instructions, in basic blocks,
    that initialize the registers before executing the decryptor. These are followed
    by a call instruction that transfers control to the IPL decryptor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意 IPL 代码以一系列指令开始，这些指令位于基本块中，负责在执行解密器之前初始化寄存器。之后是一个调用指令，控制转移到 IPL 解密器。
- en: The code in the first basic block of the decryptor ([Listing 11-1](ch11.xhtml#ch11list01))
    obtains the base address of the malicious IPL in memory ➊ and stores it on the
    stack ➋. The `jmp` instruction at ➌ transfers control to the second basic block
    (recall [Figure 11-6](ch11.xhtml#ch11fig06)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解密器第一个基本块的代码（见 [清单 11-1](ch11.xhtml#ch11list01)）获取恶意 IPL 在内存中的基本地址 ➊，并将其存储在栈中
    ➋。位于 ➌ 的 `jmp` 指令将控制转移到第二个基本块（回顾 [图 11-6](ch11.xhtml#ch11fig06)）。
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: Basic block 1 of the polymorphic decryptor*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：多态解密器的基本块 1*'
- en: The second and the third basic blocks both implement a single step of the decryption
    algorithm—memory allocation—and so are shown together in [Listing 11-2](ch11.xhtml#ch11list02).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个基本块都实现了解密算法的单步操作——内存分配——因此它们一起显示在 [清单 11-2](ch11.xhtml#ch11list02) 中。
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Basic blocks 2 and 3 of the polymorphic decryptor*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：多态解密器的基本块 2 和 3*'
- en: The code allocates 3KB of memory (see [Chapter 5](ch05.xhtml#ch05) on memory
    allocation in real mode) and stores the address of the memory in the `cx` register.
    The allocated memory will be used to store the decrypted malicious IPL code. The
    code then reads the total amount of available memory in real execution mode from
    address 0040:0013h and decrements the value by 3KB ➊. The `jmp` instruction at
    ➋ transfers control to the next basic block.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码分配了 3KB 的内存（请参见 [第 5 章](ch05.xhtml#ch05) 关于实模式下内存分配的内容），并将内存的地址存储在 `cx` 寄存器中。分配的内存将用于存储解密后的恶意
    IPL 代码。然后，代码从地址 0040:0013h 读取实执行模式下的总可用内存，并将值减去 3KB ➊。位于 ➋ 的 `jmp` 指令将控制转移到下一个基本块。
- en: Basic blocks 4 through 8, shown in [Listing 11-3](ch11.xhtml#ch11list03), implement
    the decryption key and decryption counter initializations, as well as the decryption
    loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块 4 至 8，如 [清单 11-3](ch11.xhtml#ch11list03) 所示，实现了解密密钥和解密计数器的初始化，以及解密循环。
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-3: Basic blocks 4 through 8 of the polymorphic decryptor*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3：多态解密器的基本块 4 至 8*'
- en: At address 0000:D959h, the `si` register is initialized with the address of
    the encrypted data ➊. Instructions at ➋ initialize the `es` and `di` registers
    with the address of the buffer allocated to store the decrypted data. The `dx`
    register at address 0000:D93Eh ➌ is initialized with the decryption key `0FCE8h`,
    and the `cx` register is initialized with the number of XOR operations to execute
    ➍ in the decryption loop. On every XOR operation, 2 bytes of encrypted data are
    XORed with the decryption key, so the value in the `cx` register is equal to `number_of_bytes_to_decrypt`
    divided by 2.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址 0000:D959h，`si` 寄存器被初始化为加密数据的地址 ➊。位于 ➋ 的指令初始化 `es` 和 `di` 寄存器，指向存储解密数据的缓冲区地址。位于地址
    0000:D93Eh ➌ 的 `dx` 寄存器被初始化为解密密钥 `0FCE8h`，`cx` 寄存器则初始化为解密循环中要执行的 XOR 操作次数 ➍。在每次
    XOR 操作中，2 字节的加密数据与解密密钥进行异或运算，因此 `cx` 寄存器的值等于 `number_of_bytes_to_decrypt` 除以 2。
- en: The instructions in the decryption loop read 2 bytes from the source ➎, XOR
    them with the key ➏, and write the result in the destination buffer ➐. Once the
    decryption step is complete, a `jmp` instruction ➑ transfers control to the next
    basic block.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解密循环中的指令从源地址 ➎ 读取 2 个字节，将其与密钥 ➏ 做异或运算，并将结果写入目标缓冲区 ➐。解密步骤完成后，`jmp` 指令 ➑ 会将控制权转移到下一个基本块。
- en: Basic blocks 9 through 11 implement register initialization and transfer control
    to the decrypted code ([Listing 11-4](ch11.xhtml#ch11list04)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块 9 到 11 实现了寄存器初始化，并将控制权转交给解密代码（[列表 11-4](ch11.xhtml#ch11list04)）。
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-4: Basic blocks 9 through 11 of the polymorphic decryptor*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-4：多态解密器的基本块 9 到 11*'
- en: Instructions at ➊ store the decrypted IPL code that will execute after decryption
    on the stack address, and `retf` ➋ pops this address from the stack and transfers
    control to it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 ➊ 处的指令将解密后的 IPL 代码存储在栈地址中，`retf` ➋ 从栈中弹出该地址，并将控制权转移到该地址。
- en: To obtain the decrypted IPL code, we need to determine the address of the buffer
    for the decrypted data. To do so, we set up a breakpoint at address 0000:D970h
    right after instruction ➋ in [Listing 11-3](ch11.xhtml#ch11list03) and release
    control, as shown in [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取解密后的 IPL 代码，我们需要确定解密数据缓冲区的地址。为此，我们在 [列表 11-3](ch11.xhtml#ch11list03) 中的指令
    ➋ 后紧接着设置一个断点，地址为 0000:D970h，并释放控制，如 [图 11-10](ch11.xhtml#ch11fig10) 所示。
- en: '![image](../images/11fig10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig10.jpg)'
- en: '*Figure 11-10: Setting up a breakpoint in IDA Pro*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：在 IDA Pro 中设置断点*'
- en: Next, we’ll set up a breakpoint at address 0000:D98Eh (➋ in [Listing 11-4](ch11.xhtml#ch11list04)),
    the last instruction of the polymorphic decryptor, and let the rest of the decryptor
    code run. Once the debugger breaks at this address, we execute the last `retf`
    instruction, which brings us directly to the decrypted code at address 9EC0:0732h.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在地址 0000:D98Eh 处设置一个断点（[列表 11-4](ch11.xhtml#ch11list04)中的➋），这是多态解密器的最后一条指令，并让其余的解密器代码继续执行。一旦调试器在这个地址断开，我们执行最后的
    `retf` 指令，这会直接将我们引导到地址 9EC0:0732h 处的解密代码。
- en: At this point, the malicious IPL code is decrypted in memory and is available
    for further analysis. Note that, after decryption, the first routine of the malicious
    IPL is located not at the very beginning of the decrypted buffer at address 9EC0:0000h,
    but at offset 732h, due to the layout of the malicious IPL. If you want to dump
    the contents of the buffer from memory into a file on disk for static analysis,
    you should start dumping at address 9EC0:0000h, where the buffer starts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，恶意 IPL 代码已在内存中解密，可以进行进一步分析。请注意，解密后，恶意 IPL 的第一个例程并不位于解密缓冲区的开始处（地址 9EC0:0000h），而是位于偏移量
    732h 处，这是由于恶意 IPL 的布局。如果你想将缓冲区的内容从内存转储到磁盘文件以进行静态分析，你应该从地址 9EC0:0000h 开始转储，这里是缓冲区的起始位置。
- en: '***Taking Control by Patching the Windows Bootloader***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过修补 Windows 引导加载器来控制***'
- en: The main purpose of Rovnix’s IPL code is to load a malicious kernel-mode driver.
    The malicious boot code works in close collaboration with the OS bootloader components
    and follows the execution flow from the very beginning of the boot process, through
    the processor’s execution-mode switching, until the OS kernel is loaded. The loader
    relies heavily on the platform-debugging facilities and binary representations
    of the OS bootloader components.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 的 IPL 代码的主要目的是加载一个恶意的内核模式驱动程序。恶意引导代码与操作系统引导加载器组件紧密协作，并遵循从启动过程一开始，到处理器执行模式切换，再到操作系统内核加载的执行流程。加载器在很大程度上依赖于平台调试设施和操作系统引导加载器组件的二进制表示。
- en: Once the decrypted malicious IPL code is executed, it hooks the INT 13h handler
    so it can monitor all the data being read from the hard drive and set up further
    hooks in OS bootloader components. The malicious IPL then decompresses and returns
    control to the original IPL code to resume the normal boot process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解密后的恶意 IPL 代码执行，它会挂钩 INT 13h 处理程序，以便监控所有从硬盘读取的数据，并在操作系统引导加载器组件中设置进一步的钩子。恶意
    IPL 随后会解压，并将控制权交还给原始 IPL 代码，以继续正常的启动过程。
- en: '[Figure 11-11](ch11.xhtml#ch11fig11) depicts the steps Rovnix takes to interfere
    with the boot process and compromise the OS kernel. We’ve covered the steps up
    to the fourth box, so we’ll resume our description of the bootkit functionality
    from the “Load *bootmgr*” step at ➊.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-11](ch11.xhtml#ch11fig11) 展示了 Rovnix 干扰启动过程并危及操作系统内核的步骤。我们已经覆盖了前四个步骤，因此我们将从
    ➊ 处的“加载 *bootmgr*”步骤继续描述引导病毒的功能。'
- en: '![image](../images/11fig11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig11.jpg)'
- en: '*Figure 11-11: Boot process of Rovnix IPL code*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-11：Rovnix IPL代码的引导过程*'
- en: Once it has hooked the INT 13h handler, Rovnix monitors all data being read
    from the hard drive and looks for a certain byte pattern corresponding to the
    *bootmgr* of the OS. When Rovnix finds the matching pattern, it modifies the *bootmgr*
    ➋ to enable it to detect the switching of the processor from real to protected
    mode, which is a standard step in the boot process. This execution-mode switching
    changes the translation of the virtual address to physical and, as a result, changes
    the layout of the virtual memory, which would dislodge Rovnix. Therefore, in order
    to propagate itself through the switch and keep control of the boot process, Rovnix
    hooks *bootmgr* by patching it with a `jmp` instruction, allowing Rovnix to receive
    control right before the OS switches the execution mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦钩住了INT 13h处理程序，Rovnix监视所有从硬盘读取的数据，并寻找与操作系统的*bootmgr*对应的某个字节模式。当Rovnix找到匹配模式时，它会修改*bootmgr*
    ➋，使其能够检测处理器从实模式切换到保护模式，这是引导过程中的标准步骤。此执行模式切换改变了虚拟地址到物理地址的转换，因此改变了虚拟内存的布局，这会使Rovnix失效。因此，为了在切换过程中保持自身传播并控制引导过程，Rovnix通过在*bootmgr*中打补丁，插入`jmp`指令，使Rovnix能够在操作系统切换执行模式之前立即接管控制。
- en: Before moving on, we’ll explore how Rovnix hides its hooks and then look at
    how exactly it persists through the mode switching.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将探讨Rovnix如何隐藏其钩子，然后看它是如何通过模式切换保持持久性的。
- en: '**Abusing the Debugging Interface to Hide Hooks**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**滥用调试接口隐藏钩子**'
- en: One thing that makes Rovnix even more interesting than other bootkits is the
    stealth of its control hooks. It hooks the INT 1h handler ➌ to be able to receive
    control at specific moments during OS kernel initialization, and it abuses debugging
    registers `dr0` through `dr7` to set up hooks that avoid detection by leaving
    the code being hooked unaltered. The INT 1h handler is responsible for handling
    debugging events, such as tracing and setting hardware breakpoints, using the
    `dr0` through `dr7` registers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使Rovnix比其他引导工具更有趣的一件事是它的控制钩子的隐蔽性。它钩住了INT 1h处理程序 ➌，以便在操作系统内核初始化的特定时刻接管控制，并且它滥用调试寄存器`dr0`到`dr7`来设置钩子，从而避免通过不修改被钩住的代码来进行检测。INT
    1h处理程序负责处理调试事件，例如追踪和设置硬件断点，使用`dr0`到`dr7`寄存器。
- en: The eight debugging registers, `dr0` through `dr7`, provide hardware-based debugging
    support on Intel x86 and x64 platforms. The first four, `dr0` through `dr3`, are
    used to specify the linear addresses of breakpoints. The `dr7` register lets you
    selectively specify and enable the conditions for triggering breakpoints; for
    instance, you can use it to set up a breakpoint that triggers upon code execution
    or memory access (read/write) at a specific address. The `dr6` register is a status
    register that allows you to determine which debug condition has occurred—that
    is, which breakpoint has been triggered. The `dr4`^([1](footnotes.xhtml#ch11fn1))
    and `dr5` registers are reserved and not used. Once a hardware breakpoint is triggered,
    INT 1h is executed to determine which debug condition has occurred and respond
    accordingly to dispatch it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 八个调试寄存器，`dr0` 到 `dr7`，在Intel x86和x64平台上提供硬件级调试支持。前四个寄存器，`dr0` 到 `dr3`，用于指定断点的线性地址。`dr7`寄存器允许你选择性地指定并启用触发断点的条件；例如，你可以使用它来设置一个断点，当代码执行或在特定地址发生内存访问（读/写）时触发。`dr6`寄存器是一个状态寄存器，允许你确定哪个调试条件已发生——即，哪个断点被触发。`dr4`^([1](footnotes.xhtml#ch11fn1))
    和 `dr5`寄存器是保留的，不使用。一旦硬件断点被触发，INT 1h将被执行，以确定发生了哪个调试条件并做出相应响应。
- en: This is the functionality that enables the Rovnix bootkit to set up stealthy
    hooks without patching code. Rovnix sets the `dr0` through `dr4` registers to
    their intended hook location and enables hardware breakpoints for each register
    by setting a corresponding bitmask in the `dr7` register.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使Rovnix引导工具能够在不修改代码的情况下设置隐蔽钩子的功能。Rovnix将`dr0`到`dr4`寄存器设置为其预定的钩子位置，并通过在`dr7`寄存器中设置相应的位掩码，启用每个寄存器的硬件断点。
- en: '**Abusing the Interrupt Descriptor Table to Persist Through Boot**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**滥用中断描述符表实现引导过程中的持久性**'
- en: In addition to abusing the debugging facilities of the platform, the first iterations
    of Rovnix used an interesting technique to survive the processor’s switch from
    real to protected mode. Before execution switches to protected mode, *bootmgr*
    initializes important system structures, such as the Global Descriptor Table and
    Interrupt Descriptor Table (IDT). The latter is filled with descriptors of interrupt
    handlers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**INTERRUPT DESCRIPTOR TABLE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The IDT is a special system structure used by the CPU in protected mode to
    specify CPU interrupt handlers. In real mode, the IDT (also referred to as the
    *Interrupt Vector Table*, or *IVT*) is trivial—merely an array of 4-byte addresses
    of handlers, starting at address 0000:0000h. In other words, the address of the
    INT 0h handler is 0000:0000h, the address of the INT 1h handler is 0000:0004h,
    the address of the INT 2h handler is 0000:0008h, and so on. In protected mode,
    the IDT has a more complex layout: an array of 8-byte interrupt handler descriptors.
    The base address of the IDT can be obtained via the `sidt` processor instruction.
    For more information on IDT, refer to Intel’s documentation at *[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Rovnix copies the malicious IPL code over the second half of the IDT, which
    is not being used by the system at the moment. Given that each descriptor is 8
    bytes and there are 256 descriptors in the table, this provides Rovnix with 1KB
    of IDT memory, sufficient to store its malicious code. The IDT is in protected
    mode, so storing its code in the IDT ensures that Rovnix will persist across the
    mode switching, and the IDT address can be easily obtained via the `sidt` instruction.
    The overall layout of the IDT after Rovnix’s modifications is shown in [Figure
    11-12](ch11.xhtml#ch11fig12).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: How Rovnix abuses the IDT to propagate through execution-mode
    switching*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '***Loading the Malicious Kernel-Mode Driver***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After hooking the INT 1h handler, Rovnix proceeds with hooking other OS bootloader
    components, such as *winload.exe* and the OS kernel image (*ntoskrnl.exe*, for
    instance). Rovnix waits while the *bootmgr* code loads *winload.exe* and then
    hooks the `BlImgAllocateImageBuffer` routine (see ➍ in [Figure 11-11](ch11.xhtml#ch11fig11))
    to allocate a buffer for an executable image by setting up a hardware breakpoint
    at its starting address. This technique allocates memory to hold the malicious
    kernel-mode driver.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The malware also hooks the `OslArchTransferToKernel` routine in *winload.exe*.
    This routine transfers control from *winload.exe* to the kernel’s entry point
    `KiSystemStartup`, which starts kernel initialization. By hooking `OslArchTransferToKernel`,
    Rovnix gets control right before `KiSystemStartup` is called, and it takes this
    opportunity to inject the malicious kernel-mode driver.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The routine `KiSystemStartup` takes the single parameter `KeLoaderBlock`, which
    is a pointer to `LOADER_PARAMETER_BLOCK`—an undocumented structure initialized
    by *winload.exe* that contains important system information, such as boot options
    and loaded modules. The structure is shown in [Listing 11-5](ch11.xhtml#ch11list05).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-5: The `LOADER_PARAMETER_BLOCK` description*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Rovnix is interested in the field `BootDriverListHead` ➊, which contains the
    head of a list of special data structures corresponding to boot-mode drivers.
    These drivers are loaded by *winload.exe* at the same time that the kernel image
    is loaded. However, the `DriverEntry` routine that initializes the drivers isn’t
    called until after the OS kernel image receives control. The OS kernel initialization
    code traverses records in `BootDriverListHead` and calls the `DriverEntry` routine
    of the corresponding driver.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Once the `OslArchTransferToKernel` hook is triggered, Rovnix obtains the address
    of the `KeLoaderBlock` structure from the stack and inserts a record corresponding
    to the malicious driver into the boot driver list using the `BootDriverListHead`
    field. Now the malicious driver is loaded into memory as if it were a kernel-mode
    driver with a legitimate digital signature. Next, Rovnix transfers control to
    the `KiSystemStartup` routine, which resumes the boot process and starts kernel
    initialization (➎ in [Figure 11-11](ch11.xhtml#ch11fig11)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: At some point during initialization, the kernel traverses the list of boot drivers
    in `KeLoaderBlock` and calls their initialization routines, including that of
    the malicious driver ([Figure 11-13](ch11.xhtml#ch11fig13)). This is how the `DriverEntry`
    routine of the malicious kernel-mode driver is executed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: A malicious Rovnix driver inserted into `BootDriverList`*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel-Mode Driver Functionality**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main function of the malicious driver is to inject the payload, stored in
    the driver’s binary and compressed with aPlib as discussed earlier, into target
    processes in the system—primarily into *explorer.exe* and browsers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '***Injecting the Payload Module***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The payload module contains the code *JFA* in its signature, so to extract it,
    Rovnix looks for the JFA signature in a free space between the section table of
    the driver and its first section. This signature signifies the beginning of the
    configuration data block, an example of which is displayed in [Listing 11-6](ch11.xhtml#ch11list06).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-6: `PAYLOAD_CONFIGURATION_BLOCK` structure describing payload configuration*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The fields `PayloadRva` and `PayloadSize` specify the coordinates of the compressed
    payload image in the kernel-mode driver. The `ProcessNames` array contains names
    of the processes to inject the payload into. The number of entries in the array
    is specified by `NumberOfProcessNames`. [Figure 11-14](ch11.xhtml#ch11fig14) shows
    an example of such a data block taken from a real-world malicious kernel-mode
    driver. As you can see, the payload is to be injected into *explorer.exe* and
    the browsers *iexplore.exe*, *firefox.exe*, and *chrome.exe*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-14: A payload configuration block*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Rovnix first decompresses the payload into a memory buffer. Then it employs
    a conventional technique frequently used by rootkits to inject the payload, consisting
    of the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Register `CreateProcessNotifyRoutine` and `LoadImageNotifyRoutine` using the
    standard documented kernel-mode API. This permits Rovnix to gain control each
    time a new process is created or a new image is loaded into the address of a target
    process.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the new processes in the system and look for the target process, identified
    by the image name.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as the target process is loaded, map the payload into its address space
    and queue an *asynchronous procedure call (APC)*, which transfers control to the
    payload.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s examine this technique in more detail. The `CreateProcessNotify` routine
    allows Rovnix to install a special handler that’s triggered every time a new process
    is created on the system. This way, the malware is able to detect when a target
    process is launched. However, because the malicious create-process handler is
    triggered at the very beginning of process creation, when all the necessary system
    structures are already initialized but before the executable file of the target
    process is loaded into its address space, the malware isn’t able to inject the
    payload at this point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The second routine, `LoadImageNotifyRoutine`, allows Rovnix to set up a handler
    that’s triggered every time an executable module (*.exe* file, DLL library, and
    so forth) is loaded or unloaded on the system. This handler monitors the main
    executable image and notifies Rovnix once the image is loaded in the target process’s
    address space, at which point Rovnix injects the payload and executes it by creating
    an APC.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '***Stealth Self-Defense Mechanisms***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The kernel-mode driver implements the same defensive mechanisms as the TDL4
    bootkit: it hooks the `IRP_MJ_INTERNAL_CONTROL` handler of the hard disk miniport
    `DRIVER_OBJECT`. This handler is the lowest-level hardware-independent interface
    with access to data stored on the hard drive, providing the malware with a reliable
    way of controlling data being read from and written to the hard drive.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, Rovnix can intercept all the read/write requests and protect critical
    areas from being read or overwritten. To be specific, it protects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The infected IPL code
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stored kernel-mode driver
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hidden filesystem partition
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 11-7](ch11.xhtml#ch11list07) presents the pseudocode of the `IRP_MJ_INTERNAL_CONTROL`
    hook routine, which determines whether to block or authorize an I/O operation
    depending on which part of the hard drive is being read or written to.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-7: The pseudocode of a malicious `IRP_MJ_INTERNAL_CONTROL` handler*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: First the code checks whether the I/O request is addressed to the hard drive
    device object ➊. If so, the malware checks whether the operation is a read or
    write operation and which region of the hard drive is being accessed ➋. The routine
    `CheckSrbParams` ➌ returns `TRUE` when regions protected by the bootkit are being
    accessed. If someone tries to write data to the region protected by the bootkit,
    the code rejects the I/O operation and returns `STATUS_ACCESS_DENIED` ➍. If someone
    tries to read from the bootkit-protected region, the malware sets a malicious
    completion routine ➎ and passes the I/O request down to the hard drive device
    object for completing the read operation. Once the read operation finishes, the
    malicious completion routine is triggered and wipes the buffer containing the
    read data by writing zeros into it. This way, the malware protects its data on
    the hard drive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**The Hidden Filesystem**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another significant feature of Rovnix is its hidden filesystem (FS) partition
    (that is, one not visible to the operating system) that’s used to secretly store
    configuration data and additional payload modules. Implementation of hidden storage
    isn’t a new bootkit technique—it’s been used by other rootkits such as TDL4 and
    Olmasco—but Rovnix has a slightly different implementation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: To physically store its hidden partition, Rovnix occupies space either at the
    beginning or end of the hard drive, depending on where there’s enough free space;
    if there are 0x7D0 (2,000 in decimal, almost 1MB) or more free sectors before
    the first partition, Rovnix places the hidden partition right after the MBR sector
    and extends it over the entirety of the free 0x7D0 sectors. If there isn’t enough
    space at the beginning of the hard drive, Rovnix tries to place the hidden partition
    at its end. To access the data stored in the hidden partition, Rovnix uses the
    original `IRP_MJ_INTERNAL_CONTROL` handler, hooked as explained in the previous
    section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '***Formatting the Partition as a Virtual FAT System***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once Rovnix has allocated space for the hidden partition, it formats it as a
    *Virtual File Allocation Table (VFAT)* filesystem—a modification of the FAT filesystem
    capable of storing files with long Unicode filenames (up to 256 bytes). The original
    FAT filesystem imposes limitations on filename lengths of 8 + 3, meaning up to
    eight characters for a filename and three characters for an extension name.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '***Encrypting the Hidden Filesystem***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To protect the data in the hidden filesystem, Rovnix implements partition-transparent
    encryption with the RC6 encryption algorithm in Electronic Code Book (ECB) mode
    and a key length of 128 bits. In ECB mode, the data to be encrypted is split into
    blocks of equal lengths, each of which is encrypted with the same key independently
    of the other blocks. The key is stored in the last 16 bytes of the very first
    sector of the hidden partition, as shown in [Figure 11-15](ch11.xhtml#ch11fig15),
    and is used to encrypt and decrypt the whole partition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-15: Encryption key location in the first sector of the hidden partition*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**RC6**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Rivest cipher 6, or RC6, is a symmetric key block cipher designed by Ron Rivest,
    Matt Robshaw, Ray Sidney, and Yiqun Lisa Yin to meet the requirements of the *Advanced
    Encryption Standard (AES)* competition. RC6 has a block size of 128 bits and supports
    key sizes of 128, 192, and 256 bits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing the Hidden Filesystem***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the hidden filesystem accessible to the payload modules, Rovnix creates
    a special object called a *symbolic link*. Loosely speaking, the symbolic link
    is an alternative name for a hidden storage device object that can be used by
    modules in user-mode processes. Rovnix generates the string `\DosDevices\<`XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`>`,
    where X is a randomly generated hexadecimal number, from 0 to F, that’s used as
    the symbolic link name for the hidden storage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of the hidden filesystem is that it may be accessed as a regular
    filesystem through the standard Win32 API functions provided by the operating
    system, such as `CreateFile`, `CloseFile`, `ReadFile`, or `WriteFile`. For instance,
    to create the file *file_to_create* in the root directory of the hidden filesystem,
    a malicious payload calls `CreateFile`, passing the symbolic link string `\DosDevices\<%`XXXXXXXX`-`XXXX`-`XXXX`-`XXXX`-`XXXXXXXXXXXX`>\file_to_create`
    as a filename parameter. Once the payload module issues this call, the operating
    system redirects the request to the malicious kernel-mode driver responsible for
    handling requests for the hidden filesystem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-16](ch11.xhtml#ch11fig16) shows how the malicious driver implements
    the filesystem driver functionality. Once it receives an I/O request from the
    payload, Rovnix dispatches the request using the hooked hard drive handler to
    perform read and write operations for the hidden filesystem located on the hard
    drive.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig16.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-16: Architecture of the Rovnix hidden storage filesystem*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, the operating system and the malicious hidden filesystem coexist
    on the same hard drive, but the operating system isn’t aware of the hard drive
    region used to store the hidden data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The malicious hidden filesystem potentially could alter legitimate data being
    stored on the operating system’s filesystem, but the chances of that are low due
    to the hidden filesystem’s placement at the beginning or end of the hard drive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '**The Hidden Communication Channel**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rovnix has further stealth tricks up its sleeve. The Rovnix kernel-mode driver
    implements a TCP/IP protocol stack to communicate secretly with remote C&C servers.
    The network interfaces provided by the OS are frequently hooked by security software
    in order to monitor and control network traffic passing through the network. Instead
    of relying on these network interfaces and risk detection by the security software,
    Rovnix uses its own custom implementation of network protocols, independent of
    the operating system, to download payload modules from C&C servers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to send and receive data over this network, the Rovnix kernel-mode
    driver implements a complete network stack, including the following interfaces:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft *Network Driver Interface Specification (NDIS)* miniport interface
    to send data packets using a physical network Ethernet interface
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport Driver Interface for TCP/IP network protocols
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket interface
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP protocol to communicate with remote C&C servers
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown in [Figure 11-17](ch11.xhtml#ch11fig17), the NDIS miniport layer is
    responsible for communicating with the network interface card to send and receive
    network packets. The Transport Driver Interface provides a TCP/IP interface for
    the upper-level socket interface, which in turn is used by Rovnix’s HTTP protocol
    to transmit data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig17.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-17: Architecture of Rovnix custom network stack implementation*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Rovnix’s creators didn’t develop this hidden network communication system from
    scratch—such an implementation requires thousands of lines of code and thus is
    prone to errors. Instead, they based their implementation on an open source, lightweight
    TCP/IP network library called lwIP. The lwIP library is a small, independent implementation
    of the TCP/IP protocol suite with a focus on reducing resource usage while still
    delivering a full-scale TCP/IP stack. According to its website, lwIP has a footprint
    of tens of kilobytes of RAM and around 40KB of code, which fits the bootkit perfectly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Features like the hidden communication channel allow Rovnix to bypass local
    network monitoring security software. Since Rovnix comes with its own network
    protocol stack, network security software is unaware of—and thus unable to monitor—its
    communications over the network. From the very top of the protocol layer down
    to the very bottom of the NDIS miniport driver, Rovnix uses only its own network
    components, making it a very stealthy bootkit.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Case History: The Carberp Connection**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One real-world example of Rovnix being used in the wild is in the Carberp trojan
    malware, developed by the most prominent cybercrime group in Russia. Carberp was
    used to allow a banking trojan to persist on the victim’s system.^([2](footnotes.xhtml#ch11fn2))
    We’ll look at a few aspects of Carberp and how it was developed from the Rovnix
    bootkit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**CARBERP-RELATED MALWARE**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'It was estimated that the group that developed Carberp earned an average weekly
    income of several million US dollars and invested heavily in other malware technologies,
    such as the Hodprot dropper,^([1](ch11.xhtml#ch11sfn1)) which has been implicated
    in installations of Carberp, RDPdoor, and Sheldor.^([2](ch11.xhtml#ch11sfn2))
    RDPdoor was especially malicious: it installed Carberp in order to open a backdoor
    in the infected system and manually perform fraudulent banking transactions.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[1](ch11.xhtml#ch11sfn1a). *[https://www.welivesecurity.com/media_files/white-papers/Hodprot-Report.pdf](https://www.welivesecurity.com/media_files/white-papers/Hodprot-Report.pdf)*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[2](ch11.xhtml#ch11sfn2a). *[https://www.welivesecurity.com/2011/01/14/sheldor-shocked/](https://www.welivesecurity.com/2011/01/14/sheldor-shocked/)*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '***Development of Carberp***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In November 2011, we noticed that one of the C&C servers set up by the cybercrime
    group behind Carberp started distributing a dropper with a bootkit based on the
    Rovnix framework. We started tracking the Carberp trojan and found that during
    this period, its distribution was very limited.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Two things in our analysis suggested that the bot was working in test mode and
    therefore being actively developed. The first clue was an abundance of debugging
    and tracing information relating to the bot’s installation and the binary’s behavior.
    The second, which we discovered by gaining access to logfiles from the bot C&C
    server, was that masses of information on failures in installation were being
    sent back to the C&C. [Figure 11-18](ch11.xhtml#ch11fig18) shows an example of
    the kind of information Carberp was reporting.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig18.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-18: An example of Rovnix dropper logs*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The ID column specifies a unique identifier of a Rovnix instance; the status
    column contains information on whether the victim’s system has been successfully
    compromised. The infection algorithm was split into a number of steps, and information
    was reported to the C&C server directly after each step. The step column provides
    information on which step is being executed, and the info column contains a description
    of any error encountered during installation. By looking at the step and info
    columns, operators of the botnet could determine at which step and for what reason
    the infection failed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The version of Rovnix that Carberp used contained a lot of debugging strings
    and sent a lot of verbose messages to the C&C. [Figure 11-19](ch11.xhtml#ch11fig19)
    shows examples of the kind of strings it might send. This information was extremely
    useful to us in analyzing this threat and understanding its functionality. The
    debugging information left in the binary revealed the names of the routines implemented
    in the binary and their purpose. It documented the logic of the code. Using this
    data, we could more easily reconstruct the context of the malicious code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/11fig19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-19: Debug strings left by developers in the Rovnix dropper*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '***Dropper Enhancements***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The framework of Rovnix used in Carberp was pretty much the same as the bootkit
    we described in the beginning of the chapter, with the only significant change
    appearing in the dropper. In “[Infecting the System](ch07.xhtml#ch07lev3sec1)”
    on [page 150](ch11.xhtml#page_150), we mentioned that Rovnix tries to elevate
    its privileges by using the `ShellExecuteEx` Win32 API to achieve administrator
    rights on the victim’s machine. In Carberp’s version of Rovnix, the dropper exploited
    the following vulnerabilities in the system to elevate privileges:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**MS10-073 in the *win32k.sys* module** This vulnerability was originally used
    by the Stuxnet worm and exploits the incorrect handling of a specially crafted
    keyboard layout file.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**MS10-092 in Windows Task Scheduler** This vulnerability was also first discovered
    in Stuxnet and exploits the integrity verification mechanism in Windows Scheduler.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**MS11-011 in the *win32k.sys* module** This vulnerability results in a stack-based
    buffer overflow in `win32k.sys!RtlQueryRegistryValues` routine.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Runtime Optimization vulnerability** This is a vulnerability in the
    Microsoft .NET Runtime Optimization Service that results in execution of malicious
    code with SYSTEM privileges.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Yet another interesting feature of the Carberp installer is that it removed
    various hooks from the list of system routines, shown in [Listing 11-8](ch11.xhtml#ch11list08),
    just before installing the trojan or bootkit onto the system. These routines are
    common hook targets for security software, such as sandboxes and host intrusion
    prevention and protection systems. By unhooking these functions, the malware increased
    its ability to evade detection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-8: List of routines unhooked by the Rovnix dropper*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The bootkit and kernel-mode driver sections of the Carberp’s Rovnix modification
    remain the same as in the original version of the bootkit. After successful installation
    onto the system, the malicious IPL code loaded the kernel-mode driver, and the
    driver injected its Carberp trojan payload into the system processes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***Leaked Source Code***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In June 2013, the source code for Carberp and Rovnix was leaked to the public.
    The complete archive was made available for download and contained all the necessary
    source code for attackers to build their own Rovnix bootkit. Despite this, we
    haven’t seen as many custom modifications of Rovnix and Carberp in the wild as
    we might expect, which we assume is due to the complexity of this bootkit technology.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter provided a detailed technical analysis of Rovnix in the continuous
    bootkit arms race facing the security industry. Once security software caught
    up with contemporary bootkits infecting the MBR, Rovnix presented another infection
    vector, the IPL, triggering another round of evolution in antivirus technology.
    Due to its IPL infection approach, and its implementation of hidden storage and
    hidden network communication channels, Rovnix is one of the most complex bootkits
    seen in the wild. These features make it a dangerous weapon in the hands of cybercriminals,
    as confirmed by the Carberp case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we devoted special attention to dissecting Rovnix’s IPL code
    using VMware and IDA Pro, demonstrating the practical usage of these tools in
    the context of bootkit analysis. You can download all the necessary data to repeat
    the steps, or to conduct your own in-depth investigation into Rovnix’s IPL code,
    from *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
