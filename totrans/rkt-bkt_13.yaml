- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: 'IPL BOOTKITS: ROVNIX AND CARBERP**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: IPL引导工具：ROVNIX和CARBERP**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Distribution of Rovnix, the first known bootkit to infect the IPL code of the
    active partition on a bootable hard drive, began at the end of 2011\. Security
    products at that time had already evolved to monitor the MBR, as discussed in
    [Chapter 10](ch10.xhtml#ch10), to protect against bootkits such as TDL4 and Olmasco.
    The appearance of Rovnix in the wild was therefore a challenge for security software.
    Because Rovnix went further in the boot process and infected the IPL code that
    executed after the VBR code (see [Chapter 5](ch05.xhtml#ch05)), it stayed under
    the radar for a few months until the security industry managed to catch up.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix的分发始于2011年底，这是第一个已知的感染可启动硬盘的活动分区IPL代码的引导工具。当时的安全产品已经进化到能够监控MBR，如[第10章](ch10.xhtml#ch10)中所讨论的，用以防御如TDL4和Olmasco等引导工具。因此，Rovnix的出现对安全软件构成了挑战。由于Rovnix进一步深入了引导过程，感染了在VBR代码之后执行的IPL代码（见[第5章](ch05.xhtml#ch05)），它在几个月内未被察觉，直到安全行业跟进。
- en: 'In this chapter, we’ll focus on the technical details of the Rovnix bootkit
    framework by studying how it infects target systems and bypasses the Kernel-Mode
    Signing Policy to load the malicious kernel-mode driver. We’ll pay special attention
    to the malicious IPL code, and we’ll debug it using VMware and the IDA Pro GDB,
    as discussed in [Chapter 9](ch09.xhtml#ch09). Finally, we’ll see an implementation
    of Rovnix in the wild: the Carberp banking trojan, which used a modification of
    Rovnix to persist on victims’ machines.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过研究Rovnix如何感染目标系统并绕过内核模式签名策略来加载恶意内核模式驱动程序，专注于Rovnix引导工具框架的技术细节。我们将特别关注恶意IPL代码，并使用VMware和IDA
    Pro GDB进行调试，如[第9章](ch09.xhtml#ch09)所讨论的。最后，我们将看到Rovnix在野外的实现：Carberp银行木马，它使用了Rovnix的修改版本在受害者机器上保持持久性。
- en: '**Rovnix’s Evolution**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Rovnix的演变**'
- en: Rovnix was first advertised on a private underground forum, shown in [Figure
    11-1](ch11.xhtml#ch11fig01), as a new Ring0 bundle with extensive functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix首次在一个私人地下论坛上广告宣传，如[图11-1](ch11.xhtml#ch11fig01)所示，作为一个具有广泛功能的新Ring0捆绑软件。
- en: '![image](../images/11fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig01.jpg)'
- en: '*Figure 11-1: Rovnix advertisement on a private underground forum*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：Rovnix在私人地下论坛上的广告*'
- en: It had a modular architecture that made it very attractive for malware developers
    and distributors. It seems likely that its developers were more focused on selling
    the framework than on distributing and using the malware.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有模块化架构，这使其对恶意软件开发者和分发者非常有吸引力。开发者似乎更专注于销售该框架，而不是分发和使用恶意软件。
- en: Since its first appearance in the wild, Rovnix has gone through multiple iterations.
    This chapter will focus on the latest generation at the time of this writing,
    but we’ll touch on the earlier versions to give you an idea of its development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自首次在野外出现以来，Rovnix经历了多个迭代。本章将重点介绍撰写时的最新版本，但我们也会提及早期版本，以帮助你了解其发展过程。
- en: The first iterations of Rovnix used a simple IPL infector to inject a payload
    into the user-mode address space of the boot processes. The malicious IPL code
    was the same in all early iterations, so the security industry was able to quickly
    develop detection methods using simple static signatures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix的早期版本使用简单的IPL感染器，将有效负载注入到引导进程的用户模式地址空间中。所有早期版本的恶意IPL代码相同，因此安全行业能够迅速开发出使用简单静态签名的检测方法。
- en: 'The next versions of Rovnix rendered these detection methods ineffectual by
    implementing *polymorphic* malicious IPL code. Rovnix also added another new feature:
    a hidden filesystem to secretly store its configuration data, payload modules,
    and so on. Inspired by TDL4-like bootkits, Rovnix also began implementing functionality
    that monitored read and write requests to the infected hard drive, making it harder
    to remove the malware from the system.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix的后续版本通过实施*多态*恶意IPL代码，使这些检测方法变得无效。Rovnix还增加了一个新特性：一个隐藏的文件系统，用于秘密存储其配置数据、有效负载模块等。受到类似TDL4引导工具的启发，Rovnix还开始实现监控对感染硬盘的读写请求的功能，从而使得从系统中移除恶意软件变得更加困难。
- en: A later iteration added a hidden communication channel to allow Rovnix to exchange
    data with remote C&C servers and bypass the traffic monitoring performed by personal
    firewalls and Host Intrusion Prevention Systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 后来的一个版本添加了一个隐藏的通信通道，使Rovnix能够与远程C&C服务器交换数据，并绕过个人防火墙和主机入侵防护系统（HIPS）执行的流量监控。
- en: At this point, we’ll turn our attention to the latest known modifications of
    Rovnix (also known as Win32/Rovnix.D) at the time of this writing and discuss
    its features in detail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将把注意力转向本写作时已知的最新 Rovnix 修改版本（也称为 Win32/Rovnix.D），并详细讨论其特性。
- en: '**The Bootkit Architecture**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Bootkit 架构**'
- en: First we’ll consider the Rovnix architecture from a high-level point of view.
    [Figure 11-2](ch11.xhtml#ch11fig02) shows the main components of Rovnix and how
    they relate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从高层次角度考虑 Rovnix 的架构。[图 11-2](ch11.xhtml#ch11fig02)展示了 Rovnix 的主要组件及其相互关系。
- en: '![image](../images/11fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig02.jpg)'
- en: '*Figure 11-2: Rovnix architecture*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：Rovnix 架构*'
- en: At the heart of Rovnix lies a malicious kernel-mode driver, the main purpose
    of which is to inject payload modules into processes in the system. Rovnix can
    hold multiple payloads for injection into different processes. An example of such
    a payload is a banking trojan that creates fake transactions, like the Carberp
    trojan discussed later in this chapter. Rovnix has a default payload module hardcoded
    into the malicious kernel-mode driver, but it is capable of downloading additional
    modules from remote C&C servers through the hidden network channel (discussed
    in “[The Hidden Communication Channel](ch11.xhtml#ch11lev1sec7)” on [page 169](ch11.xhtml#page_169)).
    The kernel-mode driver also implements hidden storage to store downloaded payloads
    and configuration information (covered in detail in “[The Hidden Filesystem](ch01.xhtml#ch01lev1sec4)”
    on [page 167](ch11.xhtml#page_167)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 的核心是一种恶意的内核模式驱动程序，其主要目的是将有效负载模块注入系统中的进程。Rovnix 可以持有多个有效负载，以便注入到不同的进程中。一个这样的有效负载示例是银行木马，它创建伪造交易，如本章后面讨论的
    Carberp 木马。Rovnix 默认在恶意内核模式驱动程序中硬编码了一个有效负载模块，但它能够通过隐藏的网络通道（在 “[隐藏通信通道](ch11.xhtml#ch11lev1sec7)”
    章节的 [第169页](ch11.xhtml#page_169)中讨论）从远程 C&C 服务器下载额外的模块。内核模式驱动程序还实现了隐藏存储，用于存储下载的有效负载和配置信息（在
    “[隐藏文件系统](ch01.xhtml#ch01lev1sec4)” 章节的 [第167页](ch11.xhtml#page_167)中有详细讨论）。
- en: '**Infecting the System**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**感染系统**'
- en: Let’s continue our analysis of Rovnix by dissecting its infection algorithm,
    depicted in [Figure 11-3](ch11.xhtml#ch11fig03).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续分析 Rovnix，通过剖析其感染算法，如[图 11-3](ch11.xhtml#ch11fig03)所示。
- en: '![image](../images/11fig03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig03.jpg)'
- en: '*Figure 11-3: Rovnix dropper infection algorithm*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：Rovnix 投放器感染算法*'
- en: Rovnix first checks if the system has already been infected by accessing the
    system registry key *HKLM\Software\Classes\CLSID\<XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX>*,
    where *X* is generated from the filesystem volume serial number. If this registry
    key exists, it means the system is already infected with Rovnix, so the malware
    terminates and deletes itself from the system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 首先通过访问系统注册表项 *HKLM\Software\Classes\CLSID\<XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX>*
    来检查系统是否已被感染，其中 *X* 是根据文件系统卷序列号生成的。如果此注册表项存在，则意味着系统已经被 Rovnix 感染，恶意软件会终止并从系统中删除自身。
- en: If the system is not already infected, Rovnix queries the version of the operating
    system. To gain low-level access to the hard drive, the malware requires administrator
    privileges. In Windows XP, the regular user is granted administrator rights by
    default, so if the OS is XP, Rovnix can proceed as a regular user without having
    to check privileges.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统尚未感染，Rovnix 会查询操作系统的版本。为了获得硬盘的低级访问权限，恶意软件需要管理员权限。在 Windows XP 中，普通用户默认被授予管理员权限，因此如果操作系统是
    XP，Rovnix 可以作为普通用户继续运行，而无需检查权限。
- en: However, in Windows Vista, Microsoft introduced a new security feature—*User
    Account Control (UAC)*—that demotes the privileges of applications running under
    the administrator account, so if the OS is Vista or above, Rovnix has to check
    administrative privileges. If the dropper is running without administrative privileges,
    Rovnix tries to elevate the privileges by relaunching itself with the `ShellExecuteEx`
    API using the `runas` command. The dropper’s manifest contains a `requireAdministrator`
    property, so `runas` attempts to execute the dropper with elevated privileges.
    On systems with UAC enabled, a dialog displays, asking the user whether they authorize
    the program to run with administrator privileges. If the user chooses Yes, the
    malware starts with elevated privileges and infects the system. If the user chooses
    No, the malware will not be executed. If there is no UAC on a system or if UAC
    is disabled, the malware just runs with the privileges of the current account.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Windows Vista 中，微软引入了一个新的安全功能——*用户帐户控制（UAC）*——它会降低以管理员帐户运行的应用程序的权限。因此，如果操作系统是
    Vista 或更高版本，Rovnix 需要检查管理员权限。如果没有管理员权限运行，Rovnix 会通过使用 `ShellExecuteEx` API 和 `runas`
    命令重新启动自身以提升权限。启动器的清单包含一个 `requireAdministrator` 属性，因此 `runas` 尝试以提升的权限执行启动器。在启用了
    UAC 的系统上，会弹出一个对话框，询问用户是否授权程序以管理员权限运行。如果用户选择“是”，恶意软件将以提升的权限启动并感染系统。如果用户选择“否”，恶意软件将不会执行。如果系统没有启用
    UAC 或 UAC 被禁用，恶意软件将以当前帐户的权限运行。
- en: Once it has the required privileges, Rovnix gains low-level access to the hard
    drive by using the native API functions `ZwOpenFile`, `ZwReadFile`, and `ZwWriteFile`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得所需的权限，Rovnix 通过使用本地 API 函数 `ZwOpenFile`、`ZwReadFile` 和 `ZwWriteFile` 获取对硬盘的低级访问权限。
- en: First the malware calls `ZwOpenFile` using *\??\PhysicalDrive0* as a filename,
    which returns a handle corresponding to the hard drive. Rovnix then uses the returned
    handle with the `ZwReadFile` and `ZwWriteFile` routines to read data from and
    write data to the hard drive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先使用 `ZwOpenFile` 调用 *\??\PhysicalDrive0* 作为文件名，返回一个与硬盘对应的句柄。然后，Rovnix 使用返回的句柄与
    `ZwReadFile` 和 `ZwWriteFile` 函数来读取和写入硬盘上的数据。
- en: To infect the system, the malware scans the partition table in the MBR of the
    hard drive, and then reads the IPL of the active partition and reduces its size
    with the aPlib compression library. Next, Rovnix creates a new malicious IPL by
    prepending the compressed legitimate IPL with malicious loader code, as shown
    in [Figure 11-4](ch11.xhtml#ch11fig04).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感染系统，恶意软件扫描硬盘的 MBR 中的分区表，然后读取活动分区的 IPL，并通过 aPlib 压缩库减小其大小。接下来，Rovnix 通过将恶意加载程序代码附加到压缩后的合法
    IPL 前面，创建一个新的恶意 IPL，如 [图 11-4](ch11.xhtml#ch11fig04) 所示。
- en: '![image](../images/11fig04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig04.jpg)'
- en: '*Figure 11-4: Hard drive layout before and after Rovnix infection*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：Rovnix 感染前后的硬盘布局*'
- en: After modifying the IPL, Rovnix writes a malicious kernel-mode driver at the
    end of the hard drive to be loaded by the malicious IPL code during system start-up.
    The malware reserves some space at the end of the hard drive for the hidden filesystem,
    which we’ll describe later in the chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改 IPL 后，Rovnix 将一个恶意的内核模式驱动程序写入硬盘的末尾，供恶意的 IPL 代码在系统启动时加载。该恶意软件在硬盘的末尾保留了一些空间，用于隐藏的文件系统，稍后我们将在本章中详细描述。
- en: '**APLIB**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**APLIB**'
- en: aPlib is a small compression library used primarily for compressing executable
    code. It’s based on the compression algorithm used in aPack software for packing
    executable files. One of the library’s distinguishing features is a good compression:speed
    ratio and tiny depacker footprint, which is especially important in the preboot
    environment since it has only a small amount of memory. The aPlib compression
    library is also frequently used in malware to pack and obfuscate the payload.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: aPlib 是一个小型压缩库，主要用于压缩可执行代码。它基于用于打包可执行文件的 aPack 软件中的压缩算法。该库的一个显著特点是具有良好的压缩：速度比，并且解压器占用空间小，这在启动前环境中尤其重要，因为该环境内存较小。aPlib
    压缩库在恶意软件中也被广泛用于打包和混淆有效载荷。
- en: Finally, Rovnix creates the system registry key to mark the system as infected
    and initiates a restart by calling `ExitWindowsEx` Win32 API with the parameters
    `EWX_REBOOT | EWX_FORCE`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Rovnix 创建了系统注册表项，以标记系统为已感染，并通过调用 `ExitWindowsEx` Win32 API，并使用参数 `EWX_REBOOT
    | EWX_FORCE` 发起重启。
- en: '**Post-Infection Boot Process and IPL**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**感染后启动过程与 IPL**'
- en: Once Rovnix infects the machine and forces a reboot, the BIOS boot code carries
    on as usual, loading and executing the bootable hard drive’s unmodified MBR. The
    MBR finds an active partition on the hard drive and executes the legitimate, unmodified
    VBR. The VBR then loads and executes the infected IPL code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Rovnix 感染了机器并强制重启，BIOS 启动代码照常继续，加载并执行启动硬盘上未修改的 MBR。MBR 找到硬盘上的活动分区，并执行合法且未修改的
    VBR。VBR 随后加载并执行感染的 IPL 代码。
- en: '***Implementing the Polymorphic Decryptor***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现多态解密器***'
- en: The infected IPL begins with a small decryptor whose purpose is to decrypt the
    rest of the malicious IPL code and execute it ([Figure 11-5](ch11.xhtml#ch11fig05)).
    The fact that the decryptor is polymorphic means that each instance of Rovnix
    comes with custom decryptor code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 被感染的 IPL 以一个小的解密器开始，其目的是解密其余的恶意 IPL 代码并执行它（[图 11-5](ch11.xhtml#ch11fig05)）。解密器的多态性意味着每个
    Rovnix 实例都带有定制的解密器代码。
- en: '![image](../images/11fig05.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig05.jpg)'
- en: '*Figure 11-5: Layout of the infected IPL*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：感染的 IPL 布局*'
- en: 'Let’s take a look at how the decryptor is implemented. We’ll give a general
    description of the decryption algorithm before analyzing the actual polymorphic
    code. The decryptor follows this process to decrypt the content of the malicious
    IPL:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解密器是如何实现的。在分析实际的多态代码之前，我们将先给出解密算法的一般描述。解密器按以下流程解密恶意 IPL 的内容：
- en: Allocate a memory buffer to store decrypted code.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配内存缓冲区来存储解密后的代码。
- en: Initialize the decryption key and decryption counters—the offset and size of
    the encrypted data, respectively.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化解密密钥和解密计数器——分别是加密数据的偏移量和大小。
- en: Decrypt the IPL code into the allocated buffer.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 IPL 代码解密到已分配的缓冲区中。
- en: Initialize registers before executing the decrypted code.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行解密后的代码之前初始化寄存器。
- en: Transfer control to the decrypted code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控制权转移到解密后的代码。
- en: In order to customize the decryption routine, Rovnix randomly splits it into
    *basic blocks* (sets of continuous instructions with no branches), each of which
    contains a small number of assembly instructions for the routine. Rovnix then
    shuffles the basic blocks and reorders them randomly, connecting them using `jmp`
    instructions, as shown in [Figure 11-6](ch11.xhtml#ch11fig06). The result is a
    custom decryption code for every instance of Rovnix.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定制解密例程，Rovnix 随机将其拆分成 *基本块*（一组没有分支的连续指令），每个基本块包含少量的汇编指令。然后 Rovnix 将这些基本块进行洗牌并随机重新排序，通过
    `jmp` 指令连接它们，如[图 11-6](ch11.xhtml#ch11fig06)所示。结果是每个 Rovnix 实例都有一个定制的解密代码。
- en: '![image](../images/11fig06.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig06.jpg)'
- en: '*Figure 11-6: Generation of polymorphic decryptor*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：多态解密器的生成*'
- en: This polymorphic mechanism is actually quite simple compared to some other code
    obfuscation techniques employed in modern malware, but because the byte pattern
    of the routine changes with every instance of Rovnix, it’s sufficient for avoiding
    detection by security software that uses static signatures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多态机制与一些现代恶意软件中采用的代码混淆技术相比其实相当简单，但由于每次 Rovnix 的实例中例程的字节模式都会变化，它足以避免使用静态签名的安全软件检测。
- en: Polymorphism is not invulnerable, though, and one of the most common approaches
    to defeating it is software emulation. In emulation, security software applies
    behavioral patterns to detect malware.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性并非无懈可击，其中一种最常见的应对方法是软件仿真。在仿真中，安全软件应用行为模式来检测恶意软件。
- en: '***Decrypting the Rovnix Bootloader with VMware and IDA Pro***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 VMware 和 IDA Pro 解密 Rovnix 启动加载程序***'
- en: Let’s take a look at the actual implementation of the decryption routine using
    a VMware virtual machine and IDA Pro. All the necessary information on how to
    set up VMware with IDA Pro can be found in [Chapter 9](ch09.xhtml#ch09). In this
    demonstration, we’ll use a VMware image preinfected with the Win32/Rovnix.D bootkit,
    which you can download from *[https://nostarch.com/rootkits](https://nostarch.com/rootkits)*
    as the file *bootkit_files.zip.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用 VMware 虚拟机和 IDA Pro 的实际解密例程实现。关于如何设置 VMware 和 IDA Pro 的所有必要信息，可以在[第9章](ch09.xhtml#ch09)中找到。在本示范中，我们将使用一个已感染
    Win32/Rovnix.D 启动木马的 VMware 镜像，你可以从 *[https://nostarch.com/rootkits](https://nostarch.com/rootkits)*
    下载该文件 *bootkit_files.zip*。
- en: Our goal is to obtain the decrypted malicious IPL code using dynamic analysis.
    We’ll walk you through the debugging process, skipping quickly through the MBR
    and VBR steps to focus on analyzing the polymorphic IPL decryptor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过动态分析获取解密后的恶意 IPL 代码。我们将引导你完成调试过程，快速跳过 MBR 和 VBR 步骤，重点分析多态 IPL 解密程序。
- en: '**Observing the MBR and VBR Code**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**观察 MBR 和 VBR 代码**'
- en: Flip back to “[Combining VMware GDB with IDA](ch09.xhtml#ch09lev2sec7)” on [page
    126](ch09.xhtml#page_126) and follow the steps there to decrypt the MBR from *bootkit_files.zip*.
    You’ll find the MBR code located at address 0000:7c00h. In [Figure 11-7](ch11.xhtml#ch11fig07),
    the address 0000:7c00h is denoted as `MEMORY:7c00h` because IDA Pro displays the
    segment name (in our case, `MEMORY`) instead of the segment base address 0000h.
    Because Rovnix infects the IPL code and not the MBR, the MBR code shown in the
    debugger is legitimate and we won’t dig into it very deeply.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 “[将 VMware GDB 与 IDA 结合使用](ch09.xhtml#ch09lev2sec7)” 第[126页](ch09.xhtml#page_126)，并按照那里的步骤解密来自
    *bootkit_files.zip* 的 MBR。你会在地址 0000:7c00h 处找到 MBR 代码。在[图 11-7](ch11.xhtml#ch11fig07)中，地址
    0000:7c00h 被表示为 `MEMORY:7c00h`，因为 IDA Pro 显示的是段名（在我们的例子中是 `MEMORY`），而不是段基址 0000h。由于
    Rovnix 感染的是 IPL 代码而不是 MBR，调试器中显示的 MBR 代码是合法的，我们不需要深入研究它。
- en: '![image](../images/11fig07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig07.jpg)'
- en: '*Figure 11-7: The beginning of the MBR code*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：MBR 代码的开头*'
- en: This routine code relocates the MBR to another memory address to recycle the
    memory located at 0000:7c00h, in order to read and store the VBR of the active
    partition. Register `si` ➋ is initialized with the value `7C1h`, which corresponds
    to the source address, and register `di` ➌ is initialized with the value `61Bh`,
    the destination address. Register `cx` ➍ is initialized with `1E5h`, the number
    of bytes to copy, and the `rep movsb` instruction ➎ copies the bytes. The `retf`
    instruction ➏ transfers control to the copied code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序代码将 MBR 移动到另一个内存地址，以回收位于 0000:7c00h 的内存，用于读取和存储活动分区的 VBR。寄存器 `si` ➋ 被初始化为值
    `7C1h`，对应源地址，寄存器 `di` ➌ 被初始化为值 `61Bh`，对应目标地址。寄存器 `cx` ➍ 被初始化为 `1E5h`，即要复制的字节数，`rep
    movsb` 指令 ➎ 执行字节复制。`retf` 指令 ➏ 将控制转移到复制后的代码。
- en: At this point, the instruction pointer register `ip` points at address 0000:7c00h
    ➊. Execute each instruction in the listing by pressing **F8** until you reach
    the last `retf` instruction ➏. Once `retf` is executed, control is transferred
    to the code that has just been copied to address 0000:061Bh—namely, the main MBR
    routine, whose purpose is to find the active partition in the MBR’s partition
    table and load its very first sector, the VBR.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，指令指针寄存器 `ip` 指向地址 0000:7c00h ➊。通过按 **F8** 执行列出的每条指令，直到到达最后一条 `retf` 指令 ➏。执行
    `retf` 后，控制转移到刚刚复制到地址 0000:061Bh 的代码——即主 MBR 程序，其目的是查找 MBR 分区表中活动分区并加载其第一个扇区，即
    VBR。
- en: The VBR also remains unchanged, so we’ll proceed to the next step by setting
    up a breakpoint right at the end of the routine. The `retf` instruction located
    at address 0000:069Ah transfers control directly to the VBR code of the active
    partition, so we’ll put the breakpoint at the `retf` instruction (highlighted
    in [Figure 11-8](ch11.xhtml#ch11fig08)). Move your cursor to this address and
    press **F2** to toggle the breakpoint. If you see a dialog upon pressing F2, just
    click **OK** to use the default values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 也保持不变，因此我们将继续下一步，直接在该程序的末尾设置断点。位于地址 0000:069Ah 的 `retf` 指令将控制直接转移到活动分区的
    VBR 代码，因此我们将在 `retf` 指令处设置断点（如[图 11-8](ch11.xhtml#ch11fig08)所示）。将光标移动到该地址，按 **F2**
    切换断点。如果按 F2 后出现对话框，只需点击 **OK** 以使用默认值。
- en: '![image](../images/11fig08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig08.jpg)'
- en: '*Figure 11-8: Setting a breakpoint at the end of the MBR code*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：在 MBR 代码的末尾设置断点*'
- en: Once you’ve set the breakpoint, press **F9** to continue the analysis up to
    the breakpoint. This will execute the main MBR routine. When execution reaches
    the breakpoint, the VBR is already read into memory and we can get to it by executing
    the `retf` (F8) instruction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点后，按 **F9** 继续分析，直到达到断点。这将执行主 MBR 程序。当执行到达断点时，VBR 已经被读取到内存中，我们可以通过执行 `retf`（F8）指令来进入
    VBR。
- en: The VBR code starts with a `jmp` instruction, which transfers control to the
    routine that reads the IPL into memory and executes it. The disassembly of the
    routine is shown in [Figure 11-9](ch11.xhtml#ch11fig09). To go directly to the
    malicious IPL code, set a breakpoint at the last instruction of the VBR routine
    at address 0000:7C7Ah ➊ and press **F9** again to release control. Once execution
    reaches the breakpoint, the debugger breaks on the `retf` instruction. Execute
    this instruction with **F8** to get to the malicious IPL code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: VBR 代码以 `jmp` 指令开始，该指令将控制转移到读取 IPL 代码到内存并执行它的例程。该例程的反汇编显示在 [图 11-9](ch11.xhtml#ch11fig09)
    中。为了直接跳转到恶意 IPL 代码，请在 VBR 例程的最后一条指令（地址 0000:7C7Ah ➊）设置断点，然后再次按 **F9** 释放控制。一旦执行到达断点，调试器会在
    `retf` 指令处中断。执行此指令（按 **F8**）以跳转到恶意 IPL 代码。
- en: '![image](../images/11fig09.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig09.jpg)'
- en: '*Figure 11-9: VBR code*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：VBR 代码*'
- en: '**Dissecting the IPL Polymorphic Decryptor**'
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解剖 IPL 多态解密器**'
- en: The malicious IPL code starts with a series of instructions, in basic blocks,
    that initialize the registers before executing the decryptor. These are followed
    by a call instruction that transfers control to the IPL decryptor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意 IPL 代码以一系列指令开始，这些指令位于基本块中，负责在执行解密器之前初始化寄存器。之后是一个调用指令，控制转移到 IPL 解密器。
- en: The code in the first basic block of the decryptor ([Listing 11-1](ch11.xhtml#ch11list01))
    obtains the base address of the malicious IPL in memory ➊ and stores it on the
    stack ➋. The `jmp` instruction at ➌ transfers control to the second basic block
    (recall [Figure 11-6](ch11.xhtml#ch11fig06)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解密器第一个基本块的代码（见 [清单 11-1](ch11.xhtml#ch11list01)）获取恶意 IPL 在内存中的基本地址 ➊，并将其存储在栈中
    ➋。位于 ➌ 的 `jmp` 指令将控制转移到第二个基本块（回顾 [图 11-6](ch11.xhtml#ch11fig06)）。
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: Basic block 1 of the polymorphic decryptor*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：多态解密器的基本块 1*'
- en: The second and the third basic blocks both implement a single step of the decryption
    algorithm—memory allocation—and so are shown together in [Listing 11-2](ch11.xhtml#ch11list02).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个基本块都实现了解密算法的单步操作——内存分配——因此它们一起显示在 [清单 11-2](ch11.xhtml#ch11list02) 中。
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Basic blocks 2 and 3 of the polymorphic decryptor*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：多态解密器的基本块 2 和 3*'
- en: The code allocates 3KB of memory (see [Chapter 5](ch05.xhtml#ch05) on memory
    allocation in real mode) and stores the address of the memory in the `cx` register.
    The allocated memory will be used to store the decrypted malicious IPL code. The
    code then reads the total amount of available memory in real execution mode from
    address 0040:0013h and decrements the value by 3KB ➊. The `jmp` instruction at
    ➋ transfers control to the next basic block.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码分配了 3KB 的内存（请参见 [第 5 章](ch05.xhtml#ch05) 关于实模式下内存分配的内容），并将内存的地址存储在 `cx` 寄存器中。分配的内存将用于存储解密后的恶意
    IPL 代码。然后，代码从地址 0040:0013h 读取实执行模式下的总可用内存，并将值减去 3KB ➊。位于 ➋ 的 `jmp` 指令将控制转移到下一个基本块。
- en: Basic blocks 4 through 8, shown in [Listing 11-3](ch11.xhtml#ch11list03), implement
    the decryption key and decryption counter initializations, as well as the decryption
    loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块 4 至 8，如 [清单 11-3](ch11.xhtml#ch11list03) 所示，实现了解密密钥和解密计数器的初始化，以及解密循环。
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-3: Basic blocks 4 through 8 of the polymorphic decryptor*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3：多态解密器的基本块 4 至 8*'
- en: At address 0000:D959h, the `si` register is initialized with the address of
    the encrypted data ➊. Instructions at ➋ initialize the `es` and `di` registers
    with the address of the buffer allocated to store the decrypted data. The `dx`
    register at address 0000:D93Eh ➌ is initialized with the decryption key `0FCE8h`,
    and the `cx` register is initialized with the number of XOR operations to execute
    ➍ in the decryption loop. On every XOR operation, 2 bytes of encrypted data are
    XORed with the decryption key, so the value in the `cx` register is equal to `number_of_bytes_to_decrypt`
    divided by 2.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址 0000:D959h，`si` 寄存器被初始化为加密数据的地址 ➊。位于 ➋ 的指令初始化 `es` 和 `di` 寄存器，指向存储解密数据的缓冲区地址。位于地址
    0000:D93Eh ➌ 的 `dx` 寄存器被初始化为解密密钥 `0FCE8h`，`cx` 寄存器则初始化为解密循环中要执行的 XOR 操作次数 ➍。在每次
    XOR 操作中，2 字节的加密数据与解密密钥进行异或运算，因此 `cx` 寄存器的值等于 `number_of_bytes_to_decrypt` 除以 2。
- en: The instructions in the decryption loop read 2 bytes from the source ➎, XOR
    them with the key ➏, and write the result in the destination buffer ➐. Once the
    decryption step is complete, a `jmp` instruction ➑ transfers control to the next
    basic block.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解密循环中的指令从源地址 ➎ 读取 2 个字节，将其与密钥 ➏ 做异或运算，并将结果写入目标缓冲区 ➐。解密步骤完成后，`jmp` 指令 ➑ 会将控制权转移到下一个基本块。
- en: Basic blocks 9 through 11 implement register initialization and transfer control
    to the decrypted code ([Listing 11-4](ch11.xhtml#ch11list04)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基本块 9 到 11 实现了寄存器初始化，并将控制权转交给解密代码（[列表 11-4](ch11.xhtml#ch11list04)）。
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-4: Basic blocks 9 through 11 of the polymorphic decryptor*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-4：多态解密器的基本块 9 到 11*'
- en: Instructions at ➊ store the decrypted IPL code that will execute after decryption
    on the stack address, and `retf` ➋ pops this address from the stack and transfers
    control to it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 地址 ➊ 处的指令将解密后的 IPL 代码存储在栈地址中，`retf` ➋ 从栈中弹出该地址，并将控制权转移到该地址。
- en: To obtain the decrypted IPL code, we need to determine the address of the buffer
    for the decrypted data. To do so, we set up a breakpoint at address 0000:D970h
    right after instruction ➋ in [Listing 11-3](ch11.xhtml#ch11list03) and release
    control, as shown in [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取解密后的 IPL 代码，我们需要确定解密数据缓冲区的地址。为此，我们在 [列表 11-3](ch11.xhtml#ch11list03) 中的指令
    ➋ 后紧接着设置一个断点，地址为 0000:D970h，并释放控制，如 [图 11-10](ch11.xhtml#ch11fig10) 所示。
- en: '![image](../images/11fig10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig10.jpg)'
- en: '*Figure 11-10: Setting up a breakpoint in IDA Pro*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：在 IDA Pro 中设置断点*'
- en: Next, we’ll set up a breakpoint at address 0000:D98Eh (➋ in [Listing 11-4](ch11.xhtml#ch11list04)),
    the last instruction of the polymorphic decryptor, and let the rest of the decryptor
    code run. Once the debugger breaks at this address, we execute the last `retf`
    instruction, which brings us directly to the decrypted code at address 9EC0:0732h.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在地址 0000:D98Eh 处设置一个断点（[列表 11-4](ch11.xhtml#ch11list04)中的➋），这是多态解密器的最后一条指令，并让其余的解密器代码继续执行。一旦调试器在这个地址断开，我们执行最后的
    `retf` 指令，这会直接将我们引导到地址 9EC0:0732h 处的解密代码。
- en: At this point, the malicious IPL code is decrypted in memory and is available
    for further analysis. Note that, after decryption, the first routine of the malicious
    IPL is located not at the very beginning of the decrypted buffer at address 9EC0:0000h,
    but at offset 732h, due to the layout of the malicious IPL. If you want to dump
    the contents of the buffer from memory into a file on disk for static analysis,
    you should start dumping at address 9EC0:0000h, where the buffer starts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，恶意 IPL 代码已在内存中解密，可以进行进一步分析。请注意，解密后，恶意 IPL 的第一个例程并不位于解密缓冲区的开始处（地址 9EC0:0000h），而是位于偏移量
    732h 处，这是由于恶意 IPL 的布局。如果你想将缓冲区的内容从内存转储到磁盘文件以进行静态分析，你应该从地址 9EC0:0000h 开始转储，这里是缓冲区的起始位置。
- en: '***Taking Control by Patching the Windows Bootloader***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过修补 Windows 引导加载器来控制***'
- en: The main purpose of Rovnix’s IPL code is to load a malicious kernel-mode driver.
    The malicious boot code works in close collaboration with the OS bootloader components
    and follows the execution flow from the very beginning of the boot process, through
    the processor’s execution-mode switching, until the OS kernel is loaded. The loader
    relies heavily on the platform-debugging facilities and binary representations
    of the OS bootloader components.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 的 IPL 代码的主要目的是加载一个恶意的内核模式驱动程序。恶意引导代码与操作系统引导加载器组件紧密协作，并遵循从启动过程一开始，到处理器执行模式切换，再到操作系统内核加载的执行流程。加载器在很大程度上依赖于平台调试设施和操作系统引导加载器组件的二进制表示。
- en: Once the decrypted malicious IPL code is executed, it hooks the INT 13h handler
    so it can monitor all the data being read from the hard drive and set up further
    hooks in OS bootloader components. The malicious IPL then decompresses and returns
    control to the original IPL code to resume the normal boot process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解密后的恶意 IPL 代码执行，它会挂钩 INT 13h 处理程序，以便监控所有从硬盘读取的数据，并在操作系统引导加载器组件中设置进一步的钩子。恶意
    IPL 随后会解压，并将控制权交还给原始 IPL 代码，以继续正常的启动过程。
- en: '[Figure 11-11](ch11.xhtml#ch11fig11) depicts the steps Rovnix takes to interfere
    with the boot process and compromise the OS kernel. We’ve covered the steps up
    to the fourth box, so we’ll resume our description of the bootkit functionality
    from the “Load *bootmgr*” step at ➊.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-11](ch11.xhtml#ch11fig11) 展示了 Rovnix 干扰启动过程并危及操作系统内核的步骤。我们已经覆盖了前四个步骤，因此我们将从
    ➊ 处的“加载 *bootmgr*”步骤继续描述引导病毒的功能。'
- en: '![image](../images/11fig11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig11.jpg)'
- en: '*Figure 11-11: Boot process of Rovnix IPL code*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-11：Rovnix IPL代码的引导过程*'
- en: Once it has hooked the INT 13h handler, Rovnix monitors all data being read
    from the hard drive and looks for a certain byte pattern corresponding to the
    *bootmgr* of the OS. When Rovnix finds the matching pattern, it modifies the *bootmgr*
    ➋ to enable it to detect the switching of the processor from real to protected
    mode, which is a standard step in the boot process. This execution-mode switching
    changes the translation of the virtual address to physical and, as a result, changes
    the layout of the virtual memory, which would dislodge Rovnix. Therefore, in order
    to propagate itself through the switch and keep control of the boot process, Rovnix
    hooks *bootmgr* by patching it with a `jmp` instruction, allowing Rovnix to receive
    control right before the OS switches the execution mode.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦钩住了INT 13h处理程序，Rovnix监视所有从硬盘读取的数据，并寻找与操作系统的*bootmgr*对应的某个字节模式。当Rovnix找到匹配模式时，它会修改*bootmgr*
    ➋，使其能够检测处理器从实模式切换到保护模式，这是引导过程中的标准步骤。此执行模式切换改变了虚拟地址到物理地址的转换，因此改变了虚拟内存的布局，这会使Rovnix失效。因此，为了在切换过程中保持自身传播并控制引导过程，Rovnix通过在*bootmgr*中打补丁，插入`jmp`指令，使Rovnix能够在操作系统切换执行模式之前立即接管控制。
- en: Before moving on, we’ll explore how Rovnix hides its hooks and then look at
    how exactly it persists through the mode switching.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们将探讨Rovnix如何隐藏其钩子，然后看它是如何通过模式切换保持持久性的。
- en: '**Abusing the Debugging Interface to Hide Hooks**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**滥用调试接口隐藏钩子**'
- en: One thing that makes Rovnix even more interesting than other bootkits is the
    stealth of its control hooks. It hooks the INT 1h handler ➌ to be able to receive
    control at specific moments during OS kernel initialization, and it abuses debugging
    registers `dr0` through `dr7` to set up hooks that avoid detection by leaving
    the code being hooked unaltered. The INT 1h handler is responsible for handling
    debugging events, such as tracing and setting hardware breakpoints, using the
    `dr0` through `dr7` registers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使Rovnix比其他引导工具更有趣的一件事是它的控制钩子的隐蔽性。它钩住了INT 1h处理程序 ➌，以便在操作系统内核初始化的特定时刻接管控制，并且它滥用调试寄存器`dr0`到`dr7`来设置钩子，从而避免通过不修改被钩住的代码来进行检测。INT
    1h处理程序负责处理调试事件，例如追踪和设置硬件断点，使用`dr0`到`dr7`寄存器。
- en: The eight debugging registers, `dr0` through `dr7`, provide hardware-based debugging
    support on Intel x86 and x64 platforms. The first four, `dr0` through `dr3`, are
    used to specify the linear addresses of breakpoints. The `dr7` register lets you
    selectively specify and enable the conditions for triggering breakpoints; for
    instance, you can use it to set up a breakpoint that triggers upon code execution
    or memory access (read/write) at a specific address. The `dr6` register is a status
    register that allows you to determine which debug condition has occurred—that
    is, which breakpoint has been triggered. The `dr4`^([1](footnotes.xhtml#ch11fn1))
    and `dr5` registers are reserved and not used. Once a hardware breakpoint is triggered,
    INT 1h is executed to determine which debug condition has occurred and respond
    accordingly to dispatch it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 八个调试寄存器，`dr0` 到 `dr7`，在Intel x86和x64平台上提供硬件级调试支持。前四个寄存器，`dr0` 到 `dr3`，用于指定断点的线性地址。`dr7`寄存器允许你选择性地指定并启用触发断点的条件；例如，你可以使用它来设置一个断点，当代码执行或在特定地址发生内存访问（读/写）时触发。`dr6`寄存器是一个状态寄存器，允许你确定哪个调试条件已发生——即，哪个断点被触发。`dr4`^([1](footnotes.xhtml#ch11fn1))
    和 `dr5`寄存器是保留的，不使用。一旦硬件断点被触发，INT 1h将被执行，以确定发生了哪个调试条件并做出相应响应。
- en: This is the functionality that enables the Rovnix bootkit to set up stealthy
    hooks without patching code. Rovnix sets the `dr0` through `dr4` registers to
    their intended hook location and enables hardware breakpoints for each register
    by setting a corresponding bitmask in the `dr7` register.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使Rovnix引导工具能够在不修改代码的情况下设置隐蔽钩子的功能。Rovnix将`dr0`到`dr4`寄存器设置为其预定的钩子位置，并通过在`dr7`寄存器中设置相应的位掩码，启用每个寄存器的硬件断点。
- en: '**Abusing the Interrupt Descriptor Table to Persist Through Boot**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**滥用中断描述符表实现引导过程中的持久性**'
- en: In addition to abusing the debugging facilities of the platform, the first iterations
    of Rovnix used an interesting technique to survive the processor’s switch from
    real to protected mode. Before execution switches to protected mode, *bootmgr*
    initializes important system structures, such as the Global Descriptor Table and
    Interrupt Descriptor Table (IDT). The latter is filled with descriptors of interrupt
    handlers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了滥用平台的调试功能外，Rovnix 的初期版本还使用了一种有趣的技术，以在处理器从实模式切换到保护模式时生存下来。在执行切换到保护模式之前，*bootmgr*
    初始化了重要的系统结构，如全局描述符表（GDT）和中断描述符表（IDT）。后者填充了中断处理程序的描述符。
- en: '**INTERRUPT DESCRIPTOR TABLE**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断描述符表**'
- en: 'The IDT is a special system structure used by the CPU in protected mode to
    specify CPU interrupt handlers. In real mode, the IDT (also referred to as the
    *Interrupt Vector Table*, or *IVT*) is trivial—merely an array of 4-byte addresses
    of handlers, starting at address 0000:0000h. In other words, the address of the
    INT 0h handler is 0000:0000h, the address of the INT 1h handler is 0000:0004h,
    the address of the INT 2h handler is 0000:0008h, and so on. In protected mode,
    the IDT has a more complex layout: an array of 8-byte interrupt handler descriptors.
    The base address of the IDT can be obtained via the `sidt` processor instruction.
    For more information on IDT, refer to Intel’s documentation at *[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: IDT 是 CPU 在保护模式下使用的特殊系统结构，用于指定 CPU 中断处理程序。在实模式下，IDT（也称为*中断向量表*，或*IVT*）很简单——只是一个由处理程序的
    4 字节地址组成的数组，从地址 0000:0000h 开始。换句话说，INT 0h 处理程序的地址是 0000:0000h，INT 1h 处理程序的地址是
    0000:0004h，INT 2h 处理程序的地址是 0000:0008h，依此类推。在保护模式下，IDT 具有更复杂的布局：一个由 8 字节中断处理程序描述符组成的数组。可以通过`sidt`处理器指令获取
    IDT 的基地址。有关 IDT 的更多信息，请参阅英特尔的文档：*[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)*。
- en: Rovnix copies the malicious IPL code over the second half of the IDT, which
    is not being used by the system at the moment. Given that each descriptor is 8
    bytes and there are 256 descriptors in the table, this provides Rovnix with 1KB
    of IDT memory, sufficient to store its malicious code. The IDT is in protected
    mode, so storing its code in the IDT ensures that Rovnix will persist across the
    mode switching, and the IDT address can be easily obtained via the `sidt` instruction.
    The overall layout of the IDT after Rovnix’s modifications is shown in [Figure
    11-12](ch11.xhtml#ch11fig12).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 将恶意 IPL 代码复制到 IDT 的第二半部分，该部分目前系统未使用。由于每个描述符占 8 字节，而表中有 256 个描述符，这为 Rovnix
    提供了 1KB 的 IDT 内存，足够存储其恶意代码。IDT 在保护模式下，因此将代码存储在 IDT 中可确保 Rovnix 在模式切换后仍能保持，并且可以通过`sidt`指令轻松获取
    IDT 地址。Rovnix 修改后 IDT 的整体布局如[图 11-12](ch11.xhtml#ch11fig12)所示。
- en: '![image](../images/11fig12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig12.jpg)'
- en: '*Figure 11-12: How Rovnix abuses the IDT to propagate through execution-mode
    switching*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12：Rovnix 如何滥用 IDT 在执行模式切换中传播*'
- en: '***Loading the Malicious Kernel-Mode Driver***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加载恶意内核模式驱动程序***'
- en: After hooking the INT 1h handler, Rovnix proceeds with hooking other OS bootloader
    components, such as *winload.exe* and the OS kernel image (*ntoskrnl.exe*, for
    instance). Rovnix waits while the *bootmgr* code loads *winload.exe* and then
    hooks the `BlImgAllocateImageBuffer` routine (see ➍ in [Figure 11-11](ch11.xhtml#ch11fig11))
    to allocate a buffer for an executable image by setting up a hardware breakpoint
    at its starting address. This technique allocates memory to hold the malicious
    kernel-mode driver.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂钩 INT 1h 处理程序后，Rovnix 接着挂钩其他操作系统引导加载程序组件，如*winload.exe*和操作系统内核镜像（例如*ntoskrnl.exe*）。Rovnix
    在*bootmgr*代码加载*winload.exe*时等待，然后挂钩`BlImgAllocateImageBuffer`例程（见[图 11-11](ch11.xhtml#ch11fig11)）来为可执行镜像分配缓冲区，通过在其起始地址设置硬件断点。此技术分配内存来容纳恶意的内核模式驱动程序。
- en: The malware also hooks the `OslArchTransferToKernel` routine in *winload.exe*.
    This routine transfers control from *winload.exe* to the kernel’s entry point
    `KiSystemStartup`, which starts kernel initialization. By hooking `OslArchTransferToKernel`,
    Rovnix gets control right before `KiSystemStartup` is called, and it takes this
    opportunity to inject the malicious kernel-mode driver.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还会钩住 *winload.exe* 中的 `OslArchTransferToKernel` 例程。该例程将控制从 *winload.exe*
    转移到内核的入口点 `KiSystemStartup`，进而启动内核初始化。通过钩住 `OslArchTransferToKernel`，Rovnix 在
    `KiSystemStartup` 被调用之前获取控制权，并趁机注入恶意的内核模式驱动程序。
- en: The routine `KiSystemStartup` takes the single parameter `KeLoaderBlock`, which
    is a pointer to `LOADER_PARAMETER_BLOCK`—an undocumented structure initialized
    by *winload.exe* that contains important system information, such as boot options
    and loaded modules. The structure is shown in [Listing 11-5](ch11.xhtml#ch11list05).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`KiSystemStartup` 例程接受一个参数 `KeLoaderBlock`，这是一个指向 `LOADER_PARAMETER_BLOCK`
    的指针——这是一个由 *winload.exe* 初始化的未记录结构，包含了重要的系统信息，如启动选项和已加载的模块。该结构见[列表 11-5](ch11.xhtml#ch11list05)。'
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-5: The `LOADER_PARAMETER_BLOCK` description*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-5：`LOADER_PARAMETER_BLOCK` 描述*'
- en: Rovnix is interested in the field `BootDriverListHead` ➊, which contains the
    head of a list of special data structures corresponding to boot-mode drivers.
    These drivers are loaded by *winload.exe* at the same time that the kernel image
    is loaded. However, the `DriverEntry` routine that initializes the drivers isn’t
    called until after the OS kernel image receives control. The OS kernel initialization
    code traverses records in `BootDriverListHead` and calls the `DriverEntry` routine
    of the corresponding driver.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 关注的是字段 `BootDriverListHead` ➊，它包含了一个与启动模式驱动程序对应的特殊数据结构的列表头。这些驱动程序与内核映像一起由
    *winload.exe* 加载。然而，初始化这些驱动程序的 `DriverEntry` 例程直到操作系统内核映像接管控制权后才会被调用。操作系统内核初始化代码会遍历
    `BootDriverListHead` 中的记录，并调用相应驱动程序的 `DriverEntry` 例程。
- en: Once the `OslArchTransferToKernel` hook is triggered, Rovnix obtains the address
    of the `KeLoaderBlock` structure from the stack and inserts a record corresponding
    to the malicious driver into the boot driver list using the `BootDriverListHead`
    field. Now the malicious driver is loaded into memory as if it were a kernel-mode
    driver with a legitimate digital signature. Next, Rovnix transfers control to
    the `KiSystemStartup` routine, which resumes the boot process and starts kernel
    initialization (➎ in [Figure 11-11](ch11.xhtml#ch11fig11)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `OslArchTransferToKernel` 钩子被触发，Rovnix 从栈中获取 `KeLoaderBlock` 结构的地址，并使用 `BootDriverListHead`
    字段将一个对应于恶意驱动程序的记录插入启动驱动程序列表。此时，恶意驱动程序被加载到内存中，仿佛它是一个具有合法数字签名的内核模式驱动程序。接下来，Rovnix
    将控制权转交给 `KiSystemStartup` 例程，后者恢复启动过程并开始内核初始化（见[图 11-11](ch11.xhtml#ch11fig11)中的➎）。
- en: At some point during initialization, the kernel traverses the list of boot drivers
    in `KeLoaderBlock` and calls their initialization routines, including that of
    the malicious driver ([Figure 11-13](ch11.xhtml#ch11fig13)). This is how the `DriverEntry`
    routine of the malicious kernel-mode driver is executed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化的某个时刻，内核会遍历 `KeLoaderBlock` 中的启动驱动程序列表，并调用它们的初始化例程，包括恶意驱动程序的初始化例程（见[图 11-13](ch11.xhtml#ch11fig13)）。这就是恶意内核模式驱动程序的
    `DriverEntry` 例程被执行的方式。
- en: '![image](../images/11fig13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig13.jpg)'
- en: '*Figure 11-13: A malicious Rovnix driver inserted into `BootDriverList`*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-13：恶意的Rovnix驱动程序被插入到`BootDriverList`中*'
- en: '**Kernel-Mode Driver Functionality**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**内核模式驱动程序功能**'
- en: The main function of the malicious driver is to inject the payload, stored in
    the driver’s binary and compressed with aPlib as discussed earlier, into target
    processes in the system—primarily into *explorer.exe* and browsers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意驱动程序的主要功能是将存储在驱动程序二进制文件中的有效负载注入目标进程，之前提到过，这些有效负载使用aPlib进行压缩，主要注入到 *explorer.exe*
    和浏览器中。
- en: '***Injecting the Payload Module***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***注入有效负载模块***'
- en: The payload module contains the code *JFA* in its signature, so to extract it,
    Rovnix looks for the JFA signature in a free space between the section table of
    the driver and its first section. This signature signifies the beginning of the
    configuration data block, an example of which is displayed in [Listing 11-6](ch11.xhtml#ch11list06).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有效负载模块在其签名中包含了 *JFA* 代码，因此，为了提取它，Rovnix 会在驱动程序的节表和第一个节之间的空闲空间中查找 JFA 签名。该签名表示配置数据块的开始，示例见[列表
    11-6](ch11.xhtml#ch11list06)。
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-6: `PAYLOAD_CONFIGURATION_BLOCK` structure describing payload configuration*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：描述有效负载配置的 `PAYLOAD_CONFIGURATION_BLOCK` 结构*'
- en: The fields `PayloadRva` and `PayloadSize` specify the coordinates of the compressed
    payload image in the kernel-mode driver. The `ProcessNames` array contains names
    of the processes to inject the payload into. The number of entries in the array
    is specified by `NumberOfProcessNames`. [Figure 11-14](ch11.xhtml#ch11fig14) shows
    an example of such a data block taken from a real-world malicious kernel-mode
    driver. As you can see, the payload is to be injected into *explorer.exe* and
    the browsers *iexplore.exe*, *firefox.exe*, and *chrome.exe*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`PayloadRva` 和 `PayloadSize` 字段指定了压缩有效负载镜像在内核模式驱动中的坐标。`ProcessNames` 数组包含了要将有效负载注入的进程名称。数组中的条目数由
    `NumberOfProcessNames` 指定。[图 11-14](ch11.xhtml#ch11fig14) 显示了一个来自真实恶意内核模式驱动的数据块示例。如你所见，有效负载将被注入到
    *explorer.exe* 以及浏览器 *iexplore.exe*、*firefox.exe* 和 *chrome.exe* 中。'
- en: '![image](../images/11fig14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig14.jpg)'
- en: '*Figure 11-14: A payload configuration block*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-14：有效负载配置块*'
- en: 'Rovnix first decompresses the payload into a memory buffer. Then it employs
    a conventional technique frequently used by rootkits to inject the payload, consisting
    of the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 首先将有效负载解压到内存缓冲区中。然后它使用根套件（rootkit）常用的传统技术来注入有效负载，具体步骤如下：
- en: Register `CreateProcessNotifyRoutine` and `LoadImageNotifyRoutine` using the
    standard documented kernel-mode API. This permits Rovnix to gain control each
    time a new process is created or a new image is loaded into the address of a target
    process.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准文档化的内核模式 API 注册 `CreateProcessNotifyRoutine` 和 `LoadImageNotifyRoutine`。这样，Rovnix
    就能在每次新进程创建或新镜像加载到目标进程的地址空间时获得控制。
- en: Monitor the new processes in the system and look for the target process, identified
    by the image name.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控系统中新进程的创建，并通过镜像名称寻找目标进程。
- en: As soon as the target process is loaded, map the payload into its address space
    and queue an *asynchronous procedure call (APC)*, which transfers control to the
    payload.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦目标进程被加载，将有效负载映射到其地址空间，并排队一个 *异步过程调用（APC）*，将控制权转交给有效负载。
- en: Let’s examine this technique in more detail. The `CreateProcessNotify` routine
    allows Rovnix to install a special handler that’s triggered every time a new process
    is created on the system. This way, the malware is able to detect when a target
    process is launched. However, because the malicious create-process handler is
    triggered at the very beginning of process creation, when all the necessary system
    structures are already initialized but before the executable file of the target
    process is loaded into its address space, the malware isn’t able to inject the
    payload at this point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分析这种技术。`CreateProcessNotify` 例程允许 Rovnix 安装一个特殊的处理程序，每当系统上创建新进程时触发。通过这种方式，恶意软件能够检测何时启动目标进程。然而，由于恶意的创建进程处理程序在进程创建的最初阶段被触发，即在所有必要的系统结构已初始化但目标进程的可执行文件尚未加载到其地址空间时，恶意软件此时无法注入有效负载。
- en: The second routine, `LoadImageNotifyRoutine`, allows Rovnix to set up a handler
    that’s triggered every time an executable module (*.exe* file, DLL library, and
    so forth) is loaded or unloaded on the system. This handler monitors the main
    executable image and notifies Rovnix once the image is loaded in the target process’s
    address space, at which point Rovnix injects the payload and executes it by creating
    an APC.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例程 `LoadImageNotifyRoutine` 允许 Rovnix 设置一个处理程序，每次加载或卸载可执行模块（*.exe* 文件、DLL
    库等）时触发。这个处理程序监控主可执行镜像，并在镜像加载到目标进程的地址空间后通知 Rovnix，这时 Rovnix 将注入有效负载并通过创建 APC 来执行它。
- en: '***Stealth Self-Defense Mechanisms***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐匿自我防御机制***'
- en: 'The kernel-mode driver implements the same defensive mechanisms as the TDL4
    bootkit: it hooks the `IRP_MJ_INTERNAL_CONTROL` handler of the hard disk miniport
    `DRIVER_OBJECT`. This handler is the lowest-level hardware-independent interface
    with access to data stored on the hard drive, providing the malware with a reliable
    way of controlling data being read from and written to the hard drive.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式驱动实现了与 TDL4 启动工具相同的防御机制：它钩住了硬盘迷你端口 `DRIVER_OBJECT` 的 `IRP_MJ_INTERNAL_CONTROL`
    处理程序。这个处理程序是与硬件无关的最低级接口，可以访问硬盘上存储的数据，为恶意软件提供了一种可靠的方式来控制从硬盘读取和写入的数据。
- en: 'This way, Rovnix can intercept all the read/write requests and protect critical
    areas from being read or overwritten. To be specific, it protects:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Rovnix 可以拦截所有的读/写请求，并保护关键区域免受读取或覆盖。具体来说，它保护以下内容：
- en: The infected IPL code
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被感染的 IPL 代码
- en: The stored kernel-mode driver
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储的内核模式驱动
- en: The hidden filesystem partition
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏的文件系统分区
- en: '[Listing 11-7](ch11.xhtml#ch11list07) presents the pseudocode of the `IRP_MJ_INTERNAL_CONTROL`
    hook routine, which determines whether to block or authorize an I/O operation
    depending on which part of the hard drive is being read or written to.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-7](ch11.xhtml#ch11list07) 展示了 `IRP_MJ_INTERNAL_CONTROL` 钩子例程的伪代码，该例程决定是否阻止或授权
    I/O 操作，具体取决于正在读取或写入硬盘的哪个部分。'
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-7: The pseudocode of a malicious `IRP_MJ_INTERNAL_CONTROL` handler*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-7: 恶意 `IRP_MJ_INTERNAL_CONTROL` 处理程序的伪代码*'
- en: First the code checks whether the I/O request is addressed to the hard drive
    device object ➊. If so, the malware checks whether the operation is a read or
    write operation and which region of the hard drive is being accessed ➋. The routine
    `CheckSrbParams` ➌ returns `TRUE` when regions protected by the bootkit are being
    accessed. If someone tries to write data to the region protected by the bootkit,
    the code rejects the I/O operation and returns `STATUS_ACCESS_DENIED` ➍. If someone
    tries to read from the bootkit-protected region, the malware sets a malicious
    completion routine ➎ and passes the I/O request down to the hard drive device
    object for completing the read operation. Once the read operation finishes, the
    malicious completion routine is triggered and wipes the buffer containing the
    read data by writing zeros into it. This way, the malware protects its data on
    the hard drive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码检查 I/O 请求是否针对硬盘设备对象 ➊。如果是，恶意软件会检查操作是读取还是写入操作，以及正在访问硬盘的哪个区域 ➋。`CheckSrbParams`
    例程 ➌ 在访问受 bootkit 保护的区域时返回 `TRUE`。如果有人尝试向受 bootkit 保护的区域写入数据，代码会拒绝 I/O 操作并返回 `STATUS_ACCESS_DENIED`
    ➍。如果有人尝试从受 bootkit 保护的区域读取数据，恶意软件会设置一个恶意的完成例程 ➎，并将 I/O 请求传递给硬盘设备对象以完成读取操作。一旦读取操作完成，恶意的完成例程会被触发，通过向缓冲区写入零来清除读取数据。这种方式，恶意软件保护了它在硬盘上的数据。
- en: '**The Hidden Filesystem**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**隐藏文件系统**'
- en: Another significant feature of Rovnix is its hidden filesystem (FS) partition
    (that is, one not visible to the operating system) that’s used to secretly store
    configuration data and additional payload modules. Implementation of hidden storage
    isn’t a new bootkit technique—it’s been used by other rootkits such as TDL4 and
    Olmasco—but Rovnix has a slightly different implementation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 的另一个显著特征是其隐藏的文件系统 (FS) 分区（即操作系统无法看到的分区），用于秘密存储配置数据和附加的有效载荷模块。隐藏存储的实现并不是一种新的
    bootkit 技术——它已被其他 rootkit 如 TDL4 和 Olmasco 使用过——但 Rovnix 的实现略有不同。
- en: To physically store its hidden partition, Rovnix occupies space either at the
    beginning or end of the hard drive, depending on where there’s enough free space;
    if there are 0x7D0 (2,000 in decimal, almost 1MB) or more free sectors before
    the first partition, Rovnix places the hidden partition right after the MBR sector
    and extends it over the entirety of the free 0x7D0 sectors. If there isn’t enough
    space at the beginning of the hard drive, Rovnix tries to place the hidden partition
    at its end. To access the data stored in the hidden partition, Rovnix uses the
    original `IRP_MJ_INTERNAL_CONTROL` handler, hooked as explained in the previous
    section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了物理存储其隐藏分区，Rovnix 会占用硬盘的开始部分或结束部分的空间，具体取决于哪里有足够的空闲空间；如果在第一个分区之前有 0x7D0（即 2,000
    十进制，几乎 1MB）或更多的空闲扇区，Rovnix 会将隐藏分区放置在 MBR 扇区之后，并扩展到所有空闲的 0x7D0 扇区。如果硬盘的开始部分没有足够的空间，Rovnix
    会尝试将隐藏分区放在硬盘的末尾。为了访问存储在隐藏分区中的数据，Rovnix 使用原始的 `IRP_MJ_INTERNAL_CONTROL` 处理程序，按前一部分中解释的方式进行钩取。
- en: '***Formatting the Partition as a Virtual FAT System***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将分区格式化为虚拟 FAT 系统***'
- en: Once Rovnix has allocated space for the hidden partition, it formats it as a
    *Virtual File Allocation Table (VFAT)* filesystem—a modification of the FAT filesystem
    capable of storing files with long Unicode filenames (up to 256 bytes). The original
    FAT filesystem imposes limitations on filename lengths of 8 + 3, meaning up to
    eight characters for a filename and three characters for an extension name.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Rovnix 为隐藏分区分配了空间，它将其格式化为 *虚拟文件分配表 (VFAT)* 文件系统——这是一种 FAT 文件系统的修改版，能够存储带有长
    Unicode 文件名的文件（最长 256 字节）。原始的 FAT 文件系统对文件名的长度有限制，为 8 + 3，即文件名最多 8 个字符，扩展名最多 3
    个字符。
- en: '***Encrypting the Hidden Filesystem***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密隐藏文件系统***'
- en: To protect the data in the hidden filesystem, Rovnix implements partition-transparent
    encryption with the RC6 encryption algorithm in Electronic Code Book (ECB) mode
    and a key length of 128 bits. In ECB mode, the data to be encrypted is split into
    blocks of equal lengths, each of which is encrypted with the same key independently
    of the other blocks. The key is stored in the last 16 bytes of the very first
    sector of the hidden partition, as shown in [Figure 11-15](ch11.xhtml#ch11fig15),
    and is used to encrypt and decrypt the whole partition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护隐藏文件系统中的数据，Rovnix 使用 RC6 加密算法在电子密码本（ECB）模式下实施分区透明加密，并且密钥长度为128位。在 ECB 模式下，待加密的数据被分割成等长的块，每个块都使用相同的密钥独立加密，与其他块无关。该密钥存储在隐藏分区第一扇区的最后16字节中，如[图11-15](ch11.xhtml#ch11fig15)所示，并用于加密和解密整个分区。
- en: '![image](../images/11fig15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig15.jpg)'
- en: '*Figure 11-15: Encryption key location in the first sector of the hidden partition*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-15：隐藏分区第一扇区的加密密钥位置*'
- en: '**RC6**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**RC6**'
- en: Rivest cipher 6, or RC6, is a symmetric key block cipher designed by Ron Rivest,
    Matt Robshaw, Ray Sidney, and Yiqun Lisa Yin to meet the requirements of the *Advanced
    Encryption Standard (AES)* competition. RC6 has a block size of 128 bits and supports
    key sizes of 128, 192, and 256 bits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Rivest密码6，或称 RC6，是由 Ron Rivest、Matt Robshaw、Ray Sidney 和 Yiqun Lisa Yin 设计的一种对称密钥分组密码，旨在满足*高级加密标准（AES）*竞赛的要求。RC6
    的分组大小为128位，支持128位、192位和256位的密钥长度。
- en: '***Accessing the Hidden Filesystem***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问隐藏文件系统***'
- en: To make the hidden filesystem accessible to the payload modules, Rovnix creates
    a special object called a *symbolic link*. Loosely speaking, the symbolic link
    is an alternative name for a hidden storage device object that can be used by
    modules in user-mode processes. Rovnix generates the string `\DosDevices\<`XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`>`,
    where X is a randomly generated hexadecimal number, from 0 to F, that’s used as
    the symbolic link name for the hidden storage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使隐藏文件系统对有效载荷模块可访问，Rovnix 创建了一个名为*符号链接*的特殊对象。宽泛地讲，符号链接是隐藏存储设备对象的另一种名称，可以被用户模式进程中的模块使用。Rovnix
    生成字符串 `\DosDevices\<`XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX`>`，其中 X 是一个随机生成的十六进制数字，范围从
    0 到 F，用作隐藏存储的符号链接名称。
- en: One advantage of the hidden filesystem is that it may be accessed as a regular
    filesystem through the standard Win32 API functions provided by the operating
    system, such as `CreateFile`, `CloseFile`, `ReadFile`, or `WriteFile`. For instance,
    to create the file *file_to_create* in the root directory of the hidden filesystem,
    a malicious payload calls `CreateFile`, passing the symbolic link string `\DosDevices\<%`XXXXXXXX`-`XXXX`-`XXXX`-`XXXX`-`XXXXXXXXXXXX`>\file_to_create`
    as a filename parameter. Once the payload module issues this call, the operating
    system redirects the request to the malicious kernel-mode driver responsible for
    handling requests for the hidden filesystem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏文件系统的一个优势是，可以通过操作系统提供的标准 Win32 API 函数，如 `CreateFile`、`CloseFile`、`ReadFile`
    或 `WriteFile`，将其作为常规文件系统访问。例如，要在隐藏文件系统的根目录中创建名为 *file_to_create* 的文件，恶意有效载荷会调用
    `CreateFile`，并传递符号链接字符串 `\DosDevices\<%`XXXXXXXX`-`XXXX`-`XXXX`-`XXXX`-`XXXXXXXXXXXX`>\file_to_create`
    作为文件名参数。一旦有效载荷模块发出此调用，操作系统会将请求重定向到负责处理隐藏文件系统请求的恶意内核模式驱动程序。
- en: '[Figure 11-16](ch11.xhtml#ch11fig16) shows how the malicious driver implements
    the filesystem driver functionality. Once it receives an I/O request from the
    payload, Rovnix dispatches the request using the hooked hard drive handler to
    perform read and write operations for the hidden filesystem located on the hard
    drive.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-16](ch11.xhtml#ch11fig16)展示了恶意驱动程序如何实现文件系统驱动程序功能。一旦它收到来自有效载荷的 I/O 请求，Rovnix
    使用钩住的硬盘处理程序调度该请求，执行针对硬盘上隐藏文件系统的读写操作。'
- en: '![image](../images/11fig16.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig16.jpg)'
- en: '*Figure 11-16: Architecture of the Rovnix hidden storage filesystem*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-16：Rovnix隐藏存储文件系统的架构*'
- en: In this scenario, the operating system and the malicious hidden filesystem coexist
    on the same hard drive, but the operating system isn’t aware of the hard drive
    region used to store the hidden data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，操作系统和恶意隐藏文件系统共存于同一硬盘上，但操作系统并不知道用于存储隐藏数据的硬盘区域。
- en: The malicious hidden filesystem potentially could alter legitimate data being
    stored on the operating system’s filesystem, but the chances of that are low due
    to the hidden filesystem’s placement at the beginning or end of the hard drive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意隐藏文件系统可能会更改存储在操作系统文件系统中的合法数据，但由于隐藏文件系统被放置在硬盘的开始或结束位置，因此这种情况发生的几率较低。
- en: '**The Hidden Communication Channel**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**隐藏的通信通道**'
- en: Rovnix has further stealth tricks up its sleeve. The Rovnix kernel-mode driver
    implements a TCP/IP protocol stack to communicate secretly with remote C&C servers.
    The network interfaces provided by the OS are frequently hooked by security software
    in order to monitor and control network traffic passing through the network. Instead
    of relying on these network interfaces and risk detection by the security software,
    Rovnix uses its own custom implementation of network protocols, independent of
    the operating system, to download payload modules from C&C servers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 还有更多隐秘的伎俩。Rovnix 内核模式驱动程序实现了一个 TCP/IP 协议栈，用于与远程 C&C 服务器秘密通信。操作系统提供的网络接口常常被安全软件劫持，以监控和控制通过网络的流量。Rovnix
    并不依赖这些网络接口，也避免了被安全软件检测的风险，而是使用了其自定义的网络协议实现，独立于操作系统，从 C&C 服务器下载有效载荷模块。
- en: 'To be able to send and receive data over this network, the Rovnix kernel-mode
    driver implements a complete network stack, including the following interfaces:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在这个网络上发送和接收数据，Rovnix 内核模式驱动实现了一个完整的网络栈，包括以下接口：
- en: Microsoft *Network Driver Interface Specification (NDIS)* miniport interface
    to send data packets using a physical network Ethernet interface
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 *网络驱动接口规范 (NDIS)* 微型端口接口，通过物理网络以太网接口发送数据包
- en: Transport Driver Interface for TCP/IP network protocols
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 TCP/IP 网络协议的传输驱动接口
- en: Socket interface
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字接口
- en: HTTP protocol to communicate with remote C&C servers
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 协议用于与远程 C&C 服务器通信
- en: As shown in [Figure 11-17](ch11.xhtml#ch11fig17), the NDIS miniport layer is
    responsible for communicating with the network interface card to send and receive
    network packets. The Transport Driver Interface provides a TCP/IP interface for
    the upper-level socket interface, which in turn is used by Rovnix’s HTTP protocol
    to transmit data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 11-17](ch11.xhtml#ch11fig17) 所示，NDIS 微型端口层负责与网络接口卡通信，发送和接收网络数据包。传输驱动接口为上层套接字接口提供了
    TCP/IP 接口，后者则被 Rovnix 的 HTTP 协议用来传输数据。
- en: '![image](../images/11fig17.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig17.jpg)'
- en: '*Figure 11-17: Architecture of Rovnix custom network stack implementation*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-17：Rovnix 自定义网络栈实现架构*'
- en: Rovnix’s creators didn’t develop this hidden network communication system from
    scratch—such an implementation requires thousands of lines of code and thus is
    prone to errors. Instead, they based their implementation on an open source, lightweight
    TCP/IP network library called lwIP. The lwIP library is a small, independent implementation
    of the TCP/IP protocol suite with a focus on reducing resource usage while still
    delivering a full-scale TCP/IP stack. According to its website, lwIP has a footprint
    of tens of kilobytes of RAM and around 40KB of code, which fits the bootkit perfectly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix 的创造者并不是从零开始开发这个隐藏的网络通信系统——这种实现需要成千上万行代码，因此容易出错。相反，他们基于一个开源、轻量级的 TCP/IP
    网络库 lwIP 进行了实现。lwIP 库是一个小型、独立的 TCP/IP 协议套件实现，重点是减少资源使用，同时仍提供完整的 TCP/IP 协议栈。根据其官方网站的描述，lwIP
    占用的 RAM 空间只有几十 KB，代码量约为 40KB，非常适合用作启动木马。
- en: Features like the hidden communication channel allow Rovnix to bypass local
    network monitoring security software. Since Rovnix comes with its own network
    protocol stack, network security software is unaware of—and thus unable to monitor—its
    communications over the network. From the very top of the protocol layer down
    to the very bottom of the NDIS miniport driver, Rovnix uses only its own network
    components, making it a very stealthy bootkit.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的通信通道等特性使得 Rovnix 可以绕过本地网络监控安全软件。由于 Rovnix 带有自己的网络协议栈，网络安全软件无法识别——因此也无法监控——它在网络上的通信。从协议层的最上层到底层的
    NDIS 微型端口驱动，Rovnix 仅使用自己的网络组件，使其成为一个非常隐秘的启动木马。
- en: '**Case History: The Carberp Connection**'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例分析：Carberp 连接**'
- en: One real-world example of Rovnix being used in the wild is in the Carberp trojan
    malware, developed by the most prominent cybercrime group in Russia. Carberp was
    used to allow a banking trojan to persist on the victim’s system.^([2](footnotes.xhtml#ch11fn2))
    We’ll look at a few aspects of Carberp and how it was developed from the Rovnix
    bootkit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Rovnix在实际环境中使用的一个例子是Carberp木马，它由俄罗斯最著名的网络犯罪集团开发。Carberp被用于使一个银行木马在受害者的系统上持续存在。^([2](footnotes.xhtml#ch11fn2))我们将查看Carberp的一些方面，以及它如何从Rovnix引导程序开发而来。
- en: '**CARBERP-RELATED MALWARE**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**与CARBERP相关的恶意软件**'
- en: 'It was estimated that the group that developed Carberp earned an average weekly
    income of several million US dollars and invested heavily in other malware technologies,
    such as the Hodprot dropper,^([1](ch11.xhtml#ch11sfn1)) which has been implicated
    in installations of Carberp, RDPdoor, and Sheldor.^([2](ch11.xhtml#ch11sfn2))
    RDPdoor was especially malicious: it installed Carberp in order to open a backdoor
    in the infected system and manually perform fraudulent banking transactions.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 据估计，开发Carberp的集团每周的平均收入达到数百万美元，并在其他恶意软件技术上投入了大量资金，如Hodprot投放器，^([1](ch11.xhtml#ch11sfn1))该投放器曾在Carberp、RDPdoor和Sheldor的安装中发挥作用。^([2](ch11.xhtml#ch11sfn2))
    RDPdoor尤其恶意：它安装Carberp以便在被感染的系统中打开后门，并手动执行欺诈性银行交易。
- en: '[1](ch11.xhtml#ch11sfn1a). *[https://www.welivesecurity.com/media_files/white-papers/Hodprot-Report.pdf](https://www.welivesecurity.com/media_files/white-papers/Hodprot-Report.pdf)*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](ch11.xhtml#ch11sfn1a)。 *[https://www.welivesecurity.com/media_files/white-papers/Hodprot-Report.pdf](https://www.welivesecurity.com/media_files/white-papers/Hodprot-Report.pdf)*'
- en: '[2](ch11.xhtml#ch11sfn2a). *[https://www.welivesecurity.com/2011/01/14/sheldor-shocked/](https://www.welivesecurity.com/2011/01/14/sheldor-shocked/)*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](ch11.xhtml#ch11sfn2a)。 *[https://www.welivesecurity.com/2011/01/14/sheldor-shocked/](https://www.welivesecurity.com/2011/01/14/sheldor-shocked/)*'
- en: '***Development of Carberp***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Carberp的开发***'
- en: In November 2011, we noticed that one of the C&C servers set up by the cybercrime
    group behind Carberp started distributing a dropper with a bootkit based on the
    Rovnix framework. We started tracking the Carberp trojan and found that during
    this period, its distribution was very limited.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年11月，我们注意到Carberp背后的网络犯罪集团设置的一个C&C服务器开始分发一个基于Rovnix框架的引导程序。我们开始跟踪Carberp木马，发现此期间其分发非常有限。
- en: Two things in our analysis suggested that the bot was working in test mode and
    therefore being actively developed. The first clue was an abundance of debugging
    and tracing information relating to the bot’s installation and the binary’s behavior.
    The second, which we discovered by gaining access to logfiles from the bot C&C
    server, was that masses of information on failures in installation were being
    sent back to the C&C. [Figure 11-18](ch11.xhtml#ch11fig18) shows an example of
    the kind of information Carberp was reporting.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分析中有两个迹象表明该机器人处于测试模式，因此正在积极开发中。第一个线索是关于机器人安装和二进制文件行为的大量调试和追踪信息。第二个线索是我们通过访问机器人C&C服务器的日志文件发现的——大量安装失败信息被发送回C&C。[图11-18](ch11.xhtml#ch11fig18)展示了Carberp报告的此类信息示例。
- en: '![image](../images/11fig18.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig18.jpg)'
- en: '*Figure 11-18: An example of Rovnix dropper logs*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-18：Rovnix投放器日志示例*'
- en: The ID column specifies a unique identifier of a Rovnix instance; the status
    column contains information on whether the victim’s system has been successfully
    compromised. The infection algorithm was split into a number of steps, and information
    was reported to the C&C server directly after each step. The step column provides
    information on which step is being executed, and the info column contains a description
    of any error encountered during installation. By looking at the step and info
    columns, operators of the botnet could determine at which step and for what reason
    the infection failed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ID列指定Rovnix实例的唯一标识符；状态列包含受害者系统是否成功被攻破的信息。感染算法分为多个步骤，每完成一步后，信息便会直接报告给C&C服务器。步骤列提供正在执行的步骤信息，信息列包含安装过程中遇到的任何错误描述。通过查看步骤和信息列，僵尸网络操作员可以确定感染失败的步骤和原因。
- en: The version of Rovnix that Carberp used contained a lot of debugging strings
    and sent a lot of verbose messages to the C&C. [Figure 11-19](ch11.xhtml#ch11fig19)
    shows examples of the kind of strings it might send. This information was extremely
    useful to us in analyzing this threat and understanding its functionality. The
    debugging information left in the binary revealed the names of the routines implemented
    in the binary and their purpose. It documented the logic of the code. Using this
    data, we could more easily reconstruct the context of the malicious code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Carberp 使用的 Rovnix 版本包含了大量的调试字符串，并且向 C&C 发送了许多冗长的消息。[图 11-19](ch11.xhtml#ch11fig19)
    展示了它可能发送的字符串示例。这些信息对我们分析这个威胁并理解其功能非常有帮助。二进制文件中留下的调试信息揭示了二进制中实现的例程名称及其目的，记录了代码的逻辑。利用这些数据，我们可以更容易地重建恶意代码的上下文。
- en: '![image](../images/11fig19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/11fig19.jpg)'
- en: '*Figure 11-19: Debug strings left by developers in the Rovnix dropper*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-19：开发人员在 Rovnix 下拉程序中留下的调试字符串*'
- en: '***Dropper Enhancements***'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***下拉程序增强功能***'
- en: 'The framework of Rovnix used in Carberp was pretty much the same as the bootkit
    we described in the beginning of the chapter, with the only significant change
    appearing in the dropper. In “[Infecting the System](ch07.xhtml#ch07lev3sec1)”
    on [page 150](ch11.xhtml#page_150), we mentioned that Rovnix tries to elevate
    its privileges by using the `ShellExecuteEx` Win32 API to achieve administrator
    rights on the victim’s machine. In Carberp’s version of Rovnix, the dropper exploited
    the following vulnerabilities in the system to elevate privileges:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Carberp 中使用的 Rovnix 框架与我们在本章开始时描述的引导工具几乎相同，唯一的显著变化出现在下拉程序中。在 “[感染系统](ch07.xhtml#ch07lev3sec1)”
    中的[第 150 页](ch11.xhtml#page_150)，我们提到 Rovnix 尝试通过使用 `ShellExecuteEx` Win32 API
    来提升权限，从而在受害者机器上获得管理员权限。在 Carberp 版本的 Rovnix 中，下拉程序利用了系统中的以下漏洞来提升权限：
- en: '**MS10-073 in the *win32k.sys* module** This vulnerability was originally used
    by the Stuxnet worm and exploits the incorrect handling of a specially crafted
    keyboard layout file.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**MS10-073 在 *win32k.sys* 模块中的漏洞** 该漏洞最初由 Stuxnet 蠕虫利用，攻击了对特殊构造的键盘布局文件的错误处理。'
- en: '**MS10-092 in Windows Task Scheduler** This vulnerability was also first discovered
    in Stuxnet and exploits the integrity verification mechanism in Windows Scheduler.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**MS10-092 在 Windows 任务计划程序中的漏洞** 该漏洞也首次在 Stuxnet 中被发现，利用了 Windows 计划程序中的完整性验证机制。'
- en: '**MS11-011 in the *win32k.sys* module** This vulnerability results in a stack-based
    buffer overflow in `win32k.sys!RtlQueryRegistryValues` routine.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**MS11-011 在 *win32k.sys* 模块中的漏洞** 该漏洞导致 `win32k.sys!RtlQueryRegistryValues`
    例程中的堆栈溢出。'
- en: '**.NET Runtime Optimization vulnerability** This is a vulnerability in the
    Microsoft .NET Runtime Optimization Service that results in execution of malicious
    code with SYSTEM privileges.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET 运行时优化漏洞** 这是 Microsoft .NET 运行时优化服务中的一个漏洞，导致以 SYSTEM 权限执行恶意代码。'
- en: Yet another interesting feature of the Carberp installer is that it removed
    various hooks from the list of system routines, shown in [Listing 11-8](ch11.xhtml#ch11list08),
    just before installing the trojan or bootkit onto the system. These routines are
    common hook targets for security software, such as sandboxes and host intrusion
    prevention and protection systems. By unhooking these functions, the malware increased
    its ability to evade detection.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的特性是 Carberp 安装程序在将特洛伊木马或引导工具安装到系统之前，从系统例程列表中移除了各种钩子，这些内容在[清单 11-8](ch11.xhtml#ch11list08)中显示。由于这些例程通常是安全软件（如沙箱、主机入侵防护系统等）的钩子目标，因此通过解除钩子，恶意软件增加了绕过检测的能力。
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-8: List of routines unhooked by the Rovnix dropper*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-8：Rovnix 下拉程序解除钩子的例程列表*'
- en: The bootkit and kernel-mode driver sections of the Carberp’s Rovnix modification
    remain the same as in the original version of the bootkit. After successful installation
    onto the system, the malicious IPL code loaded the kernel-mode driver, and the
    driver injected its Carberp trojan payload into the system processes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Carberp 的 Rovnix 修改版中的引导工具和内核模式驱动程序部分与原版引导工具相同。成功安装到系统后，恶意的 IPL 代码加载了内核模式驱动程序，该驱动程序将
    Carberp 特洛伊木马有效载荷注入到系统进程中。
- en: '***Leaked Source Code***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***泄露的源代码***'
- en: In June 2013, the source code for Carberp and Rovnix was leaked to the public.
    The complete archive was made available for download and contained all the necessary
    source code for attackers to build their own Rovnix bootkit. Despite this, we
    haven’t seen as many custom modifications of Rovnix and Carberp in the wild as
    we might expect, which we assume is due to the complexity of this bootkit technology.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年6月，Carberp和Rovnix的源代码泄露给了公众。完整的档案文件可以下载，其中包含了攻击者用来构建自己Rovnix启动病毒的所有必要源代码。尽管如此，我们并没有在现实中看到像预期那样多的Rovnix和Carberp定制版本，这我们推测是因为这种启动病毒技术的复杂性。
- en: '**Conclusion**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter provided a detailed technical analysis of Rovnix in the continuous
    bootkit arms race facing the security industry. Once security software caught
    up with contemporary bootkits infecting the MBR, Rovnix presented another infection
    vector, the IPL, triggering another round of evolution in antivirus technology.
    Due to its IPL infection approach, and its implementation of hidden storage and
    hidden network communication channels, Rovnix is one of the most complex bootkits
    seen in the wild. These features make it a dangerous weapon in the hands of cybercriminals,
    as confirmed by the Carberp case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对Rovnix进行了详细的技术分析，讨论了在安全行业面临的持续启动病毒军备竞赛中，Rovnix的作用。随着安全软件赶上了当时感染MBR的启动病毒，Rovnix则提出了另一种感染途径——IPL，引发了杀毒技术的另一轮进化。由于其IPL感染方法，以及隐藏存储和隐藏网络通信通道的实现，Rovnix成为了在现实中最复杂的启动病毒之一。这些特性使它成为网络犯罪分子手中的一种危险武器，Carberp案件就证明了这一点。
- en: In this chapter we devoted special attention to dissecting Rovnix’s IPL code
    using VMware and IDA Pro, demonstrating the practical usage of these tools in
    the context of bootkit analysis. You can download all the necessary data to repeat
    the steps, or to conduct your own in-depth investigation into Rovnix’s IPL code,
    from *[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们特别关注了使用VMware和IDA Pro剖析Rovnix的IPL代码，展示了这些工具在启动病毒分析中的实际应用。你可以从*[https://nostarch.com/rootkits/](https://nostarch.com/rootkits/)*下载所有必要的数据，重复步骤或进行你自己的深入调查，研究Rovnix的IPL代码。
