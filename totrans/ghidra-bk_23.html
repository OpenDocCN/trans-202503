<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_427"/>
<h2 class="h2" id="ch19"><strong><span class="big">19</span><br/>THE GHIDRA DECOMPILER</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent"><span class="big1">Until now, we’ve focused our reverse engineering analysis on the Listing window and presented Ghidra’s features through the disassembly listing lens. In this chapter, we shift our focus to the Decompiler window and investigate how we can accomplish familiar analysis tasks</span> (and some new ones) with the Decompiler and its associated functionality. We start with a brief overview of the decompilation process before moving on to the functionality available in the Decompiler window. We then walk through some examples to help you identify ways that the Decompiler window can be used to improve your reverse engineering process.</p>
<span epub:type="pagebreak" id="page_428"/>
<h3 class="h3" id="ch19lev350"><strong>Decompiler Analysis</strong></h3>
<p class="noindent">It’s logical to assume that the content in the Decompiler window is derived from the Listing window, but, surprisingly, the contents of the Listing window and Decompiler window are derived independently, which is why they sometimes disagree and why both should be evaluated in context when you’re trying to determine ground truth. The main function of Ghidra’s Decompiler is to convert machine language instructions into p-code (see <a href="ch18.xhtml#ch18">Chapter 18</a>) and then to convert the p-code to C and present it in the Decompiler window.</p>
<p class="indent">In a simplified view, the decompilation process includes three distinct phases. In the first phase, the Decompiler uses the SLEIGH specification file to create a draft of the p-code and derive associated basic blocks and flows. The second phase focuses on simplification: unneeded content such as unreachable code is eliminated, and then control flows are adjusted and tuned in response to the changes. In the wrap-up phase, finishing touches are added, some final checks are made, and the final results are sent through a pretty-printing algorithm before being presented in the Decompiler window. Of course, this greatly simplifies a very complex process, but the main takeaways are the following:<sup><a id="ch19fn1a" href="footnotes.xhtml#ch19fn1">1</a></sup></p>
<ul>
<li><p class="noindent">The Decompiler is an analyzer.</p></li>
<li><p class="noindent">It starts its work with the binary and produces p-code.</p></li>
<li><p class="noindent">It converts the p-code to C.</p></li>
<li><p class="noindent">The C code and any associated messages are displayed in the Decompiler window.</p></li>
</ul>
<p class="indent">We discuss some of these steps in more detail as we navigate through Ghidra’s decompilation functionality. Let’s start our investigation with the analysis process and the primary capabilities it unleashes.</p>
<h4 class="h4" id="ch19lev351"><strong><em>Analysis Options</em></strong></h4>
<p class="noindent">During the auto analysis process, there are several analyzers that pertain to the Decompiler window. Decompiler analysis options are managed through the Edit ▸ Tool Options menu, shown in <a href="ch19.xhtml#fig19_1">Figure 19-1</a> with defaults selected.</p>
<p class="indent">We discuss two of these options, Eliminate unreachable code and Simplify predication, next. For the remaining options, you can experiment with their results or refer to Ghidra Help.</p>
<span epub:type="pagebreak" id="page_429"/>
<div class="image"><img src="Images/fig19-1.jpg" alt="image" width="425" height="369"/></div>
<p class="figcap" id="fig19_1"><em>Figure 19-1: Ghidra Decompiler analysis options with defaults selected</em></p>
<h5 class="h5" id="ch19lev352"><strong>Eliminate Unreachable Code</strong></h5>
<p class="noindent">The Eliminate unreachable code option excludes unreachable code from the Decompiler listing. For example, the following C function has two conditions that can never be met, which makes the corresponding conditional blocks unreachable:</p>
<pre>int demo_unreachable(volatile int a) {<br/>
    volatile int b = a ^ a;<br/>
 <span class="ent">➊</span> if (b) {<br/>
        printf("This is unreachable\n");<br/>
        a += 1;<br/>
    }<br/>
 <span class="ent">➋</span> if (a - a &gt; 0) {<br/>
        printf("This should be unreachable too\n");<br/>
        a += 1;<br/>
    } else {<br/>
        printf("We should always see this\n");<br/>
        a += 2;<br/>
    }<br/>
    printf("End of demo_unreachable()\n");<br/>
    return a;<br/>
}</pre>
<p class="indent">The variable <code>b</code> is initialized to zero in a perhaps less than obvious manner. When <code>b</code> is tested <span class="ent">➊</span>, its value can never be non zero, and the body of the corresponding <code>if</code> statement will never be executed. Similarly <code>a - a</code> can never be greater than zero, and the condition in the second <code>if</code> statement <span class="ent">➋</span> can also never evaluate to true. When the Eliminate unreachable code option is selected, the Decompiler window displays warning messages to let us know it has removed unreachable code.</p>
<span epub:type="pagebreak" id="page_430"/>
<pre>/* WARNING: Removing unreachable block (ram,0x00100777) */<br/>
/* WARNING: Removing unreachable block (ram,0x0010079a) */<br/>
ulong demo_unreachable(int param_1)<br/>
{<br/>
  puts("We should always see this");<br/>
  puts("End of demo_unreachable()");<br/>
  return (ulong)(param_1 + 2);<br/>
}</pre>
<h5 class="h5" id="ch19lev353"><strong>Simplify Predication</strong></h5>
<p class="noindent">This option optimizes <code>if</code>/<code>else</code> blocks by merging blocks that share the same condition. In the following listing, the first two <code>if</code> statements share the same condition:</p>
<pre>int demo_simppred(int a) {<br/>
    if (a &gt; 0) {<br/>
          printf("A is &gt; 0\n");<br/>
    }<br/>
    if (a &gt; 0) {<br/>
          printf("Yes, A is definitely &gt; 0!\n");<br/>
    }<br/>
    if (a &gt; 2) {<br/>
          printf("A &gt; 2\n");<br/>
    }<br/>
    return a * 10;<br/>
}</pre>
<p class="indent">With Simplify predication enabled, the resulting Decompiler listing shows the combined blocks:</p>
<pre>ulong demo_simppred(int param_1)<br/>
{<br/>
  if (0 &lt; param_1) {<br/>
    puts("A is &gt; 0");<br/>
    puts("Yes, A is definitely &gt; 0!");<br/>
  }<br/>
  if (2 &lt; param_1) {<br/>
    puts("A &gt; 2");<br/>
  }<br/>
  return (ulong)(uint)(param_1 * 10);<br/>
}</pre>
<h3 class="h3" id="ch19lev354"><strong>The Decompiler Window</strong></h3>
<p class="noindent">Now that you understand how the Decompiler Analysis Engine populates the Decompiler window, let’s see how you can use the window to facilitate your analysis. Navigating the Decompiler window is relatively easy, as it displays only one function at a time. To move between functions or see the function in context, it is helpful to correlate with the Listing window. Because the <span epub:type="pagebreak" id="page_431"/>Decompiler window and the Listing window are linked by default, you can navigate both by using the available options in the CodeBrowser toolbar.</p>
<p class="indent">The function displayed in the Decompiler window helps with analysis, but it may not be so easy to read at first. Any lack of information about the data types used by the functions that it decompiles requires Ghidra to infer those data types itself. As a result, the decompiler may overuse type casts, as you can see in the following sample statements:</p>
<pre>printf("a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d\n", (ulong)param_1,<br/>
      (ulong)param_2,(ulong)uVar1,(ulong)uVar2,(ulong)(uVar1 + param_1),<br/>
      (ulong)(uVar2 * 100),(ulong)uVar4);<br/>
<br/>
uStack44 = *(undefined4 *)**(undefined4 **)(iStack24 + 0x10);</pre>
<p class="indent">As you provide more accurate type information using the Decompiler editing options, you will notice that the Decompiler relies less and less on type casts, and the generated C code become easier to read. In the examples that follow, we’ll discuss some of the Decompiler window’s most useful features to clean up the generated source code. The ultimate goal is readable source code that is easier to comprehend, which reduces the amount of time needed to understand the behavior of the code.</p>
<h4 class="h4" id="ch19lev355"><strong><em>Example 1: Editing in the Decompiler Window</em></strong></h4>
<p class="noindent">Consider a program that accepts two integer values from the user and then calls the following function:</p>
<pre>int do_math(int a, int b) {<br/>
<br/>
    int c, d, e, f, g;<br/>
    srand(time(0));<br/>
<br/>
    c = rand();<br/>
    printf("c=%d\n", c);<br/>
<br/>
    d = a + b + c;<br/>
    printf("d=%d\n", d);<br/>
<br/>
    e = a + c;<br/>
    printf("e=%d\n", e);<br/>
<br/>
    f = d * 100;<br/>
    printf("f=%d\n", f);<br/>
<br/>
    g = rand() - e;<br/>
    printf("g=%d\n", g);<br/>
<br/>
    printf("a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d\n", a, b, c, d, e, f, g);<br/>
<br/>
    return g;<br/>
}</pre>
<span epub:type="pagebreak" id="page_432"/>
<p class="indent">The function uses two integer parameters with five local variables to generate its output. The interdependencies can be summed up as follows:</p>
<ul>
<li><p class="noindent">Variable <code>c</code> depends on the <code>rand()</code> return value, influences <code>d</code> and <code>e</code> directly, and influences <code>f</code> and <code>g</code> indirectly.</p></li>
<li><p class="noindent">Variable <code>d</code> depends on <code>a</code>, <code>b</code>, and <code>c</code>, and influences <code>f</code> directly.</p></li>
<li><p class="noindent">Variable <code>e</code> depends on <code>a</code> and <code>c</code>, and influences <code>g</code> directly.</p></li>
<li><p class="noindent">Variable <code>f</code> depends on <code>d</code> directly and on <code>a</code>, <code>b</code>, and <code>c</code> indirectly, and influences nothing.</p></li>
<li><p class="noindent">Variable <code>g</code> depends on <code>e</code> directly and on <code>a</code> and <code>c</code> indirectly, and influences nothing.</p></li>
</ul>
<p class="indent">When the associated binary is loaded into Ghidra and the function is analyzed, you see the following representation of the <code>do_math</code> function in the Decompiler window:</p>
<pre>ulong do_math(uint param_1,uint param_2)<br/>
{<br/>
    uint uVar1;<br/>
    uint uVar2;<br/>
    int iVar3;<br/>
    uint uVar4;<br/>
    time_t tVar5;<br/>
  <br/>
    tVar5 = time((time_t *)0x0);<br/>
    srand((uint)tVar5);<br/>
    uVar1 = rand();<br/>
    printf("c=%d\n");<br/>
    uVar2 = uVar1 + param_1 + param_2;<br/>
  <span class="ent">➊</span> printf("d=%d\n");<br/>
    printf("e=%d\n");<br/>
    printf("f=%d\n");<br/>
    iVar3 = rand();<br/>
    uVar4 = iVar3 - (uVar1 + param_1);<br/>
    printf("g=%d\n");<br/>
    printf("a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d\n", (ulong)param_1,<br/>
          (ulong)param_2,(ulong)uVar1,(ulong)uVar2,(ulong)(uVar1 + param_1),<br/>
          (ulong)(uVar2 * 100),(ulong)uVar4);<br/>
    return (ulong)uVar4;<br/>
  }</pre>
<p class="indent">If you want to do your analysis using the Decompiler, you’ll want to make sure the code the Decompiler is generating is as accurate as possible. Usually, this is done by providing as much information as possible about data types and function prototypes. Functions that accept a variable number of arguments, such as <code>printf</code>, are especially tricky for the Decompiler since the Decompiler would need to fully understand the semantics of the required arguments in order to estimate the number of supplied optional arguments.</p>
<span epub:type="pagebreak" id="page_433"/>
<h5 class="h5" id="ch19lev356"><strong>Overriding Function Signatures</strong></h5>
<p class="noindent">You can see a number of <code>printf</code> statements <span class="ent">➊</span> that don’t look quite right. Each one has a format string but no additional arguments. Since <code>printf</code> takes a variable number of arguments, you can override the function signature at each calling location and (based on the format string) indicate that the <code>printf</code> statement should take one integer argument.<sup><a id="ch19fn2a" href="footnotes.xhtml#ch19fn2">2</a></sup> To make this change, right-click a <code>printf</code> statement and choose <strong>Override Signature</strong> from the context menu to open the dialog shown in <a href="ch19.xhtml#fig19_2">Figure 19-2</a>.</p>
<div class="image"><img src="Images/fig19-2.jpg" alt="image" width="497" height="275"/></div>
<p class="figcap" id="fig19_2"><em>Figure 19-2: The Override Signature dialog</em></p>
<p class="indent">Adding the second parameter type, <code>int</code>, to the signature (as shown in the figure) for each of the <code>printf</code> statements results in the following listing:</p>
<pre> ulong do_math(uint param_1,uint param_2)<br/>
 {<br/>
<span class="ent">➊</span> uint uVar1;<br/>
   uint uVar2;<br/>
   uint uVar3;<br/>
   int iVar4;<br/>
   uint uVar5;<br/>
   time_t tVar6;<br/>
 <br/>
   tVar6 = time((time_t *)0x0);<br/>
   srand((uint)tVar6);<br/>
   uVar1 = rand();<br/>
   printf("c=%d\n",uVar1);<br/>
   uVar2 = uVar1 + param_1 + param_2;<br/>
   printf("d=%d\n",uVar2);<br/>
<span class="ent">➋</span> uVar3 = uVar1 + param_1;<br/>
   printf("e=%d\n",uVar3);<br/>
   printf("f=%d\n",uVar2 * 100);<br/>
   iVar4 = rand();<br/>
<span class="ent">➌</span> uVar5 = iVar4 - uVar3;<br/>
   printf("g=%d\n",uVar5);<br/>
<span class="ent">➍</span> printf("a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d\n", (ulong)param_1,<br/>
<span epub:type="pagebreak" id="page_434"/>
         (ulong)param_2,(ulong)uVar1,(ulong)uVar2,(ulong)(uVar1 + param_1),<br/>
         (ulong)(uVar2 * 100),(ulong)uVar4);<br/>
   return (ulong)uVar4;<br/>
 }</pre>
<p class="indent">In addition to the updated calls to <code>printf</code> with the correct arguments, two new lines have been added to the Decompiler listing as a result of overriding the <code>printf</code> function <span class="ent">➋ ➌</span>. These statements weren’t included previously because Ghidra believed the results were not used. Once the Decompiler understands that the results are used in each <code>printf</code>, the statements become meaningful and are displayed in the Decompiler window.</p>
<h5 class="h5" id="ch19lev357"><strong>Editing Variable Types and Names</strong></h5>
<p class="noindent">After correcting the function calls, you can continue cleaning up the listing by renaming (hotkey L) and retyping (hotkey <span class="small">CTRL-</span>L) the parameters and the variables <span class="ent">➊</span> based on the names found in the <code>printf</code> format strings. As an aside, format strings are an extremely valuable source of information regarding the type and purpose of variables in any program.</p>
<p class="indent">After these changes have been completed, the final <code>printf</code> statement <span class="ent">➍</span> is still a bit cumbersome:</p>
<pre>printf("a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d\n", (ulong)a,<br/>
      (ulong)(uint)b, (ulong)(uint)c, (ulong)(uint)d, (ulong)(uint)e,<br/>
      (ulong)(uint)(d * 100),(ulong)(uint)g);</pre>
<p class="indent">Right-clicking this statement allows you to override the function signature. The first argument in this <code>printf</code> statement is the format string, and it doesn’t need to be modified. Changing the rest of the arguments to type <code>int</code> results in the following cleaner code (<a href="ch19.xhtml#exa19_1">Listing 19-1</a>) in the Decompiler window.</p>
<pre>int do_math(int a, int b)<br/>
{<br/>
  int c;<br/>
  int d;<br/>
  int e;<br/>
  int g;<br/>
  time_t tVar1;<br/>
<br/>
  tVar1 = time((time_t *)0x0);<br/>
  srand((uint)tVar1);<br/>
  c = rand();<br/>
  printf("c=%d\n",c);<br/>
  d = c + a + b;<br/>
  printf("d=%d\n",d);<br/>
  e = c + a;<br/>
  printf("e=%d\n",e);<br/>
  printf("f=%d\n",d * 100);<br/>
  g = rand();<br/>
  g = g - e;<br/>
  printf("g=%d\n",g);<br/>
<span epub:type="pagebreak" id="page_435"/>
  printf("a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d\n",a,b,c,d,e,d * 100<span class="ent">➊</span>,g);<br/>
  return g;<br/>
}</pre>
<p class="ex-caption" id="exa19_1"><em>Listing 19-1: Decompiled function with updated signatures</em></p>
<p class="indent">This is very similar to our original source code and much easier to read than the original Decompiler listing as the modifications of the function arguments have been propagated throughout the listing. One difference between the Decompiler listing and our original source code is that the variable <code>f</code> has been replaced by an equivalent expression <span class="ent">➊</span>.</p>
<h5 class="h5" id="ch19lev358"><strong>Highlighting Slices</strong></h5>
<p class="noindent">Now that you have a more understandable Decompiler window, you can begin further analysis. Suppose that you want to know how individual variables affect and are affected by other variables. A <em>program slice</em> is a collection of statements that contribute to the value of a variable (<em>backward slice</em>) or are affected by a variable (<em>forward slice</em>). In vulnerability analysis scenarios, this might manifest as “I have control of this variable; where does its value get used?”</p>
<p class="indentb">Ghidra provides five options in its right-click context menu to highlight relationships between variables and instructions in a function. If you right-click a variable in the Decompiler window, you can choose from the following options:</p>
<p class="uln-indent"><strong>Highlight Def-use</strong> This option highlights all uses of the variable within the function. (You can use a middle mouse click to get the same effect.)</p>
<p class="uln-indent"><strong>Highlight Forward Slice</strong> This option highlights everything that is impacted by the value in the selected variable. For example, if you select variable <code>b</code> in <a href="ch19.xhtml#exa19_1">Listing 19-1</a> and choose this option, all occurrences of <code>b</code> and <code>d</code> will be highlighted in the listing, because a change in the value of <code>b</code> could also result in a change in the value of <code>d</code>.</p>
<p class="uln-indent"><strong>Highlight Backward Slice</strong> This is the inverse of the previous option and highlights all of the variables that contribute to a particular value. If you right-click variable <code>e</code> in the final <code>printf</code> statement in <a href="ch19.xhtml#exa19_1">Listing 19-1</a> and choose this option, all of the variables that affect the value of <code>e</code> (in this case <code>e</code>, <code>a</code>, and <code>c</code>) will be highlighted. Changing <code>a</code> or <code>c</code> could also change the value of <code>e</code>.</p>
<p class="uln-indent"><strong>Highlight Forward Inst Slice</strong> This option highlights the entire statement associated with the Highlight Forward Slice option. In <a href="ch19.xhtml#exa19_1">Listing 19-1</a>, if you use this option while variable <code>b</code> is selected, all statements in which <code>b</code> or <code>d</code> appear will be highlighted.</p>
<p class="uln-indent"><strong>Highlight Backward Inst Slice</strong> This option highlights the entire statement associated with the Highlight Backward Slice option. In <a href="ch19.xhtml#exa19_1">Listing 19-1</a>, selecting this option while highlighting variable <code>e</code> in the final <code>printf</code> statement will cause all statements in which <code>a</code>, <code>c</code>, or <code>e</code> appear to be highlighted.</p>
<span epub:type="pagebreak" id="page_436"/>
<p class="indenta">Now that we have a general understanding of some approaches to work with the Decompiler window and use it in our analysis, let’s look at a more specific example.</p>
<h4 class="h4" id="ch19lev359"><strong><em>Example 2: Non-Returning Functions</em></strong></h4>
<p class="noindent">In general, Ghidra can safely assume function calls return and therefore treat function calls as if they exhibit sequential flow within basic blocks. However, some functions, such as those marked with the <code>noreturn</code> keyword in source code, or ended with an obfuscated jump instruction in malware, do not return, and Ghidra may generate inaccurate disassembled or decompiled code. Ghidra offers three approaches for dealing with non-returning functions: two non-returning function analyzers and the capability to edit function signatures manually.</p>
<p class="indent">Ghidra can identify non-returning functions based on a list of known <code>noreturn</code> functions such as <code>exit</code> and <code>abort</code> using the Non-Returning Functions-Known analyzer. This analyzer is selected by default as part of auto analysis, and its job is straightforward: if a function name appears in its list, it marks the function as non-returning and does its best to correct any associated issues (for example, set associated calls to non-returning, find flows that might need repairing, and so on).</p>
<p class="indent">The Non-Returning Functions-Discovered analyzer looks for clues that might indicate that a function doesn’t return (for example, data or bad instructions right after the call). What it does with the information is largely controlled by the three options associated with the analyzer, as shown in <a href="ch19.xhtml#fig19_3">Figure 19-3</a>.</p>
<div class="image"><img src="Images/fig19-3.jpg" alt="image" width="574" height="333"/></div>
<p class="figcap" id="fig19_3"><em>Figure 19-3: Analysis options for Non-Returning Functions-Discovered</em></p>
<p class="indent">The first option <span class="ent">➊</span> allows the automatic creation of analysis bookmarks (which appear on the Listing window’s bookmark bar). The second option <span class="ent">➋</span> allows you to specify a threshold that determines whether to designate a function as non-returning based on a series of checks for <span epub:type="pagebreak" id="page_437"/>characteristics that are likely to indicate a non-returning function. Finally, there is a checkbox <span class="ent">➌</span> to repair the associated flow damage.</p>
<p class="indent">When Ghidra is unable to identify a non-returning function, you have the option to edit the function signature yourself. If you complete analysis and have error bookmarks, which are used to flag bad instructions, then that is a good indication that something is not quite right with Ghidra’s own analysis. If the bad instruction follows a <code>CALL</code>, as in</p>
<pre>00100839                 CALL          noReturnA<br/>
0010083e                 ??            FFh</pre>
<p class="noindent">then you are likely to see an associated post-comment warning you about the situation in the Decompiler window, like this:</p>
<pre>  noReturnA(1);<br/>
  /* WARNING: Bad instruction - Truncating control flow here */<br/>
  halt_baddata();</pre>
<p class="indent">If you click the function name (<code>noReturnA</code> in this case) in the Decompiler window and then choose Edit Function Signature, you will have the option to modify attributes associated with the function, as shown in <a href="ch19.xhtml#fig19_4">Figure 19-4</a>.</p>
<div class="image"><img src="Images/fig19-4.jpg" alt="image" width="574" height="221"/></div>
<p class="figcap" id="fig19_4"><em>Figure 19-4: Editing function attributes</em></p>
<p class="indent">Check the No Return box to mark the function as non-returning. Ghidra then inserts a pre comment, shown next, in the Decompiler window as well as a post comment in the Listing window:</p>
<pre>  /* WARNING: Subroutine does not return */<br/>
  noReturnA(1);</pre>
<p class="indent">With this error corrected, you can move on to other issues.</p>
<h4 class="h4" id="ch19lev360"><strong><em>Example 3: Automated Structure Creation</em></strong></h4>
<p class="noindent">When analyzing decompiled C source code, you’re likely to come across statements that appear to contain structure field references. Ghidra helps you create a structure and populate it based on the associated references <span epub:type="pagebreak" id="page_438"/>that the Decompiler has detected. Let’s walk through an example starting with the source code and Ghidra’s initial decompilation of the code.</p>
<p class="indent">Suppose you have source code that defines two struct types and then creates a global instance of each:</p>
<pre><span class="ent">➊</span> struct s1 {<br/>
      int a;<br/>
      int b;<br/>
      int c;<br/>
   };<br/>
  <br/>
<span class="ent">➋</span> typedef struct s2 {<br/>
       int x;<br/>
       char y;<br/>
       float z;<br/>
   } s2_type;<br/>
   <br/>
   struct s1 GLOBAL_S1;<br/>
   s2_type GLOBAL_S2;</pre>
<p class="indent">One structure <span class="ent">➊</span> contains homogeneous elements, and the other <span class="ent">➋</span> contains a heterogeneous collection of types. The source code also contains three functions, one of which (<code>do_struct_demo</code>) declares a local instance of each structure type:</p>
<pre>void display_s1(struct s1* s) {<br/>
    printf("The fields in s1 = %d, %d, and %d\n", s-&gt;a, s-&gt;b, s-&gt;c);<br/>
}<br/>
<br/>
void update_s2(s2_type* s, int v) {<br/>
    s-&gt;x = v;<br/>
    s-&gt;y = (char)('A' + v);<br/>
    s-&gt;z = v * 2.0;<br/>
}<br/>
<br/>
void do_struct_demo() {<br/>
    s2_type local_s2;<br/>
    struct s1 local_s1;<br/>
<br/>
    printf("Enter six ints: ");<br/>
    scanf("%d %d %d %d %d %d", (int *)&amp;local_s1, &amp;local_s1.b, &amp;local_s1.c,<br/>
          &amp;GLOBAL_S1.a, &amp;GLOBAL_S1.b, &amp;GLOBAL_S1.c);<br/>
<br/>
    printf("You entered: %d and %d\n", local_s1.a, GLOBAL_S1.a);<br/>
    display_s1(&amp;local_s1);<br/>
    display_s1(&amp;GLOBAL_S1);<br/>
<br/>
    update_s2(&amp;local_s2, local_s1.a);<br/>
}</pre>
<span epub:type="pagebreak" id="page_439"/>
<p class="indent">The decompiled version of <code>do_struct_demo</code> appears in <a href="ch19.xhtml#exa19_2">Listing 19-2</a>.</p>
<pre>void do_struct_demo(void)<br/>
{<br/>
   undefined8 uVar1;<br/>
   uint local_20;<br/>
   undefined local_1c [4];<br/>
   undefined local_18 [4];<br/>
   undefined local_14 [12];<br/>
 <br/>
   uVar1 = 0x100735;<br/>
   printf("Enter six ints: ");<br/>
   __isoc99_scanf("%d %d %d %d %d %d", &amp;local_20, local_1c, local_18,<br/>
                  GLOBAL_S1,0x30101c,0x301020,uVar1);<br/>
   printf("You entered: %d and %d\n",(ulong)local_20,(ulong)GLOBAL_S1._0_4_);<br/>
<span class="ent">➊</span> display_s1(&amp;local_20);<br/>
<span class="ent">➋</span> display_s1(GLOBAL_S1);<br/>
   update_s2(local_14,(ulong)local_20,(ulong)local_20);<br/>
   return;<br/>
}</pre>
<p class="ex-caption" id="exa19_2"><em>Listing 19-2: Initial decompilation of</em> <code>do_struct_demo</code></p>
<p class="indent">Navigating to the <code>display_s1</code> function from either function call <span class="ent">➊➋</span> by double-clicking it in the Decompiler window yields the following:</p>
<pre>void display_s1(uint *param_1)<br/>
{<br/>
  printf("The fields in s1 = %d, %d, and %d\n", (ulong)*param_1,<br/>
        (ulong)param_1[1],(ulong)param_1[2]);<br/>
  return;<br/>
}</pre>
<p class="indent">Because you suspect the argument to <code>display_s1</code> might be a structure pointer, you can ask Ghidra to automate the process of creating a struct for you by right-clicking <code>param_1</code> in the function’s argument list and selecting Auto Create Structure from the context menu. In response, Ghidra tracks all uses of <code>param_1</code>, treats all arithmetic performed on the pointer as referencing a member of a struct, and automatically creates a new struct type containing fields at each referenced offset. This changes a few things in the Decompiler listing:</p>
<pre>void display_s1(astruct *param_1)<br/>
{<br/>
  printf("The fields in s1 = %d, %d, and %d\n",(ulong)param_1-&gt;field_0x0,<br/>
        (ulong)param_1-&gt;field_0x4,(ulong)param_1-&gt;field_0x8);<br/>
  return;<br/>
}</pre>
<span epub:type="pagebreak" id="page_440"/>
<p class="indent">The type of the parameter has changed and is now <code>astruct*</code>, and the call to <code>printf</code> now contains field references. The new type has also been added to the Data Type Manager, and hovering over the structure name displays the field definitions, as shown in <a href="ch19.xhtml#fig19_5">Figure 19-5</a>.</p>
<div class="image"><img src="Images/fig19-5.jpg" alt="image" width="327" height="438"/></div>
<p class="figcap" id="fig19_5"><em>Figure 19-5: Automatic structs in the Data Type Manager</em></p>
<p class="indent">You can update the type for <code>local_20</code> and <code>GLOBAL_S1</code> to <code>astruct</code> by using the Retype Variable option from the right-click context menu. The results are shown in the following listing:</p>
<pre> void do_struct_demo(void)<br/>
 {<br/>
   undefined8 uVar1;<br/>
<span class="ent">➊</span> astruct local_20;<br/>
   undefined local_14 [12];<br/>
 <br/>
   uVar1 = 0x100735;<br/>
   printf("Enter six ints: ");<br/>
   __isoc99_scanf("%d %d %d %d %d %d", &amp;local_20, &amp;local_20.field_0x4<span class="ent">➋</span>,<br/>
             <span class="ent">➌</span> &amp;local_20.field_0x8, &amp;GLOBAL_S1, 0x30101c, 0x301020, uVar1);<br/>
   printf("You entered: %d and  %d\n", (ulong)local_20.field_0x0,<br/>
      <span class="ent">➍</span> (ulong)GLOBAL_S1.field_0x0);<br/>
   display_s1(&amp;local_20);<br/>
   display_s1(&amp;GLOBAL_S1);<br/>
   update_s2(local_14,(ulong)local_20.field_0x0,(ulong)local_20.field_0x0);<br/>
   return;<br/>
 }</pre>
<p class="indent">Comparing this with <a href="ch19.xhtml#exa19_2">Listing 19-2</a> shows the modification of the type for <code>local_20</code> <span class="ent">➊</span> and the addition of field references for both <code>local_20</code> <span class="ent">➋ ➌</span> and <code>GLOBAL_S1</code> <span class="ent">➍</span>.</p>
<span epub:type="pagebreak" id="page_441"/>
<p class="indent">Let’s shift focus to the decompilation of the third function, <code>update_s2</code>, shown in <a href="ch19.xhtml#exa19_3">Listing 19-3</a>.</p>
<pre>void update_s2(int *param_1,int param_2)<br/>
{<br/>
  *param_1 = param_2;<br/>
  *(char *)(param_1 + 1) = (char)param_2 + 'A';<br/>
  *(float *)(param_1 + 2) = (float)param_2 + (float)param_2;<br/>
  return;<br/>
}</pre>
<p class="ex-caption" id="exa19_3"><em>Listing 19-3: Initial decompilation of</em> <code>update_s2</code></p>
<p class="indent">You can use the previous approach to automatically create a structure for <code>param_1</code>. Simply right-click <code>param_1</code> in the function and choose <strong>Auto Create Structure</strong> from the context menu.</p>
<pre>void update_s2(astruct_1 *param_1,int param_2)<br/>
{<br/>
  param_1-&gt;field_0x0 = param_2;<br/>
  param_1-&gt;field_0x4 = (char)param_2 + 'A';<br/>
  param_1-&gt;field_0x8 = (float)param_2 + (float)param_2;<br/>
  return;<br/>
}</pre>
<p class="indent">The Data Type Manager now has a second struct definition associated with this file, as shown in <a href="ch19.xhtml#fig19_6">Figure 19-6</a>.</p>
<div class="image"><img src="Images/fig19-6.jpg" alt="image" width="342" height="535"/></div>
<p class="figcap" id="fig19_6"><em>Figure 19-6: Additional automatic structs in the Data Type Manager window</em></p>
<span epub:type="pagebreak" id="page_442"/>
<p class="indent">This structure has an <code>int</code>, a <code>char</code>, three <code>undefined</code> bytes (likely padding inserted by the compiler), and a <code>float</code>. To edit the structure, right-click <code>astruct_1</code> and choose Edit from the context menu, which opens the Structure Editor window. If we choose to name the <code>int</code> field <code>x</code>, the <code>char</code> field <code>y</code>, and the <code>float</code> field <code>z</code>, and then save the changes, the new field names will be reflected in the Decompiler listing:</p>
<pre>void update_s2(astruct_1 *param_1,int param_2)<br/>
{<br/>
  param_1-&gt;x = param_2;<br/>
  param_1-&gt;y = (char)param_2 + 'A';<br/>
  param_1-&gt;z = (float)param_2 + (float)param_2;<br/>
  return;<br/>
}</pre>
<p class="indent">This listing is much easier to read and understand than the original decompilation in <a href="ch19.xhtml#exa19_3">Listing 19-3</a>.</p>
<h3 class="h3" id="ch19lev361"><strong>Summary</strong></h3>
<p class="noindent">The Decompiler window, like the Listing window, provides you with a view into a binary, and each has its associated strengths and weaknesses. The Decompiler provides a higher-level view that can help you understand the general structure and functionality of a single function more quickly than looking at the disassembly (particularly for those who do not have years of experience reading disassembly listings). The Listing window provides a lower-level view of the entire binary, with all of the available detail, but this can make it more difficult to gain insight into the big picture.</p>
<p class="indent">Ghidra’s Decompiler can be used effectively with the Listing window and all of the other tools we have introduced throughout the book to aid you in your reverse engineering process. In the end, it is the reverse engineer’s role to determine the best approach to solving the problem at hand.</p>
<p class="indent">This chapter focused on the Decompiler window and issues associated with decompilation. Many of challenges can be traced to the wide variety of compilers and associated compiler options that directly influence the resulting binary. In the next chapter, we take a look at some compiler-specific behaviors and compiler build options to better understand the resulting binaries.</p>
</div>



  </body></html>