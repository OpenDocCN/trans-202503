<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Levels, Sound, and More"><div class="titlepage"><div><div><h1 class="title"><a id="levelscomma_soundcomma_and_more"/>Chapter 7. Levels, Sound, and More</h1></div></div></div><p><a id="iddle1444" class="indexterm"/><a id="iddle2005" class="indexterm"/><a id="iddle2015" class="indexterm"/><a id="iddle2158" class="indexterm"/><a id="iddle2450" class="indexterm"/>In this chapter, we’ll add a few finishing touches to <span class="emphasis"><em>Bubble Shooter</em></span> and cover a few more features of HTML5. Right now, the bubble grid could fill up the entire page in no time, giving players no room to fire bubbles. To prevent this from happening, we’ll make the game end if the player adds more than two rows to the bottom of the board. We’ll also implement multiple levels and high scores using the Local Storage API, smooth out animation with <code class="literal">requestAnimationFrame</code>, and add sound to the game with HTML5. Let’s start by adding multiple levels and high scores.</p><div class="sect1" title="Multiple Levels and High Scores"><div class="titlepage"><div><div><h1 class="title"><a id="multiple_levels_and_high_scores"/>Multiple Levels and High Scores</h1></div></div></div><p><a id="iddle1321" class="indexterm"/><a id="iddle1812" class="indexterm"/><a id="iddle1971" class="indexterm"/><a id="iddle2159" class="indexterm"/><a id="iddle2326" class="indexterm"/><a id="iddle2387" class="indexterm"/><a id="iddle2443" class="indexterm"/>It’s possible to complete a level by clearing out all of the bubbles, but thereafter, if you want to play again, you must refresh the browser. Obviously, this is not satisfactory for a game, and a few other game flow elements are missing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A limited supply of bubbles (otherwise, the player can continue firing forever and cause the bubble counter to display negative numbers!)</p></li><li class="listitem"><p>A scoring system</p></li><li class="listitem"><p>End-of-level conditions</p></li><li class="listitem"><p>Further levels</p></li></ul></div><p>The game will award points for each bubble popped, and those points will add up to the player’s score. We already have the information we need to limit the player’s bubble supply, because we count the bubbles, although our count can go into negative numbers. To add multiple levels that increase in difficulty, we’ll give the player fewer bubbles at each level.</p><div class="sect2" title="New Game State Variables"><div class="titlepage"><div><div><h2 class="title"><a id="new_game_state_variables"/>New Game State Variables</h2></div></div></div><p>The first steps we need to take are incorporating the bubble counter and creating other game state variables. We could create a new object to store all of the game state parameters, such as the player’s score, the number of bubbles remaining, the level number, and so on. Alternatively, we could store these as variables inside the <code class="literal">Game</code> object. I’ve opted for the latter because there are only three values to track. If you need to track more information or if the information to track is more complex, it’s best to store the data in its own object to keep <span class="emphasis"><em>game.js</em></span> as small and readable as possible.</p><p>Let’s add a few new variables to the top of the <code class="literal">Game</code> class and give the player a different number of bubbles to complete the level based on the level number:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00148"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      var curBubble;
      var board;
      var numBubbles;
      var bubbles = [];
      var MAX_BUBBLES = 70;
➊    <span class="strong"><strong>var POINTS_PER_BUBBLE = 50;</strong></span>
➋    <span class="strong"><strong>var level = 0;</strong></span>
➌    <span class="strong"><strong>var score = 0;</strong></span>
➍    <span class="strong"><strong>var highScore = 0;</strong></span>
      var requestAnimationID;
      this.init = function(){
        --<span class="emphasis"><em>snip</em></span>--
      };
      var startGame = function(){
        $(".but_start_game").unbind("click");
        BubbleShoot.ui.hideDialog();
➎      numBubbles = MAX_BUBBLES <span class="strong"><strong>- level * 5;</strong></span>
        board = new BubbleShoot.Board();
        bubbles = board.getBubbles();
        if(BubbleShoot.Renderer)
        {
          if(!requestAnimationID)
            requestAnimationID = setTimeout(renderFrame,40);
        }else{
          BubbleShoot.ui.drawBoard(board);
        };
        curBubble = getNextBubble();
        $("#game").bind("click",clickGameScreen);
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1441" class="indexterm"/><a id="iddle1952" class="indexterm"/><a id="iddle2149" class="indexterm"/><a id="iddle2192" class="indexterm"/><a id="iddle2447" class="indexterm"/><a id="iddle2558" class="indexterm"/>We’ve created new variables for the number of points to award for each bubble ➊, the player’s current level ➋, their current score ➌, and a high score ➍. When the game starts, we reduce the number of bubbles by 5 for every level the player has completed ➎. At the first level, players are given 70 bubbles, at level 2, they have 65, and so on.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>You may notice a couple of problems with the way we are calculating the number of bubbles available. First, it’s impossible to complete level 14, because the number of bubbles the user would be given would be zero at this point. Second, the levels leading up to this will be extremely difficult. It’s hard to imagine being able to complete a level with 20 or 30 bubbles, let alone only 10 or 15! I’ll leave a solution to this problem as an exercise for the end of the chapter.</em></span></p></div></div><div class="sect2" title="Display Level and Score"><div class="titlepage"><div><div><h2 class="title"><a id="display_level_and_score"/>Display Level and Score</h2></div></div></div><p>We don’t have anywhere to display the score yet, so we’ll add a DOM element to <span class="emphasis"><em>index.html</em></span> for that, as well as somewhere to display the current level and high score. The bar at the top of the screen is a good place in the layout to display that information. The new elements are shown at the top of <a class="xref" href="ch07.html#screen_layout_showing_levelcomma_scoreco" title="Figure 7-1. Screen layout showing level, score, and high score display">Figure 7-1</a>.</p><div class="figure"><a id="screen_layout_showing_levelcomma_scoreco"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00025"/><img src="httpatomoreillycomsourcenostarchimages2184537.png.jpg" alt="Screen layout showing level, score, and high score display"/></div></div><p class="title">Figure 7-1. Screen layout showing level, score, and high score display</p></div><p><a id="iddle1329" class="indexterm"/><a id="iddle1442" class="indexterm"/><a id="iddle2016" class="indexterm"/><a id="iddle2150" class="indexterm"/><a id="iddle2448" class="indexterm"/><span class="emphasis"><em>index.html</em></span></p><a id="pro_id00149"/><pre class="programlisting">  &lt;!DOCTYPE HTML&gt;
  &lt;html lang="en-US"&gt;
  &lt;head&gt;
    --<span class="emphasis"><em>snip</em></span>--
  &lt;/head&gt;
  &lt;body&gt;
  &lt;div id="page"&gt;
    &lt;div id="top_bar"&gt;
➊    <span class="strong"><strong>&lt;div id="top_level_box" class="top_bar_box"&gt;</strong></span>
        <span class="strong"><strong>&lt;div id="top_level_label"&gt;Level:&lt;/div&gt;</strong></span>
        <span class="strong"><strong>&lt;div id="level"&gt;1&lt;/div&gt;</strong></span>
      <span class="strong"><strong>&lt;/div&gt;</strong></span>
➋    <span class="strong"><strong>&lt;div class="top_bar_box"&gt;</strong></span>
        <span class="strong"><strong>&lt;div id="top_score_label"&gt;Score:&lt;/div&gt;</strong></span>
        <span class="strong"><strong>&lt;div id="score"&gt;0&lt;/div&gt;</strong></span>
      <span class="strong"><strong>&lt;/div&gt;</strong></span>
➌    <span class="strong"><strong>&lt;div class="top_bar_box"&gt;</strong></span>
        <span class="strong"><strong>&lt;div id="top_score_label"&gt;High Score:&lt;/div&gt;</strong></span>
        <span class="strong"><strong>&lt;div id="high_score"&gt;0&lt;/div&gt;</strong></span>
      <span class="strong"><strong>&lt;/div&gt;</strong></span>
    &lt;/div&gt;
    --<span class="emphasis"><em>snip</em></span>--
  &lt;/div&gt;
  &lt;/body&gt;
  &lt;/html&gt;</pre><p><a id="iddle1342" class="indexterm"/><a id="iddle1345" class="indexterm"/><a id="iddle1884" class="indexterm"/>Three new <code class="literal">&lt;div&gt;</code> elements were added: one each for the level number ➊, the current game score ➋, and the high score ➌. Each <code class="literal">&lt;div&gt;</code> has an element to display the label and then a value.</p><p>These also need style definitions in <span class="emphasis"><em>main.css</em></span>:</p><p><span class="emphasis"><em>main.css</em></span></p><a id="pro_id00150"/><pre class="programlisting">  body
  {
    margin: 0;
  }
  #page
  {
    position: absolute;
    left: 0;
    top: 0;
    width: 1000px;
    height: 738px;
  }
    #top_bar
    {
      position: absolute;
      left: 0;
      top: 0;
      width: 1000px;
      height: 70px;
      background-color: #369;
      color: #fff;
    }
➊    <span class="strong"><strong>.top_bar_box</strong></span>
      <span class="strong"><strong>{</strong></span>
        <span class="strong"><strong>font-size: 24px;</strong></span>
        <span class="strong"><strong>line-height: 60px;</strong></span>
        <span class="strong"><strong>float: left;</strong></span>
        <span class="strong"><strong>margin-left:20px;</strong></span>
        <span class="strong"><strong>width: 250px;</strong></span>
      <span class="strong"><strong>}</strong></span>
➋      <span class="strong"><strong>.top_bar_box div</strong></span>
        <span class="strong"><strong>{</strong></span>
          <span class="strong"><strong>float: left;</strong></span>
          <span class="strong"><strong>margin-right: 20px;</strong></span>
        <span class="strong"><strong>}</strong></span>
  --<span class="emphasis"><em>snip</em></span>--</pre><p>I haven’t styled each of the three elements individually; instead, I’ve given them a common class of <code class="literal">top_bar_box</code> ➊. The basic CSS styling gives each element a width of 250 pixels and floats it to the left, so the elements form a row at the top of the screen inside <code class="literal">top_bar</code>. The label and value displayed for each element is inside a <code class="literal">&lt;div&gt;</code>, so the styling for that is applied without creating a new CSS class ➋.</p><p>Now let’s award some points to the player and display their score and level. Points need to be awarded and displayed whenever bubbles are popped <a id="iddle1953" class="indexterm"/><a id="iddle1967" class="indexterm"/><a id="iddle2559" class="indexterm"/><a id="iddle2618" class="indexterm"/><a id="iddle2619" class="indexterm"/><a id="iddle2640" class="indexterm"/>or orphaned, and score and level values should be displayed at the start of the game. First, we need functions in <span class="emphasis"><em>ui.js</em></span> to draw the values to the screen. We’ll put them inside <span class="emphasis"><em>ui.js</em></span> to continue to keep <span class="emphasis"><em>game.js</em></span> free of display code:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00151"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.ui = (function($){
    --<span class="emphasis"><em>snip</em></span>--
    var ui = {
      --<span class="emphasis"><em>snip</em></span>--
➊    <span class="strong"><strong>drawScore : function(score){</strong></span>
        <span class="strong"><strong>$("#score").text(score);</strong></span>
      <span class="strong"><strong>},</strong></span>
➋    <span class="strong"><strong>drawHighScore : function(highScore){</strong></span>
        <span class="strong"><strong>$("#high_score").text(highScore);</strong></span>
      <span class="strong"><strong>},</strong></span>
➌    <span class="strong"><strong>drawLevel : function(level){</strong></span>
        <span class="strong"><strong>$("#level").text(level+1);</strong></span>
      <span class="strong"><strong>}</strong></span>
    };
    --<span class="emphasis"><em>snip</em></span>--
    return ui;
  } )(jQuery);</pre><p><code class="literal">drawScore</code> ➊ and <code class="literal">drawHighScore</code> ➋ accept score values and draw them into the relevant <code class="literal">&lt;div&gt;</code>s on the screen. <code class="literal">drawLevel</code> writes the level number but adds 1 to it first, because the internal level state starts at zero ➌. Although all three of these functions contain only a single line of code, it’s a good idea to create separate functions for them and write, for example, <code class="literal">ui.drawScore(score)</code> rather than <code class="literal">$("#score").text(score)</code> each time you update the score value. Then, if you want to add visual effects to any of the elements when they change, you can do so in one function without tracking down every instance where the score is updated. If you want the score to flash, say, every time it increases, then you would only need to make the change in one place.</p><p>Now we add calls to these functions into <span class="emphasis"><em>game.js</em></span> within <code class="literal">startGame</code> and <code class="literal">clickScreen</code>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00152"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      var startGame = function(){
        $(".but_start_game").unbind("click");
        BubbleShoot.ui.hideDialog();
        numBubbles = MAX_BUBBLES;
        board = new BubbleShoot.Board();
        bubbles = board.getBubbles();
        if(BubbleShoot.Renderer)
        {
          if(!requestAnimationID)
            requestAnimationID = setTimeout(renderFrame,40);
        }else{
          BubbleShoot.ui.drawBoard(board);
        };
        curBubble = getNextBubble();
        $("#game").bind("click",clickGameScreen);
➊      <span class="strong"><strong>BubbleShoot.ui.drawScore(score);</strong></span>
        <span class="strong"><strong>BubbleShoot.ui.drawLevel(level);</strong></span>
      };
      var clickGameScreen = function(e){
        var angle = BubbleShoot.ui.getBubbleAngle(curBubble.getSprite(),e,board.
          calculateTop());
        var duration = 750;
        var distance = 1000;
        var collision = BubbleShoot.CollisionDetector.findIntersection(curBubble,
          board,angle);
        if(collision){
          var coords = collision.coords;
          duration = Math.round(duration * collision.distToCollision / distance);
          board.addBubble(curBubble,coords);
          var group = board.getGroup(curBubble,{});
          if(group.list.length &gt;= 3){
            popBubbles(group.list,duration);
            var orphans = board.findOrphans();
            var delay = duration + 200 + 30 * group.list.length;
            dropBubbles(orphans,delay);
➋          <span class="strong"><strong>var popped = [].concat(group.list,orphans);</strong></span>
➌          <span class="strong"><strong>var points = popped.length * POINTS_PER_BUBBLE;</strong></span>
➍          <span class="strong"><strong>score += points;</strong></span>
➎          <span class="strong"><strong>setTimeout(function(){</strong></span>
              <span class="strong"><strong>BubbleShoot.ui.drawScore(score);</strong></span>
            <span class="strong"><strong>},delay);</strong></span>
          };
        }else{
          --<span class="emphasis"><em>snip</em></span>--
        };
        --<span class="emphasis"><em>snip</em></span>--
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1559" class="indexterm"/><a id="iddle1813" class="indexterm"/><a id="iddle1924" class="indexterm"/><a id="iddle2160" class="indexterm"/><a id="iddle2327" class="indexterm"/><a id="iddle2490" class="indexterm"/>We draw the score and level at game start ➊. When bubbles are popped, we first want to make a set of all of the bubbles that are both popped and orphaned. This is done by concatenating two arrays—the popped list and orphaned list ➋—and then multiplying <code class="literal">POINTS_PER_BUBBLE</code> by the length of the new array ➌. We then increment the score internally ➍, but we only update the display once the bubble has finished firing at the end of <code class="literal">delay</code> ➎. If you reload and start the game, your score should now increment.</p><p>Next, we’ll check for the end game conditions. Two states could result in the end game being reached: the player could run out of bubbles to fire, <a id="iddle1170" class="indexterm"/><a id="iddle1322" class="indexterm"/><a id="iddle1352" class="indexterm"/><a id="iddle1809" class="indexterm"/><a id="iddle1929" class="indexterm"/>or the player could pop all the bubbles in the game board. If the former, then we want to show players a final score and have them start a new game at the first level. If the latter, then we want to clear the board, increment the level number, and prompt to start the next level.</p><p>We know that game state only changes as a result of the player firing a bubble, so the only place we need to check for possible end game conditions is after we calculate the result of any collision. We’ll do this immediately after the bubble has been fired, which happens inside <code class="literal">clickGameScreen</code> inside <code class="literal">Game</code>. If the board is empty or the player has run out of bubbles, we’ll end the game; if not, we’ll give the player the next bubble to fire. Make the following change to <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00153"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      var clickGameScreen = function(e){
        --<span class="emphasis"><em>snip</em></span>--
        BubbleShoot.ui.fireBubble(curBubble,coords,duration);
➊      <span class="strong"><strong>if(numBubbles == 0){</strong></span>
          <span class="strong"><strong>endGame(false);</strong></span>
➋      <span class="strong"><strong>}else if(board.isEmpty()){</strong></span>
          <span class="strong"><strong>endGame(true);</strong></span>
➌      <span class="strong"><strong>}else{</strong></span>
          curBubble = getNextBubble(board);
        <span class="strong"><strong>}</strong></span>
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p>We first check to see if the player has run out of bubbles ➊ and then check to see if the board is cleared of bubbles ➋. If neither is true, we retrieve the next bubble as usual ➌. A new function called <code class="literal">endGame</code> uses a Boolean to determine whether the player has won or lost the level: <code class="literal">false</code> means the player lost (by running out of bubbles), and <code class="literal">true</code> means the player won (by clearing the board).</p><p>Note the call to <code class="literal">board.isEmpty</code>, which is a method that we haven’t written yet. Let’s do that now by adding the following into the <span class="emphasis"><em>board.js</em></span> class:</p><p><span class="emphasis"><em>board.js</em></span></p><a id="pro_id00154"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
BubbleShoot.Board = (function($){
  var NUM_ROWS = 9;
  var NUM_COLS = 32;
  var Board = function(){
    var that = this;
    --<span class="emphasis"><em>snip</em></span>--
    <span class="strong"><strong>this.isEmpty = function(){</strong></span>
      <span class="strong"><strong>return this.getBubbles().length == 0;</strong></span>
    <span class="strong"><strong>};</strong></span>
    return this;
  };
  --<span class="emphasis"><em>snip</em></span>--
  return Board;
})(jQuery);</pre><p><a id="iddle1158" class="indexterm"/><a id="iddle1180" class="indexterm"/><a id="iddle2194" class="indexterm"/><a id="iddle2426" class="indexterm"/>The <code class="literal">isEmpty</code> function checks to see if a call to the <code class="literal">getBubbles</code> method returns any objects. If the array has a length of zero, all the bubbles have been popped.</p><p>The second possible end game condition is if the player adds more than two new rows to the bottom of the board. We already have a function, <code class="literal">getRows</code>, to return the array of rows, so we just need to check whether its length is greater than the maximum number of rows we’ll permit, which is 11.</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00155"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
    var curBubble;
    var board;
    var numBubbles;
    var bubbles = [];
    var MAX_BUBBLES = 70;
    var POINTS_PER_BUBBLE = 50;
➊  <span class="strong"><strong>var MAX_ROWS = 11;</strong></span>
      --<span class="emphasis"><em>snip</em></span>--
      var clickGameScreen = function(e){
        --<span class="emphasis"><em>snip</em></span>--
        BubbleShoot.ui.fireBubble(curBubble,coords,duration);
➋      <span class="strong"><strong>if(board.getRows().length &gt; MAX_ROWS){</strong></span>
          <span class="strong"><strong>endGame(false);</strong></span>
        <span class="strong"><strong>}else</strong></span> if(numBubbles == 0){
          endGame(false);
        }else if(board.isEmpty()){
          endGame(true);
        }else{
          curBubble = getNextBubble(board);
        }
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p>To make the code easy to read, we’ll store the maximum number of rows allowed in a variable called <code class="literal">MAX_ROWS</code> ➊ and then we’ll check to see whether the number of rows on the board is greater than this number ➋; if so, we’ll end the game.</p><p><a id="iddle1744" class="indexterm"/><a id="iddle1745" class="indexterm"/><a id="iddle1814" class="indexterm"/><a id="iddle2161" class="indexterm"/><a id="iddle2449" class="indexterm"/>We also need to display messages to the player indicating a win or loss, a score, and so on. If we have a large number of different messages to show, we might create some JavaScript code to dynamically create and display dialogs. But we only have a couple of variations, so we’ll hardcode them into the HTML. The dialog we’ll show will look the same as the one for starting the game but with more information, as shown in <a class="xref" href="ch07.html#end_game_dialog" title="Figure 7-2. The end game dialog">Figure 7-2</a>.</p><div class="figure"><a id="end_game_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00026"/><img src="httpatomoreillycomsourcenostarchimages2184539.png.jpg" alt="The end game dialog"/></div></div><p class="title">Figure 7-2. The end game dialog</p></div><p>Let’s add the structure for this to <span class="emphasis"><em>index.html</em></span> now:</p><p><span class="emphasis"><em>index.html</em></span></p><a id="pro_id00156"/><pre class="programlisting">  &lt;!DOCTYPE HTML&gt;
  &lt;html lang="en-US"&gt;
  &lt;head&gt;
    --<span class="emphasis"><em>snip</em></span>--
  &lt;/head&gt;
  &lt;body&gt;
  &lt;div id="page"&gt;
    --<span class="emphasis"><em>snip</em></span>--
    &lt;div id="start_game" class="dialog"&gt;
      &lt;div id="start_game_message"&gt;
        &lt;h2&gt;Start a new game&lt;/h2&gt;
      &lt;/div&gt;
      &lt;div class="but_start_game button"&gt;
        New Game
      &lt;/div&gt;
    &lt;/div&gt;
➊  <span class="strong"><strong>&lt;div id="end_game" class="dialog"&gt;</strong></span>
      <span class="strong"><strong>&lt;div id="end_game_message"&gt;</strong></span>
        <span class="strong"><strong>&lt;h2&gt;Game Over&lt;/h2&gt;</strong></span>
➋      <span class="strong"><strong>&lt;div id="final_score"&gt;</strong></span>
          <span class="strong"><strong>&lt;span&gt;Final Score:&lt;/span&gt;</strong></span>
          <span class="strong"><strong>&lt;span id="final_score_value"&gt;&lt;/span&gt;</strong></span>
        <span class="strong"><strong>&lt;/div&gt;</strong></span>
➌      <span class="strong"><strong>&lt;div id="new_high_score"&gt;New High Score!&lt;/div&gt;</strong></span>
➍      <span class="strong"><strong>&lt;div id="level_failed" class="level_failed"&gt;Level Failed!&lt;/div&gt;</strong></span>
➎      <span class="strong"><strong>&lt;div id="level_complete" class="level_complete"&gt;Level Complete!&lt;/div&gt;</strong></span>
      <span class="strong"><strong>&lt;/div&gt;</strong></span>
➏    <span class="strong"><strong>&lt;div class="but_start_game button"&gt;</strong></span>
➐      <span class="strong"><strong>&lt;span class="level_complete"&gt;Next Level&lt;/span&gt;</strong></span>
➑      <span class="strong"><strong>&lt;span class="level_failed"&gt;New Game&lt;/span&gt;</strong></span>
      <span class="strong"><strong>&lt;/div&gt;</strong></span>
    <span class="strong"><strong>&lt;/div&gt;</strong></span>
  &lt;/div&gt;
  &lt;/body&gt;
  &lt;/html&gt;</pre><p><a id="iddle1457" class="indexterm"/><a id="iddle1661" class="indexterm"/><a id="iddle1885" class="indexterm"/><a id="iddle2030" class="indexterm"/><a id="iddle2121" class="indexterm"/><a id="iddle2273" class="indexterm"/><a id="iddle2609" class="indexterm"/><a id="iddle2647" class="indexterm"/>Our game only ever shows one dialog ➊, which contains a message for the final score ➋, whether the level was completed or failed. If the player reaches a new high score, we’ll show that message ➌. The Level Failed! ➍ or Level Complete! ➎ messages will be shown depending on the situation. Finally, a single button will enable the next game to start ➏, which will lead to either the next level ➐ or a brand-new game ➑. We can determine after the button has been clicked whether the game is being restarted or continued, because we’ll know the current level number.</p><p>When we show the <code class="literal">end_game</code> dialog, we’ll show or hide the <code class="literal">level_complete</code> or <code class="literal">level_failed</code> classes, as appropriate, to display the correct messages. Notice that the <code class="literal">level_complete</code> class is attached to both the Level Complete! message ➎ and the Next Level button ➐, whereas the <code class="literal">level_failed</code> class is attached to the Level Failed! message ➍ and the New Game button ➑. This will enable us to, for example, hide all of the <code class="literal">level_failed</code> elements with a single jQuery call:</p><a id="pro_id00157"/><pre class="programlisting">$(".level_failed").hide();</pre><p>This is one of the advantages of using HTML and CSS for the user interface, and it’s possible because <span class="emphasis"><em>Bubble Shooter</em></span> is a relatively simple game. But even if you had a much larger range of messages to show in a dialog, you could still use jQuery to create DOM elements and use CSS to style them.</p><p>The dialog will inherit some styling from the <code class="literal">dialog</code> class definition, but we need to add some more definitions to <span class="emphasis"><em>main.css</em></span>:</p><p><span class="emphasis"><em>main.css</em></span></p><a id="pro_id00158"/><pre class="programlisting">#final_score
{
  margin: 26px 0;
}
  #end_game_message span
  {
    margin-right: 20px;
    font-size: 24px;
  }
  #level_complete,#level_failed,#new_high_score
  {
    font-size: 36px;
    color: #fff;
  }</pre><p><a id="iddle1137" class="indexterm"/><a id="iddle1253" class="indexterm"/><a id="iddle1552" class="indexterm"/><a id="iddle1810" class="indexterm"/><a id="iddle1829" class="indexterm"/><a id="iddle1930" class="indexterm"/><a id="iddle1954" class="indexterm"/><a id="iddle2131" class="indexterm"/><a id="iddle2395" class="indexterm"/><a id="iddle2560" class="indexterm"/><a id="iddle2616" class="indexterm"/><a id="iddle2620" class="indexterm"/>We now want to create the <code class="literal">endGame</code> function in <span class="emphasis"><em>game.js</em></span>. This will display the end-of-game dialog with the appropriate win or lose message and then allow the player to either play the next level or start a new game:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00159"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      var renderFrame = function(){
        --<span class="emphasis"><em>snip</em></span>--
      };
      <span class="strong"><strong>var endGame = function(hasWon){</strong></span>
➊      <span class="strong"><strong>if(score &gt; highScore){</strong></span>
➋       <span class="strong"><strong>highScore = score;</strong></span>
➌       <span class="strong"><strong>$("#new_high_score").show();</strong></span>
➍       <span class="strong"><strong>BubbleShoot.ui.drawHighScore(highScore);</strong></span>
        <span class="strong"><strong>}else{</strong></span>
➎        <span class="strong"><strong>$("#new_high_score").hide();</strong></span>
        <span class="strong"><strong>};</strong></span>
➏      <span class="strong"><strong>if(hasWon){</strong></span>
          <span class="strong"><strong>level++;</strong></span>
➐     <span class="strong"><strong>}else{</strong></span>
          <span class="strong"><strong>score = 0;</strong></span>
          <span class="strong"><strong>level = 0;</strong></span>
        <span class="strong"><strong>};</strong></span>
➑      <span class="strong"><strong>$(".but_start_game").click("click",startGame);</strong></span>
➒      <span class="strong"><strong>$("#board .bubble").remove();</strong></span>
        <span class="strong"><strong>BubbleShoot.ui.endGame(hasWon,score);</strong></span>
      <span class="strong"><strong>};</strong></span>
    };
    return Game;
  })(jQuery);</pre><p>First, we check to see if the player’s score is higher than the value of <code class="literal">highScore</code>, which starts at zero ➊. If so, <code class="literal">highScore</code> is updated ➋ and we show the <code class="literal">new_high_score</code> element inside the game completion dialog ➌. Then a call to <code class="literal">ui.drawHighScore</code> occurs, which we created when we updated the in-game scoring display ➍. If there isn’t a new high score, the message is hidden ➎.</p><p>The next branch checks if the player has won and, if so ➏, increments <code class="literal">level</code> by 1. If the player lost, <code class="literal">score</code> and <code class="literal">level</code> are reset to zero ➐. Then we need to enable the <code class="literal">startGame</code> button again by binding the <code class="literal">click</code> event to it ➑, clear the rest of the bubbles from the display ➒, and call a new method in <span class="emphasis"><em>ui.js</em></span> that will display the game over dialog.</p><p><a id="iddle1323" class="indexterm"/><a id="iddle1560" class="indexterm"/><a id="iddle1838" class="indexterm"/><a id="iddle1925" class="indexterm"/><a id="iddle2615" class="indexterm"/><a id="iddle2641" class="indexterm"/>Note that it doesn’t matter whether the player is playing the first level or the fiftieth, because <code class="literal">startGame</code> just draws the current level and starts the game; therefore, we don’t need to create a new function to handle new levels.</p><p>But the display isn’t the only part of the game that should react to a game over. The player shouldn’t be able to shoot bubbles anymore either! Let’s also create a function called <code class="literal">endGame</code> in <span class="emphasis"><em>ui.js</em></span>. Whereas <code class="literal">endGame</code> in <span class="emphasis"><em>game.js</em></span> deals with the game logic aspects to finishing a level, the code in <span class="emphasis"><em>ui.js</em></span> will handle the visual aspects of ending the game, such as showing the dialog and populating it with the player’s score:</p><p><span class="emphasis"><em>ui.js</em></span></p><a id="pro_id00160"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.ui = (function($){
    --<span class="emphasis"><em>snip</em></span>--
    var ui = {
      --<span class="emphasis"><em>snip</em></span>--
      <span class="strong"><strong>endGame : function(hasWon,score){</strong></span>
➊      <span class="strong"><strong>$("#game").unbind("click");</strong></span>
➋      <span class="strong"><strong>BubbleShoot.ui.drawBubblesRemaining(0);</strong></span>
➌      <span class="strong"><strong>if(hasWon){</strong></span>
          <span class="strong"><strong>$(".level_complete").show();</strong></span>
          <span class="strong"><strong>$(".level_failed").hide();</strong></span>
        <span class="strong"><strong>}else{</strong></span>
          <span class="strong"><strong>$(".level_complete").hide();</strong></span>
          <span class="strong"><strong>$(".level_failed").show();</strong></span>
        <span class="strong"><strong>};</strong></span>
➍      <span class="strong"><strong>$("#end_game").fadeIn(500);</strong></span>
        <span class="strong"><strong>$("#final_score_value").text(score);</strong></span>
      <span class="strong"><strong>}</strong></span>
    };
    --<span class="emphasis"><em>snip</em></span>--
    return ui;
  } )(jQuery);</pre><p>When the game is finished, the <code class="literal">endGame</code> method ensures that clicks ➊ in the game area will no longer trigger the <code class="literal">clickGameScreen</code> function, because we don’t want the player to fire bubbles when the game is over. It also updates the bubbles remaining display to zero ➋ and shows the correct win/lose message inside the dialog ➌. Then we show the dialog with the messages for Level Complete! or Level Failed! inside ➍.</p></div></div><div class="sect1" title="Ending Levels Efficiently"><div class="titlepage"><div><div><h1 class="title"><a id="ending_levels_efficiently"/>Ending Levels Efficiently</h1></div></div></div><p>Currently, <span class="emphasis"><em>Bubble Shooter</em></span>’s end game can be a bit tedious: the player is left firing bubbles until they form groups large enough to pop. This can also prove problematic if the bubbles don’t come out in the right color combinations. For example, if the only bubble on the board is blue and the randomizer generates only red bubbles, the player might fail a level through no fault of their own! Rather than expect the player to clear every bubble, we’ll give <a id="iddle1159" class="indexterm"/><a id="iddle1939" class="indexterm"/><a id="iddle2333" class="indexterm"/><a id="iddle2427" class="indexterm"/>them a quick ending when they clear all but the last five bubbles in the top row. When that happens, the remaining top row bubbles will pop, and everything else will drop down as if it were an orphaned group (using the <code class="literal">kaboom</code> routine).</p><div class="sidebar"><a id="anticipate_and_alleviate_player_frustrat"/><p class="title">Anticipate and Alleviate Player Frustrations</p><p>Always think ahead about how your game could become frustrating and solve the problem in advance. By doing so, you’ll improve the game and keep players coming back for more. In <span class="emphasis"><em>Bubble Shooter</em></span>, a level could be impossible to complete because the bubbles didn’t appear in the correct order. This situation is a perfect example of what can happen when a possible outcome—in this case, a <span class="emphasis"><em>single</em></span> bubble being left on the board and not being poppable—isn’t considered during the original game design. Game programming is almost always iterative, and rarely will your first version be the final one.</p></div><p>After we calculate the current set to pop, we’ll check how many bubbles are left anytime the player pops bubbles. If five or fewer bubbles remain on the board after the player has finished firing bubbles, we’ll pop those for free and take the player straight to the game’s end.</p><p>The check to determine if the level is nearly complete will be inside <code class="literal">clickGameScreen</code> in <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00161"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      var clickGameScreen = function(e){
        --<span class="emphasis"><em>snip</em></span>--
        if(collision){
          var coords = collision.coords;
          duration = Math.round(duration * collision.distToCollision /
            distance);
          board.addBubble(curBubble,coords);
          var group = board.getGroup(curBubble,{});
          if(group.list.length &gt;= 3){
            popBubbles(group.list,duration);
➊          <span class="strong"><strong>var topRow = board.getRows()[0];</strong></span>
➋          <span class="strong"><strong>var topRowBubbles = [];</strong></span>
            <span class="strong"><strong>for(var i=0;i&lt;topRow.length;i++){</strong></span>
              <span class="strong"><strong>if(topRow[i])</strong></span>
                <span class="strong"><strong>topRowBubbles.push(topRow[i]);</strong></span>
            <span class="strong"><strong>};</strong></span>
➌          <span class="strong"><strong>if(topRowBubbles.length &lt;= 5){</strong></span>
➍            <span class="strong"><strong>popBubbles(topRowBubbles,duration);</strong></span>
➎            <span class="strong"><strong>group.list.concat(topRowBubbles);</strong></span>
            <span class="strong"><strong>};</strong></span>
            var orphans = board.findOrphans();
            var delay = duration + 200 + 30 * group.list.length;
            dropBubbles(orphans,delay);
➏          var popped = [].concat(group.list,orphans);
            var points = popped.length * POINTS_PER_BUBBLE;
            score += points;
            setTimeout(function(){
              BubbleShoot.ui.drawScore(score);
            },delay);
          };
        }else{
          --<span class="emphasis"><em>snip</em></span>--
        };
        --<span class="emphasis"><em>snip</em></span>--
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1631" class="indexterm"/><a id="iddle2017" class="indexterm"/><a id="iddle2472" class="indexterm"/><a id="iddle2691" class="indexterm"/>First, we retrieve the top row ➊, and then we loop through it, counting the number of bubbles ➋. If five or fewer bubbles are present ➌, we pop all of the bubbles in the top row ➍ and add them to the list of popped bubbles ➎ so they contribute to the player’s score ➏.</p><p>You should now be able to play through an entire game level, clear the board, and see a prompt to start the next level. Congratulations! You just finished your first fully playable game.</p><p>But before you put <span class="emphasis"><em>Bubble Shooter</em></span> in front of another player, let’s make the high score persist from one session to the next rather than resetting every time the browser window is closed. After all, what’s the point of a high score if you can’t come back to challenge it later?</p></div><div class="sect1" title="High Score Persistence with Web Storage"><div class="titlepage"><div><div><h1 class="title"><a id="high_score_persistence_with_web_storage"/>High Score Persistence with Web Storage</h1></div></div></div><p>Although <span class="emphasis"><em>Bubble Shooter</em></span> has no server-side component to save high scores, we can use the Web Storage system that comes with HTML5 to save them to the local machine. Players who play again with the same browser will see the previous high score, which gives them a target to beat.</p><p><span class="emphasis"><em>Bubble Shooter</em></span> is a casual game: the user will open it, play a few levels until they fail, and then close the browser tab. Remembering the high score is a good idea, but we don’t need to retain any other data. Regardless, the principle of using Web Storage to persist data from one game session to the next is the same even if you’re storing a much larger amount of information.</p><div class="sect2" title="Web Storage vs. Cookies"><div class="titlepage"><div><div><h2 class="title"><a id="web_storage_vsdot_cookies"/>Web Storage vs. Cookies</h2></div></div></div><p>On the client side, Web Storage behaves in a similar way to cookies, but the implementation details (and advantages) are very different. Web Storage is easier to access than cookies are because data is stored in name/value pairs. Unlike with cookies, there is no server-side access to the contents of <a id="iddle1029" class="indexterm"/><a id="iddle1538" class="indexterm"/><a id="iddle1784" class="indexterm"/><a id="iddle1863" class="indexterm"/><a id="iddle2038" class="indexterm"/><a id="iddle2059" class="indexterm"/><a id="iddle2173" class="indexterm"/><a id="iddle2177" class="indexterm"/><a id="iddle2483" class="indexterm"/><a id="iddle2574" class="indexterm"/><a id="iddle2676" class="indexterm"/>Web Storage, because data isn’t transmitted as part of an HTTP request. The contents of the store are restricted by domain, so different subdomains have different stores. We could store the high score in a cookie, but there’s no reason to do so, and the storage format as well as the overhead of transmitting data unnecessarily to the server on each request makes a cookie a worse option than Web Storage. Trying to store large amounts of data (such as the layout of the current board) in a cookie can also cause performance issues, because this data is transmitted to the server with each request. For example, when the browser tries to download an image file of only a few kilobytes, it could also have to send a large amount of extraneous data to the server.</p><p>Web Storage, on the other hand, gives you more space than cookies do, although the exact amount isn’t defined in the HTML specification and is set individually by the browser vendors. The current lowest common figure among the main web browsers is 5MB; that limit applies to all data stored within a domain. Google Chrome, Firefox, and Internet Explorer 9 on a desktop all provide up to 10MB, but the Android browser on phone and tablet devices provides as little as 2MB. Compare that with the maximum cookie storage—anything upwards of 300 cookies of 4KB each—and you can see that even at the lower limits, Web Storage provides much more storage.</p><p>Because browser limits can change regularly, if you plan to place large amounts of data into Web Storage, there’s no substitute for testing on specific devices; however, for small elements such as the high score in <span class="emphasis"><em>Bubble Shooter</em></span>, the space limits are irrelevant.</p></div><div class="sect2" title="Adding Data to Web Storage"><div class="titlepage"><div><div><h2 class="title"><a id="adding_data_to_web_storage"/>Adding Data to Web Storage</h2></div></div></div><p>Web Storage comes in two parts: Session Storage and Local Storage. We’ll only look at Local Storage, which is best for persisting data across sessions. The principles of storing and accessing data are largely the same for Session Storage, although the persistence and security differ slightly. As the name might imply, Session Storage only persists for the duration of the browser session. The data disappears when the user closes their browser window. This type of storage might be useful for a multipage web application where data needs to persist from one page to the next, but it’s obviously unsuited to storing a high score. Once you’re familiar with Local Storage, you’ll be able to adapt to working with Session Storage if you need to use it.</p><p>The format for adding a piece of data to <code class="literal">localStorage</code> is as follows:</p><a id="pro_id00162"/><pre class="programlisting">localStorage.setItem(key,value);</pre><p>The <code class="literal">key</code> is a string, such as <code class="literal">"high_score"</code>, and <code class="literal">value</code> is also a string, or a number or other object that can be automatically converted to a string. Note that if you try to pass in a complex object, such as an array, the conversion to a string may result in the name of the object (that is, <code class="literal">Array</code>) rather <a id="iddle1811" class="indexterm"/><a id="iddle1931" class="indexterm"/><a id="iddle1960" class="indexterm"/><a id="iddle2142" class="indexterm"/><a id="iddle2143" class="indexterm"/><a id="iddle2166" class="indexterm"/><a id="iddle2175" class="indexterm"/><a id="iddle2300" class="indexterm"/><a id="iddle2301" class="indexterm"/><a id="iddle2630" class="indexterm"/>than the data you want to store. So if in doubt, perform a conversion yourself. For more complex data, you can use <code class="literal">JSON.stringify</code> to save objects and <code class="literal">JSON.parse</code> to retrieve them.</p><p>To retrieve data, you just need the <code class="literal">key</code>:</p><a id="pro_id00163"/><pre class="programlisting">var value = localStorage.getItem(key);</pre><p><code class="literal">localStorage.getItem</code> always returns values as strings, so you’ll need to use <code class="literal">parseInt</code> or <code class="literal">parseFloat</code> to convert them to numerical data.</p><p>If the game were more complex or took longer to play, you might want to save more data, such as the current level as well as the high score. In that case, we could just keep on adding strings:</p><a id="pro_id00164"/><pre class="programlisting">localStorage.setItem("high_score",highScore);
localStorage.setItem("level",level);</pre><p>Or we could create an object and JSON encode it:</p><a id="pro_id00165"/><pre class="programlisting">var gameData = {high_score : highScore, level : level};
localStorage.setItem("bubbleshoot_data",JSON.stringify(gameData));</pre><p>Then, when we want to retrieve the data, we would use this:</p><a id="pro_id00166"/><pre class="programlisting">var gameData = JSON.parse(localStorage.getItem("bubbleshoot_data"));</pre><p>The general principle is that if you can convert your data into a string and decode it from a string when you want to retrieve it, you can save it to Local Storage.</p><p>In <span class="emphasis"><em>Bubble Shooter</em></span>, to save the high score, the Local Storage entry will be called <code class="literal">high_score</code>. At game initialization, we want to check whether an existing value is stored and, if so, use that in place of the zero that is currently hardcoded in. When the player has set a new record, we’ll set the Local Storage value to the new high score.</p><p>In <span class="emphasis"><em>game.js</em></span>, we’ll make additions to <code class="literal">init</code> and <code class="literal">endGame</code> to retrieve and set the high score:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00167"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
    BubbleShoot.Game = (function($){
    var Game = function(){
      --<span class="emphasis"><em>snip</em></span>--
      this.init = function(){
        if(BubbleShoot.Renderer){
          BubbleShoot.Renderer.init(function(){
            $(".but_start_game").click("click",startGame);
          });
        }else{
          $(".but_start_game").click("click",startGame);
        };
➊      <span class="strong"><strong>if(window.localStorage &amp;&amp; localStorage.getItem("high_score")){</strong></span>
➋        <span class="strong"><strong>highScore = parseInt(localStorage.getItem("high_score"));</strong></span>
        <span class="strong"><strong>}</strong></span>
➌      <span class="strong"><strong>BubbleShoot.ui.drawHighScore(highScore);</strong></span>
      };
      --<span class="emphasis"><em>snip</em></span>--
      var endGame = function(hasWon){
        if(score &gt; highScore){
          highScore = score;
          $("#new_high_score").show();
          BubbleShoot.ui.drawHighScore(highScore);
➍        <span class="strong"><strong>if(window.localStorage){</strong></span>
➎          <span class="strong"><strong>localStorage.setItem("high_score",highScore);</strong></span>
          <span class="strong"><strong>}</strong></span>
        }else{
          $("#new_high_score").hide();
        };
        if(hasWon){
          level++;
        }else{
          score = 0;
          level = 0;
        };
        $(".but_start_game").click("click",startGame);
        $("#board .bubble").remove();
        BubbleShoot.ui.endGame(hasWon,score);
      };
    };
    return Game;
  })(jQuery);</pre><p><a id="iddle1223" class="indexterm"/><a id="iddle1595" class="indexterm"/><a id="iddle1972" class="indexterm"/><a id="iddle2075" class="indexterm"/><a id="iddle2097" class="indexterm"/><a id="iddle2132" class="indexterm"/><a id="iddle2219" class="indexterm"/><a id="iddle2396" class="indexterm"/><a id="iddle2465" class="indexterm"/><a id="iddle2617" class="indexterm"/>First, we check whether <code class="literal">localStorage</code> is supported by the browser, by using another Modernizr detector, and whether a value for <code class="literal">high_score</code> exists ➊. If a high score exists, we set <code class="literal">highScore</code> to the contents in the store ➋. We make sure to wrap the value with a <code class="literal">parseInt</code>, because values in the store are returned as strings and we want to work with an integer. We then display the high score ➌. To save the score, we add a line to <code class="literal">endGame</code> to check whether <code class="literal">localStorage</code> is supported ➍ and then save to it ➎.</p><p>Reload the browser and play through a game. At first, any score you get should become the new high score. But if you close the browser and reload the game, the high score should be populated with your previous value.</p><p>You could also use Web Storage to save things like language preferences, player profiles, or game state progression. Just be mindful of what you store there, because the values inside the storage system are open to calls from the JavaScript console. That means there’s nothing to stop particularly tech-savvy players from updating data themselves! In the next chapter, we’ll briefly discuss security issues in HTML5 games, but for now we can rely on the fact that there’s really no incentive to set an impossibly high score to try to beat.</p></div></div><div class="sect1" title="Smoothing Animations with requestAnimationFrame"><div class="titlepage"><div><div><h1 class="title"><a id="smoothing_animations_with_requestanimati"/>Smoothing Animations with requestAnimationFrame</h1></div></div></div><p><a id="iddle1045" class="indexterm"/><a id="iddle1070" class="indexterm"/><a id="iddle1242" class="indexterm"/><a id="iddle1514" class="indexterm"/><a id="iddle1888" class="indexterm"/><a id="iddle1915" class="indexterm"/><a id="iddle2138" class="indexterm"/><a id="iddle2411" class="indexterm"/><a id="iddle2491" class="indexterm"/>We use <code class="literal">setTimeout</code> to time animations in <span class="emphasis"><em>jquery.kaboom.js</em></span> and when we trigger frame updates in the canvas version of <span class="emphasis"><em>Bubble Shooter</em></span>. <code class="literal">setTimeout</code> is cross-browser compatible and relatively simple: set the timeout value to 40 milliseconds, and you can expect 25 frames per second.</p><p>However, there are downsides to using <code class="literal">setTimeout</code>. The main problem is that if the browser is busy with something else, the next iteration may not be called for more than 40 milliseconds. In some cases, it might take a lot longer and the user will start to notice.</p><p>We could recode movement so that objects move a distance proportional to the time elapsed since the last update, effectively ignoring the 40 millisecond figure. But we’d still have to accept the fact that whatever value we set the timeout delay to will be too low for some setups and those displays won’t be able to keep up. On systems that can handle much faster updates, we could display much smoother animations, but if we set the timeout value to 10 milliseconds to handle those cases, slower systems will see an adverse effect.</p><p>Fortunately, HTML5 introduced <code class="literal">requestAnimationFrame</code>, an alternative to <code class="literal">setTimeout</code> that is better suited to animation. Rather than making the programmer guess what kind of frame rate <span class="emphasis"><em>might</em></span> work, the browser calls the function passed to <code class="literal">requestAnimationFrame</code> whenever it is ready to draw a new update. The time between updates might be much faster (or slower!) than 40 milliseconds, but at least we know that we’re neither making a processing logjam worse nor having the system sit idle when we could spend extra cycles smoothing the animations.</p><div class="sect2" title="A New Perspective on Frame Updates"><div class="titlepage"><div><div><h2 class="title"><a id="new_perspective_on_frame_updates"/>A New Perspective on Frame Updates</h2></div></div></div><p>We have to think differently about frame updates when switching to <code class="literal">requestAnimationFrame</code>. Currently, <span class="emphasis"><em>before</em></span> <code class="literal">setTimeout</code> runs, we tell the browser how long to wait. We assume that the time elapsed is the time we expected to elapse. For example, in <code class="literal">moveAll</code> in <span class="emphasis"><em>jquery.kaboom.js</em></span>, we set a timeout of 40 milliseconds:</p><a id="pro_id00168"/><pre class="programlisting">setTimeout(moveAll,40);</pre><p>We then update the position of the bubbles assuming that 40 milliseconds—1/25th of a second—has elapsed. However, with <code class="literal">requestAnimationFrame</code>, we don’t specify a frame rate. In the <code class="literal">moveAll</code> function in <span class="emphasis"><em>jquery.kaboom.js</em></span>, if <code class="literal">requestAnimationFrame</code> did happen to run this routine every 40 milliseconds, we wouldn’t need to change anything. But if it ran every, say, 20 milliseconds, we couldn’t keep the same values of <code class="literal">dx</code> and <code class="literal">dy</code>, or our whole animation would run much faster—twice as fast, in fact, because it would add <code class="literal">dx</code> and <code class="literal">dy</code> twice as often.</p><p>Instead, we need to find out how many milliseconds have elapsed and then adjust our animation step size. We can even apply the same math techniques to <code class="literal">setTimeout</code> animations to get better results on older browsers that <a id="iddle1071" class="indexterm"/><a id="iddle1224" class="indexterm"/><a id="iddle1226" class="indexterm"/><a id="iddle1243" class="indexterm"/><a id="iddle1889" class="indexterm"/><a id="iddle2239" class="indexterm"/><a id="iddle2253" class="indexterm"/><a id="iddle2328" class="indexterm"/><a id="iddle2492" class="indexterm"/><a id="iddle2681" class="indexterm"/>don’t support <code class="literal">requestAnimationFrame</code>. As shown in <a class="xref" href="ch07.html#bubble_positions_with_different_frame_ra" title="Figure 7-3. Bubble positions with different frame rates">Figure 7-3</a>, the less time that’s elapsed since the bubble was last drawn, the less distance we have to move it along its path.</p><div class="figure"><a id="bubble_positions_with_different_frame_ra"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00027"/><img src="httpatomoreillycomsourcenostarchimages2184541.png.jpg" alt="Bubble positions with different frame rates"/></div></div><p class="title">Figure 7-3. Bubble positions with different frame rates</p></div></div><div class="sect2" title="Code Compatibility with Polyfills"><div class="titlepage"><div><div><h2 class="title"><a id="code_compatibility_with_polyfills"/>Code Compatibility with Polyfills</h2></div></div></div><p>Modernizr will help us build the <code class="literal">setTimeout</code> fallback. <code class="literal">requestAnimationFrame</code> is still regarded as prestandards by many browsers, so prefixed versions are available for Webkit, Mozilla, and so on, which Modernizr can fill in for us. Add the following to <span class="emphasis"><em>game.js</em></span>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00169"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
  };
  <span class="strong"><strong>window.requestAnimationFrame = Modernizr.prefixed("requestAnimationFrame",</strong></span>
    <span class="strong"><strong>window) || function(callback){</strong></span>
    <span class="strong"><strong>window.setTimeout(function(){</strong></span>
      <span class="strong"><strong>callback();</strong></span>
    <span class="strong"><strong>}, 40);</strong></span>
  <span class="strong"><strong>};</strong></span>
  return Game;
})(jQuery);</pre><p>This single line of new code says that if <code class="literal">requestAnimationFrame</code> (vendor-prefixed if necessary) is defined, then set <code class="literal">window.requestAnimationFrame</code> to the contents of <code class="literal">requestAnimationFrame</code>. If <code class="literal">requestAnimationFrame</code> is not defined, then we create a new function that accepts a function as a parameter and calls that function after 40 milliseconds using <code class="literal">setTimeout</code>.</p><p><a id="iddle1632" class="indexterm"/><a id="iddle1942" class="indexterm"/><a id="iddle1955" class="indexterm"/><a id="iddle2174" class="indexterm"/><a id="iddle2176" class="indexterm"/><a id="iddle2178" class="indexterm"/><a id="iddle2408" class="indexterm"/><a id="iddle2561" class="indexterm"/>This technique is known as a <span class="emphasis"><em>polyfill</em></span>. Polyfills attempt to mimic or patch in new functionality to a browser where it’s not supported natively, allowing you to use new technologies in your code without having to always worry about forking your code or providing fallbacks yourself. The name comes from the filling substance Polyfilla, because the technique involves filling in the cracks in browser support.</p><p>Polyfills are written to support all kinds of functionality in older browsers. For example, to store the player’s high score, we’re using the Local Storage API. This isn’t available in older browsers, but we could achieve the same effect by storing the data in a cookie. There are two ways to approach this: one way is to write an <code class="literal">if/else</code> statement every time we access Local Storage to check if it exists and, if not, branch to run some cookie code. Alternatively, we could create an object called <code class="literal">localStorage</code> and add methods for <code class="literal">getItem</code> and <code class="literal">setItem</code> that use cookies to save and retrieve data.</p><p>Polyfills are rarely perfect solutions: <code class="literal">setTimeout</code> and <code class="literal">requestAnimationFrame</code> may operate in very similar ways, but sometimes the differences may be important. In the Local Storage example, we might be able to use cookies in exactly the same way as Local Storage, but if we tried to store a lot of data, we’d run into problems. Polyfills can enhance browser compatibility without a lot of code, but it’s important to know the limitations of any polyfill you use.</p><p>Once we have the polyfill for <code class="literal">requestAnimationFrame</code>, as far as the rest of our code is concerned, <code class="literal">requestAnimationFrame</code> is supported, and we can use it regardless of the browser. We know that in truth, a <code class="literal">setTimeout</code> call is running behind the scenes and that sometimes the animation won’t run as smoothly as it would with the natively supported <code class="literal">requestAnimationFrame</code> method. But as far as the code that calls it is concerned, the function behaves in the same way.</p><p>Now that we have a working <code class="literal">requestAnimationFrame</code> polyfill, we can replace our calls to <code class="literal">setTimeout</code> in <span class="emphasis"><em>game.js</em></span> with calls to the new function in <code class="literal">startGame</code> and <code class="literal">renderFrame</code>:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00170"/><pre class="programlisting">var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
  var Game = function(){
    --<span class="emphasis"><em>snip</em></span>--
    var startGame = function(){
      --<span class="emphasis"><em>snip</em></span>--
      if(BubbleShoot.Renderer)
      {
        if(!requestAnimationID)
          requestAnimationID = <span class="strong"><strong>requestAnimationFrame(renderFrame);</strong></span>
      }else{
        BubbleShoot.ui.drawBoard(board);
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    --<span class="emphasis"><em>snip</em></span>--
  var renderFrame = function(){
    $.each(bubbles,function(){
      if(this.getSprite().updateFrame)
        this.getSprite().updateFrame();
    });
      BubbleShoot.Renderer.render(bubbles,board.calculateTop());
      requestAnimationID = <span class="strong"><strong>requestAnimationFrame(renderFrame);</strong></span>
    };
    --<span class="emphasis"><em>snip</em></span>--
  };
  --<span class="emphasis"><em>snip</em></span>--
  return Game;
})(jQuery);</pre><p><a id="iddle2139" class="indexterm"/>We must make similar changes inside <span class="emphasis"><em>jquery.kaboom.js</em></span> to use <code class="literal">requestAnimationFrame</code> rather than <code class="literal">setTimeout</code>. The <code class="literal">kaboom</code> function internally assumes that 40 milliseconds elapses between frames, giving a frame rate of 25 frames per second, but as we now know, with <code class="literal">requestAnimationFrame</code> the elapsed time may vary. Again, we need to calculate how much time has elapsed and calculate movement proportionally:</p><p><span class="emphasis"><em>jquery.kaboom.js</em></span></p><a id="pro_id00171"/><pre class="programlisting">  (function(jQuery){
    var defaults = {
      gravity : 1.3,
      maxY : 800
    };
    var toMove = [];
➊  <span class="strong"><strong>var prevTime;</strong></span>
    var moveAll = function(){
➋    <span class="strong"><strong>var newTime = Date.now();</strong></span>
➌    <span class="strong"><strong>var elapsed = newTime - prevTime;</strong></span>
➍    <span class="strong"><strong>var frameProportion = elapsed / 25;</strong></span>
➎    <span class="strong"><strong>prevTime = newTime;</strong></span>
      var stillToMove = [];
      for(var i=0;i&lt;toMove.length;i++){
        var obj = toMove[i];
        obj.x += obj.dx * frameProportion;
        obj.y -= obj.dy * frameProportion;
        obj.dy -= obj.config.gravity * frameProportion;
        if(obj.y &lt; obj.config.maxY){
          obj.elm.css({
            top : Math.round(obj.y),
            left : Math.round(obj.x)
          });
          stillToMove.push(obj);
        }else if(obj.config.callback){
          obj.config.callback();
        }
      };
      toMove = stillToMove;
      if(toMove.length &gt; 0)
➏      <span class="strong"><strong>requestAnimationFrame(moveAll);</strong></span>
    };
    jQuery.fn.kaboom = function(settings)
  {
    var elm = this;
    var config = $.extend({}, defaults, settings);
    if(toMove.length == 0){
      <span class="strong"><strong>prevTime = Date.now();</strong></span>
➐    <span class="strong"><strong>requestAnimationFrame(moveAll);</strong></span>
    };
    var dx = Math.round(Math.random() * 10) - 5;
    var dy = Math.round(Math.random() * 5) + 5;
    toMove.push({
      elm : this,
      dx : dx,
      dy : dy,
      x : this.position().left,
      y : this.position().top,
      config : config
    });
  };
})(jQuery);</pre><p><a id="iddle1203" class="indexterm"/><a id="iddle2357" class="indexterm"/><a id="iddle2500" class="indexterm"/><a id="iddle2502" class="indexterm"/><a id="iddle2503" class="indexterm"/><a id="iddle2504" class="indexterm"/><a id="iddle2506" class="indexterm"/><a id="iddle2507" class="indexterm"/><a id="iddle2508" class="indexterm"/>First, we define an empty variable called <code class="literal">prevTime</code> ➊ to store the timestamp of the last rendered frame, which is null initially. Each time <code class="literal">moveAll</code> is called, we retrieve the current timestamp ➋ and calculate the time elapsed since the last frame ➌. Our initial calculations were based on 40 milliseconds having elapsed, so to calculate the correct position, we scale the proportion of the frame elapsed accordingly ➍. If only 8 milliseconds have elapsed, <code class="literal">frameProportion</code> will be 0.2, and the animation will update in smaller but more frequent steps. If 80 milliseconds have elapsed, <code class="literal">frameProportion</code> will be 2, and the animation will update in larger steps. The end effect is that the bubbles take the same time to drop off the screen regardless of the frame rate. To prepare for the next frame, we update <code class="literal">prevTime</code> to the current timestamp ➎.</p><p>Also, <code class="literal">setTimeout</code> is replaced with <code class="literal">requestAnimationFrame</code> in two places: once when the animation is started ➏ and once for each frame loop ➐.</p><p>Reload the game and run it again to make sure it works properly. You probably won’t see a difference in performance unless you have a particularly slow browser setup. However, now you can be confident that everyone who plays <span class="emphasis"><em>Bubble Shooter</em></span> will see bubbles moving and falling at the same speeds, even if the frame update rates vary between devices.</p></div></div><div class="sect1" title="Adding Sound with HTML5"><div class="titlepage"><div><div><h1 class="title"><a id="adding_sound_with_html5"/>Adding Sound with HTML5</h1></div></div></div><p>A game never feels like a game without sound! HTML5 provides some increasingly powerful options for processing and playing back audio. I say <span class="emphasis"><em>increasingly powerful</em></span> because browser support is being improved all the time. You can manipulate wave files byte by byte, record from the microphone, perform dynamic mixing, and take advantage of a whole host of features in addition to the woeful audio options that HTML offered not long ago. Let’s look at the basic features of HTML5 audio.</p><div class="sect2" title="The HTML5 Audio API"><div class="titlepage"><div><div><h2 class="title"><a id="html5_audio_api"/>The HTML5 Audio API</h2></div></div></div><p><a id="iddle1111" class="indexterm"/><a id="iddle1112" class="indexterm"/><a id="iddle1113" class="indexterm"/><a id="iddle1114" class="indexterm"/><a id="iddle1539" class="indexterm"/><a id="iddle1596" class="indexterm"/><a id="iddle1864" class="indexterm"/><a id="iddle2037" class="indexterm"/><a id="iddle2076" class="indexterm"/><a id="iddle2257" class="indexterm"/><a id="iddle2501" class="indexterm"/><a id="iddle2505" class="indexterm"/><a id="iddle2509" class="indexterm"/><a id="iddle2510" class="indexterm"/><a id="iddle2567" class="indexterm"/><a id="iddle2673" class="indexterm"/>Historically, HTML has implemented audio poorly, offering no reliable way to embed and control sounds within web pages. This changed with HTML5, and you can embed a sound directly into a page with a simple tag, such as this one:</p><a id="pro_id00172"/><pre class="programlisting">&lt;audio src="sounds.mp3" autoplay&gt;&lt;/autoplay&gt;</pre><p>On its own, this isn’t a lot of help for a game in which we want to programmatically start and stop sounds so they can react to events like bubbles popping. Fortunately, HTML5 also provides a way to play audio through a JavaScript API without using HTML tags at all.</p><p>The JavaScript equivalent of the preceding HTML fragment, which just embeds and plays a single file, is this:</p><a id="pro_id00173"/><pre class="programlisting">var sound = new Audio("sounds.mp3");
sound.play();</pre><p>You can try this with any MP3 file you have. The parameter passed into the <code class="literal">new Audio</code> call is the URL to the sound file. If you place it in the <span class="emphasis"><em>bubbleshoot</em></span> folder and change the parameter to the file’s name, you can run the previous command in the JavaScript console and the sound should play.</p><p>The sound will stop naturally when it ends, and you can use the <code class="literal">stop</code> method to end a sound at any point during playback:</p><a id="pro_id00174"/><pre class="programlisting">sound.stop()</pre><p>Those are the only commands we need, but take time to look through the audio API specification to see the growing potential for sound delivery in browsers. As well as methods and properties that affect the basic playback of audio, such as changing the volume of a sound or skipping to a specific point in a file, there is functionality for recording from input devices, mixing sounds, changing stereo, and even 3D sound positioning, as well as ways to post-process sounds to add effects such as echo. These are increasingly being supported in mainstream browsers, such as Google Chrome and Firefox, with improvements arriving in each new version.</p><p>If you want to play multiple sounds simultaneously, you must create multiple <code class="literal">Audio</code> objects. For example:</p><a id="pro_id00175"/><pre class="programlisting">var sound1 = new Audio("sounds.mp3");
var sound2 = new Audio("sounds.mp3");
sound1.play();
sound2.play();</pre><p>To just play different sounds one after another, you could reuse an <code class="literal">Audio</code> object by changing the object’s <code class="literal">src</code> property. But to play multiple sounds at the same time, you need as many objects in existence as sounds that you <a id="iddle1346" class="indexterm"/><a id="iddle1910" class="indexterm"/><a id="iddle2183" class="indexterm"/><a id="iddle2224" class="indexterm"/><a id="iddle2335" class="indexterm"/><a id="iddle2512" class="indexterm"/><a id="iddle2513" class="indexterm"/>plan to play simultaneously. As you’ll see in <span class="emphasis"><em>Bubble Shooter</em></span>, this means that if we want to pop a group of 20 bubbles, we’ll need 20 sound objects to play the 20 popping sounds at the same time.</p></div><div class="sect2" title="Popping Bubbles: Complete with Sound"><div class="titlepage"><div><div><h2 class="title"><a id="popping_bubbles_complete_with_sound"/>Popping Bubbles: Complete with Sound</h2></div></div></div><p>We’ll add HTML5 sound support to <span class="emphasis"><em>Bubble Shooter</em></span> using the audio API so a sound plays for each bubble popped. Grab the file <span class="emphasis"><em>pop.mp3</em></span> from <span class="emphasis"><em><a class="ulink" href="http://www.buildanhtml5game.com/">http://www.buildanhtml5game.com/</a></em></span> and put it in a new folder called <span class="emphasis"><em>_mp3</em></span> inside the game folder.</p><p>First, create a class to play the sounds. We’ll wrap the HTML5 audio functionality in our own code, which will prevent an error from being thrown in browsers that don’t support HTML5 audio. Create a new file in the <span class="emphasis"><em>_js</em></span> folder called <span class="emphasis"><em>sounds.js</em></span> and then add the file to load in <span class="emphasis"><em>index.html</em></span>. Sound processing, like rendering and the user interface, is another piece of functionality that’s best to keep separate from game logic wherever possible. By creating a separate file to handle playback, we can put all of our sound-handling code in one place.</p><p>We’ll reuse <code class="literal">Audio</code> objects, so we’ll create these as the code is initialized. Then, whenever a sound needs to play, we’ll pull out the next object in the queue, change the <code class="literal">src</code> to the file we want to play, and then play it. We’ll set a cap of 10 sounds that can play simultaneously, which is a low number, but even on the rare occasion when a player is popping more than 10 bubbles at a time, there’s no need to play more than 10 sounds.</p><p><span class="emphasis"><em>sounds.js</em></span></p><a id="pro_id00176"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Sounds = (function(){
➊  var soundObjects = [];
➋  for(var i=0;i&lt;10;i++){
      soundObjects.push(new Audio());
    }
➌  var curSoundNum = 0;
➍  var Sounds = {
➎    play : function(url,volume){
        if(Modernizr.audio){
➏        var sound = soundObjects[curSoundNum];
➐        sound.src = url;
➑        sound.volume = volume;
➒        sound.play();
➓        curSoundNum++
          if(curSoundNum &gt;= soundObjects.length){
            curSoundNum = curSoundNum % soundObjects.length;
          }
        }
      }
    };
    return Sounds;
  })();</pre><p><a id="iddle1221" class="indexterm"/><a id="iddle1940" class="indexterm"/><a id="iddle2220" class="indexterm"/><a id="iddle2334" class="indexterm"/><a id="iddle2511" class="indexterm"/>A new object called <code class="literal">BubbleShoot.Sounds</code> contains the array <code class="literal">soundObjects</code> ➊, which we’ll use to store the ten <code class="literal">Audio</code> objects. These are initialized as soon as the code is loaded ➋. We also keep track of which object to use with the variable <code class="literal">curSoundNum</code> ➌.</p><p>Next, we create the object to play the sound ➍, which contains a single method to play a sound ➎. It will accept two parameters: the URL of the sound file to play and the volume to play the sound at, which is a decimal number between 0 (silent) and 1 (full volume).</p><p>We use Modernizr to check whether or not HTML5 audio is supported, and if it is, we grab the current <code class="literal">Audio</code> object from the <code class="literal">soundObjects</code> array ➏, set its <code class="literal">src</code> property to the URL of the file to play ➐, set its volume ➑, and then play it ➒. If audio isn’t supported, the method will do nothing, but because of our check for <code class="literal">Modernizr.audio</code>, no error will be thrown.</p><p>Finally, we increment the value of <code class="literal">curSoundNum</code> ➓ so that next time <code class="literal">play</code> is called, we will grab the next object in the queue. Then, we make sure that the value of <code class="literal">curSoundNum</code> is never greater than the number of <code class="literal">sound</code> objects in the <code class="literal">soundObjects</code> array.</p><p>If we want to play more sounds, we could push more <code class="literal">Audio</code> objects into the <code class="literal">soundObjects</code> array. Currently, if we try to play more than 10 sounds at once, only the last 10 sounds will play.</p><p>Sound control will happen inside <span class="emphasis"><em>game.js</em></span> with a call to the <code class="literal">BubbleShoot.Sounds.play</code> function:</p><p><span class="emphasis"><em>game.js</em></span></p><a id="pro_id00177"/><pre class="programlisting">  var BubbleShoot = window.BubbleShoot || {};
  BubbleShoot.Game = (function($){
    var popBubbles = function(bubbles,delay){
      $.each(bubbles,function(){
          var bubble = this;
          setTimeout(function(){
            bubble.setState(BubbleShoot.BubbleState.POPPING);
            bubble.animatePop();
            setTimeout(function(){
              bubble.setState(BubbleShoot.BubbleState.POPPED);
            },200);
➊          <span class="strong"><strong>BubbleShoot.Sounds.play("_mp3/pop.mp3"</strong></span>➋<span class="strong"><strong>,Math.random()*.5 + .5</strong></span>➌<span class="strong"><strong>);</strong></span>
          },delay);
          board.popBubbleAt(bubble.getRow(),bubble.getCol());
          setTimeout(function(){
            bubble.getSprite().remove();
          },delay + 200);
          delay += 60;
        });
      };
      --<span class="emphasis"><em>snip</em></span>--
    };
    --<span class="emphasis"><em>snip</em></span>--
    return Game;
  })(jQuery);</pre><p>We want to play as many sounds as there are bubbles to pop, and we also want to start the sound at the same time we start the animation ➊. We pass the play method of <code class="literal">Sounds</code> two parameters: a relative URL to the MP3 file to play ➋ and a volume, which will be a random number between .5 and 1 ➌.</p><div class="sidebar"><a id="increase_immersion_with_variety"/><p class="title">Increase Immersion with Variety</p><p>Why do we pass a random volume level? Try passing in a value of 1 and popping some bubbles. Then compare this effect to that of the random value. It’s only a small change, but the variation in volume provides just enough differentiation between each sound to make it slightly less mechanical. We could do other things to make the effect even more natural, such as using a set of sounds rather than just one MP3 file so not every bubble sounds the same or changing the timing between pops so they aren’t evenly spaced. Experimenting to create the most immersive experience possible and doing it with minimum effort are tasks you’ll become more proficient at as you develop more games.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00013"/>Summary</h1></div></div></div><p>Now that we have a simple sound to add a bit of atmosphere, you’ve finished building <span class="emphasis"><em>Bubble Shooter</em></span>! The game should play on older browsers, using CSS for positioning and animations, and it will work well on newer browsers that support the <code class="literal">canvas</code> element. We have persistent high scores and audio, and we’ve developed the animations in such a way that they should perform well regardless of the player’s system speed.</p><p>In the next chapter, we’ll explore some other parts of HTML5 that aren’t directly related to the game you just built. You’ll learn some pointers on how to deploy your game to Web and mobile environments, and you’ll see what the future holds for HTML5.</p></div><div class="sect1" title="Further Practice"><div class="titlepage"><div><div><h1 class="title"><a id="further_practice-id00014"/>Further Practice</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Toward the end of each level, the player can only have bubbles of one, two, or three colors left on the board. Giving them a bubble of a color that won’t match any of these causes the player to waste a shot and can make the game more difficult to complete. Change the bubble-generating algorithm so that it gives players only bubbles of a color that can potentially form a match. For example, if only red and blue bubbles remain, the firing bubble should be either red or blue. You will need to amend <code class="literal">getNextBubble</code> in <span class="emphasis"><em>game.js</em></span> and choose a bubble <code class="literal">type</code> from one of the types that exist in the <code class="literal">Board</code> object.</p></li><li class="listitem"><p><a id="iddle2412" class="indexterm"/>As noted in <a class="xref" href="ch07.html#multiple_levels_and_high_scores" title="Multiple Levels and High Scores">Multiple Levels and High Scores</a>, the game will become unplayable after a few levels because the number of bubbles allowed becomes too small. Instead of subtracting five bubbles per level, create an algorithm that makes levels progressively harder but makes it possible to complete a level. Perhaps the smallest number of fired bubbles a player can complete a level in is 30, and we want them to reach this level of difficulty on level 15. Before this point, the step from level 1 to 2 might be, say, five bubbles fewer, but the step from level 14 to 15 might be only one fewer. Write an equation or other method to decrease the number of bubbles allowed and increase the difficulty in this way.</p></li><li class="listitem"><p>Give players an incentive to repeat levels by awarding stars for a completion grade instead of the pass or fail condition that currently exists. You could award one star whenever the player clears the level, two stars if they clear with more than 25 percent of the level’s bubble allocation remaining, and three stars if they complete the level by firing only half the bubbles they were given. Add information to the level completion dialog to show the player how many stars they earned.</p></li><li class="listitem"><p>Once you’ve added the preceding star system, create a way to store the number of stars the player has obtained for each level. Then you can show them not only how many stars they’ve attained but also a message when they beat a previous best. Currently, we store the number of bubbles remaining, the player’s score, and current level number as variables inside <code class="literal">Game</code>. But now the best approach might be to create an object that stores each level and records the number of stars. Save this data to Local Storage for when the player returns to the game.</p></li><li class="listitem"><p>Write a polyfill to add Local Storage support to older browsers using cookies. You’ll need to create an object called <code class="literal">window.localStorage</code>, if one doesn’t already exist, and create <code class="literal">getItem</code> and <code class="literal">setItem</code> methods.</p></li></ol></div></div></div></body></html>