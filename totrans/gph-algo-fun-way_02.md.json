["```\ng: list = [[1,3,4], [0,2,4], [1,4], [0,4], [0,1,2,3]] \n```", "```\nclass Edge: \n    def __init__(self, from_node: int, to_node: int, weight: float):\n        self.from_node: int = from_node\n        self.to_node: int = to_node\n        self.weight: float = weight \n```", "```\nclass Node:\n    def __init__(self, index: int, label=None): \n        self.index: int = index\n        self.edges: dict = {}\n        self.label = label\n\n    def num_edges(self) -> int: \n        return len(self.edges)\n\n    def get_edge(self, neighbor: int) -> Union[Edge, None]: \n        if neighbor in self.edges:\n            return self.edges[neighbor]\n        return None def add_edge(self, neighbor: int, weight: float): \n        self.edges[neighbor] = Edge(self.index, neighbor, weight)\n\n    def remove_edge(self, neighbor: int): \n        if neighbor in self.edges:\n            del self.edges[neighbor]\n\n    def get_edge_list(self) -> list: \n        return list(self.edges.values())\n\n    def get_sorted_edge_list(self) -> list: \n        result = []\n        neighbors = (list)(self.edges.keys())\n        neighbors.sort()\n\n        for n in neighbors:\n            result.append(self.edges[n])\n        return result \n```", "```\nclass Graph:\n    def __init__(self, num_nodes: int, undirected: bool=False): \n        self.num_nodes: int = num_nodes\n        self.undirected: bool = undirected\n        self.nodes: list = [Node(j) for j in range(num_nodes)] \n```", "```\ndef get_edge(self, from_node: int, to_node: int) -> Union[Edge, None]: \n    if from_node < 0 or from_node >= self.num_nodes:\n        raise IndexError\n    if to_node < 0 or to_node >= self.num_nodes:\n        raise IndexError\n    return self.nodes[from_node].get_edge(to_node) def is_edge(self, from_node: int, to_node: int) -> bool: \n    return self.get_edge(from_node, to_node) is not None\n\ndef make_edge_list(self) -> list:\n    all_edges: list = []\n    for node in self.nodes:\n        for edge in node.edges.values():\n            all_edges.append(edge)\n    return all_edges \n```", "```\ndef insert_edge(self, from_node: int, to_node: int, weight: float): \n  ❶ if from_node < 0 or from_node >= self.num_nodes:\n        raise IndexError\n    if to_node < 0 or to_node >= self.num_nodes:\n        raise IndexError\n\n    self.nodes[from_node].add_edge(to_node, weight)\n  ❷ if self.undirected:\n        self.nodes[to_node].add_edge(from_node, weight)\n\ndef remove_edge(self, from_node: int, to_node: int): \n  ❸ if from_node < 0 or from_node >= self.num_nodes:\n        raise IndexError\n    if to_node < 0 or to_node >= self.num_nodes:\n        raise IndexError\n\n    self.nodes[from_node].remove_edge(to_node)\n  ❹ if self.undirected:\n        self.nodes[to_node].remove_edge(from_node) \n```", "```\ng: Graph = Graph(5, undirected=False)\ng.insert_edge(0, 1, 1.0)\ng.insert_edge(0, 3, 1.0)\ng.insert_edge(0, 4, 3.0)\ng.insert_edge(1, 2, 2.0)\ng.insert_edge(1, 4, 1.0)\ng.insert_edge(3, 4, 3.0)\ng.insert_edge(4, 2, 3.0)\ng.insert_edge(4, 3, 3.0) \n```", "```\ndef insert_node(self, label=None) -> Node: \n    new_node: Node = Node(self.num_nodes, label=label)\n    self.nodes.append(new_node)\n    self.num_nodes += 1\n    return new_node \n```", "```\ndef make_copy(self): \n    g2: Graph = Graph(self.num_nodes, undirected=self.undirected)\n    for node in self.nodes:\n      ❶ g2.nodes[node.index].label = node.label\n        for edge in node.edges.values():\n          ❷ g2.insert_edge(edge.from_node, edge.to_node, edge.weight)\n    return g2 \n```", "```\ng = [[0, 1, 0, 1, 1],\n     [1, 0, 1, 0, 1],\n     [0, 1, 0, 0, 1],\n     [1, 0, 0, 0, 1],\n     [1, 1, 1, 1, 0]] \n```", "```\nclass GraphMatrix:\n    def __init__(self, num_nodes: int, undirected: bool=False): \n        self.num_nodes: int = num_nodes\n        self.undirected: bool = undirected\n        self.connections = [[0.0] * num_nodes for _ in range(num_nodes)] \n```", "```\ndef get_edge(self, from_node: int, to_node: int) -> float: \n    if from_node < 0 or from_node >= self.num_nodes:\n        raise IndexError if to_node < 0 or to_node >= self.num_nodes:\n        raise IndexError\n    return self.connections[from_node][to_node] \n```", "```\ndef set_edge(self, from_node: int, to_node: int, weight: float):\n  ❶ if from_node < 0 or from_node >= self.num_nodes:\n        raise IndexError\n    if to_node < 0 or to_node >= self.num_nodes:\n        raise IndexError\n\n  ❷ self.connections[from_node][to_node] = weight\n  ❸ if self.undirected:\n        self.connections[to_node][from_node] = weight \n```", "```\ng: GraphMatrix = GraphMatrix(5, undirected=False)\ng.set_edge(0, 1, 1.0)\ng.set_edge(0, 3, 1.0)\ng.set_edge(0, 4, 3.0)\ng.set_edge(1, 2, 2.0)\ng.set_edge(1, 4, 1.0)\ng.set_edge(3, 4, 3.0)\ng.set_edge(4, 2, 3.0)\ng.set_edge(4, 3, 3.0) \n```"]