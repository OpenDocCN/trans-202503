["```\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom os import urandom\n\nBLOCK_SIZE = 16\nKEY_SIZE = 16\n\n# Pick a random 16-byte key using Python's crypto PRNG.\nk = urandom(KEY_SIZE)\nprint(f\"k = {k.hex()}\")\n\n# Create an instance of AES-128.\naes = Cipher(algorithms.AES(k), modes.ECB())\naes_ecb_encryptor = aes.encryptor()\n\n# Set plaintext p to the all-zero string.\np = bytes([0x00] * BLOCK_SIZE)\n\n# Encrypt plaintext p to ciphertext c.\nc = aes_ecb_encryptor.update(p) + aes_ecb_encryptor.finalize()\nprint(f\"enc({p.hex()}) = {c.hex()}\")\n\n# Decrypt ciphertext c to plaintext p.\naes_ecb_decryptor = aes.decryptor()\np = aes_ecb_decryptor.update(c) + aes_ecb_decryptor.finalize()\nprint(f\"dec({c.hex()}) = {p.hex()}\")\n```", "```\n$ **./aes_block.py**\nk = 2c6202f9a582668aa96d511862d8a279\nenc(00000000000000000000000000000000) = 12b620bb5eddcde9a07523e59292a6d7\ndec(12b620bb5eddcde9a07523e59292a6d7) = 00000000000000000000000000000000\n```", "```\n /* Round 1: */\n  t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[4];\n  t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[5];\n  t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[6];\n  t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[7];\n  /* Round 2: */\n  s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[8];\n  s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[9];\n  s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];\n  s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];\n`--snip--`\n```", "```\nPXOR       %xmm5,  %xmm0\nAESENC     %xmm6,  %xmm0\nAESENC     %xmm7,  %xmm0\nAESENC     %xmm8,  %xmm0\nAESENC     %xmm9,  %xmm0\nAESENC     %xmm10, %xmm0\nAESENC     %xmm11, %xmm0\nAESENC     %xmm12, %xmm0\nAESENC     %xmm13, %xmm0\nAESENC     %xmm14, %xmm0\nAESENCLAST %xmm15, %xmm0\n```", "```\n#!/usr/bin/env python\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom os import urandom\n\nBLOCK_SIZE = 16\nKEY_SIZE = 16\n\n# The blocks() function splits a data string into space-separated blocks.\ndef blocks(data):\n    split = [data[i:i+BLOCK_SIZE].hex() for i in range(0, len(data), BLOCK_SIZE)]\n    return ' '.join(split)\nk = urandom(KEY_SIZE)\nprint(f\"k = {k.hex()}\")\n\n# Create an instance of AES-128 to encrypt and decrypt.\naes = Cipher(algorithms.AES(k), modes.ECB())\naes_ecb_encryptor = aes.encryptor()\n\n# Set plaintext p as two blocks of zeros.\np = bytes([0x00] * 2 * BLOCK_SIZE)\n\n# Encrypt plaintext p to ciphertext c.\nc = aes_ecb_encryptor.update(p) + aes_ecb_encryptor.finalize()\nprint(f\"enc({blocks(p)}) = {blocks(c)}\")\n```", "```\n$ **./aes_ecb.py**\nk = 50a0ebeff8001250e87d31d72a86e46d\nenc(00000000000000000000000000000000 00000000000000000000000000000000) =\n5eb4b7af094ef7aca472bbd3cd72f1ed 5eb4b7af094ef7aca472bbd3cd72f1ed\n```", "```\n#!/usr/bin/env python\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom os import urandom\n\nBLOCK_SIZE = 16\nKEY_SIZE = 16\n\n# The blocks() function splits a data string into space-separated blocks.\ndef blocks(data):\n    split = [data[i:i+BLOCK_SIZE].hex() for i in range(0, len(data), BLOCK_SIZE)]\n    return ' '.join(split)\n\n# Pick a random key.\nk = urandom(KEY_SIZE)\nprint(f\"k  = {k.hex()}\")\n\n# Pick a random IV.\n**iv = urandom(BLOCK_SIZE)**\nprint(f\"iv = {iv.hex()}\")\n\n# Pick an instance of AES in CBC mode.\naes_cbc_encryptor = Cipher(algorithms.AES(k), modes.CBC(iv)).encryptor()\n\n# Set plaintext p as two blocks of zeros.\np = bytes([0x00] * 2 * BLOCK_SIZE)\n\nc = aes_cbc_encryptor.update(p) + aes_cbc_encryptor.finalize()\nprint(f\"enc({blocks(p)}) = {blocks(c)}\")\n\n# Now with a different IV and the same key\n**iv = urandom(BLOCK_SIZE)**\nprint(f\"iv = {iv.hex()}\")\n\naes_cbc_encryptor = Cipher(algorithms.AES(k), modes.CBC(iv)).encryptor()\nc = aes_cbc_encryptor.update(p) + aes_cbc_encryptor.finalize()\nprint(f\"enc({blocks(p)}) = {blocks(c)}\")\n```", "```\n$ **./aes_cbc.py**\nk = 9cf0d31ad2df24f3cbbefc1e6933c872\niv = 0a75c4283b4539c094fc262aff0d17af\nenc(00000000000000000000000000000000 00000000000000000000000000000000) =\n370404dcab6e9ecbc3d24ca5573d2920 3b9e5d70e597db225609541f6ae9804a\niv = a6016a6698c3996be13e8739d9e793e2\nenc(00000000000000000000000000000000 00000000000000000000000000000000) =\n655e1bb3e74ee8cf9ec1540afd8b2204 b59db5ac28de43b25612dfd6f031087a\n```", "```\n#!/usr/bin/env python\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom os import urandom\n\nBLOCK_SIZE = 16\nKEY_SIZE = 16\n\n# Pick a random key.\nk = urandom(KEY_SIZE)\nprint(f\"k  = {k.hex()}\")\n\n# And a random nonce\n# (careful with random nonces, see discussion below).\nn = urandom(BLOCK_SIZE)\nprint(f\"nonce  = {n.hex()}\")\n\n# Create a 7-byte plaintext p.\np = bytes([0x00] * 7)\n\n# Encrypt the plaintext p with AES-CTR.\naes_ctr_encryptor = Cipher(algorithms.AES(k), modes.CTR(n)).encryptor()\n\nc = aes_ctr_encryptor.update(p) + aes_ctr_encryptor.finalize()\nprint(f\"enc({p.hex()}) = {c.hex()}\")\n\n# Decrypt the ciphertext c.\naes_ctr_decryptor = Cipher(algorithms.AES(k), modes.CTR(n)).decryptor()\np = aes_ctr_decryptor.update(c) + aes_ctr_decryptor.finalize()\nprint(f\"dec({c.hex()}) = {p.hex()}\")\n\n# Decrypt the ciphertext c using the encryption function.\naes_ctr_encryptor = Cipher(algorithms.AES(k), modes.CTR(n)).encryptor()\np = aes_ctr_encryptor.update(c) + aes_ctr_encryptor.finalize()\nprint(f\"enc({c.hex()}) = {p.hex()}\")\n```", "```\n$ **./aes_ctr.py**\nk = 130a1aa77fa58335272156421cb2a3ea\nenc(00010203) = b23d284e\nenc(b23d284e) = 00010203\n```"]