- en: Chapter 54. POSIX Shared Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous chapters, we looked at two techniques that allow unrelated processes
    to share memory regions in order to perform IPC: System V shared memory ([Chapter 48](ch48.html
    "Chapter 48. System V Shared Memory")) and shared file mappings ([Shared File
    Mappings](ch49.html#shared_file_mappings "Shared File Mappings")). Both of these
    techniques have potential drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The System V shared memory model, which uses keys and identifiers, is not consistent
    with the standard UNIX I/O model, which uses filenames and descriptors. This difference
    means that we require an entirely new set of system calls and commands for working
    with System V shared memory segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a shared file mapping for IPC requires the creation of a disk file, even
    if we are not interested in having a persistent backing store for the shared region.
    Aside from the inconvenience of needing to create the file, this technique incurs
    some file I/O overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of these drawbacks, POSIX.1b defined a new shared memory API: POSIX
    shared memory, which is the subject of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: POSIX talks about shared memory *objects*, while System V talks about shared
    memory *segments*. These differences in terminology are historical—both terms
    are used for referring to regions of memory shared between processes.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: POSIX shared memory allows to us to share a mapped region between unrelated
    processes without needing to create a corresponding mapped file. POSIX shared
    memory is supported on Linux since kernel 2.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'SUSv3 doesn’t specify any of the details of how POSIX shared memory is to be
    implemented. In particular, there is no requirement for the use of a (real or
    virtual) file system to identify shared memory objects, although many UNIX implementations
    do employ a file system for this purpose. Some UNIX implementations create the
    names for shared memory objects as files in a special location in the standard
    file system. Linux uses a dedicated *tmpfs* file system ([A Virtual Memory File
    System: *tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs "A Virtual
    Memory File System: tmpfs")) mounted under the directory `/dev/shm`. This file
    system has kernel persistence--the shared memory objects that it contains will
    persist even if no process currently has them open, but they will be lost if the
    system is shut down.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The total amount of memory in all POSIX shared memory regions on the system
    is limited by the size of the underlying *tmpfs* file system. This file system
    is typically mounted at boot time with some default size (e.g., 256 MB). If necessary,
    the superuser can change the size of the file system by remounting it using the
    command *mount -o remount,size=<num-bytes>*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a POSIX shared memory object, we perform two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the *shm_open()* function to open an object with a specified name. (We described
    the rules governing the naming of POSIX shared memory objects in Section 51.1.)
    The *shm_open()* function is analogous to the *open()* system call. It either
    creates a new shared memory object or opens an existing object. As its function
    result, *shm_open()* returns a file descriptor referring to the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the file descriptor obtained in the previous step in a call to *mmap()*
    that specifies `MAP_SHARED` in the *flags* argument. This maps the shared memory
    object into the process’s virtual address space. As with other uses of *mmap()*,
    once we have mapped the object, we can close the file descriptor without affecting
    the mapping. However, we may need to keep the file descriptor open for subsequent
    use in calls to *fstat()* and *ftruncate()* (see [Creating Shared Memory Objects](ch54.html#creating_shared_memory_objects
    "Creating Shared Memory Objects")).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The relationship between *shm_open()* and *mmap()* for POSIX shared memory is
    analogous to that between *shmget()* and *shmat()* for System V shared memory.
    The origin of the two-step process (*shm_open()* plus *mmap()*) for using POSIX
    shared memory objects instead of the use of a single function that performs both
    tasks is historical. When the POSIX committee added this feature, the *mmap()*
    call already existed ([Stevens, 1999]). In effect, all that we are doing is replacing
    calls to *open()* with calls to *shm_open()*, with the difference that using *shm_open()*
    doesn’t require the creation of a file in a disk-based file system.
  prefs: []
  type: TYPE_NORMAL
- en: Since a shared memory object is referred to using a file descriptor, we can
    usefully employ various file descriptor system calls already defined in the UNIX
    system (e.g., *ftruncate()*), rather than needing new special-purpose system calls
    (as is required for System V shared memory).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Shared Memory Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *shm_open()* function creates and opens a new shared memory object or opens
    an existing object. The arguments to *shm_open()* are analogous to those for *open()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns file descriptor on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *name* argument identifies the shared memory object to be created or opened.
    The *oflag* argument is a mask of bits that modify the behavior of the call. The
    values that can be included in this mask are summarized in [Table 54-1](ch54.html#bit_values_for_the_shm_underscore_open_o
    "Table 54-1. Bit values for the shm_open() oflag argument").
  prefs: []
  type: TYPE_NORMAL
- en: Table 54-1. Bit values for the *shm_open() oflag* argument
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `O_CREAT` | Create object if it doesn’t already exist |'
  prefs: []
  type: TYPE_TB
- en: '| `O_EXCL` | With `O_CREAT`, create object exclusively |'
  prefs: []
  type: TYPE_TB
- en: '| `O_RDONLY` | Open for read-only access |'
  prefs: []
  type: TYPE_TB
- en: '| `O_RDWR` | Open for read-write access |'
  prefs: []
  type: TYPE_TB
- en: '| `O_TRUNC` | Truncate object to zero length |'
  prefs: []
  type: TYPE_TB
- en: One of the purposes of the *oflag* argument is to determine whether we are opening
    an existing shared memory object or creating and opening a new object. If *oflag*
    doesn’t include `O_CREAT`, we are opening an existing object. If O_CREAT is specified,
    then the object is created if it doesn’t already exist. Specifying `O_EXCL` in
    conjunction with `O_CREAT` is a request to ensure that the caller is the creator
    of the object; if the object already exists, an error results (`EEXIST`).
  prefs: []
  type: TYPE_NORMAL
- en: The *oflag* argument also indicates the kind of access that the calling process
    will make to the shared memory object, by specifying exactly one of the values
    `O_RDONLY` or `O_RDWR`.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining flag value, `O_TRUNC`, causes a successful open of an existing
    shared memory object to truncate the object to a length of zero.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, truncation occurs even on a read-only open. However, SUSv3 says that
    results of using `O_TRUNC` with a read-only open is undefined, so we can’t portably
    rely on a specific behavior in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new shared memory object is created, its ownership and group ownership
    are taken from the effective user and group IDs of the process calling *shm_open()*,
    and the object permissions are set according to the value supplied in the *mode*
    bit-mask argument. The bit values for *mode* are the same as for files ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files")).
    As with the *open()* system call, the permissions mask in *mode* is masked against
    the process umask ([The Process File Mode Creation Mask: *umask()*](ch15.html#the_process_file_mode_creation_mask_colo
    "The Process File Mode Creation Mask: umask()")). Unlike *open()*, the *mode*
    argument is always required for a call to *shm_open()*; if we are not creating
    a new object, this argument should be specified as 0.'
  prefs: []
  type: TYPE_NORMAL
- en: The close-on-exec flag (`FD_CLOEXEC`, [File Descriptors and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()")) is set on the file descriptor returned by *shm_open()*,
    so that the file descriptor is automatically closed if the process performs an
    *exec()*. (This is consistent with the fact that mappings are unmapped when an
    *exec()* is performed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new shared memory object is created, it initially has zero length. This
    means that, after creating a new shared memory object, we normally call *ftruncate()*
    ([Truncating a File: *truncate()* and *ftruncate()*](ch05.html#truncating_a_file_colon_truncate_open_pa
    "Truncating a File: truncate() and ftruncate()")) to set the size of the object
    before calling *mmap()*. Following the *mmap()* call, we may also use *ftruncate()*
    to expand or shrink the shared memory object as desired, bearing in mind the points
    discussed in [Boundary Cases](ch49.html#boundary_cases "Boundary Cases").'
  prefs: []
  type: TYPE_NORMAL
- en: When a shared memory object is extended, the newly added bytes are automatically
    initialized to 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any point, we can apply *fstat()* ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) to the file descriptor returned by *shm_open()*
    in order to obtain a *stat* structure whose fields contain information about the
    shared memory object, including its size *(st_size)*, permissions *(st_mode)*,
    owner *(st_uid)*, and group *(st_gid)*. (These are the only fields that SUSv3
    requires *fstat()* to set in the *stat* structure, although Linux also returns
    meaningful information in the time fields, as well as various other less useful
    information in the remaining fields.)'
  prefs: []
  type: TYPE_NORMAL
- en: The permissions and ownership of a shared memory object can be changed using
    *fchmod()* and *fchown()*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 54-1](ch54.html#creating_a_posix_shared_memory_object "Example 54-1. Creating
    a POSIX shared memory object") provides a simple example of the use of *shm_open()*,
    *ftruncate()*, and *mmap()*. This program creates a shared memory object whose
    size is specified by a command-line argument, and maps the object into the process’s
    virtual address space. (The mapping step is redundant, since we don’t actually
    do anything with the shared memory, but it serves to demonstrate the use of *mmap()*.)
    The program permits the use of command-line options to select flags (`O_CREAT`
    and `O_EXCL`) for the *shm_open()* call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use this program to create a 10,000-byte shared
    memory object, and then use *ls* to show this object in `/dev/shm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 54-1. Creating a POSIX shared memory object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using Shared Memory Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 54-2](ch54.html#copying_data_into_a_posix_shared_memory "Example 54-2. Copying
    data into a POSIX shared memory object") and [Example 54-3](ch54.html#copying_data_from_a_posix_shared_memory
    "Example 54-3. Copying data from a POSIX shared memory object") demonstrate the
    use of a shared memory object to transfer data from one process to another. The
    program in [Example 54-2](ch54.html#copying_data_into_a_posix_shared_memory "Example 54-2. Copying
    data into a POSIX shared memory object") copies the string contained in its second
    command-line argument into the existing shared memory object named in its first
    command-line argument. Before mapping the object and performing the copy, the
    program uses *ftruncate()* to resize the shared memory object to be the same length
    as the string that is to be copied.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 54-2. Copying data into a POSIX shared memory object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The program in [Example 54-3](ch54.html#copying_data_from_a_posix_shared_memory
    "Example 54-3. Copying data from a POSIX shared memory object") displays the string
    in the existing shared memory object named in its command-line argument on standard
    output. After calling *shm_open()*, the program uses *fstat()* to determine the
    size of the shared memory and uses that size in the call to *mmap()* that maps
    the object and in the *write()* call that prints the string.
  prefs: []
  type: TYPE_NORMAL
- en: Example 54-3. Copying data from a POSIX shared memory object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following shell session demonstrates the use of the programs in [Example 54-2](ch54.html#copying_data_into_a_posix_shared_memory
    "Example 54-2. Copying data into a POSIX shared memory object") and [Example 54-3](ch54.html#copying_data_from_a_posix_shared_memory
    "Example 54-3. Copying data from a POSIX shared memory object"). We first create
    a zero-length shared memory object using the program in [Example 54-1](ch54.html#creating_a_posix_shared_memory_object
    "Example 54-1. Creating a POSIX shared memory object").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the program in [Example 54-2](ch54.html#copying_data_into_a_posix_shared_memory
    "Example 54-2. Copying data into a POSIX shared memory object") to copy a string
    into the shared memory object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that the program resized the shared memory object
    so that it is large enough to hold the specified string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use the program in [Example 54-3](ch54.html#copying_data_from_a_posix_shared_memory
    "Example 54-3. Copying data from a POSIX shared memory object") to display the
    string in the shared memory object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Applications must typically use some synchronization technique to allow processes
    to coordinate their access to shared memory. In the example shell session shown
    here, the coordination was provided by the user running the programs one after
    the other. Typically, applications would instead use a synchronization primitive
    (e.g., semaphores) to coordinate access to a shared memory object.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Shared Memory Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SUSv3 requires that POSIX shared memory objects have at least kernel persistence;
    that is, they continue to exist until they are explicitly removed or the system
    is rebooted. When a shared memory object is no longer required, it should be removed
    using *shm_unlink()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *shm_unlink()* function removes the shared memory object specified by *name*.
    Removing a shared memory object doesn’t affect existing mappings of the object
    (which will remain in effect until the corresponding processes call *munmap()*
    or terminate), but prevents further *shm_open()* calls from opening the object.
    Once all processes have unmapped the object, the object is removed, and its contents
    are lost.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 54-4](ch54.html#using_shm_underscore_unlink_open_parenth
    "Example 54-4. Using shm_unlink() to unlink a POSIX shared memory object") uses
    *shm_unlink()* to remove the shared memory object specified in the program’s command-line
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Example 54-4. Using *shm_unlink()* to unlink a POSIX shared memory object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Comparisons Between Shared Memory APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we have considered a number of different techniques for sharing memory
    regions between unrelated processes:'
  prefs: []
  type: TYPE_NORMAL
- en: System V shared memory ([Chapter 48](ch48.html "Chapter 48. System V Shared
    Memory"));
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shared file mappings ([Shared File Mappings](ch49.html#shared_file_mappings
    "Shared File Mappings")); and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX shared memory objects (the subject of this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the points that we make in this section are also relevant for shared
    anonymous mappings ([Anonymous Mappings](ch49.html#anonymous_mappings "Anonymous
    Mappings")), which are used for sharing memory between processes that are related
    via *fork()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number of points apply to all of these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: They provide fast IPC, and applications typically must use a semaphore (or other
    synchronization primitive) to synchronize access to the shared region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the shared memory region has been mapped into the process’s virtual address
    space, it looks just like any other part of the process’s memory space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system places the shared memory regions within the process virtual address
    space in a similar manner. We outlined this placement while describing System
    V shared memory in Section 48.5\. The Linux-specific `/proc/`*PID*`/maps` file
    lists information about all types of shared memory regions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming that we don’t attempt to map a shared memory region at a fixed address,
    we should ensure that all references to locations in the region are calculated
    as offsets (rather than pointers), since the region may be located at different
    virtual addresses within different processes ([Storing Pointers in Shared Memory](ch48.html#storing_pointers_in_shared_memory
    "Storing Pointers in Shared Memory")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions described in [Chapter 50](ch50.html "Chapter 50. Virtual Memory
    Operations") that operate on regions of virtual memory can be applied to shared
    memory regions created using any of these techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few notable differences between the techniques for shared
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the contents of a shared file mapping are synchronized with the
    underlying mapped file means that the data stored in a shared memory region can
    persist across system restarts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System V and POSIX shared memory use different mechanisms to identify and refer
    to a shared memory object. System V uses its own scheme of keys and identifiers,
    which doesn’t fit with the standard UNIX I/O model and requires separate system
    calls (e.g., *shmctl()*) and commands (*ipcs* and *ipcrm*). By contrast, POSIX
    shared memory employs names and file descriptors, and consequently shared memory
    objects can be examined and manipulated using a variety of existing UNIX system
    calls (e.g., *fstat()* and *fchmod()*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of a System V shared memory segment is fixed at the time of creation
    (via *shmget()*). By contrast, for a mapping backed by a file or by a POSIX shared
    memory object, we can use *ftruncate()* to adjust the size of the underlying object,
    and then re-create the mapping using *munmap()* and *mmap()* (or the Linux-specific
    *mremap()*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historically, System V shared memory was more widely available than *mmap()*
    and POSIX shared memory, although most UNIX implementations now provide all of
    these techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the exception of the final point regarding portability, the differences
    listed above are advantages in favor of shared file mappings and POSIX shared
    memory objects. Thus, in new applications, one of these interfaces may be preferable
    to System V shared memory. Which one we choose depends on whether or not we require
    a persistent backing store. Shared file mappings provide such a store; POSIX shared
    memory objects allow us to avoid the overhead of using a disk file when a backing
    store is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A POSIX shared memory object is used to share a region of memory between unrelated
    processes without creating an underlying disk file. To do this, we replace the
    call to *open()* that normally precedes *mmap()* with a call to *shm_open()*.
    The *shm_open()* call creates a file in a memory-based file system, and we can
    employ traditional file descriptor system calls to perform various operations
    on this virtual file. In particular, *ftruncate()* must be used to set the size
    of the shared memory object, since initially it has a length of zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now described three techniques for sharing memory regions between unrelated
    processes: System V shared memory, shared file mappings, and POSIX shared memory
    objects. There are several similarities between the three techniques. There are
    also some important differences, and, except for the issue of portability, these
    differences favor shared file mappings and POSIX shared memory objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rewrite the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`) to use POSIX shared memory objects instead of
    System V shared memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
