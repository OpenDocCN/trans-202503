- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SHORTCUTS AND APPROXIMATIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we’ve spent a lot of time looking at how to compute efficiently, especially
    with regard to memory usage. But there’s one thing that’s better than computing
    efficiently, and that’s not computing at all. This chapter looks at two ways to
    avoid computing: taking shortcuts and approximating.'
  prefs: []
  type: TYPE_NORMAL
- en: We think of computers as very exact and precise. But, as we saw in “[Representing
    Real Numbers](ch01.xhtml#ch01lev1sec6)” on [page 14](ch01.xhtml#page_14), they
    really aren’t. We can write code to be as exact as we want. For example, the UNIX
    `bc` utility is an arbitrary precision calculator that’s perfect if you need lots
    of accuracy, but it’s not a very efficient approach because computer hardware
    doesn’t support arbitrary precision. This leads to the question, how close is
    good enough for a particular application? Effective use of computing resources
    means not doing more work than necessary. Calculating all the digits of π before
    using it is just not rational!
  prefs: []
  type: TYPE_NORMAL
- en: '**Table Lookup**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many times it’s simpler and faster to look something up in a table than to do
    a calculation. We’ll look at a few examples of this approach in the following
    subsections. Table lookup is similar to the loop-invariant optimization that was
    discussed in [Chapter 8](ch08.xhtml#ch08) in that if you’re going to use something
    a lot, it often makes sense to calculate it once in advance.
  prefs: []
  type: TYPE_NORMAL
- en: '***Conversion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we need to read a temperature sensor and display the result in tenths
    of a degree Celsius (°C). A clever hardware designer has given us a circuit that
    produces a voltage based on the measured temperature that we can read using an
    A/D converter (see “[Analog-to-Digital Conversion](ch06.xhtml#ch06lev2sec15)”
    on [page 162](ch06.xhtml#page_162)). The curve looks like [Figure 11-1](ch11.xhtml#ch11fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Temperature sensor curve*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the curve is not a convenient straight line. We can calculate
    the temperature (t) from the voltage (v) using the following formula, where *A*,
    *B*, and *C* are constants determined by the particular model of sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq284-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a lot of floating-point arithmetic is involved, including natural
    logarithms, which is costly. So let’s skip it all. Instead, let’s build a table
    that maps voltage values into temperatures. Suppose we have a 10-bit A/D and that
    8 bits is enough to hold our temperature value. That means we only need a 1,024-byte
    table to eliminate all the calculation, as shown in [Figure 11-2](ch11.xhtml#ch11fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Table lookup conversion*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Texture Mapping***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Table lookup is a mainstay of *texture mapping*, a technique that helps provide
    realistic-looking images in video games and movies. The idea behind it is that
    pasting an image onto an object such as a wall takes a lot less computation than
    algorithmically generating all the detail. This is all well and good, but it has
    its own issues. Let’s say we have a brick wall texture such as the one in [Figure
    11-3](ch11.xhtml#ch11fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Brick wall texture*'
  prefs: []
  type: TYPE_NORMAL
- en: Looks pretty good. But video games aren’t static. You might be running away
    from a brick wall at high speed because you’re being chased by zombies. The appearance
    of the brick wall needs to change based on your distance from it. [Figure 11-4](ch11.xhtml#ch11fig04)
    shows how the wall looks from a long distance away (on the left) and from very
    close (on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Brick wall texture at different distances*'
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, adjusting the texture for distance is a lot of work. As
    the viewpoint moves farther away from the texture, adjacent pixels must be averaged
    together. It’s important to be able to do this calculation quickly so that the
    image doesn’t jump around.
  prefs: []
  type: TYPE_NORMAL
- en: Lance Williams (1949–2017) at the New York Institute of Technology Graphics
    Language Laboratory devised a clever approach called *MIP mapping* (named from
    the Latin *multum in parvo*, meaning “many things in a small place”). His paper
    on this topic, entitled “Pyramidal Parametrics,” was published in the July 1983
    SIGGRAPH proceedings. His method is still in use today, not only in software but
    also in hardware.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in “[Representing Colors](ch01.xhtml#ch01lev1sec12)” on [page 27](ch01.xhtml#page_27),
    a pixel has three 8-bit components, one each for red, green, and blue. Williams
    noticed that on 32-bit systems, a quarter of the space was left over when these
    components were arranged in a rectangular fashion, as shown in [Figure 11-5](ch11.xhtml#ch11fig05).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: Color component arrangement with leftover space*'
  prefs: []
  type: TYPE_NORMAL
- en: He couldn’t just let that space go to waste, so he put it to good use in a different
    way than Tom Duff and Thomas Porter did (see “[Adding Transparency](ch01.xhtml#ch01lev2sec18)”
    on [page 29](ch01.xhtml#page_29)). Williams noticed that because it was one-fourth
    of the space, he could put a one-fourth-size copy of the image into that space,
    and then another one-fourth-size copy into *that* space, and so on, as shown in
    [Figure 11-6](ch11.xhtml#ch11fig06). He called this arrangment a MIP map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: Multiple image layout*'
  prefs: []
  type: TYPE_NORMAL
- en: Making a MIP map out of our brick wall texture results in the image shown in
    [Figure 11-7](ch11.xhtml#ch11fig07) (you’ll have to imagine the color components
    in this grayscale image).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: MIP mapped texture*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there’s a lot more detail in the closer-up images, where it’s
    important. This is interesting, but other than being a clever storage mechanism,
    what use is it? Take a look at [Figure 11-8](ch11.xhtml#ch11fig08), which unfolds
    one of the colors of the MIP map into a pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: MIP map pyramid*'
  prefs: []
  type: TYPE_NORMAL
- en: The image at the tip of the pyramid is what things look like from far away,
    and there’s more detail as we head toward the base. When we need to compute the
    actual texture to display for the position of the eye in [Figure 11-8](ch11.xhtml#ch11fig08),
    we don’t need to average together all the pixels in the base image; we just need
    to use the pixels in the nearest layer. This saves a lot of time, especially when
    the vantage point is far away.
  prefs: []
  type: TYPE_NORMAL
- en: Precomputing information that’s going to be used a lot—in this case, the lower-resolution
    versions of the texture—is equivalent to loop-invariant optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '***Character Classification***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Table lookup methods had a big influence on the addition of libraries to the
    programming language C. Back in [Chapter 8](ch08.xhtml#ch08), we saw that *character
    classification*—deciding which characters were letters, numbers, and so on—is
    an important part of lexical analysis. Going back to the ASCII code chart in [Table
    1-10](ch01.xhtml#ch01tab10), you could easily write code to implement classification,
    such as that shown in [Listing 11-1](ch11.xhtml#ch11list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: Character classification code*'
  prefs: []
  type: TYPE_NORMAL
- en: Some at Bell Labs suggested putting commonly useful functions, such as the ones
    in [Listing 11-1](ch11.xhtml#ch11list01), into *libraries*. Dennis Ritchie (1941–2011)
    argued that people could easily write their own. But Nils-Peter Nelson in the
    computer center had written an implementation of these routines that used a table
    instead of a collection of `if` statements. The table was indexed by character
    value, and each entry in the table had bits for aspects like uppercase, lowercase,
    digit, and so forth, as shown in [Figure 11-9](ch11.xhtml#ch11fig09).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-9: Character classification table*'
  prefs: []
  type: TYPE_NORMAL
- en: Classification, in this case, involved looking up the value in the table and
    checking the bits, as shown in [Listing 11-2](ch11.xhtml#ch11list02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Table-driven character classification code*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the functions in [Listing 11-2](ch11.xhtml#ch11list02) are simpler
    than those in [Listing 11-1](ch11.xhtml#ch11list01). And they have another nice
    property, which is that they’re all essentially the same code; the only difference
    is the value of the constants that are ANDed with the table contents. This approach
    was 20 times faster than what anybody else had done, so Ritchie gave in and these
    functions were added as a library, setting the stage for additional libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll notice that I use* macros *in [Listing 11-2](ch11.xhtml#ch11list02)
    but* functions *in [Listing 11-1](ch11.xhtml#ch11list01). In case you haven’t
    seen macros before, they’re a language construct that substitutes the code on
    the right for the code on the left. So, if your source code included isupper(''a''),
    the language* preprocessor *would replace it with table[(''a'') & 0x7f] & UPPER.
    This is great for small chunks of code because there’s no function call overhead.
    But the code in [Listing 11-1](ch11.xhtml#ch11list01) couldn’t reasonably be implemented
    using macros because we have to handle the case where someone does isupper(*p++).
    If the code in [Listing 11-1](ch11.xhtml#ch11list01) were implemented as macros,
    then in ishexdigit, for example, p would be incremented six times, which would
    be a surprise to the caller. The version in [Listing 11-2](ch11.xhtml#ch11list02)
    references the argument only once, so that doesn’t happen.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integer Methods**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be obvious from the earlier discussion of hardware that some operations
    are cheaper to perform in terms of speed and power consumption than others. Integer
    addition and subtraction are inexpensive. Multiplication and division cost more,
    although we can multiply and divide by 2 cheaply using shift operations. Floating-point
    operations are considerably more expensive. Complex floating-point operations,
    such as the calculation of trigonometric and logarithmic functions, are much more
    expensive. In keeping with the theme for this chapter, it would be best if we
    could find ways to avoid using the more expensive operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some visual examples. [Listing 11-3](ch11.xhtml#ch11list03) modifies
    the web page skeleton from [Listing 10-1](ch10.xhtml#ch10list01) to have `style`,
    a `script` fragment, and a `body`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: Basic canvas*'
  prefs: []
  type: TYPE_NORMAL
- en: I briefly mentioned canvases back in “[HTML5](ch09.xhtml#ch09lev1sec10)” on
    [page 255](ch09.xhtml#page_255). A *canvas* is an element on which you can do
    free-form drawing. You can think of it as a piece of graph paper.
  prefs: []
  type: TYPE_NORMAL
- en: The canvas “graph paper” isn’t exactly what you’re used to because it doesn’t
    use the standard Cartesian coordinate system by default. This is an artifact of
    the direction in which the raster was drawn on televisions (see “[Raster Graphics](ch06.xhtml#ch06lev2sec22)”
    on [page 180](ch06.xhtml#page_180)); the raster starts at the upper left. The
    x-coordinate behaves normally, but the y-coordinate starts at the top and increases
    downward. This coordinate system was kept when television monitors were repurposed
    for computer graphics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern computer graphics systems support arbitrary coordinate systems for which
    graphics hardware often includes support. A *transformation* is applied to every
    (*x*, *y*) coordinate you specify and maps your coordinates to the screen coordinates
    (*x′*, *y′*) using the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*′ = *Ax* + *By* + *C*'
  prefs: []
  type: TYPE_NORMAL
- en: '*y*′ = *Dx* + *Ey* + *F*'
  prefs: []
  type: TYPE_NORMAL
- en: The *C* and *F* terms provide *translation*, which means they move things around.
    The *A* and *E* terms provide *scaling*, which means they make things bigger and
    smaller. The *B* and *D* terms provide *rotation*, which means they change the
    orientation. These are often represented in matrix form.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we just care about translation and scaling to convert the canvas coordinate
    system into a familiar one. We translate downward by the height of the canvas
    on line 13 and then flip the direction of the y-axis on line 14\. The order matters;
    if we did these translations in the reverse order, the origin would be above the
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics are effectively created from blobs of primary colors plopped on a piece
    of graph paper (see “[Representing Colors](ch01.xhtml#ch01lev1sec12)” on [page
    27](ch01.xhtml#page_27)). But how fine a piece of graph paper do we need? And
    how much control do we need over the color blob composition?
  prefs: []
  type: TYPE_NORMAL
- en: The `width` and `height` attributes on line 19 set the size of the `canvas`
    in pixels (see “[Digital Images](ch06.xhtml#ch06lev2sec17)” on [page 173](ch06.xhtml#page_173)).
    The *resolution* of the display is the number of pixels per inch (or per centimeter).
    The size of the canvas on your screen depends on the resolution of your screen.
    Unless it’s a real antique, you probably can’t see the individual pixels. (Note
    that the resolution of the human eye isn’t a constant across the field of vision;
    see “A Photon Accurate Model of the Human Eye,” Michael Deering, SIGGRAPH 2005.)
    Even though current UHD monitors are awesome, techniques such as supersampling
    are still needed to make things look really good.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by drawing things at a very low resolution so we can see the details.
    Let’s make some graph paper by adding a JavaScript function that clears the canvas
    and draws a grid, as shown in [Listing 11-4](ch11.xhtml#ch11list04). We’ll also
    use a scaling transformation to get integer value grid intersections. The scale
    applies to everything drawn on the canvas, so we have to make the line width smaller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: Drawing a grid*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Straight Lines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s draw a couple of lines by placing colored circles on the grid in [Listing
    11-5](ch11.xhtml#ch11list05). One line is horizontal, and the other has a slope
    of 45 degrees. The diagonal line blobs are slightly bigger so we can see both
    lines at the point where they intersect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: Horizontal and diagonal lines*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 11-10](ch11.xhtml#ch11fig10) and by running the program,
    the pixels are farther apart on the diagonal line than they are on the horizontal
    line (![Image](../images/eq293-01.jpg) farther apart, according to Pythagoras).
    Why does this matter? Because both lines have the same number of pixels emitting
    light, but when the pixels are farther apart on the diagonal line, the light density
    is less, making it appear dimmer than the horizontal line. There’s not much you
    can do about it; designers of displays adjust the shape of the pixels to minimize
    this effect. It’s more of an issue on cheaper displays than on desktop monitors
    and phones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: Pixel spacing*'
  prefs: []
  type: TYPE_NORMAL
- en: The horizontal, vertical, and diagonal lines are the easy cases. How do we decide
    what pixels to illuminate for other lines? Let’s make a line-drawing program.
    We’ll start by adding some controls after the `canvas` element in the `body`,
    as shown in [Listing 11-6](ch11.xhtml#ch11list06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: Basic line-drawing program body*'
  prefs: []
  type: TYPE_NORMAL
- en: Then, in [Listing 11-7](ch11.xhtml#ch11list07), we’ll replace the code from
    [Listing 11-5](ch11.xhtml#ch11list05) with event handlers for the `draw` and `erase`
    buttons. The `draw` function uses the dreaded *y* = *mx* + *b*, with *b* always
    being 0 in our case. Surprise! Some stuff from math is actually used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: Floating-point line-drawing and erase functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try this with a y-coordinate of 15\. The result should look like [Figure
    11-11](ch11.xhtml#ch11fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: Line drawn using floating-point arithmetic*'
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty bad, but if you stand way back, it looks like a line. It’s
    as close as we can get. This is not just a computer graphics problem, as anyone
    who does cross-stitching can tell you.
  prefs: []
  type: TYPE_NORMAL
- en: Although the program we just wrote works fine, it’s not very efficient. It’s
    performing floating-point multiplication and rounding at every point. That’s at
    least an order of magnitude slower than integer arithmetic, even on modern machines.
    We do get some performance from computing the slope once in advance (line 15).
    It’s a loop invariant, so there’s a good chance that an optimizer (see “[Optimization](ch08.xhtml#ch08lev1sec10)”
    on [page 234](ch08.xhtml#page_234)) would do this for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Way back in 1962, when floating-point was cost-prohibitive, Jack Bresenham at
    IBM came up with a clever way to draw lines without using floating-point arithmetic.
    Bresenham brought his innovation to the IBM patent office, which didn’t see the
    value in it and declined to pursue a patent. Good thing, since it turned out to
    be a fundamental computer graphics algorithm, and the lack of a patent meant that
    everybody could use it. Bresenham recognized that the line-drawing problem could
    be approached incrementally. Because we’re calculating `y` at each successive
    `x`, we can just add the slope (line 9 in [Listing 11-8](ch11.xhtml#ch11list08))
    each time through, which eliminates the multiplication. That’s not something an
    optimizer is likely to catch; it’s essentially a complex strength-reduction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8: Incrementally calculating y*'
  prefs: []
  type: TYPE_NORMAL
- en: We need floating-point arithmetic because the slope ![Image](../images/eq295-01.jpg)
    is a fraction. But the division can be replaced with addition and subtraction.
    We can have a *decision variable* `d` and add Δ*y* on each iteration. The `y`
    value is incremented whenever `d` ≥ Δ*x*, and then we subtract Δ*x* from `d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last issue: rounding. We want to choose points in the middle of
    pixels, not at the bottom of them. That’s easy to handle by setting the initial
    value of `d` to ½*m* instead of 0\. But we don’t want to introduce a fraction.
    No problem: we’ll just get rid of the ½ by multiplying it and everything else
    by 2 using 2Δ*y* and 2Δ*x* instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the code that draws the dots on the grid with [Listing 11-9](ch11.xhtml#ch11list09)’s
    “integer-only” version (we have no control over whether JavaScript uses integers
    internally, unlike in a language like C). Note that this code works only for lines
    with slopes in the range of 0 to 1\. I’ll leave making it work for all slopes
    as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-9: Integer line drawing*'
  prefs: []
  type: TYPE_NORMAL
- en: One interesting question that arises from [Listing 11-9](ch11.xhtml#ch11list09)
    is, why isn’t the decision arithmetic written as shown in [Listing 11-10](ch11.xhtml#ch11list10)?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-10: Alternate decision code*'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this approach seems better because there’s only one addition
    to the decision variable per iteration. [Listing 11-11](ch11.xhtml#ch11list11)
    shows how this might appear in some hypothetical assembly language such as the
    one from [Chapter 4](ch04.xhtml#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-11: Alternate decision code assembly language*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the alternate version is one instruction longer than the original.
    And in most machines, integer addition takes the same amount of time as a branch.
    Thus, the code we thought would be better is actually one instruction time slower
    whenever we need to increment `y`.
  prefs: []
  type: TYPE_NORMAL
- en: The technique used in Bresenham’s line algorithm can be applied to a large variety
    of other problems. For example, you can produce a smoothly changing color *gradient*,
    such as that shown in [Figure 11-12](ch11.xhtml#ch11fig12), by replacing `y` with
    a color value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: Color gradient*'
  prefs: []
  type: TYPE_NORMAL
- en: The gradient in [Figure 11-12](ch11.xhtml#ch11fig12) was generated using the
    code shown in [Listing 11-12](ch11.xhtml#ch11list12) in the document ready function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-12: Color gradient code*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Curves Ahead***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Integer methods aren’t limited to straight lines. Let’s draw an ellipse. We’ll
    stick to the simple case of ellipses whose axes are aligned with the coordinate
    axes and whose center is at the origin. They’re defined by the following equation,
    where *a* is one-half the width and *b* is one-half the height:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq298-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assuming that we’re at the solid black point in [Figure 11-13](ch11.xhtml#ch11fig13),
    we need to decide which of the three possible next points is closest to the ideal
    ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: Ellipse decision points*'
  prefs: []
  type: TYPE_NORMAL
- en: Defining *A* = *b*² and *B* = *a*², we can rearrange the ellipse equation as
    *Ax*² + *By*² – *AB* = 0\. We won’t be able to satisfy this equation most of the
    time because the points we need to draw on the integer grid aren’t likely to be
    the same as those on the ideal ellipse. When we’re at (*x*, *y*), we want to choose
    our next point to be the one in which *Ax*² + *By*² – *AB* is closest to 0\. And
    we’d like to be able to do it without the seven multiplications in that equation.
  prefs: []
  type: TYPE_NORMAL
- en: Our approach is to calculate the value of the equation at each of the three
    possible points and then choose the point where the equation value is closest
    to 0\. In other words, we’ll calculate a distance variable *d* at each of the
    three points using *d* = *Ax*² + *By*² – *AB*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by figuring out how to calculate *d* at the point (*x* + 1, *y*)
    without the multiplications. We can plug (*x* + 1) into the equation for *x*,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*[*x*+1] = *A*(*x* + 1)² + *By*² – *AB*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, squaring something is just multiplying it by itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*[*x*+1] = *A*(*x* + 1)(*x* + 1) + *By*² – *AB*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying it all out, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*[*x*+1] = *x*² + 2*Ax* + *A* + *By*² – *AB*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we subtract that from the original equation, we see that the difference
    between the equation at *x* and *x* + 1 is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dx* = 2*Ax* + *A*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add *dx* to *d* to get *d[x]* [+ 1]. That doesn’t quite get us where
    we want to be, though, because there’s still a multiplication. So let’s evaluate
    *dx* at *x* + 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dx*[*x*+1] = 2*A*(*x* + 1) + *A*'
  prefs: []
  type: TYPE_NORMAL
- en: '*dx*[*x*+1] = 2*Ax* + 2*A* + *A*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like before, subtraction gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*2*x* = 2*A*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This yields a constant, which makes it easy to calculate *d* at (*x* + 1, *y*)
    without multiplication by using the intermediates *dx* and *d*2*x*:'
  prefs: []
  type: TYPE_NORMAL
- en: 2*A*[*x*+1] = 2*Ax* + *d*2*x*
  prefs: []
  type: TYPE_NORMAL
- en: 'That gets us the horizontal direction—the vertical is almost identical, except
    there’s a sign difference since we’re going in the –*y* direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dy* = –2*By* + *B*'
  prefs: []
  type: TYPE_NORMAL
- en: '*d*2*y* = 2*B*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all these terms, deciding which of the three points is closest
    to the ideal curve is simple. We calculate the horizontal difference *dh* to point
    (*x* + 1, *y*), the vertical difference *dv* to the point (*x*, *y* – 1), and
    the diagonal difference *dd* to the point (*x* + 1, *y* – 1) and choose the smallest.
    Note that although *dx* is always positive, *dv* and *dd* can be negative, so
    we need to take their absolute value before comparing, as shown in [Figure 11-14](ch11.xhtml#ch11fig14).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our ellipse-drawing algorithm draws the ellipse only in the first quadrant.
    That’s okay because there’s another trick that we can use: symmetry. We know that
    each quadrant of the ellipse looks the same as the first; it’s just flipped horizontally,
    vertically, or both. We could draw the whole ellipse by drawing (–*x*, *y*), (–*x*,
    –*y*), and (*x*, –*y*) in addition to drawing (*x*, *y*). Note that we could use
    eight-way symmetry if we were drawing circles.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-14: Ellipse-drawing algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm includes some comparisons that could be simplified, which result
    from drawing one-quarter of the ellipse. The one-quarter ellipse could be partitioned
    into two sections at the point where the slope of the curve is 1\. By doing so,
    we’d have one piece of code that only had to decide between horizontal and diagonal
    movements and another that had to decide between vertical and diagonal movements.
    Which one got executed first would depend on the values of *a* and *b*. But a
    lot more time is spent inside the loop making decisions than in the setup, so
    it’s a good trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding algorithm has one serious deficiency: because it starts from
    the half-width (*a*) and half-height (*b*), it can draw only ellipses that are
    odd numbers of pixels in width and height, since the result is 2*a* wide and 2*b*
    high plus 1 for the axes.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Polynomials***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The method we used to draw ellipses by incrementally calculating differences
    doesn’t scale well beyond conic sections (squared things). That’s because higher-order
    equations can do strange things, such as change direction several times within
    the space of a single pixel—which is pretty hard to test for efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'But incrementally calculating differences can be generalized to any polynomials
    of the form *y* = *Ax*⁰ + *Bx*¹ + *Cx*² + . . . *Dx^n*. All we have to do is generate
    *n* sets of differences so that we start our accumulated additions with a constant.
    This works because, unlike with the ellipse-drawing code, the polynomials have
    only a single independent variable. You may remember Charles Babbage’s difference
    engine from “[The Case for Digital Computers](ch02.xhtml#ch02lev1sec1)” on [page
    34](ch02.xhtml#page_34). It was designed to do just this: evaluate equations using
    incremental differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recursive Subdivision**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We touched briefly on *recursive subdivision* back in “[Stacks](ch05.xhtml#ch05lev1sec3)”
    on [page 122](ch05.xhtml#page_122). It’s a technique with many uses. In this section,
    we’ll examine how to use it to get by with the minimum amount of work.
  prefs: []
  type: TYPE_NORMAL
- en: '***Spirals***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our line-drawing code can be leveraged for more complicated curves. We can calculate
    some points and connect them together using lines.
  prefs: []
  type: TYPE_NORMAL
- en: Your math class has probably covered the measurement of angles in degrees, so
    you know that there are 360 degrees in a circle. You may not be aware that there
    are other systems of measurement. A commonly used one is *radians*. There are
    2π radians in a circle. So 360 degrees is 2π radians, 180 degrees is π radians,
    90 degrees is π/2 radians, 45 degrees is π/4 radians, and so on. You need to know
    this because many trigonometric functions available in math libraries, such as
    the ones in JavaScript, expect angles in radians instead of degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use curves drawn in polar coordinates for our examples because they’re
    pretty. Just in case you haven’t learned this yet, *polar coordinates* use radius
    *r* and angle θ instead of *x* and *y*. Conversion to Cartesian coordinates is
    easy: *x* = *r*cosθ and *y* = *r*sinθ. Our first example draws a spiral using
    *r* = θ × 10; the point that we draw gets farther away from the center as we sweep
    through the angles. We’ll make the input in degrees because it’s not as intuitive
    for many people to think in radians. [Listing 11-13](ch11.xhtml#ch11list13) shows
    the body for the controls.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-13: Spiral body*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll skip the grid here because we need to draw more detail. Because we’re
    doing polar coordinates, [Listing 11-14](ch11.xhtml#ch11list14) puts (0, 0) at
    the center.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-14: Dotted spiral JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a value of 10 for degrees and click Draw. You should see something like
    [Figure 11-15](ch11.xhtml#ch11fig15).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the dots get farther apart as we get farther from the origin, even
    though they overlap near the center. We could make the value of degrees small
    enough that we’d get a good-looking curve, but that means we’d have a lot of points
    that overlap, which is a lot slower, and it’s difficult to guess the value needed
    for an arbitrary function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try drawing lines between the points. Swap in [Listing 11-15](ch11.xhtml#ch11list15)
    for the drawing code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-15: Dotted spiral*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-15: Spiral line JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a value of 20 for degrees and click Draw. [Figure 11-16](ch11.xhtml#ch11fig16)
    shows what you should see.
  prefs: []
  type: TYPE_NORMAL
- en: Not very pretty. Again, it looks good near the center but gets worse as we progress
    outward. We need some way to compute more points as needed—which is where our
    old friend recursive subdivision comes into play. We’re drawing lines using the
    spiral function between two angles, θ[1] and θ[2]. What we’ll do is have some
    *close enough* criterion, and if a pair of points is not close enough, we’ll halve
    the difference in the angles and try again until we do get close enough. We’ll
    use the *distance formula* ![Image](../images/eq303-01.jpg) to find the distance
    between points, as shown in [Listing 11-16](ch11.xhtml#ch11list16).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-16: Spiral line*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-16: Recursive spiral line JavaScript*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that as long as `close_enough` is small enough, the size of the
    increment in degrees doesn’t matter because the code automatically generates as
    many intermediate angles as needed. Play around with different values for `close_enough`;
    maybe add an input field so that it’s easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: The determination of close enough is very important for certain applications.
    Though it’s beyond the scope of this book, think about curved objects that you’ve
    seen in movies. Shining light on them makes them look more realistic. Now imagine
    a mirrored sphere approximated by some number of flat faces just like the spiral
    was approximated by line segments. If the flat faces aren’t small enough, it turns
    into a disco ball (a set of flat surfaces approximating a sphere), which reflects
    light in a completely different manner.
  prefs: []
  type: TYPE_NORMAL
- en: '***Constructive Geometry***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.xhtml#ch05) briefly mentioned quadtrees and showed how they
    could represent shapes. They’re an obvious use of recursion because they’re a
    hierarchical mechanism for dividing up space.'
  prefs: []
  type: TYPE_NORMAL
- en: We can perform Boolean operations on quadtrees. Let’s say we want to design
    something like the engine gasket in [Figure 11-17](ch11.xhtml#ch11fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-17: Engine gasket*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need a data structure for a quadtree node, plus two special leaf values—one
    for 0, which we’re coloring white, and one for 1, which we’re coloring black.
    [Figure 11-18](ch11.xhtml#ch11fig18) shows a structure and the data it represents.
    Each node can reference four other nodes, which is a good use for pointers in
    languages such as C.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-18: Quadtree node*'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to keep track of the size of a node. All operations start from
    the root, the size of which is known, and each child node is one-quarter the size
    of its parent. [Figure 11-19](ch11.xhtml#ch11fig19) shows us how to get the value
    at a location in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-19: Get value of (*x, y*) coordinate in quadtree*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-20](ch11.xhtml#ch11fig20) shows how we would set the value of (that
    is, make black) an (*x*, *y*) coordinate in a quadtree. Note that “done” means
    “return from the function” since it’s recursive.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-20: Set value of (*x, y*) coordinate in quadtree*'
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the value-getting code in [Figure 11-19](ch11.xhtml#ch11fig19).
    At a high level, it descends the tree, subdividing as it goes, until it reaches
    the 1×1 square for the (*x*, *y*) coordinate and sets it to black. Any time it
    hits a white node, it replaces it with a new node having four white children so
    there’s a tree to keep descending. On the way back up, any nodes having all black
    children are replaced by a black node. This happens any time a node with three
    black children has the fourth set to black, as shown in [Figure 11-21](ch11.xhtml#ch11fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-21: Coalescing a node*'
  prefs: []
  type: TYPE_NORMAL
- en: Coalescing nodes not only makes the tree take less memory, but it also makes
    many operations on the tree faster because it’s not as deep.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to clear (that is, make white) the value of an (*x*, *y*) coordinate
    in a quadtree. The answer is fairly similar to the setting algorithm. The differences
    are that we partition black nodes instead of white ones and we coalesce white
    nodes instead of black ones.
  prefs: []
  type: TYPE_NORMAL
- en: We can build some more complicated drawing functions on top of our value-setting
    function. It’s easy to draw rectangles by invoking the set function for each coordinate.
    We can do the same for ellipses using the algorithm from “[Curves Ahead](ch11.xhtml#ch11lev2sec5)”
    on [page 298](ch11.xhtml#page_298) and symmetry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun stuff. Let’s create quadtree versions for some of our Boolean
    logic functions from [Chapter 1](ch01.xhtml#ch01). The NOT function is simple:
    just descend the tree and replace any black nodes with white ones and vice versa.
    The AND and OR functions in [Figure 11-22](ch11.xhtml#ch11fig22) are more interesting.
    These algorithms aren’t designed to perform the equivalents of *C* = *a* AND *b*
    and *C* = *a* OR *b*. Instead, they implement *dst* &= *src* and *dst* |= *src*,
    as in the assignment operators found in many languages. The *dst* operand is the
    one modified.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-22: Quadtree AND and OR functions*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all these tools, let’s build our gasket. We’ll do it at low
    resolution so the details are visible. We’ll start with an empty gasket quadtree
    on the left and a scratch quadtree in the center in which we draw a big circle.
    The scratch quadtree is OR’d with the gasket, producing the result on the right
    as shown in [Figure 11-23](ch11.xhtml#ch11fig23). Note how the coalescing keeps
    the number of subdivisions to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-23: Gasket, circle, circle OR gasket*'
  prefs: []
  type: TYPE_NORMAL
- en: Next we’ll make another circle in a different position and combine it with the
    partially completed gasket, as shown in [Figure 11-24](ch11.xhtml#ch11fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-24: Adding to the gasket*'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing on, we’ll make a black rectangle and combine it with the gasket,
    as shown in [Figure 11-25](ch11.xhtml#ch11fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-25: Adding the rectangle*'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to make a hole. This is accomplished by making a black circle
    and then inverting it using the NOT operation to make it white. The result is
    then ANDed with the partially completed gasket, resulting in the hole as seen
    in [Figure 11-26](ch11.xhtml#ch11fig26).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-26: ANDing a NOT-hole*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s getting boring at this point. We need to combine another hole, in the same
    way as shown in [Figure 11-26](ch11.xhtml#ch11fig26), and then eight smaller holes
    in a similar fashion. You can see the result in [Figure 11-27](ch11.xhtml#ch11fig27).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-27: Completed gasket*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can use Boolean functions on quadtrees to construct objects
    with complicated shapes out of simple geometric pieces. Although we used a two-dimensional
    gasket as our example, this is more commonly done in three dimensions. Twice as
    many nodes are needed for three dimensions, so the quadtree is extended into an
    *octree*, an example of which is shown in [Figure 11-28](ch11.xhtml#ch11fig28).
  prefs: []
  type: TYPE_NORMAL
- en: Building complex objects in three dimensions using the preceding techniques
    is called *constructive solid geometry*. The three-dimensional counterpart to
    a two-dimensional pixel is called a *voxel*, which sort of means “volume pixel.”
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-28: Octree*'
  prefs: []
  type: TYPE_NORMAL
- en: Octrees are a common storage method for CAT scan and MRI data. These machines
    generate a stack of 2D slices. It’s a simple matter to peel away layers to obtain
    cutaway views.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shifting and Masking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the downsides of quadtrees is that the data is scattered around memory;
    they have terrible locality of reference. Just because two squares are next to
    each other in the tree doesn’t mean they’re anywhere near each other in memory.
    This becomes a problem when we have to convert data from one memory organization
    to another. We could always move data 1 bit at a time, but that would involve
    a large number of memory accesses—which we want to minimize, because they’re slow.
  prefs: []
  type: TYPE_NORMAL
- en: One task where this situation arises is displaying data. That’s because the
    display memory organization is determined by the hardware. As mentioned back in
    “[Raster Graphics](ch06.xhtml#ch06lev2sec22)” on [page 180](ch06.xhtml#page_180),
    each row of the raster is painted one at a time in a particular order. A raster
    row is called a *scan line*. The whole collection of scan lines is called a *frame
    buffer*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to paint our completed gasket from [Figure 11-27](ch11.xhtml#ch11fig27)
    on a display. For simplicity, we’ll use a monochrome display that has 1 bit for
    each pixel and uses 16-bit-wide memory. That means the upper-leftmost 16 pixels
    are in the first word, the next 16 are in the second, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The upper-left square in [Figure 11-27](ch11.xhtml#ch11fig27) is 4×4 pixels
    in size and is white, which means we need to be clearing bits in the frame buffer.
    We’ll use the coordinates and size of the quadtree square to construct a mask,
    as shown in [Figure 11-29](ch11.xhtml#ch11fig29).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-29: AND mask*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then AND this mask with all the affected rows, costing only two memory
    accesses per row: one for read and one for write. We would do something similar
    to set bits in the frame buffer; the mask would have 1s in the area to set, and
    we would OR instead of AND.'
  prefs: []
  type: TYPE_NORMAL
- en: Another place where this comes into play is when drawing text characters. Most
    text characters are stored as *bitmaps*, two-dimensional arrays of bits, as shown
    in [Figure 11-30](ch11.xhtml#ch11fig30). Character bitmaps are packed together
    to minimize memory use. That’s how text characters used to be provided; now they
    come as geometric descriptions. But for performance reasons, they’re often converted
    into bitmaps before use, and those bitmaps are usually cached on the assumption
    that characters get reused.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-30: Bitmap text characters*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s replace the character *B* on the display shown in [Figure 11-31](ch11.xhtml#ch11fig31)
    with a *C*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-31: Bitmap text characters*'
  prefs: []
  type: TYPE_NORMAL
- en: The *C* is located in bits 10 through 14 and needs to go into bits 6 through
    10\. For each row, we need to grab the *C* and then mask off everything else in
    the word. Then we need to shift it into the destination position. The destination
    must be read and the locations that we want to overwrite masked off before combining
    with the shifted *C* and being written, as shown in [Figure 11-32](ch11.xhtml#ch11fig32).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-32: Painting a character*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses three memory accesses per row: one to fetch the source, one
    to fetch the destination, and one to write the result. Doing this bit by bit would
    take five times that amount.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there are often additional complications when the source or
    destination spans word boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Math Avoidance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed some simple ways to avoid expensive math in “[Integer Methods](ch11.xhtml#ch11lev1sec2)”
    on [page 290](ch11.xhtml#page_290). Now that we have the background, let’s talk
    about a couple of more complicated math-avoidance techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '***Power Series Approximations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s another take on getting close enough. Let’s say we need to generate
    the sine function because we don’t have hardware that does it for us. One way
    to do this is with a *Taylor series*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq313-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 11-33](ch11.xhtml#ch11fig33) shows a sine wave and the Taylor series
    approximations for different numbers of terms. As you can see, the more terms,
    the closer the result is to an ideal sine.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-33: Taylor series for sine*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a simple matter to add terms until you get the desired degree of accuracy.
    It’s also worth noting that fewer terms are needed for angles more acute than
    90 degrees, so you can be more efficient by using symmetry for other angles.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can reduce the number of multiplications required by initializing
    a *product* to *x*, precomputing –*x*², and multiplying the *product* by –*x*²
    to get each term. All the denominators are constants that could reside in a small
    table indexed by the exponent. Also, we don’t have to compute all of the terms.
    If we need only two digits of accuracy, we can stop when computing more terms
    doesn’t change those digits.
  prefs: []
  type: TYPE_NORMAL
- en: '***The CORDIC Algorithm***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Jack Volder at Convair invented the *Coordinate Rotation Digital Computer (CORDIC)*
    algorithm in 1956\. CORDIC was invented to replace an analog part of the B-58
    bomber navigation system with something more accurate. CORDIC can be used to generate
    trigonometric and logarithmic functions using integer arithmetic. It was used
    in the HP-35, the first portable scientific calculator, released in 1972\. It
    was also used in the Intel 80x87 family of floating-point coprocessors.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of CORDIC is illustrated in [Figure 11-34](ch11.xhtml#ch11fig34).
    Because it’s a unit circle (radius of 1) the x- and y-coordinates of the arrow
    ends are the cosine and sine of the angle. We want to rotate the arrow from its
    original position along the x-axis in smaller and smaller steps until we get to
    the desired angle and then grab the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-34: CORDIC algorithm overview*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want sin(57.529°). As you can see, we first try 45 degrees, which
    isn’t enough, so we take another step of 25.565 degrees, getting us to 71.565
    degrees, which is too much. We then go backward by 14.036 degrees, which gets
    us to our desired 57.529 degrees. We’re clearly performing some sort of subdivision
    but with weird values for the angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw the equations for transformation earlier in “[Integer Methods](ch11.xhtml#ch11lev1sec2),”
    where we cared only about translation and scaling. The CORDIC algorithm is based
    on rotation. The following equations, the general form of which you’ve seen, show
    us how (*x*, *y*) is rotated by angle θ to get a new set of coordinates (*x′*,
    *y′*):'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*′ = *x* × cos(θ) – *y* × sin(θ)'
  prefs: []
  type: TYPE_NORMAL
- en: '*y*′ = *x* × sin(θ) + *y* × cos(θ)'
  prefs: []
  type: TYPE_NORMAL
- en: Although this is mathematically correct, it seems useless because we wouldn’t
    be discussing an algorithm that generates sines and cosines if they were already
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make it worse before making it better by rewriting the equations in terms
    of tangents using the trigonometric identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq314-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Because we’re dividing by cos(θ), we need to multiply the result by the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq314-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That looks pretty ugly. We’re making a bad situation worse, but that’s because
    we haven’t talked about the trick, which goes back to the weird angles. It turns
    out that tan(45°) = 1, tan(26.565°) = ½, and tan(14.036°) = ¼. That sure looks
    like some simple integer division by 2, or as Maxwell Smart might have said, “the
    old right shift trick.” It’s a binary search of the tangents of the angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this plays out for the example in [Figure 11-34](ch11.xhtml#ch11fig34).
    There are three rotations that get us from the original coordinates to the final
    ones. Keep in mind that, per [Figure 11-34](ch11.xhtml#ch11fig34), *x*[0] = 1
    and *y*[0] = 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq315-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the sign change in the last set of equations that result from going the
    other (clockwise) direction; when we’re going clockwise, the sign of the tangent
    is negative. Plugging the equations for (*x*[1], *y*[1]) into the equations for
    (*x*[2], *y*[2]) and plugging that into the equations for (*x*[3], *y*[3]) and
    then factoring out the cosines (and cleaning out the multiplications by 1) gives
    us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq315-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So what about those cosines? Skipping the mathematical proof, it turns out
    that as long as we have enough terms:'
  prefs: []
  type: TYPE_NORMAL
- en: cos(45°) × cos(26.565°) × cos(–14.036°) × . . . = 0.607252935008881
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a constant, and we like constants. Let’s call it *C*. We could multiply
    it at the end like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq316-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But we could save that multiplication by just using the constant for *x*[0],
    as shown next. We’ll also eliminate *y*[0], since it’s 0\. It ends up looking
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/eq316-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you check, you’ll discover that the values for *x*[3] and *y*[3] are pretty
    close to the values of the cosine and sine of 57.529 degrees. And that’s with
    only three terms; more terms gets us closer. Notice that this is all accomplished
    with addition, subtraction, and division by 2.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s turn this into a program that gives us a chance to introduce several additional
    tricks. First, we’ll use a slightly different version of CORDIC called *vectoring
    mode*; so far, we’ve been discussing *rotation mode* because it’s a little easier
    to understand. We’ve seen that in rotation mode we start with a vector (arrow)
    along the x-axis and rotate it until it’s at the desired angle. Vectoring mode
    is sort of the opposite; we start at our desired angle and rotate it until we
    end up with a vector along the x-axis (angle of 0). Doing it this way means we
    can just test the sign of the angle to determine the direction of rotation for
    a step; it saves a comparison between two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we’re going to use table lookup. We’ll precompute a table of angles
    with tangents of 1, ½, ¼, and so on. We only need to do this once. The final algorithm
    is shown in [Figure 11-35](ch11.xhtml#ch11fig35).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-35: CORDIC flowchart*'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s write a C program that implements this algorithm using even more tricks.
    First, we’re going to express our angles in radians instead of in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The second trick is related to the first. You may have noticed that we haven’t
    encountered any numbers greater than 1\. We can design our program to work in
    the first quadrant (between 0 and 90 degrees) and get the others using symmetry.
    An angle of 90 degrees is π/2, which is ≈ 1.57\. Because we don’t have a wide
    range of numbers, we can use a fixed-point integer system instead of floating-point.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to base our sample implementation on 32-bit integers. Because we
    need a range of ≈ ±1.6, we can make bit 30 be the ones, bit 29 the halves, bit
    28 the quarters, bit 27 the eighths, and so on. We’ll use the MSB (bit 31) as
    the sign bit. We can convert floating-point numbers (as long as they’re in range)
    to our fixed-point notation by multiplying by our version of 1, which is 0x40000000,
    and casting (converting) that into integers. Likewise, we can convert our results
    into floating-point by casting them as such and dividing by 0x40000000.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-17](ch11.xhtml#ch11list17) shows the code, which is quite simple.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-17: CORDIC implementation in C*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing CORDIC uses many of the goodies in our growing bag of tricks:
    recursive subdivision, precomputation, table lookup, shifting for power-of-two
    division, integer fixed-point arithmetic, and symmetry.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Somewhat Random Things**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s very difficult to do completely random things on computers because they
    have to generate random numbers based on some formula, and that makes it repeatable.
    That kind of “random” is good enough for most computing tasks though, except for
    cryptography, which we’ll discuss in [Chapter 13](ch13.xhtml#ch13). In this section,
    we’ll explore some approximations based on *pseudorandomness*. We’re choosing
    visual examples because they’re interesting and printable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Space-Filling Curves***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Italian mathematician Giuseppe Peano (1858–1932) came up with the first example
    of a *space-filling curve* in 1890\. Three iterations of it are shown in [Figure
    11-36](ch11.xhtml#ch11fig36).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-36: Peano curve*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the curve is a simple shape that is shrunk and repeated at different
    orientations. Each time that’s done, it fills more of the space.
  prefs: []
  type: TYPE_NORMAL
- en: Space-filling curves exhibit *self-similarity*, which means they look about
    the same both up close and far away. They’re a subset of something called *fractals*,
    which were popularized when Benoit Mandelbrot (1924–2010) published *The Fractal
    Geometry of Nature* (W. H. Freeman and Company, 1977). Many natural phenomena
    are self-similar; for example, a coastline has the same jaggedness when observed
    from a satellite and from a microscope.
  prefs: []
  type: TYPE_NORMAL
- en: The term *fractal* comes from *fraction*. Geometry includes numerous integer
    relationships. For example, doubling the length of the sides of a square quadruples
    its area. But an integer change in lengths in a fractal can change the area by
    a fractional amount, hence the name.
  prefs: []
  type: TYPE_NORMAL
- en: The Koch snowflake is an easy-to-generate curve first described in 1904 by Swedish
    mathematician Helge von Koch (1870–1924). It starts with an equilateral triangle.
    Each side is divided into thirds, and the center third is replaced by a triangle
    one-third of the size, with the edge in line with the original side omitted, as
    shown in [Figure 11-37](ch11.xhtml#ch11fig37).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-37: Four iterations of the Koch snowflake*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that complex and interesting shapes can be generated with a tiny
    amount of code and recursion. Let’s look at slightly more complex example: the
    Hilbert curve, first described in 1891 by German mathematician David Hilbert (1862–1943),
    as shown in [Figure 11-38](ch11.xhtml#ch11fig38).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-38: Four iterations of the Hilbert curve*'
  prefs: []
  type: TYPE_NORMAL
- en: The rules for the next iteration of the Hilbert curve are more complicated than
    for the Koch snowflake, because we don’t do the same thing everywhere. There are
    four different orientations of the “cup” shape that are replaced by smaller versions,
    as shown in [Figure 11-39](ch11.xhtml#ch11fig39). There’s both a graphical representation
    and one using letters for right, up, left, and down. For each iteration, each
    corner of the shape on the left is replaced with the four shapes on the right
    (in order) at one-quarter the size of the shape on the left and then connected
    by straight lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-39: Hilbert curve rules*'
  prefs: []
  type: TYPE_NORMAL
- en: '***L-Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The rules in [Figure 11-39](ch11.xhtml#ch11fig39) are similar to the regular
    expressions we saw back in “[Regular Expressions](ch08.xhtml#ch08lev2sec2)” on
    [page 224](ch08.xhtml#page_224), but backward. Instead of defining what patterns
    are matched, these rules define what patterns can be produced. They’re called
    *L-systems* or *Lindenmayer systems*, after Hungarian botanist Aristid Lindenmayer
    (1925–1989), who developed them in 1968\. Because they define what can be produced,
    they’re also called *production grammars*.
  prefs: []
  type: TYPE_NORMAL
- en: You can see from [Figure 11-39](ch11.xhtml#ch11fig39) that replacing an *R*
    with the sequence *U R R U* transforms the leftmost curve in [Figure 11-38](ch11.xhtml#ch11fig38)
    into the one next to it.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about production grammars is that they’re compact and easy to
    both specify and implement. They can be used to model a lot of phenomena. This
    became quite the rage when Alvy Ray Smith at Lucasfilm published “Plants, Fractals,
    and Formal Languages” (SIGGRAPH, 1984); you couldn’t go outside without bumping
    into L-System-generated shrubbery. Lindenmayer’s work became the basis for much
    of the computer graphics now seen in movies.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make some trees so this book will be carbon-neutral. We have four symbols
    in our grammar, as shown in [Listing 11-18](ch11.xhtml#ch11list18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-18: Symbols for tree grammar*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 11-19](ch11.xhtml#ch11list19), we create a grammar that contains
    two rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-19: Tree grammar rules*'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the symbols and rules as a genetic code. [Figure 11-40](ch11.xhtml#ch11fig40)
    shows several iterations of the grammar starting from *E*. Note that we’re not
    bothering to draw leaves on the ends of the branches. Also, beyond the first three,
    the set of symbols that define the tree are too long to show.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-40: Simple L-system tree*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get pretty good-looking trees without much work. L-systems
    are a great way to generate natural-looking objects.
  prefs: []
  type: TYPE_NORMAL
- en: Production grammars have been used to generate objects since long before computers.
    Knitting instructions are production grammars, for example, as shown in [Listing
    11-20](ch11.xhtml#ch11list20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-20: Production grammar for scarf in [Figure 11-41](ch11.xhtml#ch11fig41)*'
  prefs: []
  type: TYPE_NORMAL
- en: Executing the grammar in [Listing 11-20](ch11.xhtml#ch11list20) using the knitting
    needle I/O device for some number of sections yields a scarf, as shown in [Figure
    11-41](ch11.xhtml#ch11fig41).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-41: Scarf produced by production grammar*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Going Stochastic***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Stochastic* is a good word to use when you want to sound sophisticated and
    *random* just won’t do. Alan Fournier and Don Fussell at the University of Texas
    at Dallas introduced the notion of adding randomness to computer graphics in 1980\.
    A certain amount of randomness adds variety. For example, [Figure 11-42](ch11.xhtml#ch11fig42)
    shows a stochastic modification of the L-system trees from the last section.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-42: Stochastic L-system trees*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it generates a nice set of similar-looking trees. A forest looks
    more realistic when the trees aren’t all identical.
  prefs: []
  type: TYPE_NORMAL
- en: Loren Carpenter at Boeing published a paper that pioneered a simple way to generate
    fractals (“Computer Rendering of Fractal Curves and Surfaces,” SIGGRAPH, 1980).
    At SIGGRAPH 1983, Carpenter and Mandelbrot engaged in a very heated discussion
    about whether Carpenter’s results were actually fractals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Carpenter left Boeing and continued his work at Lucasfilm. His fractal mountains
    produced the planet in *Star Trek II: The Wrath of Khan*. An interesting factoid
    is that the planet took about six months of computer time to generate. Because
    it was generated using random numbers, Spock’s coffin ended up flying through
    the side of the mountain for several frames. Artists had to manually cut a notch
    in the mountain to fix this.'
  prefs: []
  type: TYPE_NORMAL
- en: Carpenter’s technique was simple. He randomly selected a point on a line and
    then moved that point a random amount. He recursively repeated this for the two
    line segments until things were close enough. It’s a bit like adding randomness
    to the Koch curve generator. [Figure 11-43](ch11.xhtml#ch11fig43) shows a few
    random peaks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-43: Fractal mountains*'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, pretty good for not much work.
  prefs: []
  type: TYPE_NORMAL
- en: '***Quantization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes we don’t have a choice about approximating and must do the best we
    can. For example, we may have a color photograph that needs to be printed in a
    black-and-white newspaper. Let’s look at how we might make this transformation.
    We’ll use the grayscale image in [Figure 11-44](ch11.xhtml#ch11fig44), since this
    book isn’t printed in color. Because it’s grayscale, each of the three color components
    is identical and in the range of 0 to 255.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig44-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-44: Tony Cat*'
  prefs: []
  type: TYPE_NORMAL
- en: We need to perform a process called *quantization*, which means taking the colors
    that we have available in the original image and assigning them to colors in the
    transformed image. It’s yet another sampling problem, as we have to take an analog
    (or *more* analog, in our case) signal and divide it among a fixed set of buckets.
    How do we map 256 values into 2?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple approach called *thresholding*. As you might guess
    from the name, we pick a threshold and assign anything brighter than that to white,
    and anything darker to black. [Listing 11-21](ch11.xhtml#ch11list21) makes anything
    greater than 127 white, and anything not white is black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-21: Threshold pseudocode*'
  prefs: []
  type: TYPE_NORMAL
- en: Running this pseudocode on the image in [Figure 11-44](ch11.xhtml#ch11fig44)
    produces the image in [Figure 11-45](ch11.xhtml#ch11fig45).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig45-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-45: Threshold algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: That doesn’t look very good. But there’s not a lot we can do; we could monkey
    around with the threshold, but that would just give us different bad results.
    We’ll try to get better results using optical illusions.
  prefs: []
  type: TYPE_NORMAL
- en: British scientist Henry Talbot (1800–1877) invented *halftone printing* in the
    1850s for just this reason; photography at the time was grayscale, and printing
    was black and white. Halftone printing broke the image up into dots of varying
    sizes, as shown in the magnified image on the left in [Figure 11-46](ch11.xhtml#ch11fig46).
    As you can see on the right, your eye interprets this as shades of gray.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-46: Halftone pattern*'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t vary the dot size on a computer screen, but we want the same type of
    effect. Let’s explore some different ways to accomplish this. We can’t change
    the characteristics of a single dot that can be either black or white, so we need
    to adjust the surrounding dots somehow to come up with something that your eye
    will see as shades of gray. We’re effectively trading off image resolution for
    the perception of more shades or colors.
  prefs: []
  type: TYPE_NORMAL
- en: The name for this process is *dithering*, and it has an amusing origin going
    back once again to World War II analog computers. Someone noticed that the computers
    worked better aboard flying airplanes than on the ground. It turns out that the
    random vibration from the plane engines kept the gears, wheels, cogs, and such
    from sticking. Vibrating motors were subsequently added to the computers on the
    ground to make them work better by trembling them. This random vibration was called
    *dither*, based on the Middle English verb *didderen*, meaning “to tremble.” There
    are many dithering algorithms; we’ll examine only a few here.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to use a pattern of different thresholds for different pixels.
    In the mid-1970s, American scientist Bryce Bayer (1929–2012) at Eastman Kodak
    invented a key technology for digital cameras, the eponymous *Bayer filter*. The
    *Bayer matrix* is a variation that we can use for our purposes. Some examples
    are shown in [Figure 11-47](ch11.xhtml#ch11fig47).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-47: Bayer matrices*'
  prefs: []
  type: TYPE_NORMAL
- en: These matrices are *tiled* over the image, meaning they repeat in both the x
    and y directions, as shown in [Figure 11-48](ch11.xhtml#ch11fig48). Dithering
    using tiled patterns is called *ordered dithering*, as there’s a predictable pattern
    based on position in the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-48: 2×2 Bayer matrix tiling pattern*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-22](ch11.xhtml#ch11list22) shows the pseudocode for the Bayer matrices
    from [Figure 11-47](ch11.xhtml#ch11fig47).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-22: Bayer ordered dithering pseudocode*'
  prefs: []
  type: TYPE_NORMAL
- en: 'On to the important question: what does Tony Cat think of this? [Figures 11-49](ch11.xhtml#ch11fig49)
    through [11-51](ch11.xhtml#ch11fig51) show him dithered using the three matrices
    just shown.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig49-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-49: Tony dithered using the 2×2 Bayer matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig50-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-50: Tony dithered using the 3×3 Bayer matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig51-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-51: Tony dithered using the 4×4 Bayer matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, these are somewhat acceptable if you squint, and they improve
    with larger matrices. Not exactly the cat’s meow, but a lot better than thresholding.
    Doing more work by using larger matrices yields better results. But the tiling
    pattern shows through. Plus it can produce really trippy artifacts called *moiré*
    patterns for certain images. You might have seen these if you’ve ever grabbed
    a stack of window screens.
  prefs: []
  type: TYPE_NORMAL
- en: How can we eliminate some of these screening artifacts? Instead of using a pattern,
    let’s just compare each pixel to a random number using the pseudocode in [Listing
    11-23](ch11.xhtml#ch11list23). The result is shown in [Figure 11-52](ch11.xhtml#ch11fig52).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-23: Random-number dithering pseudocode*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig52-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-52: Tony dithered using random numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: This eliminates the patterning artifacts but is pretty fuzzy, which is not unusual
    for cats. It’s not as good as the ordered dither.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental problem behind all these approaches is that we can only do so
    much making decisions on a pixel-by-pixel basis. Think about the difference between
    the original pixel values and the processed ones. There’s a certain amount of
    *error* for any pixel that wasn’t black or white in the original. Instead of discarding
    this error as we’ve done so far, let’s try spreading it around to other pixels
    in the neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with something really simple. We’ll take the error for the current
    pixel and apply it to the next horizontal pixel. The pseudocode is in [Listing
    11-24](ch11.xhtml#ch11list24), and the result is shown in [Figure 11-53](ch11.xhtml#ch11fig53).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-24: One-dimensional error propagation pseudocode*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig53-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-53: Tony dithered using one-dimensional error propagation*'
  prefs: []
  type: TYPE_NORMAL
- en: Not great, but not horrible—easily beats thresholding and random numbers and
    is somewhat comparable to the 2×2 matrix; they each have different types of artifacts.
    If you think about it, you’ll realize that error propagation is the same decision
    variable trick that we used earlier for drawing lines and curves.
  prefs: []
  type: TYPE_NORMAL
- en: American computer scientists Robert Floyd (1936–2001) and Louis Steinberg came
    up with an approach in the mid-1970s that you can think of as a cross between
    this error propagation and a Bayer matrix. The idea is to spread the error from
    a pixel to some surrounding pixels using a set of weights, as shown in [Figure
    11-54](ch11.xhtml#ch11fig54).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-54: Floyd-Steinberg error distribution weights*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-25](ch11.xhtml#ch11list25) shows the Floyd-Steinberg pseudocode.
    Note that we have to keep two rows’ worth of error values. We make each of those
    rows 2 longer than needed and offset the index by 1 so that we don’t have to worry
    about running off the end when handling the first or last columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-25: Floyd-Steinberg error propagation code*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot more work, but the results, as shown in [Figure 11-55](ch11.xhtml#ch11fig55),
    look pretty good. (Note that this is unrelated to the Pink Floyd–Steinberg algorithm
    that was used to make album covers in the 1970s.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig55-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-55: Tony dithered using the Floyd-Steinberg algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: Post–Floyd-Steinberg, numerous other distribution schemes have been proposed,
    most of which do more work and distribute the error among more neighboring pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try one more approach, this one published by Dutch software engineer Thiadmer
    Riemersma in 1998\. His algorithm does several interesting things. First, it goes
    back to the approach of affecting only one adjacent pixel. But it keeps track
    of 16 pixels’ worth of error. It calculates a weighted average so that the most
    recently visited pixel has more effect than the least recently visited one. [Figure
    11-56](ch11.xhtml#ch11fig56) shows the weighting curve.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-56: Riemersma pixel weights*'
  prefs: []
  type: TYPE_NORMAL
- en: The Riemersma algorithm doesn’t use the typical adjacent pixels grid that we’ve
    seen before (see [Listing 11-26](ch11.xhtml#ch11list26)). Instead, it follows
    the path of a Hilbert curve, which we saw in [Figure 11-38](ch11.xhtml#ch11fig38).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-26: Riemersma error propagation pseudocode*'
  prefs: []
  type: TYPE_NORMAL
- en: The result is shown in [Figure 11-57](ch11.xhtml#ch11fig57). Still not purr-fect,
    but at this point we’ve seen enough cats. Try the example code on a gradient such
    as the one in [Figure 11-12](ch11.xhtml#ch11fig12). You’ve learned that there
    are many different ways to deal with approximation required by real-life circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/11fig57-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-57: Tony dithered using the Riemersma algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve examined a number of tricks you can use to increase performance
    and efficiency by avoiding or minimizing computation. As Jim Blinn, one of the
    giants in the field of computer graphics, said, “A technique is just a trick that
    you use more than once.” And just as you saw with hardware building blocks, these
    tricks can be combined to solve complex problems.
  prefs: []
  type: TYPE_NORMAL
