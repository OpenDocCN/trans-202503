- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: SHORTCUTS AND APPROXIMATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**捷径和近似**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'So far, we’ve spent a lot of time looking at how to compute efficiently, especially
    with regard to memory usage. But there’s one thing that’s better than computing
    efficiently, and that’s not computing at all. This chapter looks at two ways to
    avoid computing: taking shortcuts and approximating.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花费了大量时间研究如何高效计算，特别是在内存使用方面。但有一件事比高效计算更好，那就是根本不计算。本章将讨论避免计算的两种方法：走捷径和近似。
- en: We think of computers as very exact and precise. But, as we saw in “[Representing
    Real Numbers](ch01.xhtml#ch01lev1sec6)” on [page 14](ch01.xhtml#page_14), they
    really aren’t. We can write code to be as exact as we want. For example, the UNIX
    `bc` utility is an arbitrary precision calculator that’s perfect if you need lots
    of accuracy, but it’s not a very efficient approach because computer hardware
    doesn’t support arbitrary precision. This leads to the question, how close is
    good enough for a particular application? Effective use of computing resources
    means not doing more work than necessary. Calculating all the digits of π before
    using it is just not rational!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为计算机是非常精确的。但是，正如我们在[《表示实数》](ch01.xhtml#ch01lev1sec6)一节中所看到的，计算机并不是那么精确。我们可以编写代码做到尽可能精确。例如，UNIX中的`bc`工具是一个任意精度计算器，如果你需要大量精度，它是完美的，但它并不是一种高效的方法，因为计算机硬件并不支持任意精度。这就引出了一个问题，对于特定应用，精确到什么程度才算足够好呢？有效利用计算资源意味着不要做多余的工作。在使用π之前计算出所有的数字，显然是不理性的！
- en: '**Table Lookup**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**查表法**'
- en: Many times it’s simpler and faster to look something up in a table than to do
    a calculation. We’ll look at a few examples of this approach in the following
    subsections. Table lookup is similar to the loop-invariant optimization that was
    discussed in [Chapter 8](ch08.xhtml#ch08) in that if you’re going to use something
    a lot, it often makes sense to calculate it once in advance.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，通过查表来获取某些值比进行计算更简单、更快捷。在接下来的子节中，我们将看看这种方法的一些例子。查表法与[第8章](ch08.xhtml#ch08)中讨论的循环不变优化类似，即如果某个值会被频繁使用，提前计算一次通常是有意义的。
- en: '***Conversion***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***转换***'
- en: Suppose we need to read a temperature sensor and display the result in tenths
    of a degree Celsius (°C). A clever hardware designer has given us a circuit that
    produces a voltage based on the measured temperature that we can read using an
    A/D converter (see “[Analog-to-Digital Conversion](ch06.xhtml#ch06lev2sec15)”
    on [page 162](ch06.xhtml#page_162)). The curve looks like [Figure 11-1](ch11.xhtml#ch11fig01).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要读取一个温度传感器，并以十分之一摄氏度（°C）为单位显示结果。一位聪明的硬件设计师为我们提供了一个电路，它根据测量的温度输出一个电压，我们可以通过A/D转换器读取这个电压（参见[《模拟到数字转换》](ch06.xhtml#ch06lev2sec15)一节，[第162页](ch06.xhtml#page_162)）。曲线如[图
    11-1](ch11.xhtml#ch11fig01)所示。
- en: '![Image](../images/11fig01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig01.jpg)'
- en: '*Figure 11-1: Temperature sensor curve*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：温度传感器曲线*'
- en: 'You can see that the curve is not a convenient straight line. We can calculate
    the temperature (t) from the voltage (v) using the following formula, where *A*,
    *B*, and *C* are constants determined by the particular model of sensor:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这条曲线并不是一条方便的直线。我们可以使用以下公式根据电压（v）来计算温度（t），其中 *A*、*B* 和 *C* 是由特定传感器型号决定的常数：
- en: '![Image](../images/eq284-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq284-01.jpg)'
- en: As you can see, a lot of floating-point arithmetic is involved, including natural
    logarithms, which is costly. So let’s skip it all. Instead, let’s build a table
    that maps voltage values into temperatures. Suppose we have a 10-bit A/D and that
    8 bits is enough to hold our temperature value. That means we only need a 1,024-byte
    table to eliminate all the calculation, as shown in [Figure 11-2](ch11.xhtml#ch11fig02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里涉及了大量的浮点运算，包括自然对数，而这些都是比较昂贵的运算。所以我们决定跳过这些计算。相反，我们可以构建一个查表，将电压值映射到温度值。假设我们有一个10位的A/D转换器，且8位足以表示我们的温度值。这意味着我们只需要一个1,024字节的表格，就可以避免所有计算，如[图
    11-2](ch11.xhtml#ch11fig02)所示。
- en: '![Image](../images/11fig02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig02.jpg)'
- en: '*Figure 11-2: Table lookup conversion*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：查表转换*'
- en: '***Texture Mapping***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***纹理映射***'
- en: Table lookup is a mainstay of *texture mapping*, a technique that helps provide
    realistic-looking images in video games and movies. The idea behind it is that
    pasting an image onto an object such as a wall takes a lot less computation than
    algorithmically generating all the detail. This is all well and good, but it has
    its own issues. Let’s say we have a brick wall texture such as the one in [Figure
    11-3](ch11.xhtml#ch11fig03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表格查找是*纹理映射*的一个主要组成部分，这项技术有助于在视频游戏和电影中提供逼真的图像。其背后的思路是，将图像粘贴到物体（如墙壁）上，比通过算法生成所有细节要少得多的计算量。这听起来没问题，但它也有自己的问题。假设我们有一个砖墙纹理，像[图11-3](ch11.xhtml#ch11fig03)中那样。
- en: '![Image](../images/11fig03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig03.jpg)'
- en: '*Figure 11-3: Brick wall texture*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：砖墙纹理*'
- en: Looks pretty good. But video games aren’t static. You might be running away
    from a brick wall at high speed because you’re being chased by zombies. The appearance
    of the brick wall needs to change based on your distance from it. [Figure 11-4](ch11.xhtml#ch11fig04)
    shows how the wall looks from a long distance away (on the left) and from very
    close (on the right).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。但视频游戏不是静态的。你可能因为被僵尸追赶而高速逃离一堵砖墙。砖墙的外观需要根据你与它的距离变化。[图11-4](ch11.xhtml#ch11fig04)展示了从远处看墙壁（左侧）和从近处看墙壁（右侧）的样子。
- en: '![Image](../images/11fig04.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig04.jpg)'
- en: '*Figure 11-4: Brick wall texture at different distances*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-4：不同距离下的砖墙纹理*'
- en: As you might expect, adjusting the texture for distance is a lot of work. As
    the viewpoint moves farther away from the texture, adjacent pixels must be averaged
    together. It’s important to be able to do this calculation quickly so that the
    image doesn’t jump around.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预期的那样，调整远距离的纹理是非常繁琐的工作。当视点远离纹理时，邻近的像素必须进行平均处理。能够快速进行这种计算非常重要，以确保图像不会出现跳动现象。
- en: Lance Williams (1949–2017) at the New York Institute of Technology Graphics
    Language Laboratory devised a clever approach called *MIP mapping* (named from
    the Latin *multum in parvo*, meaning “many things in a small place”). His paper
    on this topic, entitled “Pyramidal Parametrics,” was published in the July 1983
    SIGGRAPH proceedings. His method is still in use today, not only in software but
    also in hardware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 兰斯·威廉姆斯（1949–2017）在纽约理工学院图形语言实验室提出了一种巧妙的方法，称为*MIP映射*（这个名字源于拉丁语*multum in parvo*，意思是“在小地方放许多东西”）。他关于这个主题的论文《金字塔参数化》于1983年7月的SIGGRAPH会议记录中发表。他的方法至今仍在使用，不仅在软件中，也在硬件中得到了应用。
- en: As we saw in “[Representing Colors](ch01.xhtml#ch01lev1sec12)” on [page 27](ch01.xhtml#page_27),
    a pixel has three 8-bit components, one each for red, green, and blue. Williams
    noticed that on 32-bit systems, a quarter of the space was left over when these
    components were arranged in a rectangular fashion, as shown in [Figure 11-5](ch11.xhtml#ch11fig05).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[《颜色表示》](ch01.xhtml#ch01lev1sec12)一节中看到的，[第27页](ch01.xhtml#page_27)提到，一个像素有三个8位的分量，分别代表红色、绿色和蓝色。威廉姆斯注意到，在32位系统上，当这些分量以矩形形式排列时，会留下四分之一的空余空间，正如[图11-5](ch11.xhtml#ch11fig05)所示。
- en: '![Image](../images/11fig05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig05.jpg)'
- en: '*Figure 11-5: Color component arrangement with leftover space*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-5：颜色分量排列与剩余空间*'
- en: He couldn’t just let that space go to waste, so he put it to good use in a different
    way than Tom Duff and Thomas Porter did (see “[Adding Transparency](ch01.xhtml#ch01lev2sec18)”
    on [page 29](ch01.xhtml#page_29)). Williams noticed that because it was one-fourth
    of the space, he could put a one-fourth-size copy of the image into that space,
    and then another one-fourth-size copy into *that* space, and so on, as shown in
    [Figure 11-6](ch11.xhtml#ch11fig06). He called this arrangment a MIP map.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 他不能让这块空间白白浪费掉，于是他采用了一种与Tom Duff和Thomas Porter不同的方式来加以利用（参见[《添加透明度》](ch01.xhtml#ch01lev2sec18)在[第29页](ch01.xhtml#page_29)）。威廉姆斯注意到，因为它是四分之一的空间，所以他可以将图像的四分之一大小副本放入这块空间，再将另一个四分之一大小的副本放入*那个*空间，依此类推，正如[图11-6](ch11.xhtml#ch11fig06)所示。他称这种排列为MIP图。
- en: '![Image](../images/11fig06.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig06.jpg)'
- en: '*Figure 11-6: Multiple image layout*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：多重图像布局*'
- en: Making a MIP map out of our brick wall texture results in the image shown in
    [Figure 11-7](ch11.xhtml#ch11fig07) (you’ll have to imagine the color components
    in this grayscale image).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的砖墙纹理制作成MIP图，最终结果就是[图11-7](ch11.xhtml#ch11fig07)中所示的图像（你需要想象这张灰度图中的颜色分量）。
- en: '![Image](../images/11fig07.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig07.jpg)'
- en: '*Figure 11-7: MIP mapped texture*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-7：MIP映射纹理*'
- en: As you can see, there’s a lot more detail in the closer-up images, where it’s
    important. This is interesting, but other than being a clever storage mechanism,
    what use is it? Take a look at [Figure 11-8](ch11.xhtml#ch11fig08), which unfolds
    one of the colors of the MIP map into a pyramid.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，近距离的图像包含更多的细节，这在关键位置很重要。这很有趣，但除了作为一个巧妙的存储机制，它有什么用途呢？看看[图 11-8](ch11.xhtml#ch11fig08)，它将
    MIP 映射的一个颜色展开成金字塔形状。
- en: '![Image](../images/11fig08.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig08.jpg)'
- en: '*Figure 11-8: MIP map pyramid*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：MIP 映射金字塔*'
- en: The image at the tip of the pyramid is what things look like from far away,
    and there’s more detail as we head toward the base. When we need to compute the
    actual texture to display for the position of the eye in [Figure 11-8](ch11.xhtml#ch11fig08),
    we don’t need to average together all the pixels in the base image; we just need
    to use the pixels in the nearest layer. This saves a lot of time, especially when
    the vantage point is far away.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔顶部的图像展示的是远处的样子，随着我们向底部移动，细节逐渐增多。当我们需要计算显示给定眼睛位置的实际纹理时，在[图 11-8](ch11.xhtml#ch11fig08)中，我们不需要将底部图像中的所有像素平均化；我们只需使用最接近的一层像素。这可以节省大量时间，尤其是在视点很远的情况下。
- en: Precomputing information that’s going to be used a lot—in this case, the lower-resolution
    versions of the texture—is equivalent to loop-invariant optimization.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 预计算将被频繁使用的信息——在这种情况下，低分辨率版本的纹理——相当于循环不变优化。
- en: '***Character Classification***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***字符分类***'
- en: Table lookup methods had a big influence on the addition of libraries to the
    programming language C. Back in [Chapter 8](ch08.xhtml#ch08), we saw that *character
    classification*—deciding which characters were letters, numbers, and so on—is
    an important part of lexical analysis. Going back to the ASCII code chart in [Table
    1-10](ch01.xhtml#ch01tab10), you could easily write code to implement classification,
    such as that shown in [Listing 11-1](ch11.xhtml#ch11list01).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表格查找方法对 C 语言中库的加入产生了很大的影响。在[第 8 章](ch08.xhtml#ch08)中，我们看到*字符分类*——决定哪些字符是字母、数字等——是词法分析中的一个重要部分。回顾[表
    1-10](ch01.xhtml#ch01tab10)中的 ASCII 码表，你可以轻松编写代码实现分类，如[清单 11-1](ch11.xhtml#ch11list01)中所示。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: Character classification code*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：字符分类代码*'
- en: Some at Bell Labs suggested putting commonly useful functions, such as the ones
    in [Listing 11-1](ch11.xhtml#ch11list01), into *libraries*. Dennis Ritchie (1941–2011)
    argued that people could easily write their own. But Nils-Peter Nelson in the
    computer center had written an implementation of these routines that used a table
    instead of a collection of `if` statements. The table was indexed by character
    value, and each entry in the table had bits for aspects like uppercase, lowercase,
    digit, and so forth, as shown in [Figure 11-9](ch11.xhtml#ch11fig09).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 贝尔实验室的一些人建议将常用的函数，如[清单 11-1](ch11.xhtml#ch11list01)中的函数，放入*库*中。Dennis Ritchie（1941–2011）认为人们可以很容易地编写自己的代码。但计算机中心的
    Nils-Peter Nelson 编写了一个实现这些例程的程序，使用了一个表格而不是一系列 `if` 语句。该表格通过字符值进行索引，表格中的每个条目包含表示大写、小写、数字等方面的位，如[图
    11-9](ch11.xhtml#ch11fig09)所示。
- en: '![Image](../images/11fig09.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig09.jpg)'
- en: '*Figure 11-9: Character classification table*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：字符分类表*'
- en: Classification, in this case, involved looking up the value in the table and
    checking the bits, as shown in [Listing 11-2](ch11.xhtml#ch11list02).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，分类涉及查找表中的值并检查位，如[清单 11-2](ch11.xhtml#ch11list02)所示。
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Table-driven character classification code*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：基于表格的字符分类代码*'
- en: As you can see, the functions in [Listing 11-2](ch11.xhtml#ch11list02) are simpler
    than those in [Listing 11-1](ch11.xhtml#ch11list01). And they have another nice
    property, which is that they’re all essentially the same code; the only difference
    is the value of the constants that are ANDed with the table contents. This approach
    was 20 times faster than what anybody else had done, so Ritchie gave in and these
    functions were added as a library, setting the stage for additional libraries.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，[清单 11-2](ch11.xhtml#ch11list02)中的函数比[清单 11-1](ch11.xhtml#ch11list01)中的函数简单。而且它们有一个很好的特性，那就是它们本质上是相同的代码；唯一的区别是与表格内容进行与运算的常量值。这种方法比其他任何方法快了
    20 倍，因此 Ritchie 妥协了，这些函数被作为库加入，铺垫了更多库的出现。
- en: '**NOTE**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You’ll notice that I use* macros *in [Listing 11-2](ch11.xhtml#ch11list02)
    but* functions *in [Listing 11-1](ch11.xhtml#ch11list01). In case you haven’t
    seen macros before, they’re a language construct that substitutes the code on
    the right for the code on the left. So, if your source code included isupper(''a''),
    the language* preprocessor *would replace it with table[(''a'') & 0x7f] & UPPER.
    This is great for small chunks of code because there’s no function call overhead.
    But the code in [Listing 11-1](ch11.xhtml#ch11list01) couldn’t reasonably be implemented
    using macros because we have to handle the case where someone does isupper(*p++).
    If the code in [Listing 11-1](ch11.xhtml#ch11list01) were implemented as macros,
    then in ishexdigit, for example, p would be incremented six times, which would
    be a surprise to the caller. The version in [Listing 11-2](ch11.xhtml#ch11list02)
    references the argument only once, so that doesn’t happen.*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*您会注意到，我在 [清单 11-2](ch11.xhtml#ch11list02) 中使用了* 宏 *，但在 [清单 11-1](ch11.xhtml#ch11list01)
    中使用了* 函数 *。如果您之前没见过宏，它们是一种语言结构，用于将右侧的代码替换为左侧的代码。例如，如果您的源代码包含 isupper(''a'')，那么语言*预处理器*会将其替换为
    table[(''a'') & 0x7f] & UPPER。这对于小块代码很有用，因为没有函数调用的开销。但是，像 [清单 11-1](ch11.xhtml#ch11list01)
    中的代码，使用宏来实现是不可行的，因为我们必须处理像 isupper(*p++) 这样的情况。如果 [清单 11-1](ch11.xhtml#ch11list01)
    中的代码被实现为宏，那么例如在 ishexdigit 中，p 会被递增六次，这对调用者来说是个意外。而 [清单 11-2](ch11.xhtml#ch11list02)
    中的版本仅引用了参数一次，因此不会发生这种情况。*'
- en: '**Integer Methods**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**整数方法**'
- en: It should be obvious from the earlier discussion of hardware that some operations
    are cheaper to perform in terms of speed and power consumption than others. Integer
    addition and subtraction are inexpensive. Multiplication and division cost more,
    although we can multiply and divide by 2 cheaply using shift operations. Floating-point
    operations are considerably more expensive. Complex floating-point operations,
    such as the calculation of trigonometric and logarithmic functions, are much more
    expensive. In keeping with the theme for this chapter, it would be best if we
    could find ways to avoid using the more expensive operations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的硬件讨论中应该很明显，一些操作在速度和功耗方面比其他操作更便宜。整数加法和减法是便宜的。乘法和除法成本较高，尽管我们可以通过移位操作便宜地进行乘2和除2。浮动点运算要贵得多。复杂的浮动点运算，如三角函数和对数函数的计算，要贵得多。与本章的主题一致，最好我们能找到避免使用更昂贵操作的方法。
- en: Let’s look at some visual examples. [Listing 11-3](ch11.xhtml#ch11list03) modifies
    the web page skeleton from [Listing 10-1](ch10.xhtml#ch10list01) to have `style`,
    a `script` fragment, and a `body`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一些视觉示例。[清单 11-3](ch11.xhtml#ch11list03) 修改了 [清单 10-1](ch10.xhtml#ch10list01)
    中的网页框架，新增了 `style`、`script` 片段和 `body`。
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-3: Basic canvas*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3：基础画布*'
- en: I briefly mentioned canvases back in “[HTML5](ch09.xhtml#ch09lev1sec10)” on
    [page 255](ch09.xhtml#page_255). A *canvas* is an element on which you can do
    free-form drawing. You can think of it as a piece of graph paper.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 “[HTML5](ch09.xhtml#ch09lev1sec10)” 一节中简要提到过画布，位于 [第255页](ch09.xhtml#page_255)。*canvas*
    是一种元素，您可以在上面进行自由形式的绘图。您可以将其视为一张图表纸。
- en: The canvas “graph paper” isn’t exactly what you’re used to because it doesn’t
    use the standard Cartesian coordinate system by default. This is an artifact of
    the direction in which the raster was drawn on televisions (see “[Raster Graphics](ch06.xhtml#ch06lev2sec22)”
    on [page 180](ch06.xhtml#page_180)); the raster starts at the upper left. The
    x-coordinate behaves normally, but the y-coordinate starts at the top and increases
    downward. This coordinate system was kept when television monitors were repurposed
    for computer graphics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 画布“图表纸”并不像您习惯的那样，因为默认情况下它不使用标准的笛卡尔坐标系。这是电视上栅格绘制方向的产物（参见 “[栅格图形](ch06.xhtml#ch06lev2sec22)”
    第 [180页](ch06.xhtml#page_180)）；栅格从左上角开始。x 坐标表现正常，但 y 坐标从顶部开始并向下增加。当电视显示器被重新用于计算机图形时，这种坐标系统被保留下来。
- en: 'Modern computer graphics systems support arbitrary coordinate systems for which
    graphics hardware often includes support. A *transformation* is applied to every
    (*x*, *y*) coordinate you specify and maps your coordinates to the screen coordinates
    (*x′*, *y′*) using the following formulas:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机图形系统支持任意坐标系，图形硬件通常包括对其的支持。*变换* 会应用到您指定的每个 (*x*, *y*) 坐标，并通过以下公式将您的坐标映射到屏幕坐标
    (*x′*, *y′*)：
- en: '*x*′ = *Ax* + *By* + *C*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*′ = *Ax* + *By* + *C*'
- en: '*y*′ = *Dx* + *Ey* + *F*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*′ = *Dx* + *Ey* + *F*'
- en: The *C* and *F* terms provide *translation*, which means they move things around.
    The *A* and *E* terms provide *scaling*, which means they make things bigger and
    smaller. The *B* and *D* terms provide *rotation*, which means they change the
    orientation. These are often represented in matrix form.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*和*F*项提供*平移*，这意味着它们移动事物的位置。*A*和*E*项提供*缩放*，这意味着它们让事物变大或变小。*B*和*D*项提供*旋转*，这意味着它们改变方向。这些通常以矩阵形式表示。'
- en: For now, we just care about translation and scaling to convert the canvas coordinate
    system into a familiar one. We translate downward by the height of the canvas
    on line 13 and then flip the direction of the y-axis on line 14\. The order matters;
    if we did these translations in the reverse order, the origin would be above the
    canvas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只关心平移和缩放，以将画布坐标系统转换为一个熟悉的坐标系统。我们在第13行通过画布的高度向下平移，然后在第14行翻转y轴的方向。顺序很重要；如果我们反过来执行这些平移，原点将位于画布的上方。
- en: Graphics are effectively created from blobs of primary colors plopped on a piece
    of graph paper (see “[Representing Colors](ch01.xhtml#ch01lev1sec12)” on [page
    27](ch01.xhtml#page_27)). But how fine a piece of graph paper do we need? And
    how much control do we need over the color blob composition?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图形实际上是通过将基本颜色的斑点放置在一张图表纸上来创建的（参见 “[表示颜色](ch01.xhtml#ch01lev1sec12)” 第27页）。那么，我们需要多精细的图表纸？我们对颜色斑点的组成需要多少控制？
- en: The `width` and `height` attributes on line 19 set the size of the `canvas`
    in pixels (see “[Digital Images](ch06.xhtml#ch06lev2sec17)” on [page 173](ch06.xhtml#page_173)).
    The *resolution* of the display is the number of pixels per inch (or per centimeter).
    The size of the canvas on your screen depends on the resolution of your screen.
    Unless it’s a real antique, you probably can’t see the individual pixels. (Note
    that the resolution of the human eye isn’t a constant across the field of vision;
    see “A Photon Accurate Model of the Human Eye,” Michael Deering, SIGGRAPH 2005.)
    Even though current UHD monitors are awesome, techniques such as supersampling
    are still needed to make things look really good.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第19行中的`width`和`height`属性设置`canvas`的像素大小（参见 “[数字图像](ch06.xhtml#ch06lev2sec17)”
    第173页）。显示器的*分辨率*是每英寸（或每厘米）的像素数量。屏幕上的画布大小取决于屏幕的分辨率。除非它是一个真正的古董，否则你可能看不见单个像素。（请注意，人眼的分辨率在视野范围内并不是恒定的；参见《人眼的光子精确模型》，Michael
    Deering，SIGGRAPH 2005。）即使是当前的超高清显示器也很棒，但仍然需要像超采样这样的技术，才能让画面看起来真的很棒。
- en: We’ll start by drawing things at a very low resolution so we can see the details.
    Let’s make some graph paper by adding a JavaScript function that clears the canvas
    and draws a grid, as shown in [Listing 11-4](ch11.xhtml#ch11list04). We’ll also
    use a scaling transformation to get integer value grid intersections. The scale
    applies to everything drawn on the canvas, so we have to make the line width smaller.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在非常低的分辨率下绘制图形开始，这样我们就能看到细节。我们通过添加一个JavaScript函数来清除画布并绘制网格，来制作一些图表纸，如[清单
    11-4](ch11.xhtml#ch11list04)所示。我们还将使用缩放变换来获得整数值的网格交点。缩放应用于画布上的所有绘制内容，因此我们必须将线条宽度调整得更小。
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-4: Drawing a grid*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4：绘制网格*'
- en: '***Straight Lines***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***直线***'
- en: Now let’s draw a couple of lines by placing colored circles on the grid in [Listing
    11-5](ch11.xhtml#ch11list05). One line is horizontal, and the other has a slope
    of 45 degrees. The diagonal line blobs are slightly bigger so we can see both
    lines at the point where they intersect.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在[清单 11-5](ch11.xhtml#ch11list05)中的网格上放置彩色圆圈来绘制几条线。一条线是水平的，另一条线的斜率是45度。对角线的斑点稍微大一点，这样我们就能看到它们相交的点。
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-5: Horizontal and diagonal lines*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：水平和对角线*'
- en: As you can see in [Figure 11-10](ch11.xhtml#ch11fig10) and by running the program,
    the pixels are farther apart on the diagonal line than they are on the horizontal
    line (![Image](../images/eq293-01.jpg) farther apart, according to Pythagoras).
    Why does this matter? Because both lines have the same number of pixels emitting
    light, but when the pixels are farther apart on the diagonal line, the light density
    is less, making it appear dimmer than the horizontal line. There’s not much you
    can do about it; designers of displays adjust the shape of the pixels to minimize
    this effect. It’s more of an issue on cheaper displays than on desktop monitors
    and phones.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 11-10](ch11.xhtml#ch11fig10)中看到的，或者通过运行程序，你会发现对角线上的像素比水平线上的像素更远（![图片](../images/eq293-01.jpg)，根据毕达哥拉斯定理更远）。这有什么影响呢？因为这两条线的像素数相同，都会发出光线，但当对角线上的像素更分散时，光的密度会较低，使其看起来比水平线暗。对此你几乎无能为力；显示器设计者会调整像素的形状以尽量减少这种效果。对于便宜的显示器来说，这个问题更为明显，而在桌面显示器和手机上相对较少。
- en: '![Image](../images/11fig10.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig10.jpg)'
- en: '*Figure 11-10: Pixel spacing*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：像素间距*'
- en: The horizontal, vertical, and diagonal lines are the easy cases. How do we decide
    what pixels to illuminate for other lines? Let’s make a line-drawing program.
    We’ll start by adding some controls after the `canvas` element in the `body`,
    as shown in [Listing 11-6](ch11.xhtml#ch11list06).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 水平线、垂直线和对角线是简单的情况。我们怎么决定为其他线条照亮哪些像素呢？让我们写一个绘制线条的程序。我们将从在 `body` 中的 `canvas`
    元素后添加一些控件开始，如[列表 11-6](ch11.xhtml#ch11list06)所示。
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-6: Basic line-drawing program body*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：基本的绘制线条程序主体*'
- en: Then, in [Listing 11-7](ch11.xhtml#ch11list07), we’ll replace the code from
    [Listing 11-5](ch11.xhtml#ch11list05) with event handlers for the `draw` and `erase`
    buttons. The `draw` function uses the dreaded *y* = *mx* + *b*, with *b* always
    being 0 in our case. Surprise! Some stuff from math is actually used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在[列表 11-7](ch11.xhtml#ch11list07)中，我们将用 `draw` 和 `erase` 按钮的事件处理程序替换[列表 11-5](ch11.xhtml#ch11list05)中的代码。`draw`
    函数使用的是那个让人头疼的 *y* = *mx* + *b*，在我们的例子中，*b* 总是 0。惊讶吧！一些数学知识实际上被应用了。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-7: Floating-point line-drawing and erase functions*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-7：浮点线条绘制与擦除函数*'
- en: Let’s try this with a y-coordinate of 15\. The result should look like [Figure
    11-11](ch11.xhtml#ch11fig11).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试 y 坐标为 15 的情况。结果应该类似于[图 11-11](ch11.xhtml#ch11fig11)。
- en: '![Image](../images/11fig11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig11.jpg)'
- en: '*Figure 11-11: Line drawn using floating-point arithmetic*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：使用浮点运算绘制的线条*'
- en: This looks pretty bad, but if you stand way back, it looks like a line. It’s
    as close as we can get. This is not just a computer graphics problem, as anyone
    who does cross-stitching can tell you.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来相当糟糕，但如果你站得远一点看，它看起来就像一条线。这是我们能做到的最接近的效果。这不仅仅是一个计算机图形学问题，任何做十字绣的人都会告诉你这一点。
- en: Although the program we just wrote works fine, it’s not very efficient. It’s
    performing floating-point multiplication and rounding at every point. That’s at
    least an order of magnitude slower than integer arithmetic, even on modern machines.
    We do get some performance from computing the slope once in advance (line 15).
    It’s a loop invariant, so there’s a good chance that an optimizer (see “[Optimization](ch08.xhtml#ch08lev1sec10)”
    on [page 234](ch08.xhtml#page_234)) would do this for you automatically.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚写的程序运行得很好，但它的效率并不高。它在每一个点上都在进行浮点乘法和舍入运算。即使在现代计算机上，这比整数运算慢了至少一个数量级。我们确实从提前计算一次斜率（第15行）中获得了一些性能提升。它是一个循环不变式，因此优化器（参见“[优化](ch08.xhtml#ch08lev1sec10)”在[第234页](ch08.xhtml#page_234)）很有可能会自动为你处理这一点。
- en: Way back in 1962, when floating-point was cost-prohibitive, Jack Bresenham at
    IBM came up with a clever way to draw lines without using floating-point arithmetic.
    Bresenham brought his innovation to the IBM patent office, which didn’t see the
    value in it and declined to pursue a patent. Good thing, since it turned out to
    be a fundamental computer graphics algorithm, and the lack of a patent meant that
    everybody could use it. Bresenham recognized that the line-drawing problem could
    be approached incrementally. Because we’re calculating `y` at each successive
    `x`, we can just add the slope (line 9 in [Listing 11-8](ch11.xhtml#ch11list08))
    each time through, which eliminates the multiplication. That’s not something an
    optimizer is likely to catch; it’s essentially a complex strength-reduction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 早在1962年，当浮点运算成本过高时，IBM的Jack Bresenham想出了一个巧妙的方法，通过不使用浮点运算来绘制直线。Bresenham将他的创新带到了IBM专利局，但专利局并未看出其价值，拒绝了申请专利的请求。幸运的是，后来这被证明是一个基础的计算机图形学算法，而没有专利意味着每个人都可以使用它。Bresenham意识到，绘制直线问题可以通过逐步逼近来解决。因为我们在每个连续的`x`值上计算`y`，我们只需每次加上斜率（在[Listing
    11-8](ch11.xhtml#ch11list08)中的第9行），这样就消除了乘法运算。这种优化器不太可能察觉，它本质上是一个复杂的强度减少。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-8: Incrementally calculating y*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-8: 逐步计算y*'
- en: We need floating-point arithmetic because the slope ![Image](../images/eq295-01.jpg)
    is a fraction. But the division can be replaced with addition and subtraction.
    We can have a *decision variable* `d` and add Δ*y* on each iteration. The `y`
    value is incremented whenever `d` ≥ Δ*x*, and then we subtract Δ*x* from `d`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要浮点运算，因为斜率![Image](../images/eq295-01.jpg)是一个分数。但除法可以通过加法和减法来代替。我们可以有一个*决策变量*`d`，并在每次迭代中加上Δ*y*。每当`d`
    ≥ Δ*x*时，`y`值会增加，然后我们从`d`中减去Δ*x*。
- en: 'There is one last issue: rounding. We want to choose points in the middle of
    pixels, not at the bottom of them. That’s easy to handle by setting the initial
    value of `d` to ½*m* instead of 0\. But we don’t want to introduce a fraction.
    No problem: we’ll just get rid of the ½ by multiplying it and everything else
    by 2 using 2Δ*y* and 2Δ*x* instead.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是：四舍五入。我们希望选择像素中间的点，而不是像素底部的点。这可以通过将`d`的初始值设置为½*m*而不是0来轻松处理。但我们不想引入分数。没问题：我们只需通过将其及其他内容乘以2，使用2Δ*y*和2Δ*x*来去掉½。
- en: Replace the code that draws the dots on the grid with [Listing 11-9](ch11.xhtml#ch11list09)’s
    “integer-only” version (we have no control over whether JavaScript uses integers
    internally, unlike in a language like C). Note that this code works only for lines
    with slopes in the range of 0 to 1\. I’ll leave making it work for all slopes
    as an exercise for you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将绘制网格上点的代码替换为[Listing 11-9](ch11.xhtml#ch11list09)的“仅限整数”版本（我们无法控制JavaScript是否在内部使用整数，这与像C这样的语言不同）。请注意，这段代码仅适用于斜率在0到1之间的直线。如何让它适用于所有斜率，作为一个练习留给你自己去完成。
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-9: Integer line drawing*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-9: 整数线条绘制*'
- en: One interesting question that arises from [Listing 11-9](ch11.xhtml#ch11list09)
    is, why isn’t the decision arithmetic written as shown in [Listing 11-10](ch11.xhtml#ch11list10)?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从[Listing 11-9](ch11.xhtml#ch11list09)中引出的一个有趣问题是，为什么决策算术不按[Listing 11-10](ch11.xhtml#ch11list10)中显示的那样编写？
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-10: Alternate decision code*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-10: 替代决策代码*'
- en: At first glance, this approach seems better because there’s only one addition
    to the decision variable per iteration. [Listing 11-11](ch11.xhtml#ch11list11)
    shows how this might appear in some hypothetical assembly language such as the
    one from [Chapter 4](ch04.xhtml#ch04).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，这种方法似乎更好，因为每次迭代只对决策变量进行一次加法操作。[Listing 11-11](ch11.xhtml#ch11list11)显示了这在某些假设的汇编语言中可能的表现，类似于[第4章](ch04.xhtml#ch04)中的语言。
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-11: Alternate decision code assembly language*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-11: 替代决策代码汇编语言*'
- en: Notice that the alternate version is one instruction longer than the original.
    And in most machines, integer addition takes the same amount of time as a branch.
    Thus, the code we thought would be better is actually one instruction time slower
    whenever we need to increment `y`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，替代版本比原始版本多了一条指令。而在大多数计算机中，整数加法所需的时间与分支操作相同。因此，我们原本认为更好的代码实际上在每次需要增加`y`时，反而多了一条指令的时间。
- en: The technique used in Bresenham’s line algorithm can be applied to a large variety
    of other problems. For example, you can produce a smoothly changing color *gradient*,
    such as that shown in [Figure 11-12](ch11.xhtml#ch11fig12), by replacing `y` with
    a color value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Bresenham 线算法中使用的技术可以应用于许多其他问题。例如，您可以通过将 `y` 替换为颜色值，生成平滑变化的颜色 *渐变*，如 [图 11-12](ch11.xhtml#ch11fig12)
    所示。
- en: '![Image](../images/11fig12.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig12.jpg)'
- en: '*Figure 11-12: Color gradient*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12: 颜色渐变*'
- en: The gradient in [Figure 11-12](ch11.xhtml#ch11fig12) was generated using the
    code shown in [Listing 11-12](ch11.xhtml#ch11list12) in the document ready function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-12](ch11.xhtml#ch11fig12) 中的渐变是使用文档中 [列表 11-12](ch11.xhtml#ch11list12)
    所示的代码在文档准备函数中生成的。'
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-12: Color gradient code*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-12: 颜色渐变代码*'
- en: '***Curves Ahead***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***前方曲线***'
- en: 'Integer methods aren’t limited to straight lines. Let’s draw an ellipse. We’ll
    stick to the simple case of ellipses whose axes are aligned with the coordinate
    axes and whose center is at the origin. They’re defined by the following equation,
    where *a* is one-half the width and *b* is one-half the height:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 整数方法不限于直线。让我们画一个椭圆。我们将坚持使用简单情况，即椭圆的轴与坐标轴对齐且中心位于原点。它们由以下方程定义，其中 *a* 是宽度的一半，*b*
    是高度的一半：
- en: '![Image](../images/eq298-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq298-01.jpg)'
- en: Assuming that we’re at the solid black point in [Figure 11-13](ch11.xhtml#ch11fig13),
    we need to decide which of the three possible next points is closest to the ideal
    ellipse.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们位于 [图 11-13](ch11.xhtml#ch11fig13) 中的实心黑点，我们需要决定下一个三个可能点中，哪个点最接近理想的椭圆。
- en: '![Image](../images/11fig13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig13.jpg)'
- en: '*Figure 11-13: Ellipse decision points*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-13: 椭圆决策点*'
- en: Defining *A* = *b*² and *B* = *a*², we can rearrange the ellipse equation as
    *Ax*² + *By*² – *AB* = 0\. We won’t be able to satisfy this equation most of the
    time because the points we need to draw on the integer grid aren’t likely to be
    the same as those on the ideal ellipse. When we’re at (*x*, *y*), we want to choose
    our next point to be the one in which *Ax*² + *By*² – *AB* is closest to 0\. And
    we’d like to be able to do it without the seven multiplications in that equation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *A* = *b*² 和 *B* = *a*²，我们可以将椭圆方程重新排列为 *Ax*² + *By*² – *AB* = 0。我们大多数时候无法满足这个方程，因为我们需要绘制的点不太可能与理想椭圆上的点相同。当我们处于
    (*x*, *y*) 时，我们希望选择下一个点，使得 *Ax*² + *By*² – *AB* 最接近 0。我们希望能够做到这一点，而不需要方程中的七次乘法运算。
- en: Our approach is to calculate the value of the equation at each of the three
    possible points and then choose the point where the equation value is closest
    to 0\. In other words, we’ll calculate a distance variable *d* at each of the
    three points using *d* = *Ax*² + *By*² – *AB*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法是计算三个可能点上方程的值，然后选择方程值最接近 0 的点。换句话说，我们将使用 *d* = *Ax*² + *By*² – *AB* 计算每个点的距离变量
    *d*。
- en: 'Let’s start by figuring out how to calculate *d* at the point (*x* + 1, *y*)
    without the multiplications. We can plug (*x* + 1) into the equation for *x*,
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先弄清楚如何在没有乘法的情况下计算 (*x* + 1, *y*) 处的 *d*。我们可以将 (*x* + 1) 代入 *x* 的方程，如下所示：
- en: '*d*[*x*+1] = *A*(*x* + 1)² + *By*² – *AB*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*d*[*x*+1] = *A*(*x* + 1)² + *By*² – *AB*'
- en: 'Of course, squaring something is just multiplying it by itself:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，平方某个数就是将它乘以自身：
- en: '*d*[*x*+1] = *A*(*x* + 1)(*x* + 1) + *By*² – *AB*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*d*[*x*+1] = *A*(*x* + 1)(*x* + 1) + *By*² – *AB*'
- en: 'Multiplying it all out, we get:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将其展开，我们得到：
- en: '*d*[*x*+1] = *x*² + 2*Ax* + *A* + *By*² – *AB*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*d*[*x*+1] = *x*² + 2*Ax* + *A* + *By*² – *AB*'
- en: 'Now, if we subtract that from the original equation, we see that the difference
    between the equation at *x* and *x* + 1 is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将其从原始方程中减去，我们可以看到方程在 *x* 和 *x* + 1 之间的差异为：
- en: '*dx* = 2*Ax* + *A*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*dx* = 2*Ax* + *A*'
- en: 'We can add *dx* to *d* to get *d[x]* [+ 1]. That doesn’t quite get us where
    we want to be, though, because there’s still a multiplication. So let’s evaluate
    *dx* at *x* + 1:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 *dx* 加到 *d* 上，得到 *d[x]* [+ 1]。但这还不能完全解决问题，因为仍然存在乘法运算。所以让我们在 *x* + 1 处评估
    *dx*：
- en: '*dx*[*x*+1] = 2*A*(*x* + 1) + *A*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*dx*[*x*+1] = 2*A*(*x* + 1) + *A*'
- en: '*dx*[*x*+1] = 2*Ax* + 2*A* + *A*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*dx*[*x*+1] = 2*Ax* + 2*A* + *A*'
- en: 'Just like before, subtraction gives us:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，减法给我们带来：
- en: '*d*2*x* = 2*A*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*d*2*x* = 2*A*'
- en: 'This yields a constant, which makes it easy to calculate *d* at (*x* + 1, *y*)
    without multiplication by using the intermediates *dx* and *d*2*x*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这会得到一个常数，使得可以在不进行乘法运算的情况下，使用中间变量 *dx* 和 *d*2*x* 计算 (*x* + 1, *y*) 处的 *d*：
- en: 2*A*[*x*+1] = 2*Ax* + *d*2*x*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 2*A*[*x*+1] = 2*Ax* + *d*2*x*
- en: 'That gets us the horizontal direction—the vertical is almost identical, except
    there’s a sign difference since we’re going in the –*y* direction:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们水平方向——垂直方向几乎是相同的，唯一的不同是符号，因为我们是在 -*y* 方向上：
- en: '*dy* = –2*By* + *B*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*dy* = –2*By* + *B*'
- en: '*d*2*y* = 2*B*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*d*2*y* = 2*B*'
- en: Now that we have all these terms, deciding which of the three points is closest
    to the ideal curve is simple. We calculate the horizontal difference *dh* to point
    (*x* + 1, *y*), the vertical difference *dv* to the point (*x*, *y* – 1), and
    the diagonal difference *dd* to the point (*x* + 1, *y* – 1) and choose the smallest.
    Note that although *dx* is always positive, *dv* and *dd* can be negative, so
    we need to take their absolute value before comparing, as shown in [Figure 11-14](ch11.xhtml#ch11fig14).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些术语，决定哪一个点最接近理想曲线变得简单了。我们计算到点 (*x* + 1, *y*) 的水平方向差 *dh*，到点 (*x*, *y*
    – 1) 的垂直方向差 *dv*，以及到点 (*x* + 1, *y* – 1) 的对角线差 *dd*，然后选择最小的一个。请注意，虽然 *dx* 总是正数，*dv*
    和 *dd* 可能是负数，所以我们需要取它们的绝对值再进行比较，如 [图 11-14](ch11.xhtml#ch11fig14) 所示。
- en: 'Our ellipse-drawing algorithm draws the ellipse only in the first quadrant.
    That’s okay because there’s another trick that we can use: symmetry. We know that
    each quadrant of the ellipse looks the same as the first; it’s just flipped horizontally,
    vertically, or both. We could draw the whole ellipse by drawing (–*x*, *y*), (–*x*,
    –*y*), and (*x*, –*y*) in addition to drawing (*x*, *y*). Note that we could use
    eight-way symmetry if we were drawing circles.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的椭圆绘制算法只在第一象限绘制椭圆。这没关系，因为我们还可以使用另一个技巧：对称性。我们知道椭圆的每个象限看起来都和第一个一样，只是水平、垂直或两者都翻转。我们可以通过绘制
    (–*x*, *y*)、(–*x*, –*y*) 和 (*x*, –*y*) 来绘制整个椭圆，除此之外还绘制 (*x*, *y*)。请注意，如果我们绘制的是圆形，我们可以使用八向对称性。
- en: '![Image](../images/11fig14.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig14.jpg)'
- en: '*Figure 11-14: Ellipse-drawing algorithm*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-14：椭圆绘制算法*'
- en: This algorithm includes some comparisons that could be simplified, which result
    from drawing one-quarter of the ellipse. The one-quarter ellipse could be partitioned
    into two sections at the point where the slope of the curve is 1\. By doing so,
    we’d have one piece of code that only had to decide between horizontal and diagonal
    movements and another that had to decide between vertical and diagonal movements.
    Which one got executed first would depend on the values of *a* and *b*. But a
    lot more time is spent inside the loop making decisions than in the setup, so
    it’s a good trade-off.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法包括一些可以简化的比较，这些比较源于绘制椭圆的四分之一部分。四分之一椭圆可以在曲线斜率为 1 的点处划分为两部分。通过这种方法，我们将有一段代码只需要在水平方向和对角线方向之间做出选择，另一段则需要在垂直方向和对角线方向之间做出选择。哪个先执行取决于
    *a* 和 *b* 的值。但更多的时间是在循环中做决策，而不是在设置时，因此这是一个不错的折衷方案。
- en: 'The preceding algorithm has one serious deficiency: because it starts from
    the half-width (*a*) and half-height (*b*), it can draw only ellipses that are
    odd numbers of pixels in width and height, since the result is 2*a* wide and 2*b*
    high plus 1 for the axes.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的算法有一个严重的缺陷：因为它是从半宽度 (*a*) 和半高度 (*b*) 开始的，所以它只能绘制宽度和高度是奇数像素的椭圆，因为结果是 2*a*
    宽，2*b* 高，再加 1 用于轴。
- en: '***Polynomials***'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多项式***'
- en: The method we used to draw ellipses by incrementally calculating differences
    doesn’t scale well beyond conic sections (squared things). That’s because higher-order
    equations can do strange things, such as change direction several times within
    the space of a single pixel—which is pretty hard to test for efficiently.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来绘制椭圆的通过增量计算差异的方法，在圆锥曲线（平方类的东西）之外不太适用。因为高阶方程会做出奇怪的事情，例如在单个像素的空间内多次改变方向——这是很难高效检测的。
- en: 'But incrementally calculating differences can be generalized to any polynomials
    of the form *y* = *Ax*⁰ + *Bx*¹ + *Cx*² + . . . *Dx^n*. All we have to do is generate
    *n* sets of differences so that we start our accumulated additions with a constant.
    This works because, unlike with the ellipse-drawing code, the polynomials have
    only a single independent variable. You may remember Charles Babbage’s difference
    engine from “[The Case for Digital Computers](ch02.xhtml#ch02lev1sec1)” on [page
    34](ch02.xhtml#page_34). It was designed to do just this: evaluate equations using
    incremental differences.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但逐步计算差分可以推广到任何形式的多项式，如*y* = *Ax*⁰ + *Bx*¹ + *Cx*² + ... *Dx^n*。我们要做的就是生成*n*组差分，使得我们的累积加法从常数开始。这之所以有效，是因为与椭圆绘制代码不同，多项式只有一个独立变量。你可能还记得查尔斯·巴贝奇的差分引擎，它出现在《[数字计算机的案例](ch02.xhtml#ch02lev1sec1)》一章的[第34页](ch02.xhtml#page_34)中。它的设计就是为了实现这一点：使用增量差分来评估方程。
- en: '**Recursive Subdivision**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**递归细分**'
- en: We touched briefly on *recursive subdivision* back in “[Stacks](ch05.xhtml#ch05lev1sec3)”
    on [page 122](ch05.xhtml#page_122). It’s a technique with many uses. In this section,
    we’ll examine how to use it to get by with the minimum amount of work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在《[堆栈](ch05.xhtml#ch05lev1sec3)》一章的[第122页](ch05.xhtml#page_122)中简单提到过*递归细分*。这是一种用途广泛的技术。在本节中，我们将探讨如何使用它，以便在最少的工作量下实现目标。
- en: '***Spirals***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***螺旋线***'
- en: Our line-drawing code can be leveraged for more complicated curves. We can calculate
    some points and connect them together using lines.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的线条绘制代码可以用于更复杂的曲线。我们可以计算一些点并通过线条将它们连接起来。
- en: Your math class has probably covered the measurement of angles in degrees, so
    you know that there are 360 degrees in a circle. You may not be aware that there
    are other systems of measurement. A commonly used one is *radians*. There are
    2π radians in a circle. So 360 degrees is 2π radians, 180 degrees is π radians,
    90 degrees is π/2 radians, 45 degrees is π/4 radians, and so on. You need to know
    this because many trigonometric functions available in math libraries, such as
    the ones in JavaScript, expect angles in radians instead of degrees.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你们数学课可能讲过角度的度量方法，你知道一个圆有360度。你可能不知道的是，还有其他的度量系统。一种常用的系统是*弧度*。一个圆有2π弧度。因此，360度等于2π弧度，180度等于π弧度，90度等于π/2弧度，45度等于π/4弧度，依此类推。你需要了解这一点，因为许多数学库中的三角函数，比如JavaScript中的函数，期望的角度是以弧度表示的，而不是度数。
- en: 'We’ll use curves drawn in polar coordinates for our examples because they’re
    pretty. Just in case you haven’t learned this yet, *polar coordinates* use radius
    *r* and angle θ instead of *x* and *y*. Conversion to Cartesian coordinates is
    easy: *x* = *r*cosθ and *y* = *r*sinθ. Our first example draws a spiral using
    *r* = θ × 10; the point that we draw gets farther away from the center as we sweep
    through the angles. We’ll make the input in degrees because it’s not as intuitive
    for many people to think in radians. [Listing 11-13](ch11.xhtml#ch11list13) shows
    the body for the controls.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用极坐标绘制的曲线作为示例，因为它们很漂亮。以防你还没有学习过，*极坐标*使用半径*r*和角度θ，而不是*x*和*y*。转换为笛卡尔坐标很简单：*x*
    = *r*cosθ* 和 *y* = *r*sinθ*。我们的第一个示例绘制了一个螺旋线，使用*r* = θ × 10；当我们扫过角度时，绘制的点逐渐远离中心。我们将输入角度值，而不是弧度值，因为对于很多人来说，角度的概念比弧度更直观。[列表11-13](ch11.xhtml#ch11list13)显示了控件的主体部分。
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-13: Spiral body*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-13：螺旋体*'
- en: We’ll skip the grid here because we need to draw more detail. Because we’re
    doing polar coordinates, [Listing 11-14](ch11.xhtml#ch11list14) puts (0, 0) at
    the center.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里跳过了网格，因为我们需要绘制更多细节。由于我们使用的是极坐标，[列表11-14](ch11.xhtml#ch11list14)将(0, 0)设为中心。
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 11-14: Dotted spiral JavaScript*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-14：点状螺旋JavaScript*'
- en: Enter a value of 10 for degrees and click Draw. You should see something like
    [Figure 11-15](ch11.xhtml#ch11fig15).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 输入10作为角度值，然后点击“绘制”。你应该会看到类似于[图11-15](ch11.xhtml#ch11fig15)的结果。
- en: Notice that the dots get farther apart as we get farther from the origin, even
    though they overlap near the center. We could make the value of degrees small
    enough that we’d get a good-looking curve, but that means we’d have a lot of points
    that overlap, which is a lot slower, and it’s difficult to guess the value needed
    for an arbitrary function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到随着我们远离原点，点之间的间距变大，尽管它们在中心附近重叠。我们可以将角度值设得足够小，使得曲线看起来比较好看，但这意味着我们会有许多重叠的点，这会变得非常慢，而且很难为一个任意函数猜出所需的角度值。
- en: Let’s try drawing lines between the points. Swap in [Listing 11-15](ch11.xhtml#ch11list15)
    for the drawing code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在这些点之间绘制线条。将[列表11-15](ch11.xhtml#ch11list15)中的绘制代码替换进去。
- en: '![Image](../images/11fig15.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig15.jpg)'
- en: '*Figure 11-15: Dotted spiral*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-15：虚线螺旋*'
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 11-15: Spiral line JavaScript*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-15：螺旋线 JavaScript*'
- en: Enter a value of 20 for degrees and click Draw. [Figure 11-16](ch11.xhtml#ch11fig16)
    shows what you should see.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输入20作为度数值，然后点击绘制。[图 11-16](ch11.xhtml#ch11fig16)展示了你应该看到的结果。
- en: Not very pretty. Again, it looks good near the center but gets worse as we progress
    outward. We need some way to compute more points as needed—which is where our
    old friend recursive subdivision comes into play. We’re drawing lines using the
    spiral function between two angles, θ[1] and θ[2]. What we’ll do is have some
    *close enough* criterion, and if a pair of points is not close enough, we’ll halve
    the difference in the angles and try again until we do get close enough. We’ll
    use the *distance formula* ![Image](../images/eq303-01.jpg) to find the distance
    between points, as shown in [Listing 11-16](ch11.xhtml#ch11list16).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不是很美观。再次强调，它在中心附近看起来不错，但随着我们向外推进，它变得越来越差。我们需要一种方法来根据需要计算更多的点——这时我们的老朋友递归细分方法派上了用场。我们使用螺旋函数在两个角度
    θ[1] 和 θ[2] 之间绘制线条。我们将设定一个*足够接近*的标准，如果一对点之间的距离不够接近，我们将把角度差一分为二并重试，直到足够接近为止。我们将使用*距离公式*
    ![Image](../images/eq303-01.jpg)来计算点之间的距离，正如[清单 11-16](ch11.xhtml#ch11list16)所示。
- en: '![Image](../images/11fig16.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig16.jpg)'
- en: '*Figure 11-16: Spiral line*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-16：螺旋线*'
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 11-16: Recursive spiral line JavaScript*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-16：递归螺旋线 JavaScript*'
- en: You’ll notice that as long as `close_enough` is small enough, the size of the
    increment in degrees doesn’t matter because the code automatically generates as
    many intermediate angles as needed. Play around with different values for `close_enough`;
    maybe add an input field so that it’s easy to do.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，只要`close_enough`足够小，增量的大小就无关紧要，因为代码会自动生成所需的所有中间角度。你可以尝试不同的`close_enough`值，也许可以添加一个输入框，让操作更方便。
- en: The determination of close enough is very important for certain applications.
    Though it’s beyond the scope of this book, think about curved objects that you’ve
    seen in movies. Shining light on them makes them look more realistic. Now imagine
    a mirrored sphere approximated by some number of flat faces just like the spiral
    was approximated by line segments. If the flat faces aren’t small enough, it turns
    into a disco ball (a set of flat surfaces approximating a sphere), which reflects
    light in a completely different manner.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 足够接近的判定对于某些应用非常重要。尽管这超出了本书的范围，但你可以想象电影中你看到的曲面物体。照射光线使它们看起来更逼真。现在，想象一个镜面球体，它由一些平面来近似，就像螺旋由线段近似一样。如果这些平面不够小，它就变成了一个迪斯科球（由一组平面表面近似的球体），它反射光线的方式完全不同。
- en: '***Constructive Geometry***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构造几何***'
- en: '[Chapter 5](ch05.xhtml#ch05) briefly mentioned quadtrees and showed how they
    could represent shapes. They’re an obvious use of recursion because they’re a
    hierarchical mechanism for dividing up space.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](ch05.xhtml#ch05)简要介绍了四叉树并展示了它们如何表示形状。它们是递归的明显应用，因为它们是分割空间的层次结构机制。'
- en: We can perform Boolean operations on quadtrees. Let’s say we want to design
    something like the engine gasket in [Figure 11-17](ch11.xhtml#ch11fig17).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对四叉树执行布尔运算。假设我们想设计类似于[图 11-17](ch11.xhtml#ch11fig17)中发动机垫圈的东西。
- en: '![Image](../images/11fig17.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig17.jpg)'
- en: '*Figure 11-17: Engine gasket*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-17：发动机垫圈*'
- en: We’ll need a data structure for a quadtree node, plus two special leaf values—one
    for 0, which we’re coloring white, and one for 1, which we’re coloring black.
    [Figure 11-18](ch11.xhtml#ch11fig18) shows a structure and the data it represents.
    Each node can reference four other nodes, which is a good use for pointers in
    languages such as C.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个四叉树节点的数据结构，并且需要两个特殊的叶子值——一个为0，表示白色，另一个为1，表示黑色。[图 11-18](ch11.xhtml#ch11fig18)展示了一个结构以及它所表示的数据。每个节点可以引用其他四个节点，这在像C这样的语言中是指针的良好应用。
- en: '![Image](../images/11fig18.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig18.jpg)'
- en: '*Figure 11-18: Quadtree node*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-18：四叉树节点*'
- en: We don’t need to keep track of the size of a node. All operations start from
    the root, the size of which is known, and each child node is one-quarter the size
    of its parent. [Figure 11-19](ch11.xhtml#ch11fig19) shows us how to get the value
    at a location in the tree.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要跟踪节点的大小。所有操作从根节点开始，根节点的大小是已知的，每个子节点的大小是其父节点的四分之一。[图 11-19](ch11.xhtml#ch11fig19)向我们展示了如何获取树中某个位置的值。
- en: '![Image](../images/11fig19.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig19.jpg)'
- en: '*Figure 11-19: Get value of (*x, y*) coordinate in quadtree*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-19：在四叉树中获取（*x, y*）坐标的值*'
- en: '[Figure 11-20](ch11.xhtml#ch11fig20) shows how we would set the value of (that
    is, make black) an (*x*, *y*) coordinate in a quadtree. Note that “done” means
    “return from the function” since it’s recursive.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-20](ch11.xhtml#ch11fig20)展示了我们如何设置四叉树中 (*x*, *y*) 坐标的值（即将其设置为黑色）。请注意，“done”意味着“从函数返回”，因为这是递归的。'
- en: '![Image](../images/11fig20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig20.jpg)'
- en: '*Figure 11-20: Set value of (*x, y*) coordinate in quadtree*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-20：设置四叉树中 (*x, y*) 坐标的值*'
- en: This is similar to the value-getting code in [Figure 11-19](ch11.xhtml#ch11fig19).
    At a high level, it descends the tree, subdividing as it goes, until it reaches
    the 1×1 square for the (*x*, *y*) coordinate and sets it to black. Any time it
    hits a white node, it replaces it with a new node having four white children so
    there’s a tree to keep descending. On the way back up, any nodes having all black
    children are replaced by a black node. This happens any time a node with three
    black children has the fourth set to black, as shown in [Figure 11-21](ch11.xhtml#ch11fig21).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[图 11-19](ch11.xhtml#ch11fig19)中的值获取代码类似。从高层次来看，它会遍历树，并在下降时进行细分，直到达到 (*x*,
    *y*) 坐标的 1×1 方块并将其设置为黑色。每当遇到白色节点时，它会用一个新的节点替换它，该节点有四个白色子节点，以便继续遍历树。在回溯时，任何所有子节点都是黑色的节点会被替换为一个黑色节点。每当一个有三个黑色子节点的节点将第四个子节点设置为黑色时，就会发生这种情况，如[图
    11-21](ch11.xhtml#ch11fig21)所示。
- en: '![Image](../images/11fig21.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig21.jpg)'
- en: '*Figure 11-21: Coalescing a node*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-21：合并节点*'
- en: Coalescing nodes not only makes the tree take less memory, but it also makes
    many operations on the tree faster because it’s not as deep.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 合并节点不仅减少了树的内存占用，还因为树的深度变浅而加快了许多操作的速度。
- en: We need a way to clear (that is, make white) the value of an (*x*, *y*) coordinate
    in a quadtree. The answer is fairly similar to the setting algorithm. The differences
    are that we partition black nodes instead of white ones and we coalesce white
    nodes instead of black ones.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来清除（即，将其设置为白色）四叉树中 (*x*, *y*) 坐标的值。答案与设置算法非常相似。不同之处在于，我们对黑色节点进行分割，而不是白色节点，并且合并的是白色节点，而不是黑色节点。
- en: We can build some more complicated drawing functions on top of our value-setting
    function. It’s easy to draw rectangles by invoking the set function for each coordinate.
    We can do the same for ellipses using the algorithm from “[Curves Ahead](ch11.xhtml#ch11lev2sec5)”
    on [page 298](ch11.xhtml#page_298) and symmetry.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在值设置函数的基础上构建一些更复杂的绘制函数。通过调用设置函数来为每个坐标绘制矩形非常容易。我们也可以利用“[曲线前行](ch11.xhtml#ch11lev2sec5)”算法和对称性，用同样的方法绘制椭圆，具体见[第298页](ch11.xhtml#page_298)。
- en: 'Now for the fun stuff. Let’s create quadtree versions for some of our Boolean
    logic functions from [Chapter 1](ch01.xhtml#ch01). The NOT function is simple:
    just descend the tree and replace any black nodes with white ones and vice versa.
    The AND and OR functions in [Figure 11-22](ch11.xhtml#ch11fig22) are more interesting.
    These algorithms aren’t designed to perform the equivalents of *C* = *a* AND *b*
    and *C* = *a* OR *b*. Instead, they implement *dst* &= *src* and *dst* |= *src*,
    as in the assignment operators found in many languages. The *dst* operand is the
    one modified.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分了。让我们为[第1章](ch01.xhtml#ch01)中的一些布尔逻辑函数创建四叉树版本。NOT 函数很简单：只需遍历树，替换任何黑色节点为白色节点，反之亦然。[图
    11-22](ch11.xhtml#ch11fig22)中的 AND 和 OR 函数则更有意思。这些算法并非用于执行 *C* = *a* AND *b* 和
    *C* = *a* OR *b* 的等价操作。相反，它们实现了 *dst* &= *src* 和 *dst* |= *src*，类似于许多语言中的赋值操作符。*dst*
    操作数是被修改的对象。
- en: '![Image](../images/11fig22.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig22.jpg)'
- en: '*Figure 11-22: Quadtree AND and OR functions*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-22：四叉树的与运算和或运算*'
- en: Now that we have all these tools, let’s build our gasket. We’ll do it at low
    resolution so the details are visible. We’ll start with an empty gasket quadtree
    on the left and a scratch quadtree in the center in which we draw a big circle.
    The scratch quadtree is OR’d with the gasket, producing the result on the right
    as shown in [Figure 11-23](ch11.xhtml#ch11fig23). Note how the coalescing keeps
    the number of subdivisions to a minimum.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些工具，来构建我们的垫片。我们将以低分辨率进行绘制，以便能够看到细节。我们从左边的一个空白垫片四叉树开始，在中央的一个临时四叉树中绘制一个大圆形。将临时四叉树与垫片进行
    OR 运算，产生右边的结果，如[图 11-23](ch11.xhtml#ch11fig23)所示。注意，合并操作使得细分的数量保持在最小值。
- en: '![Image](../images/11fig23.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig23.jpg)'
- en: '*Figure 11-23: Gasket, circle, circle OR gasket*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-23：垫片、圆形、圆形 OR 垫片*'
- en: Next we’ll make another circle in a different position and combine it with the
    partially completed gasket, as shown in [Figure 11-24](ch11.xhtml#ch11fig24).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在不同的位置制作另一个圆，并将其与部分完成的垫圈合并，如[图 11-24](ch11.xhtml#ch11fig24)所示。
- en: '![Image](../images/11fig24.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig24.jpg)'
- en: '*Figure 11-24: Adding to the gasket*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-24：添加到垫圈中*'
- en: Continuing on, we’ll make a black rectangle and combine it with the gasket,
    as shown in [Figure 11-25](ch11.xhtml#ch11fig25).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将制作一个黑色矩形，并将其与垫圈合并，如[图 11-25](ch11.xhtml#ch11fig25)所示。
- en: '![Image](../images/11fig25.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig25.jpg)'
- en: '*Figure 11-25: Adding the rectangle*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-25：添加矩形*'
- en: The next step is to make a hole. This is accomplished by making a black circle
    and then inverting it using the NOT operation to make it white. The result is
    then ANDed with the partially completed gasket, resulting in the hole as seen
    in [Figure 11-26](ch11.xhtml#ch11fig26).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是制作一个孔。通过制作一个黑色圆圈，然后使用非操作将其反转为白色，就可以完成这一操作。然后将结果与部分完成的垫圈进行与操作，最终得到[图 11-26](ch11.xhtml#ch11fig26)中看到的孔。
- en: '![Image](../images/11fig26.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig26.jpg)'
- en: '*Figure 11-26: ANDing a NOT-hole*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-26：与非操作的孔*'
- en: It’s getting boring at this point. We need to combine another hole, in the same
    way as shown in [Figure 11-26](ch11.xhtml#ch11fig26), and then eight smaller holes
    in a similar fashion. You can see the result in [Figure 11-27](ch11.xhtml#ch11fig27).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段已经有些无聊了。我们需要以与[图 11-26](ch11.xhtml#ch11fig26)中所示相同的方式合并另一个孔，然后再以类似的方式合并八个更小的孔。你可以在[图
    11-27](ch11.xhtml#ch11fig27)中看到结果。
- en: '![Image](../images/11fig27.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig27.jpg)'
- en: '*Figure 11-27: Completed gasket*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-27：完成的垫圈*'
- en: As you can see, we can use Boolean functions on quadtrees to construct objects
    with complicated shapes out of simple geometric pieces. Although we used a two-dimensional
    gasket as our example, this is more commonly done in three dimensions. Twice as
    many nodes are needed for three dimensions, so the quadtree is extended into an
    *octree*, an example of which is shown in [Figure 11-28](ch11.xhtml#ch11fig28).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以使用四叉树上的布尔函数，将简单的几何形状拼合成复杂的物体。虽然我们使用的是二维垫圈作为示例，但这种方法在三维中更为常见。三维需要的节点数是二维的两倍，因此四叉树被扩展为*八叉树*，其示例见[图
    11-28](ch11.xhtml#ch11fig28)。
- en: Building complex objects in three dimensions using the preceding techniques
    is called *constructive solid geometry*. The three-dimensional counterpart to
    a two-dimensional pixel is called a *voxel*, which sort of means “volume pixel.”
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述技术在三维空间中构建复杂物体叫做*构造实体几何*。三维中的像素对应物叫做*体素*，可以理解为“体积像素”。
- en: '![Image](../images/11fig28.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig28.jpg)'
- en: '*Figure 11-28: Octree*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-28：八叉树*'
- en: Octrees are a common storage method for CAT scan and MRI data. These machines
    generate a stack of 2D slices. It’s a simple matter to peel away layers to obtain
    cutaway views.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 八叉树是CAT扫描和MRI数据的常见存储方法。这些机器生成一系列的二维切片。分层剖析以获得切割视图是件简单的事。
- en: '***Shifting and Masking***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移位与遮罩***'
- en: One of the downsides of quadtrees is that the data is scattered around memory;
    they have terrible locality of reference. Just because two squares are next to
    each other in the tree doesn’t mean they’re anywhere near each other in memory.
    This becomes a problem when we have to convert data from one memory organization
    to another. We could always move data 1 bit at a time, but that would involve
    a large number of memory accesses—which we want to minimize, because they’re slow.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树的一个缺点是数据在内存中分散；它们的引用局部性很差。仅仅因为两个方块在树中彼此相邻，并不意味着它们在内存中也很接近。当我们需要将数据从一种内存组织转换到另一种时，这就成为了一个问题。我们当然可以每次移动1位数据，但那会涉及大量的内存访问——而我们希望最小化内存访问，因为它们的速度较慢。
- en: One task where this situation arises is displaying data. That’s because the
    display memory organization is determined by the hardware. As mentioned back in
    “[Raster Graphics](ch06.xhtml#ch06lev2sec22)” on [page 180](ch06.xhtml#page_180),
    each row of the raster is painted one at a time in a particular order. A raster
    row is called a *scan line*. The whole collection of scan lines is called a *frame
    buffer*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况出现的一个任务是显示数据。这是因为显示内存的组织由硬件决定。正如在“[光栅图形](ch06.xhtml#ch06lev2sec22)”中提到的，在[第180页](ch06.xhtml#page_180)，每一行光栅都按特定的顺序逐行绘制。一行光栅称为*扫描线*，所有扫描线的集合称为*帧缓冲区*。
- en: Let’s say we want to paint our completed gasket from [Figure 11-27](ch11.xhtml#ch11fig27)
    on a display. For simplicity, we’ll use a monochrome display that has 1 bit for
    each pixel and uses 16-bit-wide memory. That means the upper-leftmost 16 pixels
    are in the first word, the next 16 are in the second, and so on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在显示器上绘制来自[图 11-27](ch11.xhtml#ch11fig27)的完成的垫片。为了简化起见，我们将使用一个单色显示器，每个像素有
    1 位，并使用 16 位宽的内存。这意味着最左上角的 16 个像素位于第一个字中，接下来的 16 个像素位于第二个字中，以此类推。
- en: The upper-left square in [Figure 11-27](ch11.xhtml#ch11fig27) is 4×4 pixels
    in size and is white, which means we need to be clearing bits in the frame buffer.
    We’ll use the coordinates and size of the quadtree square to construct a mask,
    as shown in [Figure 11-29](ch11.xhtml#ch11fig29).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-27](ch11.xhtml#ch11fig27)中的左上方的方块是 4×4 像素大小，且为白色，这意味着我们需要清除帧缓冲区中的位。我们将使用四叉树方块的坐标和大小来构建掩码，如[图
    11-29](ch11.xhtml#ch11fig29)所示。'
- en: '![Image](../images/11fig29.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig29.jpg)'
- en: '*Figure 11-29: AND mask*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-29：AND 掩码*'
- en: 'We can then AND this mask with all the affected rows, costing only two memory
    accesses per row: one for read and one for write. We would do something similar
    to set bits in the frame buffer; the mask would have 1s in the area to set, and
    we would OR instead of AND.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这个掩码与所有受影响的行进行 AND 操作，每行仅需要两次内存访问：一次读取和一次写入。我们可以采取类似的方法来设置帧缓冲区中的位；掩码在需要设置的区域中为
    1，而我们将使用 OR 而不是 AND 操作。
- en: Another place where this comes into play is when drawing text characters. Most
    text characters are stored as *bitmaps*, two-dimensional arrays of bits, as shown
    in [Figure 11-30](ch11.xhtml#ch11fig30). Character bitmaps are packed together
    to minimize memory use. That’s how text characters used to be provided; now they
    come as geometric descriptions. But for performance reasons, they’re often converted
    into bitmaps before use, and those bitmaps are usually cached on the assumption
    that characters get reused.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用场景是绘制文本字符时。大多数文本字符以 *位图* 的形式存储，即二维位数组，如[图 11-30](ch11.xhtml#ch11fig30)所示。字符位图被打包在一起，以最小化内存使用。这就是过去文本字符的提供方式；现在它们以几何描述的形式提供。但出于性能原因，它们通常在使用前会被转换为位图，并且这些位图通常会被缓存，假设字符会被重复使用。
- en: '![Image](../images/11fig30.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig30.jpg)'
- en: '*Figure 11-30: Bitmap text characters*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-30：位图文本字符*'
- en: Let’s replace the character *B* on the display shown in [Figure 11-31](ch11.xhtml#ch11fig31)
    with a *C*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在显示器上将[图 11-31](ch11.xhtml#ch11fig31)中显示的字符 *B* 替换为 *C*。
- en: '![Image](../images/11fig31.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig31.jpg)'
- en: '*Figure 11-31: Bitmap text characters*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-31：位图文本字符*'
- en: The *C* is located in bits 10 through 14 and needs to go into bits 6 through
    10\. For each row, we need to grab the *C* and then mask off everything else in
    the word. Then we need to shift it into the destination position. The destination
    must be read and the locations that we want to overwrite masked off before combining
    with the shifted *C* and being written, as shown in [Figure 11-32](ch11.xhtml#ch11fig32).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* 位于第 10 到第 14 位之间，需要移到第 6 到第 10 位之间。对于每一行，我们需要获取 *C*，然后将字中的其他部分屏蔽掉。接着我们需要将其移到目标位置。必须读取目标数据，并在将其与移位后的
    *C* 结合并写入之前，先屏蔽掉我们希望覆盖的部分，如[图 11-32](ch11.xhtml#ch11fig32)所示。'
- en: '![Image](../images/11fig32.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig32.jpg)'
- en: '*Figure 11-32: Painting a character*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-32：绘制字符*'
- en: 'This example uses three memory accesses per row: one to fetch the source, one
    to fetch the destination, and one to write the result. Doing this bit by bit would
    take five times that amount.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子每行使用三次内存访问：一次获取源数据，一次获取目标数据，一次写入结果。如果逐位进行操作，将需要五倍的时间。
- en: Keep in mind that there are often additional complications when the source or
    destination spans word boundaries.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当源或目标跨越字边界时，通常会有额外的复杂性。
- en: '**More Math Avoidance**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更多数学避免**'
- en: We discussed some simple ways to avoid expensive math in “[Integer Methods](ch11.xhtml#ch11lev1sec2)”
    on [page 290](ch11.xhtml#page_290). Now that we have the background, let’s talk
    about a couple of more complicated math-avoidance techniques.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“[整数方法](ch11.xhtml#ch11lev1sec2)”一节中讨论了一些避免昂贵数学计算的简单方法，在[第 290 页](ch11.xhtml#page_290)中有介绍。现在我们有了背景知识，让我们讨论几种更复杂的数学避免技巧。
- en: '***Power Series Approximations***'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***幂级数近似***'
- en: 'Here’s another take on getting close enough. Let’s say we need to generate
    the sine function because we don’t have hardware that does it for us. One way
    to do this is with a *Taylor series*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一种方法来接近所需结果。假设我们需要生成正弦函数，因为我们没有为我们提供该功能的硬件。实现这种功能的一种方法是使用 *泰勒级数*：
- en: '![Image](../images/eq313-01.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq313-01.jpg)'
- en: '[Figure 11-33](ch11.xhtml#ch11fig33) shows a sine wave and the Taylor series
    approximations for different numbers of terms. As you can see, the more terms,
    the closer the result is to an ideal sine.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-33](ch11.xhtml#ch11fig33)展示了正弦波及不同项数的泰勒级数近似值。正如你所看到的，项数越多，结果越接近理想的正弦值。'
- en: '![Image](../images/11fig33.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig33.jpg)'
- en: '*Figure 11-33: Taylor series for sine*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-33：正弦的泰勒级数*'
- en: It’s a simple matter to add terms until you get the desired degree of accuracy.
    It’s also worth noting that fewer terms are needed for angles more acute than
    90 degrees, so you can be more efficient by using symmetry for other angles.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 只需不断添加项，直到达到所需的精度即可。值得注意的是，对于小于90度的角度所需的项较少，因此通过利用对称性，你可以在计算其他角度时提高效率。
- en: Note that we can reduce the number of multiplications required by initializing
    a *product* to *x*, precomputing –*x*², and multiplying the *product* by –*x*²
    to get each term. All the denominators are constants that could reside in a small
    table indexed by the exponent. Also, we don’t have to compute all of the terms.
    If we need only two digits of accuracy, we can stop when computing more terms
    doesn’t change those digits.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过将*积*初始化为*x*，预先计算–*x*²，并将*积*与–*x*²相乘以获得每一项，我们可以减少所需的乘法运算次数。所有的分母都是常数，可以存储在一个小表格中，由指数索引。此外，我们不必计算所有项。如果只需要两位数的精度，当计算更多项不再改变这些数字时，我们可以停止。
- en: '***The CORDIC Algorithm***'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***CORDIC算法***'
- en: Jack Volder at Convair invented the *Coordinate Rotation Digital Computer (CORDIC)*
    algorithm in 1956\. CORDIC was invented to replace an analog part of the B-58
    bomber navigation system with something more accurate. CORDIC can be used to generate
    trigonometric and logarithmic functions using integer arithmetic. It was used
    in the HP-35, the first portable scientific calculator, released in 1972\. It
    was also used in the Intel 80x87 family of floating-point coprocessors.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Jack Volder在Convair公司于1956年发明了*坐标旋转数字计算机（CORDIC）*算法。CORDIC的发明是为了替代B-58轰炸机导航系统中的模拟部分，以提供更高的精度。CORDIC可以利用整数运算生成三角函数和对数函数。它被用于1972年发布的第一款便携式科学计算器HP-35，也应用于Intel
    80x87系列浮点协处理器中。
- en: The basic idea of CORDIC is illustrated in [Figure 11-34](ch11.xhtml#ch11fig34).
    Because it’s a unit circle (radius of 1) the x- and y-coordinates of the arrow
    ends are the cosine and sine of the angle. We want to rotate the arrow from its
    original position along the x-axis in smaller and smaller steps until we get to
    the desired angle and then grab the coordinates.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: CORDIC的基本思想在[图11-34](ch11.xhtml#ch11fig34)中有说明。由于它是单位圆（半径为1），箭头末端的x和y坐标分别为角度的余弦和正弦。我们希望将箭头从其原始位置沿x轴旋转，通过越来越小的步长直到到达所需的角度，然后获取坐标。
- en: '![Image](../images/11fig34.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig34.jpg)'
- en: '*Figure 11-34: CORDIC algorithm overview*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-34：CORDIC算法概述*'
- en: Let’s say we want sin(57.529°). As you can see, we first try 45 degrees, which
    isn’t enough, so we take another step of 25.565 degrees, getting us to 71.565
    degrees, which is too much. We then go backward by 14.036 degrees, which gets
    us to our desired 57.529 degrees. We’re clearly performing some sort of subdivision
    but with weird values for the angles.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想求sin(57.529°)。如你所见，我们首先尝试45度，但这还不够，因此我们采取了另一步25.565度，得到71.565度，这又太大了。然后我们回退14.036度，最终得到了所需的57.529度。我们显然在进行某种细分操作，但角度的数值是有些奇怪的。
- en: 'We saw the equations for transformation earlier in “[Integer Methods](ch11.xhtml#ch11lev1sec2),”
    where we cared only about translation and scaling. The CORDIC algorithm is based
    on rotation. The following equations, the general form of which you’ve seen, show
    us how (*x*, *y*) is rotated by angle θ to get a new set of coordinates (*x′*,
    *y′*):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 “[整数方法](ch11.xhtml#ch11lev1sec2)” 中曾经看到过转换方程式，当时我们只关心平移和缩放。CORDIC算法是基于旋转的。以下方程式的通用形式已经展示过，说明了如何通过旋转角度θ将(*x*,
    *y*)旋转，从而获得一组新的坐标(*x′*, *y′*)：
- en: '*x*′ = *x* × cos(θ) – *y* × sin(θ)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*′ = *x* × cos(θ) – *y* × sin(θ)'
- en: '*y*′ = *x* × sin(θ) + *y* × cos(θ)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*′ = *x* × sin(θ) + *y* × cos(θ)'
- en: Although this is mathematically correct, it seems useless because we wouldn’t
    be discussing an algorithm that generates sines and cosines if they were already
    available.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在数学上是正确的，但看起来没什么用处，因为如果正弦和余弦已经可用，我们就不会讨论一种生成正弦和余弦的算法了。
- en: 'Let’s make it worse before making it better by rewriting the equations in terms
    of tangents using the trigonometric identity:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在改善之前使问题变得更糟，通过将方程式用正切形式重写，利用三角恒等式：
- en: '![Image](../images/eq314-01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq314-01.jpg)'
- en: 'Because we’re dividing by cos(θ), we need to multiply the result by the same:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在除以 cos(θ)，所以需要将结果乘以相同的值：
- en: '![Image](../images/eq314-02.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq314-02.jpg)'
- en: That looks pretty ugly. We’re making a bad situation worse, but that’s because
    we haven’t talked about the trick, which goes back to the weird angles. It turns
    out that tan(45°) = 1, tan(26.565°) = ½, and tan(14.036°) = ¼. That sure looks
    like some simple integer division by 2, or as Maxwell Smart might have said, “the
    old right shift trick.” It’s a binary search of the tangents of the angles.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当难看。我们正把糟糕的情况弄得更糟，但这是因为我们还没有讨论那个技巧，这个技巧回到那些奇怪的角度。事实证明，tan(45°) = 1，tan(26.565°)
    = ½，tan(14.036°) = ¼。这看起来就像是一些简单的整数除以 2，或者像 Maxell Smart 可能会说的，“老式的右移技巧”。这是对角度切线的二分查找。
- en: 'Let’s see how this plays out for the example in [Figure 11-34](ch11.xhtml#ch11fig34).
    There are three rotations that get us from the original coordinates to the final
    ones. Keep in mind that, per [Figure 11-34](ch11.xhtml#ch11fig34), *x*[0] = 1
    and *y*[0] = 0:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个在[图 11-34](ch11.xhtml#ch11fig34)中的例子是如何表现的。从原始坐标到最终坐标有三个旋转。请记住，根据[图 11-34](ch11.xhtml#ch11fig34)，*x*[0]
    = 1 且 *y*[0] = 0：
- en: '![Image](../images/eq315-01.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq315-01.jpg)'
- en: 'Note the sign change in the last set of equations that result from going the
    other (clockwise) direction; when we’re going clockwise, the sign of the tangent
    is negative. Plugging the equations for (*x*[1], *y*[1]) into the equations for
    (*x*[2], *y*[2]) and plugging that into the equations for (*x*[3], *y*[3]) and
    then factoring out the cosines (and cleaning out the multiplications by 1) gives
    us the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在最后一组方程中符号的变化，这是由于我们改变了方向（顺时针方向）。当我们顺时针旋转时，切线的符号是负的。将方程 (*x*[1], *y*[1]) 代入
    (*x*[2], *y*[2]) 的方程中，然后再代入 (*x*[3], *y*[3]) 的方程，并提取出余弦（并清除乘以 1 的部分）后，得到以下结果：
- en: '![Image](../images/eq315-02.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq315-02.jpg)'
- en: 'So what about those cosines? Skipping the mathematical proof, it turns out
    that as long as we have enough terms:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些余弦呢？略去数学证明，事实证明，只要我们有足够多的项：
- en: cos(45°) × cos(26.565°) × cos(–14.036°) × . . . = 0.607252935008881
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: cos(45°) × cos(26.565°) × cos(–14.036°) × . . . = 0.607252935008881
- en: 'That’s a constant, and we like constants. Let’s call it *C*. We could multiply
    it at the end like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常数，我们喜欢常数。我们称之为 *C*。我们可以像这样在最后进行乘法运算：
- en: '![Image](../images/eq316-01.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq316-01.jpg)'
- en: 'But we could save that multiplication by just using the constant for *x*[0],
    as shown next. We’ll also eliminate *y*[0], since it’s 0\. It ends up looking
    like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以通过直接使用常数 *x*[0] 来避免那次乘法，如下所示。我们还将去掉 *y*[0]，因为它是 0。最终结果如下所示：
- en: '![Image](../images/eq316-02.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/eq316-02.jpg)'
- en: If you check, you’ll discover that the values for *x*[3] and *y*[3] are pretty
    close to the values of the cosine and sine of 57.529 degrees. And that’s with
    only three terms; more terms gets us closer. Notice that this is all accomplished
    with addition, subtraction, and division by 2.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查一下，你会发现 *x*[3] 和 *y*[3] 的值非常接近 57.529 度的余弦和正弦值。而这仅仅用了三项；更多的项会让结果更接近。请注意，这一切都通过加法、减法和除以
    2 完成。
- en: Let’s turn this into a program that gives us a chance to introduce several additional
    tricks. First, we’ll use a slightly different version of CORDIC called *vectoring
    mode*; so far, we’ve been discussing *rotation mode* because it’s a little easier
    to understand. We’ve seen that in rotation mode we start with a vector (arrow)
    along the x-axis and rotate it until it’s at the desired angle. Vectoring mode
    is sort of the opposite; we start at our desired angle and rotate it until we
    end up with a vector along the x-axis (angle of 0). Doing it this way means we
    can just test the sign of the angle to determine the direction of rotation for
    a step; it saves a comparison between two numbers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个转换为一个程序，这样我们就有机会介绍一些额外的技巧。首先，我们将使用一个略微不同版本的 CORDIC，称为 *矢量模式*；到目前为止，我们讨论的都是
    *旋转模式*，因为它稍微容易理解一些。我们已经看到，在旋转模式中，我们从沿 x 轴的一个向量（箭头）开始，旋转它直到达到所需的角度。矢量模式几乎是相反的；我们从目标角度开始，旋转它直到我们得到一个沿
    x 轴的向量（角度为 0）。这样做的好处是，我们可以直接通过测试角度的符号来确定旋转的方向，从而省去了两个数值的比较。
- en: Second, we’re going to use table lookup. We’ll precompute a table of angles
    with tangents of 1, ½, ¼, and so on. We only need to do this once. The final algorithm
    is shown in [Figure 11-35](ch11.xhtml#ch11fig35).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将使用查表法。我们将预先计算出一个角度表，包含了 1、½、¼ 等的切线值。我们只需要做这一步一次。最终的算法见[图 11-35](ch11.xhtml#ch11fig35)。
- en: '![Image](../images/11fig35.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig35.jpg)'
- en: '*Figure 11-35: CORDIC flowchart*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-35：CORDIC 流程图*'
- en: Now let’s write a C program that implements this algorithm using even more tricks.
    First, we’re going to express our angles in radians instead of in degrees.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个 C 程序，使用更多的技巧来实现这个算法。首先，我们将角度表示为弧度，而不是度数。
- en: The second trick is related to the first. You may have noticed that we haven’t
    encountered any numbers greater than 1\. We can design our program to work in
    the first quadrant (between 0 and 90 degrees) and get the others using symmetry.
    An angle of 90 degrees is π/2, which is ≈ 1.57\. Because we don’t have a wide
    range of numbers, we can use a fixed-point integer system instead of floating-point.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个技巧与第一个有关。你可能已经注意到，我们没有遇到任何大于 1 的数字。我们可以将程序设计为仅在第一象限（0 到 90 度之间）工作，然后通过对称性得到其他象限的结果。90
    度的角度是 π/2，约等于 1.57。由于我们没有很宽的数字范围，我们可以使用定点整数系统，而不是浮点数。
- en: We’re going to base our sample implementation on 32-bit integers. Because we
    need a range of ≈ ±1.6, we can make bit 30 be the ones, bit 29 the halves, bit
    28 the quarters, bit 27 the eighths, and so on. We’ll use the MSB (bit 31) as
    the sign bit. We can convert floating-point numbers (as long as they’re in range)
    to our fixed-point notation by multiplying by our version of 1, which is 0x40000000,
    and casting (converting) that into integers. Likewise, we can convert our results
    into floating-point by casting them as such and dividing by 0x40000000.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于 32 位整数来实现示例。因为我们需要大约 ±1.6 的范围，我们可以让第 30 位表示 1，第 29 位表示 0.5，第 28 位表示 0.25，第
    27 位表示 0.125，以此类推。我们将使用 MSB（第 31 位）作为符号位。我们可以通过将浮点数（只要它们在范围内）乘以我们版本的 1（即 0x40000000）并将其转换为整数，从而将浮点数转换为定点表示。同样，我们可以通过将结果强制转换为浮点数并除以
    0x40000000 来将其转换回浮点数。
- en: '[Listing 11-17](ch11.xhtml#ch11list17) shows the code, which is quite simple.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-17](ch11.xhtml#ch11list17)展示了代码，它相当简单。'
- en: '[PRE16]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-17: CORDIC implementation in C*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-17：CORDIC 在 C 中的实现*'
- en: 'Implementing CORDIC uses many of the goodies in our growing bag of tricks:
    recursive subdivision, precomputation, table lookup, shifting for power-of-two
    division, integer fixed-point arithmetic, and symmetry.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 CORDIC 使用了我们不断增长的技巧包中的许多好东西：递归细分、预计算、表查找、用于二的幂次除法的位移、整数定点运算和对称性。
- en: '**Somewhat Random Things**'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一些随机的东西**'
- en: It’s very difficult to do completely random things on computers because they
    have to generate random numbers based on some formula, and that makes it repeatable.
    That kind of “random” is good enough for most computing tasks though, except for
    cryptography, which we’ll discuss in [Chapter 13](ch13.xhtml#ch13). In this section,
    we’ll explore some approximations based on *pseudorandomness*. We’re choosing
    visual examples because they’re interesting and printable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上做完全随机的事情非常困难，因为它们必须根据某个公式生成随机数，这使得它是可重复的。然而，这种“随机性”对大多数计算任务来说已经足够了，除了加密学，我们将在
    [第 13 章](ch13.xhtml#ch13) 中讨论。在本节中，我们将探索一些基于 *伪随机性* 的近似方法。我们选择视觉示例是因为它们既有趣又便于打印。
- en: '***Space-Filling Curves***'
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***填充空间曲线***'
- en: Italian mathematician Giuseppe Peano (1858–1932) came up with the first example
    of a *space-filling curve* in 1890\. Three iterations of it are shown in [Figure
    11-36](ch11.xhtml#ch11fig36).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利数学家朱塞佩·皮亚诺（Giuseppe Peano，1858–1932）在 1890 年提出了第一个 *填充空间曲线* 的例子。它的三次迭代如 [图
    11-36](ch11.xhtml#ch11fig36) 所示。
- en: '![Image](../images/11fig36.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig36.jpg)'
- en: '*Figure 11-36: Peano curve*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-36：皮亚诺曲线*'
- en: As you can see, the curve is a simple shape that is shrunk and repeated at different
    orientations. Each time that’s done, it fills more of the space.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，曲线是一个简单的形状，经过缩放和在不同方向上的重复。每次这样做时，它会填充更多的空间。
- en: Space-filling curves exhibit *self-similarity*, which means they look about
    the same both up close and far away. They’re a subset of something called *fractals*,
    which were popularized when Benoit Mandelbrot (1924–2010) published *The Fractal
    Geometry of Nature* (W. H. Freeman and Company, 1977). Many natural phenomena
    are self-similar; for example, a coastline has the same jaggedness when observed
    from a satellite and from a microscope.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 填充空间曲线表现出 *自相似性*，这意味着它们无论是近距离还是远距离看起来差不多。它们是 *分形* 的一个子集，分形在 Benoit Mandelbrot（1924–2010）出版《自然的分形几何学》（W.
    H. Freeman and Company，1977）一书后变得广为人知。许多自然现象是自相似的；例如，海岸线无论从卫星上观察还是用显微镜观察，其锯齿状都很相似。
- en: The term *fractal* comes from *fraction*. Geometry includes numerous integer
    relationships. For example, doubling the length of the sides of a square quadruples
    its area. But an integer change in lengths in a fractal can change the area by
    a fractional amount, hence the name.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*分形*这个词源自*分数*。几何学中包括许多整数关系。例如，正方形边长的两倍会使其面积增加四倍。但是，在分形中，边长的整数变化可能会使面积发生分数变化，因此得名。'
- en: The Koch snowflake is an easy-to-generate curve first described in 1904 by Swedish
    mathematician Helge von Koch (1870–1924). It starts with an equilateral triangle.
    Each side is divided into thirds, and the center third is replaced by a triangle
    one-third of the size, with the edge in line with the original side omitted, as
    shown in [Figure 11-37](ch11.xhtml#ch11fig37).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Koch雪花是一个易于生成的曲线，最早由瑞典数学家赫尔格·冯·科赫（Helge von Koch，1870–1924）于1904年描述。它以一个等边三角形开始，每条边被分成三等份，中间的三分之一被一个三角形替代，三角形的大小是原三角形的三分之一，边与原始边对齐，缺失的边被省略，如[图11-37](ch11.xhtml#ch11fig37)所示。
- en: '![Image](../images/11fig37.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig37.jpg)'
- en: '*Figure 11-37: Four iterations of the Koch snowflake*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-37：Koch雪花的四次迭代*'
- en: 'You can see that complex and interesting shapes can be generated with a tiny
    amount of code and recursion. Let’s look at slightly more complex example: the
    Hilbert curve, first described in 1891 by German mathematician David Hilbert (1862–1943),
    as shown in [Figure 11-38](ch11.xhtml#ch11fig38).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，复杂有趣的形状可以通过极少的代码和递归生成。让我们来看一个稍微复杂一点的例子：Hilbert曲线，最早由德国数学家大卫·希尔伯特（David
    Hilbert，1862–1943）于1891年描述，如[图11-38](ch11.xhtml#ch11fig38)所示。
- en: '![Image](../images/11fig38.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig38.jpg)'
- en: '*Figure 11-38: Four iterations of the Hilbert curve*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-38：Hilbert曲线的四次迭代*'
- en: The rules for the next iteration of the Hilbert curve are more complicated than
    for the Koch snowflake, because we don’t do the same thing everywhere. There are
    four different orientations of the “cup” shape that are replaced by smaller versions,
    as shown in [Figure 11-39](ch11.xhtml#ch11fig39). There’s both a graphical representation
    and one using letters for right, up, left, and down. For each iteration, each
    corner of the shape on the left is replaced with the four shapes on the right
    (in order) at one-quarter the size of the shape on the left and then connected
    by straight lines.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Hilbert曲线的下一次迭代规则比Koch雪花更复杂，因为我们并不是在每个地方做相同的事情。这里有四个不同方向的“杯”形状，它们会被较小版本所替代，如[图11-39](ch11.xhtml#ch11fig39)所示。有一个图形表示法，还有一个使用字母表示右、上、左、下的表示法。每次迭代时，左边形状的每个角都会被右边的四个形状（按顺序）替换，大小为左边形状的四分之一，并通过直线连接。
- en: '![Image](../images/11fig39.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig39.jpg)'
- en: '*Figure 11-39: Hilbert curve rules*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-39：Hilbert曲线规则*'
- en: '***L-Systems***'
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***L系统***'
- en: The rules in [Figure 11-39](ch11.xhtml#ch11fig39) are similar to the regular
    expressions we saw back in “[Regular Expressions](ch08.xhtml#ch08lev2sec2)” on
    [page 224](ch08.xhtml#page_224), but backward. Instead of defining what patterns
    are matched, these rules define what patterns can be produced. They’re called
    *L-systems* or *Lindenmayer systems*, after Hungarian botanist Aristid Lindenmayer
    (1925–1989), who developed them in 1968\. Because they define what can be produced,
    they’re also called *production grammars*.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-39](ch11.xhtml#ch11fig39)中的规则类似于我们在《[正则表达式](ch08.xhtml#ch08lev2sec2)》第224页中看到的正则表达式，但方向相反。这些规则不是定义匹配哪些模式，而是定义可以生成哪些模式。它们被称为*L系统*或*林登梅耶系统*，得名于匈牙利植物学家阿里斯蒂德·林登梅耶（Aristid
    Lindenmayer，1925–1989），他在1968年开发了这些系统。由于它们定义了可以生成的内容，它们也被称为*生成文法*。'
- en: You can see from [Figure 11-39](ch11.xhtml#ch11fig39) that replacing an *R*
    with the sequence *U R R U* transforms the leftmost curve in [Figure 11-38](ch11.xhtml#ch11fig38)
    into the one next to it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图11-39](ch11.xhtml#ch11fig39)中可以看到，将*R*替换为序列*U R R U*会将[图11-38](ch11.xhtml#ch11fig38)中最左边的曲线转换为其旁边的曲线。
- en: The nice thing about production grammars is that they’re compact and easy to
    both specify and implement. They can be used to model a lot of phenomena. This
    became quite the rage when Alvy Ray Smith at Lucasfilm published “Plants, Fractals,
    and Formal Languages” (SIGGRAPH, 1984); you couldn’t go outside without bumping
    into L-System-generated shrubbery. Lindenmayer’s work became the basis for much
    of the computer graphics now seen in movies.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 关于生成文法的一个好处是它们既简洁又易于指定和实现。它们可以用来建模许多现象。当阿尔维·雷·史密斯（Alvy Ray Smith）在卢卡斯影业发布《植物、分形与形式语言》（SIGGRAPH，1984）时，这一方法变得非常流行；你走到哪里都能碰到由L系统生成的灌木丛。林登梅耶的工作成为了如今许多电影中计算机图形的基础。
- en: Let’s make some trees so this book will be carbon-neutral. We have four symbols
    in our grammar, as shown in [Listing 11-18](ch11.xhtml#ch11list18).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些树木，这样这本书就可以实现碳中和。我们的语法中有四个符号，如[清单 11-18](ch11.xhtml#ch11list18)所示。
- en: '[PRE17]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 11-18: Symbols for tree grammar*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-18：树语法的符号*'
- en: In [Listing 11-19](ch11.xhtml#ch11list19), we create a grammar that contains
    two rules.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 11-19](ch11.xhtml#ch11list19)中，我们创建了一个包含两个规则的语法。
- en: '[PRE18]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 11-19: Tree grammar rules*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-19：树语法规则*'
- en: You can think of the symbols and rules as a genetic code. [Figure 11-40](ch11.xhtml#ch11fig40)
    shows several iterations of the grammar starting from *E*. Note that we’re not
    bothering to draw leaves on the ends of the branches. Also, beyond the first three,
    the set of symbols that define the tree are too long to show.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将符号和规则看作是一种遗传代码。[图 11-40](ch11.xhtml#ch11fig40)展示了从*E*开始的语法的多个迭代。请注意，我们没有在分支的末端画出叶子。此外，除了前三个外，定义树的符号集太长，无法展示。
- en: '![Image](../images/11fig40.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig40.jpg)'
- en: '*Figure 11-40: Simple L-system tree*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-40：简单的 L 系统树*'
- en: As you can see, we get pretty good-looking trees without much work. L-systems
    are a great way to generate natural-looking objects.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只需要稍微做些工作就能得到相当漂亮的树。L 系统是生成自然外观物体的一个极好方法。
- en: Production grammars have been used to generate objects since long before computers.
    Knitting instructions are production grammars, for example, as shown in [Listing
    11-20](ch11.xhtml#ch11list20).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 生产语法在计算机出现之前就已经被用来生成物体了。例如，编织说明就是一种生产语法，如[清单 11-20](ch11.xhtml#ch11list20)所示。
- en: '[PRE19]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 11-20: Production grammar for scarf in [Figure 11-41](ch11.xhtml#ch11fig41)*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-20：围巾的生产语法，[图 11-41](ch11.xhtml#ch11fig41)所示*'
- en: Executing the grammar in [Listing 11-20](ch11.xhtml#ch11list20) using the knitting
    needle I/O device for some number of sections yields a scarf, as shown in [Figure
    11-41](ch11.xhtml#ch11fig41).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[清单 11-20](ch11.xhtml#ch11list20)中的语法并通过编织针I/O设备执行若干部分后，得到一条围巾，如[图 11-41](ch11.xhtml#ch11fig41)所示。
- en: '![Image](../images/11fig41.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig41.jpg)'
- en: '*Figure 11-41: Scarf produced by production grammar*'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-41：由生产语法生成的围巾*'
- en: '***Going Stochastic***'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***走向随机化***'
- en: '*Stochastic* is a good word to use when you want to sound sophisticated and
    *random* just won’t do. Alan Fournier and Don Fussell at the University of Texas
    at Dallas introduced the notion of adding randomness to computer graphics in 1980\.
    A certain amount of randomness adds variety. For example, [Figure 11-42](ch11.xhtml#ch11fig42)
    shows a stochastic modification of the L-system trees from the last section.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机*是一个很好的词，当你想显得复杂而*随机*的感觉不足以表达时可以使用。1980年，德克萨斯大学达拉斯分校的Alan Fournier和Don Fussell提出了将随机性引入计算机图形学的概念。适量的随机性增加了多样性。例如，[图
    11-42](ch11.xhtml#ch11fig42)展示了上一节中L系统树的随机修改。'
- en: '![Image](../images/11fig42.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig42.jpg)'
- en: '*Figure 11-42: Stochastic L-system trees*'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-42：随机 L 系统树*'
- en: As you can see, it generates a nice set of similar-looking trees. A forest looks
    more realistic when the trees aren’t all identical.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它生成了一组看起来相似的树。森林看起来更逼真当树木不完全相同时。
- en: Loren Carpenter at Boeing published a paper that pioneered a simple way to generate
    fractals (“Computer Rendering of Fractal Curves and Surfaces,” SIGGRAPH, 1980).
    At SIGGRAPH 1983, Carpenter and Mandelbrot engaged in a very heated discussion
    about whether Carpenter’s results were actually fractals.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Loren Carpenter 在波音公司发布了一篇论文，开创了一种生成分形的简单方法（《分形曲线与表面的计算机渲染》，SIGGRAPH，1980）。在
    SIGGRAPH 1983 上，Carpenter 和 Mandelbrot 就 Carpenter 的结果是否真的是分形展开了一场激烈的讨论。
- en: 'Carpenter left Boeing and continued his work at Lucasfilm. His fractal mountains
    produced the planet in *Star Trek II: The Wrath of Khan*. An interesting factoid
    is that the planet took about six months of computer time to generate. Because
    it was generated using random numbers, Spock’s coffin ended up flying through
    the side of the mountain for several frames. Artists had to manually cut a notch
    in the mountain to fix this.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Carpenter 离开了波音公司，继续在卢卡斯影业工作。他的分形山脉为《星际迷航 II：可汗的愤怒》中的行星提供了素材。一个有趣的事实是，这个行星的生成花费了大约六个月的计算机时间。由于它是使用随机数生成的，斯波克的棺材最终在几帧中飞过山的一侧。艺术家们不得不手动在山脉中切割一个缺口来修复这个问题。
- en: Carpenter’s technique was simple. He randomly selected a point on a line and
    then moved that point a random amount. He recursively repeated this for the two
    line segments until things were close enough. It’s a bit like adding randomness
    to the Koch curve generator. [Figure 11-43](ch11.xhtml#ch11fig43) shows a few
    random peaks.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Carpenter的方法很简单。他随机选择了一条线上的一点，然后将该点随机移动一定的距离。然后他递归地重复这个过程，直到两段线段足够接近。这有点像给Koch曲线生成器添加随机性。[图
    11-43](ch11.xhtml#ch11fig43)展示了几个随机的峰值。
- en: '![Image](../images/11fig43.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig43.jpg)'
- en: '*Figure 11-43: Fractal mountains*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-43: 分形山脉*'
- en: Once again, pretty good for not much work.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 再次来看，做得不错，几乎没有多少工作。
- en: '***Quantization***'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***量化***'
- en: Sometimes we don’t have a choice about approximating and must do the best we
    can. For example, we may have a color photograph that needs to be printed in a
    black-and-white newspaper. Let’s look at how we might make this transformation.
    We’ll use the grayscale image in [Figure 11-44](ch11.xhtml#ch11fig44), since this
    book isn’t printed in color. Because it’s grayscale, each of the three color components
    is identical and in the range of 0 to 255.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们没有选择，只能尽最大努力进行近似。例如，我们可能有一张需要在黑白报纸上打印的彩色照片。让我们看看如何进行这种转换。我们将使用[图 11-44](ch11.xhtml#ch11fig44)中的灰度图像，因为本书并不是彩色印刷的。由于是灰度图像，每个颜色组件都是相同的，且范围在0到255之间。
- en: '![Image](../images/11fig44-2.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig44-2.jpg)'
- en: '*Figure 11-44: Tony Cat*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-44: 托尼猫*'
- en: We need to perform a process called *quantization*, which means taking the colors
    that we have available in the original image and assigning them to colors in the
    transformed image. It’s yet another sampling problem, as we have to take an analog
    (or *more* analog, in our case) signal and divide it among a fixed set of buckets.
    How do we map 256 values into 2?
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行一个叫做*量化*的过程，这意味着将原始图像中可用的颜色映射到变换后的图像中的颜色。这又是一个采样问题，因为我们必须将一个模拟信号（或者在我们这里说是*更*模拟的信号）分配到一组固定的桶中。我们该如何将256个值映射到2个值呢？
- en: Let’s start with a simple approach called *thresholding*. As you might guess
    from the name, we pick a threshold and assign anything brighter than that to white,
    and anything darker to black. [Listing 11-21](ch11.xhtml#ch11list21) makes anything
    greater than 127 white, and anything not white is black.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一种简单的方法开始，叫做*阈值处理*。正如你从名字中可以猜到的那样，我们选择一个阈值，并将所有比这个阈值亮的部分设为白色，所有比这个阈值暗的部分设为黑色。[列表
    11-21](ch11.xhtml#ch11list21)将大于127的部分设为白色，其他部分设为黑色。
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 11-21: Threshold pseudocode*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-21: 阈值伪代码*'
- en: Running this pseudocode on the image in [Figure 11-44](ch11.xhtml#ch11fig44)
    produces the image in [Figure 11-45](ch11.xhtml#ch11fig45).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-44](ch11.xhtml#ch11fig44)上的图像上运行这个伪代码，得到了[图 11-45](ch11.xhtml#ch11fig45)中的图像。
- en: '![Image](../images/11fig45-2.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig45-2.jpg)'
- en: '*Figure 11-45: Threshold algorithm*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-45: 阈值算法*'
- en: That doesn’t look very good. But there’s not a lot we can do; we could monkey
    around with the threshold, but that would just give us different bad results.
    We’ll try to get better results using optical illusions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不太好。但我们没什么能做的；我们可以调试阈值，但那只会给我们不同的糟糕结果。我们会尝试使用光学错觉来获得更好的效果。
- en: British scientist Henry Talbot (1800–1877) invented *halftone printing* in the
    1850s for just this reason; photography at the time was grayscale, and printing
    was black and white. Halftone printing broke the image up into dots of varying
    sizes, as shown in the magnified image on the left in [Figure 11-46](ch11.xhtml#ch11fig46).
    As you can see on the right, your eye interprets this as shades of gray.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 英国科学家亨利·塔尔博特（1800–1877）在1850年代发明了*半色调印刷*，正是为了解决这个问题；当时的摄影是灰度的，而印刷是黑白的。半色调印刷将图像分解为不同大小的点，如[图
    11-46](ch11.xhtml#ch11fig46)中左侧放大的图像所示。正如你在右侧看到的那样，你的眼睛将其解读为灰度。
- en: '![Image](../images/11fig46.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig46.jpg)'
- en: '*Figure 11-46: Halftone pattern*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-46: 半色调图案*'
- en: We can’t vary the dot size on a computer screen, but we want the same type of
    effect. Let’s explore some different ways to accomplish this. We can’t change
    the characteristics of a single dot that can be either black or white, so we need
    to adjust the surrounding dots somehow to come up with something that your eye
    will see as shades of gray. We’re effectively trading off image resolution for
    the perception of more shades or colors.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在计算机屏幕上改变点的大小，但我们希望获得相同类型的效果。让我们探索一些不同的方法来实现这一目标。我们不能改变单个点的特性，单个点只能是黑色或白色，因此我们需要以某种方式调整周围的点，以呈现出你的眼睛会看到的灰度效果。我们实际上是在用图像分辨率换取更多的阴影或颜色感知。
- en: The name for this process is *dithering*, and it has an amusing origin going
    back once again to World War II analog computers. Someone noticed that the computers
    worked better aboard flying airplanes than on the ground. It turns out that the
    random vibration from the plane engines kept the gears, wheels, cogs, and such
    from sticking. Vibrating motors were subsequently added to the computers on the
    ground to make them work better by trembling them. This random vibration was called
    *dither*, based on the Middle English verb *didderen*, meaning “to tremble.” There
    are many dithering algorithms; we’ll examine only a few here.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的名称叫做*抖动*，它有一个有趣的来源，追溯到二战时期的模拟计算机。有人注意到，这些计算机在飞行中的表现比在地面上更好。原来，飞机引擎的随机振动防止了齿轮、轮子、齿轮和类似物品的卡住。于是，振动马达被添加到地面上的计算机中，通过抖动来改善性能。这种随机振动被称为*dither*，源自中古英语动词*didderen*，意思是“颤抖”。有许多抖动算法；我们这里只讨论其中几个。
- en: The basic idea is to use a pattern of different thresholds for different pixels.
    In the mid-1970s, American scientist Bryce Bayer (1929–2012) at Eastman Kodak
    invented a key technology for digital cameras, the eponymous *Bayer filter*. The
    *Bayer matrix* is a variation that we can use for our purposes. Some examples
    are shown in [Figure 11-47](ch11.xhtml#ch11fig47).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思路是对不同像素使用不同阈值的模式。1970年代中期，美国科学家布莱斯·贝尔（Bryce Bayer，1929–2012）在伊士曼柯达公司发明了一项关键技术——数字相机的同名*贝尔滤镜*。*贝尔矩阵*是一个变体，我们可以用来实现这一目的。[图
    11-47](ch11.xhtml#ch11fig47)展示了一些示例。
- en: '![Image](../images/11fig47.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig47.jpg)'
- en: '*Figure 11-47: Bayer matrices*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-47: 贝尔矩阵*'
- en: These matrices are *tiled* over the image, meaning they repeat in both the x
    and y directions, as shown in [Figure 11-48](ch11.xhtml#ch11fig48). Dithering
    using tiled patterns is called *ordered dithering*, as there’s a predictable pattern
    based on position in the image.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵是*平铺*在图像上的，意味着它们在x和y方向上都重复，如[图 11-48](ch11.xhtml#ch11fig48)所示。使用平铺模式的抖动称为*有序抖动*，因为它基于图像中的位置有一个可预测的模式。
- en: '![Image](../images/11fig48.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig48.jpg)'
- en: '*Figure 11-48: 2×2 Bayer matrix tiling pattern*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-48: 2×2 Bayer矩阵平铺模式*'
- en: '[Listing 11-22](ch11.xhtml#ch11list22) shows the pseudocode for the Bayer matrices
    from [Figure 11-47](ch11.xhtml#ch11fig47).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-22](ch11.xhtml#ch11list22)展示了[图 11-47](ch11.xhtml#ch11fig47)中的贝尔矩阵的伪代码。'
- en: '[PRE21]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 11-22: Bayer ordered dithering pseudocode*'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-22: 贝尔有序抖动伪代码*'
- en: 'On to the important question: what does Tony Cat think of this? [Figures 11-49](ch11.xhtml#ch11fig49)
    through [11-51](ch11.xhtml#ch11fig51) show him dithered using the three matrices
    just shown.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个重要问题：Tony Cat对此怎么看？[图 11-49](ch11.xhtml#ch11fig49)到[图 11-51](ch11.xhtml#ch11fig51)显示了他使用刚才展示的三种矩阵抖动的效果。
- en: '![Image](../images/11fig49-2.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig49-2.jpg)'
- en: '*Figure 11-49: Tony dithered using the 2×2 Bayer matrix*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-49: Tony使用2×2 Bayer矩阵抖动*'
- en: '![Image](../images/11fig50-2.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig50-2.jpg)'
- en: '*Figure 11-50: Tony dithered using the 3×3 Bayer matrix*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-50: Tony使用3×3 Bayer矩阵抖动*'
- en: '![Image](../images/11fig51-2.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig51-2.jpg)'
- en: '*Figure 11-51: Tony dithered using the 4×4 Bayer matrix*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-51: Tony使用4×4 Bayer矩阵抖动*'
- en: As you can see, these are somewhat acceptable if you squint, and they improve
    with larger matrices. Not exactly the cat’s meow, but a lot better than thresholding.
    Doing more work by using larger matrices yields better results. But the tiling
    pattern shows through. Plus it can produce really trippy artifacts called *moiré*
    patterns for certain images. You might have seen these if you’ve ever grabbed
    a stack of window screens.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些如果你眯着眼看是可以接受的，随着矩阵的增大，它们会变得更好。虽然不完全是完美的效果，但比阈值处理好得多。通过使用更大的矩阵做更多的工作可以获得更好的结果。但是，平铺模式仍然可见。而且，它可能会在某些图像上产生称为*莫尔条纹*的奇异伪影。如果你曾经拿过一堆窗纱，可能见过这些效果。
- en: How can we eliminate some of these screening artifacts? Instead of using a pattern,
    let’s just compare each pixel to a random number using the pseudocode in [Listing
    11-23](ch11.xhtml#ch11list23). The result is shown in [Figure 11-52](ch11.xhtml#ch11fig52).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何消除一些这些筛选伪影呢？不使用模式，我们可以将每个像素与一个随机数进行比较，使用[清单 11-23](ch11.xhtml#ch11list23)中的伪代码。结果如[图
    11-52](ch11.xhtml#ch11fig52)所示。
- en: '[PRE22]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 11-23: Random-number dithering pseudocode*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-23: 随机数抖动伪代码*'
- en: '![Image](../images/11fig52-2.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig52-2.jpg)'
- en: '*Figure 11-52: Tony dithered using random numbers*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-52: Tony使用随机数抖动*'
- en: This eliminates the patterning artifacts but is pretty fuzzy, which is not unusual
    for cats. It’s not as good as the ordered dither.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了图案伪影，但效果相当模糊，对于猫咪来说这并不算异常。这不如有序抖动效果好。
- en: The fundamental problem behind all these approaches is that we can only do so
    much making decisions on a pixel-by-pixel basis. Think about the difference between
    the original pixel values and the processed ones. There’s a certain amount of
    *error* for any pixel that wasn’t black or white in the original. Instead of discarding
    this error as we’ve done so far, let’s try spreading it around to other pixels
    in the neighborhood.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法背后的根本问题是，我们在逐像素的基础上做决策只能做这么多。想想原始像素值和处理后像素值之间的区别。对于任何在原始图像中不是黑色或白色的像素，都有一定量的*误差*。我们不再像以前那样丢弃这些误差，而是尝试将其扩散到周围的其他像素。
- en: Let’s start with something really simple. We’ll take the error for the current
    pixel and apply it to the next horizontal pixel. The pseudocode is in [Listing
    11-24](ch11.xhtml#ch11list24), and the result is shown in [Figure 11-53](ch11.xhtml#ch11fig53).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始。我们将当前像素的误差应用到下一个水平像素。伪代码见[列表 11-24](ch11.xhtml#ch11list24)，结果如[图
    11-53](ch11.xhtml#ch11fig53)所示。
- en: '[PRE23]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 11-24: One-dimensional error propagation pseudocode*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-24：一维误差传播伪代码*'
- en: '![Image](../images/11fig53-2.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig53-2.jpg)'
- en: '*Figure 11-53: Tony dithered using one-dimensional error propagation*'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-53：Tony使用一维误差传播进行抖动*'
- en: Not great, but not horrible—easily beats thresholding and random numbers and
    is somewhat comparable to the 2×2 matrix; they each have different types of artifacts.
    If you think about it, you’ll realize that error propagation is the same decision
    variable trick that we used earlier for drawing lines and curves.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然效果不是很好，但也不算糟糕——比阈值化和随机数方法好得多，并且在某种程度上与2×2矩阵的效果相当；它们各自有不同类型的伪影。如果仔细想想，你会发现误差传播其实就是我们早些时候用来绘制线条和曲线的决策变量技巧。
- en: American computer scientists Robert Floyd (1936–2001) and Louis Steinberg came
    up with an approach in the mid-1970s that you can think of as a cross between
    this error propagation and a Bayer matrix. The idea is to spread the error from
    a pixel to some surrounding pixels using a set of weights, as shown in [Figure
    11-54](ch11.xhtml#ch11fig54).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 美国计算机科学家罗伯特·弗洛伊德（1936–2001）和路易斯·斯坦伯格在1970年代中期提出了一种方法，你可以把它看作是误差传播与Bayer矩阵的结合体。这个思路是通过一组权重将像素的误差传播到周围的像素，如[图
    11-54](ch11.xhtml#ch11fig54)所示。
- en: '![Image](../images/11fig54.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig54.jpg)'
- en: '*Figure 11-54: Floyd-Steinberg error distribution weights*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-54：Floyd-Steinberg误差分布权重*'
- en: '[Listing 11-25](ch11.xhtml#ch11list25) shows the Floyd-Steinberg pseudocode.
    Note that we have to keep two rows’ worth of error values. We make each of those
    rows 2 longer than needed and offset the index by 1 so that we don’t have to worry
    about running off the end when handling the first or last columns.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-25](ch11.xhtml#ch11list25)展示了Floyd-Steinberg伪代码。注意，我们必须保留两行的误差值。我们将每一行做得比需要的长2个单位，并将索引偏移1，这样在处理第一列或最后一列时，我们就不必担心越界。'
- en: '[PRE24]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 11-25: Floyd-Steinberg error propagation code*'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-25：Floyd-Steinberg误差传播代码*'
- en: This is a lot more work, but the results, as shown in [Figure 11-55](ch11.xhtml#ch11fig55),
    look pretty good. (Note that this is unrelated to the Pink Floyd–Steinberg algorithm
    that was used to make album covers in the 1970s.)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这要做的工作多得多，但结果，如[图 11-55](ch11.xhtml#ch11fig55)所示，看起来相当不错。（请注意，这与20世纪70年代用于制作专辑封面的Pink
    Floyd–Steinberg算法无关。）
- en: '![Image](../images/11fig55-2.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/11fig55-2.jpg)'
- en: '*Figure 11-55: Tony dithered using the Floyd-Steinberg algorithm*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-55：Tony使用Floyd-Steinberg算法进行抖动*'
- en: Post–Floyd-Steinberg, numerous other distribution schemes have been proposed,
    most of which do more work and distribute the error among more neighboring pixels.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在Floyd-Steinberg之后，提出了许多其他的分布方案，其中大多数做了更多的工作，并将误差分配到更多的相邻像素。
- en: Let’s try one more approach, this one published by Dutch software engineer Thiadmer
    Riemersma in 1998\. His algorithm does several interesting things. First, it goes
    back to the approach of affecting only one adjacent pixel. But it keeps track
    of 16 pixels’ worth of error. It calculates a weighted average so that the most
    recently visited pixel has more effect than the least recently visited one. [Figure
    11-56](ch11.xhtml#ch11fig56) shows the weighting curve.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一种方法，这种方法由荷兰软件工程师Thiadmer Riemersma于1998年发布。他的算法做了几件有趣的事情。首先，它回到了只影响一个相邻像素的方法。但它会跟踪16个像素的误差。它计算加权平均值，使得最近访问的像素比最久未访问的像素有更大的影响。[图
    11-56](ch11.xhtml#ch11fig56)展示了加权曲线。
- en: '![Image](../images/11fig56.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig56.jpg)'
- en: '*Figure 11-56: Riemersma pixel weights*'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-56: Riemersma像素权重*'
- en: The Riemersma algorithm doesn’t use the typical adjacent pixels grid that we’ve
    seen before (see [Listing 11-26](ch11.xhtml#ch11list26)). Instead, it follows
    the path of a Hilbert curve, which we saw in [Figure 11-38](ch11.xhtml#ch11fig38).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Riemersma算法没有使用我们之前见过的典型相邻像素网格（见[清单 11-26](ch11.xhtml#ch11list26)）。相反，它沿着Hilbert曲线的路径前进，这在[图
    11-38](ch11.xhtml#ch11fig38)中展示过。
- en: '[PRE25]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 11-26: Riemersma error propagation pseudocode*'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-26: Riemersma误差传播伪代码*'
- en: The result is shown in [Figure 11-57](ch11.xhtml#ch11fig57). Still not purr-fect,
    but at this point we’ve seen enough cats. Try the example code on a gradient such
    as the one in [Figure 11-12](ch11.xhtml#ch11fig12). You’ve learned that there
    are many different ways to deal with approximation required by real-life circumstances.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如[图 11-57](ch11.xhtml#ch11fig57)所示。虽然仍然不是完美无缺，但在这一点上，我们已经看到了足够多的“猫”。你可以尝试在类似[图
    11-12](ch11.xhtml#ch11fig12)中的渐变上运行示例代码。你已经了解到，在现实生活的情况下，需要采用多种不同的方式来处理近似问题。
- en: '![Image](../images/11fig57-2.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/11fig57-2.jpg)'
- en: '*Figure 11-57: Tony dithered using the Riemersma algorithm*'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-57: Tony使用Riemersma算法进行抖动*'
- en: '**Summary**'
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we’ve examined a number of tricks you can use to increase performance
    and efficiency by avoiding or minimizing computation. As Jim Blinn, one of the
    giants in the field of computer graphics, said, “A technique is just a trick that
    you use more than once.” And just as you saw with hardware building blocks, these
    tricks can be combined to solve complex problems.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考察了许多可以用来提高性能和效率的技巧，方法是避免或最小化计算。正如计算机图形学领域的巨头Jim Blinn所说：“一种技巧只是你多次使用的窍门。”就像你在硬件构建模块中看到的那样，这些技巧可以结合起来解决复杂问题。
