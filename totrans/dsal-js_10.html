<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">8</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">SHUFFLING AND SAMPLING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Consider this chapter to be a complement of the two previous chapters, but instead of sorting values into some kind of order, you want to shuffle them into a random, disordered sequence (as for a card game). And rather than select a value at a given position, you want to choose a set of values randomly (as for statistical sampling algorithms). <span class="chapterintro_Xref"><a href="chapter6.xhtml">Chapters 6</a></span> and <span class="chapterintro_Xref"><a href="chapter7.xhtml">7</a></span> revolved around order and consistency, but this chapter works with disorder and randomness instead.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_138" aria-label="138"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-37"/><span class="SANS_Futura_Std_Bold_B_11">Choosing Numbers Randomly</span></h3>&#13;
<p class="TNI1">First, consider a basic function that you’ll need to use throughout this chapter: generating a random number in a given interval. JavaScript already provides <span class="SANS_TheSansMonoCd_W5Regular_11">Math.random()</span>, which produces a pseudorandom number <i>r</i> such that 0 ≤ <i>r</i> &lt; 1. (For more information, see <i><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random.">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random</a>.</i>) The distribution of the numbers this function produces is <i>uniform</i>, which means that each value is equally possible, and no value is more likely than another.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Why is it pseudorandom? The random numbers are actually produced by an algorithm in such a way that the properties of the generated sequence are approximately that of a sequence of truly random numbers. However, the fact that the numbers are generated by a procedure automatically means that they aren’t truly random; they just look like they are. For the sake of simplicity, though, in this chapter we’ll consider the produced numbers to be random.</i></p>&#13;
<p class="TX">Using this function, you can scale its results to produce numbers in any given range. The following functions will come in handy for the rest of the chapter:</p>&#13;
<pre id="pre-114"><code>const randomBit = () =&gt; Math.random() &gt;= 0.5;&#13;
const randomNum = (a, b) =&gt; a + (b - a) * Math.random();&#13;
const randomInt = (a, b) =&gt; Math.floor(randomNum(a, b));</code></pre>&#13;
<p class="TX">The first function is useful when you want to decide between two alternatives randomly, as if simulating a coin toss. If a random number is less than 0.5 (0 to 0.4999 ...), you return <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> (heads), and you return <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> (tails) otherwise (0.5 to 0.9999 ...). Given a range of values from <i>a</i> to <i>b</i> (not necessarily integers, but <i>a</i> &lt; <i>b</i>), the second function produces a random floating-point number <i>r</i> such that <i>a</i> &lt; <i>r</i> &lt; <i>b</i>. This is easily verified by noting that <span class="SANS_TheSansMonoCd_W5Regular_11">(b - a)*Math.random()</span> is greater than or equal to zero but strictly less than <span class="SANS_TheSansMonoCd_W5Regular_11">(b - a)</span>. The last function is meant to be called with integer arguments, and it produces a random integer <i>r</i> such that <i>a</i> &lt; <i>r</i> &lt; <i>b</i>. You can also write it as follows:</p>&#13;
<pre id="pre-115"><code>const randomInt = (a, b) =&gt; a + Math.floor((b - a) * Math.random());</code></pre>&#13;
<p class="TX">Some people have difficulty with <span class="SANS_TheSansMonoCd_W5Regular_11">randomInt(...)</span>. For instance, to simulate rolling a die, they might write <span class="SANS_TheSansMonoCd_W5Regular_11">randomInt(1,6)</span>, but that won’t work: <span class="SANS_TheSansMonoCd_W5Regular_11">randomInt(1,7)</span> does the job. (See question 8.2 for another take on this.) You could obviously rewrite <span class="SANS_TheSansMonoCd_W5Regular_11">randomInt(...)</span> to do it another way, but you’re following JavaScript’s lead as in the <span class="SANS_TheSansMonoCd_W5Regular_11">array.slice(start,end)</span> method, whose parameters work exactly as these do, taking elements from <span class="SANS_TheSansMonoCd_W5Regular_11">start</span> up to (but not including) <span class="SANS_TheSansMonoCd_W5Regular_11">end</span>.</p>&#13;
<p class="TX">With these basic tools, let’s turn to the problems of shuffling and sampling, both of which will be based on random numbers in one way or another.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>&#13;
<h3 class="H1" id="sec2"><span id="h1-38"/><span class="SANS_Futura_Std_Bold_B_11">Shuffling</span></h3>&#13;
<p class="TNI1">The first problem we’ll consider is <i>shuffling</i> an array of values in order to produce a random sequence of values—or to use a mathematical term, a permutation. This is equivalent to shuffling a deck of cards before playing a game to start anew with a different sequence of cards every time.</p>&#13;
<p class="TX">An important requisite is that every possible permutation should be equally likely, which presents a thorny problem: How can you make sure that the shuffling code ran correctly? For instance, when sorting an array, you can check that the sorted array is actually in order and that its elements are the same before and after sorting. Similarly, for selection algorithms, you can check that it worked by sorting the array separately and then checking whether the selected value is correct. Shuffling is harder to check.</p>&#13;
<p class="TX">First, you should prove (somehow) that the logic is correct so that all results are equally probable. However, what if you implement the algorithm badly, with some bug? (Don’t ask me how I know.) An empirical suggestion is to run the algorithm many times with a known input sequence and test statistically whether the observed outcomes suggest a uniform distribution; we’ll leave the mathematical aspects of this solution to the textbooks and instead try an easier way (see question 8.1).</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-67"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Shuffling by Sorting</span></h4>&#13;
<p class="TNI1">We’ll start with a sorting-based algorithm. It doesn’t have the best performance, but it’s the simplest implementation. In order to shuffle a set of values, you associate a random number with each value, sort the set on that random value, and the result will be a totally random shuffle (see <a href="chapter8.xhtml#fig8-1">Figure 8-1</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-1" src="../images/Figure8-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-1: Sorting an array by a randomly assigned key produces a totally random shuffle.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can implement this solution with any of the algorithms discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. Let’s go the simplest possible direction and use JavaScript’s own <span class="SANS_TheSansMonoCd_W5Regular_11">.sort(...)</span> method. The shuffle code ends up being a single line, even though more lines are used here to show it clearly:</p>&#13;
<pre id="pre-116"><code>const sortingShuffle = (arr) =&gt;&#13;
  arr&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> .map((v) =&gt; ({val: v, key: Math.random()}))&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .sort((a, b) =&gt; a.key – b.key)&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> .map((o) =&gt; o.val);</code></pre>&#13;
<p class="TX">The code directly matches the steps in <a href="chapter8.xhtml#fig8-1">Figure 8-1</a>. Given the array of values, create a new array where objects have the original value in <span class="SANS_TheSansMonoCd_W5Regular_11">val</span> and a random value in <span class="SANS_TheSansMonoCd_W5Regular_11">key</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then sort it by this random key <span class="CodeAnnotation" aria-label="annotation2">❷</span> and produce a new array with only the values <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">This algorithm is probably the shortest one in the book, and it produces a shuffled list of values easily. However, it’s easy to make a mistake when implementing random sorting (see question 8.3 for an example).</p>&#13;
<p class="TX">The performance of this code is <i>O</i>(<i>n</i> log <i>n</i>), but you can do better. First, however, we’ll consider something you could have designed based on an interesting mix of concepts from <span class="Xref"><a href="chapter5.xhtml">Chapters 5</a></span> and <span class="Xref"><a href="chapter6.xhtml">6</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-68"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Shuffling by Coin Tossing</span></h4>&#13;
<p class="TNI1">Let’s explore other ways to shuffle a set of values. Imagine a divide-and-conquer procedure where you split a set in two (using a simulated coin toss to decide what goes where), recursively shuffle each part, and join them back together. Empty sets or sets with only one element would need no shuffling. You can shuffle a set with exactly two elements by randomly deciding (again, tossing a coin) which elements will be first and last. For sets with more than two elements, apply the recursive procedure illustrated in <a href="chapter8.xhtml#fig8-2">Figure 8-2</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-2" src="../images/Figure8-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-2: Randomly splitting an array, shuffling each part, and joining the results produces a shuffle that’s reminiscent of merge sort.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first split at the top separates the array into two parts with five and three elements. The subsequent steps follow moving downward. The five-element array splits into arrays with one and four elements. The single element doesn’t need any further shuffling, and the array with elements splits <span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>into two parts. Of those two parts, one is left as is (12, 60), and the other is swapped. The joined pairs create a random shuffle of the original four-element array, which then joins with the single element (22) to produce a random shuffle of the initial five-element array. A similar process occurs on the right side of the array, and the final result is at the bottom.</p>&#13;
<p class="TX">Here’s the implementation:</p>&#13;
<pre id="pre-117"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const coinTossingShuffle = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
  const len = to - from + 1;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> if (len &lt; 2) {&#13;
    // nothing to do&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span>} else if (len === 2) {&#13;
    if (randomBit()) {&#13;
      [arr[from], arr[to]] = [arr[to], arr[from]];&#13;
    }&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span>} else /* len &gt; 2 */ {&#13;
    let ind0 = from - 1;&#13;
    let ind1 = to + 1;&#13;
    let i = from;&#13;
    while (i &lt; ind1) {&#13;
      if (randomBit()) {&#13;
        ind1--;&#13;
        [arr[i], arr[ind1]] = [arr[ind1], arr[i]];&#13;
      } else {&#13;
        ind0++;&#13;
        i++;&#13;
      }&#13;
    }&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span> coinTossingShuffle(arr, from, ind0);&#13;
  <span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span> coinTossingShuffle(arr, ind1, to);&#13;
  }&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation7">❼</span> return arr;&#13;
};</code></pre>&#13;
<p class="TX">The parameters for shuffling functions will be an array <span class="SANS_TheSansMonoCd_W5Regular_11">arr</span> and the portion of it (<span class="SANS_TheSansMonoCd_W5Regular_11">from</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">to</span>) you are shuffling <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the length of the array is less than 2 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, nothing needs to be done. If the array has exactly two elements <span class="CodeAnnotation" aria-label="annotation3">❸</span>, flip a coin to decide whether to leave it be or swap the two elements. If the array has more than two elements <span class="CodeAnnotation" aria-label="annotation4">❹</span>, apply a logic reminiscent of partitioning in quicksort: flip coins to decide where each value goes. If the coin flip is true, the value goes into the <span class="SANS_TheSansMonoCd_W5Regular_11">ind1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">to</span> section, and if the coin flip is false, the value goes in the <span class="SANS_TheSansMonoCd_W5Regular_11">from</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">ind0</span> section. After moving every element to its place (at which time <span class="SANS_TheSansMonoCd_W5Regular_11">ind0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ind1</span> will point to positions next to each other), use recursion to shuffle the elements that received a false bit <span class="CodeAnnotation" aria-label="annotation5">❺</span> and those that got a true bit <span class="CodeAnnotation" aria-label="annotation6">❻</span>. Finally, return the shuffled-in-place array <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">This algorithm can be proven to have an average <i>O</i>(<i>n</i> log <i>n</i>) performance with a worst case of <i>O</i>(<i>n</i><sup>2</sup>). <a href="chapter8.xhtml#fig8-2">Figure 8-2</a> should remind you of merge sort and quicksort, algorithms with similar workings, so you haven’t really done better than with sorting.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>&#13;
<h4 class="H2" id="sec5"><span id="h2-69"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Shuffling in Linear Time</span></h4>&#13;
<p class="TNI1">How fast can we shuffle? The best possible result with shuffling is <i>O</i>(<i>n</i>), where you access each element in the array once. All the methods in the previous section had worse performance (although for small values of <i>n</i> they may be quite suitable), so now you’re going to consider linear time shuffling algorithms. And to better match what we did in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, we’ll shuffle just a portion of an array.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h5 class="H3" id="sec6"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Floyd’s Shuffle</span></h5>&#13;
<p class="TNI1">Robert Floyd’s linear time shuffling algorithm has some interesting ideas. The process has two steps: first, it generates a random permutation of numbers 0 to <i>n</i> – 1, and then it uses that generated permutation to shuffle the original array. (You’ll also see this technique in Floyd’s sampling algorithm, later in this chapter.) Start by generating the permutation, which is similar to an insertion sort (see <a href="chapter8.xhtml#fig8-3">Figure 8-3</a>).</p>&#13;
<figure class="IMG"><img class="img4" id="fig8-3" src="../images/Figure8-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-3: Floyd’s algorithm produces a shuffle by randomly inserting new values into the previously shuffled ones.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The algorithm works the same way as arranging playing cards by hand. You pick the first card, and that’s it. Then you pick the second card and place it to the left or to the right of the previous one. Then pick the third card and place it to the left, in the middle, or to the right of the previous two cards. Each new card goes somewhere among the previous cards, in a random place.</p>&#13;
<p class="TX">Here’s the code:</p>&#13;
<pre id="pre-118"><code>const floydShuffleN = (n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const result = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let i = 0; i &lt; n; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const j = randomInt(0, i + 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> result.splice(j, 0, i);&#13;
  }&#13;
  return result;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>For a simple implementation <span class="CodeAnnotation" aria-label="annotation1">❶</span>, you can use an array for the generated shuffle. First loop <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> times starting at 0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and each time you generate a random position <span class="CodeAnnotation" aria-label="annotation3">❸</span> where you insert the new number among the previous ones <span class="CodeAnnotation" aria-label="annotation4">❹</span> by using the very handy <span class="SANS_TheSansMonoCd_W5Regular_11">.splice(...)</span> method.</p>&#13;
<p class="TX">But how do you get from this permutation to a shuffle of the original array? <a href="chapter8.xhtml#fig8-4">Figure 8-4</a> shows how to use the previous result to finish the task.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-4" src="../images/Figure8-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-4: A random permutation of numbers is used to shuffle an array.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each element of the original array gets moved to a different place, according to the corresponding value that <span class="SANS_TheSansMonoCd_W5Regular_11">floydShuffleN(...)</span> produces. Implementing the moves requires an extra array. Having generated a shuffled list of numbers from 0 to <i>n</i> – 1, here’s the code to finish shuffling:</p>&#13;
<pre id="pre-119"><code>const floydShuffle = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const sample = floydShuffleN(to - from + 1);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const original = arr.slice(from, to + 1);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> sample.forEach((v, i) =&gt; (arr[from + i] = original[v]));&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">First generate a sample of numbers the same size as the portion of the array that you want to shuffle <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and then take the values in the input array <span class="CodeAnnotation" aria-label="annotation2">❷</span> and replace them according to the method <span class="CodeAnnotation" aria-label="annotation3">❸</span> shown in <a href="chapter8.xhtml#fig8-3">Figure 8-3</a>.</p>&#13;
<p class="TX">How the code performs depends on what data structure you choose for the sample. Using an array as shown here means that insertion <span class="SANS_TheSansMonoCd_W5Regular_11">.splice(...)</span> is <i>O</i>(<i>n</i>), so the whole algorithm becomes <i>O</i>(<i>n</i><sup>2</sup>). You’ll see appropriate data structures in future chapters, but Floyd suggests using a hash table of size 2<i>n</i>, with entries forming a linked list, for an expected average O(<i>n</i>) performance, or a balanced ordered tree with linked nodes, for O(<i>n</i> log <i>n</i>) assured performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Robson’s Algorithm</span></h5>&#13;
<p class="TNI1">Here’s a different take on how to generate a permutation. With an array of <i>n</i> elements, there are <i>n</i>! possible shuffling outcomes. The idea in Robson’s algorithm is to randomly select a number between 0 and <i>n</i>! – 1 inclusive and use that number to generate a permutation, so each different number produces a different shuffle.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This method is related to a mathematical concept called the Lehmer code, which is a way to encode each possible permutation of n numbers, but we won’t go into that here.</i></p>&#13;
<p class="TX">If you want to shuffle an array with four elements to produce a random permutation out of the 24 (= 4!) possible ones, you’d start with a random number between 0 and 23 inclusive. Then divide that number by 4. The quotient will be a number between 0 and 5, and the remainder will be between 0 and 3. (An important detail is that all possible combinations of quotient and remainder are equally probable. Can you verify that?)</p>&#13;
<p class="TX">Use the remainder to choose one of the four elements in the array, set it aside, and keep working with the other three. Consider the quotient: it’s a random value between 0 and 5.</p>&#13;
<p class="TX">This time, divide by 3. The new quotient will be 0 or 1, and the remainder will be 0, 1, or 2, which you can use to choose one of the three remaining numbers. Consider the quotient, which is either 0 or 1. If you divide the quotient you had by 2, you’ll get a quotient of 0 (no more work to be done). You can use the remainder (0 or 1) to choose one of the two remaining numbers, and you’ll have your desired shuffle. (After you’ve chosen 3 out of 4, the complete shuffle is implied.) <a href="chapter8.xhtml#fig8-5">Figure 8-5</a> shows the algorithm if you had drawn 14 as the random number.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-5" src="../images/Figure8-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-5:</span> <span class="SANS_Futura_Std_Book_Oblique_11">Robson’s shuffling algorithm is also based on transforming the original array depending on a randomly chosen permutation.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Start with values ABCD in the four positions of the array, from 0 to 3. In the first step, divide 14 by 4, getting a quotient of 3 and a remainder of 2. Then swap the element in position 2 of the array with the last, getting ABDC. The second step divides 3 (the previous quotient) by 3, producing quotient 1 and remainder 0. Then swap the element in position 0 with the next-to-last element, resulting in DBAC. Then, divide 1 (the latest quotient) by 2, which gives quotient 0 and remainder 1. You don’t need to swap, because you’d swap the element at position 1 with itself, and you’d still have DBAC. After having shuffled three of the elements of the array, the fourth is also in place, and you’re done.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>Here’s the logic:</p>&#13;
<pre id="pre-120"><code>const robsonShuffle = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const n = to - from + 1;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let r = randomInt(0, fact(n));&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (let i = n; i &gt; 1; i--) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const q = r % i;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> [arr[from + i - 1], arr[from + q]] = [arr[from + q], arr[from + i – 1]];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> r = Math.floor(r / i);&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">The number of elements to shuffle is <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You generate a random number <span class="CodeAnnotation" aria-label="annotation2">❷</span> between 0 and <i>n</i>! – 1 using the factorial function developed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. You then loop through the array from right to left <span class="CodeAnnotation" aria-label="annotation3">❸</span>: calculate <span class="SANS_TheSansMonoCd_W5Regular_11">q</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, use it to swap elements <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and find <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> to loop again <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">The algorithm is obviously <i>O</i>(<i>n</i>), as it follows from its single loop. However, as is, the algorithm has a problem. You wouldn’t be able to use it for large arrays, because calculating a factorial may exceed the available precision of JavaScript (see question 8.5). Fortunately, there’s a way out.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><span class="SANS_Futura_Std_Bold_Condensed_B_11">The Fisher-Yates Algorithm</span></h5>&#13;
<p class="TNI1">The problem with Robson’s algorithm is the need to calculate <i>n</i>! to get a random number with which to proceed. But if you consider it carefully, you don’t really need the factorial. The key to that algorithm was the series of remainders, and you can generate those by using a random function. The first remainder was in the range 0 to <i>n</i> – 1, and it was used to choose the initial value of the permutation; the second remainder was in the range 0 to <i>n</i> – 2, and it was used to choose the second value of the permutation, and so on. It follows that you just need to generate random values at proper times in Robson’s algorithm, and that’s the Fisher-Yates algorithm.</p>&#13;
<p class="TX">Thus, you can write this alternative to Robson’s code:</p>&#13;
<pre id="pre-121"><code>const fisherYatesShuffle = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = to + 1; i &gt; from + 1; i--) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const j = randomInt(from, i);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [arr[i - 1], arr[j]] = [arr[j], arr[i – 1]];&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">As in Robson’s shuffle, loop from right to left <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and at each pass calculate a random number <span class="CodeAnnotation" aria-label="annotation2">❷</span> that you use to decide what elements to swap <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Basically, any element in positions <span class="SANS_TheSansMonoCd_W5Regular_11">from</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> could be chosen for the swap.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>The Fisher-Yates algorithm is frequently written to shuffle from left to right, which is basically the same idea:</p>&#13;
<pre id="pre-122"><code>const fisherYatesShuffle2 = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = from; i &lt; to; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const j = randomInt(i, to + 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [arr[i], arr[j]] = [arr[j], arr[i]];&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">The code is the same <span class="CodeAnnotation" aria-label="annotation1">❶</span> except that the generated permutation starts from left to right, and any element in positions <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">to</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> may be chosen for swapping <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This algorithm is quite efficient, and it’s often used for shuffling. Be careful, though, because it’s easy to mess up; see question 8.4.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-39"/><span class="SANS_Futura_Std_Bold_B_11">Sampling</span></h3>&#13;
<p class="TNI1">Sampling is a technique frequently used in statistics. Basically, out of a set of values (an array), you want to pick a random, smaller set, which is called a <i>sample</i>. There are two kinds of sampling procedures: sampling with repetition, in which elements may be chosen more than once, and sampling without repetition, in which no element may be chosen two times or more. In mathematical terms, the latter procedure is called selecting a <i>combination</i> of elements. (In the first case, sampling with repetition, the number of chosen elements can be anything. In the second case, the number is limited by the number of elements in the original set.) Don’t worry about the order in which the elements are selected.</p>&#13;
<p class="TX">We’ll first consider sampling with repetition, for which we just need a couple of short, optimally efficient algorithms, and then we’ll dedicate most of the rest of the chapter to sampling without repetition, which requires more complex logic.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-70"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Sampling with Repetition</span></h4>&#13;
<p class="TNI1">Sampling with repetition is a simple algorithm, and you’ll start by selecting just a single value. Choosing a larger sample will simply be a matter of choosing a value over and over again.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Choosing Only One Value</span></h5>&#13;
<p class="TNI1">Choosing a single value is the simplest kind of sampling, and all you need is a random number in the appropriate range. You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">randomInt(...)</span> function, and for an element of an array, the following works:</p>&#13;
<pre id="pre-123"><code>const singlePick = (arr, from = 0, to = arr.length - 1) =&gt;&#13;
  arr[randomInt(from, to + 1)];</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>To select an element between the <span class="SANS_TheSansMonoCd_W5Regular_11">from</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">to</span> positions (both included), you produce a random number in that range and return the corresponding element.</p>&#13;
<p class="TX">Of course, if you always want to choose values from the whole array (as you’ll do in the rest of the chapter), simpler code does the job:</p>&#13;
<pre id="pre-124"><code>const singlePickAll = (arr) =&gt; arr[randomInt(0, arr.length)];</code></pre>&#13;
<p class="TX">This is equivalent to setting <span class="SANS_TheSansMonoCd_W5Regular_11">from</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> <span class="SANS_TheSansMonoCd_W5Regular_11">arr.length - 1</span>, so this new function works in the same way.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Choosing Several Values with Repetition</span></h5>&#13;
<p class="TNI1">As mentioned, to make multiple selections from a set (maybe to simulate a series of roulette wheel turns, or create a strategy for a game of rock/paper/scissors, or implement the lazy select median-finding algorithm from <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>), doing several single selections is enough:</p>&#13;
<pre id="pre-125"><code>const repeatedPick = (arr, k, from = 0, to = arr.length - 1) =&gt; {&#13;
  const sample = Array(k);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = 0; i &lt; k; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> sample[i] = arr[randomInt(from, to + 1)];&#13;
  }&#13;
  return sample;&#13;
};</code></pre>&#13;
<p class="TX">The logic is simple: first loop <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> times <span class="CodeAnnotation" aria-label="annotation1">❶</span>, randomly choosing elements one by one <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Again, as with choosing a single value, to make selections from an entire array, the code is simpler, and you can reuse the <span class="SANS_TheSansMonoCd_W5Regular_11">singlePickAll</span> code from the previous section as well:</p>&#13;
<pre id="pre-126"><code>const repeatedPickAll = (arr, k) =&gt; {&#13;
  const sample = Array(k);&#13;
  for (let i = 0; i &lt; k; i++) {&#13;
    sample[i] = singlePickAll(arr);&#13;
  }&#13;
  return sample;&#13;
};</code></pre>&#13;
<p class="TX">For a related coding challenge, see question 8.7. Next, take a look at sampling without repetition, which has the restrictions of not allowing you to choose any element more than once and doing so in an efficient way.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-71"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Sampling Without Repetition</span></h4>&#13;
<p class="TNI1">This process is equivalent to what’s used in Powerball-style lottery drawings: numbers are removed from (but not returned to) an urn, guaranteeing that all selected numbers are different.</p>&#13;
<p class="TX">For the algorithms in this section, assume you have an array with <i>n</i> elements, from which you want to pick a combination of <i>k</i> elements. It must be <span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/><i>k</i> &lt; <i>n</i>—if <i>k</i> were equal to <i>n</i>, no algorithm would be needed, and <i>k</i> cannot be greater than <i>n</i> if no repetitions are allowed. Algorithms will be faster the fewer elements that you want, so for a cheap optimization, you can assume that <i>k &gt;</i>= <i>n</i>/2; indeed, if <i>k</i> ≥ <i>n</i>/2, instead of selecting <i>k</i> elements, you could select <i>n</i> – <i>k</i> ones and discard them.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Sampling by Sorting or Shuffling</span></h5>&#13;
<p class="TNI1">The first idea is inspired by the “<span class="Xref">Shuffling by Sorting</span>” section on page <span class="Xref">139</span>, plus the selection algorithm explored in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. You can assign random keys to all elements, sort them, and then get the elements with the lowest <i>k</i> keys. You’ve already considered all the necessary code to implement this method, so leave actual development to question 8.8.</p>&#13;
<p class="TX">A second idea you could try is based on the fact that you already know how to generate a random permutation of a set. Given this, an obvious way to generate a sample could easily be to shuffle the set and then take its first <i>k</i> elements. That works, but you can get the desired sample with more efficient logic without having to shuffle (similar to what you found with selection algorithms, when you saw better ways of selecting that didn’t require a previous sort). You won’t see the code for this procedure either, as it’s derived from what you’ve already done. Let’s move on to new algorithms instead.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Floyd’s Algorithm</span></h5>&#13;
<p class="TNI1">Often you just need a sample of <i>k</i> integers between 0 (included) and <i>n</i> (excluded). Robert Floyd’s <span class="SANS_TheSansMonoCd_W5Regular_11">floydSampleKofN(...)</span> algorithm produces an array with a combination of <i>k</i> such numbers, which is interesting in itself and will help you write a more general sampling algorithm. If you need a sample from the original array, you can use the selected numbers produced by <span class="SANS_TheSansMonoCd_W5Regular_11">floydSampleKofN()</span> for that task, as in <a href="chapter8.xhtml#fig8-6">Figure 8-6</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-6" src="../images/Figure8-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-6: A random selection of numbers from 0 to</span> <span class="SANS_Futura_Std_Book_11">n</span> <span class="SANS_Futura_Std_Book_Oblique_11">– 1 produces a random sample.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can choose values from the original input array using the sample’s values as indices, as shown in <a href="chapter8.xhtml#fig8-6">Figure 8-6</a>. The input array is at the top, the sample produced by Floyd’s code is [5, 2, 3], and the final result is shaded in gray.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/>Here’s the code that uses the (yet unseen) <span class="SANS_TheSansMonoCd_W5Regular_11">floydSampleKofN()</span> function:</p>&#13;
<pre id="pre-127"><code>const floydSample = (arr, k) =&gt;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> floydSampleKofN(k, arr.length).map((v) =&gt; arr[v]);</code></pre>&#13;
<p class="TX">You generate a random combination of <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> values out of <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and use those numbers as indices to get values from the original input array.</p>&#13;
<p class="TX">Let’s return to generating the combination and finally see <span class="SANS_TheSansMonoCd_W5Regular_11">floydSampleKofN()</span>. The recursive version is the following, and recursion helps you understand how and why the algorithm works:</p>&#13;
<pre id="pre-128"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const floydSampleKofN = (k, n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (k === 0) {&#13;
    return [];&#13;
  } else {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const sample = floydSampleKofN(k - 1, n – 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const j = randomInt(0, n);&#13;
    sample.push(sample.includes(j) ? n - 1 : j);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return sample;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">You want a combination of <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> distinct values between 0 and <span class="SANS_TheSansMonoCd_W5Regular_11">n - 1</span> inclusive <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> is 0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you return an empty sample. Otherwise, you use recursion first to choose a combination of <span class="SANS_TheSansMonoCd_W5Regular_11">k - 1</span> values up to <span class="SANS_TheSansMonoCd_W5Regular_11">n - 2</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Then decide what value to add to that sample <span class="CodeAnnotation" aria-label="annotation4">❹</span>. At the end <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you return the created sample.</p>&#13;
<p class="TX">Now examine how to add a new value to the sample, working with getting a sample of three values out of eight, as in <a href="chapter8.xhtml#fig8-6">Figure 8-6</a>. Suppose you already have a sample of two values out of the set 0 to 6: should you add a 7 value to produce the sample of three values? A possibility (1/8) is that the random number <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> is exactly 7. It can’t be in the previous sample, so it will be added.</p>&#13;
<p class="TX">The other way to add 7 is if <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> was one of the two numbers already in the sample (2/8). Thus, the probability that 7 will end up included in the sample of 3 out of 8 is 1/8 + 2/8, which is exactly 3/8 as you needed. You can apply this argument systematically and find that each of the <i>n</i> values has a probability of <i>k/n</i> of being in the final sample, so the algorithm really produces a correct sample.</p>&#13;
<p class="TX">Since recursion always happens at the beginning of each pass, you can turn the code into an iterative equivalent version (see question 8.9):</p>&#13;
<pre id="pre-129"><code>const floydSampleKofN = (k, n) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const sample = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let i = n - k; i &lt;= n - 1; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const j = randomInt(0, i + 1);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> sample.push(sample.includes(j) ? i : j);&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> return sample;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>First, create an array to return the chosen sample <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and you’ll return this at the end <span class="CodeAnnotation" aria-label="annotation5">❺</span>. A loop executes <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> times <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In each pass choose a random number <span class="CodeAnnotation" aria-label="annotation3">❸</span> and use the same logic (checking whether the randomly selected number was already selected) to decide what to add <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The argument to prove that this algorithm works correctly is along the same lines as for the recursive version, so it won’t be repeated here.</p>&#13;
<p class="TX">The key to performance for Floyd’s algorithm is how it adds a value to the sample and checks whether a given value is already in the sample. In other words, it needs an efficient implementation of a set. You also could use a bitmap as in <span class="Xref"><a href="chapter6.xhtml">Chapters 6</a></span> and <span class="Xref"><a href="chapter7.xhtml">7</a></span> (we’ll leave this for now and consider such options in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Lottery Drawing</span></h5>&#13;
<p class="TNI1">Another method to consider implies actually replicating a lottery drawing. You choose a random element of the set, place it somewhere else, and do it again and again until you get the complete sample. <a href="chapter8.xhtml#fig8-7">Figure 8-7</a> shows the process. The set of values is on the left, the selected sample is on the right, and the triangle marks the randomly chosen element at each stage.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-7" src="../images/Figure8-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-7: A simulated lottery drawing produces a random sample.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When you remove an element, you swap it with the one in the last place of the array to avoid having to shift the whole array, which would slow the code’s performance.</p>&#13;
<p class="TX">Here’s a simple implementation:</p>&#13;
<pre id="pre-130"><code>const lotterySample = (arr, k) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const n = arr.length;&#13;
  const sample = Array(k);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let i = 0; i &lt; k; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const j = randomInt(0, n – i);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> sample[i] = arr[j];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> arr[j] = arr[n - i – 1];&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> return sample;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>Start by creating the array that will get the sample <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Loop <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> times <span class="CodeAnnotation" aria-label="annotation2">❷</span>, generating a random position <span class="CodeAnnotation" aria-label="annotation3">❸</span> among the first <span class="SANS_TheSansMonoCd_W5Regular_11">n - i</span> elements of the array, because the already sampled elements will go to the end of the array <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The chosen element is added to the sample array, and it’s swapped so it won’t be considered again in other selections <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Finally, return the produced sample <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">This algorithm is simple enough, and it has <i>O</i>(<i>k</i>) performance that cannot be improved upon. After all, you want a sample with <i>k</i> elements. However, you can get a bit more speed if you notice that there’s no actual need for a separate sample array.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Fisher-Yates Sampling</span></h5>&#13;
<p class="TNI1">In the previous lottery sampling algorithm, at any time each element of the array is either chosen or not, so you don’t need two arrays. The original one will do. <a href="chapter8.xhtml#fig8-8">Figure 8-8</a> illustrates this idea; the shaded numbers are the chosen ones.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-8" src="../images/Figure8-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-8: The lottery sampling algorithm can work in place, without extra memory.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Every time an element is chosen, move it to the front of the array, so all of its first elements are in the sample and the rest are the nonchosen ones. This algorithm is a variation of the Fisher-Yates shuffling method (the same logic but applied fewer times, because you don’t want to randomize the whole array; only <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> elements), and you can code it as follows:</p>&#13;
<pre id="pre-131"><code>const fisherYatesSample = (arr, k) =&gt; {&#13;
  const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = 0; i &lt; k; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const j = randomInt(i, n);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [arr[i], arr[j]] = [arr[j], arr[i]];&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> return arr.slice(0, k);&#13;
};</code></pre>&#13;
<p class="TX">In this algorithm, the <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> variable points to the corresponding sampled element. You loop <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> times <span class="CodeAnnotation" aria-label="annotation1">❶</span>, choosing a random position among the yet-unchosen elements <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and you do a swap to change the selected element <span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label="152"/>from the unchosen part to the chosen one <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After completing the loop <span class="CodeAnnotation" aria-label="annotation4">❹</span>, return the initial slice (<span class="SANS_TheSansMonoCd_W5Regular_11">k</span> elements long) of the original array.</p>&#13;
<p class="TX">The Fisher-Yates sampling algorithm is also <i>O</i>(<i>k</i>); the only difference is where the sample is stored.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Knuth’s Algorithm</span></h5>&#13;
<p class="TNI1">Donald Knuth’s algorithm has the interesting characteristic that the values in the sample keep their relative order as in the original array. The algorithm is based on probabilities, which directly proves its correctness.</p>&#13;
<p class="TX">To understand how it works, suppose you want to choose three elements out of eight. The probability that the first element will be included is 3/8. The probability that the second element will be chosen depends on whether the first element was chosen. If it was, the probability of choosing the second is 2/7 (because having selected one of the eight, now you choose two out of the remaining seven), but if skipped, the probability of choosing the second is 3/7 (because now you have to choose three elements out of the remaining seven).</p>&#13;
<p class="TX">The algorithm chooses or skips elements based on random numbers and probabilities, as follows:</p>&#13;
<pre id="pre-132"><code>const orderedSample = (arr, k) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (k === 0) {&#13;
   return [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>} else if (Math.random() &lt; k / arr.length) {&#13;
   return [arr[0], . . .orderedSample(arr.slice(1), k - 1)];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>} else {&#13;
   return [...orderedSample(arr.slice(1), k)];&#13;
 }&#13;
};</code></pre>&#13;
<p class="TX">If you want to choose an empty sample <span class="CodeAnnotation" aria-label="annotation1">❶</span>, an empty array is returned; this is the base case for the recursion. Otherwise, you get a random number and compare it with the probability: if it’s smaller <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you include the first element of the array followed by a <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> – 1 sized sample of the rest. If it’s greater <span class="CodeAnnotation" aria-label="annotation3">❸</span>, you select all <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> elements out of the rest of the array.</p>&#13;
<p class="TX">A better implementation avoids recursion and all the destructuring and slicing of arrays as follows:</p>&#13;
<pre id="pre-133"><code>const orderedSample = (arr, k) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const sample = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let toSelect = k;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let toConsider = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> for (let i = 0; toSelect &gt; 0; i++) {&#13;
    if (Math.random() &lt; toSelect / toConsider) {&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> sample.push(arr[i]);&#13;
      toSelect--;&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> toConsider--;&#13;
  }&#13;
  return sample;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label="153"/>As in other algorithms, <span class="SANS_TheSansMonoCd_W5Regular_11">sample</span> is the array that will be produced <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The variables <span class="SANS_TheSansMonoCd_W5Regular_11">toSelect</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">toConsider</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> will keep count of how many values you still have to select out of the values not yet considered. You loop until there are no more values to choose <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Each time, you decide whether to choose or ignore a value, according to the probabilistic method described. If the test comes out true <span class="CodeAnnotation" aria-label="annotation5">❺</span>, add the value to the sample array and decrease the count of pending values to select by 1. Every pass through the loop, we decrease the number of values to yet consider <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">You can also write it in a more compact way:</p>&#13;
<pre id="pre-134"><code>const orderedSample2 = (arr, k) =&gt; {&#13;
  const n = arr.length;&#13;
  const sample = [];&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = 0; k &gt; 0; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> if (Math.random() &lt; k / (n - i)) {&#13;
      sample.push(arr[i]);&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> k--;&#13;
    }&#13;
  }&#13;
  return sample;&#13;
};</code></pre>&#13;
<p class="TX">The difference is that you’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> instead of a <span class="SANS_TheSansMonoCd_W5Regular_11">toSelect</span> variable <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and you’ll calculate how many yet-unseen values there are <span class="CodeAnnotation" aria-label="annotation2">❷</span>; otherwise, the algorithm is the same.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Reservoir Sampling</span></h5>&#13;
<p class="TNI1">The final algorithm we’ll consider was created by Alan Waterman, and it’s interesting because it can work in an online mode, without needing the whole array of elements beforehand. All the other algorithms in this chapter work in offline mode. The code goes through the input data, maintaining a suitable random sample at all times; it can be stopped at any moment and would have a proper random sample of the elements seen so far. This algorithm is quite suitable for large streams, where it might be impossible to store all values in memory and then apply one of the previous algorithms considered in this chapter.</p>&#13;
<p class="TX">Consider a simple case first: choosing just one element out of a sequence of undetermined length. (If you knew the length of the sequence, using <span class="SANS_TheSansMonoCd_W5Regular_11">randomInt(...)</span> would be the quickest way to pick an element.) The solution to this problem works as follows:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Choose the first element of the sequence and place it in a reservoir.</li>&#13;
<li class="ListBullet">For the <i>i</i>th element in the sequence after the first, use it to replace the reservoir value with probability of 1/<i>i.</i></li>&#13;
</ul>&#13;
<p class="TX">Suppose the sequence had 1,000 elements. What’s the probability of choosing the very last element? Obviously, it’s 1/1,000. If you didn’t choose it, when you have 999 elements, what’s the probability of choosing the 999th? It would be 1/999. As more and more elements are processed, the probability of choosing the <i>i</i>th one is always 1/<i>i</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_154" aria-label="154"/>You can expand this example to choose a sample of <i>k</i> elements; the process is quite similar:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Choose the first <i>k</i> elements of the sequence and place them in a reservoir.</li>&#13;
<li class="ListBullet">For the <i>i</i>th element in the sequence after those <i>k</i>, add it to the reservoir value with a probability of <i>k</i>/<i>i</i> by replacing a randomly selected value of the reservoir.</li>&#13;
</ul>&#13;
<p class="TX">You can code this as follows:</p>&#13;
<pre id="pre-135"><code>const reservoirSample = (arr, k) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const n = arr.length;&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const sample = arr.slice(0, k);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (let i = k; i &lt; n; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const j = randomInt(0, i + 1);&#13;
    if (j &lt; k) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> sample[j] = arr[i];&#13;
    }&#13;
  }&#13;
  return sample;&#13;
};</code></pre>&#13;
<p class="TX">We won’t work with a stream, but the changes for that are straightforward. Here, to know when the sequence is ended you’ll use variable <span class="SANS_TheSansMonoCd_W5Regular_11">n</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and the <span class="SANS_TheSansMonoCd_W5Regular_11">sample</span> reservoir is initialized with the first <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> elements of the sequence <span class="CodeAnnotation" aria-label="annotation2">❷</span>. You loop through the data <span class="CodeAnnotation" aria-label="annotation3">❸</span> and do a random test <span class="CodeAnnotation" aria-label="annotation4">❹</span> to see whether the number should go into the array; the <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> variable is used both for the test and to randomly decide what reservoir element to replace <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">If you modify the input array (using its first <i>k</i> positions for the reservoir), the algorithm looks like this:</p>&#13;
<pre id="pre-136"><code>const reservoirSample2 = (arr, k) =&gt; {&#13;
  const n = arr.length;&#13;
  for (let i = k; i &lt; n; i++) {&#13;
    const j = randomInt(0, i + 1);&#13;
    if (j &lt; k) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> [arr[i], arr[j]] = [arr[j], arr[i]];&#13;
    }&#13;
  }&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> return arr.slice(0, k);&#13;
};</code></pre>&#13;
<p class="TX">The differences are how you swap a chosen value into the reservoir <span class="CodeAnnotation" aria-label="annotation1">❶</span> and how you return the chosen sample <span class="CodeAnnotation" aria-label="annotation2">❷</span>; otherwise, it functions exactly the same way.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h3 class="H1" id="sec20"><span id="h1-40"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter we’ve considered algorithms for generating randomized permutations and combinations of an array, methods that are quite useful for <span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label="155"/>several areas like gaming or statistics, among others. In the next chapter, we’ll turn to another common and important task: searching efficiently for a value.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h3 class="H1" id="sec21"><span id="h1-41"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>8.1  Good Enough Shuffling</b></p>&#13;
<p class="ListPlainFirst">Implement a logging function that takes a shuffling function as input and runs many tests, counting how often each possible permutation is produced, and then draw a histogram to visualize its results.</p>&#13;
<p class="ListBody"><a href="chapter8.xhtml#fig8-9">Figure 8-9</a> shows the output from my own tests with good results for a shuffle of an array of four elements.</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-9" src="../images/Figure8-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-9: A histogram showing that a certain shuffling algorithm produces all possible outcomes with similar frequencies</span></p></figcaption>&#13;
</figure>&#13;
<p class="ListBody">After 48,000 random tries, all permutations (24 = 4!) were generated, and the results seem similar enough. Although this assertion isn’t really valid in a statistical way; a <span class="greek_alt"><span xml:lang="el" lang="el">χ</span></span><sup>2</sup> (that’s the Greek letter chi) goodness-of-fit test would be required for that.</p>&#13;
<p class="ListHead"><b>8.2  Random Roll</b></p>&#13;
<p class="ListPlainFirst">Suppose you have to generate a uniform random triple option: instead of true/false, say high/medium/low. Using <span class="SANS_TheSansMonoCd_W5Regular_11">Math.random()</span>, it’s easy to do, as seen in the <span class="SANS_TheSansMonoCd_W5Regular_11">randomNum(...)</span> function, but can you do this using only <span class="SANS_TheSansMonoCd_W5Regular_11">randomBit()</span>? Along the same lines, how can you generate a uniform die roll (1–6) using <span class="SANS_TheSansMonoCd_W5Regular_11">randomBit()</span>? Or a 1 to 20 roll for a <i>Dungeons &amp; Dragons</i> type of game? (This last question is trickier.)</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label="156"/><b>8.3  Not-So-Random Shuffling</b></p>&#13;
<p class="ListPlainFirst">After reading the description for random shuffling, a programmer decides to make it simpler: instead of bothering to assign random keys and sorting by them, the programmer took a sorting algorithm (bubble sort, in this case) and changed the comparisons among keys to use a random bit:</p>&#13;
<pre class="pre" id="pre-137"><code>const naiveSortShuffle = (arr) =&gt; {&#13;
  for (let j = arr.length - 1; j &gt; 0; j--) {&#13;
    for (let i = 0; i &lt; j; i++) {&#13;
    <span class="listcode_CodeAnnotation" aria-label="annotation1">❶</span> if (<b>randomBit()</b>) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
      }&#13;
    }&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListBody">The logic is that of bubble sort (see <span class="listbody_Xref"><a href="chapter6.xhtml">Chapter 6</a></span>) but with a single change <span class="listbody_CodeAnnotation" aria-label="annotation1">❶</span>. Why is this a bad shuffle generator? Where did the programmer go wrong?</p>&#13;
<p class="ListHead"><b>8.4  Bad Swapping Shuffle</b></p>&#13;
<p class="ListPlainFirst">A developer messed up when implementing the Fisher-Yates shuffling code and wrote the following, which seems good enough at first:</p>&#13;
<pre class="pre" id="pre-138"><code>const naiveSwappingShuffle = (arr) =&gt; {&#13;
  const n = arr.length;&#13;
  for (let i = 0; i &lt; n; i++) {&#13;
    <b>const j = randomInt(0, n);</b>&#13;
    [arr[i], arr[j]] = [arr[j], arr[i]];&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="ListContinued">The difference is in the line in bold. You always choose a random place from the complete array. What’s wrong with this code?</p>&#13;
<p class="ListHead"><b>8.5  Robson’s Top?</b></p>&#13;
<p class="ListPlainFirst">What’s the maximum length of array that you can shuffle using Robson’s algorithm? Be careful; the answer is tricky.</p>&#13;
<p class="ListHead"><b>8.6  Sampling Testing</b></p>&#13;
<p class="ListPlainFirst">Can you develop something to visually validate sampling functions, along the lines of what was required in question 8.1?</p>&#13;
<p class="ListHead"><b>8.7  Single-Line Repeater</b></p>&#13;
<p class="ListPlainFirst">A reviewer of the draft for this chapter mentioned that <span class="SANS_TheSansMonoCd_W5Regular_11">repeatedPick(...)</span>, as shown in the “<span class="listplain_Xref">Choosing Several Values with Repetition</span>” section on <span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label="157"/>page <span class="listplain_Xref">147</span>, could be written as a single line, in just one statement. What would it be?</p>&#13;
<p class="ListHead"><b>8.8  Sort to Sample</b></p>&#13;
<p class="ListPlainFirst">Implement the algorithm described in the section “<span class="listplain_Xref">Sampling by Sorting or Shuffling</span>” on page <span class="listplain_Xref">148</span>.</p>&#13;
<p class="ListHead"><b>8.9  Iterate, Don’t Recurse</b></p>&#13;
<p class="ListPlainFirst">A recursive function along the lines of</p>&#13;
<pre class="pre" id="pre-139"><code>const something = (p) =&gt; (p === 0 ? BASE : other(something(p - 1), p));</code></pre>&#13;
<p class="ListContinued">can be written equivalently in an iterative fashion as the following:</p>&#13;
<pre class="pre" id="pre-140"><code>const something = (p) =&gt; {&#13;
  let result = BASE;&#13;
  for (let i = 1; i &lt;= p; i++) {&#13;
    result = other(result, i);&#13;
  }&#13;
  return result;&#13;
};</code></pre>&#13;
<p class="ListBody">Explain why this works. Also, try this conversion for the <span class="SANS_TheSansMonoCd_W5Regular_11">factorial(...)</span> function from <span class="listbody_Xref"><a href="chapter5.xhtml">Chapter 5</a></span> and adapt it for Floyd’s <span class="SANS_TheSansMonoCd_W5Regular_11">sampleKofN(...)</span> algorithm (which will be trickier) to verify what was shown in the text.</p>&#13;
<p class="ListHead"><b>8.10  No Limits?</b></p>&#13;
<p class="ListPlainFirst">In Knuth’s sample code, there’s no check to see whether <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> goes out of bounds; why isn’t it needed?</p>&#13;
<pre class="pre" id="pre-141"><code>const orderedSample = (arr, k) =&gt; {&#13;
  const n = arr.length;&#13;
  const sample = [];&#13;
  let toSelect = k;&#13;
  let toConsider = n;&#13;
  for (<b>let i = 0; toSelect &gt; 0; i++</b>) {&#13;
    if (Math.random() &lt; toSelect / toConsider) {&#13;
      sample.push(arr[i]);&#13;
      toSelect--;&#13;
    }&#13;
    toConsider--;&#13;
  }&#13;
  return sample;&#13;
};</code></pre>&#13;
</section>&#13;
</section>&#13;
</body></html>