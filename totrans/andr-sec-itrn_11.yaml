- en: Chapter 11. NFC and Secure Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 NFC与安全元素
- en: This chapter gives a brief overview of near field communication (NFC) and secure
    elements (SEs), and explains how they’re integrated into mobile devices. While
    NFC has many uses, we focus on its card emulation mode, which is used to provide
    an interface to an SE integrated into a mobile device. Secure elements offer protected
    storage for private data, such as authentication keys, and provide a secure execution
    environment that can protect security-critical code. We’ll describe which types
    of SEs Android supports and introduce the APIs that Android applications can use
    to communicate with SEs. Finally, we’ll discuss host-based card emulation (HCE)
    and its Android implementations, and demonstrate how to implement an HCE application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了近场通信（NFC）和安全元素（SE），并解释了它们如何集成到移动设备中。虽然NFC有许多用途，但我们将重点介绍其卡片仿真模式，该模式用于提供与集成在移动设备中的SE的接口。安全元素为私密数据提供受保护的存储，例如身份验证密钥，并提供一个安全执行环境，以保护安全关键代码。我们将描述Android支持的SE类型，并介绍Android应用程序可以使用的与SE通信的API。最后，我们将讨论基于主机的卡片仿真（HCE）及其在Android中的实现，并演示如何实现HCE应用程序。
- en: NFC Overview
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFC概述
- en: '*NFC* is a technology that allows devices that are in close proximity (usually
    10 centimeters or less) to establish radio communication with each other and exchange
    data. NFC is not a single standard, but is based on a set of standards that define
    radio frequencies, communication protocols, and data exchange formats. NFC builds
    upon radio-frequency identification (RFID) technology and operates at the 13.56
    MHz frequency, allowing various data transmission rates such as 106kbps, 212kbps,
    and 424kbps.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*NFC*是一种允许处于近距离（通常为10厘米或更短）的设备之间建立无线通信并交换数据的技术。NFC不是单一的标准，而是基于一组标准，这些标准定义了射频、通信协议和数据交换格式。NFC基于射频识别（RFID）技术，并在13.56
    MHz频率下工作，支持106kbps、212kbps和424kbps等不同的数据传输速率。'
- en: 'NFC communication involves two devices: an initiator and a target. In *active
    mode*, both the initiator and the target have their own power supplies and each
    can transmit a radio signal in order to communicate with the other party. In *passive
    mode*, the target device does not have its own power source and is activated and
    powered by the electromagnetic field emitted by the initiator.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: NFC通信涉及两个设备：发起者和目标。在*主动模式*下，发起者和目标都有各自的电源，并且每个设备都可以发射无线信号以便与对方进行通信。在*被动模式*下，目标设备没有自己的电源，而是通过发起者发射的电磁场来激活并供电。
- en: When communicating in passive mode, the initiator is often called a *reader*,
    and the target a *tag*. The reader can be a dedicated device or be embedded in
    a general purpose device, such as a personal computer or a mobile phone. Tags
    come in various shapes and sizes and range from simple stickers with very limited
    amount of memory to contactless smart cards, which have an embedded CPU.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在被动模式下进行通信时，发起者通常被称为*读卡器*，而目标则被称为*标签*。读卡器可以是专用设备，也可以嵌入到通用设备中，例如个人电脑或手机。标签有各种形状和大小，从简单的、内存非常有限的贴纸到内嵌CPU的非接触智能卡。
- en: 'NFC devices can operate in three different modes: reader/writer (R/W), peer-to-peer
    (P2P), and card emulation (CE). In R/W mode, a device acts as an active initiator
    and can read and write data to external tags. In P2P mode, two NFC devices can
    actively exchange data using a bidirectional communication protocol. The CE mode
    allows an NFC device to emulate a tag or a contactless smart card. Android supports
    all three modes with some limitations. We give an overview of Android’s NFC architecture
    and show how to use each mode in the next section.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: NFC设备可以在三种不同模式下工作：读写（R/W）、点对点（P2P）和卡片仿真（CE）。在R/W模式下，设备作为主动发起者，可以读取和写入外部标签的数据。在P2P模式下，两台NFC设备可以使用双向通信协议进行主动的数据交换。CE模式允许NFC设备仿真标签或非接触式智能卡。Android支持这三种模式，但存在一些限制。我们将在下一节概述Android的NFC架构，并展示如何使用每种模式。
- en: Android NFC Support
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android NFC支持
- en: NFC support in Android was introduced in version 2.3 and the related architecture
    and features remained largely unchanged until version 4.4, which introduced HCE
    support.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Android在2.3版本中引入了NFC支持，相关架构和功能在版本4.4之前基本保持不变，而版本4.4引入了HCE支持。
- en: Android’s NFC implementation resides in the `NfcService` system service, part
    of the `Nfc` system application (package `com.android.nfc`). It wraps the native
    libraries required to drive each supported NFC controller; implements access control,
    tag discovery, and dispatch; and controls card emulation. Android doesn’t expose
    a low-level API to the functionality of `NfcService`, but instead offers an event-driven
    framework that allows interested applications to register for NFC events. This
    event-driven approach is used in all three NFC operating modes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android的NFC实现位于`NfcService`系统服务中，属于`Nfc`系统应用（包名为`com.android.nfc`）。它封装了驱动每个支持的NFC控制器所需的本地库；实现了访问控制、标签发现和分发；并控制卡模拟。Android并未向外部暴露`NfcService`的低级API，而是提供了一个事件驱动框架，允许感兴趣的应用程序注册NFC事件。这种事件驱动的方法在所有三种NFC操作模式中均有使用。
- en: Reader/Writer Mode
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读/写模式
- en: NFC-enabled Android applications can’t directly set the device in R/W mode.
    Instead, they declare the type of tags they’re interested in, and Android’s tag
    dispatch system selects and starts the matching application when it discovers
    a tag.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 启用NFC的Android应用程序不能直接将设备设置为读/写模式。相反，它们声明自己感兴趣的标签类型，当Android的标签分发系统发现标签时，选择并启动匹配的应用程序。
- en: 'The tag dispatch system both uses the tag technology (discussed shortly) and
    parses tag contents in order to decide which application to dispatch the tag to.
    The tag dispatch system uses three intent actions to notify applications about
    the discovered tag: `ACTION_NDEF_DISCOVERED`, `ACTION_TECH_DISCOVERED`, and `ACTION_TAG_DISCOVERED`.
    The `ACTION_NDEF_DISCOVERED` intent has the highest priority and is sent when
    Android discovers a tag that is formatted using the standard NFC Data Exchange
    Format (NDEF)^([[111](#ftn.ch11fn01)]) and that contains a recognized data type.
    The `ACTION_TECH_DISCOVERED` intent is sent when the scanned tag does not contain
    NDEF data or the data format is not recognized by applications that can handle
    the discovered tag technology. If no applications can handle `ACTION_NDEF_DISCOVERED`
    or `ACTION_TECH_DISCOVERED`, the `NfcService` sends the generic `ACTION_TAG_DISCOVERED`
    intent. Tag dispatch events are delivered only to activities, and therefore cannot
    be processed in the background without user interaction.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 标签分发系统既使用标签技术（稍后讨论），又解析标签内容，以决定将标签分发到哪个应用程序。标签分发系统使用三个意图动作来通知应用程序发现的标签：`ACTION_NDEF_DISCOVERED`、`ACTION_TECH_DISCOVERED`和`ACTION_TAG_DISCOVERED`。`ACTION_NDEF_DISCOVERED`意图具有最高优先级，当Android发现一个使用标准NFC数据交换格式（NDEF）格式化的标签，并且该标签包含已识别的数据类型时，便会发送该意图。`ACTION_TECH_DISCOVERED`意图则在扫描的标签不包含NDEF数据或数据格式不被能够处理已发现标签技术的应用程序所识别时发送。如果没有应用程序可以处理`ACTION_NDEF_DISCOVERED`或`ACTION_TECH_DISCOVERED`，`NfcService`会发送通用的`ACTION_TAG_DISCOVERED`意图。标签分发事件仅传递给活动，因此无法在没有用户交互的情况下在后台处理。
- en: Registering for Tag Dispatch
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册标签分发
- en: Applications register for NFC events using the standard intent filter system
    by declaring the intents that an NFC-enabled activity supports in *AndroidManifest.xml*,
    as shown in [Example 11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "Example 11-1. Manifest file of an NFC-enabled application").
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过声明NFC启用的活动所支持的意图，在*AndroidManifest.xml*中使用标准的意图过滤器系统注册NFC事件，如[示例11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "示例11-1. NFC启用应用程序的清单文件")所示。
- en: Example 11-1. Manifest file of an NFC-enabled application
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11-1. NFC启用应用程序的清单文件
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in this listing, the application first requests the `android.permission.NFC`
    permission ➊, which is required to access the NFC controller, and then declares
    an activity that handles NFC events, `NfcActivity` ➋. The activity registers three
    intent filters; one for each tag discovery event. The application declares that
    it can handle NDEF data with the *text/plain* MIME type by specifying the `mimeType`
    attribute of the `<data>` tag in the `NDEF_DISCOVERED` intent filter ➌. `NfcActivity`
    also declares that it can handle the `TECH_DISCOVERED` intent ➍, which is sent
    if the scanned tag uses one of the technologies specified in the associated metadata
    XML resource file ➏. Finally, the application requests that it be notified about
    all discovered NFC tags by adding the catch-all `TAG_DISCOVERED` intent filter
    ➎.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如该清单所示，应用程序首先请求`android.permission.NFC`权限 ➊，该权限用于访问NFC控制器，然后声明一个处理NFC事件的活动`NfcActivity`
    ➋。该活动注册了三个意图过滤器，每个过滤器对应一个标签发现事件。应用程序声明它可以通过在`NDEF_DISCOVERED`意图过滤器的`<data>`标签中指定`mimeType`属性，来处理具有*text/plain*
    MIME类型的NDEF数据 ➌。`NfcActivity`还声明它可以处理`TECH_DISCOVERED`意图 ➍，如果扫描的标签使用关联的元数据XML资源文件中指定的某种技术，则会发送此意图
    ➏。最后，应用程序通过添加通配符`TAG_DISCOVERED`意图过滤器 ➎，请求在发现所有NFC标签时得到通知。
- en: If more than one activity that supports the scanned tag is found, Android shows
    a selection dialog, allowing the user to select which activity should handle the
    tag. Applications already in the foreground can short-circuit this selection by
    calling the `NfcAdapter.enableForegroundDispatch()` method. Such an application
    will be given priority over all other matching applications and will automatically
    receive the NFC intent when it’s in the foreground.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到多个支持扫描标签的活动，Android会显示一个选择对话框，允许用户选择哪个活动处理该标签。已经在前台的应用程序可以通过调用`NfcAdapter.enableForegroundDispatch()`方法来绕过此选择。这样的应用程序将在所有其他匹配的应用程序中优先处理，并且当应用程序处于前台时，会自动接收NFC意图。
- en: Tag Technologies
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签技术
- en: A *tag technology* is an abstract term that describes a concrete NFC tag. The
    tag technology is determined by the communication protocol the tag uses, its internal
    structure, or the features it offers. For example, a tag that uses the NFC-A protocol
    (based on ISO 14443-3A)^([[112](#ftn.ch11fn02)]) for communication matches the
    *NfcA* technology, and a tag that contains NDEF-formatted data matches the *Ndef*
    technology, regardless of the underlying communication protocol. (See the `TagTechnology`
    class reference documentation^([[113](#ftn.ch11fn03)]) for a full list of tag
    technologies supported by Android.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签技术*是一个抽象术语，用于描述具体的NFC标签。标签技术由标签使用的通信协议、其内部结构或其提供的功能决定。例如，使用NFC-A协议（基于ISO
    14443-3A）进行通信的标签与*NfcA*技术匹配，而包含NDEF格式数据的标签则与*Ndef*技术匹配，无论其底层通信协议如何。（有关Android支持的所有标签技术的完整列表，请参见`TagTechnology`类参考文档。）'
- en: An activity that specifies the `TECH_DISCOVERED` intent filter must provide
    an XML resource file that in turn specifies the concrete technologies it supports
    with a `<tech-list>` element. An activity is considered a match for a tag if one
    of the tech lists it declares is a subset of the technologies supported by the
    tag. Multiple tech lists can be declared in order to match different tags, as
    shown in [Example 11-2](ch11.html#declaring_technologies_to_match_using_te "Example 11-2. Declaring
    technologies to match using tech lists").
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指定了`TECH_DISCOVERED`意图过滤器的活动必须提供一个XML资源文件，该文件进一步指定它支持的具体技术，并使用`<tech-list>`元素。
    如果一个活动声明的技术列表是标签所支持的技术的子集，则认为该活动与标签匹配。 可以声明多个技术列表，以匹配不同的标签，如[示例 11-2](ch11.html#declaring_technologies_to_match_using_te
    "示例 11-2. 使用技术列表声明匹配的技术")所示。
- en: Example 11-2. Declaring technologies to match using tech lists
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-2. 使用技术列表声明匹配的技术
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the first tech list ➊ will match tags that provide a communication interface
    compatible with ISO 14443-4 (ISO-DEP), and which are implemented using the NFC-A
    technology (usually used by NXP contactless smart cards); the second tech list
    ➋ matches tags that use the NFC-F technology (typically Felica cards). Because
    both tech lists are defined independently, our example `NfcActivity` (see [Example 11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "Example 11-1. Manifest file of an NFC-enabled application")) will be notified
    when either a contactless NXP smart card or a Felica card or tag is scanned.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个技术列表 ➊ 将匹配提供与ISO 14443-4（ISO-DEP）兼容的通信接口的标签，这些标签使用NFC-A技术实现（通常用于NXP非接触智能卡）；第二个技术列表
    ➋ 匹配使用NFC-F技术的标签（通常是Felica卡）。由于这两个技术列表是独立定义的，我们的示例`NfcActivity`（参见[示例 11-1](ch11.html#manifest_file_of_an_nfc-enabled_applicat
    "示例 11-1. 启用NFC应用程序的清单文件")）将在扫描到NXP非接触智能卡或Felica卡或标签时收到通知。
- en: Reading a Tag
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取标签
- en: After the tag dispatch system selects an activity to handle the scanned tag,
    it creates an NFC intent object and passes it to the selected activity. The activity
    can then use the `EXTRA_TAG` extra to obtain a `Tag` object representing the scanned
    tag and call its methods in order to read or write to the tag. (Tags that contain
    NDEF data also provide the `EXTRA_NDEF_MESSAGES` extra, which contains an array
    of NDEF messages parsed from the tag.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签调度系统选择一个活动来处理扫描到的标签后，它会创建一个NFC意图对象，并将其传递给选中的活动。活动可以通过`EXTRA_TAG`额外数据来获取一个表示扫描到标签的`Tag`对象，并调用其方法以读取或写入标签。（包含NDEF数据的标签还会提供`EXTRA_NDEF_MESSAGES`额外数据，其中包含从标签解析出来的NDEF消息数组。）
- en: A concrete `Tag` object representing the underlying tag technology can be obtained
    using the static `get()` method of the corresponding technology class, as shown
    in [Example 11-3](ch11.html#obtaining_a_concrete_tag_instance_from_t "Example 11-3. Obtaining
    a concrete Tag instance from the NFC intent"). If the `Tag` object does not support
    the requested technology, the `get()` method returns `null.`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相应技术类的静态`get()`方法获取表示底层标签技术的具体`Tag`对象，如[示例 11-3](ch11.html#obtaining_a_concrete_tag_instance_from_t
    "示例 11-3. 从NFC意图中获取具体的Tag实例")所示。如果`Tag`对象不支持请求的技术，`get()`方法将返回`null`。
- en: Example 11-3. Obtaining a concrete `Tag` instance from the NFC intent
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-3. 从NFC意图中获取具体的`Tag`实例
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using Reader Mode
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用阅读器模式
- en: In addition to the intent-based tag dispatch system, Android 4.4 adds a new
    method that activities can use to obtain a live `Tag` object, called reader mode.
    Reader mode guarantees that while the target activity is in the foreground, all
    other operation modes supported by the NFC controller (such as peer-to-peer and
    card emulation) are disabled. This mode is helpful when scanning an active NFC
    device, such as another Android device in host-based emulation mode, which could
    trigger point-to-point communication and thus take control away from the current
    foreground activity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于意图的标签调度系统，Android 4.4还添加了一种新的方法，活动可以用来获取一个实时的`Tag`对象，称为阅读器模式。阅读器模式确保在目标活动处于前景时，NFC控制器支持的所有其他操作模式（如点对点模式和卡片模拟模式）都会被禁用。当扫描一个活跃的NFC设备时，这种模式非常有用，比如另一台处于主机模拟模式的Android设备，它可能会触发点对点通信，从而将控制权转移给当前的前景活动。
- en: Activities can enable reader mode by calling the `enableReaderMode()` method
    of the `NfcAdapter` class,^([[114](#ftn.ch11fn04)]) as shown in [Example 11-4](ch11.html#enabling_reader_mode_and_obtaining_a_tag
    "Example 11-4. Enabling reader mode and obtaining a Tag object using ReaderCallback").
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 活动可以通过调用`NfcAdapter`类的`enableReaderMode()`方法来启用阅读器模式，如[示例 11-4](ch11.html#enabling_reader_mode_and_obtaining_a_tag
    "示例 11-4. 启用阅读器模式并使用ReaderCallback获取Tag对象")所示。
- en: Example 11-4. Enabling reader mode and obtaining a `Tag` object using `ReaderCallback`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 11-4. 启用阅读器模式并使用`ReaderCallback`获取`Tag`对象
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the activity enables reader mode when it comes to the foreground
    by calling the `enableReaderMode()` method ➊ (the activity should disable reader
    mode using the matching `disableReaderMode()` method when it leaves the foreground),
    and obtains a `Tag` instance directly (without an intermediate intent) via the
    `onTagDiscovered()` callback ➋. The `Tag` object is then used in the same way
    as in intent-based dispatch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，活动通过调用`enableReaderMode()`方法 ➊ 来启用前景模式中的阅读器模式（当活动离开前景时，应该使用相应的`disableReaderMode()`方法禁用阅读器模式），并通过`onTagDiscovered()`回调
    ➋ 直接获取一个`Tag`实例（无需中间的意图）。然后，`Tag`对象的使用方式与基于意图的调度方式相同。
- en: Peer-to-Peer Mode
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点对点模式
- en: Android implements a limited NFC P2P mode data exchange between devices using
    the proprietary NDEF push and the standard Simple NDEF Exchange Protocol (SNEP)
    protocols.^([[115](#ftn.ch11fn05)]) Android devices can exchange a single NDEF
    message with any device that supports either of these protocols, but the P2P mode
    is typically used with another Android device in order to implement the so-called
    Android Beam feature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android 实现了一种有限的 NFC P2P 模式数据交换，通过专有的 NDEF 推送和标准的简单 NDEF 交换协议（SNEP）协议进行交换。^([[115](#ftn.ch11fn05)])
    Android 设备可以与支持这两种协议的任何设备交换单个 NDEF 消息，但 P2P 模式通常与其他 Android 设备一起使用，以实现所谓的 Android
    Beam 功能。
- en: In addition to NDEF messages, Android Beam allows for the transfer of larger
    data objects, such as photos and videos, which cannot fit in a single NDEF message
    by creating a temporary Bluetooth connection between devices. This process is
    called *NFC handover* and was added in Android 4.1.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 NDEF 消息，Android Beam 还允许传输更大的数据对象，如照片和视频，这些数据无法通过单个 NDEF 消息传输。通过在设备之间创建一个临时的蓝牙连接，可以实现这一过程。这一过程称为*NFC
    交接*，并在 Android 4.1 中加入了此功能。
- en: NDEF message exchange in P2P mode is enabled by calling the `setNdefPushMessage()`
    or `setNdefPushMessageCallback()` methods of the `NfcAdapter` class. (See the
    official NFC API guide^([[116](#ftn.ch11fn06)]) for more details and sample code.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 P2P 模式下的 NDEF 消息交换是通过调用 `NfcAdapter` 类的 `setNdefPushMessage()` 或 `setNdefPushMessageCallback()`
    方法来启用的。（有关更多详情和示例代码，请参见官方的 NFC API 指南^([[116](#ftn.ch11fn06)])。）
- en: Card Emulation Mode
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡模拟模式
- en: As mentioned in “[NFC Overview](ch11.html#nfc_overview "NFC Overview")”, CE
    mode allows an Android device to emulate a contactless smart card or an NFC tag.
    In CE mode, the device receives commands over NFC, processes them, and sends replies,
    again over NFC. The component responsible for processing commands can be either
    a hardware secure element (as discussed in the next section) connected to the
    device’s NFC controller, or an Android application running on the device (when
    in host-based card emulation, HCE).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 “[NFC 概述](ch11.html#nfc_overview "NFC Overview")” 中所述，CE 模式允许 Android 设备模拟一张非接触式智能卡或
    NFC 标签。在 CE 模式下，设备通过 NFC 接收命令，处理这些命令，并通过 NFC 返回响应。负责处理命令的组件可以是一个硬件安全元件（如下一节所讨论）连接到设备的
    NFC 控制器，或者是一个运行在设备上的 Android 应用程序（当处于基于主机的卡模拟模式，HCE 时）。
- en: In the following sections, we’ll discuss secure elements in mobile devices,
    and the Android APIs that applications can use to communicate with SEs. We’ll
    also describe how Android implements HCE and demonstrate how to create an application
    that enables card emulation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论移动设备中的安全元件，以及应用程序可以用来与安全元件通信的 Android API。我们还将描述 Android 如何实现
    HCE，并展示如何创建一个使能卡模拟的应用程序。
- en: Secure Elements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全元件
- en: A *secure element (SE)* is a tamper-resistant smart card chip capable of running
    smart card applications (called *applets* or *cardlets*) with a certain level
    of security and isolation. A smart card is essentially a minimal computing environment
    on a single chip, complete with a CPU, ROM, EEPROM, RAM, and I/O port. Recent
    cards also include cryptographic co-processors that implement common algorithms
    such as AES and RSA.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *安全元件 (SE)* 是一个防篡改的智能卡芯片，能够以一定的安全性和隔离性运行智能卡应用（称为 *小程序* 或 *卡片*）。智能卡本质上是一个包含
    CPU、ROM、EEPROM、RAM 和 I/O 端口的最小计算环境。现代智能卡还包括加密协处理器，能够实现常见的算法，如 AES 和 RSA。
- en: Smart cards use various techniques to implement tamper resistance, making it
    quite hard to extract data by disassembling or analyzing the chip. Modern smart
    cards come pre-programmed with a multi-application OS that takes advantage of
    the hardware’s memory protection features to ensure that each application’s data
    is only available to itself. Application installation and (optionally) access
    is controlled by requiring the use of cryptographic keys for each operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡采用各种技术来实现防篡改，使得通过拆解或分析芯片来提取数据变得非常困难。现代智能卡预装了多应用操作系统，利用硬件的内存保护功能确保每个应用程序的数据仅对其自身可用。应用程序的安装和（可选的）访问通过要求每次操作使用加密密钥来控制。
- en: The SE can be integrated in mobile devices as a Universal Integrated Circuit
    Card (UICC, commonly known as a *SIM card*) embedded in the handset or connected
    to a SD card slot. If the device supports NFC, the SE is usually connected to
    (or embedded into) the NFC controller, making it possible to communicate with
    the SE wirelessly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SE可以集成在移动设备中，作为通用集成电路卡（UICC，通常称为*SIM卡*），嵌入在手机中或连接到SD卡槽。如果设备支持NFC，SE通常与NFC控制器连接（或嵌入其中），使得可以无线与SE通信。
- en: Smart cards have been around since the 1970s and are now used in applications
    ranging from pre-paid phone calls and transit ticketing to credit cards and VPN
    credential storage. Because an SE installed in a mobile device has equivalent
    or superior capabilities to that of a smart card, it can theoretically be used
    for any application that physical smart cards are currently used for. Additionally,
    because an SE can host multiple applications, it has the potential to replace
    the bunch of cards people use daily with a single device. Furthermore, because
    the SE can be controlled by the device’s OS, access to it can be restricted by
    requiring additional authentication (PIN, passphrase, or code signature) to enable
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 智能卡自1970年代以来就已经出现，并且现在被广泛用于从预付费电话和交通票务到信用卡和VPN凭证存储等各种应用中。由于安装在移动设备中的SE具有与智能卡等效或更强的功能，因此理论上可以用于目前智能卡所使用的任何应用程序。此外，由于SE可以托管多个应用程序，它有潜力用一个设备替代人们日常使用的多张卡片。此外，由于SE可以由设备的操作系统控制，可以通过要求额外的身份验证（如PIN码、密码短语或代码签名）来限制对其的访问。
- en: One of the main applications of SEs in mobile devices is that of emulating contactless
    payment cards, and the goal of enabling mobile payments has indeed been the driving
    force behind SE deployment. Aside from financial applications, mobile SEs could
    be used to emulate other contactless cards that are in wide use, such as access
    cards, loyalty cards, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SE在移动设备中的一个主要应用是模拟非接触支付卡，而启用移动支付的目标确实是推动SE部署的动力。除了金融应用外，移动SE还可以用于模拟其他广泛使用的非接触卡，如门禁卡、忠诚卡等。
- en: 'Mobile SEs could also be used to enhance the security of apps that deal with
    sensitive information or algorithms: The security-critical part of the app, such
    as credential storage or license verification, can be implemented inside the SE
    in order to guarantee that it’s impervious to reverse engineering and information
    extraction. Other apps that can benefit from being implemented in the SE are One
    Time Password (OTP) generators and, of course, credential storage (for shared
    secret keys, or private keys in a PKI).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 移动SE也可以用来增强处理敏感信息或算法的应用程序的安全性：应用程序的安全关键部分，如凭证存储或许可证验证，可以在SE内部实现，从而确保其不易受到逆向工程和信息提取的攻击。其他可以从SE实现中受益的应用程序包括一次性密码（OTP）生成器，当然还有凭证存储（用于共享密钥或PKI中的私钥）。
- en: While it’s possible to implement SE-enabled apps today with standard tools and
    technologies, using them in practice on current commercial Android devices isn’t
    straightforward. We’ll discuss this in detail in “[Android SE Execution Environment](ch11.html#android_se_execution_environment
    "Android SE Execution Environment")”, but let’s first explore the types of SEs
    available on mobile devices, and the level of support they have in Android.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管今天可以使用标准工具和技术实现支持SE的应用程序，但在当前的商业Android设备上实际使用它们并不简单。我们将在“[Android SE执行环境](ch11.html#android_se_execution_environment
    "Android SE执行环境")”中详细讨论这一点，但首先让我们探索一下移动设备上可用的SE类型，以及它们在Android中的支持级别。
- en: SE Form Factors in Mobile Devices
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动设备中的SE形态
- en: '[Figure 11-1](ch11.html#android_nfc_and_se_components "Figure 11-1. Android
    NFC and SE components") shows a simplified block diagram of the components of
    an Android device as they relate to NFC and SE support, including the embedded
    SE (eSE) and the UICC. We’ll refer to the components in this diagram in our discussion
    of secure elements and host-based card emulation in the rest of this chapter.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-1](ch11.html#android_nfc_and_se_components "图11-1. Android NFC和SE组件")展示了一个简化的块图，描述了与NFC和SE支持相关的Android设备组件，包括嵌入式SE（eSE）和UICC。在我们讨论本章其余部分的安全元件和基于主机的卡模拟时，将引用此图中的组件。'
- en: In the following subsections, we briefly review the types of SEs available on
    Android devices, how they’re connected to other device components, and the methods
    the OS uses to communicate with each type of SE.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们简要回顾了Android设备上可用的SE类型、它们与其他设备组件的连接方式，以及操作系统如何与每种SE进行通信。
- en: '![Android NFC and SE components](figs/web/11fig01.png.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Android NFC和SE组件](figs/web/11fig01.png.jpg)'
- en: Figure 11-1. Android NFC and SE components
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1. Android NFC和SE组件
- en: UICC
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UICC
- en: Most mobile devices today have some kind of UICC. Although UICCs are smart cards
    that can host applications, because the UICC has traditionally only been connected
    to the baseband processor (not the application processor that runs the main device
    OS), they can’t be accessed directly from Android. All communication goes through
    the Radio Interface Layer (RIL), which is essentially a proprietary IPC interface
    to the baseband.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数移动设备都配备了某种类型的UICC。虽然UICC是可以托管应用的智能卡，但由于UICC传统上只与基带处理器连接（而不是运行主设备操作系统的应用处理器），因此无法直接从Android进行访问。所有通信都通过无线接口层（RIL）进行，RIL本质上是一个专有的IPC接口，用于与基带进行通信。
- en: Communication with the UICC SE is carried out using extended AT commands (`AT+CCHO`,
    `AT+CCHC`, `AT+CGLA` as defined by 3GPP TS 27.007),^([[117](#ftn.ch11fn07)]) which
    the current Android telephony manager does not support. The SEEK for Android project^([[118](#ftn.ch11fn08)])
    provides patches to implement the needed commands, allowing for communication
    with the UICC via the SmartCard API, which is a reference implementation of the
    SIMalliance Open Mobile API specification^([[119](#ftn.ch11fn09)]) (discussed
    in “[Using the OpenMobile API](ch11.html#using_the_openmobile_api "Using the OpenMobile
    API")”). However, as with most components that talk directly to the hardware in
    Android, the RIL consists of an open source part (*rild*), and a proprietary library
    (*libXXX-ril.so*). In order to support communication with the UICC secure element,
    support must be added both to the *rild* and to the underlying proprietary library.
    The choice of whether to add that support is left to hardware vendors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与UICC SE的通信通过扩展的AT命令（`AT+CCHO`、`AT+CCHC`、`AT+CGLA`，如3GPP TS 27.007定义）进行，^([[117](#ftn.ch11fn07)])，当前的Android电话管理器不支持这些命令。Android的SEEK项目^([[118](#ftn.ch11fn08)])提供了补丁来实现所需的命令，从而通过SmartCard
    API与UICC进行通信，SmartCard API是SIMalliance开放移动API规范的参考实现^([[119](#ftn.ch11fn09)])（详见“[使用OpenMobile
    API](ch11.html#using_the_openmobile_api "Using the OpenMobile API")”）。然而，正如与Android中的大多数硬件直接通信的组件一样，RIL由一个开源部分（*rild*）和一个专有库（*libXXX-ril.so*）组成。为了支持与UICC安全元件的通信，必须同时在*rild*和底层专有库中添加支持。是否添加该支持的决定权由硬件厂商来决定。
- en: As of this writing, the SmartCard API has not been integrated into mainline
    Android (although the AOSP source tree includes an empty *packages/ apps/SmartCardService/*
    directory). However, Android devices from major vendors ship with an implementation
    of the SmartCard API, which allows communication from the UICC to third-party
    applications (subject to various access restrictions).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，SmartCard API尚未集成到主线Android中（尽管AOSP源码树中包含一个空的*packages/apps/SmartCardService/*目录）。然而，来自主要厂商的Android设备配备了SmartCard
    API的实现，允许UICC与第三方应用进行通信（受各种访问限制的约束）。
- en: The Single Wire Protocol (SWP) offers an alternative way to use the UICC as
    an SE. SWP is used to connect the UICC to a NFC controller, allowing the NFC controller
    to expose the UICC to external readers when in card emulation mode. The NFC controllers
    built into recent Nexus devices (such as the Broadcom BCM20793M in the Nexus 5)
    support SWP, but this functionality is disabled by default. (It can be enabled
    by changing the configuration file of the *libnfc-brcm* library on the Nexus 5.)
    A standard API to switch between the UICC, the embedded SE (if available), and
    HCE when in card emulation mode is currently not exposed, but the “off-host” routing
    functionality available in Android 4.4 can theoretically route commands to the
    UICC (see “[APDU Routing](ch11.html#apdu_routing "APDU Routing")” for details).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 单线协议（SWP）提供了一种将UICC用作SE的替代方式。SWP用于将UICC连接到NFC控制器，允许NFC控制器在卡模拟模式下将UICC暴露给外部读卡器。近期的Nexus设备（如Nexus
    5中的Broadcom BCM20793M）内置的NFC控制器支持SWP，但此功能默认是禁用的。（通过修改Nexus 5上*libnfc-brcm*库的配置文件，可以启用此功能。）目前没有公开的标准API来在卡模拟模式下切换UICC、嵌入式SE（如果有的话）和HCE，但Android
    4.4中可用的“离线”路由功能理论上可以将命令路由到UICC（详情请参见“[APDU路由](ch11.html#apdu_routing "APDU Routing")”）。
- en: microSD-Based SE
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于microSD的SE
- en: Another form factor for an SE is an *Advanced Security SD card (ASSD)*,^([[120](#ftn.ch11fn10)])
    which is basically an SD card with an embedded SE chip. When connected to an Android
    device with an SD card slot, running a SEEK-patched Android version, the SE can
    be accessed via the SmartCard API. However, Android devices with an SD card slot
    are becoming the exceptions rather than the norm, so it’s unlikely that ASSD Android
    support will make it to the mainstream. Additionally, even when available, recent
    Android versions treat SD cards as secondary storage devices and allow access
    to them only via a very high-level, restrictive API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: SE的另一种形式因子是*高级安全SD卡（ASSD）*，^([[120](#ftn.ch11fn10)])，它基本上是一张带有嵌入式SE芯片的SD卡。当连接到带有SD卡插槽的Android设备时，并且运行SEEK修改版的Android系统时，可以通过智能卡API访问SE。然而，带有SD卡插槽的Android设备已经成为例外而非常态，因此ASSD在Android上的支持不太可能成为主流。此外，即使在可用的情况下，最近的Android版本将SD卡视为次级存储设备，只能通过非常高层次、有限制的API进行访问。
- en: Embedded SE
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌入式SE
- en: An *embedded SE (eSE)* is not a distinct device but is usually integrated with
    the NFC controller and housed in the same enclosure. An example of an eSE is NXP’s
    PN65N chip, which combines the PN544 NFC radio controller with the P5CN072 SE
    (part of the SmartMX series).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌入式SE（eSE）*并不是一个独立的设备，而通常与NFC控制器集成在一起，并被封装在同一个外壳中。eSE的一个例子是NXP的PN65N芯片，它将PN544
    NFC无线电控制器与P5CN072 SE（智能MX系列的一部分）结合在一起。'
- en: The first mainstream Android device to feature an embedded SE was the Nexus
    S, which also introduced NFC support to Android and was built using the PN65N
    controller. Its successors, the Galaxy Nexus and the Nexus 4, also came equipped
    with an eSE. However, recent Google-branded devices, such as the Nexus 5 and Nexus
    7 (2013), have deprecated the eSE in favor of host-based card emulation and do
    not include an eSE.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款搭载嵌入式SE的主流Android设备是Nexus S，它也首次为Android引入了NFC支持，并且采用了PN65N控制器。其后继产品，Galaxy
    Nexus和Nexus 4，也都配备了eSE。然而，最近的Google品牌设备，如Nexus 5和Nexus 7（2013款），已不再使用eSE，而是采用主机卡模拟，并且不再包括eSE。
- en: 'The embedded SE is connected to the NFC controller through a SignalIn/SignalOut
    connection (S2C), standardized as NFC Wired Interface (NFC-WI),^([[121](#ftn.ch11fn11)])
    and has three modes of operation: off, wired, and virtual. In off mode, there’s
    no communication with the SE. In wired mode, the SE is visible to the Android
    OS as if it were a contactless smart card connected to the NFC reader. In virtual
    mode, the SE is visible to external readers as if the phone were a contactless
    smart card. These modes are mutually exclusive, so we can communicate with the
    SE either via the contactless interface (that is, from an external reader), or
    through the wired interface (that is, from an Android app). The next section shows
    how to use the wired mode to communicate with the eSE from an Android app.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式SE通过SignalIn/SignalOut连接（S2C）与NFC控制器连接，并标准化为NFC无线接口（NFC-WI），^([[121](#ftn.ch11fn11)])，具有三种操作模式：关闭模式、无线模式和虚拟模式。在关闭模式下，与SE没有通信。在无线模式下，SE对Android操作系统可见，就像它是一个连接到NFC读卡器的非接触式智能卡一样。在虚拟模式下，SE对外部读卡器可见，就像手机是一个非接触式智能卡。这些模式是互斥的，因此我们可以通过非接触式接口（即，从外部读卡器）或通过有线接口（即，从Android应用程序）与SE进行通信。下一节将展示如何使用有线模式从Android应用程序与eSE通信。
- en: Accessing the Embedded SE
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问嵌入式SE
- en: As of this writing, no public Android SDK API allows communication with the
    embedded SE, but recent Android versions include an optional library called *nfc_extras*,
    which offers a stable interface to the eSE. This section demonstrates how to configure
    Android to allow eSE access to certain Android applications, as well as how to
    use the *nfc_extras* library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，没有公开的Android SDK API允许与嵌入式SE进行通信，但最近的Android版本包括一个名为*nfc_extras*的可选库，提供了与eSE的稳定接口。本节将演示如何配置Android，以允许某些Android应用程序访问eSE，并展示如何使用*nfc_extras*库。
- en: Card emulation, and consequently, internal APIs for accessing the embedded SE
    were introduced in Android 2.3.4 (the version that introduced Google Wallet).
    Those APIs are hidden from SDK applications and using them required system signature
    permissions (`WRITE_SECURE_SETTINGS` or `NFCEE_ADMIN`) in Android 2.3.4 and subsequent
    2.3.x releases, as well as in the initial Android 4.0 release (API Level 14).
    A signature permission is quite restrictive because it allows only parties that
    control the platform signature keys to distribute apps that can use the eSE.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.0.4 (API Level 15) lifted this restriction by replacing the signature
    permission with signing certificate whitelisting at the OS level. While this still
    requires modifying core OS files, and thus vendor cooperation, there is no need
    to sign SE applications with the vendor key, which greatly simplifies distribution.
    Additionally, since the whitelist is maintained in a file, it can easily be updated
    using an OTA to add support for more SE applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Granting Access to the eSE
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new whitelisting access control approach is implemented by the `NfceeAccessControl`
    class and enforced by the system `NfcService`. The `NfceeAccessControl` class
    reads the whitelist from */etc/nfcee_access.xml*, which is an XML file that stores
    a list of signing certificates and package names that are allowed to access the
    eSE. Access can be granted both to all apps signed by a particular certificate’s
    private key (if no package name is specified), or to a single package (app) only.
    [Example 11-5](ch11.html#contents_of_the_nfceeunderscoreaccessdot "Example 11-5. Contents
    of the nfcee_access.xml file") shows how the contents of the *nfcee_access.xml*
    file might appear:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-5. Contents of the nfcee_access.xml file
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This configuration allows SE access to the `com.example.nfc` package ➋ if it
    is signed by the specified signing certificate ➊. On production devices, this
    file usually contains only the Google Wallet app signing certificate, thus restricting
    eSE access to Google Wallet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*As of April 2014, Google Wallet is supported only on Android 4.4 and later,
    and uses HCE rather than the eSE.*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: After an application’s signing certificate has been added to *nfcee_access.xml*,
    no permissions other than the standard NFC permission are required to access the
    eSE. In addition to whitelisting the app’s signing certificate, the *nfc_extras*
    library must be explicitly added to the app’s manifest and marked as required
    with the `<uses-library>` tag in order to enable eSE access (because the library
    is optional, it’s not loaded by default), as shown in [Example 11-6](ch11.html#adding_the_nfcunderscoreextras_library_t
    "Example 11-6. Adding the nfc_extras library to AndroidManifest.xml") at ➊.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-6. Adding the nfc_extras library to AndroidManifest.xml
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the NfcExecutionEnvironment API
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android’s eSE access API isn’t based on a standard smart card communication
    API, such as JSR 177^([[122](#ftn.ch11fn12)]) or the Open Mobile API, but instead
    offers a very basic communication interface, implemented in the `NfcExecutionEnvironment`
    class. The class has only three public methods, as shown in [Example 11-7](ch11.html#nfcexecutionenvironment_api
    "Example 11-7. NfcExecutionEnvironment API").
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-7. `NfcExecutionEnvironment` API
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple interface is sufficient to communicate with the SE, but in order
    to use it you first need to obtain an instance of the `NfcExecutionEnvironment`
    class. An instance can be obtained from the `NfcAdapterExtras` class, which is
    in turn accessed via its static `get()` method, as shown in [Example 11-8](ch11.html#using_the_nfcexecutionenvironmen-id00025
    "Example 11-8. Using the NfcExecutionEnvironment API").
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-8. Using the `NfcExecutionEnvironment` API
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we first obtain an `NfcAdapterExtras` instance ➊, and then call its `getEmbeddedExecutionEnvironment()`
    method in order to obtain an interface to the eSE ➋. To be able to communicate
    with the eSE, we first open a connection ➌, and then use the `transceive()` method
    to send a command and get a response ➍. Finally, we close the connection using
    the `close()` method ➎.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: eSE-Related Broadcasts
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An SE-enabled app needs to be notified of NFC events such as RF field detection,
    as well as of events pertaining to the eSE and the applets installed on it, such
    as applet selection via the NFC interface, in order to be able to change state
    accordingly. Because disclosure of such events to malicious applications can lead
    to leaking of sensitive information and denial of service attacks, access to eSE-related
    events must be limited to trusted applications only.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In Android, global events are implemented by using broadcasts, and applications
    can create and register broadcast receivers that receive the broadcasts the app
    is interested in. Access to eSE-related broadcasts can be controlled with standard
    Android signature-based permissions, but this approach has the disadvantage that
    only apps signed with the platform certificate can receive eSE events, thus limiting
    SE-enabled apps to those created by the device manufacturer or mobile network
    operator (MNO). To avoid this limitation, Android uses the same mechanism employed
    to control eSE access; namely, whitelisting application certificates, in order
    to control the scope of applications that can receive eSE-related broadcasts.
    Any application whose signing certificate (and optionally package name) is registered
    in *nfcee_access.xml* can receive eSE-related broadcasts by registering a receiver
    like the one shown in [Example 11-9](ch11.html#declaring_a_broadcast_receiver_for_ese-r
    "Example 11-9. Declaring a broadcast receiver for eSE-related events in AndroidManifest.xml").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-9. Declaring a broadcast receiver for eSE-related events in AndroidManifest.xml
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, Android offers notifications for lower-level communication events,
    such as RF field detection ➊➋, APDU reception ➌, and applet selection ➍, as well
    as for higher-level events, such as MIFARE sector access ➎ and EMV card removal
    ➏. (APDUs are *Application Protocol Data Units*, the basic building block of smart
    card protocols; see “[SE Communication Protocols](ch11.html#se_communication_protocols
    "SE Communication Protocols")”. The `APDU_RECIEVED` broadcast is not implemented,
    because in practice the NFC controller routes incoming APDUs directly to the eSE,
    which makes them invisible to the OS.) SE-enabled apps register for these broadcasts
    in order to be able to change their internal state or start a related activity
    when each event occurs (for example, to start a PIN entry activity when an EMV
    applet is selected). The `INTERNAL_TARGET_DESELECTED` broadcast ➐ is sent when
    card emulation is deactivated, and the `MASTER_CLEAR_NOTIFICATION` broadcast ➑
    is sent when the contents of the eSE are cleared. (Pre-HCE versions of Google
    Wallet offered users the option to clear the eSE remotely if their device was
    lost or stolen.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Android SE Execution Environment
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android SE is essentially a smart card in a different package, so most standards
    and protocols originally developed for smart cards apply. Let’s briefly review
    the most important ones.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Smart cards have traditionally been filesystem-oriented and the main role of
    their OS has been to handle file access and enforce access permissions. Newer
    cards support a virtual machine running on top of the native OS that allows for
    the execution of “platform independent” applications called applets, which use
    a well-defined runtime library to implement their functionality. While different
    implementations of this paradigm exist, by far the most popular one is the Java
    Card runtime environment (JCRE). Applets are implemented in a restricted version
    of the Java language and use a limited runtime library, which offers basic classes
    for I/O, message parsing, and cryptographic operations. While the JCRE specification^([[123](#ftn.ch11fn13)])
    fully defines the applet runtime environment, it does not specify how to load,
    initialize, and delete applets on actual physical cards (tools are only provided
    for the JCRE emulator).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Because one of the main applications of smart cards are various payment services,
    the application loading and initialization process (often referred to as *card
    personalization*) needs to be controlled, and only authorized entities should
    be able to alter the state of the card and installed applications. Visa originally
    developed a specification for securely managing applets, called Open Platform,
    which is now maintained and developed by the GlobalPlatform (GP) organization
    under the name GlobalPlatform Card Specification.^([[124](#ftn.ch11fn14)]) The
    gist of this specification is that each GP-compliant card has a mandatory *Issuer
    Security Domain (ISD)* component (informally referred to as the *Card Manager*)
    that offers a well-defined interface for card and application life cycle management.
    Executing ISD operations requires authentication using cryptographic keys saved
    on the card, and thus only an entity that knows those keys can change the state
    of the card (one of `OP_READY`, `INITIALIZED`, `SECURED`, `CARD_LOCKED`, or `TERMINATED`)
    or manage applets. Additionally, the GP card specification defines various secure
    communication protocols (called Secure Channels) that offer authentication, confidentiality,
    and message integrity when communicating with the card.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于智能卡的主要应用之一是各种支付服务，因此应用加载和初始化过程（通常称为*卡片个性化*）需要受到控制，并且只有授权实体能够更改卡片及其已安装应用程序的状态。Visa最初开发了一种用于安全管理小程序的规范，称为开放平台（Open
    Platform），该规范现在由GlobalPlatform（GP）组织以GlobalPlatform Card Specification的名义进行维护和开发。该规范的核心内容是，每个符合GP标准的卡片都有一个强制性的*发行者安全域（ISD）*组件（非正式地称为*卡片管理器*），该组件为卡片和应用生命周期管理提供了一个明确定义的接口。执行ISD操作需要使用存储在卡片上的加密密钥进行身份验证，因此，只有知道这些密钥的实体才能更改卡片的状态（如`OP_READY`、`INITIALIZED`、`SECURED`、`CARD_LOCKED`或`TERMINATED`）或管理小程序。此外，GP卡片规范定义了多种安全通信协议（称为安全通道），在与卡片通信时，提供身份验证、保密性和消息完整性。
- en: SE Communication Protocols
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SE通信协议
- en: 'As discussed in “[Using the NfcExecutionEnvironment API](ch11.html#using_the_nfcexecutionenvironment_api
    "Using the NfcExecutionEnvironment API")”, Android’s interface for communicating
    with the SE is the `byte[] transceive(byte[] command)` method of the `NfcExecutionEnvironment`
    class. The messages exchanged using this API are in practice APDUs, and their
    structure is defined in the *ISO/IEC 7816-4: Organization, security and commands
    for interchange* standard.^([[125](#ftn.ch11fn15)]) The reader (also known as
    a *Card Acceptance Device*, or *CAD*) sends command APDUs (sometimes referred
    to as *C-APDUs*) to the card, composed of a mandatory four-byte header with a
    command class (*CLA*), instruction (*INS*), and two parameters (*P1* and *P2*).
    This is followed by the optional command data length (*Lc*), the actual data,
    and finally the maximum number of response bytes expected, if any (*Le*). The
    card returns a response APDU (*R-APDU*) with a mandatory status word (*SW*, consisting
    of two bytes: *SW1* and *SW2*) and optional response data.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '如在《[使用NfcExecutionEnvironment API](ch11.html#using_the_nfcexecutionenvironment_api
    "Using the NfcExecutionEnvironment API")》中所讨论，Android与SE通信的接口是`byte[] transceive(byte[]
    command)`方法，该方法属于`NfcExecutionEnvironment`类。通过此API交换的信息实际上是APDU，它们的结构在*ISO/IEC
    7816-4: 交换的组织、安全性和命令*标准中有定义。读卡器（也称为*卡片接受设备*，或*CAD*）发送命令APDU（有时称为*C-APDU*）到卡片，命令包括一个强制性的四字节头部，其中包含命令类（*CLA*）、指令（*INS*）和两个参数（*P1*和*P2*）。接着是可选的命令数据长度（*Lc*）、实际数据，最后是最大期望响应字节数（如果有的话，*Le*）。卡片返回一个响应APDU（*R-APDU*），其包含一个强制性的状态字（*SW*，由两字节组成：*SW1*和*SW2*），以及可选的响应数据。'
- en: 'Historically, command APDU data has been limited to 255 bytes (total APDU length
    261 bytes) and response APDU data to 256 bytes (total APDU length 258 bytes).
    Recent cards and readers support extended APDUs with data length up to 65536 bytes,
    but extended APDUs are not always usable, mostly for reasons of compatibility.
    The lower-level communication between the reader and the card is carried out by
    one of several transmission protocols, the most widely used of which are T=0 (byte-oriented)
    and T=1 (block-oriented). Both are defined in *ISO 7816-3: Cards with contacts
    — Electrical interface and transmission protocols*. The APDU exchange is not completely
    protocol-agnostic, because T=0 cannot directly send response data, but only notify
    the reader of the number of available bytes. Additional command APDUs (`GET RESPONSE`)
    need to be sent in order to retrieve the response data.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '历史上，命令 APDU 数据的长度限制为 255 字节（总 APDU 长度为 261 字节），响应 APDU 数据的长度限制为 256 字节（总 APDU
    长度为 258 字节）。近年来的卡片和读卡器支持数据长度可达 65536 字节的扩展 APDU，但扩展 APDU 并不总是可用，主要是出于兼容性原因。读卡器与卡片之间的低层通信是通过多种传输协议之一来进行的，其中最常用的是
    T=0（字节导向）和 T=1（块导向）。这两者都在 *ISO 7816-3: 带接触的卡片 — 电气接口和传输协议* 中有所定义。APDU 交换并非完全与协议无关，因为
    T=0 无法直接发送响应数据，而只能通知读卡器可用字节数。需要发送额外的命令 APDU（`GET RESPONSE`）以检索响应数据。'
- en: The original ISO 7816 standards were developed for contact cards, but the same
    APDU-based communication model is used for contactless cards as well. It’s layered
    on top of the wireless transmission protocol defined by ISO/IEC 14443-4, which
    behaves much like T=1 for contact cards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 ISO 7816 标准是为接触式卡片制定的，但相同的基于 APDU 的通信模型也被用于非接触式卡片。它是建立在 ISO/IEC 14443-4
    定义的无线传输协议之上的，其行为类似于接触式卡片的 T=1。
- en: Querying the eSE Execution Environment
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询 eSE 执行环境
- en: As discussed in “[Embedded SE](ch11.html#embedded_se "Embedded SE")”, the eSE
    in the Galaxy Nexus is a chip from NXP’s SmartMX series. It runs a Java Card–compatible
    operating system and comes with a GlobalPlatform-compliant ISD. The ISD is configured
    to require authentication for most card management operations, and the authentication
    keys are, naturally, not publicly available. Additionally, a number of subsequent
    failed authentication attempts (usually 10) will lock the ISD and make it impossible
    to install or remove applets, so trying to brute-force the authentication keys
    is not an option. However, the ISD does provide some information about itself
    and the runtime environment on the card without requiring authentication in order
    to make it possible for clients to adjust their behavior dynamically and be compatible
    with different cards.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“[嵌入式 SE](ch11.html#embedded_se "Embedded SE")”中讨论的那样，Galaxy Nexus 中的 eSE
    是 NXP SmartMX 系列的芯片。它运行一个兼容 Java Card 的操作系统，并配备一个符合 GlobalPlatform 标准的 ISD。该 ISD
    被配置为需要进行身份验证才能执行大多数卡片管理操作，而身份验证密钥自然是无法公开的。此外，若发生多次身份验证失败（通常为 10 次），ISD 将被锁定，无法安装或移除小应用程序，因此暴力破解身份验证密钥不可行。然而，ISD
    确实提供了一些关于其自身及卡片运行环境的信息，无需身份验证，目的是使客户端能够动态调整其行为，并兼容不同的卡片。
- en: Because both Java Card and GlobalPlatform define a multi-application environment,
    each application needs a unique identifier called the *Application Identifier
    (AID)*. The AID consists of a 5-byte Registered Application Provider Identifier
    (RID, also called a Resource Identifier) and a Proprietary Identifier eXtension
    (PIX), which can be up to 11 bytes long. Thus, the length of an AID can be 5 to
    16 bytes long. Before being able to send commands to a particular applet, it needs
    to be made active, or selected, by issuing the `SELECT` (`CLA`=00, `INS`=A4) command
    with its AID. As all applications, the ISD is also identified by an AID, which
    varies between card manufacturers and GP implementations. We can find out the
    AID of the ISD by sending an empty `SELECT` command, which both selects the ISD
    and returns information about the card and the ISD configuration. An empty `SELECT`
    is simply a select without an AID specified, so the `SELECT` command APDU becomes
    `00 A4 04 00 00`. If we send this command using the `transcieve()` method of the
    `NfcExecutionEnvironment` class ([Example 11-8](ch11.html#using_the_nfcexecutionenvironmen-id00025
    "Example 11-8. Using the NfcExecutionEnvironment API") at ➍), the returned response
    might look like [Example 11-10](ch11.html#galaxy_nexus_eseapostrophes_response_to
    "Example 11-10. Galaxy Nexus eSE’s response to empty SELECT") at ➋ (➊ is the `SELECT`
    command).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-10. Galaxy Nexus eSE’s response to empty `SELECT`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The response includes a successful status (0x9000) and a long string of bytes.
    The format of this data is defined in “APDU Command Reference,” [Chapter 9](ch09.html
    "Chapter 9. Enterprise Security") of the GlobalPlatform Card Specification and,
    as with most things in the smart card world, is in tag-length-value (TLV) format.
    In TLV, each unit of data is described by a unique tag, followed by its length
    in bytes, and finally the actual data. Most structures are recursive, so the data
    can host another TLV structure, which in turns wraps another, and so on. The structure
    shown in [Example 11-10](ch11.html#galaxy_nexus_eseapostrophes_response_to "Example 11-10. Galaxy
    Nexus eSE’s response to empty SELECT") is called *File Control Information (FCI)*
    and in this case it wraps a Security Domain Management Data structure, which describes
    the ISD. When parsed, the FCI might look like [Example 11-11](ch11.html#parsed_fci_of_the_isd_on_the_ese_in_gala
    "Example 11-11. Parsed FCI of the ISD on the eSE in Galaxy Nexus").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-11. Parsed FCI of the ISD on the eSE in Galaxy Nexus
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the AID of the ISD is A0 00 00 00 03 00 00 00 ➊, the version of the GlobalPlatform
    implementation is 2.1.1 ➋, the supported Secure Channel protocol is SC02 ➌, and
    the last two fields of the structure contain some proprietary data about the card
    configuration (➍ and ➎). The only other GP command that doesn’t require authentication
    is `GET DATA`, which can be used to return additional data about the ISD configuration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: UICC as a Secure Element
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in “[SE Form Factors in Mobile Devices](ch11.html#se_form_factors_in_mobile_devices
    "SE Form Factors in Mobile Devices")”, the UICC in a mobile device can be used
    as a general-purpose SE when accessed using the Open Mobile API or a similar programming
    interface. This section gives a brief overview of UICCs and the applications they
    typically host, and then shows how to access the UICC via the Open Mobile API.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: SIM Cards and UICCs
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The predecessor of the UICC is the SIM card, and UICCs are still colloquially
    referred to as “SIM cards.” *SIM* stands for *Subscriber Identity Module* and
    refers to a smart card that securely stores the subscriber identifier and the
    associated key used to identify and authenticate a device to a mobile network.
    SIMs were initially used on GSM networks and the original GSM standards were later
    extended to support 3G and LTE. Because SIMs are smart cards, they conform to
    ISO-7816 standards regarding physical characteristics and electrical interface.
    The first SIM cards were the same size as “regular” smart cards (Full-size, FF),
    but by far the most popular sizes today are Mini-SIM (2FF) and Micro-SIM (3FF),
    with Nano-SIM (4FF), which was introduced in 2012, also gaining market share.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, not every smart card that fits in the SIM slot can be used in a
    mobile device, so the next question is: What makes a smart card a SIM card? Technically,
    it’s conformance to mobile communication standards such as 3GPP TS 11.11 and certification
    by the SIMalliance. In practice, it is the ability to run an application that
    allows it to communicate with the phone (referred to as *Mobile Equipment* or
    *Mobile Station* in related standards) and connect to a mobile network. While
    the original GSM standard did not distinguish between the physical smart card
    and the software required to connect to the mobile network, with the introduction
    of 3G standards, a clear distinction has been made. The physical smart card is
    referred to as a *Universal Integrated Circuit Card (UICC),* and different mobile
    network applications that run on it have been defined: GSM, CSIM, USIM, ISIM,
    and so on. A UICC can host and run more than one network application (hence the
    name *universal*), and thus can be used to connect to different networks. While
    network application functionality depends on the specific mobile network, their
    core features are quite similar: store network parameters securely and identify
    to the network, as well as authenticate the user (optionally) and store user data.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: UICC Applications
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take GSM as an example and briefly review how a network application works.
    For GSM, the main network parameters are network identity (International Mobile
    Subscriber Identity, IMSI; tied to the SIM), phone number (MSISDN, used for routing
    calls and changeable), and a shared network authentication key *Ki*. To connect
    to the network, the phone needs to authenticate and negotiate a session key. Both
    authentication and session keys are derived using *Ki*, which is also known to
    the network and looked up by IMSI. The phone sends a connection request that includes
    its IMSI, which the network uses to find the corresponding *Ki*. The network then
    uses the *Ki* to generate a challenge (*RAND*), expected challenge response (*SRES*),
    and session key *Kc*. When those parameters have been generated, the network sends
    *RAND* to the phone and the GSM application running on the SIM card comes into
    play: the mobile passes the *RAND* to the SIM card, which generates its own *SRES*
    and *Kc*. The *SRES* is sent to the network and if it matches the expected value,
    encrypted communication is established using the session key *Kc*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the security of this protocol hinges solely on the secrecy of
    the *Ki*. Because all operations involving the *Ki* are implemented inside the
    SIM card, and it never comes in direct contact with the phone or the network,
    the scheme is kept reasonably secure. Of course, security depends on the encryption
    algorithms used as well, and major weaknesses that allow intercepted GSM calls
    to be decrypted using off-the-shelf hardware were found in the original versions
    of the A5/1 stream cipher (which was initially secret).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In Android, network authentication is implemented by the baseband processor
    (more on this in “[Accessing the UICC](ch11.html#accessing_the_uicc "Accessing
    the UICC")” below) and is never directly visible to the main OS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: UICC Application Implementation and Installation
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen that UICCs need to run applications; now let’s see how those applications
    are implemented and installed. Initial smart cards were based on a filesystem
    model, where files (called *elementary files*, or *EF*) and directories (called
    *dedicated files*, or *DF*) were named with a two-byte identifier. Thus, developing
    “an application” involved selecting an ID for the DF that hosts the application’s
    files (called *ADF*), and specifying the formats and names of the EFs that store
    data. For example, the GSM application is under the *7F20* ADF, and the USIM ADF
    hosts the *EF_imsi*, *EF_keys*, *EF_sms*, and other required files.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Because practically all UICCs in use today are based on Java Card technology
    and implement GlobalPlatform card specifications, all network applications are
    implemented as Java Card applets and emulate the legacy file-based structure for
    backward compatibility. Applets are installed according to GlobalPlatform specifications
    by authenticating to the ISD and issuing `LOAD` and `INSTALL` commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: One application management feature specific to SIM cards is support for OTA
    updates via binary SMS. This functionality is not used by all carriers, but it
    allows carriers to remotely install applets on SIM cards they’ve issued. OTA is
    implemented by wrapping card commands (APDUs) in SMS T-PDUs (transport protocol
    data units), which the phone forwards to the UICC. In most UICCs, this is the
    only way to load applets on the card, even during initial personalization.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The major use case for this OTA functionality is to install and maintain SIM
    Toolkit (STK) applications that can interact with the handset via standard “proactive”
    commands (which in reality are implemented via polling), and to display menus
    or even open web pages and send SMS. Android supports STK with a dedicated STK
    system app, which is automatically disabled if the UICC card has no STK applets
    installed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the UICC
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we discussed in “[UICC Applications](ch11.html#uicc_applications "UICC Applications")”,
    mobile network–related functionality in Android, including UICC access, is implemented
    by the baseband software. The main OS (Android) is limited in what it can do with
    the UICC by the features the baseband exposes. Android supports STK applications
    and can look up and store contacts on the SIM, so it’s clear that it has internal
    support for communicating to the SIM. However, the Android security overview explicitly
    states that “low-level access to the SIM card is not available to third-party
    apps.”^([[126](#ftn.ch11fn16)]) How can we use the SIM card (UICC) as an SE then?
    Some Android builds from major vendors, most notably Samsung, provide an implementation
    of the SIMalliance Open Mobile API, and an open source implementation (for compatible
    devices) of the API is available from the SEEK for Android project. The Open Mobile
    API aims to provide a unified interface for accessing SEs on Android, including
    the UICC.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the Open Mobile API works and the cause of its limitations,
    let’s review how access to the SIM card is implemented in Android. On Android
    devices, all mobile network functionality (dialing, sending SMS, and so on) is
    provided by the baseband processor (also referred to as *modem* or *radio*). Android
    applications and system services communicate with the baseband only indirectly
    via the Radio Interface Layer (RIL) daemon (*rild*). The *rild* in turn talks
    to the actual hardware by using a manufacturer-provided RIL HAL library, which
    wraps the proprietary interface that the baseband provides. The UICC card is typically
    connected only to the baseband processor (though sometimes also to the NFC controller
    via SWP), and thus all communication needs to go through the RIL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: While the proprietary RIL implementation can always access the UICC in order
    to perform network identification and authentication, as well as read and write
    contacts and access STK applications, support for transparent APDU exchange is
    not always available. As we mentioned in [UICC](ch11.html#uicc "UICC"), the standard
    way to provide this feature is to use extended AT commands such `AT+CSIM` (Generic
    SIM access) and `AT+CGLA` (Generic UICC Logical Channel Access), but some vendors
    implement APDU exchange using proprietary extensions, so support for the necessary
    AT commands doesn’t automatically provide UICC access.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: SEEK for Android implements a resource manager service (`SmartCardService`)
    that can connect to any supported SE (eSE, ASSD, or UICC) and extensions to the
    Android telephony framework that allow for transparent APDU exchange with the
    UICC. Because access through the RIL is hardware- and HAL-dependent, you need
    both a compatible device and a build that includes the `SmartCardService` and
    related framework extensions, such as those found in most recent Samsung Galaxy
    devices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using the OpenMobile API
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OpenMobile API is relatively small and defines classes that represent the
    card reader that an SE is connected to (`Reader`), a communication session with
    an SE (`Session`), and a basic (channel 0, as per ISO 7816-4) or logical channel
    with the SE (`Channel`). The `Channel` class allows applications to exchange APDUs
    with the SE using the `transmit()` method. The entry point to the API is the `SEService`
    class, which connects to the remote resource manager service (`SmartcardService`)
    and provides a method that returns a list of `Reader` objects available on the
    device. (For more information about the OpenMobile API and the architecture of
    the `SmartcardService`, refer to the SEEK for Android Wiki.^([[127](#ftn.ch11fn17)]))
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to use the OpenMobile API, applications need to request
    the `org.simalliance.openmobileapi.SMARTCARD` permission and add the *org.simalliance.openmobileapi*
    extension library to their manifest as shown in [Example 11-12](ch11.html#androidmanifestdotxml_configuration_requ
    "Example 11-12. AndroidManifest.xml configuration required to use the OpenMobile
    API").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-12. AndroidManifest.xml configuration required to use the OpenMobile
    API
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 11-13](ch11.html#sending_a_command_to_the_first_se_using "Example 11-13. Sending
    a command to the first SE using the OpenMobile API") demonstrates how an application
    can use the OpenMobile API to connect and send a command to the first SE on the
    device.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-13. Sending a command to the first SE using the OpenMobile API
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the application first creates an `SEService` ➊ instance, which connects
    to the `SmartCardService` asynchronously and notifies the application via the
    `serviceConnected()` method (not shown) of the `SEService.CallBack` interface
    when the connection is established. The app can then get a list of the available
    SE readers using the `getReaders()` method ➋, and then open a session to the selected
    reader using the `openSession()` method ➌. If the device does not contain an eSE
    (or another form of SE besides the UICC), or the `SmartCardService` hasn’t been
    configured to use it, the list of readers contains a single `Reader` instance
    that represents the built-in UICC reader in the device. When the app has an open
    `Session` with the target SE, it calls the `openLogicalChannel()` method ➍ in
    order to obtain a `Channel`, which it then uses to send APDUs and receive responses
    using its `transmit()` method ➎.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Software Card Emulation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Software card emulation* (also referred to as *host-based card emulation*
    or *HCE*) allows commands received by the NFC controller to be delivered to the
    application processor (main OS), and to be processed by regular Android applications,
    instead of by applets installed on a hardware SE. Responses are then sent back
    to the reader via NFC, allowing an app to act as a virtual contactless smart card.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Before being officially added to the Android API, HCE was first available as
    an experimental feature of the CyanogenMod Android distribution.^([[128](#ftn.ch11fn18)])
    Beginning with version 9.1, CyanogenMod integrated a set of patches (developed
    by Doug Yeager) that unlock the HCE functionality of the popular PN544 NFC controller
    and provide a framework interface to HCE. In order to support HCE, two new tag
    technologies (`IsoPcdA` and `IsoPcdB`, representing external contactless readers
    based on NFC Type A and Type B technology, respectively) were added to the NFC
    framework. (The letters *Pcd* stand for *Proximity Coupling Device*, which is
    just another technical term for contactless reader.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IsoPcdA` and `IsoPcdB` classes reversed the role of `Tag` objects in the
    Android NFC API: because the external contactless reader is presented as a “tag,”
    “commands” you send from the phone are actually replies to the reader-initiated
    communication. Unlike the rest of Android’s NFC stack, this architecture was not
    event driven and required applications to handle blocking I/O while waiting for
    the reader to send its next command. Android 4.4 introduced a standard, event-driven
    framework for developing HCE applications, which we discuss next.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.4 HCE Architecture
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the R/W and P2P mode, which are only available to activities, HCE applications
    can work in the background and are implemented by defining a service that processes
    commands received from the external reader and returns responses. Such HCE services
    extend the `HostApduService` abstract framework class and implement its `onDeactivated()`
    and `processCommand()` methods. `HostApduService` itself is a very thin mediator
    class that enables twoway communication with the system `NfcService` by using
    `Messenger` objects.^([[129](#ftn.ch11fn19)]) For example, when the `NfcService`
    receives an APDU that needs to be routed (APDU routing is discussed in the next
    section) to a HCE service, it sends a `MSG_COMMAND_APDU` to `HostApduService`,
    which then extracts the APDU from the message and passes it to its concrete implementation
    by calling the `processCommand()` method. If `processCommand()` returns an APDU,
    `HostApduService` encapsulates it in a `MSG_RESPONSE_APDU` message and sends it
    to the `NfcService`, which in turn forwards it to the NFC controller. If the concrete
    HCE service cannot return a response APDU immediately, it returns `null` and sends
    the response later (when it is available) by calling the `sendResponseApdu()`,
    which sends the response to the `NfcService` wrapped in a `MSG_RESPONSE_APDU`
    message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: APDU Routing
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the device is in card emulation mode, the NFC controller receives all APDUs
    coming from external readers and decides whether to send them to a physical SE
    (if any), or to an HCE service based on its internal APDU routing table. The routing
    table is AID-based and is populated using the metadata SE-enabled applications
    and HCE services declared in their application manifests. When the external reader
    sends a `SELECT` command that is not directly routed to the SE, the NFC controller
    forwards it to the `NfcService`, which extracts the target AID from the command
    and searches the routing table for a matching HCE service by calling the `resolveAidPrefix()`
    method of the `RegisteredAidCache` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If a matching service is found, `NfcService` binds to it and obtains a `Messenger`
    instance, which it then uses to send subsequent APDUs (wrapped in `MSG_COMMAND_APDU`
    messages, as discussed in the previous section). For this to work, the app’s HCE
    service needs to be declared in *AndroidManifest.xml* as shown in [Example 11-14](ch11.html#declaring_a_hce_service_in_androidmanife
    "Example 11-14. Declaring a HCE service in AndroidManifest.xml").
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-14. Declaring a HCE service in AndroidManifest.xml
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The application declares its HCE service ➊ as usual, using the `<service>` tag,
    but there are a few additional requirements. First, the service must be protected
    with the `BIND_NFC_SERVICE` system signature permission ➋, to guarantee that only
    system apps (in practice, only the `NfcService`) can bind to it. Next, the service
    needs to declare an intent filter that matches the `android.nfc.cardemulation.action.HOST_APDU_SERVICE`
    action ➌ so that it can be identified as a HCE service when scanning installed
    packages, and be bound to when a matching APDU is received. Finally, the service
    must have an XML resource metadata entry under the name *android.nfc.cardemulation.host_apdu_
    service* ➍, which points to an XML resource file listing the AIDs that the service
    can handle. The contents of this file is used to build the AID routing table,
    which the NFC stack consults when it receives a `SELECT` command.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Routing for HCE Services
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For HCE applications, the XML file must include a `<host-apdu-service>` root
    element as shown in [Example 11-15](ch11.html#hce_service_aid_metadata_file "Example 11-15. HCE
    service AID metadata file").
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-15. HCE service AID metadata file
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `<host-apdu-service>` tag has a `description` attribute and a `requireDeviceUnlock`
    attribute ➊, which specifies whether the corresponding HCE service should be activated
    when the device is locked. (The device’s screen must be on for NFC to work.) The
    root element contains one or more `<aid-group>` entries ➋, which each have a `category`
    attribute ➌ and contain one or more `<aid-filter>` ➍ tags that specify an AID
    in their `name` attribute (*A0000000010101* in this example).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: An AID group defines a set of AIDs that is always handled by a particular HCE
    service. The NFC framework guarantees that if a single AID is handled by an HCE
    service, then all other AIDs in the group are also handled by the same service.
    If two or more HCE services define the same AID, the system shows a selection
    dialog letting the user choose which application should handle the incoming `SELECT`
    command. When an app is chosen, all subsequent commands are routed to it after
    the user confirms the selection by tapping on the dialog shown in [Figure 11-2](ch11.html#hce_application_selection_confirmation_d
    "Figure 11-2. HCE application selection confirmation dialog").
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Each AID group is associated with a category (specified with the `category`
    attribute), which allows the system to set a default handler per category, rather
    than per AID. An application can check if a particular service is the default
    handler for a category by calling the `isDefaultServiceForCategory()` method of
    the `CardEmulation` class, and get the selection mode for a category by calling
    the `getSelectionModeForCategory()` method. As of this writing, only two categories
    are defined: `CATEGORY_PAYMENT` and `CATEGORY_OTHER`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Android enforces a single active payment category in order to ensure that the
    user has explicitly selected which app should handle payment transactions. The
    default app for the payment category is selected in the Tap & pay screen of the
    system Settings app, as shown in [Figure 11-3](ch11.html#selecting_the_default_payment_applicatio
    "Figure 11-3. Selecting the default payment application in the Tap & pay screen").
    (See the official HCE documentation^([[130](#ftn.ch11fn20)]) for more on payment
    applications.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![HCE application selection confirmation dialog](figs/web/11fig02.png.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2. HCE application selection confirmation dialog
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting the default payment application in the Tap & pay screen](figs/web/11fig03.png.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3. Selecting the default payment application in the Tap & pay screen
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Routing for SE Applets
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a device supports HCE and also has a physical SE, a `SELECT` command sent
    by an external reader can target either an HCE service, or an applet installed
    on the SE. Because Android 4.4 directs all AIDs not listed in the AID routing
    table to the host, the AIDs of applets installed on the SE must be explicitly
    added to the NFC controller’s routing table. This is accomplished with the same
    mechanism used for registering HCE services: by adding a service entry to the
    application’s manifest, and linking it to a meta-data XML file that specifies
    a list of AIDs that should be routed to the SE. When the route is established,
    command APDUs are sent directly to the SE (which processes them and returns a
    response via the NFC controller), so the service is used only as a marker and
    provides no functionality.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The Android SDK includes a helper service (`OffHostApduService`) that can be
    used to list AIDs that should be routed directly to the SE. This `OffHostApduService`
    class defines some useful constants, but is otherwise empty. An application can
    extend it and declare the resulting service component in its manifest as shown
    in [Example 11-16](ch11.html#declaring_an_off-host_apdu_service_in_an "Example 11-16. Declaring
    an off-host APDU service in AndroidManifest.xml").
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-16. Declaring an off-host APDU service in AndroidManifest.xml
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The service declaration is similar to that of [Example 11-14](ch11.html#declaring_a_hce_service_in_androidmanife
    "Example 11-14. Declaring a HCE service in AndroidManifest.xml"), except that
    the declared intent action is *android.nfc.cardemulation.action.OFF_HOST_ APDU_SERVICE*
    ➊ and the XML metadata name is *android.nfc.cardemulation.off_host_apdu_service*
    ➋. The metadata file is also slightly different, as shown in [Example 11-17](ch11.html#off-host_apdu_service_metadata_file
    "Example 11-17. Off-host APDU service metadata file").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-17. Off-host APDU service metadata file
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the format is the same as that of an HCE service, but the root
    element of the file is `<offhost-apdu-service>` ➊ instead of `<host-apdu-service>`.
    Another subtle difference is that `<offhost-apdu-service>` does not support the
    `requireDeviceUnlock` attribute, because transactions are sent directly to the
    SE and therefore the host cannot intervene regardless of the state of the lockscreen.
    The AIDs of the applets residing on the SE (➌ and ➍) are included in a `<aid-group>`
    ➋. Those AIDs are sent directly to the NFC controller, which saves them in its
    internal routing table in order to be able to send matching APDUs directly to
    the SE, without interacting with the Android OS. If the received APDU is not in
    the NFC controller’s routing table, it forwards it to the `NfcService`, which
    sends it to the matching HCE service, or returns an error if no matches are found.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Writing an HCE Service
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the HCE service of an application has been declared in its manifest as
    shown in [Example 11-14](ch11.html#declaring_a_hce_service_in_androidmanife "Example 11-14. Declaring
    a HCE service in AndroidManifest.xml"), HCE functionality can be added by extending
    the `HostApduService` base class and implementing its abstract methods as shown
    in [Example 11-18](ch11.html#implementing_a_hostapduservice "Example 11-18. Implementing
    a HostApduService").
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-18. Implementing a `HostApduService`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the example HCE service first declares a few constants that will be helpful
    when accessing APDU data ➊ and returning a standard status result ➋. The service
    defines the `SELECT` command that is used to activate it, including the AID ➌.
    The next few constants ➍ declare the instruction class (*CLA*) and instructions
    that the service can handle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: When the HCE service receives an APDU, it passes it to the `processCommandApdu()`
    method as a byte array, which the service analyzes. If the service hasn’t been
    selected yet, the `processCommandApdu()` method checks if the APDU contains a
    `SELECT` command ➎, and sets the `selected` flag if it does. If the APDU contains
    some other command, the code checks to see if it has a class byte (*CLA*) the
    services supports ➏, and then extracts the instruction byte (*INS*) included in
    the command ➐. If the command APDU contains the `INS_CMD1` instruction ➑, the
    service extracts the *P1* and *P2* parameters, possibly parses the data included
    in the APDU (not shown), sets some internal state, and returns a success status.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If the command includes `INS_CMD2`, which in our example maps to a hypothetical
    operation that requires some time to process (for example, asymmetric key generation),
    the service starts a worker thread (not shown), and returns `null` ➒ in order
    not to block the main thread of the application. When the worker thread completes
    execution, it can return its result using the inherited `sendResponseApdu()` (defined
    in the parent `HostApduService` class). When another service or SE applet is selected,
    the system calls the `onDeactivated()` method, which should release any used resources
    before returning, but in our example simply sets the `selected` flag to `false`
    ➓.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Because an HCE service essentially parses command APDUs and returns responses,
    the programming model is very similar to that of Java Card applets. However, because
    a HCE service lives inside a regular Android application, it does not execute
    in a constrained environment and can take advantage of all available Android features.
    This makes it easy to implement complex functionality, but also impacts the security
    of HCE apps, as discussed next.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Security of HCE Applications
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because any Android application can declare an HCE service and receive and process
    APDUs, the system guarantees that a malicious application cannot inject rogue
    APDU commands into an HCE service by requiring the `BIND_NFC_SERVICE` system signature
    permission in order to bind to HCE services. Additionally, Android’s sandboxing
    model ensures that other applications cannot access sensitive data stored by the
    HCE application by reading its files or calling any data access APIs it might
    expose without permission (assuming such APIs have been properly secured, of course).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a malicious application that manages to obtain root privileges
    on a device (for example, by exploiting a privilege escalation vulnerability)
    can both inspect and inject APDUs targeted at an HCE service, and read its private
    data. The HCE application can take some measures to detect this situation, for
    example by inspecting the identity and signing certificate of the caller of its
    `processCommandApdu()` method, but such measures can ultimately be defeated given
    unconstrained access to the OS. Like all applications that store sensitive data,
    HCE applications should also take steps to protect stored data, such as by encrypting
    it on disk or by storing it in the system credential store in the case of cryptographic
    keys. Another way to protect both the code and data of HCE applications is to
    forward all received commands to a remote server, over an encrypted channel, and
    relay only its replies. However, because most of these measures are implemented
    in software, they can ultimately be disabled or bypassed by a sufficiently sophisticated
    malicious application with root access.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, hardware security elements offer physical tamper resistance, reduced
    attack surface due to their constrained functionality, and tight control over
    installed applets. Therefore, physical SEs are much harder to attack and provide
    much stronger protection of sensitive data used in typical card emulation scenarios
    like contactless payments, even when the default security guarantees of the host
    OS have been bypassed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*For a detailed discussion of the difference in security level of card emulation
    applications when implemented in secure elements as opposed to in software using
    HCE, see the “HCE vs embedded secure element” blog post series by Cem Paya (who
    worked on the original eSE-backed Google Wallet implementation).*^([[131](#ftn.ch11fn21)])'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android supports the three NFC modes: reader/writer, point-to-point, and card
    emulation. In reader/writer mode, Android devices can access NFC tags, contactless
    cards, and NFC emulation devices, while the point-to-point mode provides simple
    data exchange functionality. The card emulation mode can be backed either by a
    physical secure element (SE) such as a UICC, one that is integrated with the NFC
    controller (embedded SE), or by regular Android applications since Android 4.4\.
    Hardware security elements provide the highest security by offering physical tamper
    resistance and stringent control over SE application (typically implemented as
    Java Card applets) management. However, because the authentication keys required
    to install an application on an SE are typically controlled by a single entity
    (such as the device manufacturer or MNO), distributing SE applications can be
    problematic. Host-based card emulation (HCE), introduced in Android 4.4, makes
    it easy to develop and distribute applications that work in card emulation mode,
    but it relies solely on the OS to enforce security and therefore offers weaker
    protection of sensitive application code and data.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '^([[111](#ch11fn01)]) The NDEF format and its implementation using various
    tag technologies are described in the NFC Forum specification, available on its
    website: *[http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/](http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/)*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: ^([[112](#ch11fn02)]) Official versions of all ISO standards can be purchased
    on its website, *[http://www.iso.org/iso/home/store/catalogue_ics.htm](http://www.iso.org/iso/home/store/catalogue_ics.htm)*.
    Draft versions of standards can usually be obtained from the website of the standard
    working group.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: ^([[113](#ch11fn03)]) Google, *Android API Reference*, “TagTechnology,” *[https://developer.android.com/reference/android/nfc/tech/TagTechnology.html](https://developer.android.com/reference/android/nfc/tech/TagTechnology.html)*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: ^([[114](#ch11fn04)]) Google, *Android API Reference*, “NfcAdapter,” *[https://developer.android.com/reference/android/nfc/NfcAdapter.html](https://developer.android.com/reference/android/nfc/NfcAdapter.html)*
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: ^([[115](#ch11fn05)]) NFC Forum, “NFC Forum Technical Specifications,” *[http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/](http://nfc-forum.org/our-work/specifications-and-application-documents/specifications/nfc-forum-technical-specifications/)*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: ^([[116](#ch11fn06)]) Google, *Android API Guides*, “NFC Basics,” *[https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p](https://developer.android.com/guide/topics/connectivity/nfc/nfc.html#p2p)*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: ^([[117](#ch11fn07)]) 3GPP, *AT command set for User Equipment (UE)*, *[http://www.3gpp.org/ftp/Specs/html-info/27007.htm](http://www.3gpp.org/ftp/Specs/html-info/27007.htm)*
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: ^([[118](#ch11fn08)]) “Secure Element Evaluation Kit for the Android platform,”
    *[https://code.google.com/p/seek-for-android/](https://code.google.com/p/seek-for-android/)*
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: ^([[119](#ch11fn09)]) SIMalliance Limited, *Open Mobile API Specification v2.05*,
    *[http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&fileID=1392314878580](http://www.simalliance.org/en?t=/documentManager/sfdoc.file.supply&fileID=1392314878580)*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '^([[120](#ch11fn10)]) SD Association, “Advanced Security SD Card: ASSD,” *[https://www.sdcard.org/developers/overview/ASSD/](https://www.sdcard.org/developers/overview/ASSD/)*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '^([[121](#ch11fn11)]) ECMA International, *ECMA-373: Near Field Communication
    Wired Interface (NFC-WI)*, *[http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-373.pdf)*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '^([[122](#ch11fn12)]) Oracle, “JSR 177: Security and Trust Services API for
    J2METM,” *[https://jcp.org/en/jsr/detail?id=177](https://jcp.org/en/jsr/detail?id=177)*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: ^([[123](#ch11fn13)]) Oracle, “Java Card Classic Platform Specification 3.0.4,”
    *[http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html](http://www.oracle.com/technetwork/java/javacard/specs-jsp-136430.html)*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: ^([[124](#ch11fn14)]) GlobalPlatform, “Card Specifications,” *[http://www.globalplatform.org/specificationscard.asp](http://www.globalplatform.org/specificationscard.asp)*
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '^([[125](#ch11fn15)]) A summary of ISO 7816 and other smart card-related standards
    is available on CardWerk’s website: *[http://www.cardwerk.com/smartcards/smartcard_standards.aspx](http://www.cardwerk.com/smartcards/smartcard_standards.aspx)*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: ^([[126](#ch11fn16)]) Google, *Android Security Overview*, “SIM Card Access,”
    *[https://source.android.com/devices/tech/security/#sim-card-access](https://source.android.com/devices/tech/security/#sim-card-access)*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: ^([[127](#ch11fn17)]) *SEEK for Android*, “SmartCardAPI*,” [https://code.google.com/p/seek-for-android/wiki/SmartcardAPI](https://code.google.com/p/seek-for-android/wiki/SmartcardAPI)*
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: ^([[128](#ch11fn18)]) CyanogenMod*, [http://www.cyanogenmod.org/](http://www.cyanogenmod.org/)*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: ^([[129](#ch11fn19)]) Google, *Android API Reference*, “Messenger,” *[https://developer.android.com/reference/android/os/Messenger.html](https://developer.android.com/reference/android/os/Messenger.html)*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: ^([[130](#ch11fn20)]) Google*, Host-based Card Emulation*, “Payment Applications,”
    *[https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps](https://developer.android.com/guide/topics/connectivity/nfc/hce.html#PaymentApps)*
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ^([[131](#ch11fn21)]) Cem Paya*, Random Oracle*, “HCE vs embedded secure element,”
    parts I to VI, *[http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/](http://randomoracle.wordpress.com/2014/03/08/hce-vs-embedded-secure-element-comparing-risks-part-i/)*
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
