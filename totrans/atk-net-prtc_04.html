<html><head></head><body>
<h2 class="h2a" id="ch04"><span epub:type="pagebreak" id="page_63"/><strong><span class="big">4</span></strong><br/><strong>ADVANCED APPLICATION TRAFFIC CAPTURE</strong></h2>&#13;
<p class="noindent_first">Usually, the network traffic-capturing techniques you learned in <a href="../Text/ch02.xhtml#ch02">Chapter 2</a> should suffice, but occasionally you’ll encounter tricky situations that require more advanced ways to capture network traffic. Sometimes, the challenge is an embedded platform that can only be configured with the Dynamic Host Configuration Protocol (DHCP); other times, there may be a network that offers you little control unless you’re directly connected to it.</p>&#13;
<p class="indent">Most of the advanced traffic-capturing techniques discussed in this chapter use existing network infrastructure and protocols to redirect traffic. None of the techniques require specialty hardware; all you’ll need are software packages commonly found on various operating systems.</p>&#13;
<h3 class="h3" id="ch00lev1sec92"><span epub:type="pagebreak" id="page_64"/><strong>Rerouting Traffic</strong></h3>&#13;
<p class="noindent">IP is a <em>routed</em> protocol; that is, none of the nodes on the network need to know the exact location of any other nodes. Instead, when one node wants to send traffic to another node that it isn’t directly connected to, it sends the traffic to a <em>gateway</em> node, which forwards the traffic to the destination. A gateway is also commonly called a <em>router</em>, a device that routes traffic from one location to another.</p>&#13;
<p class="indent">For example, in <a href="../Text/ch04.xhtml#ch4fig1">Figure 4-1</a>, the client 192.168.56.10 is trying to send traffic to the server 10.1.1.10, but the client doesn’t have a direct connection to the server. It first sends traffic destined for the server to Router A. In turn, Router A sends the traffic to Router B, which has a direct connection to the target server; Router B passes the traffic on to its final destination.</p>&#13;
<p class="indent">As with all nodes, the gateway node doesn’t know the traffic’s exact destination, so it looks up the appropriate next gateway to send to. In this case, Routers A and B only know about the two networks they are directly connected to. To get from the client to the server, the traffic must be routed.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig1"/><em>Figure 4-1: An example of routed traffic</em></p>&#13;
<h4 class="h4" id="ch00lev1sec93"><strong><em>Using Traceroute</em></strong></h4>&#13;
<p class="noindent">When tracing a route, you attempt to map the route that the IP traffic will take to a particular destination. Most operating systems have built-in tools to perform a trace, such as <code>traceroute</code> on most Unix-like platforms and <code>tracert</code> on Windows.</p>&#13;
<p class="indent"><a href="../Text/ch04.xhtml#ch4list1">Listing 4-1</a> shows the result of tracing the route to <em><a href="http://www.google.com">www.google.com</a></em> from a home internet connection.</p>&#13;
<pre>C:\Users\user&gt;tracert www.google.com<br/><br/>Tracing route to www.google.com [173.194.34.176]<br/>over a maximum of 30 hops:<br/><br/>  1     2 ms     2 ms     2 ms  home.local [192.168.1.254]<br/>  2    15 ms    15 ms    15 ms  217.32.146.64<br/>  3    88 ms    15 ms    15 ms  217.32.146.110<br/>  4    16 ms    16 ms    15 ms  217.32.147.194<br/>  5    26 ms    15 ms    15 ms  217.41.168.79<br/>  6    16 ms    26 ms    16 ms  217.41.168.107<span epub:type="pagebreak" id="page_65"/><br/>  7    26 ms    15 ms    15 ms  109.159.249.94<br/>  8    18 ms    16 ms    15 ms  109.159.249.17<br/>  9    17 ms    28 ms    16 ms  62.6.201.173<br/> 10    17 ms    16 ms    16 ms  195.99.126.105<br/> 11    17 ms    17 ms    16 ms  209.85.252.188<br/> 12    17 ms    17 ms    17 ms  209.85.253.175<br/> 13    27 ms    17 ms    17 ms  lhr14s22-in-f16.1e100.net [173.194.34.176]</pre>&#13;
<p class="listing"><a id="ch4list1"/><em>Listing 4-1: Traceroute to</em> <a href="http://www.google.com">www.google.com</a> <em>using the <code><span class="codeitalic">tracert</code></span> tool</em></p>&#13;
<p class="indent">Each numbered line of output (1, 2, and so on) represents a unique gateway routing traffic to the ultimate destination. The output refers to a maximum number of <em>hops</em>. A single hop represents the network between each gateway in the entire route. For example, there’s a hop between your machine and the first router, another between that router and the next, and hops all the way to the final destination. If the maximum hop count is exceeded, the traceroute process will stop probing for more routers. The maximum hop can be specified to the trace route tool command line; specify <code>-h NUM</code> on Windows and <code>-m NUM</code> on Unix-style systems.(The output also shows the round-trip time from the machine performing the traceroute and the discovered node.)</p>&#13;
<h4 class="h4" id="ch00lev1sec94"><strong><em>Routing Tables</em></strong></h4>&#13;
<p class="noindent">The OS uses <em>routing tables</em> to figure out which gateways to send traffic to. A routing table contains a list of destination networks and the gateway to route traffic to. If a network is directly connected to the node sending the network traffic, no gateway is required, and the network traffic can be transmitted directly on the local network.</p>&#13;
<p class="indent">You can view your computer’s routing table by entering the command <code>netstat -r</code> on most Unix-like systems or <code>route print</code> on Windows. <a href="../Text/ch04.xhtml#ch4list2">Listing 4-2</a> shows the output from Windows when you execute this command.</p>&#13;
<p class="programs1">&gt; <strong>route print</strong></p>&#13;
<pre>   IPv4 Route Table<br/>   =============================================================================<br/>   Active Routes:<br/>   Network Destination           Netmask         Gateway      Interface   Metric<br/><span class="ent">➊</span>             0.0.0.0           0.0.0.0   192.168.1.254   192.168.1.72       10<br/>             127.0.0.0         255.0.0.0         On-link      127.0.0.1      306<br/>             127.0.0.1   255.255.255.255         On-link      127.0.0.1      306<br/>       127.255.255.255   255.255.255.255         On-link      127.0.0.1      306<br/>           192.168.1.0     255.255.255.0         On-link   192.168.1.72      266<br/>          192.168.1.72   255.255.255.255         On-link   192.168.1.72      266<br/>         192.168.1.255   255.255.255.255         On-link   192.168.1.72      266<br/>             224.0.0.0         240.0.0.0         On-link      127.0.0.1      306<br/>             224.0.0.0         240.0.0.0         On-link   192.168.56.1      276<br/>             224.0.0.0         240.0.0.0         On-link   192.168.1.72      266<br/>       255.255.255.255   255.255.255.255         On-link      127.0.0.1      306<br/>       255.255.255.255   255.255.255.255         On-link   192.168.56.1      276<br/><span epub:type="pagebreak" id="page_66"/><br/>       255.255.255.255   255.255.255.255         On-link   192.168.1.72      266<br/>   =============================================================================</pre>&#13;
<p class="listing"><a id="ch4list2"/><em>Listing 4-2: Example routing table output</em></p>&#13;
<p class="indent">As mentioned earlier, one reason routing is used is so that nodes don’t need to know the location of all other nodes on the network. But what happens to traffic when the gateway responsible for communicating with the destination network isn’t known? In that case, it’s common for the routing table to forward all unknown traffic to a <em>default gateway</em>. You can see the default gateway at <span class="ent">➊</span>, where the network destination is 0.0.0.0. This destination is a placeholder for the default gateway, which simplifies the management of the routing table. By using a placeholder, the table doesn’t need to be changed if the network configuration changes, such as through a DHCP configuration. Traffic sent to any destination that has no known matching route will be sent to the gateway registered for the 0.0.0.0 placeholder address.</p>&#13;
<p class="indent">How can you use routing to your advantage? Let’s consider an embedded system in which the operating system and hardware come as one single device. You might not be able to influence the network configuration in an embedded system as you might not even have access to the underlying operating system, but if you can present your capturing device as a gateway between the system generating the traffic and its ultimate destination, you can capture the traffic on that system.</p>&#13;
<p class="indent">The following sections discuss ways to configure an OS to act as a gateway to facilitate traffic capture.</p>&#13;
<h3 class="h3" id="ch00lev1sec95"><strong>Configuring a Router</strong></h3>&#13;
<p class="noindent">By default, most operating systems do not route traffic directly between network interfaces. This is mainly to prevent someone on one side of the route from communicating directly with the network addresses on the other side. If routing is not enabled in the OS configuration, any traffic sent to one of the machine’s network interfaces that needs to be routed is instead dropped or an error message is sent to the sender. The default configuration is very important for security: imagine the implications if the router controlling your connection to the internet routed traffic from the internet directly to your private network.</p>&#13;
<p class="indent">Therefore, to enable an OS to perform routing, you need to make some configuration changes as an administrator. Although each OS has different ways of enabling routing, one aspect remains constant: you’ll need at least two separate network interfaces installed in your computer to act as a router. In addition, you’ll need routes on both sides of the gateway for routing to function correctly. If the destination doesn’t have a corresponding route back to the source device, communication might not work as expected. Once routing is enabled, you can configure the network devices <span epub:type="pagebreak" id="page_67"/>to forward traffic via your new router. By running a tool such as Wireshark on the router, you can capture traffic as it’s forwarded between the two network interfaces you configured.</p>&#13;
<h4 class="h4" id="ch00lev1sec96"><strong><em>Enabling Routing on Windows</em></strong></h4>&#13;
<p class="noindent">By default, Windows does not enable routing between network interfaces. To enable routing on Windows, you need to modify the system registry. You can do this by using a GUI registry editor, but the easiest way is to run the following command as an administrator from the command prompt:</p>&#13;
<pre>C&gt; <span class="codestrong">reg add HKLM\System\CurrentControlSet\Services\Tcpip\Parameters ^</span><br/>    <span class="codestrong">/v IPEnableRouter /t REG_DWORD /d 1</span></pre>&#13;
<p class="indent">To turn off routing after you’ve finished capturing traffic, enter the following command:</p>&#13;
<pre>C&gt; <span class="codestrong">reg add HKLM\System\CurrentControlSet\Services\Tcpip\Parameters ^</span><br/>    <span class="codestrong">/v IPEnableRouter /t REG_DWORD /d 0</span></pre>&#13;
<p class="indent">You’ll also need to reboot between command changes.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Be very careful when you’re modifying the Windows registry. Incorrect changes could completely break Windows and prevent it from booting! Be sure to make a system backup using a utility like the built-in Windows backup tool before performing any dangerous changes.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec97"><strong><em>Enabling Routing on *nix</em></strong></h4>&#13;
<p class="noindent">To enable routing on Unix-like operating systems, you simply change the IP routing system setting using the <code>sysctl</code> command. (Note that the instructions for doing so aren’t necessarily consistent between systems, but you should be able to easily find specific instructions.)</p>&#13;
<p class="indent">To enable routing on Linux for IPv4, enter the following command as root (no need to reboot; the change is immediate):</p>&#13;
<pre># <span class="codestrong">sysctl net.ipv4.conf.all.forwarding=1</span></pre>&#13;
<p class="indent">To enable IPv6 routing on Linux, enter this:</p>&#13;
<pre># <span class="codestrong">sysctl net.ipv6.conf.all.forwarding=1</span></pre>&#13;
<p class="indent">You can revert the routing configuration by changing <code>1</code> to <code>0</code> in the previous commands.</p>&#13;
<p class="indent">To enable routing on macOS, enter the following:</p>&#13;
<pre>&gt; <span class="codestrong">sysctl -w net.inet.ip.forwarding=1</span></pre>&#13;
<h3 class="h3" id="ch00lev1sec98"><span epub:type="pagebreak" id="page_68"/><strong>Network Address Translation</strong></h3>&#13;
<p class="noindent">When trying to capture traffic, you may find that you can capture outbound traffic but not returning traffic. The reason is that an upstream router doesn’t know the route to the original source network; therefore, it either drops the traffic entirely or forwards it to an unrelated network. You can mitigate this situation by using <em>Network Address Translation (NAT)</em>, a technique that modifies the source and destination address information of IP and higher-layer protocols, such as TCP. NAT is used extensively to extend the limited IPv4 address space by hiding multiple devices behind a single public IP address.</p>&#13;
<p class="indent">NAT can make network configuration and security easier, too. When NAT is turned on, you can run as many devices behind a single NAT IP address as you like and manage only that public IP address.</p>&#13;
<p class="indent">Two types of NAT are common today: <em>Source NAT (SNAT)</em> and <em>Destination NAT (DNAT)</em>. The differences between the two relate to which address is modified during the NAT processing of the network traffic. SNAT (also called <em>masquerading</em>) changes the IP source address information; DNAT changes the destination address.</p>&#13;
<h4 class="h4" id="ch00lev1sec99"><strong><em>Enabling SNAT</em></strong></h4>&#13;
<p class="noindent">When you want a router to hide multiple machines behind a single IP address, you use SNAT. When SNAT is turned on, as traffic is routed across the external network interface, the source IP address in the packets is rewritten to match the single IP address made available by SNAT.</p>&#13;
<p class="indent">It can be useful to implement SNAT when you want to route traffic to a network that you don’t control because, as you’ll recall, both nodes on the network must have appropriate routing information for network traffic to be sent between the nodes. In the worst case, if the routing information is incorrect, traffic will flow in only one direction. Even in the best case, it’s likely that you would be able to capture traffic only in one direction; the other direction would be routed through an alternative path.</p>&#13;
<p class="indent">SNAT addresses this potential problem by changing the source address of the traffic to an IP address that the destination node can route to—typically, the one assigned to the external interface of the router. Thus, the destination node can send traffic back in the direction of the router. <a href="../Text/ch04.xhtml#ch4fig2">Figure 4-2</a> shows a simple example of SNAT.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig2"/><em>Figure 4-2: An example of SNAT from a client to a server</em></p>&#13;
<p class="indent">When the client wants to send a packet to a server on a different network, it sends it to the router that has been configured with SNAT. When <span epub:type="pagebreak" id="page_69"/>the router receives the packet from the client, the source address is the client’s (10.0.0.1) and the destination is the server (the resolved address of <em><a href="http://domain.com">domain.com</a></em>). It’s at this point that SNAT is used: the router modifies the source address of the packet to its own (1.1.1.1) and then forwards the packet to the server.</p>&#13;
<p class="indent">When the server receives this packet, it assumes the packet came from the router; so, when it wants to send a packet back, it sends the packet to 1.1.1.1. The router receives the packet, determines it came from an existing NAT connection (based on destination address and port numbers), and reverts the address change, converting 1.1.1.1 back to the original client address of 10.0.0.1. Finally, the packet can be forwarded back to the original client without the server needing to know about the client or how to route to its network.</p>&#13;
<h4 class="h4" id="ch00lev1sec100"><strong><em>Configuring SNAT on Linux</em></strong></h4>&#13;
<p class="noindent">Although you can configure SNAT on Windows and macOS using Internet Connection Sharing, I’ll only provide details on how to configure SNAT on Linux because it’s the easiest platform to describe and the most flexible when it comes to network configuration.</p>&#13;
<p class="indent">Before configuring SNAT, you need to do the following:</p>&#13;
<p class="bullt">• Enable IP routing as described earlier in this chapter.</p>&#13;
<p class="bull">• Find the name of the outbound network interface on which you want to configure SNAT. You can do so by using the <code>ifconfig</code> command. The outbound interface might be named something like <code>eth0</code>.</p>&#13;
<p class="bullb">• Note the IP address associated with the outbound interface when you use <code>ifconfig</code>.</p>&#13;
<p class="indent">Now you can configure the NAT rules using the <code>iptables</code>. (The <code>iptables</code> command is most likely already installed on your Linux distribution.) But first, flush any existing NAT rules in <code>iptables</code> by entering the following command as the root user:</p>&#13;
<pre># <span class="codestrong">iptables -t nat -F</span></pre>&#13;
<p class="indent">If the outbound network interface has a fixed address, run the following commands as root to enable SNAT. Replace <code><span class="codeitalic">INTNAME</code></span> with the name of your outbound interface and <code><span class="codeitalic">INTIP</code></span> with the IP address assigned to that interface.</p>&#13;
<pre># iptables -t nat -A POSTROUTING -o <span class="codeitalic">INTNAME</span> -j SNAT --to <span class="codeitalic">INTIP</span></pre>&#13;
<p class="indent">However, if the IP address is configured dynamically (perhaps using DHCP or a dial-up connection), use the following command to automatically determine the outbound IP address:</p>&#13;
<pre># iptables -t nat -A POSTROUTING -o <span class="codeitalic">INTNAME</span> -j MASQUERADE</pre>&#13;
<h4 class="h4" id="ch00lev1sec101"><span epub:type="pagebreak" id="page_70"/><strong><em>Enabling DNAT</em></strong></h4>&#13;
<p class="noindent">DNAT is useful if you want to redirect traffic to a proxy or other service to terminate it, or before forwarding the traffic to its original destination. DNAT rewrites the destination IP address, and optionally, the destination port. You can use DNAT to redirect specific traffic to a different destination, as shown in <a href="../Text/ch04.xhtml#ch4fig3">Figure 4-3</a>, which illustrates traffic being redirected from both the router and the server to a proxy at 192.168.0.10 to perform a man-in-the-middle analysis.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig3"/><em>Figure 4-3: An example of DNAT to a proxy</em></p>&#13;
<p class="indent"><a href="../Text/ch04.xhtml#ch4fig3">Figure 4-3</a> shows a client application sending traffic through a router that is destined for <em><a href="http://domain.com">domain.com</a></em> on port 1234. When a packet is received at the router, that router would normally just forward the packet to the original destination. But because DNAT is used to change the packet’s destination address and port to 192.168.0.10:8888, the router will apply its forwarding rules and send the packet to a proxy machine that can capture the traffic. The proxy then establishes a new connection to the server and forwards any packets sent from the client to the server. All traffic between the original client and the server can be captured and manipulated.</p>&#13;
<p class="indent">Configuring DNAT depends on the OS the router is running. (If your router is running Windows, you’re probably out of luck because the functionality required to support it isn’t exposed to the user.) Setup varies considerably between different versions of Unix-like operating systems and macOS, so I’ll only show you how to configure DNAT on Linux. First, flush any existing NAT rules by entering the following command:</p>&#13;
<pre># <span class="codestrong">iptables -t nat -F</span></pre>&#13;
<p class="indent">Next, run the following command as the root user, replacing <code><span class="codeitalic">ORIGIP</code></span> (originating IP) with the IP address to match traffic to and <code><span class="codeitalic">NEWIP</code></span> with the new destination IP address you want that traffic to go to.</p>&#13;
<pre><span epub:type="pagebreak" id="page_71"/><br/># iptables -t nat -A PREROUTING -d <span class="codeitalic">ORIGIP</span> -j DNAT --to-destination <span class="codeitalic">NEWIP</span></pre>&#13;
<p class="indent">The new NAT rule will redirect any packet routed to <code><span class="codeitalic">ORIGIP</code></span> to <code><span class="codeitalic">NEWIP</code></span>. (Because the DNAT occurs prior to the normal routing rules on Linux, it’s safe to choose a local network address; the DNAT rule will not affect traffic sent directly from Linux.) To apply the rule only to a specific TCP or UDP, change the command:</p>&#13;
<pre>iptables -t nat -A PREROUTING -p <span class="codeitalic">PROTO</span> -d <span class="codeitalic">ORIGIP</span> --dport <span class="codeitalic">ORIGPORT</span> -j DNAT \<br/>    --to-destination <span class="codeitalic">NEWIP</span>:<span class="codeitalic">NEWPORT</span></pre>&#13;
<p class="indent">The placeholder <code><span class="codeitalic">PROTO</code></span> (for protocol) should be either <code>tcp</code> or <code>udp</code> depending on the IP protocol being redirected using the DNAT rule. The values for <code><span class="codeitalic">ORIGIP</code></span> (original IP) and <code><span class="codeitalic">NEWIP</code></span> are the same as earlier.</p>&#13;
<p class="indent">You can also configure <code><span class="codeitalic">ORIGPORT</code></span> (the original port) and <code><span class="codeitalic">NEWPORT</code></span> if you want to change the destination port. If <code><span class="codeitalic">NEWPORT</code></span> is not specified, only the IP address will be changed.</p>&#13;
<h3 class="h3" id="ch00lev1sec102"><strong>Forwarding Traffic to a Gateway</strong></h3>&#13;
<p class="noindent">You’ve set up your gateway device to capture and modify traffic. Everything appears to be working properly, but there’s a problem: you can’t easily change the network configuration of the device you want to capture. Also, you have limited ability to change the network configuration the device is connected to. You need some way to reconfigure or trick the sending device into forwarding traffic through your gateway. You could accomplish this by exploiting the local network by spoofing packets for either DHCP or <em>Address Resolution Protocol (ARP)</em>.</p>&#13;
<h4 class="h4" id="ch00lev1sec103"><strong><em>DHCP Spoofing</em></strong></h4>&#13;
<p class="noindent">DHCP is designed to run on IP networks to distribute network configuration information to nodes automatically. Therefore, if we can spoof DHCP traffic, we can change a node’s network configuration remotely. When DHCP is used, the network configuration pushed to a node can include an IP address as well as the default gateway, routing tables, the default DNS servers, and even additional custom parameters. If the device you want to test uses DHCP to configure its network interface, this flexibility makes it very easy to supply a custom configuration that will allow easy network traffic capture.</p>&#13;
<p class="indent">DHCP uses the UDP protocol to send requests to and from a DHCP service on the local network. Four types of DHCP packets are sent when negotiating the network configuration:</p>&#13;
<p class="noindent1t"><strong>Discover</strong> Sent to all nodes on the IP network to discover a DHCP server</p>&#13;
<p class="noindent1"><strong>Offer</strong> Sent by the DHCP server to the node that sent the discovery packet to offer a network configuration</p>&#13;
<p class="noindent1"><span epub:type="pagebreak" id="page_72"/><strong>Request</strong> Sent by the originating node to confirm its acceptance of the offer</p>&#13;
<p class="noindent1b"><strong>Acknowledgment</strong> Sent by the server to confirm completion of the configuration</p>&#13;
<p class="indent">The interesting aspect of DHCP is that it uses an unauthenticated, connectionless protocol to perform configuration. Even if an existing DHCP server is on a network, you may be able to spoof the configuration process and change the node’s network configuration, including the default gateway address, to one you control. This is called <em>DHCP spoofing</em>.</p>&#13;
<p class="indent">To perform DHCP spoofing, we’ll use <em>Ettercap</em>, a free tool that’s available on most operating systems (although Windows isn’t officially supported).</p>&#13;
<ol>&#13;
<li><p class="noindent">On Linux, start Ettercap in graphical mode as the root user:</p>&#13;
<pre># <span class="codestrong">ettercap -G</span></pre>&#13;
<p class="noindent">You should see the Ettercap GUI, as shown in <a href="../Text/ch04.xhtml#ch4fig4">Figure 4-4</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig4"/><em>Figure 4-4: The main Ettercap GUI</em></p>&#13;
</li>&#13;
<li><p class="noindent">Configure Ettercap’s sniffing mode by selecting <strong>Sniff</strong> ▸ <strong>Unified Sniffing</strong>.</p></li>&#13;
<li><span epub:type="pagebreak" id="page_73"/><p class="noindent">The dialog shown in <a href="../Text/ch04.xhtml#ch4fig5">Figure 4-5</a> should prompt you to select the network interface you want to sniff on. Select the interface connected to the network you want to perform DHCP spoofing on. (Make sure the network interface’s network is configured correctly because Ettercap will automatically send the interface’s configured IP address as the DHCP default gateway.)</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig5"/><em>Figure 4-5: Selecting the sniffing interface</em></p></li>&#13;
<li><p class="noindent">Enable DHCP spoofing by choosing <strong>Mitm</strong> ▸ <strong>Dhcp spoofing</strong>. The dialog shown in <a href="../Text/ch04.xhtml#ch4fig6">Figure 4-6</a> should appear, allowing you to configure the DHCP spoofing options.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig6"/><em>Figure 4-6: Configuring DHCP spoofing</em></p></li>&#13;
<li><p class="noindent">The IP Pool field sets the range of IP addresses to hand out for spoofing DHCP requests. Supply a range of IP addresses that you configured for the network interface that is capturing traffic. For example, in <a href="../Text/ch04.xhtml#ch4fig6">Figure 4-6</a>, the IP Pool value is set to 10.0.0.10-50 (the dash indicates all addresses inclusive of each value), so we’ll hand out IPs from 10.0.0.10 to 10.0.0.50 inclusive. Configure the Netmask to match your network interface’s netmask to prevent conflicts. Specify a DNS server IP of your choice.</p></li>&#13;
<li><p class="noindent">Start sniffing by choosing <strong>Start</strong> ▸ <strong>Start sniffing</strong>. If DHCP spoofing is successful on the device, the Ettercap log window should look like <a href="../Text/ch04.xhtml#ch4fig7">Figure 4-7</a>. The crucial line is <code>fake ACK</code> sent by Ettercap in response to the DHCP request.</p></li>&#13;
</ol>&#13;
<div class="image"><span epub:type="pagebreak" id="page_74"/><img alt="image" src="../Images/f04-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig7"/><em>Figure 4-7: Successful DHCP spoofing</em></p>&#13;
<p class="indent">That’s all there is to DHCP spoofing with Ettercap. It can be very powerful if you don’t have any other option and a DHCP server is already on the network you’re trying to attack.</p>&#13;
<h4 class="h4" id="ch00lev1sec104"><strong><em>ARP Poisoning</em></strong></h4>&#13;
<p class="noindent">ARP is critical to the operation of IP networks running on Ethernet because ARP finds the Ethernet address for a given IP address. Without ARP, it would be very difficult to communicate IP traffic efficiently over Ethernet. Here’s how ARP works: when one node wants to communicate with another on the same Ethernet network, it must be able to map the IP address to an Ethernet MAC address (which is how Ethernet knows the destination node to send traffic to). The node generates an ARP request packet (see <a href="../Text/ch04.xhtml#ch4fig8">Figure 4-8</a>) containing the node’s 6-byte Ethernet MAC address, its current IP address, and the target node’s IP address. The packet is transmitted on the Ethernet network with a destination MAC address of ff:ff:ff:ff:ff:ff, which is the defined broadcast address. Normally, an Ethernet device only processes packets with a destination address that matches its address, but if it receives a packet with the destination MAC address set to the broadcast address, it will process it, too.</p>&#13;
<p class="indent">If one of the recipients of this broadcasted message has been assigned the target IP address, it can now return an ARP response, as shown in <a href="../Text/ch04.xhtml#ch4fig9">Figure 4-9</a>. This response is almost exactly the same as the request except the sender and target fields are reversed. Because the sender’s IP address should correspond to the original requested target IP address, the original <span epub:type="pagebreak" id="page_75"/>requestor can now extract the sender’s MAC address and remember it for future network communication without having to resend the ARP request.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig8"/><em>Figure 4-8: An example ARP request packet</em></p>&#13;
<div class="image"><img alt="image" src="../Images/f04-09.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig9"/><em>Figure 4-9: An example ARP response</em></p>&#13;
<p class="indent">How can you use ARP poisoning to your advantage? As with DHCP, there’s no authentication on ARP packets, which are intentionally sent to all nodes on the Ethernet network. Therefore, you can inform the target node you own an IP address and ensure the node forwards traffic to your rogue gateway by sending spoofed ARP packets to poison the target node’s ARP cache. You can use Ettercap to spoof the packets, as shown in <a href="../Text/ch04.xhtml#ch4fig10">Figure 4-10</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-10.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig10"/><em>Figure 4-10: ARP poisoning</em></p>&#13;
<p class="indent">In <a href="../Text/ch04.xhtml#ch4fig10">Figure 4-10</a>, Ettercap sends spoofed ARP packets to the client and the router on the local network. If spoofing succeeds, these ARP packets will change the cached ARP entries for both devices to point to your proxy.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_76"/><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Be sure to spoof ARP packets to both the client and the router to ensure that you get both sides of the communication. Of course, if all you want is one side of the communication, you only need to poison one or the other node.</em></p>&#13;
</div>&#13;
<p class="indent">To start ARP poisoning, follow these steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">Start Ettercap, and enter <strong>Unified Sniffing</strong> mode as you did with DHCP spoofing.</p></li>&#13;
<li><p class="noindent">Select the network interface to poison (the one connected to the network with the nodes you want to poison).</p></li>&#13;
<li><p class="noindent">Configure a list of hosts to ARP poison. The easiest way to get a list of hosts is to let Ettercap scan for you by choosing <strong>Hosts</strong> ▸ <strong>Scan For Hosts</strong>. Depending on the size of the network, scanning can take from a few seconds to hours. When the scan is complete, choose <strong>Hosts</strong> ▸ <strong>Host List</strong>; a dialog like the one in <a href="../Text/ch04.xhtml#ch4fig11">Figure 4-11</a> should appear.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-11.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig11"/><em>Figure 4-11: A list of discovered hosts</em></p>&#13;
<p class="indent">As you can see in <a href="../Text/ch04.xhtml#ch4fig11">Figure 4-11</a>, we’ve found two hosts. In this case, one is the client node that you want to capture, which is on IP address 192.168.100.1 with a MAC address of 08:00:27:33:81:6d. The other node is the gateway to the internet on IP address 192.168.100.10 with a MAC address of 08:00:27:68:95:c3. Most likely, you’ll already know the IP addresses configured for each network device, so you can determine which is the local machine and which is the remote machine.</p></li>&#13;
<li><span epub:type="pagebreak" id="page_77"/><p class="noindent">Choose your targets. Select one of the hosts from the list and click <strong>Add to Target 1</strong>; select the other host you want to poison and click <strong>Add to Target 2</strong>. (Target 1 and Target 2 differentiate between the client and the gateway.) This should enable one-way ARP poisoning in which only data sent from Target 1 to Target 2 is rerouted.</p></li>&#13;
<li><p class="noindent">Start ARP poisoning by choosing <strong>Mitm</strong> ▸ <strong>ARP poisoning.</strong> A dialog should appear. Accept the defaults and click <strong>OK</strong>. Ettercap should attempt to poison the ARP cache of your chosen targets. ARP poisoning may not work immediately because the ARP cache has to refresh. If poisoning is successful, the client node should look similar to <a href="../Text/ch04.xhtml#ch4fig12">Figure 4-12</a>.</p>&#13;
<div class="image"><img alt="image" src="../Images/f04-12.jpg"/></div>&#13;
<p class="figcap"><a id="ch4fig12"/><em>Figure 4-12: Successful ARP poisoning</em></p></li>&#13;
</ol>&#13;
<p class="indent"><a href="../Text/ch04.xhtml#ch4fig12">Figure 4-12</a> shows the router was poisoned at IP 192.168.100.10, which has had its MAC Hardware address modified to the proxy’s MAC address of 08:00:27:08:dc:e6. (For comparison, see the corresponding entry in <a href="../Text/ch04.xhtml#ch4fig11">Figure 4-11</a>.) Now any traffic that is sent from the client to the router will instead be sent to the proxy (shown by the MAC address of 192.168.100.5). The proxy can forward the traffic to the correct destination after capturing or modifying it.</p>&#13;
<p class="indent">One advantage that ARP poisoning has over DHCP spoofing is that you can redirect nodes on the local network to communicate with your gateway even if the destination is on the local network. ARP poisoning doesn’t have to poison the connection between the node and the external gateway if you don’t want it to.</p>&#13;
<h3 class="h3" id="ch00lev1sec105"><strong>Final Words</strong></h3>&#13;
<p class="noindent">In this chapter, you’ve learned a few additional ways to capture and modify traffic between a client and server. I began by describing how to configure your OS as an IP gateway, because if you can forward traffic through your own gateway, you have a number of techniques available to you.</p>&#13;
<p class="indent">Of course, just getting a device to send traffic to your network capture device isn’t always easy, so employing techniques such as DHCP spoofing or ARP poisoning is important to ensure that traffic is sent to your device rather than directly to the internet. Fortunately, as you’ve seen, you don’t need custom tools to do so; all the tools you need are either already included in your operating system (especially if you’re running Linux) or easily downloadable.<span epub:type="pagebreak" id="page_78"/></p>&#13;
</body></html>