["```\n// Listing1-1.S\n//\n// Comments consist of all text from a //\n// sequence to the end of the line.\n// The .text directive tells Gas that the\n// statements following this directive go in the\n// section of memory reserved for machine\n// instructions (code).\n\n      ❶ .text\n\n// Here is the main function. (This example assumes\n// that the assembly language program is a\n// stand-alone program with its own main function.)\n//\n// Under macOS, the main program must have the name\n// _main beginning with an underscore. Linux\n// systems generally don't require the underscore.\n//\n// The .global _main statement makes the _main\n// procedure's name visible outside this source file\n// (needed by the linker to produce an executable).\n\n        .global _main, main\n\n// The .align 2 statement tells the assembler to\n// align the following code on a 4-byte boundary\n// (required by the ARM CPU). The 2 operand\n// specifies 2 raised to this power (2), which is 4.\n\n ❷ .align 2\n\n// Here's the actual main program. It consists of a\n// single ret (return) instruction that simply\n// returns control to the operating system.\n\n_main:\nmain:\n        ret\n```", "```\n$ as -arch arm64 Listing1-1.S -o Listing1-1.o \n$ ld -o Listing1-1 Listing1-1.o -lSystem \\\n -syslibroot `xcrun -sdk macosx --show-sdk-path` \\\n -e _main -arch arm64 \n$ ./Listing1-1 \n```", "```\n$ g++ -o Listing1-1 Listing1-1.S \n```", "```\n$ ./Listing1-1 \n```", "```\n$ g++ -E Listing1-1.S \n```", "```\n$ g++ -E Listing1-1.S | as -o Listing1-1.o \n```", "```\n$ g++ -o Listing1-1.o Listing1-1.S \n```", "```\n// Listing1-2.S \n//\n// A simple C++ program that calls \n// an assembly language function \n//\n// Need to include stdio.h so this \n// program can call printf().\n\n#include <stdio.h>\n\n// extern \"C\" namespace prevents \n// \"name mangling\" by the C++\n// compiler. \n\nextern \"C\"\n{\n    // Here's the external function, \n // written in assembly language, \n    // that this program will call: \n\n     void asmMain(void); \n};\n\nint main(void) \n{\n    printf(\"Calling asmMain:\\n\"); \n    asmMain();\n    printf(\"Returned from asmMain\\n\"); \n}\n```", "```\n// Listing1-3.S \n//\n// A simple Gas module that contains \n// an empty function to be called by \n// the C++ code in Listing 1-2 \n\n        .text \n\n// Here is the asmMain function: \n\n        .global _asmMain, asmMain \n        .align  2    // Guarantee 4-byte alignment. \n_asmMain: \nasmMain: \n\n// Empty function just returns to C++ code. \n\n        ret          // Returns to caller \n```", "```\n$ g++ -o Listing1-2 Listing1-2.cpp Listing1-3.S \n$ ./Listing1-2 \nCalling asmMain: \nReturned from asmMain \n$\n```", "```\n#include \"aoaa.inc\"\n```", "```\n.include \"include_file_name\"\n```", "```\nMemory: array [0..4294967295] of byte; \n```", "```\nbyte Memory[4294967296]; \n```", "```\n`label`: `directive value(s)`\n```", "```\nbyteVar:    .byte   0 \nhalfVar:    .hword  1,2  // Actually reserves 2 half-words \nwordVar:    .word   -1 \ndwordVar:   .dword  123456789012345 \nstr1:       .ascii  \"Hello, world!\\n\"  // Uses C-style escape for newline \nstr2:       .asciz  \"How are you?\\n\"   // Sequences are legal. \npi:         .float  3.14159 \ndoubleVar:  .double 1.23456e-2 \n```", "```\nlongStr:   .ascii \"A bell character follows this string\"\n           .byte  7, 0   // Bell (7) and zero termination \n```", "```\n .data\ni8:   .byte   0\ni16:  .hword  0\ni32:  .word   0\ni64:  .dword  0\n```", "```\n .data \ni8:  .byte   0 \ni16: .hword  0 \ni32: .word   0 \ni64: .dword  0 \n```", "```\n .data \ni8:  .byte   0  // No alignment necessary for bytes \n     .align  1 \ni16: .hword  0 \n     .align  2 \ni32: .word   0 \n     .align  3 \ni64: .dword  0 \n```", "```\n .data \n     .align  3 \ni64: .dword  0 \ni32: .word   0 \ni16: .hword  0 \ni8:  .byte   0  // No alignment necessary for bytes \n```", "```\n.equ `label`, `expression`\n```", "```\n.equ dataSize, 256\n```", "```\n .set valueCanChange, 6\n      .\n      .  // valueCanChange has the value 6 here.\n      .\n    .set valueCanChange, 7\n\n// From this point forward, valueCanChange has the value 7.\n```", "```\n`symbolicName`  .req  `register`\n```", "```\n#define arrayPtr X0\n\n// From this point forward, you can use arrayPtr in place of X0.\n```", "```\nldr{`size`}  `reg`, `mem`\nstr{`size`}  `reg`, `mem`\n```", "```\nldr x0, i64   // i64 is a 64-bit variable declared\n              // in the .data section by using .dword.\n```", "```\nadr  `reg`64, `mem`\nadrp `reg`64, `mem`\n```", "```\nldr x0, i64\n```", "```\nadr x1, i64\n```", "```\nlea `reg`, `mem`\n```", "```\n .data\ni64:    .dword  0  // This also requires the aoaa.inc file.\n         .\n         .\n         .\n// Load i64's value into X0:\n\n        lea x0, i64\n        ldr x0, [x0]\n         .\n         .\n         .\n// Store X0 into i64:\n\n        lea x1, i64\n        str x0, [x1]\n```", "```\nlea x1, i64\nldr x0, [x1]\n .\n .\n .\nstr x0, [x1]\n```", "```\nmov `reg`dest, `reg`src\nmov `reg`dest, #`constant`\n```", "```\nmov x1, x0   // X1 = X0\nmov x2, #10  // X2 = 10\n```", "```\nldr `reg`, =`veryLargeConstant`\n```", "```\nadd  `reg`dest, `reg`lsrc, `reg`rsrc // `reg`dest = `reg`lsrc + `reg`rsrc\nadd  `reg`dest, `reg`lsrc, #`const` // `reg`dest = `reg`lsrc + `const`\nadds `reg`dest, `reg`lsrc, `reg`rsrc // `reg`dest = `reg`lsrc + `reg`rsrc\nadds `reg`dest, `reg`lsrc, #`const` // `reg`dest = `reg`lsrc + `const`\nsub  `reg`dest, `reg`lsrc, `reg`rsrc // `reg`dest = `reg`lsrc - `reg`rsrc\nsub  `reg`dest, `reg`lsrc, #`const` // `reg`dest = `reg`lsrc - `const`\nsubs `reg`dest, `reg`lsrc, `reg`rsrc // `reg`dest = `reg`lsrc - `reg`rsrc\nsubs `reg`dest, `reg`lsrc, #`const` // `reg`dest = `reg`lsrc - `const`\n```", "```\nsub `reg`dest32, wzr, `reg`src32 // `reg`dest32 = - `reg`src32\nsub `reg`dest64, xzr, `reg`src64 // `reg`dest64 = - `reg`src64\n```", "```\nneg  `reg`dest32, `reg`src32 // Negate instruction, no flags\nnegs `reg`dest32, `reg`src32 // Negate instruction, w/flags\nneg  `reg`dest64, `reg`src64 // Negate instruction, no flags\nnegs `reg`dest64, `reg`src64 // Negate instruction, w/flags\n```", "```\nbl  `label`\nblr X`n`\n```", "```\nlea x0, `farAwayProcedure`\nblr x0\n```", "```\nsomeFunc:\n        ret\n         .\n         .\n         .\nmain:\n        bl someFunc\n        ret\n```", "```\nsomeFunc:\n        ret\n         .\n         .\n         .\nmain:\n        mov x1, lr\n        bl someFunc\n        mov lr, x1\n        ret\n```", "```\n#include <stdio.h>\nint main(int argc, char **argv) \n{\n   printf(\"Hello, world!\\n\"); \n}\n```", "```\nhwStr:   .asciz  \"Hello, world!\\n\"\n           . \n           . \n           . \n          lea    x0, hwStr \n```", "```\nlea x0, hwStr \nbl  printf \n```", "```\n// Listing1.4.cpp \n//\n// Generic C++ driver program to call AoAA example programs \n// Also includes a \"readLine\" function that reads a string \n// from the user and passes it on to the assembly language \n// code \n//\n// Need to include stdio.h so this program can call \"printf\"\n// and stdio.h so this program can call strlen. \n\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Extern \"C\" namespace prevents \"name mangling\" by the C++\n// compiler: \n\nextern \"C\"\n{\n    // asmMain is the assembly language code's \"main program\":\n\n    ❶ void asmMain(void); \n\n    // getTitle returns a pointer to a string of characters \n    // from the assembly code that specifies the title of that \n    // program (that makes this program generic and usable \n    // with a large number of sample programs in \"The Art of \n    // ARM Assembly Language\"):\n\n  ❷ char *getTitle(void); \n\n    // C++ function that the assembly \n    // language program can call: \n\n❸ int readLine(char *dest, int maxLen); \n\n};\n\n// readLine reads a line of text from the user (from the \n// console device) and stores that string into the destination \n// buffer the first argument specifies. Strings are limited in \n// length to the value specified by the second argument \n// (minus 1). \n//\n// This function returns the number of characters actually \n// read, or -1 if there was an error. \n//\n// If the user enters too many characters (maxLen or \n// more), this function returns only the first maxLen - 1 \n// characters. This is not considered an error. \n\nint readLine(char *dest, int maxLen) \n{\n    // Note: fgets returns NULL if there was an error, else \n    // it returns a pointer to the string data read (which \n    // will be the value of the dest pointer): \n\n    char *result = fgets(dest, maxLen, stdin); \n    if(result != NULL) \n    {\n        // Wipe out the newline character at the \n        // end of the string: \n\n        int len = strlen(result); \n        if(len > 0) \n        {\n            dest[len - 1] = 0; \n        }\n        return len; \n    }\n    return -1; // If there was an error \n}\n\nint main(void) \n{\n    // Get the assembly language program's title: \n\n    char *title = getTitle();\n\n    printf(\"Calling %s:\\n\", title); \n    asmMain();\n    printf(\"%s terminated\\n\", title); \n\n}\n```", "```\ngetTitle: \n            lea     x0, title  // C expects pointer in X0\\. \n            ret \n```", "```\ntitle:      .asciz \"Listing1-5\"\n```", "```\n#define isMacOS (1)\n#define isLinux (0)\n#include \"aoaa.inc\"\n```", "```\n#define isMacOS (0)\n#define isLinux (1)\n#include \"aoaa.inc\"\n```", "```\n-D `name`=`value`\n```", "```\ng++ -D isMacOS=1 source.S\ng++ -D isLinux=1 source.S\n```", "```\n./build example\n```", "```\ng++ -D isLinux=1 -o example c.cpp example.S\n```", "```\ng++ -D isMacOS=1 -o example c.cpp example.S\n```", "```\n./build -c example\n```", "```\ng++ -c -D isMacOS=1 -o example.o example.S\n```", "```\ng++ -c -D isLinux=1 -o example.o example.S\n```", "```\n#!/bin/bash\n#\n# build\n#\n# Automatically builds an Art of ARM Assembly\n# example program from the command line\n#\n# Usage:\n#\n#    build {options} fileName\n#\n# (no suffix on the filename.)\n#\n# options:\n#\n#    -c: Assemble .S file to object code only.\n#    -pie: On Linux, generate a PIE executable.\n\nfileName=\"\"\ncompileOnly=\" \"\npie=\"-no-pie\"\ncFile=\"c.cpp\"\nlib=\" \"\nwhile [[$# -gt 0]]\ndo\n\n    key=\"$1\"\n    case $key in\n\n        -c)\n        compileOnly='-c'\n        shift\n        ;;\n\n        -pie)\n        pie='-pie'\n        shift\n        ;;\n\n        -math)\n        math='-lm'\n        shift\n        ;;\n\n        *)\n        fileName=\"$1\"\n        shift\n        ;;\n    esac\ndone\n\n# If -c option was provided, only assemble the .S\n# file and produce an .o output file.\n#\n# If -c not specified, compile both c.cpp and the .S\n# file and produce an executable:\n\nif [\"$compileOnly\" = '-c']; then\n    objectFile=\"-o $fileName\".o\n    cFile=\" \"\nelse\n    objectFile=\"-o $fileName\"\nfi\n\n# If the executable already exists, delete it:\n\nif test -e \"$fileName\"; then\n    rm \"$fileName\"\nfi\n\n# If the object file already exists, delete it:\n\nif test -e \"$fileName\".o; then\n    rm \"$fileName\".o\nfi\n\n# Determine what OS you're running under (Linux or Darwin [macOS]) and\n# issue the appropriate GCC command to compile/assemble the files.\n\nunamestr=$(uname)\nif [\"$unamestr\" = 'Linux']; then\n    g++  -D isLinux=1 $pie $compileOnly $objectFile  $cFile $fileName.S $math\nelif [\"$unamestr\" = 'Darwin']; then\n    g++  -D isMacOS=1  $compileOnly $objectFile $cFile  $fileName.S -lSystem $math\nfi\n```", "```\nchmod u+x build\n```", "```\n// Listing1-5.S\n//\n// The venerable \"Hello, world!\" program, written\n// in ARM assembly by calling the C stdlib printf\n// function\n//\n// aoaa.inc is the Art of ARM Assembly include file.\n//\n// This makes asmMain global and\n// automatically converts it to _asmMain\n// if this program is being assembled under macOS.\n// It also converts printf to _printf for macOS.\n\n            #include \"aoaa.inc\"\n\n            .data\n\n❶ title:      .asciz  \"Listing 1-5\"\nsaveLR:     .dword  0       // Save LR here.\nhwStr:      .asciz  \"Hello, world!\\n\"\n\n            .text\n\n// getTitle function, required by c.cpp, returns the\n// name of this program. The title string must\n// appear in the .text section:\n\n .align  2       // Code must be 4-byte aligned.\n\n❷ getTitle:\n            lea     x0, title\n            ret\n\n// Here's the main function called by the c.cpp function:\n\nasmMain:\n\n// LR is *highly* volatile and will be wiped\n// out when this code calls the printf() function.\n// We need to save LR in memory somewhere so we\n// can return back to the OS using its value.\n// For now, save it in the saveLR global\n// variable:\n\n            lea     x0, saveLR\n            str     lr, [x0]\n\n// Set up printf parameter (format string)\n// and call printf():\n\n          ❸ lea     x0, hwStr   // hwStr must be in .text.\n            bl      printf      // Print the string.\n\n// Back from printf(), restore LR with its original\n// value so we can return to the OS:\n\n          ❹ lea     x0, saveLR\n            ldr     lr, [x0]\n\n// Return to the OS:\n\n            ret\n```", "```\n$ ./build Listing1-5\n$ ./Listing1-5\nCalling Listing1-5:\nHello, world!\nListing1-5 terminated\n```"]