- en: '3'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: FUZZING SOAP ENDPOINTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试 SOAP 端点
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: As a penetration tester, you may run into applications or servers that offer
    programmatic API access via SOAP endpoints. SOAP, or Simple Object Access Protocol,
    is a common enterprise technology that enables language-agnostic access to programming
    APIs. Generally speaking, SOAP is used over the HTTP protocol, and it uses XML
    to organize the data sent to and from the SOAP server. The Web Service Description
    Language (WSDL) describes the methods and functionality exposed through SOAP endpoints.
    By default, SOAP endpoints expose WSDL XML documents that clients can easily parse
    so that they can interface with the SOAP endpoints, and C# has several classes
    that make this possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，你可能会遇到提供程序化 API 访问的应用程序或服务器，这些 API 通过 SOAP 端点提供。SOAP（简单对象访问协议）是一种常见的企业技术，允许以语言无关的方式访问编程
    API。一般来说，SOAP 是通过 HTTP 协议使用的，并且它使用 XML 来组织发送到 SOAP 服务器的数据。Web 服务描述语言（WSDL）描述了通过
    SOAP 端点公开的方法和功能。默认情况下，SOAP 端点公开 WSDL XML 文档，客户端可以轻松解析这些文档，以便与 SOAP 端点进行交互，C# 有多个类使得这成为可能。
- en: This chapter builds on your knowledge of how to programmatically craft HTTP
    requests to detect XSS and SQL injection vulnerabilities, except that it focuses
    on SOAP XML instead. This chapter also shows you how to write a small fuzzer to
    download and parse the WSDL file exposed by a SOAP endpoint and then use the information
    in the WSDL file to generate HTTP requests for the SOAP service. Ultimately, you’ll
    be able to systematically and automatically look for possible SQL injection vulnerabilities
    in SOAP methods.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在你如何通过编程方式构造 HTTP 请求来检测 XSS 和 SQL 注入漏洞的基础知识之上，只不过这次我们关注的是 SOAP XML。此章还会展示如何编写一个小型模糊测试器来下载和解析
    SOAP 端点公开的 WSDL 文件，然后使用 WSDL 文件中的信息生成 SOAP 服务的 HTTP 请求。最终，你将能够系统化并自动化地查找 SOAP
    方法中的 SQL 注入漏洞。
- en: Setting Up the Vulnerable Endpoint
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 设置脆弱的端点
- en: For this chapter, you’ll use a vulnerable endpoint in a preconfigured virtual
    appliance called CsharpVulnSoap (which should have a file extension of .ova) available
    on the VulnHub website ([http://www.vulnhub.com/](http://www.vulnhub.com/)). After
    downloading the appliance, you can import it into VirtualBox or VMware on most
    operating systems by double-clicking the file. Once the appliance is installed,
    log in with a password of password or use a Guest session to open a terminal.
    From there, enter ifconfig to find the virtual appliance’s IP address. By default,
    this appliance will be listening on a host-only interface, unlike in previous
    chapters where we bridged the network interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将使用一个名为 CsharpVulnSoap 的预配置虚拟设备中的脆弱端点（该文件应具有 .ova 扩展名），该设备可在 VulnHub 网站上找到（[http://www.vulnhub.com/](http://www.vulnhub.com/)）。下载虚拟设备后，你可以通过双击文件将其导入到
    VirtualBox 或 VMware 中，支持大多数操作系统。一旦安装完成，使用密码 password 登录，或者使用访客会话打开终端。接着，输入 ifconfig
    查找虚拟设备的 IP 地址。默认情况下，该设备将通过仅主机接口进行监听，而与之前章节中的网络接口桥接不同。
- en: After bringing the endpoint up in a web browser, as shown in [Figure 3-1](#filepos246543),
    you can use the menu items on the left side of the screen (AddUser, ListUsers,
    GetUser, and DeleteUser) to see what the functions exposed by the SOAP endpoint
    return when used. Navigating to http://<ip>/Vulnerable.asmx?WSDL should present
    you with the WSDL document describing the available functions in a parseable XML
    file. Let’s dig into the structure of this document.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开端点，如[图 3-1](#filepos246543)所示，你可以使用屏幕左侧的菜单项（AddUser、ListUsers、GetUser
    和 DeleteUser）查看 SOAP 端点公开的功能在使用时的返回结果。导航到 http://<ip>/Vulnerable.asmx?WSDL 应该会展示一个
    WSDL 文档，该文档描述了可以解析的 XML 文件中的可用函数。让我们深入研究该文档的结构。
- en: '![](images/00030.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00030.jpg)'
- en: 'Figure 3-1: The vulnerable endpoint as seen from Firefox'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：从 Firefox 查看脆弱的端点
- en: Parsing the WSDL
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 WSDL
- en: WSDL XML documents are a bit complicated. Even a simple WSDL document like the
    one we’ll parse is not trivial. However, because C# has excellent classes for
    parsing and consuming XML files, getting the WSDL parsed correctly and into a
    state that lets us interact with the SOAP services in an object-oriented fashion
    is pretty bearable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL XML 文档有点复杂。即使是我们要解析的简单 WSDL 文档也并不简单。然而，由于 C# 提供了出色的类来解析和使用 XML 文件，正确解析
    WSDL 并使其处于一个可以面向对象地与 SOAP 服务交互的状态是相当容易的。
- en: A WSDL document is essentially a bunch of XML elements that relate to one another
    in a logical way, from the bottom of the document to the top. At the bottom of
    the document, you interact with the service to make a request to the endpoint.
    From the service, you have the notion of ports. These ports point to a binding,
    which in turn points to a port type. The port type contains the operations (or
    methods) available on that endpoint. The operations contain an input and an output,
    which both point to a message. The message points to a type, and the type contains
    the parameters required to call the method. [Figure 3-2](#filepos248062) explains
    this concept visually.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 WSDL 文档本质上是一些 XML 元素，这些元素彼此之间以逻辑方式相关，从文档底部到顶部。文档底部，你与服务交互，向端点发出请求。从服务开始，你有了端口的概念。这些端口指向绑定，而绑定又指向端口类型。端口类型包含该端点上可用的操作（或方法）。操作包含输入和输出，二者都指向一个消息。消息指向一个类型，而该类型包含调用方法所需的参数。[图
    3-2](#filepos248062) 直观地解释了这一概念。
- en: '![](images/00011.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00011.jpg)'
- en: 'Figure 3-2: The basic logical layout of a WSDL document'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3-2: WSDL 文档的基本逻辑布局'
- en: Our WSDL class constructor will work in reverse order. First, we’ll create the
    constructor, and then we’ll create a class to handle parsing each part of the
    WSDL document, from types to services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 WSDL 类构造函数将按相反顺序工作。首先，我们创建构造函数，然后我们将创建一个类来处理 WSDL 文档每个部分的解析，从类型到服务。
- en: Creating a Class for the WSDL Document
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为 WSDL 文档创建一个类
- en: When you’re parsing WSDL programmatically, it’s easiest to start at the top
    of the document with the SOAP types and work your way down the document. Let’s
    create a class called WSDL that encompasses the WSDL document. The constructor
    is relatively simple, as shown in [Listing 3-1](#filepos249737).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过编程解析 WSDL 时，最简单的方法是从文档的顶部开始，处理 SOAP 类型，然后逐步向下解析文档。让我们创建一个名为 WSDL 的类，它包含
    WSDL 文档。构造函数相对简单，如[清单 3-1](#filepos249737)所示。
- en: public WSDL (XmlDocument doc)
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public WSDL (XmlDocument doc)
- en: '{'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: XmlNamespaceManager nsManager = new ➊XmlNamespaceManager(doc.NameTable);
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNamespaceManager nsManager = new ➊XmlNamespaceManager(doc.NameTable);
- en: nsManager.➋AddNamespace("wsdl", doc.DocumentElement.NamespaceURI);
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nsManager.➋AddNamespace("wsdl", doc.DocumentElement.NamespaceURI);
- en: nsManager.AddNamespace("xs", "http://www.w3.org/2001/XMLSchema");
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nsManager.AddNamespace("xs", "http://www.w3.org/2001/XMLSchema");
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ParseTypes(doc, nsManager);
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseTypes(doc, nsManager);
- en: ParseMessages(doc, nsManager);
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseMessages(doc, nsManager);
- en: ParsePortTypes(doc, nsManager);
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParsePortTypes(doc, nsManager);
- en: ParseBindings(doc, nsManager);
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseBindings(doc, nsManager);
- en: ParseServices(doc, nsManager);
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ParseServices(doc, nsManager);
- en: '}'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-1: The  WSDL  class constructor'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-1: WSDL 类构造函数'
- en: 'The constructor of our WSDL class calls just a handful of methods (which we’ll
    write next), and it expects the retrieved XML document that contains all the definitions
    of the web service as a parameter. The first thing we need to do is define the
    XML namespaces we’ll be referencing while using XPath queries (which are covered
    in [Listing 3-3](#filepos253495) and later listings) when we implement the parsing
    methods. To do this, we create a new XmlNamespaceManager ➊ and use the AddNamespace()
    method ➋ to add two namespaces, wsdl and xs. Then we call the methods that will
    parse the elements of the WSDL document, starting with types and working our way
    down to services. Each method takes two arguments: the WSDL document and the namespace
    manager.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 WSDL 类的构造函数只调用了少数几个方法（我们稍后会编写），并且它期望获取包含所有 Web 服务定义的 XML 文档作为参数。我们需要做的第一件事是定义在实现解析方法时使用
    XPath 查询时所引用的 XML 命名空间（这些内容在[清单 3-3](#filepos253495)及后续清单中有所介绍）。为此，我们创建一个新的 XmlNamespaceManager
    ➊，并使用 AddNamespace() 方法 ➋ 添加两个命名空间：wsdl 和 xs。然后，我们调用将解析 WSDL 文档元素的方法，从类型开始，一直到服务。每个方法接受两个参数：WSDL
    文档和命名空间管理器。
- en: We also need access to a few properties of the WSDL class that correspond to
    the methods called in the constructor. Add the properties shown in [Listing 3-2](#filepos251619)
    to the WSDL class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要访问 WSDL 类中的一些属性，这些属性与构造函数中调用的方法相对应。将[清单 3-2](#filepos251619)中显示的属性添加到 WSDL
    类中。
- en: public List<SoapType> Types { get; set; }
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapType> Types { get; set; }
- en: public List<SoapMessage> Messages { get; set; }
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapMessage> Messages { get; set; }
- en: public List<SoapPortType> PortTypes { get; set; }
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapPortType> PortTypes { get; set; }
- en: public List<SoapBinding> Bindings { get; set; }
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapBinding> Bindings { get; set; }
- en: public List<SoapService> Services { get; set; }
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapService> Services { get; set; }
- en: 'Listing 3-2: Public properties of the  WSDL  class'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3-2: WSDL 类的公共属性'
- en: These properties of the WSDL class are consumed by the fuzzer (which is why
    they are public) and by the methods called in the constructor. The properties
    are lists of the SOAP classes we’ll implement in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL类的这些属性由模糊测试工具（因此它们是public的）和构造函数中调用的方法使用。它们是我们在本章中将实现的SOAP类的列表。
- en: Writing the Initial Parsing Methods
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编写初始解析方法
- en: First, we’ll write the methods that are called in [Listing 3-1](#filepos249737).
    Once we have those methods implemented, we’ll move on to create the classes each
    method relies on. This is going to be a bit of work, but we’ll get through it
    together!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写在[Listing 3-1](#filepos249737)中调用的方法。一旦这些方法实现完成，我们将继续创建每个方法依赖的类。这会有点工作量，但我们会一起完成的！
- en: We’ll start by implementing the first method called in [Listing 3-1](#filepos249737),
    ParseTypes(). All the methods called from the constructor are relatively simple
    and will look similar to [Listing 3-3](#filepos253495).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从实现[Listing 3-1](#filepos249737)中调用的第一个方法`ParseTypes()`开始。构造函数中调用的所有方法相对简单，看起来都与[Listing
    3-3](#filepos253495)类似。
- en: private void ParseTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Types = new List<SoapType>();
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Types = new List<SoapType>();
- en: string xpath = ➊"/wsdl:definitions/wsdl:types/xs:schema/xs:element";
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = ➊"/wsdl:definitions/wsdl:types/xs:schema/xs:element";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode type in nodes)
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode type in nodes)
- en: this.Types.Add(new SoapType(type));
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Types.Add(new SoapType(type));
- en: '}'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-3: The  ParseTypes()  method called in the  WSDL  class constructor'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-3: WSDL类构造函数中调用的`ParseTypes()`方法'
- en: Because these methods are only called internally in the WSDL constructor, we
    use the private keyword so that only the WSDL class can access them. The ParseTypes()
    method accepts a WSDL document and the namespace manager (used to resolve namespaces
    in the WSDL document) as arguments. Next, we instantiate a new List object and
    assign it to the Types property. We then iterate over the XML elements in the
    WSDL using the XPath facilities available to XML documents in C#. XPath lets a
    programmer traverse and consume an XML document based on node paths within the
    document. In this example, we use an XPath query ➊ to enumerate all the SOAP type
    nodes from the document using the SelectNodes() method. Then we iterate over those
    SOAP types and pass each node to the SoapType class constructor, which is one
    of the classes we’ll implement after entering the initial parsing methods. Finally,
    we add the newly instantiated SoapType objects to the SoapType list property of
    the WSDL class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些方法仅在WSDL构造函数内部调用，所以我们使用`private`关键字，这样只有WSDL类才能访问它们。`ParseTypes()`方法接受一个WSDL文档和命名空间管理器（用于解析WSDL文档中的命名空间）作为参数。接下来，我们实例化一个新的List对象，并将其分配给Types属性。然后，我们使用C#中XML文档的XPath功能，遍历WSDL中的XML元素。XPath允许程序员根据文档中的节点路径遍历和使用XML文档。在这个示例中，我们使用XPath查询➊来枚举文档中的所有SOAP类型节点，使用`SelectNodes()`方法。然后，我们遍历这些SOAP类型，并将每个节点传递给`SoapType`类构造函数，这是我们在进入初始解析方法后将实现的类之一。最后，我们将新实例化的`SoapType`对象添加到WSDL类的SoapType列表属性中。
- en: Easy enough, right? We’ll employ this pattern of using an XPath query to iterate
    over specific nodes a few more times to consume a few other types of nodes we
    need from the WSDL document. XPath is quite powerful and is great for working
    with the C# language in general.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？我们将采用这种使用XPath查询遍历特定节点的模式，再做几次，以便从WSDL文档中获取其他几种我们需要的节点类型。XPath非常强大，对于C#语言的使用也非常合适。
- en: Now we’ll implement the next method called in the WSDL constructor to parse
    the WSDL document, ParseMessages(), as detailed in [Listing 3-4](#filepos256350).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现WSDL构造函数中调用的下一个方法来解析WSDL文档，即`ParseMessages()`，如[Listing 3-4](#filepos256350)所示。
- en: private void ParseMessages(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private void ParseMessages(XmlDocument wsdl, XmlNamespaceManager nsManager)
- en: '{'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Messages = new List<SoapMessage>();
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Messages = new List<SoapMessage>();
- en: string xpath = ➊"/wsdl:definitions/wsdl:message";
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xpath = ➊"/wsdl:definitions/wsdl:message";
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
- en: foreach (XmlNode node in nodes)
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in nodes)
- en: this.Messages.Add(new SoapMessage(node));
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Messages.Add(new SoapMessage(node));
- en: '}'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-4: The  ParseMessages()  method called in the WSDL class constructor'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-4: WSDL类构造函数中调用的`ParseMessages()`方法'
- en: First, we need to instantiate and assign a new List to hold the SoapMessage
    objects. (SoapMessage is a class we’ll implement in “[Creating the SoapMessage
    Class to Define Sent Data](#filepos270075)” on [page 60](#filepos243384).) Using
    an XPath query ➊ to select the message nodes from the WSDL document, we iterate
    over the nodes returned by the SelectNodes() method and pass them to the SoapMessage
    constructor. These newly instantiated objects are added to the Messages property
    of the WSDL class for later consumption.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The next few methods called from the WSDL class are similar to the previous
    two. By now, they should seem relatively straightforward to you, given how the
    previous two methods have worked. These methods are all detailed in [Listing 3-5](#filepos259460).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: private void ParsePortTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.PortTypes = new List<SoapPortType>();
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string xpath = "/wsdl:definitions/wsdl:portType";
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode node in nodes)
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.PortTypes.Add(new SoapPortType(node));
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void ParseBindings(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Bindings = new List<SoapBinding>();
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string xpath = "/wsdl:definitions/wsdl:binding";
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode node in nodes)
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Bindings.Add(new SoapBinding(node));
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private void ParseServices(XmlDocument wsdl, XmlNamespaceManager nsManager)
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Services = new List<SoapService>();
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string xpath = "/wsdl:definitions/wsdl:service";
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode node in nodes)
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Services.Add(new SoapService(node));
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-5: The rest of the initial parsing methods in the  WSDL  class'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To fill the PortTypes, Bindings, and Services properties, we use XPath queries
    to find and iterate over the relevant nodes; then we instantiate specific SOAP
    classes, which we’ll implement next, and add them to the lists so that we can
    access them later when we need to build the WSDL fuzzer logic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the WSDL class. A constructor, a handful of properties to store
    data relevant to the WSDL class, and some methods to parse out a WSDL document
    are all that you need to get started. Now we need to implement the supporting
    classes. Within the parsing methods, we used some classes that haven’t yet been
    implemented (SoapType, SoapMessage, SoapPortType, SoapBinding, and SoapService).
    We’ll start with the SoapType class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Class for the SOAP Type and Parameters
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: To complete the ParseTypes() method, we need to implement the SoapType class.
    The SoapType class is a relatively simple one. All it needs is a constructor and
    a couple of properties, as shown in [Listing 3-6](#filepos262263).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: public class SoapType
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public SoapType(XmlNode type)
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = type.➊Attributes["name"].Value;
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Parameters = new List<SoapTypeParameter>();
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (type.➋HasChildNodes && type.FirstChild.HasChildNodes)
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (type.➋HasChildNodes && type.FirstChild.HasChildNodes)
- en: '{'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode node in type.➌FirstChild.FirstChild.➍ChildNodes)
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode node in type.➌FirstChild.FirstChild.➍ChildNodes)
- en: this.Parameters.Add(new SoapTypeParameter(node));
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parameters.Add(new SoapTypeParameter(node));
- en: '}'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapTypeParameter> Parameters { get; set; }
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapTypeParameter> Parameters { get; set; }
- en: '}'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-6: The  SoapType  class used in the WSDL fuzzer'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-6：在 WSDL 模糊测试中使用的 `SoapType` 类
- en: The logic in the SoapType constructor is similar to that in the previous parsing
    methods (in [Listings 3-4](#filepos256350) and [3-5](#filepos259460)), except
    we’re not using XPath to enumerate the nodes we’re iterating over. We could have,
    but I wanted to show you another way of iterating over XML nodes. Usually, when
    you’re parsing XML, XPath is the way to go, but XPath can be computationally expensive.
    In this case, we’ll write an if statement to check whether we have to iterate
    over the child nodes. Iterating over the child nodes using a foreach loop to find
    the relevant XML element involves slightly less code than using XPath in this
    particular instance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoapType` 构造函数中的逻辑与前面解析方法中的逻辑类似（见 [清单 3-4](#filepos256350) 和 [3-5](#filepos259460)），不同之处在于我们没有使用
    XPath 来枚举我们正在遍历的节点。我们本可以使用 XPath，但我想展示另一种遍历 XML 节点的方式。通常，当你解析 XML 时，XPath 是首选方法，但
    XPath 可能会计算量较大。在这种情况下，我们将写一个 `if` 语句来检查是否需要遍历子节点。在这个特定实例中，使用 `foreach` 循环遍历子节点来找到相关的
    XML 元素，比使用 XPath 的代码要少一些。'
- en: 'The SoapType class has two properties: a Name property, which is a string,
    and a list of parameters (the SoapTypeParameter class, which we’ll implement shortly).
    Both of these properties are used in the SoapType constructor and are public so
    that they can be consumed outside the class later on.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoapType` 类有两个属性：一个是 `Name` 属性，类型为字符串，另一个是参数列表（`SoapTypeParameter` 类，稍后我们会实现）。这两个属性都在
    `SoapType` 构造函数中使用，并且是公有的，以便稍后在类外部使用。'
- en: We use the Attributes property ➊ on the node passed into the constructor arguments
    to retrieve the node’s name attribute. The value of the name attribute is assigned
    to the Name property of the SoapType class. We also instantiate the SoapTypeParameter
    list and assign the new object to the Parameters property. Once this is done,
    we use an if statement to determine whether we need to iterate over child nodes
    in the first place, since we’re not using XPath to iterate over any child nodes.
    Using the HasChildNodes property ➋, which returns a Boolean value, we can determine
    whether we have to iterate over the child nodes. If the node has child nodes,
    and if the first child of that node also has child nodes, we’ll iterate over them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用传入构造函数参数的节点的 `Attributes` 属性 ➊ 来检索节点的 `name` 属性。`name` 属性的值被赋给 `SoapType`
    类的 `Name` 属性。我们还实例化了 `SoapTypeParameter` 列表，并将新对象赋给 `Parameters` 属性。完成这一步后，我们使用
    `if` 语句判断是否需要遍历子节点，因为我们没有使用 XPath 来遍历任何子节点。通过使用 `HasChildNodes` 属性 ➋，它返回一个布尔值，我们可以判断是否需要遍历子节点。如果节点有子节点，且该节点的第一个子节点也有子节点，我们就会遍历它们。
- en: Every XmlNode class has a FirstChild property and a ChildNodes property ➍ that
    returns an enumerable list of the child nodes available. In the foreach loop,
    we use a chain of FirstChild properties ➌ to iterate over the child nodes of the
    first child of the first child of the node passed in.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `XmlNode` 类都有一个 `FirstChild` 属性和一个 `ChildNodes` 属性 ➊，返回可遍历的子节点列表。在 `foreach`
    循环中，我们使用一系列 `FirstChild` 属性 ➌ 来遍历传入节点的第一个子节点的第一个子节点的子节点。
- en: An example of an XML node that would be passed to the SoapType constructor is
    shown in [Listing 3-7](#filepos266373).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `SoapType` 构造函数的 XML 节点示例如 [清单 3-7](#filepos266373) 中所示。
- en: After iterating over the relevant child nodes in the SoapType node that’s passed
    in, we instantiate a new SoapTypeParameter class by passing the current child
    node into the SoapTypeParameter constructor. The new object is stored in the Parameters
    list for access later on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历传入的 `SoapType` 节点的相关子节点之后，我们通过将当前子节点传入 `SoapTypeParameter` 构造函数来实例化一个新的 `SoapTypeParameter`
    类。新对象被存储在 `Parameters` 列表中，以便以后访问。
- en: <xs:element name="AddUser">
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:element name="AddUser">
- en: <xs:complexType>
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:complexType>
- en: <xs:sequence>
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:sequence>
- en: <xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
- en: <xs:element minOccurs="0" maxOccurs="1" name="password" type="xs:string"/>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <xs:element minOccurs="0" maxOccurs="1" name="password" type="xs:string"/>
- en: </xs:sequence>
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </xs:sequence>
- en: </xs:complexType>
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </xs:complexType>
- en: '</xs:element> Listing 3-7: Sample  SoapType  XML'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '</xs:element> Listing 3-7: 示例 SoapType XML'
- en: Now let’s create the SoapTypeParameter class. The SoapTypeParameter class is
    also relatively simple. In fact, no iteration over child nodes is required, just
    basic information gathering, as [Listing 3-8](#filepos268034) shows.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 SoapTypeParameter 类。SoapTypeParameter 类也相对简单。事实上，不需要对子节点进行迭代，只需进行基本的信息收集，正如
    [Listing 3-8](#filepos268034) 所示。
- en: public class SoapTypeParameter
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapTypeParameter
- en: '{'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapTypeParameter(XmlNode node)
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapTypeParameter(XmlNode node)
- en: '{'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊if (node.Attributes["maxOccurs"].Value == "unbounded")
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊如果 (node.Attributes["maxOccurs"].Value == "unbounded")
- en: this.MaximumOccurrence = int.MaxValue;
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.MaximumOccurrence = int.MaxValue;
- en: else
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: this.MaximumOccurrence = int.Parse(node.Attributes["maxOccurs"].Value);
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.MaximumOccurrence = int.Parse(node.Attributes["maxOccurs"].Value);
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.MinimumOccurrence = int.Parse(node.Attributes["minOccurs"].Value);
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.MinimumOccurrence = int.Parse(node.Attributes["minOccurs"].Value);
- en: this.Name = node.Attributes["name"].Value;
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = node.Attributes["name"].Value;
- en: this.Type = node.Attributes["type"].Value;
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Type = node.Attributes["type"].Value;
- en: '}'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public int MinimumOccurrence { get; set; }
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int MinimumOccurrence { get; set; }
- en: public int MaximumOccurrence { get; set; }
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public int MaximumOccurrence { get; set; }
- en: public string Name { get; set; }
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Type { get; set; }
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Type { get; set; }
- en: '}'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-8: The  SoapTypeParameter  class'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-8: SoapTypeParameter 类'
- en: An example of an XML node passed to the SoapTypeParameter constructor is shown
    in [Listing 3-9](#filepos268593).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 SoapTypeParameter 构造函数的 XML 节点示例如 [Listing 3-9](#filepos268593) 所示。
- en: '<xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
    Listing 3-9: Sample XML node passed to the  SoapTypeParameter  constructor'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '<xs:element minOccurs="0" maxOccurs="1" name="username" type="xs:string"/>
    Listing 3-9: 传递给 SoapTypeParameter 构造函数的示例 XML 节点'
- en: Given an XML node like this, we can expect a few things to happen in our method.
    First, this is a very basic WSDL parameter that defines a parameter named username
    that is of type string. It can occur at a minimum zero times and at most once.
    Look closely at the code in [Listing 3-8](#filepos268034), and you’ll notice that
    there’s an if statement ➊ that checks the value of maxOccurs. Unlike minOccurs,
    maxOccurs can be either an integer or the string value unbounded, so we have to
    check the maxOccurs value before passing it to the int.Parse() method to see what
    the value is.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个像这样的 XML 节点，我们可以预期在我们的方法中发生一些事情。首先，这是一个非常基本的 WSDL 参数，定义了一个名为 username 的参数，其类型为
    string。它至少可以出现零次，最多一次。仔细查看 [Listing 3-8](#filepos268034) 中的代码，你会注意到有一个 if 语句 ➊
    检查 maxOccurs 的值。与 minOccurs 不同，maxOccurs 可以是一个整数或字符串值 unbounded，因此我们需要在将其传递给 int.Parse()
    方法之前检查 maxOccurs 的值，以确认它的具体值。
- en: Within our SoapTypeParameter constructor, we first assign the MaximumOccurrence
    property based on the node’s maxOccurs attribute. We then assign the MinimumOccurrence,
    Name, and Type properties based on the corresponding node attributes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 SoapTypeParameter 构造函数中，我们首先根据节点的 maxOccurs 属性赋值 MaximumOccurrence 属性。然后根据相应的节点属性赋值
    MinimumOccurrence、Name 和 Type 属性。
- en: Creating the SoapMessage Class to Define Sent Data
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 SoapMessage 类以定义发送数据
- en: A SOAP message defines a set of data that the web service either expects or
    responds with for a given operation. It references the SOAP types and parameters
    previously parsed to present data to or consume data from the client application
    and is made up of parts, which is the technical term. An example of a SOAP 1.1
    message XML element is provided in [Listing 3-10](#filepos270966).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 消息定义了一组数据，Web 服务为某个操作预期接收或响应这些数据。它引用了之前解析的 SOAP 类型和参数，以向客户端应用程序呈现数据或从中获取数据，并由多个部分组成，这个“部分”是技术术语。SOAP
    1.1 消息 XML 元素的示例如 [Listing 3-10](#filepos270966) 所示。
- en: <message name="AddUserHttpGetIn">
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <message name="AddUserHttpGetIn">
- en: <part name="username" type="s:string"/>
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <part name="username" type="s:string"/>
- en: <part name="password" type="s:string"/>
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <part name="password" type="s:string"/>
- en: '</message> Listing 3-10: Sample SOAP message XML element'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '</message> Listing 3-10: 示例 SOAP 消息 XML 元素'
- en: Our SoapMessage class, which consumes an XML element like the one in [Listing
    3-10](#filepos270966), is detailed in [Listing 3-11](#filepos272170).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SoapMessage 类，它消费像 [Listing 3-10](#filepos270966) 中的 XML 元素，详见 [Listing
    3-11](#filepos272170)。
- en: public class SoapMessage
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapMessage
- en: '{'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapMessage(XmlNode node)
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapMessage(XmlNode node)
- en: '{'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊node.Attributes["name"].Value;
- en: this.Parts = new List<SoapMessagePart>();
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parts = new List<SoapMessagePart>();
- en: if (node.HasChildNodes)
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 (node.HasChildNodes)
- en: '{'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: foreach (XmlNode part in node.ChildNodes)
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode part in node.ChildNodes)
- en: this.Parts.Add(new SoapMessagePart(part));
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Parts.Add(new SoapMessagePart(part));
- en: '}'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapMessagePart> Parts { get; set; }
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapMessagePart> Parts { get; set; }
- en: '}'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-11: The  SoapMessage  class'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-11：SoapMessage 类
- en: First, we assign the name of the message to the Name property ➊ of the SoapMessage
    class. We then instantiate a new List of parts called SoapMessagePart and iterate
    over each <part> element, passing the element to the SoapMessagePart constructor
    and saving the new SoapMessagePart for later use by adding it to the Parts list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将消息的名称分配给 SoapMessage 类的 Name 属性 ➊。然后，我们实例化一个新的名为 SoapMessagePart 的部分列表，并遍历每个
    <part> 元素，将元素传递给 SoapMessagePart 构造函数，并通过将其添加到 Parts 列表中来保存新创建的 SoapMessagePart，以备后续使用。
- en: Implementing a Class for Message Parts
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为消息部分实现一个类
- en: Like the previous SOAP classes we have implemented, the SoapMessagePart class
    is a simple class, as [Listing 3-12](#filepos274368) shows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们之前实现的 SOAP 类一样，SoapMessagePart 类是一个简单的类，如[清单 3-12](#filepos274368)所示。
- en: public class SoapMessagePart
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapMessagePart
- en: '{'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapMessagePart(XmlNode part)
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapMessagePart(XmlNode part)
- en: '{'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊part.Attributes["name"].Value;
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊part.Attributes["name"].Value;
- en: if (➋part.Attributes["element"] != null)
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➋part.Attributes["element"] != null)
- en: this.Element = part.Attributes["element"].Value;
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Element = part.Attributes["element"].Value;
- en: else if ( part.Attributes["type"].Value != null)
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if ( part.Attributes["type"].Value != null)
- en: this.Type = part.Attributes["type"].Value;
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Type = part.Attributes["type"].Value;
- en: else
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: throw new ArgumentException("Neither element nor type is set.", "part");
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: throw new ArgumentException("Neither element nor type is set.", "part");
- en: '}'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Element { get; set; }
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Element { get; set; }
- en: public string Type { get; set; }
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Type { get; set; }
- en: '}'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-12: The  SoapMessagePart  class'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-12：SoapMessagePart 类
- en: 'The SoapMessagePart class constructor takes a single argument, XmlNode, that
    contains the name and the type or element of the part within the SoapMessage.
    The SoapMessagePart class defines three public properties: the part’s Name, Type,
    and Element, all of which are strings. First, we store the name of the part in
    the Name property ➊. Then, if we have an attribute called element ➋, we assign
    the value of the element attribute to the Element property. If the element attribute
    doesn’t exist, the type attribute must exist, so we assign the value of the type
    attribute to the Type property. Only two of these properties will be set for any
    given SOAP part—a SOAP part always has a Name and either a Type or Element. The
    Type or Element will be set depending on whether the part is a simple type (such
    as a string or integer) or a complex type encompassed by another XML element within
    the WSDL. We have to create a class for each kind of parameter, and we’ll start
    by implementing the Type class.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: SoapMessagePart 类的构造函数接受一个 XmlNode 类型的单一参数，该参数包含了 SoapMessage 中部分的名称、类型或元素。SoapMessagePart
    类定义了三个公共属性：部分的 Name、Type 和 Element，都是字符串类型。首先，我们将部分的名称存储在 Name 属性中 ➊。然后，如果存在名为
    element 的属性 ➋，我们将 element 属性的值赋给 Element 属性。如果 element 属性不存在，则必须存在 type 属性，此时我们将
    type 属性的值赋给 Type 属性。这三个属性中，只会为任何给定的 SOAP 部分设置其中的两个——SOAP 部分总是具有 Name 属性，并且有一个
    Type 或 Element 属性。Type 或 Element 会根据部分是简单类型（如字符串或整数）还是由另一个 XML 元素包裹的复杂类型来决定。我们需要为每种类型的参数创建一个类，我们将从实现
    Type 类开始。
- en: Defining Port Operations with the SoapPortType Class
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SoapPortType 类定义端口操作
- en: With the SoapMessage and SoapMessagePart classes defined to complete the ParseMessages()
    method from [Listing 3-4](#filepos256350), we move on to create the SoapPortType
    class, which will complete the ParsePortTypes() method. The SOAP port type defines
    the operations available on a given port (not to be confused with a network port),
    and parsing it is detailed in [Listing 3-13](#filepos277536).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 SoapMessage 和 SoapMessagePart 类以完成 [清单 3-4](#filepos256350) 中的 ParseMessages()
    方法之后，我们继续创建 SoapPortType 类，它将完成 ParsePortTypes() 方法。SOAP 端口类型定义了在给定端口上可用的操作（不要与网络端口混淆），其解析过程在[清单
    3-13](#filepos277536)中详细介绍。
- en: public class SoapPortType
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapPortType
- en: '{'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapPortType(XmlNode node)
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapPortType(XmlNode node)
- en: '{'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊node.Attributes["name"].Value;
- en: this.Operations = new List<SoapOperation>();
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Operations = new List<SoapOperation>();
- en: foreach (XmlNode op in node.ChildNodes)
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode op in node.ChildNodes)
- en: this.Operations.Add(new SoapOperation(op));
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Operations.Add(new SoapOperation(op));
- en: '}'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public List<SoapOperation> Operations { get; set; }
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public List<SoapOperation> Operations { get; set; }
- en: '}'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-13: The  SoapPortType  class used in the  ParsePortTypes()  method'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-13：在 ParsePortTypes() 方法中使用的 SoapPortType 类
- en: 'The pattern of how these SOAP classes work continues: the SoapPortType class
    in [Listing 3-13](#filepos277536) defines a small constructor that accepts an
    XmlNode from the WSDL document. It requires two public properties: a SoapOperation
    list and a Name string. Within the SoapPortType constructor, we first assign the
    Name property ➊ to the XML name attribute. We then create a new SoapOperation
    list and iterate over each of the child nodes in the portType element. As we iterate,
    we pass the child node to the SoapOperation constructor (which we build in the
    next section) and store the resulting SoapOperation in our list. An example of
    an XML node from the WSDL document that would be passed to the SoapPortType class
    constructor is shown in [Listing 3-14](#filepos280223).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SOAP 类如何工作的模式是延续的：在[示例 3-13](#filepos277536)中的 SoapPortType 类定义了一个小的构造函数，该构造函数接受来自
    WSDL 文档的 XmlNode。它需要两个公共属性：一个 SoapOperation 列表和一个 Name 字符串。在 SoapPortType 构造函数中，我们首先将
    Name 属性 ➊ 分配给 XML 的 name 属性。然后，我们创建一个新的 SoapOperation 列表，并遍历 portType 元素中的每个子节点。我们在遍历时，将子节点传递给
    SoapOperation 构造函数（在下一节中我们将构建这个构造函数），并将生成的 SoapOperation 存储在我们的列表中。一个来自 WSDL 文档的
    XML 节点示例，它将传递给 SoapPortType 类构造函数，如[示例 3-14](#filepos280223)所示。
- en: <portType name="VulnerableServiceSoap">
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <portType name="VulnerableServiceSoap">
- en: <operation name="AddUser">
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="AddUser">
- en: <input message="s0:AddUserSoapIn"/>
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:AddUserSoapIn"/>
- en: <output message="s0:AddUserSoapOut"/>
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:AddUserSoapOut"/>
- en: </operation>
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: <operation name="ListUsers">
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="ListUsers">
- en: <input message="s0:ListUsersSoapIn"/>
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:ListUsersSoapIn"/>
- en: <output message="s0:ListUsersSoapOut"/>
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:ListUsersSoapOut"/>
- en: </operation>
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: <operation name="GetUser">
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="GetUser">
- en: <input message="s0:GetUserSoapIn"/>
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:GetUserSoapIn"/>
- en: <output message="s0:GetUserSoapOut"/>
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:GetUserSoapOut"/>
- en: </operation>
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: <operation name="DeleteUser">
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <operation name="DeleteUser">
- en: <input message="s0:DeleteUserSoapIn"/>
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <input message="s0:DeleteUserSoapIn"/>
- en: <output message="s0:DeleteUserSoapOut"/>
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <output message="s0:DeleteUserSoapOut"/>
- en: </operation>
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </operation>
- en: '</portType> Listing 3-14: Sample  portType  XML node passed to the  SoapPortType  class
    constructor'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: </portType> 示例 3-14：传递给 SoapPortType 类构造函数的 portType XML 节点示例
- en: As you can see, the portType element contains the operations we’ll be able to
    perform, such as listing, creating, and deleting users. Each of the operations
    maps to a given message, which we parsed in [Listing 3-11](#filepos272170).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，portType 元素包含我们将能够执行的操作，例如列出、创建和删除用户。每个操作都映射到一个特定的消息，我们在[示例 3-11](#filepos272170)中进行了解析。
- en: Implementing a Class for Port Operations
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为端口操作实现一个类
- en: In order to use the operations from the SoapPortType class constructor, we need
    to create the SoapOperation class, as shown in [Listing 3-15](#filepos282268).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用来自 SoapPortType 类构造函数的操作，我们需要创建 SoapOperation 类，如[示例 3-15](#filepos282268)所示。
- en: public class SoapOperation
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public class SoapOperation
- en: '{'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: public SoapOperation(XmlNode op)
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public SoapOperation(XmlNode op)
- en: '{'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: this.Name = ➊op.Attributes["name"].Value;
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Name = ➊op.Attributes["name"].Value;
- en: foreach (XmlNode message in op.ChildNodes)
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (XmlNode message in op.ChildNodes)
- en: '{'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (message.Name.EndsWith("input"))
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (message.Name.EndsWith("input"))
- en: this.Input = message.Attributes["message"].Value;
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Input = message.Attributes["message"].Value;
- en: else if (message.Name.EndsWith("output"))
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else if (message.Name.EndsWith("output"))
- en: this.Output = message.Attributes["message"].Value;
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: this.Output = message.Attributes["message"].Value;
- en: '}'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: public string Name { get; set; }
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Name { get; set; }
- en: public string Input { get; set; }
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Input { get; set; }
- en: public string Output { get; set; }
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public string Output { get; set; }
- en: '}'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 3-15: The  SoapOperation  class'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-15：SoapOperation 类
- en: The SoapOperation constructor accepts an XmlNode as the single argument. The
    first thing we do is assign a property of the SoapOperation class called Name
    ➊ to the name attribute of the operation XML element passed to the constructor.
    We then iterate over each of the child nodes, checking whether the name of the
    element ends with either "input" or "output". If the name of the child node ends
    with "input", we assign the Input property to the name of the input element. Otherwise,
    we assign the Output property to the name of the output element. Now that the
    SoapOperation class has been implemented, we can move on to the classes we need
    to finish up the ParseBindings() method.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: SoapOperation 构造函数接受一个 XmlNode 作为唯一的参数。我们做的第一件事是将 SoapOperation 类中的一个属性 Name
    ➊ 分配给传递给构造函数的操作 XML 元素的 name 属性。然后，我们遍历每个子节点，检查元素的名称是否以 "input" 或 "output" 结尾。如果子节点的名称以
    "input" 结尾，我们将 Input 属性分配给输入元素的名称。否则，我们将 Output 属性分配给输出元素的名称。现在，SoapOperation
    类已经实现，我们可以继续完成 ParseBindings() 方法所需的类。
- en: Defining Protocols Used in SOAP Bindings
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The two general types of bindings are HTTP and SOAP. It seems redundant, but
    the HTTP bindings transport data over the general HTTP protocol, using an HTTP
    query string or POST parameters. SOAP bindings use either the SOAP 1.0 or SOAP
    1.1 protocol over simple TCP sockets or named pipes, which encompass the data
    flowing to and from the server in XML. The SoapBinding class lets you decide how
    to communicate with a given SOAP port depending on the binding.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: A sample binding node from the WSDL is shown in [Listing 3-16](#filepos285096).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: <binding name="VulnerableServiceSoap" type="s0:VulnerableServiceSoap">
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <soap:binding transport="http://schemas.xmlsoap.org/soap/http"/>
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <operation name="AddUser">
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <soap:operation soapAction="http://tempuri.org/AddUser" style="document"/>
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <input>
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <soap:body use="literal"/>
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </input>
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <output>
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <soap:body use="literal"/>
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </output>
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </operation>
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '</binding> Listing 3-16: Sample binding XML node from the WSDL'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In order to parse this XML node, our class needs to pull some key information
    out of the binding node, as shown in [Listing 3-17](#filepos286958).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: public class SoapBinding
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public SoapBinding(XmlNode node)
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Type = ➋node.Attributes["type"].Value;
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.IsHTTP = false;
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Operations = new List<SoapBindingOperation>();
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode op in node.ChildNodes)
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➌op.Name.EndsWith("operation"))
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Operations.Add(new SoapBindingOperation(op));
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else if (op.Name == "http:binding")
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Verb = op.Attributes["verb"].Value;
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.IsHTTP = true;
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public List<SoapBindingOperation> Operations { get; set; }
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool IsHTTP { get; set; }
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Verb { get; set; }
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Type { get; set; }
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-17: The  SoapBinding  class'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: After accepting an XmlNode as the argument to the SoapBinding constructor, we
    first assign the values of the name and type attributes of the node to the Name
    ➊ and Type ➋ properties of the SoapBinding class. By default, we set the IsHTTP
    Boolean property to false. The IsHTTP property helps us determine how to send
    the data we want to fuzz, using either HTTP parameters or SOAP XML.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: As we iterate over the child nodes, we test whether each child node’s name ends
    with "operation" ➌, and, if so, we add the operation to the SoapBindingOperation
    list. If the child node’s name does not end with "operation", the node should
    be an HTTP binding. We ensure this is the case with an else if statement, and
    we set the HTTP Verb property to the value of the verb attribute of the child
    node. We also set IsHTTP to true. The Verb property should contain either GET
    or POST, which tells us whether the data sent to the SOAP endpoint will be in
    query string (GET) parameters or POST parameters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll implement the SoapBindingOperation class.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a List of Operation Child Nodes
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The SoapBindingOperation class is a small class consumed in the SoapBinding
    class constructor. It defines a few string properties that will be assigned values
    based on the operation node passed to the constructor, as shown in [Listing 3-18](#filepos290356).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: public class SoapBindingOperation
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public SoapBindingOperation(XmlNode op)
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = ➊op.Attributes["name"].Value;
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode node in op.ChildNodes)
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➋node.Name == "http:operation")
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Location = node.Attributes["location"].Value;
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else if (node.Name == "soap:operation" || node.Name == "soap12:operation")
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.SoapAction = node.Attributes["soapAction"].Value;
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Location { get; set; }
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string SoapAction { get; set; }
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-18: The  SoapBindingOperation  class'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the XmlNode that’s passed to the constructor, we first assign the Name
    property ➊ to the value of the name attribute on the XML node. The operation node
    contains a few child nodes, but we only really care about three specific nodes:
    http:operation, soap:operation, and soap12:operation. As we iterate over the child
    nodes to find a node we care about, we check whether the operation is an HTTP
    operation or a SOAP operation. If it is an HTTP operation ➋, we store the location
    of the endpoint for the operation, which is a relative URI such as /AddUser. If
    it’s a SOAP operation, we store the SoapAction, which is used in a specific HTTP
    header when making SOAP calls against the SOAP endpoint. When we write the fuzzing
    logic, this information will be used to send the data to the correct endpoint.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Finding the SOAP Services on Ports
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Before we can begin fuzzing, we need to finish parsing the WSDL. We’ll implement
    two more small classes that encompass the SOAP services available and the SOAP
    ports on those services. We must implement the SoapService class first, as shown
    in [Listing 3-19](#filepos292818).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: public class SoapService
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public SoapService(XmlNode node)
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = ➊node.Attributes["name"].Value;
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Ports = new List<SoapPort>();
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (XmlNode port in node.ChildNodes)
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Ports.Add(new SoapPort(port));
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public List<SoapPort> Ports { get; set; }
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-19: The  SoapService  class'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The SoapService class takes an XML node as the only argument to the constructor.
    We first assign the name of the service to the Name property of the class ➊ and
    then create a new list of ports, called SoapPort. As we iterate over the child
    nodes in the service node, we use each child node to create a new SoapPort and
    add the new object to the SoapPort list for later reference.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: A sample service XML node with four child port nodes from a WSDL document is
    shown in [Listing 3-20](#filepos294942).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: <service name="VulnerableService">
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <port name="VulnerableServiceSoap" binding="s0:VulnerableServiceSoap">
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <soap:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </port>
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <port name="VulnerableServiceSoap12" binding="s0:VulnerableServiceSoap12">
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <soap12:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </port>
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <port name="VulnerableServiceHttpGet" binding="s0:VulnerableServiceHttpGet">
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </port>
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <port name="VulnerableServiceHttpPost" binding="s0:VulnerableServiceHttpPost">
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <http:address location="http://127.0.0.1:8080/Vulnerable.asmx"/>
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: </port>
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '</service> Listing 3-20: A sample service node from a WSDL document'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The last thing to do is implement the SoapPort class to complete the ParseServices()
    method and then finish parsing the WSDL for fuzzing. The SoapPort class is shown
    in [Listing 3-21](#filepos296261).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: public class SoapPort
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public SoapPort(XmlNode port)
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Name = ➊port.Attributes["name"].Value;
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Binding = port.Attributes["binding"].Value;
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.ElementType = port.➋FirstChild.Name;
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Location = port.FirstChild.Attributes["location"].Value;
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Name { get; set; }
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Binding { get; set; }
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ElementType { get; set; }
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Location { get; set; }
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-21: The  SoapPort  class'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: To finish parsing the WSDL document, we grab a few attributes from the port
    node passed to the SoapPort constructor. We first store the name of the port in
    the Name property ➊ and the binding in the Binding property. Then, referencing
    the port node’s only child node with the FirstChild property ➋, we store the name
    and location data of the child node in the ElementType and Location properties,
    respectively.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have broken apart the WSDL document into manageable pieces that
    will allow us to easily write a fuzzer to find potential SQL injections. With
    the various parts of the WSDL described as classes, we can programmatically drive
    automatic vulnerability detection and reporting.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Fuzzing the SOAP Endpoint for SQL Injection Vulnerabilities
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Now that the building blocks for the WSDL fuzzer have been built, we can start
    doing some real fun tool development. Using the WSDL class, we can interact with
    the data in the WSDL in an object-oriented manner, which makes fuzzing the SOAP
    endpoint much easier. We start by writing a new Main() method that accepts a single
    argument (the URL to the SOAP endpoint), which can be created in its own file
    inside of its own Fuzzer class, as shown in [Listing 3-22](#filepos299332).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: private static ➊WSDL _wsdl = null;
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: private static ➋string _endpoint = null;
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public static void Main(string[] args)
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _endpoint = ➌args[0];
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Fetching the WSDL for service: " + _endpoint);'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = (HttpWebRequest)WebRequest.Create(_endpoint + "?WSDL");
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XmlDocument wsdlDoc = new XmlDocument();
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (WebResponse resp = req.GetResponse())
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream respStream = resp.GetResponseStream())
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: wsdlDoc.➍Load(respStream);
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _wsdl = new WSDL(wsdlDoc);
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Fetched and loaded the web service description.");
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapService service in _wsdl.Services)
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FuzzService(service);
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-22: The  Main()  method of the SOAP endpoint fuzzer'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: We first declare a couple of static variables at the class level before the
    Main() method. These variables will be used throughout methods we write. The first
    variable is the WSDL class ➊, and the second stores the URL to the SOAP endpoint
    ➋.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Within the Main() method, we assign the _endpoint variable to the value of the
    first argument passed to the fuzzer ➌. Then we print a friendly message alerting
    the user that we are going to fetch the WSDL for the SOAP service.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: After storing the URL to the endpoint, we create a new HttpWebRequest to retrieve
    the WSDL from the SOAP service by appending ?WSDL to the end of the endpoint URL.
    We also create a temporary XmlDocument to store the WSDL and to pass to the WSDL
    class constructor. Passing the HTTP response stream to the XmlDocument Load()
    method ➍, we load the XML returned by the HTTP request into the XML document.
    We then pass the resulting XML document to the WSDL class constructor to create
    a new WSDL object. Now we can iterate over each of the SOAP endpoint services
    and fuzz the service. A foreach loop iterates over the objects in the WSDL class
    Services property and passes each service to the FuzzService() method, which we’ll
    write in the next section.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing Individual SOAP Services
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The FuzzService() method takes a SoapService as an argument and then determines
    whether we need to fuzz the service using SOAP or HTTP parameters, as shown in
    [Listing 3-23](#filepos302490).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: static void FuzzService(SoapService service)
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Fuzzing service: " + service.Name);'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapPort port in service.Ports)
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Fuzzing " + port.ElementType.Split('':'')[0] + " port: "
    + port.Name);'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapBinding binding = _wsdl.Bindings.➊Single(b => b.Name == port.Binding.Split(':')[1]);
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (binding.➋IsHTTP)
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FuzzHttpPort(binding);
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FuzzSoapPort(binding);
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-23: The  FuzzService()  method used to determine how to fuzz a given  SoapService'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: After printing the current service we’ll be fuzzing, we iterate over each SOAP
    port in the Ports service property. Using the Language-Integrated Query (LINQ)
    Single() method ➊, we select a single SoapBinding that corresponds to the current
    port. Then we test whether the binding is plain HTTP or XML-based SOAP. If the
    binding is an HTTP binding ➋, we pass it to the FuzzHttpPort() method to fuzz.
    Otherwise, we assume the binding is a SOAP binding and pass it to the FuzzSoapPort()
    method.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s implement the FuzzHttpPort() method. The two types of possible HTTP
    ports when you’re dealing with SOAP are GET and POST. The FuzzHttpPort() method
    determines which HTTP verb will be used when sending the HTTP requests during
    fuzzing, as shown in [Listing 3-24](#filepos304406).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: static void FuzzHttpPort(SoapBinding binding)
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (binding.Verb == "GET")
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FuzzHttpGetPort(binding);
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else if (binding.Verb == "POST")
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FuzzHttpPostPort(binding);
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'throw new Exception("Don''t know verb: " + binding.Verb);'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-24: The  FuzzHttpPort()  method'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The FuzzHttpPort() method is very simple. It tests whether the SoapBinding property
    Verb equals GET or POST and then passes the binding to the appropriate method—FuzzHttpGetPort()
    or FuzzHttpPostPort(), respectively. If the Verb property does not equal either
    GET or POST, an exception is thrown to alert the user that we don’t know how to
    handle the given HTTP verb.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the FuzzHttpPort() method, we’ll implement the FuzzHttpGetPort()
    method.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Creating the URL to Fuzz
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Both of the HTTP fuzzing methods are a bit more complex than the previous methods
    in the fuzzer. The first half of the FuzzHttpGetPort() method, covered in [Listing
    3-25](#filepos307580), builds the initial URL to fuzz.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: static void FuzzHttpGetPort(SoapBinding binding)
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapPortType portType = _wsdl.PortTypes.➊Single(pt => pt.Name == binding.Type.Split(':')[1]);
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapBindingOperation op in binding.Operations)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Fuzzing operation: " + op.Name);'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string url = ➋_endpoint + op.Location;
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionary<string, string> parameters = new Dictionary<string, string>();
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapMessagePart part in input.Parts)
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parameters.Add(part.Name, part.Type);
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bool ➌first = true;
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<Guid> guidList = new List<Guid>();
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (var param in parameters)
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (param.Value.EndsWith("string"))
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guid guid = Guid.NewGuid();
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: guidList.Add(guid);
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'url ➍+= (first ?➎ "?" : "&") + param.Key + "=" + guid.ToString();'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: first = false;
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-25: The first half of the  FuzzHttpGetPort()  method, where we build
    the initial URL to fuzz'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do in the FuzzHttpGetPort() method is use LINQ ➊ to select
    the port type from our WSDL class that corresponds to the current SOAP binding.
    We then iterate over the current binding’s Operations property, which contains
    information regarding each operation we can call and how to call the given operation.
    As we iterate, we print which operation we are going to fuzz. We then create the
    URL that we’ll use to make the HTTP request for the given operation by appending
    the Location property of the current operation to the _endpoint variable we set
    at the very beginning of the Main() method ➋. We select the current SoapOperation
    (not to be confused with the SoapBindingOperation!) from the Operations property
    of the portType using the LINQ method Single(). We also select the SoapMessage
    used as the input for the current operation using the same LINQ method, which
    tells us what information the current operation is expecting when called.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the information we need to set up the GET URL, we create a dictionary
    to hold the HTTP parameter names and the parameter types we’ll be sending. We
    iterate over each of the input parts using a foreach loop. As we iterate, we add
    the name of each parameter and the type, which in this case will always be a string,
    to the dictionary. After we have all of our parameter names and their respective
    types stored alongside each other, we can build the initial URL to fuzz.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we define a Boolean called first ➌, which we’ll use to determine whether
    the parameter that’s appended to the operation’s URL is the first parameter. This
    is important because the first query string parameter is always separated from
    the base URL by a question mark (?), and subsequent parameters are separated with
    an ampersand (&), so we need to be sure of the distinction. Then, we create a
    Guid list, which will hold unique values that we send along with the parameters
    so we can reference them in the second half of the FuzzHttpGetPort() method.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Next, we iterate over the parameters dictionary using a foreach loop. In this
    foreach loop, first we test whether the current parameter’s type is a string.
    If it’s a string, we create a new Guid that will be used as the parameter’s value;
    then we add the new Guid to the list we created so we can reference it later.
    We then use the += operator ➍ to append the parameter and the new value to the
    current URL. Using a ternary operation ➎, we determine whether we should prefix
    the parameter with a question mark or ampersand. This is how the HTTP query string
    parameters must be defined per the HTTP protocol. If the current parameter is
    the first parameter, it is prepended with a question mark. Otherwise, it is prepended
    with an ampersand. Finally, we set the parameter to false so that subsequent parameters
    will be prepended with the correct separating character.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing the Created URL
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: After creating the URL with query string parameters, we can make HTTP requests
    while systematically replacing parameter values with tainted values that could
    induce a SQL error from the server, as shown in [Listing 3-26](#filepos313361).
    This second half of the code completes the FuzzHttpGetPort() method.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Fuzzing full url: " + url);'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int k = 0;
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach(Guid guid in guidList)
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string testUrl = url.➊Replace(guid.ToString(), "fd'sa");
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = (HttpWebRequest)WebRequest.Create(testUrl);
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new ➋StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.ReadToEnd();
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌catch (WebException ex)
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.ReadToEnd();
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (resp.Contains("syntax error"))
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: " + input.➍Parts[k].Name);'
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k++;
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-26: The second half of the  FuzzHttpGetPort()  method, sending the
    HTTP requests'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the full URL that we’ll be fuzzing, we print it for the user
    to see. We also declare an integer, k, that will be incremented as we iterate
    over the parameter values in the URL to keep track of potentially vulnerable parameters.
    Then, using a foreach loop, we iterate over the Guid list we used as the values
    for our parameters. Within the foreach loop, the first thing we do is replace
    the current Guid in the URL with the string "fd'sa" using the Replace() method
    ➊, which should taint any SQL queries using the value without proper sanitization.
    We then create a new HTTP request with the modified URL and declare an empty string
    called resp that will hold the HTTP response.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Within a try/catch block, we attempt to read the response of the HTTP request
    from the server using a StreamReader ➋. Reading the response will cause an exception
    if the server returns a 500 error (which would happen if a SQL exception occurred
    on the server side). If an exception is thrown, we catch the exception in the
    catch block ➌ and attempt to read the response from the server again. If the response
    contains the string syntax error, we print a message alerting the user that the
    current HTTP parameter could be vulnerable to a SQL injection. In order to tell
    the user precisely which parameter could be vulnerable, we use the integer k as
    the index of the Parts list ➍ and retrieve the Name of the current property. When
    all is said and done, we increment the integer k by 1 and start back at the beginning
    of the foreach loop with a new value to test.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: That’s the full method for fuzzing HTTP GET SOAP ports. Next, we need to implement
    FuzzHttpPostPort() to fuzz POST SOAP ports.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing the HTTP POST SOAP Port
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing the HTTP POST SOAP port for a given SOAP service is very similar to
    fuzzing the GET SOAP port. The only difference is that the data is sent as HTTP
    POST parameters instead of query-string parameters. When passing the SoapBinding
    for the HTTP POST port to the FuzzHttpPostPort() method, we need to iterate over
    each operation and systematically taint values sent to the operations to induce
    SQL errors from the web server. [Listing 3-27](#filepos317685) shows the first
    half of the FuzzHttpPostPort() method.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: static void FuzzHttpPostPort(SoapBinding binding)
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➊SoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapBindingOperation op in binding.Operations)
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Fuzzing operation: " + op.Name);'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string url = _endpoint + op.Location;
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➋SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionary<string, string> parameters = new ➌Dictionary<string, string>();
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapMessagePart part in input.Parts)
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'parameters.Add(part.Name, part.Type); Listing 3-27: Determining the operation
    and parameters to fuzz within the  FuzzHttpPostPort()  method'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First we select the SoapPortType ➊ that corresponds to the SoapBinding passed
    to the method. We then iterate over each SoapBindingOperation to determine the
    current SoapBinding using a foreach loop. As we iterate, we print a message that
    specifies which operation we are currently fuzzing, and then we build the URL
    to send the data we are fuzzing to. We also select the corresponding SoapOperation
    ➋ for the portType variable so that we can find the SoapMessage we need, which
    contains the HTTP parameters we need to send to the web server. Once we have all
    the information we need to build and make valid requests to the SOAP service,
    we build a small dictionary ➌ containing the parameter names and their types to
    iterate over later.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Now we can build the HTTP parameters we’ll send to the SOAP service, as shown
    in [Listing 3-28](#filepos319979). Continue entering this code into the FuzzHttpPostPort()
    method.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: string postParams = string.Empty;
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bool first = true;
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<Guid> guids = new List<Guid>();
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (var param in parameters)
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (param.Value.➊EndsWith("string"))
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guid guid = Guid.NewGuid();
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'postParams += (first ➋? "" : "&") + param.Key + "=" + guid.ToString();'
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: guids.Add(guid);
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (first)
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: first = ➌false;
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-28: Building the POST parameters to be sent to the POST HTTP SOAP
    port'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the data we need to build the POST requests. We declare a string
    to hold the POST parameters, and we declare a Boolean, which will determine whether
    the parameter will be prefixed with an ampersand, to delineate the POST parameters.
    We also declare a Guid list so that we can store the values we add to the HTTP
    parameters for use later in the method.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Now we can iterate over each of the HTTP parameters using a foreach loop and
    build the parameters string that we’ll send in the POST request body. As we iterate,
    first we check whether the parameter type ends with string ➊. If it does, we create
    a string for a parameter value. To track which string values we use and to ensure
    each value is unique, we create a new Guid and use this as the parameter’s value.
    Using a ternary operation ➋, we determine whether we should prefix the parameter
    with an ampersand. We then store the Guid in the Guid list. Once we have appended
    the parameter and value to the POST parameters string, we check the Boolean value
    and, if it is true, set it to false ➌ so that later POST parameters will be delineated
    with an ampersand.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to send the POST parameters to the server and then read the response
    and check for any errors, as [Listing 3-29](#filepos323372) shows.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: int k = 0;
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (Guid guid in guids)
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string testParams = postParams.➊Replace(guid.ToString(), "fd'sa");
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] data = System.Text.Encoding.ASCII.GetBytes(testParams);
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = ➋(HttpWebRequest) WebRequest.Create(url);
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.Method = "POST";
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentType = "application/x-www-form-urlencoded";
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentLength = data.Length;
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.GetRequestStream().➌Write(data, 0, data.Length);
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.➍ReadToEnd();
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '} catch (WebException ex)'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.ReadToEnd();
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (resp.➎Contains("syntax error"))
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: " + input.Parts[k].Name);'
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k++;
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-29: Sending the POST parameters to the SOAP service and checking
    for server errors'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: To start off, we declare an integer named k, which will be incremented and used
    throughout the fuzzing to keep track of potentially vulnerable parameters, and
    we assign k a value of 0\. Then we iterate over the Guid list using a foreach
    loop. As we iterate, the first thing we do is create a new POST parameter string
    by replacing the current Guid with a tainted value using the Replace() method
    ➊. Because each Guid is unique, when we replace the Guid, it will only change
    a single parameter’s value. This lets us determine exactly which parameter has
    a potential vulnerability. Next, we send the POST request and read the response.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the new POST parameter string to send to the SOAP service, we convert
    the string to an array of bytes using the GetBytes() method that will be written
    to the HTTP stream. We then build the HttpWebRequest ➋ to send the bytes to the
    server and set the HttpWebRequest’s Method property to "POST", the ContentType
    property to application/x-www-form-urlencoded, and the ContentLength property
    to the size of the byte array. Once this is built, we write the byte array to
    the request stream by passing the byte array, the index of the array to begin
    writing from (0), and the number of bytes to write to the Write() method ➌.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: After the POST parameters have been written to the request stream, we need to
    read the response from the server. After declaring an empty string to hold the
    HTTP response, we use a try/catch block to catch any exceptions thrown while reading
    from the HTTP response stream. Creating a StreamReader in the context of a using
    statement, we attempt to read the entire response with the ReadToEnd() method
    ➍ and assign the response to an empty string. If the server responds with an HTTP
    code of 50x (which means an error occurred on the server side), we catch the exception,
    attempt to read the response again, and reassign the response string to the empty
    string to update it. If the response contains the phrase syntax error ➎, we print
    a message alerting the user that the current HTTP parameter could be vulnerable
    to a SQL injection. To determine which parameter was vulnerable, we use the integer
    k as the index of the parameter list to get the current parameter’s Name. Finally,
    we increment the k integer by 1 so that the next parameter will be referenced
    in the next iteration, and then we start the process over again for the next POST
    parameter.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: That completes the FuzzHttpGetPort() and FuzzHttpPostPort() methods. Next, we’ll
    write the FuzzSoapPort() method to fuzz the SOAP XML port.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing the SOAP XML Port
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: In order to fuzz the SOAP XML port, we need to dynamically build XML to send
    to the server, which is slightly more difficult than building HTTP parameters
    to send in a GET or POST request. Starting off, though, the FuzzSoapPort() method
    is similar to FuzzHttpGetPort() and FuzzHttpPostPort(), as shown in [Listing 3-30](#filepos328219).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: static void FuzzSoapPort(SoapBinding binding)
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapBindingOperation op in binding.Operations)
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.➊WriteLine("Fuzzing operation: " + op.Name);'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapOperation po = portType.Operations.Single(p => p.Name == op.Name);
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'SoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split('':'')[1]);
    Listing 3-30: Gathering initial information to build dynamic SOAP XML'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with the GET and POST fuzzing methods, we need to collect some information
    about what we are going to fuzz before we can do anything. We first grab the corresponding
    SoapPortType from the _wsdl.PortTypes property using LINQ; then we iterate over
    each operation with a foreach loop. As we iterate, we print the current operation
    we are fuzzing to the console ➊. In order to send the correct XML to the server,
    we need to select the SoapOperation and SoapMessage classes that correspond to
    the SoapBinding class passed to the method. Using the SoapOperation and SoapMessage,
    we can dynamically build the XML required. To do this, we use LINQ to XML, which
    is a set of built-in classes in the System.Xml.Linq namespace that lets you create
    simple, dynamic XML, as shown in [Listing 3-31](#filepos330717).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: XNamespace soapNS = "http://schemas.xmlsoap.org/soap/envelope/";
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XNamespace xmlNS = op.➊SoapAction.Replace(op.Name, string.Empty);
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XElement soapBody = new XElement(soapNS + "Body");
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XElement soapOperation = new ➋XElement(xmlNS + op.Name);
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: soapBody.Add(soapOperation);
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<Guid> paramList = new List<Guid>();
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SoapType type = _wsdl.Types.➌Single(t => t.Name == input.Parts[0].Element.Split(':')[1]);
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (SoapTypeParameter param in type.Parameters)
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: XElement soapParam = new ➍XElement(xmlNS + param.Name);
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (param.Type.EndsWith("string"))
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guid guid = Guid.NewGuid();
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: paramList.Add(guid);
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: soapParam.➎SetValue(guid.ToString());
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: soapOperation.Add(soapParam);
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-31: Building the dynamic SOAP XML using LINQ to XML in the SOAP fuzzer'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: We first create two XNameSpace instances to use when building the XML. The first
    XNameSpace is the default SOAP namespace, but the second XNameSpace will change
    based on the current operation’s SoapAction property ➊. After the namespaces are
    defined, we create two new XML elements using the XElement class. The first XElement
    (which will be called <Body>) is a standard XML element used in SOAP and will
    encapsulate the data for the current SOAP operation. The second XElement will
    be named after the current operation ➋. The XElement instances use the default
    SOAP namespace and the SOAP operation namespace, respectively. We then add the
    second XElement to the first using the XElement Add() method so that the SOAP
    <Body> XML element will contain the SOAP operation element.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: After creating the outer XML elements, we create a Guid list to store the values
    we generate, and we also select the current SoapType with LINQ ➌ so that we can
    iterate over the parameters required for the SOAP call. As we iterate, we first
    create a new XElement for the current parameter ➍. If the parameter type is a
    string, we assign the XElement a Guid for a value using SetValue() ➎ and store
    the Guid in the Guid list we created for reference later. We then add the XElement
    to the SOAP operation element and move on to the next parameter.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Once we have completed adding the parameters to the SOAP operation XML node,
    we need to put the whole XML document together, as shown in [Listing 3-32](#filepos333407).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: XDocument soapDoc = new XDocument(new XDeclaration("1.0", "ascii", "true"),
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: new ➊XElement(soapNS + "Envelope",
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: new XAttribute(XNamespace.Xmlns + "soap", soapNS),
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: new XAttribute("xmlns", xmlNS),
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➋soapBody)); Listing 3-32: Putting the whole SOAP XML document together'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We need to create an XDocument with one more XElement called the SOAP Envelope
    ➊. We create a new XDocument by passing a new XElement to the XDocument constructor.
    The XElement, in turn, is created with a couple of attributes defining the node’s
    XML namespaces, as well as with the SOAP body we built with the parameters ➋.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Now that the XML is built, we can send the XML to the web server and attempt
    to induce SQL errors, as [Listing 3-33](#filepos335195) shows. Continue to add
    this code to the FuzzSoapPort() method.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: int k = 0;
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (Guid parm in paramList)
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string testSoap = soapDoc.ToString().➊Replace(parm.ToString(), "fd'sa");
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] data = System.Text.Encoding.ASCII.GetBytes(testSoap);
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = (HttpWebRequest) WebRequest.Create(_endpoint);
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.Headers["SOAPAction"] = ➋op.SoapAction;
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.Method = "POST";
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentType = "text/xml";
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentLength = data.Length;
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream stream = req.GetRequestStream())
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'stream.➌Write(data, 0, data.Length); Listing 3-33: Creating the  HttpWebRequest  to
    send the SOAP XML to the SOAP endpoint'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with the fuzzers covered previously in the chapter, we iterate over each
    Guid in the list of values that we created while building the XML for the SOAP
    operation. As we iterate, we replace the current Guid in the SOAP XML body with
    a value that should induce a SQL error if that value is being used in a SQL query
    unsafely ➊. After we replace the Guid with the tainted value, we convert the resulting
    string into a byte array using the GetBytes() method, which we’ll write to the
    HTTP stream as POST data.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: We then build the HttpWebRequest that we’ll use to make the HTTP request and
    read the result. One special piece to note is the SOAPAction header ➋. This SOAPAction
    HTTP header will be used by the SOAP endpoint to determine which action is performed
    with the data, such as listing or deleting users. We also set the HTTP method
    to POST, the content type to text/xml, and the content length to the length of
    the byte array we created. Finally, we write the data to the HTTP stream ➌. Now
    we need to read the response from the server and determine whether the data we
    sent induced any SQL errors, as [Listing 3-34](#filepos337934) shows.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.➊ReadToEnd();
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: catch (WebException ex)
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.ReadToEnd();
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (resp.➋Contains("syntax error"))
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Possible SQL injection vector in parameter: ");'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.Write(type.Parameters[k].Name);
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: k++;
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 3-34: Reading the HTTP stream in the SOAP fuzzer and looking for errors'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-34](#filepos337934) uses almost the same code as the fuzzers in
    Listings [3-26](#filepos313361) and [3-29](#filepos323372) to check for a SQL
    error, but in this case we’re handling the detected error differently. First,
    we declare a string to hold the HTTP response and begin a try/catch block. Then,
    within the context of a using statement, we use a StreamReader to attempt to read
    the contents of the HTTP response and store the response in a string ➊. If an
    exception is thrown because the HTTP server returned a 50x error, we catch the
    exception and try to read the response again. If an exception is thrown and the
    response data contains the phrase syntax error ➋, we print a message to alert
    the user about a possible SQL injection and the potentially vulnerable parameter
    name. Finally, we increment k and go on to the next parameter.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Running the Fuzzer
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the fuzzer against the vulnerable SOAP service appliance CsharpVulnSoap.
    The fuzzer takes a single argument: the URL to the vulnerable SOAP endpoint. In
    this case, we’ll use [http://192.168.1.15/Vulnerable.asmx](http://192.168.1.15/Vulnerable.asmx).
    Passing the URL as the first argument and running the fuzzer should yield similar
    output to [Listing 3-35](#filepos341828).'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: $ mono ch3_soap_fuzzer.exe http://192.168.1.15/Vulnerable.asmx
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fetching the WSDL for service: http://192.168.1.15/Vulnerable.asmx'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fetched and loaded the web service description.
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing service: VulnerableService'
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing soap port: ➊VulnerableServiceSoap'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: AddUser'
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: password'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing http port: ➋VulnerableServiceHttpGet'
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: AddUser'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing full url: http://192.168.1.15/Vulnerable.asmx/AddUser?username=a7ee0684-'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: fd54-41b4-b644-20b3dd8be97a&password=85303f3d-1a68-4469-bc69-478504166314
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: password'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: ListUsers'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing full url: http://192.168.1.15/Vulnerable.asmx/ListUsers'
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing http port: ➌VulnerableServiceHttpPost'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: AddUser'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: password'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: ListUsers'
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: GetUser'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: username'
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Fuzzing operation: DeleteUser'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Possible SQL injection vector in parameter: username Listing 3-35: Partial
    output from the SOAP fuzzer running against the CsharpVulnSoap application'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From the output, we can see the various stages of the fuzzing. Starting with
    the VulnerableServiceSoap port ➊, we find that the AddUser operation might be
    vulnerable to SQL injection in the username and password fields passed to the
    operation. Next is the VulnerableServiceHttpGet port ➋. We fuzz the same AddUser
    operation and print the URL we built, which we can paste into a web browser to
    see what the response of a successful call is. Again, the username and password
    parameters were found to be potentially vulnerable to SQL injection. Finally,
    we fuzz the VulnerableServiceHttpPost SOAP port ➌, first fuzzing the AddUser operation,
    which reports the same as the previous ports. The ListUsers operation reports
    no potential SQL injections, which makes sense because it has no parameters to
    begin with. Both the GetUser and DeleteUser operations are potentially vulnerable
    to SQL injection in the username parameter.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the XML classes available from the core
    libraries. We used the XML classes to implement a full SOAP service SQL injection
    fuzzer, and we covered a few of the methods of interacting with a SOAP service.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: The first and most simple method was via HTTP GET requests, where we built URLs
    with dynamic query string parameters based on the how the WSDL document described
    the SOAP service. Once this was implemented, we built a method to fuzz POST requests
    to the SOAP service. Finally, we wrote the method to fuzz the SOAP XML using the
    LINQ to XML libraries in C# to dynamically create the XML used to fuzz the server.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: The powerful XML classes in C# make consuming and dealing with XML a breeze.
    With so many enterprise technologies reliant on XML for cross-platform communication,
    serialization, or storage, understanding how to efficiently read and create XML
    documents on the fly can be incredibly useful, especially for a security engineer
    or pentester.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
