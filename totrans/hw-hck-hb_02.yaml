- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: 'Reaching Out, Touching Me, Touching You: Hardware Peripheral Interfaces'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸我，触摸你：硬件外设接口
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Most embedded devices use standardized communication interfaces to interact
    with other chips, users, and the world. Since those interfaces are generally low
    level, rarely externally accessible, and dependent on interoperability between
    different manufacturers, they generally don’t have any protections, obfuscations,
    or encryption applied to them. In this chapter, we’ll discuss some electrical
    basics that are helpful for understanding how these various interface types work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式设备使用标准化的通信接口与其他芯片、用户和外界进行交互。由于这些接口通常处于低级别，且很少对外开放，并依赖于不同制造商之间的互操作性，因此它们通常没有应用任何保护、混淆或加密。在本章中，我们将讨论一些有助于理解这些不同类型接口工作的电气基础知识。
- en: 'After that, we’ll look at examples from three groups of communications interfaces:
    low-speed serial interfaces, parallel interfaces, and high-speed serial interfaces.
    The easiest to monitor or emulate are the *low-speed serial interfaces* used for
    most basic communications. Devices that require greater performance or bandwidth
    can be more difficult to interact with and tend to use *parallel interfaces*.
    Parallel interfaces are rapidly transitioning to *high-speed serial interfaces*,
    which can reliably run in the gigahertz range even on the cheapest embedded devices,
    but interacting with them often requires specialized hardware.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看来自三类通信接口的示例：低速串行接口、并行接口和高速串行接口。最容易监控或仿真的是用于大多数基本通信的*低速串行接口*。需要更高性能或带宽的设备可能更难与之交互，且往往使用*并行接口*。并行接口正在迅速过渡到*高速串行接口*，即使是在最便宜的嵌入式设备上，也能可靠地运行在千兆赫范围内，但与它们交互通常需要专用的硬件。
- en: When analyzing embedded systems, you need to be aware of the many interconnected
    components that need to communicate and then decide whether the components and
    communication channels are trusted. These interfaces are one of the most critical
    aspects of embedded security, and yet embedded systems designers often assume
    attackers don’t have physical access to these communication channels, so they
    assume they can trust any interface. This assumption provides attackers with an
    opportunity to listen in passively or participate actively, impacting the device’s
    security.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析嵌入式系统时，你需要意识到需要相互通信的多个互联组件，并决定这些组件和通信通道是否可信。这些接口是嵌入式安全性中最关键的方面之一，然而，嵌入式系统设计人员常常假设攻击者无法物理接触这些通信通道，因此他们认为可以信任任何接口。这个假设给攻击者提供了一个机会，可以被动监听或主动参与，从而影响设备的安全性。
- en: Electricity Basics
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电学基础
- en: When interacting with different kinds of interfaces, it’s helpful to understand
    some basic electricity terms. If you’re familiar with voltage, current, resistance,
    reactance, impedance, inductance, and capacitance, and if you know that AC/DC
    is not only the name of an Australian rock band, feel free to skip this section.
    (If you are unfamiliar with the Australian rock band AC/DC, we recommend getting
    started with the high-voltage song “Thunderstruck.”)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在与不同种类的接口交互时，了解一些基本的电学术语非常有帮助。如果你熟悉电压、电流、阻力、反应性、电抗、感抗和电容，并且知道AC/DC不仅仅是澳大利亚摇滚乐队的名字，那就可以跳过这一部分。（如果你不熟悉澳大利亚摇滚乐队AC/DC，建议你先从高电压的歌曲《Thunderstruck》开始了解。）
- en: Voltage
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电压
- en: The *volt* (*V*, expressed in units V and named after Alessandro Volta) is the
    electrical unit of voltage. It refers to *electric potential*, or how hard the
    electrons are pushing to get from point A to point B. Think of voltage on a wire
    as analogous to water pressure in a hose, or how hard the water is pushing to
    get from point A to point B.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*伏特*（*V*，单位为V，得名于亚历山德罗·伏特）是电压的电学单位。它指的是*电势*，即电子从A点到B点推动的力度。可以把电线中的电压比作水管中的水压，或者说水从A点到B点推动的力度。'
- en: Voltage is always measured between two points. For example, if you take a multimeter
    and an AA battery, you can measure the voltage between negative and positive and
    observe that the differential is 1.5 V (if it’s lower than 1.3 V, it’s probably
    time to get a new battery). If you switch the two measurement probes, you’ll see
    a differential of –1.5 V.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 电压总是测量两个点之间的差值。例如，如果你拿一只万用表和一节AA电池，你可以测量负极和正极之间的电压，并观察到电压差为1.5 V（如果低于1.3 V，可能是时候换电池了）。如果你交换两个测量探针，你会看到电压差为–1.5
    V。
- en: When people mention only one point with regard to voltage, they are actually
    talking about the voltage of that point relative to the so-called *ground*. Ground
    is normally the common reference for a system; in such a case, ground is by definition
    at 0 V.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们仅提及电压的某一点时，他们实际上是在谈论该点相对于所谓的*地线*的电压。地线通常是系统的公共参考；在这种情况下，地线的电压定义为0 V。
- en: Current
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当前
- en: The *ampere* (*I*, expressed in units A and named after André-Marie Ampère)
    is the measure of *electrical flow* or *current*, which refers to the number of
    electrons moving past a certain point in a given amount of time. Current in a
    wire is analogous to water flow in a hose, but instead of measuring the water
    that passes through a cross section of the hose, with electrical circuits, you
    count the electrons that pass through a cross section of a wire. Everything else
    being equal, more water pressure means more water would flow through the hose
    in the same amount of time. Likewise, more voltage across a wire means more current
    would flow through it in the same amount of time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*安培*（*I*，单位为A，以安德烈-玛丽·安培命名）是衡量*电流*的单位，指的是在一定时间内通过某一点的电子数量。电线中的电流类似于水管中的水流，但与其测量水流通过水管的横截面不同，在电路中，我们统计的是通过电线横截面的电子数量。其他条件相同的情况下，更高的水压意味着相同时间内更多的水流通过水管。同样，电线两端的电压越高，相同时间内通过的电流也越大。'
- en: For humans, 100 mA is roughly what’s needed to stop their hearts, and in embedded
    devices, you can easily encounter currents of multiple amps. Luckily, the voltage
    needs to be much higher than the common voltages used in electronics in order
    to push that current through your body. Although both authors have lived through
    110 V zaps to tell this story, the unpleasantness of those experiences leads us
    to recommend against touching live circuits, even when you think it’s a safe voltage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类来说，100 mA大约是足以使心脏停搏的电流，而在嵌入式设备中，你很容易遇到数安培的电流。幸运的是，为了让电流通过人体，所需的电压需要比电子设备中常见的电压高得多。尽管两位作者都曾经经历过110
    V电击并讲述这个故事，但这些不愉快的经历使我们建议避免触摸带电电路，即使你认为那是一个安全电压。
- en: Resistance
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电阻
- en: The *ohm* (*R*, expressed in units Ω and named after Georg Simon Ohm) is the
    measure of *electrical resistance*, or how difficult it is for electrons to pass
    between two points. Continuing with the water flow analogy, resistance is comparable
    to how wide or narrow a hose is (or how clogged the inside of the hose might be).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*欧姆*（*R*，单位为Ω，以乔治·西蒙·欧姆命名）是衡量*电阻*的单位，表示电子通过两个点的难易程度。继续使用水流的类比，电阻类似于水管的宽度或狭窄程度（或者水管内部可能有多堵塞）。'
- en: Ohm’s Law
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 欧姆定律
- en: Volts, amps, and ohms are closely related. *Ohm’s law* summarizes this relationship
    as *V* = *I* × *R*, whichstates that knowing any two parameters allows you to
    calculate the third parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 电压、电流和电阻是紧密相关的。*欧姆定律*总结了这种关系：*V* = *I* × *R*，该公式指出，知道任意两个参数就能计算出第三个参数。
- en: This means if you know the voltage on a wire (potential), as well as the ohm
    value of the wire (resistance), you can calculate the amperage across the wire
    (flow).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你知道电线上的电压（电势）以及电线的欧姆值（电阻），你就可以计算电线上的电流（流量）。
- en: AC/DC
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交流电/直流电
- en: '*Direct current (DC)* and *alternating current (AC)* refer to constant and
    varying currents, respectively. Modern electronics are powered from DC sources,
    such as batteries and DC power supplies. AC is a sinusoidally varying voltage
    (and thus current), generally seen on the 240 V or 110 V power grid, but sinusoidally
    varying voltages are also used in electronic equipment, such as switched power
    supplies. In this book, we measure variations in current as determined by the
    varying activities in the device’s circuitry. The constant current consumption
    is the DC component of this measurement, and the variation of that supply current,
    in which we are very interested, is what can loosely be termed the AC component.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*直流电 (DC)* 和 *交流电 (AC)* 分别指的是恒定和变化的电流。现代电子设备使用来自直流电源的电力，如电池和直流电源。交流电是正弦波变化的电压（因此也是电流），通常出现在240
    V或110 V电力网中，但正弦波变化的电压也用于电子设备中，例如开关电源。在本书中，我们通过设备电路中的活动变化来测量电流的变化。恒定的电流消耗是该测量的直流分量，而我们非常关注的电流变化部分，可以宽泛地称为交流分量。'
- en: Picking Apart Resistance
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆解电阻
- en: '*Impedance* in AC is equivalent to resistance in DC. In AC, impedance is a
    complex number made up of resistance and reactance, and it depends on the AC signal’s
    frequency. *Reactance* is a function of inductance and capacitance.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在交流电中，*阻抗*等同于直流电中的电阻。在交流电中，阻抗是由电阻和反应抗组成的复数，并且它依赖于交流信号的频率。*反应抗*是感抗和容抗的函数。
- en: '*Inductance* is the resistance (as in “objection”) by the circuit to a change
    in current. Returning to the water analogy, if water is flowing in one direction,
    it’ll take some energy to push the water in the opposite direction due to the
    flowing water’s kinetic energy. With inductance, this energy resides in the magnetic
    field around a wire that has current flowing through it, and it needs a “push”
    in the opposite direction before the current’s direction is reversed. Inductance
    causes a voltage proportional to the variation (change) in current. The unit of
    inductance is the *henry*, after Joseph Henry.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*电感*是电路对电流变化的抵抗（类似“反对”）。回到水的类比，如果水流向一个方向，那么由于流动水的动能，要将水推向相反的方向需要一些能量。在电感中，这个能量存储在流过导线的磁场中，需要一个“反向推力”才能改变电流方向。电感引起的电压与电流变化（变化）成正比。电感的单位是*亨利*，以约瑟夫·亨利命名。'
- en: '*Capacitance* is the resistance to a change in voltage. Consider a vertical
    pipe connected to a tank and connected to a horizontal pipe with flowing water
    (see [Figure 2-1](#figure2-1)).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*电容*是对电压变化的抗拒。考虑一个连接到水箱的竖直管道，并与一个水平管道相连，水流通过（见[图2-1](#figure2-1)）。'
- en: '![f02001](image_fi/278748c02/f02001.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](image_fi/278748c02/f02001.png)'
- en: 'Figure 2-1: If electricity is like water, a capacitor is like a water tank.
    On the left, the tank is “charging,” and on the right the tank is “discharging.”'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：如果电流像水一样，那么电容器就像一个水箱。左侧是水箱在“充电”，右侧是水箱在“放电”。
- en: While there is high input pressure on the pipe ([Figure 2-1](#figure2-1), left),
    water is constantly flowing into the tank, until it is full. If the pressure drops
    at the input, the tank starts to drain until it is empty. The analogy here is
    that the pressure in the vertical pipe relates to the voltage over the capacitor,
    and the amount of water in the tank relates to the charge held by the capacitor.
    If the voltage over the capacitor is high enough to “push the water level up,”
    the capacitor will take in charge. If it’s too low, the capacitor will “drain
    water” and release charge. Up to its capacity, the tank will counteract pressure
    changes at the output, and the capacitor will counteract voltage changes at the
    output. Capacitance is related to the ability of an electrical component to store
    charge, and it causes a current proportional to the variation (change) in voltage.
    The unit of capacitance is the *farad,* named for Michael Faraday.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道中有较高的输入压力时（见[图2-1](#figure2-1)，左侧），水不断流入水箱，直到水箱满。若输入压力下降，水箱开始排水，直到水空为止。这里的类比是，竖直管道中的压力与电容器上的电压相关，而水箱中的水量与电容器所储存的电荷相关。如果电容器上的电压足够高以“推高水位”，电容器将吸入电荷。如果电压太低，电容器则会“排水”并释放电荷。水箱会在其容量范围内反抗输出端的压力变化，而电容器则会反抗输出端的电压变化。电容与电气元件储存电荷的能力相关，并且它会引起与电压变化成正比的电流。电容的单位是*法拉*，以迈克尔·法拉第命名。
- en: Power
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功率
- en: Power is the amount of energy in *Joules* consumed per second, expressed as
    *P* in units of *W* (*watts*, after James Watt). In electronic circuits, this
    energy is almost exclusively turned into heat. This is called *power dissipation*,
    and the *power rule* for a given load, which is *P* = *I* × *I* × *R*, expresses
    it. The power dissipation *P* increases by the square of the current *I* and linearly
    with resistance *R*. This is called *static power consumption*. With Ohm’s law,
    we can also reformulate the power rule into measurements of current and voltage.
    Thus, we can measure power by measuring the current through a circuit and voltage
    across the load as *P* = *I* × *V*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 功率是每秒消耗的能量，单位为*焦耳*，用*P*表示，单位是*瓦特*（*W*，以詹姆斯·瓦特命名）。在电子电路中，这种能量几乎完全转化为热量。这个过程叫做*功率耗散*，而一个给定负载的*功率公式*，即*P*
    = *I* × *I* × *R*，便是对此的表达。功率耗散*P*与电流*I*的平方和电阻*R*成线性关系。这被称为*静态功耗*。根据欧姆定律，我们也可以将功率公式重写为电流和电压的测量方式。因此，我们可以通过测量电路中的电流和负载两端的电压来测量功率，公式为*P*
    = *I* × *V*。
- en: 'You may have observed that your computer gets hot when it does a lot of work:
    this is *dynamic power consumption*. In your CPU, lots of transistors are switching
    when it’s working, and that requires additional power (which your computer converts
    to heat, requiring you to move the laptop off the blankets). A digital gate is
    like a switch with a small series resistor, and every wire acts (approximately)
    as a small capacitor. When a digital gate drives the wire, it needs to charge
    and discharge that capacitor, which costs energy. The faster a digital gate switches
    from high to low and back to high, the harder the gate has to work, and the more
    power the gate will dissipate through the small series resistor.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经观察到，当你的计算机进行大量工作时，它会变热：这是*动态功耗*。在你的 CPU 中，很多晶体管在工作时会发生切换，这需要额外的功率（而计算机会将其转换为热量，需要你将笔记本电脑从被子上移开）。数字门电路就像是带有小串联电阻的开关，每根电线大致充当一个小电容。当数字门电路驱动电线时，它需要给电容充电和放电，这需要能量。数字门从高电平到低电平再到高电平的切换速度越快，门电路的工作负担就越重，门电路通过小串联电阻消耗的功率也就越多。
- en: 'More physics are at play than we want to describe in this book, but remember
    one rule, as it will relate to side-channel analysis later: if you model a wire
    as a capacitance *C*, switching a square wave between 0 V and *V* volt at frequency
    *f* requires *P* = *C* × *V* × *V* × *f*. In other words, switching faster, increasing
    voltage, or increasing capacitance each makes for more required power on a CPU,
    and that is something we can observe in a side channel.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的物理现象远比我们想要阐述的要复杂，但有一点规则需要记住，因为它与侧信道分析相关：如果你将电线建模为一个电容 *C*，在频率 *f* 下将一个方波在
    0 V 和 *V* 伏特之间切换，则需要的功率为 *P* = *C* × *V* × *V* × *f*。换句话说，切换速度更快、增加电压或增加电容都会增加
    CPU 所需的功率，而这是我们在侧信道中可以观察到的。
- en: Interface with Electricity
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与电力的接口
- en: Now that we’ve reviewed the basics, let’s explore how to use electricity to
    build a communications channel. The interfaces you encounter will use different
    electrical properties to be able to communicate in different ways, and each way
    has its own pros and cons.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了基础内容，接下来让我们探讨如何使用电力构建通信通道。你遇到的接口将使用不同的电气特性以实现不同的通信方式，而每种方式都有其优缺点。
- en: Logic Levels
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑电平
- en: In digital communication, parties exchange *symbols* (for example, the letters
    of the alphabet). The sender and listener agree on a set of symbols to represent
    letters and words. When using wires for communication, differences in voltage
    encode these symbols and send them from one side of the wire to the other. The
    other side can observe the voltage changes, reconstructing the symbols and thereby
    the message.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字通信中，通信双方交换*符号*（例如字母表中的字母）。发送者和接收者约定了一组符号来表示字母和单词。当通过电线进行通信时，电压差异对这些符号进行编码，并将它们从一侧的电线发送到另一侧。另一侧可以观察到电压变化，进而重构符号和消息。
- en: Morse code, one of the first means of communicating over wires, illustrates
    this principle. The symbols in Morse code are dots and dashes. Each symbol is
    mapped to a voltage level or shape. In Morse code, the dots are short high voltage
    pulses, and the dashes are long high voltage pulses.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔斯电码，作为最早的通过电线传输信息的方式之一，说明了这个原理。摩尔斯电码的符号是点和划，每个符号对应一个电压级别或形状。在摩尔斯电码中，点是短暂的高电压脉冲，划是较长的高电压脉冲。
- en: When communicating via Morse code, the sender has a button, and the receiver
    has either a buzzer or a marker that writes on a paper tape. When the sender presses
    the button, the wire connects to a power source, which creates a voltage differential
    on the wire and causes the buzzer to buzz when it’s powered on the other end.
    Deriving words and letters means interpreting the sequence of dots and dashes
    and spaces (the short and long high-voltage pulses) with silence on the wire in
    between (see [Figure 2-2](#figure2-2)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用摩尔斯电码进行通信时，发送者有一个按钮，接收者则有一个蜂鸣器或在纸带上写字的标记器。当发送者按下按钮时，电线连接到电源，这会在电线上产生电压差，当另一端接通电源时，蜂鸣器会发出声音。通过解码点、划和空格（即短和长的高电压脉冲）以及电线上的沉默（见
    [图 2-2](#figure2-2)），我们可以得出字母和单词。
- en: '![f02002](image_fi/278748c02/f02002.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![f02002](image_fi/278748c02/f02002.png)'
- en: 'Figure 2-2: Morse code over the wire'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：通过电线传输的摩尔斯电码
- en: In modern signaling schemes, the symbols are bits (ones and zeros). A complete
    communication scheme may also use additional special symbols (for example, to
    indicate the start and end of a transmission or to help detect transmission errors).
    You can represent a “one” bit with a high logic level and a “zero” bit with a
    low logic level. Let’s agree that 0 V represents a zero and that 5 V represents
    a one. However, because of resistance in the wire, you might not see a full 5
    V on the other end, perhaps only 4.5 V. With that in mind, let’s agree that anything
    less than 0.8 V is a zero and anything greater than 2 V is a one, giving us a
    large margin of error to work with. If we were to switch to a lower voltage source
    that could output only 3.3 V, we could still talk, as long as we could create
    a voltage greater than 2 V.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代信号方案中，符号是比特（零和一）。一个完整的通信方案可能还会使用额外的特殊符号（例如，用于表示传输的开始和结束，或帮助检测传输错误）。你可以用高逻辑电平表示“1”比特，用低逻辑电平表示“0”比特。我们可以约定，0
    V 代表零，5 V 代表一。然而，由于电线的电阻，你可能在另一端看不到完整的 5 V，可能只有 4.5 V。考虑到这一点，我们约定任何低于 0.8 V 的信号为零，任何高于
    2 V 的信号为一，这样给我们提供了一个较大的误差范围。如果我们改用一个输出电压只有 3.3 V 的低电压源，仍然可以进行通信，只要我们能够产生高于 2 V
    的电压。
- en: The 0.8 V and 2 V parameters are the *switching thresholds* we have agreed upon.
    The most common set of thresholds you’re likely to see is the *transistor-transistor
    logic (TTL)* set of thresholds. The term TTL is often generically used to indicate
    that some low-voltage signals are present, where 0 V represents a logic zero,
    and a higher voltage (that would range from 1 V to 5 V, depending on the specific
    standard) represents a logic one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8 V 和 2 V 参数是我们约定的*切换阈值*。你最常见的阈值集是*晶体管-晶体管逻辑（TTL）*阈值集。TTL 这个术语通常用来表示存在一些低电压信号，其中
    0 V 代表逻辑零，更高的电压（根据具体标准从 1 V 到 5 V 不等）代表逻辑一。
- en: 'Another reason for switching thresholds is that despite our depiction of perfect
    voltages, any analog system will have *noise* in it. This means even if the sender
    attempts to send a perfect 5 V, you may observe a signal that fluctuates between
    4.7 V and 4.8 V, seemingly randomly, at the receiving end. This is noise. Noise
    is generated at the sender, captured from the ether during transmission and then
    measured at the receiving end. If our switching threshold is 2 V, this noise isn’t
    a big deal, and together with *error correcting codes*, communication is possible.
    The problem is when *adversarial noise* is introduced: instead of mother nature
    creating random noise, an attacker injects noise that confuses the receiving end
    into seeing an attacker-controlled message. This can silently corrupt communication
    unless *cryptographic signatures* are being used. Fault injection can be considered
    adversarial noise as well.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 切换阈值的另一个原因是，尽管我们描绘了完美的电压，任何模拟系统中都会存在*噪声*。这意味着，即使发送方尝试发送完美的 5 V 信号，你也可能会在接收端看到一个在
    4.7 V 和 4.8 V 之间波动的信号，看起来似乎是随机的。这就是噪声。噪声是在发送端产生的，在传输过程中从空气中捕获并在接收端测量。如果我们的切换阈值是
    2 V，这种噪声就不成问题，并且结合*错误校正码*，通信仍然是可能的。问题出现在*敌对噪声*引入时：不是大自然产生的随机噪声，而是攻击者注入的噪声，使接收端误解为攻击者控制的信息。这可能会悄悄地破坏通信，除非使用*加密签名*。故障注入也可以视为敌对噪声。
- en: You actually could encounter many logic thresholds, and they may not all talk
    to each other intelligibly (see [Figure 2-3](#figure2-3)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可能会遇到许多逻辑阈值，它们可能并不都能相互理解（参见[图 2-3](#figure2-3)）。
- en: Several voltage levels are defined in [Figure 2-3](#figure2-3). VCC is supply
    voltage, and when driving a one, the output voltage should be between VCC and
    V[OH], and for a zero, it should be between V[OL] and GND. On the receiver side,
    any signal between VCC and V[IH] should be interpreted as a one, and any signal
    between V[IL] and GND should be interpreted as a zero.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#figure2-3)中定义了几个电压水平。VCC 是电源电压，当驱动“1”时，输出电压应介于 VCC 和 V[OH] 之间，而驱动“0”时，输出电压应介于
    V[OL] 和 GND 之间。在接收端，任何介于 VCC 和 V[IH] 之间的信号应解释为一，任何介于 V[IL] 和 GND 之间的信号应解释为零。'
- en: '![f02003](image_fi/278748c02/f02003.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![f02003](image_fi/278748c02/f02003.png)'
- en: 'Figure 2-3: Different standard voltage thresholds. Legend: VCC = supply voltage,
    V[OH] = required minimum high output voltage, V[IH] = required minimum high input
    voltage, V[IL] = required maximum low input voltage, V[OL] = required maximum
    low output voltage, and GND = ground.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：不同标准电压阈值。图例：VCC = 供电电压，V[OH] = 所需的最小高输出电压，V[IH] = 所需的最小高输入电压，V[IL] = 所需的最大低输入电压，V[OL]
    = 所需的最大低输出电压，GND = 地。
- en: High Impedance, Pullups, and Pulldowns
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高阻抗、上拉电阻和下拉电阻
- en: Integrated devices aren’t like social media friends who seem to be always on
    and connected. Sometimes devices actually go quiet, which in electronics terms
    is called a *high impedance* state (as with resistance, the unit is also measured
    in Ω). This quiet state is not the same as being at 0 V. If you connect 0 V and
    5 V together, current would flow from the 5 V end to the 0 V end, but if you connect
    high impedance to 5 V, little or no current would flow. As explained earlier,
    high impedance is the AC equivalent of high resistance; this is why the current
    does not flow. Think of 0 V as like measuring the pressure at the surface of a
    puddle of water; high impedance is like closing the tap on the hose.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 集成设备不像社交媒体上的朋友，似乎总是在线和连接的。有时设备实际上会“安静”下来，这在电子学中称为*高阻抗*状态（就像电阻一样，单位也以Ω为单位）。这种安静状态与0
    V不同。如果你将0 V和5 V连接在一起，电流会从5 V端流向0 V端，但如果你将高阻抗连接到5 V，几乎没有电流会流动。如前所述，高阻抗是高电阻的交流等效物；这就是为什么电流不流动的原因。可以将0
    V想象成测量水洼表面压力的方式；高阻抗就像关闭水管上的水龙头。
- en: A high impedance state also means that a signal is very susceptible to swinging
    between high and low voltages, due to interferences even as minimal as crosstalk
    or radio signals. Sometimes we refer to these signals as floating; it’s like a
    raindrop hitting a water pressure sensor floating in the air, causing it to give
    meaningless and erratic readings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 高阻抗状态也意味着信号非常容易在高电压和低电压之间波动，甚至受到最小的干扰，比如串扰或无线电信号。有时我们称这些信号为“漂浮”；就像一滴雨水落在漂浮在空中的水压传感器上，导致其给出无意义且不稳定的读数。
- en: To ensure that devices don’t interpret random and errant signals as valid data,
    we can use pullups and pulldowns to prevent those signals from “floating” unpredictably.
    A *pullup* is a resistor that attaches the signal to a high voltage, and a *pulldown*
    is a resistor that attaches a signal to ground or 0 V. Strong pullups (often around
    50 Ω to 470 Ω) are designed to produce a strong signal that would need a powerful
    interference signal to be overridden. Weak pullups (often around 10 kΩ to 100
    kΩ) will hold the signal high as long as no other more powerful signal drives
    it to low or high voltages. Some chips are designed with weak internal pullups
    at inputs to avoid signals from flapping around in the digital breeze. Note that
    pullup and pulldown resistors are used only to prevent random interference signals
    from being seen as an intended signal; they don’t prevent the stronger intended
    signals from being seen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保设备不会将随机和错误的信号误认为有效数据，我们可以使用上拉和下拉电阻来防止这些信号“漂浮”不定。*上拉电阻*是一个将信号连接到高电压的电阻，*下拉电阻*是一个将信号连接到地或0
    V的电阻。强上拉电阻（通常在50 Ω到470 Ω之间）设计用来产生强信号，需要强大的干扰信号才能覆盖它。弱上拉电阻（通常在10 kΩ到100 kΩ之间）会在没有其他更强信号将其拉低或拉高电压时，将信号保持在高电平。一些芯片在输入端设计了弱的内部上拉电阻，以避免信号在数字环境中漂浮。请注意，上拉和下拉电阻仅用于防止随机干扰信号被误认为是有效信号；它们不会阻止更强的有效信号被识别。
- en: Push-Pull vs. Tristate vs. Open Collector or Open Drain
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推拉与三态与开集电极或开漏
- en: In order to have bidirectional communication, or even multiple senders and receivers
    on one wire, we need to do a bit more. Let’s say we have two parties that want
    to communicate, henceforth referred to as “I” and “you.” If I want to send data
    only to you, the simple 0 V to 5 V method used earlier would work fine. This is
    called a *push-pull output*, because I will push your input to 5 V, or I will
    pull your input to 0 V. You get no say in the matter, and neither does anyone
    else.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现双向通信，甚至在一根电线上传输多个发送者和接收者，我们需要做一些额外的工作。假设我们有两个想要通信的方，以下简称为“我”和“你”。如果我只想将数据发送给你，之前使用的简单0
    V到5 V的方法将完全适用。这被称为*推拉输出*，因为我将把你的输入推到5 V，或者将你的输入拉到0 V。你对此没有发言权，其他任何人也没有。
- en: But what if you now want to reverse direction and send data to me over the same
    interconnecting wires? I would need to keep quiet and go into high-impedance mode
    so that you’d have the opportunity to respond to me. For communication to happen,
    one party must be talking, while the other party must be listening. Though this
    seems elementary, talking and listening needs to be engineered in any communication
    system, and legions of humans also have not yet mastered this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你现在想反向传输数据，通过相同的连接线路发送数据给我呢？我需要保持安静并进入高阻抗模式，这样你就可以有机会回应我。为了进行通信，一方必须在发送信号，而另一方则必须在接收信号。虽然这看起来很基础，但在任何通信系统中，发送和接收都需要精心设计，事实上很多人类也未完全掌握这一点。
- en: To communicate, I can be in the one state or the zero state (talking) or in
    the high impedance state (listening), which is also referred to as *Hi-Z* (impedance
    is abbreviated as Z) or *tristate* (since it’s a third state). Even better, if
    we coordinate when we “tristate,” we could allow several other devices to communicate
    on our wires. These groups of interconnecting wires are called *buses*. Buses
    share wires that everyone takes turns using. [Figure 2-4](#figure2-4) is a diagram
    of two communicating devices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行通信，我可以处于 1 状态或 0 状态（发送信号），也可以处于高阻抗状态（接收信号），这也被称为 *Hi-Z*（阻抗用 Z 表示）或 *三态*（因为这是第三种状态）。更好的是，如果我们协调“进入三态”的时机，我们可以让多个设备通过我们的线路进行通信。这些连接的线路被称为
    *总线*。总线共享线路，所有设备轮流使用这些线路。[图 2-4](#figure2-4) 展示了两个设备之间的通信示意图。
- en: In the upper circuit in [Figure 2-4](#figure2-4), Device 2 is controlling the
    wire because EN[2] = 1 and EN[1] = 0 (Hi-Z). It sets the value *B* on the wire,
    which Device 1 then sees. On the bottom, Device 1 is sending *A*, because EN[1]
    = 1 and EN[2] = 0 (Hi-Z).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 2-4](#figure2-4) 的上部电路中，设备 2 控制着这条线路，因为 EN[2] = 1 且 EN[1] = 0（Hi-Z）。它在线路上设置了值
    *B*，设备 1 然后读取到这个值。下面，设备 1 发送 *A*，因为 EN[1] = 1 且 EN[2] = 0（Hi-Z）。
- en: '![f02004](image_fi/278748c02/f02004.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![f02004](image_fi/278748c02/f02004.png)'
- en: 'Figure 2-4: Two devices communicating via tristate buffers'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4：通过三态缓冲器通信的两个设备
- en: '*Open collector* and *open drain* refer to different ways of connecting transistors
    to wires. Instead of having zero and one outputs, open collector transistors have
    zero and Hi-Z states. If we combine several transistor collector outputs on a
    wire with a single pullup resistor, any one of those connected collectors can
    pull the wire to 0 V to send one bit of information along the common wire to the
    next input. This signal has to be carefully synchronized with the other collectors,
    which should remain in the Hi-Z state when the signal is being sent. This technique
    allows for communication using transistors.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*开路集电极* 和 *开漏* 是指将晶体管连接到线路的不同方式。与具有 0 和 1 输出的晶体管不同，开路集电极晶体管有 0 和 Hi-Z 状态。如果我们将多个晶体管的集电极输出连接到一根线路并使用一个上拉电阻，那么这些连接的集电极中的任何一个都可以将线路拉低到
    0 V，从而通过公共线路向下一个输入发送一位信息。在信号发送时，其他集电极应保持在 Hi-Z 状态，整个信号必须与其他集电极的输出保持同步。这项技术使得通过晶体管进行通信成为可能。'
- en: Asynchronous vs. Synchronous vs. Embedded Clock
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步 vs. 同步 vs. 嵌入式时钟
- en: 'One aspect we glossed over in our TTL communication example is *clocking*.
    If we alternately spit out 0 V and 5 V on the line, how do you know the difference
    between the sequence of ones and zeros represented like this: 10101 and 10010111?
    They will both look like 1 V, 0 V, 1 V, 0 V, 1 V because the repeated signals
    simply appear as one.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 TTL 通信示例中，我们略过了一个方面——*时钟信号*。如果我们交替地在线路上输出 0 V 和 5 V，如何区分像 10101 和 10010111
    这样的 1 和 0 序列呢？它们看起来都会像 1 V，0 V，1 V，0 V，1 V，因为重复的信号看起来就像是一个信号。
- en: When we use *asynchronous* communication, I won’t electrically be telling you
    when to expect data. At some point, I’ll just start sending data. If I actually
    did want to send 10010111 to you over an asynchronous wire intelligibly, we would
    need to agree ahead of time on the *data rate* at which I would be signaling you.
    The data rate specifies how long I will keep my signal high or low in order to
    represent one bit. For instance, if I specify that you’ll receive one bit every
    second, you would know that 0 V for one second means 0, but 0 V for three seconds
    means 000.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 *异步* 通信时，我不会电气化地告诉你何时期待数据。到某个时刻，我会开始发送数据。如果我确实想通过异步线路清晰地向你发送 10010111，我们需要提前约定好
    *数据传输速率*，即我会以什么样的速率发送信号给你。数据传输速率规定了我将保持信号高电平或低电平的时间，以表示一位数据。例如，如果我规定每秒钟发送一位数据，你就知道
    0 V 持续一秒表示 0，而 0 V 持续三秒表示 000。
- en: '*Synchronous*communication is the situation where we share a clock that allows
    us to synchronize the start and end of transmitted bits, but there are a number
    of different methods for sharing a clock.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*同步*通信是我们共享一个时钟，使我们能够同步传输比特的开始和结束，但有许多不同的方法可以共享时钟。'
- en: '*Common clock* means that there’s a universal metronome ticking somewhere in
    our systems—a clock to which we both adhere. A clock in this sense is also carried
    by electrical signals: a high-voltage *tick* and a low-voltage *tock*. When the
    clock ticks, I set the communication line to 5 V. When it tocks, you read the
    5 V and decode a “1.” When the clock ticks again, I can leave the line at 5 V,
    and on the second tock, you know I’ve now sent “11.” This can become complicated
    if different interfaces in the system require different clock speeds.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用时钟*意味着在我们的系统中有一个普遍的节拍器在某处滴答作响——一个我们都遵循的时钟。在这个意义上，时钟也由电信号携带：高电压的*滴答*和低电压的*嘀嗒*。当时钟滴答时，我将通信线路设为5
    V。当它嘀嗒时，你读取5 V并解码为“1”。当时钟再次滴答时，我可以保持线路为5 V，而在第二个嘀嗒时，你就知道我已经发送了“11”。如果系统中的不同接口需要不同的时钟速度，这会变得复杂。'
- en: '*Source synchronous clock* appears the same for the receiving party, but unlike
    a common clock, the sender sets the metronome. If I am the sender, I tick before
    setting a value, then I tock when done. You listen on the other end and check
    the value every time I tock. One benefit to a source synchronous clock is that,
    if I have nothing to say or need some time to compose my bits, I can just pause
    the clock. You, in your machine-like infinite patience and obedience, will wait
    an eternity until I am ready to continue. The downside of both common and source
    synchronous clocking is that you need extra pins on chips and extra wires on your
    boards over which to transmit the clock signal.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*源同步时钟*对于接收方来说是相同的，但与通用时钟不同，发送方设置节拍器。如果我是发送方，在设置值之前我会滴答一下，然后在完成时嘀嗒一下。你在另一端监听，每次我嘀嗒时检查值。源同步时钟的一个好处是，如果我没有要说的话或需要一些时间来组织我的比特，我可以暂停时钟。你，以你那机器般无限的耐心和顺从，将等一个永恒，直到我准备继续。通用时钟和源同步时钟的缺点是，你需要在芯片上额外增加引脚，在电路板上增加额外的线缆来传输时钟信号。'
- en: '*Embedded clock* or *self-clocking* signals include data and clock information
    in the same signal. Instead of saying 5 V is one and 0 V is zero, we could use
    more complicated patterns that incorporate the clock information. For example,
    [Figure 2-5](#figure2-5) shows how *Manchester encoding* defines one as a high
    voltage transitioning to a low voltage and zero as a low voltage transitioning
    to a high voltage.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌入时钟*或*自时钟*信号将数据和时钟信息包含在同一个信号中。我们可以使用更复杂的模式来表示时钟信息，而不是直接说5 V代表1，0 V代表0。例如，[图2-5](#figure2-5)展示了*曼彻斯特编码*如何定义1为从高电压到低电压的过渡，0为从低电压到高电压的过渡。'
- en: '![f02005](image_fi/278748c02/f02005.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![f02005](image_fi/278748c02/f02005.png)'
- en: 'Figure 2-5: Example of Manchester encoding, which combines data and clock in
    one signal'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：曼彻斯特编码示例，它将数据和时钟结合在一个信号中
- en: Every single bit that gets transferred over equal periods includes a transition
    in the middle that allows the receiver to recover the clock.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个通过等时间间隔传输的比特都会在中间包含一个转换，允许接收方恢复时钟。
- en: Differential Signaling
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 差分信号
- en: Everything we’ve discussed so far refers to *single-ended signaling*, which
    means we’re using a single wire to represent a stream of ones and zeros. This
    is easy to design and works well at low speeds with simple devices. If I begin
    to transmit single-ended signals to you into the MHz range, instead of seeing
    square waves with distinct high and low voltages, you’ll start seeing high and
    low levels with rounded edges and eventually have a hard time discerning high
    from low, as shown in [Figure 2-6](#figure2-6).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的一切都涉及*单端信号*，这意味着我们使用一根线来表示一串1和0。这种设计简单，并且在低速和简单设备下效果很好。如果我开始将单端信号传输到你，频率达到MHz范围，你将不再看到具有明确高低电压的方波，而是开始看到带有圆滑边缘的高低电平，最终你将很难分辨高电平和低电平，就如[图2-6](#figure2-6)所示。
- en: '![f02006](image_fi/278748c02/f02006.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![f02006](image_fi/278748c02/f02006.png)'
- en: 'Figure 2-6: Square pulses distorted at high frequencies'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：高频率下失真方波
- en: These edges are called *ringing effects*, and they are caused by impedance and
    capacitance of the transmission wire. Ringing effects make the signal less clearly
    digital and introduce an element of analog variation. Under the right conditions,
    lengths of wire can act as antennae and pick up environmental noise, thereby introducing
    analog variation into what was meant to be a purely digital signal.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边缘现象被称为*振铃效应*，它们是由传输线的阻抗和电容引起的。振铃效应使信号变得不那么清晰数字化，并引入了模拟变化的因素。在适当的条件下，电线的长度可以充当天线，接收环境噪声，从而将模拟变化引入本应为纯数字信号的信号中。
- en: '*Differential signaling* is a way of embracing the analog nature of signals
    and using it to cancel out the noise and interference. Instead of one wire, I
    use two wires that will carry inverted voltage levels: when one wire goes high,
    the other goes low, and vice versa. The reason for this is if I run the two wires
    right next to each other, they’ll experience the same interference from outside
    sources, which will be the same on both wires and therefore won’t be inverted
    with respect to each other. At the receiver end, I simply subtract one signal
    from the other to cancel out the analog part of the signals and leave behind the
    original digital signal. If I’m equipped with a differential transmitter, and
    you are equipped with a differential receiver, we can easily communicate in the
    GHz data rate over a pair of wires, as opposed to communicating in the MHz range
    over a single wire.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*差分信号*是一种利用信号的模拟特性并将其用于抵消噪声和干扰的方式。我不使用一根电线，而是使用两根电线来传输反向的电压水平：当一根电线电压升高时，另一根电线电压下降，反之亦然。这样做的原因是，如果我将两根电线紧挨着放置，它们将遭受来自外部源的相同干扰，这种干扰在两根电线上的表现将相同，因此它们之间不会发生反向变化。在接收端，我只需将一个信号减去另一个信号，以抵消信号中的模拟部分，保留原始的数字信号。如果我配备了差分发射器，而你配备了差分接收器，我们可以通过一对电线以GHz的数据速率进行轻松通信，而不是通过一根电线在MHz范围内进行通信。'
- en: At this point, we’ve described a variety of different ways to use wires to transmit
    and receive data at an electrical level. Don’t worry if this knowledge doesn’t
    all stick. Although it’s not essential for understanding and interacting with
    the different interfaces on a system, it will be helpful to know why we need to
    interact between various interfaces in different ways. It also will help you determine
    how to approach a new protocol you might encounter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了多种不同的方式，通过电气层面使用电线来传输和接收数据。如果这些知识并没有完全掌握，也不要担心。尽管理解和与系统中不同接口的交互并不依赖于这些知识，但了解为何需要以不同的方式在各个接口之间进行交互将会有所帮助。这也有助于你确定如何处理可能遇到的新协议。
- en: Low-Speed Serial Interfaces
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低速串行接口
- en: Would you believe us if we told you that you could access the root filesystem
    on a vast number of embedded systems by connecting only three wires? (The root
    filesystem contains the files and directories critical for system operation.)
    What if we told you that you can get a pristine copy of a device’s firmware with
    only four wires? You would just need to spend $30 or less on hardware (computer
    excluded) to do it. These attacks rely on your ability to communicate with the
    target device, a communication method we’ll also use for both power analysis and
    fault injection, so next let’s look at the various communications interfaces you’ll
    need to know.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们告诉你，通过连接仅三根电线，你就可以访问大量嵌入式系统的根文件系统，你会相信吗？（根文件系统包含对系统操作至关重要的文件和目录。）如果我们告诉你，你只需四根电线就可以获得设备固件的完整副本呢？你只需要花费30美元或更少（不包括计算机）就能做到。这些攻击依赖于你与目标设备之间的通信能力，这种通信方法我们也将用于电源分析和故障注入，因此接下来我们来看看你需要了解的各种通信接口。
- en: Universal Asynchronous Receiver/Transmitter Serial
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用异步接收器/发射器串行
- en: This protocol is known by several names—serial, RS-232, TTL Serial, and UART—but
    they all refer to the same thing with only minor potential differences.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种协议有多种名称——串行、RS-232、TTL串行和UART——但它们都指的是同一事物，仅有一些小的潜在差异。
- en: '*UART* stands for *universal asynchronous receiver/transmitter* (sometimes
    called *USART* if it supports synchronous operation as well). Be sure not to confuse
    this with *universal serial bus (USB)*, which is a much more complicated protocol.
    The term *universal* is appropriate, because it is one of the most commonly encountered
    serial interfaces, and it’s easily identifiable if you’re observing the signal
    on a wire, such as by probing with an oscilloscope. The word *asynchronous* means
    it doesn’t carry its own clock; parties need to agree on a clock speed beforehand
    if they intend to communicate via UART. *Receiver/transmitter* refers to the fact
    that one device can communicate both ways if both wires in the serial cable are
    connected.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*UART*代表*通用异步接收/发送器*（如果它同时支持同步操作，有时也称为*USART*）。请务必不要将其与*通用串行总线（USB）*混淆，后者是一个复杂得多的协议。*通用*这个词是合适的，因为它是最常见的串行接口之一，如果你在观察信号，比如通过示波器探测线路信号，它也很容易辨认。*异步*意味着它不带有自己的时钟；各方需要事先就时钟速度达成一致，如果他们打算通过UART进行通信。*接收/发送器*指的是，如果串行电缆中的两根线都连接，一个设备可以双向通信。'
- en: A bidirectional UART interface needs two wires (and ground) for Device A and
    Device B to communicate (see [Figure 2-7](#figure2-7)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 双向UART接口需要两根线缆（和地线），以便设备A和设备B进行通信（见[图2-7](#figure2-7)）。
- en: '![f02007](image_fi/278748c02/f02007.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f02007](image_fi/278748c02/f02007.png)'
- en: 'Figure 2-7: Three wires for UART, connecting transmit (TX) to receive (RX)
    and connecting grounds'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-7：三根用于UART的线缆，连接发送（TX）到接收（RX）并连接地线
- en: '*RS-232* is the most ubiquitous UART standard, but it has an interesting quirk.
    Designed many years ago for linking devices over cables that were several meters
    long, it defines logic one (which is also called a *mark*) as anything between
    –3 V and –15 V and logic zero (which is also called a *space*) as anything between
    +3 V and +15 V. At the far end of the cable, you were expected to be tolerant
    of any voltage between +25 V and –25 V in case of voltage drift, which is way
    out of the signal ranges in today’s low-voltage systems that rarely range far
    beyond 0 V and 3 V. You can imagine that these devices end up being rather unhappy
    if you connect a true higher-voltage RS-232 device directly to their logic level
    inputs. On the other hand, doing so did allow for multiplayer *Doom* across two
    different kids’ bedrooms.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*RS-232*是最常见的UART标准，但它有一个有趣的怪癖。它在许多年前为通过几米长的电缆连接设备而设计，定义了逻辑一（也叫*标记*）为-3 V到-15
    V之间的任何电压，而逻辑零（也叫*空格*）为+3 V到+15 V之间的任何电压。在电缆的远端，预期能够容忍+25 V到-25 V之间的任何电压变化，以应对电压漂移，但今天低电压系统的信号范围通常不会超出0
    V和3 V之间。你可以想象，如果将一个真正的高电压RS-232设备直接连接到它们的逻辑电平输入，它们会非常不高兴。另一方面，这样做确实允许跨两个不同孩子的卧室进行多人*Doom*游戏。'
- en: '*TTL serial*,using the TTL 0 V/5 V logic levels, is otherwise identical to
    RS-232 in format. This means you can use a UART to communicate without the need
    for any additional voltage converter chips. You may find people specifying different
    voltage levels (such as “3.3 V TTL serial”) to show they’re not using the classic
    0 V/5 V logic level, but rather a 0 V/3.3 V logic level.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*TTL串行*，使用TTL 0 V/5 V逻辑电平，格式上与RS-232完全相同。这意味着你可以使用UART进行通信，而无需额外的电压转换芯片。你可能会看到有人指定不同的电压电平（如“3.3
    V TTL串行”），表示他们不是使用经典的0 V/5 V逻辑电平，而是使用0 V/3.3 V逻辑电平。'
- en: 'The UART protocol is relatively straightforward. Getting back to our two-party
    communication scenario, if I am idle, I’ll continuously transmit a logic one (mark).
    When I’m ready to send you a byte’s worth of bits, I’ll begin with a logic zero
    “start bit” to signal the start of my transmission. I’ll follow that with the
    rest of my bits, the least significant bit in each byte being sent first. (A *byte*
    is a grouping of bits.) I can optionally include parity information for error
    detection in the byte. Finally, I can send one or more logic one “stop bits” to
    signal the end of my byte. In order for you to interpret my transmission properly,
    we need to agree on a few parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: UART协议相对直接。回到我们的双向通信场景，如果我空闲时，我将持续传输逻辑一（标记）。当我准备发送一个字节的位时，我会从逻辑零“起始位”开始，以表示传输的开始。接下来，我将传输其余的位，每个字节中的最低有效位先发送。（*字节*是位的分组。）我可以选择在字节中包含奇偶校验信息，以便于错误检测。最后，我可以发送一个或多个逻辑一的“停止位”来表示字节的结束。为了使你能正确解释我的传输，我们需要就以下几个参数达成一致：
- en: Baud rate The number of bits per second that I will transmit and you will receive.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 波特率：我将传输的比特每秒数量，你将接收的比特每秒数量。
- en: Byte length The number of bits in a byte. This is almost universally eight now,
    but UART supports alternate lengths.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字节长度 字节中的位数。现在几乎普遍为八位，但UART支持其他长度。
- en: Parity N for no parity, E for even, and O for odd—the parity bit is added as
    an error detection measure to indicate whether the total number of ones in the
    byte is even or odd.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 校验位 N表示没有校验位，E表示偶校验，O表示奇校验——校验位作为一种错误检测措施，用于指示字节中1的总数是偶数还是奇数。
- en: Stop bits The length of the stop signal bit, which is often 1, 1.5, or 2.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止位 停止信号位的长度，通常为1、1.5或2。
- en: For example, if I specified 9600/8N1, you should expect to see 9,600 bits per
    second, 8-bit bytes, no parity bit, and one stop bit (see [Figure 2-8](#figure2-8)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我指定了9600/8N1，你应该期望看到9600比特每秒、8位字节、没有校验位和一个停止位（见[图 2-8](#figure2-8)）。
- en: Moving up from the electrical layer to the logical level, once you have connected
    your TX, RX, and ground and have connected your serial cable to your system, you
    can treat this interconnection the same way you would treat any other character-generating
    device. In *nix operating systems, the interconnection appears as a TTY device;
    in Windows operating systems, it appears as a COM port.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从电气层次上升到逻辑层次后，一旦你连接了TX、RX和地线，并且将串行电缆连接到系统上，你可以像对待任何其他字符生成设备一样处理这个连接。在*nix操作系统中，连接表现为TTY设备；在Windows操作系统中，它表现为COM端口。
- en: '![f02008](image_fi/278748c02/f02008.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![f02008](image_fi/278748c02/f02008.png)'
- en: 'Figure 2-8: Example of the byte 0x71/bits 0b01110001 transmitted using a UART
    at 9600/8N1'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8：使用9600/8N1的UART传输字节0x71/位0b01110001的示例
- en: While a UART is most often used as a debug console on embedded devices, it is
    also frequently used to interface with communications equipment. Some phones or
    embedded systems with cellular communications use the UART protocol to communicate
    with a cellular radio using the Hayes AT command set developed for modem control.
    Many GPS modules communicate via NMEA 0183, a text protocol that depends on a
    UART for the data link layer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UART最常用于嵌入式设备上的调试控制台，但它也常用于与通信设备接口。一些带有蜂窝通信功能的手机或嵌入式系统使用UART协议与蜂窝无线电进行通信，采用为调制解调器控制开发的Hayes
    AT命令集。许多GPS模块通过NMEA 0183进行通信，这是一种文本协议，依赖UART作为数据链路层。
- en: Serial Peripheral Interface
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行外设接口
- en: The *serial peripheral interface (SPI)* is a low pin-count, controller-peripheral,
    source-synchronous serial interface. Typically, it contains one *controller* on
    a bus and one or more *peripheral* devices. Whereas UART is a peer-to-peer interface,
    SPI is controller-peripheral, meaning that the peripheral only ever responds to
    the controller’s requests and can’t initiate communication. Also, unlike UART,
    SPI is source synchronous, so the SPI controller transmits the clock to the peripheral
    receiver. This means the peripheral and controller don’t need to agree ahead of
    time on baud rate (clock frequency) since it is provided. SPI usually runs much
    faster than UART protocols (UART typically runs at 115.2 kHz; SPI typically runs
    at 1–100 MHz).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*串行外设接口（SPI）*是一种低引脚数的控制器-外设、源同步的串行接口。通常，它包含一个总线上的*控制器*和一个或多个*外设*设备。而UART是对等接口，SPI是控制器-外设接口，这意味着外设仅响应控制器的请求，不能发起通信。此外，与UART不同，SPI是源同步的，因此SPI控制器将时钟信号传输给外设接收器。这意味着外设和控制器无需事先约定波特率（时钟频率），因为时钟信号已经提供。SPI通常运行速度比UART协议快得多（UART通常运行在115.2
    kHz；SPI通常运行在1–100 MHz）。'
- en: '[Figure 2-9](#figure2-9) shows the four wires that carry the signals for SPI
    communication between C (controller) and P (peripheral)—SCK (serial clock), COPI
    (controller out peripheral in), CIPO (controller in peripheral out), and *CS (chip
    select)—as well as GND (ground).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-9](#figure2-9)展示了C（控制器）与P（外设）之间SPI通信的四根信号线——SCK（串行时钟）、COPI（控制器输出外设输入）、CIPO（控制器输入外设输出）和*CS（芯片选择）*，以及GND（地线）。'
- en: As you might notice from the pinout names, no ambiguity or swapping of transmit
    and receive pins exists, since either side has a clearly defined controller and
    peripheral. Electrically, all the SPI outputs are push-pull, which is fine, because
    the SPI interface is designed to have only one controller on the wire.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从引脚图名称中可能注意到的那样，没有传输和接收引脚的歧义或交换，因为无论哪一方都有明确的控制器和外设。从电气角度看，所有SPI输出都是推挽型的，这没有问题，因为SPI接口设计为只有一个控制器在总线上。
- en: '![f02009](image_fi/278748c02/f02009.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![f02009](image_fi/278748c02/f02009.png)'
- en: 'Figure 2-9: Four wires for SPI, plus ground'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-9：SPI的四根信号线，以及地线
- en: The *chip select* pin is labeled with an asterisk (*CS) to indicate that it’s
    active-low, meaning the high voltage is false and 0 V is true. If you were the
    peripheral device on an SPI interface, you would need to sit quietly (in high
    impedance mode) until I assert *CS by setting it to 0 V. At that point, you would
    have to listen to SCK and COPI for your commands, and only when it’s your turn
    could you respond on the CIPO pin.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*芯片选择*引脚标有星号（*CS），表示它是低有效的，即高电压为假，0V为真。如果你是SPI接口上的外设设备，你需要安静地待在高阻抗模式下，直到我通过将其设置为0V来激活*CS*。此时，你需要监听SCK和COPI以接收命令，只有当轮到你时，才能在CIPO引脚上做出响应。'
- en: An advantage of having a *CS pin is that I, as a controller, might actually
    have several different *CS pins, one for each peripheral. Since you’re required
    to stay in high impedance mode until your *CS pin is selected, other peripherals
    can share the SCK, COPI, and CIPO pins. This allows adding more SPI peripheral
    devices to a single controller at the cost of only the single additional *CS wire
    per peripheral.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有*CS引脚*的一个优点是，作为控制器，我实际上可能有几个不同的*CS引脚*，每个外设一个。由于在选择*CS引脚*之前你需要保持在高阻抗模式，因此其他外设可以共享SCK、COPI和CIPO引脚。这允许在每个外设只增加一根额外的*CS引线*的情况下，向单个控制器添加更多的SPI外设设备。
- en: SPI is most frequently used to interface with EEPROMs. The BIOS/EFI code on
    nearly every personal computer is stored in an SPI EEPROM. Many network routers
    and USB devices store their entire firmware in an SPI EEPROM. SPI is well suited
    to devices that don’t necessarily need high speed or frequent interaction. Environmental
    sensors, cryptographic modules, wireless radios, and other devices are all available
    as SPI devices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SPI最常用于与EEPROM接口。几乎每台个人计算机上的BIOS/EFI代码都存储在SPI EEPROM中。许多网络路由器和USB设备将它们的整个固件存储在SPI
    EEPROM中。SPI非常适合不一定需要高速或频繁交互的设备。环境传感器、加密模块、无线电收发器和其他设备都可以作为SPI设备使用。
- en: You may notice some devices use only the notation *serial data out (SDO)* and
    *serial data in (SDI)*. This notation clarifies which pin is an output or input
    for a given device (there’s no confusion as to whether a device is the controller
    or peripheral), but the protocol is typically the same, regardless of the names
    used for the pins. You may also find devices that use MOSI instead of COPI, MISO
    instead of CIPO, and SS instead of CS, referring to main/secondary terminology.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，一些设备仅使用*串行数据输出（SDO）*和*串行数据输入（SDI）*的标记。这种标记明确了给定设备的引脚是输出还是输入（没有混淆控制器或外设的角色），但无论引脚名称如何，协议通常是相同的。你还可能会发现一些设备使用MOSI代替COPI，MISO代替CIPO，SS代替CS，分别指代主设备/从设备术语。
- en: Inter-IC Interface
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Inter-IC接口
- en: The *inter-IC interface*, also called IIC, I2C, I²C (pronounced “I-square-C”),
    two-wire (TWI), and SMBus, is a low pin-count, multicontroller, source-synchronous
    bus. The multitude of names is primarily due to minor differences and trademark
    issues. I²C was a claimed trademark, so companies used a different name for the
    same bus. You’ll see I2C is very similar to SPI in most respects, and you’re likely
    to find exactly the same devices with either SPI or I2C interfaces.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*Inter-IC接口*，也叫IIC、I2C、I²C（发音为“I-square-C”）、两线（TWI）和SMBus，是一种低引脚数、多控制器、源同步总线。多种名称的出现主要是由于一些细微差异和商标问题。I²C曾是一个注册商标，因此各公司为同一总线使用了不同的名称。你会发现I2C在大多数方面与SPI非常相似，并且你可能会发现相同的设备使用SPI或I2C接口。'
- en: You might notice, however, that I2C is “multicontroller,” whereas SPI is “controller-peripheral.”
    [Figure 2-10](#figure2-10) helps clarify this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会注意到，I2C是“多控制器”的，而SPI是“控制器-外设”的。[图2-10](#figure2-10)有助于澄清这一点。
- en: '![f02010](image_fi/278748c02/f02010.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f02010](image_fi/278748c02/f02010.png)'
- en: 'Figure 2-10: Two wires for I2C communication between controllers and peripherals'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-10：用于控制器和外设之间I2C通信的两根线
- en: 'The complete “bus” consists of two wires: SDA and SCL. Each wire connects to
    every SDA or SCL pin of all I2C ports connected to the bus. Each wire has a single
    pullup resistor. An inactive I2C port will put both SDA and SCL pins into high-impedance
    mode. This means if no other devices are talking, both lines will sit at logic
    one, and any device can take ownership of the bus by pulling down the SCA line.
    An I2C device can be a controller only, a peripheral only, or it can act as a
    controller or a peripheral at different points in time.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pretend you and I are two bus controllers on an I2C bus, connected to
    an I2C peripheral EEPROM. If we want to access the EEPROM, we check to see what
    the SDA and SCL lines are doing. If they’re both sitting at logic one, the bus
    is not in use, and I can take control of it by sending a START condition (that
    is, by setting SDA to 0, while SCL stays at 1). At this point, you need to stand
    back and wait until I’m done with the bus. I’ll signal this with a STOP condition
    by setting SDA to 1 while SCL stays at 1\. [Figure 2-11](#figure2-11) shows the
    STOP conditions on the SCA and SCL lines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![f02011](image_fi/278748c02/f02011.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: STOP conditions on I2C lines SDA and SCL'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Once I’ve taken control of the bus, you, the EEPROM, and everyone else have
    to sit and listen for me to send out an address.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Each device has a unique 7-bit address. Usually several bits are hardcoded,
    and the remainder are programmable via flash or pullup/pulldown resistors to differentiate
    multiple identical components connected to the same I2C bus. Following the 7-bit
    address comes a Read/*Write bit to indicate the direction the next byte of data
    will go. In order to read data from the EEPROM, I first tell the EEPROM from which
    memory address I want to read (which is a write operation—that is, a one on the
    eighth bit), then I have to tell the EEPROM to send the data at that memory location
    (which is a read operation—that is, a zero on the eighth bit). After every byte
    has been transferred over I2C, the recipient is required to acknowledge the byte.
    The sender releases the SDA line, and the controller toggles the SCL line. If
    the receiver has received all eight bits, it should set the SDA line to zero during
    this time. [Figure 2-12](#figure2-12) shows what SDA and SCL look like over time
    as the entire transaction takes place.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![f02012](image_fi/278748c02/f02012.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: I2C Read register sequence'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete sequence on SCA between a controller device and an EEPROM looks
    like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Start sequence**: The controller tells everyone else to be quiet and to listen
    for their device address.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Peripheral address**: The controller sends the 7-bit device address of the
    EEPROM it wants to read.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**R/*W bit**: The controller sends a zero because we first need to write an
    EEPROM memory address.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge**: The controller releases SDA and expects the EEPROM to signal
    reception of the device address by setting SDA to 0.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EEPROM address**: The controller sends the 8-bit byte, which is the EEPROM
    memory address.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**EEPROM地址**：控制器发送8位字节，即EEPROM内存地址。'
- en: '**Acknowledge**: The controller releases SDA and expects the EEPROM to signal
    reception of the memory address by setting SDA to 0.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确认**：控制器释放SDA，并期望EEPROM通过将SDA置为0来信号化接收内存地址。'
- en: '**Start sequence**: The controller repeats the start sequence because it now
    wants to read.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动序列**：控制器重复启动序列，因为它现在想要读取数据。'
- en: '**Peripheral address**: The controller resends the 7-bit EEPROM device address.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**外设地址**：控制器重新发送7位EEPROM设备地址。'
- en: '**R/*W bit**: The controller sends a one because it now wants to read data
    from the memory address it has just set.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**R/*W位**：控制器发送一个1，因为它现在想从刚设置的内存地址读取数据。'
- en: '**Acknowledge**: The controller releases SDA and expects the EEPROM to signal
    reception of the device address by setting SDA to zero.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确认**：控制器释放SDA，并期望EEPROM通过将SDA置为零来信号化接收设备地址。'
- en: '**EEPROM data**: The EEPROM sends the 8 data bits from the memory address on
    SDA to the controller at the moment the controller toggles SCL.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**EEPROM数据**：当控制器切换SCL时，EEPROM会将8个数据位从内存地址通过SDA发送到控制器。'
- en: '**Acknowledge**: The controller sets SDA to zero to acknowledge it has received
    the byte.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确认**：控制器将SDA置为零，以确认它已接收到该字节。'
- en: '**Repeat**: As long as the controller keeps toggling SDA and acknowledging
    at the right time, the EEPROM will continue to send successive bytes of data to
    the controller. When enough bytes are read, the controller will send a Not Acknowledge
    (NACK) to communicate to the peripheral.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复**：只要控制器继续切换SDA并在正确的时间确认，EEPROM将继续向控制器发送连续的数据字节。当读取足够的字节后，控制器会发送一个非确认（NACK）来通知外设。'
- en: '**Stop sequence**: The controller tells everyone it is done, giving others
    a turn on the bus.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止序列**：控制器告诉所有人它完成了，给其他设备轮流使用总线的机会。'
- en: During the entire sequence, the controller toggles SCL in order to synchronize
    its communication with the peripheral.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，控制器切换SCL以同步它与外设的通信。
- en: One great advantage of this multicontroller bus is that it requires only two
    wires, no matter how many devices share it. A downside is that because there’s
    only a single pullup and all the devices need to be listening on the line at all
    times, the effective maximum throughput has to be lower than the design speed
    at which the SPI can communicate due to dividing the throughput among the devices.
    For this reason, you’re more likely to find only SPI EEPROMs at bus speeds greater
    than 1 MHz, while most other devices are equally likely to have plain SPI or I2C
    interfaces.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多控制器总线的一个大优点是，它只需要两根线，无论有多少设备共享该总线。一个缺点是，由于只有一个上拉电阻，并且所有设备必须始终监听这条线，因此由于数据吞吐量需要在多个设备之间分配，有效的最大吞吐量必须低于SPI能够通信的设计速度。因此，你更可能在大于1
    MHz的总线速度下找到只有SPI EEPROM，而大多数其他设备同样可能拥有普通SPI或I2C接口。
- en: Since it requires only two wires, I2C can be squeezed into a wide number of
    hardware applications. For example, VGA, DVI, and even HDMI connectors use I2C
    in order to read a data structure from the monitor that describes the monitor’s
    output capabilities. In most systems, this I2C bus is even accessible from software
    in the event that you want to plug auxiliary devices into your system via spare
    VGA ports.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只需要两根线，I2C可以被广泛应用于各种硬件中。例如，VGA、DVI甚至HDMI连接器都使用I2C来读取显示器的数据结构，该结构描述了显示器的输出能力。在大多数系统中，甚至可以通过软件访问这个I2C总线，以便在你想通过空闲的VGA端口将辅助设备连接到系统时使用。
- en: Since I2C is a multicontroller bus, there is no problem whatsoever with jumping
    onto an I2C bus and acting as the controller, which is an option that does not
    always work as expected on an SPI bus.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于I2C是一个多控制器总线，跳到I2C总线并作为控制器工作是完全没有问题的，而这一点在SPI总线上并不总是能够按预期工作。
- en: Secure Digital Input/Output and Embedded Multimedia Cards
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全数字输入/输出和嵌入式多媒体卡
- en: '*Secure Digital Input/Output (SDIO)* uses the physical and electrical *SD card*
    interface for I/O operations. *Embedded multimedia cards (eMMCs)* are surface-mount
    chips that provide the same interface and protocol as memory cards, but without
    the need for a socket and extra packaging. MMC and SD are two closely related
    and overlapping specifications that are very commonly used for storage in embedded
    systems.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全数字输入/输出 (SDIO)* 使用物理和电气*SD卡*接口进行I/O操作。*嵌入式多媒体卡（eMMC）*是表面贴装芯片，提供与存储卡相同的接口和协议，但无需插槽和额外的包装。MMC和SD是两个紧密相关且重叠的规范，在嵌入式系统中非常常见用于存储。'
- en: SD cards are backward compatible with SPI. As long as you connect the SPI pins
    we previously discussed to any SD card (and most MMC cards too), you will be able
    to read and write data on the card.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SD卡与SPI向后兼容。只要你将我们之前讨论的SPI引脚连接到任何SD卡（大多数MMC卡也是如此），你就可以读取和写入卡上的数据。
- en: SD modified the SPI by trading the COPI and CIPO lines for bidirectional control
    and data lines. SD also expanded from these two lines to include modes with two
    or four bidirectional data lines. eMMC expands these two or four lines further
    to include eight bidirectional data lines, and SDIO expands on the basic low-level
    protocol further by using the interface to interact with another device besides
    a storage device, and it adds an interrupt line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SD通过用双向控制和数据线替换COPI和CIPO线路来修改SPI。SD还从这两条线路扩展，增加了两条或四条双向数据线的模式。eMMC进一步扩展了这两条或四条线路，增加了八条双向数据线，而SDIO通过使用接口与除存储设备外的其他设备进行交互，进一步扩展了基本的低级协议，并添加了中断线。
- en: During the progressive iterations of these specifications, a lowly 1 MHz, 1-bit
    SPI bus has expanded to up to eight parallel bits and clocks as high as 208 MHz.
    It may no longer be a “low-speed serial bus,” but conveniently, almost all devices
    are backward compatible, and when you can run them at low-speed SPI, you can still
    use low-cost sniffers to extract useful information from those devices. For various
    memory cards that still support SPI, [Table 2-1](#table2-1) shows the CS, COPI,
    CIPO, and SCLK pin locations for MMC, SD, miniSD, and microSD cards.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些规范的逐步迭代过程中，一个低ly的1 MHz、1位SPI总线已经扩展到最多8位并行位和高达208 MHz的时钟。它可能不再是一个“低速串行总线”，但方便的是，几乎所有设备都向后兼容，当你可以以低速SPI运行时，仍然可以使用低成本的嗅探器从这些设备中提取有用信息。对于仍然支持SPI的各种存储卡，[表2-1](#table2-1)显示了MMC、SD、miniSD和microSD卡的CS、COPI、CIPO和SCLK引脚位置。
- en: 'Table 2-1: SPI Communication Pinouts for MMC, SD, miniSD, and microSD Cards
    (from [https://en.wikipedia.org/wiki/SD_card](https://en.wikipedia.org/wiki/SD_card),
    CC-BY 3.0 License)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：MMC、SD、miniSD和microSD卡的SPI通信引脚排列（来自[https://en.wikipedia.org/wiki/SD_card](https://en.wikipedia.org/wiki/SD_card)，CC-BY
    3.0许可）
- en: '| **MMC** **pin** | **SD** **Pin** | **miniSD** **pin** | **microSD** **pin**
    | **Name** | **I/O** | **Logic** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **MMC** **引脚** | **SD** **引脚** | **miniSD** **引脚** | **microSD** **引脚** |
    **名称** | **I/O** | **逻辑** | **描述** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 1 | 1 | 2 | nCS | I | PP | SPI Card Select [CS] (negative logic) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 2 | nCS | I | PP | SPI卡选择 [CS]（负逻辑） |'
- en: '| 2 | 2 | 2 | 3 | DI | I | PP | SPI Serial Data In [COPI] |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | 2 | 3 | DI | I | PP | SPI串行数据输入 [COPI] |'
- en: '| 3 | 3 | 3 |  | VSS | S | S | Ground |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 3 |  | VSS | S | S | 接地 |'
- en: '| 4 | 4 | 4 | 4 | VDD | S | S | Power |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 4 | 4 | VDD | S | S | 电源 |'
- en: '| 5 | 5 | 5 | 5 | CLK | I | PP | SPI Serial Clock [SCLK] |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | 5 | 5 | CLK | I | PP | SPI串行时钟 [SCLK] |'
- en: '| 6 | 6 | 6 | 6 | VSS | S | S | Ground |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | 6 | 6 | VSS | S | S | 接地 |'
- en: '| 7 | 7 | 7 | 7 | DO | O | PP | SPI Serial Data Out [CIPO] |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 7 | 7 | 7 | DO | O | PP | SPI串行数据输出 [CIPO] |'
- en: '|  | 8 | 8 | 8 | NC nIRQ | . O | . OD | Unused (memory cards) Interrupt (SDIO
    cards, negative logic) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  | 8 | 8 | 8 | NC nIRQ | . O | . OD | 未使用（存储卡） 中断（SDIO卡，负逻辑） |'
- en: '|  | 9 | 9 | 1 | NC | . | . | Unused |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  | 9 | 9 | 1 | NC | . | . | 未使用 |'
- en: '|  |  | 10 |  | NC | . | . | Reserved |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 10 |  | NC | . | . | 保留 |'
- en: '|  |  | 11 |  | NC | . | . | Reserved |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 11 |  | NC | . | . | 保留 |'
- en: You can see the basic pins are shared between them, meaning that the naming
    of the device as an SD card, microSD card, MMC, or eMMC device really declares
    the upper boundary of the device protocol and performance. For most hardware work
    we’ll do, we can interact with the devices in the same fashion, as we’re not concerned
    with the highest possible performance. [Figure 2-13](#figure2-13) shows the physical
    pin locations corresponding to the table.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，基本引脚在它们之间是共享的，这意味着设备被命名为SD卡、microSD卡、MMC或eMMC设备，实际上声明了设备协议和性能的上限。对于大多数我们要做的硬件工作，我们可以以相同的方式与设备交互，因为我们不关心最高性能。[图2-13](#figure2-13)显示了与表格对应的物理引脚位置。
- en: You’ll notice there is some physical alignment between standards, such that
    an MMC card plugged in to an SD card reader still makes contact with pins 1–7\.
    Watch the odd numbering of the miniSD if you are interfacing directly with a miniSD
    card as well, because pins 10 and 11 are snuck in between pins 3 and 4!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到标准之间有一些物理对齐，例如将MMC卡插入SD卡读卡器时，仍然能接触到引脚1–7。如果你直接与miniSD卡接口，也要注意miniSD的奇数编号，因为引脚10和11位于引脚3和4之间！
- en: '![f02013](image_fi/278748c02/f02013.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![f02013](image_fi/278748c02/f02013.png)'
- en: 'Figure 2-13: Physical locations of the SPI pins shown in [Table 2-1](#table2-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-13：物理位置与[表2-1](#table2-1)中所示的SPI引脚对应
- en: CAN Bus
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CAN总线
- en: Many automotive applications use the *controller area network (CAN)* bus to
    connect microcontrollers that talk to sensors and actuators. For instance, buttons
    on a steering wheel may use CAN to send commands to the car stereo. You also can
    read out real-time engine data and diagnostics with CAN, which means you can use
    CAN to access the engine control via a compromised cellular connection to one
    of the vehicle’s microcontrollers. For an example, see “Remote Exploitation of
    an Unaltered Passenger Vehicle” by Dr. Charlie Miller and Chris Valasek. We were
    tinkering with the communication between an eBike display and its motor controller
    and also found out that it uses CAN.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 许多汽车应用使用*控制器局域网络（CAN）*总线来连接与传感器和执行器通信的微控制器。例如，方向盘上的按钮可能通过CAN发送命令到车载音响系统。你还可以通过CAN读取实时引擎数据和诊断信息，这意味着你可以通过被入侵的蜂窝连接访问汽车微控制器，从而访问发动机控制。例如，参见Dr.
    Charlie Miller和Chris Valasek的“未修改的乘用车远程利用”一文。我们曾经玩弄过电动自行车显示屏和电机控制器之间的通信，结果发现它也使用了CAN。
- en: 'CAN uses differential signaling, because the electrical environment in a car
    is noisy, and robustness is a strong safety requirement. A few variants of CAN
    exist, but the main ones are high- and low-speed fault-tolerant CAN. Both use
    a differential pair of wires called CAN high and CAN low, but the wire names do
    not relate to low-speed or high-speed CAN. Instead, a differential signal is sent
    across the two CAN pins, and the names correspond to voltage levels used for a
    logical one or zero:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: CAN使用差分信号传输，因为汽车的电气环境嘈杂，并且稳健性是一个重要的安全要求。CAN有几种变体，但主要的有高速和低速容错CAN。两者都使用一对差分信号线，分别称为CAN高电平和CAN低电平，但这些线的名称与低速或高速CAN无关。相反，差分信号是通过两个CAN引脚传输的，这些名称与用于表示逻辑1或逻辑0的电压电平相对应：
- en: High-speed CAN has bit rates from 40Kbps to 1Mbps and uses CAN high = CAN low
    = 2.5 V for a logical one and CAN high = 3.75 V and CAN low = 1.25 V for a logical
    zero.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高速CAN的比特率从40Kbps到1Mbps，使用CAN高电平 = CAN低电平 = 2.5 V表示逻辑1，CAN高电平 = 3.75 V和CAN低电平
    = 1.25 V表示逻辑0。
- en: Low-speed CAN has bit rates from 40Kbps to 125Kbps and uses CAN high = 5 V and
    CAN low = 0 V for a logical one and CAN high ≤ 3.85 V and CAN low ≥ 1.15 V for
    a logical zero.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低速CAN的比特率从40Kbps到125Kbps，使用CAN高电平 = 5 V和CAN低电平 = 0 V表示逻辑1，CAN高电平 ≤ 3.85 V和CAN低电平
    ≥ 1.15 V表示逻辑0。
- en: These voltages are specified for ideal circumstances and can vary in practice.
    An updated version of CAN called *CAN flexible data-rate (FD)* increases the speed
    up to 12Mbps, while also increasing the maximum bytes transferred in one packet
    to 64.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些电压是针对理想情况规定的，实际情况中可能有所不同。一种名为*CAN灵活数据速率（FD）*的CAN更新版本将速度提高至12Mbps，同时还将单个数据包中传输的最大字节数增加至64。
- en: JTAG and Other Debugging Interfaces
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JTAG及其他调试接口
- en: The *Joint Test Action Group (JTAG)* is a common hardware debugging interface
    and is critical to security. The JTAG created the IEEE 1149.1 standard, titled
    “Standard Test Access Port and Boundary-Scan Architecture.”The goal was to standardize
    a means for testing/debugging chips, as well as for testing printed circuit boards
    (PCBs) for manufacturing errors. Full coverage of JTAG is beyond the scope of
    this book, but we’ll provide an overview so you can find other resources.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*联合测试行动小组（JTAG）*是一个常见的硬件调试接口，对安全性至关重要。JTAG 制定了 IEEE 1149.1 标准，名为《标准测试接入端口与边界扫描架构》。其目标是规范化测试/调试芯片以及测试印刷电路板（PCB）制造缺陷的一种方式。本书无法全面覆盖
    JTAG，但我们将提供概述，供你查找其他资源。'
- en: Why is this testing or debugging required? With the increased use of multilayer
    PCBs in the 1980s, it became necessary to provide a means to test freshly baked
    PCBs in the manufacturing facility without exposing the inner layers to the outside
    world. Engineers came up with the idea to use the existing chips on the PCB to
    test the connections.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要进行这种测试或调试？随着 1980 年代多层 PCB 的广泛应用，制造厂中测试刚生产出来的 PCB 的需求变得愈加迫切，同时又需要避免将内层暴露给外界。工程师们想出了一个方法，利用
    PCB 上现有的芯片来测试连接。
- en: When you’re performing a *boundary scan*, you basically disable the actual functionality
    of each chip but enable control from a test apparatus over each of the chip pins.
    For example, if chip A pin 6 is connected to chip B pin 9, you can let chip A
    drive pin 6 low and then high, and you can then observe on chip B pin 9 whether
    that signal actually arrives. Extending this to all chips and all pins, you can
    verify correct manufacturing of a PCB by daisy-chaining all chips using the JTAG
    pins. To do a boundary scan properly, you need a definition of all chips on the
    daisy chain, which is specified in a *boundary scan description language (BSDL)*
    file. You can find these chip definitions online if you’re lucky.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 *边界扫描* 时，你基本上会禁用每个芯片的实际功能，而启用通过测试设备对每个芯片引脚的控制。例如，如果芯片 A 的第 6 引脚连接到芯片 B
    的第 9 引脚，你可以让芯片 A 将第 6 引脚设置为低电平然后再设置为高电平，然后你可以在芯片 B 的第 9 引脚上观察该信号是否真正到达。将此扩展到所有芯片和所有引脚，你可以通过使用
    JTAG 引脚将所有芯片级联在一起，从而验证 PCB 的正确制造。要正确执行边界扫描，你需要一个定义所有级联芯片的文件，这些定义通常在 *边界扫描描述语言（BSDL）*
    文件中指定。如果你幸运的话，可以在网上找到这些芯片定义。
- en: A boundary scan lets you touch the PCB, not the chip itself, so it’s useful
    to consider using if you’re trying to access the PCB’s inner layers. Technically,
    you can do fun things like toggle SPI or I2C pins and speak those protocols over
    JTAG, but it’ll be pretty slow, so you may be better off actually connecting to
    the SPI or I2C wires where you can. Using boundary scan is fast enough to view
    UART or other lower-speed traffic, and if you use JTAG in the sample mode, it
    runs passively, which is to say it doesn’t take control of the chip and the chip
    continues to function normally.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 边界扫描让你接触到 PCB，而不是芯片本身，因此在你尝试访问 PCB 内层时，它是一个有用的选择。从技术上讲，你可以做一些有趣的事情，比如切换 SPI
    或 I2C 引脚，并通过 JTAG 进行这些协议的通讯，但这会非常慢，所以你最好实际连接到 SPI 或 I2C 的线路上。使用边界扫描足够快，可以查看 UART
    或其他低速流量，如果你在采样模式下使用 JTAG，它是被动运行的，也就是说，它不会控制芯片，芯片仍然正常工作。
- en: Tools for toggling port pins on a device given a BSDL file exist; well-known
    examples include UrJTAG (open source) and TopJTAG (low-cost with free trial, GUI
    based). These tools can be very helpful for PCB reverse engineering, as you can
    toggle a given pin on a chip and see what happens on the PCB. You can also drive
    nets or map a known pattern to a chip pin. [Figure 2-14](#figure2-14) shows an
    example of using TopJTAG to view a serial data waveform.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 BSDL 文件的设备端口引脚切换工具是存在的；一些知名的例子包括 UrJTAG（开源）和 TopJTAG（低成本并提供免费试用，基于 GUI）。这些工具对于
    PCB 反向工程非常有帮助，因为你可以切换芯片的某个引脚并观察在 PCB 上发生的情况。你还可以驱动网络或将已知模式映射到芯片引脚上。[图 2-14](#figure2-14)
    显示了使用 TopJTAG 查看串行数据波形的例子。
- en: '![f02014](image_fi/278748c02/f02014.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![f02014](image_fi/278748c02/f02014.png)'
- en: 'Figure 2-14: Using boundary scan to inspect a tiny BGA device we can’t easily
    probe'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-14：使用边界扫描检查一个我们无法轻易探测的小型 BGA 设备
- en: An open source tool called JTAG Boundary Scanner by Viveris Technologies provides
    a simple library along with a Windows GUI for accessing pins based on the pin
    name learned from a BSDL file. If you would like to automate more complex tasks,
    such as recording power-on sequences or sending SPI commands over JTAG, the JTAG
    Boundary Scanner tool is a good starting point for this work. It’s the basis for
    the open source pyjtagbs ([https://github.com/colinoflynn/pyjtagbs/](https://github.com/colinoflynn/pyjtagbs/))Python
    bindings as well, allowing you to perform similar functionality through the JTAG
    port.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: If using boundary scan mode, you have a choice of running a `SAMPLE` instruction
    that allows you to view the I/O pin state or an `EXTEST`instruction that allows
    you to control the I/O. Typically the `EXTEST` instruction may disable other features
    (such as the CPU core), so if you’re trying to inspect a running system, you should
    use the boundary scan tools in `SAMPLE` mode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The more chip-centric (not just I/O pin) control happens through the JTAG *test
    access port (TAP)* controller, which is what provides on-chip debugging capabilities.
    The good news is that it’s standardized up to a point; the bad news is that this
    level of standardization is rather low. Basically, the TAP controller can do IC
    resets and write and read from two registers: the *instruction register (IR)*
    and the *data register* *(DR)*. Debugging facilities, such as memory dumps, breakpoints,
    single stepping, and so on, are proprietary additions on top of this standard
    interface. Much of this has been reverse engineered and is available in software,
    such as OpenOCD. This means if you have a supported target, you can connect OpenOCD
    to a JTAG adapter and then use GDB to connect to OpenOCDand debug a CPU in place!'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'JTAG uses four to six pins:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Test data in (TDI)** Shifts data into the JTAG daisy chain.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test data out (TDO)** Shifts data out of the JTAG daisy chain.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test clock (TCK)** Clocks all test logic on the JTAG chain.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test mode select (TMS)** Selects a mode of operation for all devices (for
    example, boundary chain operations versus TAP operations).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test reset (TRST, optional)** Resets the test logic. Another way of resetting
    is holding TMS=1 for five clock cycles.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System reset (SRST, optional)** Resets the entire system.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JTAG has several standard headers. For instance, ARM has a standard 20-pin connector.
    You can also identify JTAG by tracing suspected chip JTAG pins. If you’re not
    sure whether a set of pins is JTAG, try a tool like Joe Grand’s JTAGulator, which
    uses a clever algorithm to identify each of JTAG’s pins. (We give an example of
    several of these headers in Appendix B.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder whether full debug access to a CPU is terribly insecure. The
    answer is yes. That’s why manufacturers who care about security do various things
    to disable JTAG, and those various things give an attacker more to do in order
    to attack the system (see [Table 2-2](#table2-2)).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-2: Overview of JTAG Port Disablement Measures and Attacks'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '| **JTAG protection measure** | **Attack on protection** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| Remove the PCB header. | Re-solder a header onto the PCB. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| Remove the PCB traces. | Re-attach wires to JTAG pins on the CPU directly,
    which is a bit trickier for chip packages that don’t directly expose their pins.
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| Disable JTAG for secure operations. An example is the SPIDEN input signal
    on ARM cores, which can disable Secure World debugging. A separate input signal,
    SPNIDEN, can disable Normal World debugging. | If these CPU signals are brought
    out on a package pin, push them high. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| Use an OTP fuse configuration in the chip that is burned to disable JTAG
    after manufacturing. | Fault injection on the fuse readout or shadow register.
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| Put an authorization protocol on JTAG before enabling it. | Side channel
    on the crypto key used in case of a challenge/response protocol or fault the authorization.
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: With this nice set of JTAG defenses and attacks, note that JTAG is far from
    the only debug interface you’ll see used. Manufacturers of other debug interfaces
    include the protocol used by the Atmel AVR (SPI-based protocol), the protocol
    used by the Atmel XMEGA (Atmel’s Program and Debug Interface, or PDI, which is
    something like SPI but with a single data line), and the TI Chipcon series.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also find that some interfaces will support only the on-chip debug mode
    and not the JTAG boundary scan mode (or vice versa). For example, the Microchip
    SAM3U has a physical pin called JTAGSEL that selects the JTAG port it runs in
    on-chip debug mode or boundary scan mode. If you want to use a nondefault mode,
    you may need to modify the board to pull this pin to the desired level. You may
    also find that some devices disable the JTAG debug mode but leave the JTAG boundary
    scan mode enabled. This is not directly a security flaw, but the boundary scan
    mode can be very helpful for all sorts of reverse engineering work. Technically,
    everything you can do in boundary scan mode you can also do by probing the physical
    PCB (which is why it’s not a security issue to leave boundary scan mode enabled),
    but using that mode can make your life easier.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We introduced ROM-based bootloaders in Chapter 1\. In some cases, you can use
    these bootloaders for programming, and sometimes they provide debug support by
    allowing you to read out memory locations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Interfaces
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Low-speed serial interfaces don’t always cut it. If you need to load only 4MB
    of compressed firmware once at boot, they are suitable, but if you have a 128MB
    writable filesystem or want a low-latency interface to external dynamic RAM (DRAM),
    serial buses won’t provide reasonable performance. Increasing the interface’s
    clock speed has real limits, and you still need to deserialize the data before
    you can use it. Using several data wires in parallel is a much more scalable approach.
    Laying down 8 or 16 wires makes many times more bandwidth available for memory
    access or fast storage. One of the main applications of parallel buses is for
    memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 低速串行接口并不总是能够满足需求。如果你只需要在启动时加载 4MB 的压缩固件，它们是合适的，但如果你有一个 128MB 可写的文件系统，或者想要一个低延迟的外部动态
    RAM（DRAM）接口，串行总线就无法提供合理的性能。提高接口的时钟频率是有实际限制的，而且你仍然需要在使用数据之前对其进行反序列化。使用多个数据线并行传输是一种更具可扩展性的方法。铺设
    8 根或 16 根电线能为内存访问或快速存储提供更多带宽。并行总线的主要应用之一就是内存。
- en: An extract from the i.MX6 Rex board shown in [Figure 2-15](#figure2-15) depicts
    the many parallel bus lines from the chip to the external DRAM.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [2-15](#figure2-15) 中展示了来自 i.MX6 Rex 板的摘录，图中显示了从芯片到外部 DRAM 的多个并行总线线。
- en: '![f02015](image_fi/278748c02/f02015.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![f02015](image_fi/278748c02/f02015.png)'
- en: 'Figure 2-15: An extract from the i.MX6 Rex open source board'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-15：来自 i.MX6 Rex 开源板的摘录
- en: See the pinout going to a double data rate (DDR) memory bus? Many data and address
    lines (labeled DRAM_D and DRAM_A, respectively) are shown as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看看连接到双倍数据速率（DDR）内存总线的引脚布局？许多数据和地址线（分别标记为 DRAM_D 和 DRAM_A）也有显示。
- en: Memory Interfaces
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存接口
- en: Unlike serial interfaces, where you can simply hook up two to four wires, a
    parallel bus may come with multiple lines for address, data, and control signals.
    For instance, you may find a flash chip with 24 address bits, 16 data input/output
    bits, and 8 or more control signals. You’re in for a larger probing party than
    with serial interfaces; for the really brave, DDR4 has 288 pins. Because various
    standards exist for bitrates, pin/wire assignments, and so on, it helps to research
    your target first (see Chapter 3). You’ll mostly encounter memory interfaces implemented
    as parallel buses, be it for DRAM or for flash, as shown in the example of a DDR
    interface in [Figure 2-15](#figure2-15).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与串行接口不同，串行接口你只需连接两到四根电线，然而并行总线可能包含多个地址、数据和控制信号线。例如，你可能会发现一个闪存芯片，具有 24 根地址位、16
    根数据输入/输出位和 8 根或更多的控制信号线。你会面临比串行接口更复杂的探测工作；对于真正勇敢的人，DDR4 有 288 根引脚。因为各种标准存在于比特率、引脚/电线分配等方面，事先研究你的目标是非常有帮助的（参见第
    3 章）。你将主要遇到作为并行总线实现的内存接口，无论是用于 DRAM 还是闪存，如图 [2-15](#figure2-15) 中 DDR 接口的示例所示。
- en: A few options are available for connecting to parallel interfaces in circuit.
    If the pitch of pins is wide enough, you might be able to use a few dozen grabber
    probes and a rat’s nest of wires to connect to a logic analyzer or a universal
    programmer (see Appendix A for sample vendors). More often than not, you will
    find that when devices have many pins, the pins are much smaller and are routed
    to inner PCB layers. Most chips come in standard sizes, and although they may
    be expensive, you can buy in-circuit clips for most devices. Unlike the clips
    for less-dense components, these usually have a flexible printed circuit ribbon
    that carries all the traces out to a separate breakout board, which you might
    be able to adapt to your analyzer or programmer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种连接电路中并行接口的选项。如果引脚间距足够宽，你可能可以使用几打抓取探头和一堆乱七八糟的电线连接到逻辑分析仪或通用编程器（参见附录 A 以了解示例供应商）。但通常情况下，当设备引脚较多时，引脚会变得更小并且被布线到
    PCB 的内部层。大多数芯片有标准尺寸，虽然它们可能比较昂贵，但你可以为大多数设备购买在电路板上直接夹取的夹子。与不那么密集的组件夹子不同，这些夹子通常配有一个柔性印刷电路带，它将所有电路引出到一个独立的拆解板上，你可以将其适配到分析仪或编程器上。
- en: As long as you can reach the pins, you should be able to figure out some way
    to connect to them. A logic analyzer would let you capture all the traffic that
    goes across the interface for later analysis, if it’s fast enough, and then only
    for a passive analysis.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你能接触到引脚，应该就能想办法将它们连接起来。如果逻辑分析仪足够快速，它可以让你捕捉所有通过接口的流量进行后续分析，并且只需进行被动分析。
- en: If you do need full control of the interface and can’t isolate it from the rest
    of the system, or if your target device is a ball grid array (BGA) package with
    no accessible pins, you might have to remove the chip from the board to read or
    write to it. De-soldering and replacing a device without damaging anything certainly
    isn’t foolproof and probably doesn’t sound easy, but with practice (or the help
    of a talented friend), you can do it reliably with a relatively low risk of failure.
    (Chapter 3 details readout of flash chips further, and Appendix A lists some useful
    tools.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对接口进行完全控制，并且无法将其从系统的其他部分隔离，或者如果你的目标设备是一个没有可访问引脚的球栅阵列（BGA）封装，你可能需要将芯片从电路板上拆下来才能读取或写入数据。拆焊并更换设备而不损坏任何组件肯定不是万无一失的，而且听起来可能并不容易，但通过实践（或有才华的朋友的帮助），你可以在相对较低的失败风险下可靠地完成这一操作。（第3章进一步详细讲解了闪存芯片的读取，附录A列出了一些有用的工具。）
- en: High-Speed Serial Interfaces
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高速串行接口
- en: We’ve discussed how it’s easier to lay down eight times as many traces than
    it is to run one wire reliably at eight times the speed. Although the term *high-speed
    serial interface* may sound like a contradiction, it isn’t. In the previous section,
    we described single-ended signals, and earlier in this chapter, we mentioned that
    differential signals can be run in the GHz range reliably in conditions where
    single-ended signals would be limited to a few MHz.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，布置八倍数量的信号线比稳定地运行一根线并以八倍速率传输数据更容易。虽然“高速串行接口”这个术语听起来似乎有些矛盾，但实际上并非如此。在前面的章节中，我们描述了单端信号，而在本章早些时候，我们提到过在某些情况下，差分信号能够在GHz范围内稳定运行，而单端信号只能限制在几MHz内。
- en: High-speed serial interfaces have facilitated most of the data rate increases
    in the past decade. Parallel ATA cables with 40 pins maxed out at 133 MHz were
    replaced by seven-pin Serial ATA cables that now run at 6 GHz. PCI slots with
    32 data lines made it to 33 or 66 MHz, but they were superseded by PCIe lanes
    that now run up to 8 GHz. This is the case for a few reasons.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 高速串行接口促进了过去十年大部分数据传输速率的提升。40针的并行ATA电缆最大支持133 MHz，但被七针的Serial ATA电缆取代，后者现已支持6
    GHz的速度。具有32条数据线的PCI插槽最高支持33 MHz或66 MHz，但已被支持最高8 GHz速度的PCIe通道取代。这是由几个原因造成的。
- en: First, with parallel wires, you need to make sure that all the signals are stable
    at the receiver end within one cycle of the clock. This becomes trickier with
    increasing frequencies, as that means all the wires must have very similar physical
    properties, such as length and electrical characteristics. Second, parallel wires
    suffer from crosstalk, which means one wire acts as an antenna and the adjacent
    wires as receivers, leading to data errors. Those issues have less impact in single
    wires than when dealing with parallel wires, and using differential signaling
    reduces the impact even further.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，对于并行信号线，你需要确保所有信号在一个时钟周期内在接收端稳定。随着频率的提高，这变得更加复杂，因为这意味着所有信号线必须具有非常相似的物理特性，如长度和电气特性。其次，并行信号线容易受到串扰的影响，这意味着一根线充当天线，邻近的线充当接收器，从而导致数据错误。相比处理并行信号线，单根信号线的这些问题影响较小，并且使用差分信号能进一步减少这些影响。
- en: The downside of all this progress is that it’s far more difficult to observe
    or inject data on a 6 GHz differential signal than it is on a 400 kHz single-ended
    signal. This difficulty usually translates to “more expensive.” You can easily
    sniff that 6 GHz signal, but you need a logic analyzer the price of a mid-size
    sedan.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这一进展的缺点是，在6 GHz的差分信号上观察或注入数据，比在400 kHz的单端信号上要困难得多。这种困难通常意味着“更贵”。你可以轻松地嗅探到这个6
    GHz的信号，但你需要一台价格相当于中型轿车的逻辑分析仪。
- en: The silver lining is that all of these interfaces are electrically very similar,
    and they are designed to perform reliably even in less-than-optimal conditions.
    This means if the probe you’ve attached to a PCIe lane loads it so much that it
    can no longer function at full speed, it will automatically retrain at a lower
    speed without the rest of the system even noticing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，所有这些接口在电气特性上非常相似，并且它们被设计成即使在不理想的条件下也能可靠工作。这意味着，如果你附加到PCIe通道上的探头加载得太重，导致它无法以全速工作，它将自动以较低的速度重新训练，而系统的其他部分甚至不会注意到这一变化。
- en: Universal Serial Bus
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用串行总线
- en: USB was the first major external interface that used high-speed differential
    signaling, and it set a few excellent precedents. First, if you plug in a USB
    device to a host equipped with a different version of the USB standard, both ends
    of the connection automatically settle at the highest common standard. Second,
    if transmissions are lost, missed, or interrupted, they are automatically retried.
    Finally, USB actually defines many characteristics, such as the connector shapes
    and pinouts, the electrical protocol, and the data protocol, all the way up to
    device classes and how to interface with them. An example is the USB *Human Interface
    Device (HID)* specification used for equipment like keyboards and mice, which
    allows the operating system (OS) to have one driver for all USB keyboards, instead
    of one per manufacturer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'USB connections feature one host and up to 127 devices (including hubs). USB
    versions are capable of different bit rates, from 12Mbps at USB 1.1, 480Mbps at
    USB 2.0, and up to 5, 10, and 20Gbps in USB 3.0, 3.1, and 3.2, respectively. For
    data rates up to 480Mbps, four wires are used. Above 480Mbps, five additional
    wires are needed. All nine wires are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: VBUS A 5 V line that can be used to power a device.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D+ and D- The differential pair for communication up to version USB 2.0.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GND Venerable ground (for power).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSRX+, SSRX-, SSTX+, SSTX- Two differential pairs, one for reception and one
    for transmission (USB 3.0 and above).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GND_DRAIN Another ground for signal; this additional ground has less noise than
    the power ground, which may be dealing with much larger currents (USB 3.0 and
    above).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The USB’s power line provides a minimum of 100 mA at 5 V, which you can tap
    to power things in your setup. Depending on the USB standard and the host, this
    available current can go up to 5 A at 48 V (5 A × 48 V = 240 W), but you actually
    need to talk to the USB host digitally before it will allow you that amount of
    juice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Now, for fun, grab your nearest USB 2.0 micro-cable and count the number of
    pins. You’ll find five, whereas only four are needed for USB 2.0\. The fifth pin
    is the ID pin, originally used for USB On-The-Go (OTG). Devices that can be both
    host or peripheral use OTG, and they come with a special OTG cable with a host
    and a peripheral end.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'The ID pin signals which end is inserted so the device can sense whether its
    role should be host or peripheral: a grounded ID pin signals “host,” and a floating
    ID pin signals “peripheral.” However, as Michael Ossmann and Kyle Osborn showed
    in their 2013 Black Hat talk “Multiplexed Wired Attack Surfaces” ([https://www.youtube.com/watch?v=jYa6-R-piZ4](https://www.youtube.com/watch?v=jYa6-R-piZ4)),
    you can enable hidden functionality through resistance values other than “grounded”
    or “floating.” They show that if you present a Galaxy Nexus (GT-I9250M) with 150
    kΩ resistance on the ID pin, it then turns USB off and a TTL serial UART on, which
    then provides debugging access.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: USB is pervasive and has been around for two decades, so it’s likely to be the
    best example of a high-speed serial interface that you can observe or manipulate
    as readily as other much simpler and slower interfaces. It also has the advantage
    of standard communications protocols, which means you can request specific information
    from almost any USB device. The USB stack itself is relatively complicated, so
    fuzzing often produces interesting results, which fault injection can push further.
    Micah Scott has an excellent demonstration of this, which you can see in a video
    titled “Glitchy Descriptor Firmware Grab – scanlime:015” ([https://www.youtube.com/watch?v=TeCQatNcF20](https://www.youtube.com/watch?v=TeCQatNcF20)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: PCI Express
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*PCI Express (PCIe)* is the high-speed serial evolution of the old PCI bus,
    and its architecture is surprisingly similar to USB. Both use high-speed differential
    pairs to make point-to-point links. Both have clearly defined hierarchies and
    protocols for enumerating devices. Both are backward compatible and automatically
    negotiate the optimal interface.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Although PCIe was designed with personal computers rather than embedded systems
    in mind, ARM and MIPS-based System-on-Chips (SoCs) currently on the market support
    PCIe, and you can find them in embedded systems costing as little as $20\. PCIe
    starts at 2.5 GHz instead of only 12 MHz, as is the case with USB, so a simple
    sniffer isn’t going to cut it. However, a few PCIe devices are versatile enough
    to enable some unintended uses.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: A unique characteristic of PCIe is that it’s usually very tightly coupled with
    the CPU or SoC. Whereas USB doesn’t work without all the applicable drivers in
    place, PCIe usually gets full access to system memory as well as to all other
    PCIe devices and other devices in the system. If you can manage to get a rogue
    PCI device into your target system, you might be able to control all of the hardware
    in the entire system. See [https://github.com/ufrisk/pcileech/](https://github.com/ufrisk/pcileech/)
    for some examples on how to use PCIe to get memory dumps.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethernet was first standardized in 1983 for creating computer networks. It has
    variants in terms of physical cables, speeds, and frame types, but the most common
    types you’ll encounter on an embedded system are 100BASE-TX (100Mbps) and 1000BASE-T
    (1Gbps) with the familiar 8P8C plug. This plug connects to a cable that contains
    four *twisted pairs* of wires. Each pair is used for differential signaling, and
    the twisting reduces crosstalk and external interference.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Both standards run at a 125 MHz line baud rate, which means if you hook up an
    oscilloscope, you’ll see 125 MHz signals. The 10 times speed difference between
    100BASE-TX and 1000BASE-T is because 100BASE-TX uses +1 V, 0 V, or −1 V over a
    single wire pair, whereas 1000BASE-T uses −2 V, −1 V, 0 V, +1 V, and +2 V levels
    on all four wire pairs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Measurement
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No hardware book is complete without some basics on measurement. You’ll use
    measurements to learn more about your target, but more important, understanding
    measurements will help you debug all the connection mishaps you may encounter.
    Let’s look at some basic tools—the trusty old multimeter, flashy oscilloscopes,
    and tragically hip logic analyzers—and discuss why and how to use them, what can
    go wrong, and some references for good additions to your lab.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Multimeter: Volt'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Measuring voltage is important for determining supply voltages or communication
    voltages. If you intend to power a chip yourself using a lab supply, using a voltmeter
    is a good sanity check before attaching the power supply (where you’ve found the
    voltage from the device datasheet hopefully). Similarly, for communication voltages,
    you may need to match the voltages on the PCB to your communication interface
    using *level shifters*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Set your multimeter to measure DC voltage. The multimeter’s AC measurement setting
    doesn’t come into play in the types of circuits we are interested in here. Some
    meters will have auto-ranging functions, and some meters will need you to set
    a “maximum range.” For measuring a 3.3 V voltage, you would need to set the range
    switch to above the 3.3 V, so a 10 V, 20 V, and 200 V range would all work. Consult
    your user manual for more details. Measure the voltage between ground (normally
    you can put the black probe on the chassis, but sometimes that isn’t ground) and
    the point where you want to know the voltage level.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Multimeter: Continuity'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Measuring *continuity* lets you find out whether two points are connected, which
    can be useful for tracing wires, headers, pins, and so on, on a PCB. To measure
    continuity, set the multimeter to ohm, because a resistance close to zero means
    that two points are electrically connected. Again, check your manual on exactly
    how to connect it. Power down the target when you measure resistance so that there
    is almost no risk of damaging anything. Put the two probes on two points, and
    if the resistance is close to zero (or you hear a beep), you have a connection.
    Get a multimeter that beeps when there is a connection so you don’t need to monitor
    its screen all the time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The continuity test is done by running a small current through the probe leads
    and measuring the voltage. If you attempt to measure a device that still has power,
    you will often get false readings since the meter will “see” a voltage that is
    actually supplied by your circuit under test.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Digital Oscilloscope
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *oscilloscope* measures and visualizes analog signals in the form of variations
    in voltage over time. When we say oscilloscope or scope, we mean *digital* sampling
    oscilloscopes, as analog scopes don’t have the features we need. Scopes can measure
    digital communication channels (although a logic analyzer is a more fitting tool),
    and with the right probes and target preparation scopes can measure power consumption
    or electromagnetic (EM) radiation when you’re performing side-channel analysis.
    It’s a critical tool for discovering what’s going on in your PCB’s analog domain.
    Appendix A describes oscilloscopes from the perspective of their features. Here
    we focus on their usage.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: A scope has a number of *input channels* that areconnected via one or more *probes*to
    a signal source, which can be a PCB trace or header, a pin of a microcontroller,
    or simply a coil to measure EM signals. A probe often *attenuates* (reduces the
    amplitude of) the signal source before forwarding the signal to the oscilloscope.
    For the probes that come with a scope, this attenuation is usually 10× and should
    be marked on your probe somewhere. This means that a 1 V differential in your
    signal results in a 0.1 V differential on the input to your scope; however, your
    scope probe may be switchable between 1× (which does not attenuate) and 10× (which
    does attenuate).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of attenuation is that it reduces the loading on your circuit
    and increases the frequency response of the scope. Using a scope probe in 1× mode
    typically means a low bandwidth (cannot measure high-frequency signals), and the
    electrical load of the scope probe may affect your circuit under test. For this
    reason, many high-performance oscilloscope probes are fixed in 10× mode, as most
    users prefer the high-frequency response advantage of the 10× mode.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Any probe also needs to be *impedance matched* with your scope. The scope will
    have an *input impedance* (for example, 50 Ω or 1 MΩ), and your probe’s impedance
    needs to be the same to avoid signal degradation. Imagine two pipes connected
    together. If one pipe is much narrower than the other, a wave of water cannot
    properly propagate between the pipes; part of the wave energy bounces back at
    the connection point. In measurement terms, RG58U probe cables have a 50 Ω characteristic
    impedance, meaning that for very fast changes (such as steep edges), the cable
    looks like a 50 Ω termination. If you leave the scope at 1 MΩ, then the discontinuity
    causes the edge to reflect (bounce back) when it arrives at the scope. This distorts
    the measurement.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The impedance on the scope may be fixed or configurable, and that of the probe
    is fixed. Normal oscilloscope probes are designed for 1 MΩ impedance. If you have
    fancy (expensive) oscilloscopes, they may automatically detect the type of probe
    attached. You may need an *impedance matcher* if you have a mismatch. Some special
    probes (such as current probes) require a 50 Ω impedance, for example, and if
    your oscilloscope doesn’t have this option, you’ll need such an impedance matcher.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Both the scope and the probe will also have an analog *bandwidth*, expressed
    in Hz, which represents the maximum frequency they can measure. The probe and
    scope don’t need to be matched, but the total bandwidth of the probe and scope
    is limited by the component with the lowest bandwidth. The signal you want to
    measure should be within that bandwidth. For instance, with side-channel analysis,
    make sure your scope’s bandwidth is higher than your crypto’s clock frequency.
    (This, however, is not a hard requirement; sometimes crypto will leak at frequencies
    lower than the clock.)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: You can insert a *low-pass filter* to limit the bandwidth artificially, which
    can be handy to filter out noise in your signal. Similarly, you can add a *high-pass
    filter*, often used to remove DC or low-frequency components (many power supplies
    have low-frequency noise, for example). Select these filters based on frequency
    analysis of earlier measurements or knowledge of the target signal. The Mini-Circuits
    brand has some easy-to-use analog filters; make sure to impedance-match those
    with the scope and probe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the scope channel in AC or DC coupling mode. *DC coupling*
    means it can measure all the way down to 0 Hz voltage (*DC offsets*), whereas
    *AC coupling* means very low frequencies are filtered out. For side-channel analysis,
    it’s usually not a big difference, so AC is a bit easier to use, as you don’t
    need to center the signal.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Now that an analog signal is entering the scope, it needs to be converted to
    a digital signal using an *analog-to-digital converter (ADC)*. These have a resolution
    normally measured in bits. For instance, many scopes have an 8-bit ADC, which
    means the voltage range of the scope is divided into 256 equally *quantized* ranges.
    [Figure 2-16](#figure2-16) shows a simple example of a 3-bit ADC output, where
    a nice sine wave input is converted to a digital output (resembling the world
    of a once-popular 8-bit computer game featuring an Italian plumber).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: This digital output has only fixed values; thus, the ADC doesn’t perfectly represent
    the input signal. The amount of error depends partly on the resolution; for example,
    if we have an 8-bit ADC instead of a 3-bit ADC, the “staircase” in the output
    of [Figure 2-16](#figure2-16) would have much smaller steps. However, the error
    in terms of absolute voltage depends also on the total range we are asking the
    ADC to represent. A 10 V range represented in 3 bits (eight steps) means each
    bit is 1.25 V, but a 1 V range in the same 3 bits would mean each step is 0.125
    V.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![f02016](image_fi/278748c02/f02016.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-16: The sine wave input is converted to the step sequence of the digital
    output.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The scope will have a minimum and maximum voltage, denoted by the *voltage range*,
    which is often configurable. Almost every scope will have an adjustable *span*,
    but some will also have an adjustable *input offset* too. The span would show
    the maximum range we could measure; for example, a 10 V span could mean we measure
    from –5 V to 5 V. If we have an input offset, we could shift that same span to
    mean a measurement of 0 V to 10 V instead. Be sure to configure it so that it
    narrowly hugs the signal in which you’re interested. If you make the range too
    small, you’ll *clip* the signal as its voltage goes outside the range. If you
    make the range too large, you’ll get a large *quantization error*. If you are
    using only 10 percent of the range, you’re making use of only about 10 percent
    of 256 of the possible same values. Different scopes will have different ranges
    of the input offset and spans.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: These ADCs operate at a programmable *sampling rate*, which means the number
    of times per second they output a new sample. A *sample* is simply one measurement
    output. Normally, the sampling rate should be at least twice as fast as the highest
    frequency you want to capture, as stated in the Nyquist-Shannon sampling theorem.
    In practice, sampling higher than twice the highest frequency is better; go up
    to five times higher. If your oscilloscope measurement is *synchronous* to the
    target device, where each sample point occurs on the target clock cycle, you can
    get away with reduced sample rates.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: A series of samples is called a *trace*. A digital oscilloscope has a buffer
    to record traces, called the *memory depth*. Once the recording fills up the memory,
    traces either need to be sent to a PC for processing or be discarded for the next
    measurement.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The depth and sampling rate together determine the maximum length of a trace.
    For efficiency, it’s important to limit the trace length. The length of the trace
    is configured by the number of samples to acquire in a single trace.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: An oscilloscope can be continuously measuring (recording) data, or else it can
    be started by an external stimulus called the *trigger*. The trigger is a digital
    signal that also comes into the scope through a dedicated trigger channel or normal
    probe channel. Once a scope is *armed*, it waits for the trigger signal to go
    above a configurable *trigger level*, after which the oscilloscope starts measuring
    a trace. If the scope does not observe a high trigger before the *trigger timeout*,
    it assumes a *trigger miss* and starts a measurement anyway. Setting the trigger
    timeout to something noticeable (like 10 seconds) is useful. If you see your *acquisition
    campaign* (taking lots of measurements) slow down to one trace every 10 seconds,
    you know you’re missing triggers. Initially, measuring and also looking at the
    *trigger channel* trace is helpful in order to debug any trigger issues.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: In lab situations, the target itself often generates the trigger. For instance,
    if you want to measure a particular cryptographic operation, first pull the trigger
    high through an external general-purpose input/output (GPIO) pin and then start
    the operation. This way, the scope starts capturing just before the operation
    starts.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Once the trace is fully captured, high-end scopes have a built-in display for
    visualization, while more simple USB scopes send the digital signal to a PC for
    visualization. Both can send the traces to a PC for analysis—for instance, for
    finding side channels!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Just like when you’re measuring voltages with a multimeter, your target needs
    to be powered on, so take precautions not to hurt yourself or your equipment.
    Also, make doubly sure all of these tools are properly configured. Misconfiguring
    a scope is not always self-evident, so be a good person and save your future self
    a lot of time spent redoing borked measurements.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Common errors include failing to ground the scope leads correctly. If you’re
    using multiple scope probes, each one should be grounded, and you must ensure
    you are grounding each one to the same ground plane (otherwise, current will flow
    through your oscilloscope). If you will be working with high frequency or low
    noise measurements, a good ground is essential. Many oscilloscope probes have
    a little *spring ground* option, as shown in [Figure 2-17](#figure2-17).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![f02017](image_fi/278748c02/f02017.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-17: A spring ground lead on a small oscilloscope probe'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: With this grounding method, there is a small spacing between the ground on the
    PCB and the oscilloscope probe. It often requires bending the spring lead to fit
    your PCB, but it’s a low-cost and simple way of getting good high-frequency performance.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: When setting up your measurements, you also want your connections to be physically
    robust. Scope probes hanging off a bench may get snagged by clothing (or any lab
    pets) and pull your expensive development board and the scope off with it. Temporary
    cable ties, hot glue, sticky tape, or even just heavy objects, are perfect for
    ensuring your probe wires aren’t about to be snagged by a passing body.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: As much as possible, it’s best to change equipment settings or probe positions
    with the circuit off. It’s easy to slip when attaching a scope probe, and shorting
    out a power supply with a probe tip will often lead to pitting of the probe tip
    itself if an arc forms. Even the low voltages present in typical development boards
    can cause small arcs that damage your probe tips. Of course, you can also damage
    your device under test by shorting it out—or even shorting a higher voltage (such
    as a 12 V input voltage) to the low-voltage circuitry.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Logic Analyzer
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *logic analyzer* is a device that allows you to capture digital signals. It’s
    like the digital variant of an oscilloscope. With it, you can capture and decode
    communications channels that use voltages for encoding data. You could use a logic
    analyzer to decode I2C, SPI, or UART communications, or to probe much wider communication
    buses at various baud rates. Like an oscilloscope, a logic analyzer has a number
    of channels, a sampling rate, voltage levels, and an (optional) trigger (see [Figure
    2-18](#figure2-18)).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![f02018](image_fi/278748c02/f02018.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-18: Sample time series measurement from logic analyzer'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Some oscilloscopes do rudimentary logic capture and protocol analysis, but they
    are more limited in the number of channels. Conversely, some logic analyzers do
    rudimentary analog signal capture, but at very low bandwidths and sampling rates.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Not much can go wrong with logic analyzers. Like with a scope, you need to use
    it on a powered-on system, so all safety precautions apply.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter discussed a range of topics relating to hardware interfaces: electrical
    basics, using those basics for communication, as well as the different types of
    communication ports and protocols you may encounter on embedded devices. We’ve
    covered more than you’ll need to be able to communicate with a single device,
    so think of this chapter as a reference to browse through later, when you’ll have
    questions about what a volt is, what differential signaling is, or what that six-pin
    header on the PCB might be (more on that in Appendix B as well). This book comes
    with an index to help you identify where to look for particular information. We’ll
    be using the most well-known interfaces in the labs later in this book, but when
    it comes time to do work, you’ll need to communicate with all sorts of devices.
    With some practice, connecting to interfaces becomes just a small hurdle to leap
    over before getting to the interesting work of actually sending data on the interfaces
    (and eventually getting secrets out of them). In the meantime, use your knowledge
    of measurements (digital or analog) to debug the inevitable connection issues
    you’ll have. Just beware of the blue smoke!'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
