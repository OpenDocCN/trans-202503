- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reaching Out, Touching Me, Touching You: Hardware Peripheral Interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Most embedded devices use standardized communication interfaces to interact
    with other chips, users, and the world. Since those interfaces are generally low
    level, rarely externally accessible, and dependent on interoperability between
    different manufacturers, they generally don’t have any protections, obfuscations,
    or encryption applied to them. In this chapter, we’ll discuss some electrical
    basics that are helpful for understanding how these various interface types work.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we’ll look at examples from three groups of communications interfaces:
    low-speed serial interfaces, parallel interfaces, and high-speed serial interfaces.
    The easiest to monitor or emulate are the *low-speed serial interfaces* used for
    most basic communications. Devices that require greater performance or bandwidth
    can be more difficult to interact with and tend to use *parallel interfaces*.
    Parallel interfaces are rapidly transitioning to *high-speed serial interfaces*,
    which can reliably run in the gigahertz range even on the cheapest embedded devices,
    but interacting with them often requires specialized hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: When analyzing embedded systems, you need to be aware of the many interconnected
    components that need to communicate and then decide whether the components and
    communication channels are trusted. These interfaces are one of the most critical
    aspects of embedded security, and yet embedded systems designers often assume
    attackers don’t have physical access to these communication channels, so they
    assume they can trust any interface. This assumption provides attackers with an
    opportunity to listen in passively or participate actively, impacting the device’s
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Electricity Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When interacting with different kinds of interfaces, it’s helpful to understand
    some basic electricity terms. If you’re familiar with voltage, current, resistance,
    reactance, impedance, inductance, and capacitance, and if you know that AC/DC
    is not only the name of an Australian rock band, feel free to skip this section.
    (If you are unfamiliar with the Australian rock band AC/DC, we recommend getting
    started with the high-voltage song “Thunderstruck.”)
  prefs: []
  type: TYPE_NORMAL
- en: Voltage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *volt* (*V*, expressed in units V and named after Alessandro Volta) is the
    electrical unit of voltage. It refers to *electric potential*, or how hard the
    electrons are pushing to get from point A to point B. Think of voltage on a wire
    as analogous to water pressure in a hose, or how hard the water is pushing to
    get from point A to point B.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage is always measured between two points. For example, if you take a multimeter
    and an AA battery, you can measure the voltage between negative and positive and
    observe that the differential is 1.5 V (if it’s lower than 1.3 V, it’s probably
    time to get a new battery). If you switch the two measurement probes, you’ll see
    a differential of –1.5 V.
  prefs: []
  type: TYPE_NORMAL
- en: When people mention only one point with regard to voltage, they are actually
    talking about the voltage of that point relative to the so-called *ground*. Ground
    is normally the common reference for a system; in such a case, ground is by definition
    at 0 V.
  prefs: []
  type: TYPE_NORMAL
- en: Current
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *ampere* (*I*, expressed in units A and named after André-Marie Ampère)
    is the measure of *electrical flow* or *current*, which refers to the number of
    electrons moving past a certain point in a given amount of time. Current in a
    wire is analogous to water flow in a hose, but instead of measuring the water
    that passes through a cross section of the hose, with electrical circuits, you
    count the electrons that pass through a cross section of a wire. Everything else
    being equal, more water pressure means more water would flow through the hose
    in the same amount of time. Likewise, more voltage across a wire means more current
    would flow through it in the same amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: For humans, 100 mA is roughly what’s needed to stop their hearts, and in embedded
    devices, you can easily encounter currents of multiple amps. Luckily, the voltage
    needs to be much higher than the common voltages used in electronics in order
    to push that current through your body. Although both authors have lived through
    110 V zaps to tell this story, the unpleasantness of those experiences leads us
    to recommend against touching live circuits, even when you think it’s a safe voltage.
  prefs: []
  type: TYPE_NORMAL
- en: Resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *ohm* (*R*, expressed in units Ω and named after Georg Simon Ohm) is the
    measure of *electrical resistance*, or how difficult it is for electrons to pass
    between two points. Continuing with the water flow analogy, resistance is comparable
    to how wide or narrow a hose is (or how clogged the inside of the hose might be).
  prefs: []
  type: TYPE_NORMAL
- en: Ohm’s Law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Volts, amps, and ohms are closely related. *Ohm’s law* summarizes this relationship
    as *V* = *I* × *R*, whichstates that knowing any two parameters allows you to
    calculate the third parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This means if you know the voltage on a wire (potential), as well as the ohm
    value of the wire (resistance), you can calculate the amperage across the wire
    (flow).
  prefs: []
  type: TYPE_NORMAL
- en: AC/DC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Direct current (DC)* and *alternating current (AC)* refer to constant and
    varying currents, respectively. Modern electronics are powered from DC sources,
    such as batteries and DC power supplies. AC is a sinusoidally varying voltage
    (and thus current), generally seen on the 240 V or 110 V power grid, but sinusoidally
    varying voltages are also used in electronic equipment, such as switched power
    supplies. In this book, we measure variations in current as determined by the
    varying activities in the device’s circuitry. The constant current consumption
    is the DC component of this measurement, and the variation of that supply current,
    in which we are very interested, is what can loosely be termed the AC component.'
  prefs: []
  type: TYPE_NORMAL
- en: Picking Apart Resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Impedance* in AC is equivalent to resistance in DC. In AC, impedance is a
    complex number made up of resistance and reactance, and it depends on the AC signal’s
    frequency. *Reactance* is a function of inductance and capacitance.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inductance* is the resistance (as in “objection”) by the circuit to a change
    in current. Returning to the water analogy, if water is flowing in one direction,
    it’ll take some energy to push the water in the opposite direction due to the
    flowing water’s kinetic energy. With inductance, this energy resides in the magnetic
    field around a wire that has current flowing through it, and it needs a “push”
    in the opposite direction before the current’s direction is reversed. Inductance
    causes a voltage proportional to the variation (change) in current. The unit of
    inductance is the *henry*, after Joseph Henry.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Capacitance* is the resistance to a change in voltage. Consider a vertical
    pipe connected to a tank and connected to a horizontal pipe with flowing water
    (see [Figure 2-1](#figure2-1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f02001](image_fi/278748c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: If electricity is like water, a capacitor is like a water tank.
    On the left, the tank is “charging,” and on the right the tank is “discharging.”'
  prefs: []
  type: TYPE_NORMAL
- en: While there is high input pressure on the pipe ([Figure 2-1](#figure2-1), left),
    water is constantly flowing into the tank, until it is full. If the pressure drops
    at the input, the tank starts to drain until it is empty. The analogy here is
    that the pressure in the vertical pipe relates to the voltage over the capacitor,
    and the amount of water in the tank relates to the charge held by the capacitor.
    If the voltage over the capacitor is high enough to “push the water level up,”
    the capacitor will take in charge. If it’s too low, the capacitor will “drain
    water” and release charge. Up to its capacity, the tank will counteract pressure
    changes at the output, and the capacitor will counteract voltage changes at the
    output. Capacitance is related to the ability of an electrical component to store
    charge, and it causes a current proportional to the variation (change) in voltage.
    The unit of capacitance is the *farad,* named for Michael Faraday.
  prefs: []
  type: TYPE_NORMAL
- en: Power
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Power is the amount of energy in *Joules* consumed per second, expressed as
    *P* in units of *W* (*watts*, after James Watt). In electronic circuits, this
    energy is almost exclusively turned into heat. This is called *power dissipation*,
    and the *power rule* for a given load, which is *P* = *I* × *I* × *R*, expresses
    it. The power dissipation *P* increases by the square of the current *I* and linearly
    with resistance *R*. This is called *static power consumption*. With Ohm’s law,
    we can also reformulate the power rule into measurements of current and voltage.
    Thus, we can measure power by measuring the current through a circuit and voltage
    across the load as *P* = *I* × *V*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have observed that your computer gets hot when it does a lot of work:
    this is *dynamic power consumption*. In your CPU, lots of transistors are switching
    when it’s working, and that requires additional power (which your computer converts
    to heat, requiring you to move the laptop off the blankets). A digital gate is
    like a switch with a small series resistor, and every wire acts (approximately)
    as a small capacitor. When a digital gate drives the wire, it needs to charge
    and discharge that capacitor, which costs energy. The faster a digital gate switches
    from high to low and back to high, the harder the gate has to work, and the more
    power the gate will dissipate through the small series resistor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More physics are at play than we want to describe in this book, but remember
    one rule, as it will relate to side-channel analysis later: if you model a wire
    as a capacitance *C*, switching a square wave between 0 V and *V* volt at frequency
    *f* requires *P* = *C* × *V* × *V* × *f*. In other words, switching faster, increasing
    voltage, or increasing capacitance each makes for more required power on a CPU,
    and that is something we can observe in a side channel.'
  prefs: []
  type: TYPE_NORMAL
- en: Interface with Electricity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve reviewed the basics, let’s explore how to use electricity to
    build a communications channel. The interfaces you encounter will use different
    electrical properties to be able to communicate in different ways, and each way
    has its own pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Logic Levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In digital communication, parties exchange *symbols* (for example, the letters
    of the alphabet). The sender and listener agree on a set of symbols to represent
    letters and words. When using wires for communication, differences in voltage
    encode these symbols and send them from one side of the wire to the other. The
    other side can observe the voltage changes, reconstructing the symbols and thereby
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: Morse code, one of the first means of communicating over wires, illustrates
    this principle. The symbols in Morse code are dots and dashes. Each symbol is
    mapped to a voltage level or shape. In Morse code, the dots are short high voltage
    pulses, and the dashes are long high voltage pulses.
  prefs: []
  type: TYPE_NORMAL
- en: When communicating via Morse code, the sender has a button, and the receiver
    has either a buzzer or a marker that writes on a paper tape. When the sender presses
    the button, the wire connects to a power source, which creates a voltage differential
    on the wire and causes the buzzer to buzz when it’s powered on the other end.
    Deriving words and letters means interpreting the sequence of dots and dashes
    and spaces (the short and long high-voltage pulses) with silence on the wire in
    between (see [Figure 2-2](#figure2-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02002](image_fi/278748c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Morse code over the wire'
  prefs: []
  type: TYPE_NORMAL
- en: In modern signaling schemes, the symbols are bits (ones and zeros). A complete
    communication scheme may also use additional special symbols (for example, to
    indicate the start and end of a transmission or to help detect transmission errors).
    You can represent a “one” bit with a high logic level and a “zero” bit with a
    low logic level. Let’s agree that 0 V represents a zero and that 5 V represents
    a one. However, because of resistance in the wire, you might not see a full 5
    V on the other end, perhaps only 4.5 V. With that in mind, let’s agree that anything
    less than 0.8 V is a zero and anything greater than 2 V is a one, giving us a
    large margin of error to work with. If we were to switch to a lower voltage source
    that could output only 3.3 V, we could still talk, as long as we could create
    a voltage greater than 2 V.
  prefs: []
  type: TYPE_NORMAL
- en: The 0.8 V and 2 V parameters are the *switching thresholds* we have agreed upon.
    The most common set of thresholds you’re likely to see is the *transistor-transistor
    logic (TTL)* set of thresholds. The term TTL is often generically used to indicate
    that some low-voltage signals are present, where 0 V represents a logic zero,
    and a higher voltage (that would range from 1 V to 5 V, depending on the specific
    standard) represents a logic one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason for switching thresholds is that despite our depiction of perfect
    voltages, any analog system will have *noise* in it. This means even if the sender
    attempts to send a perfect 5 V, you may observe a signal that fluctuates between
    4.7 V and 4.8 V, seemingly randomly, at the receiving end. This is noise. Noise
    is generated at the sender, captured from the ether during transmission and then
    measured at the receiving end. If our switching threshold is 2 V, this noise isn’t
    a big deal, and together with *error correcting codes*, communication is possible.
    The problem is when *adversarial noise* is introduced: instead of mother nature
    creating random noise, an attacker injects noise that confuses the receiving end
    into seeing an attacker-controlled message. This can silently corrupt communication
    unless *cryptographic signatures* are being used. Fault injection can be considered
    adversarial noise as well.'
  prefs: []
  type: TYPE_NORMAL
- en: You actually could encounter many logic thresholds, and they may not all talk
    to each other intelligibly (see [Figure 2-3](#figure2-3)).
  prefs: []
  type: TYPE_NORMAL
- en: Several voltage levels are defined in [Figure 2-3](#figure2-3). VCC is supply
    voltage, and when driving a one, the output voltage should be between VCC and
    V[OH], and for a zero, it should be between V[OL] and GND. On the receiver side,
    any signal between VCC and V[IH] should be interpreted as a one, and any signal
    between V[IL] and GND should be interpreted as a zero.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02003](image_fi/278748c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: Different standard voltage thresholds. Legend: VCC = supply voltage,
    V[OH] = required minimum high output voltage, V[IH] = required minimum high input
    voltage, V[IL] = required maximum low input voltage, V[OL] = required maximum
    low output voltage, and GND = ground.'
  prefs: []
  type: TYPE_NORMAL
- en: High Impedance, Pullups, and Pulldowns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integrated devices aren’t like social media friends who seem to be always on
    and connected. Sometimes devices actually go quiet, which in electronics terms
    is called a *high impedance* state (as with resistance, the unit is also measured
    in Ω). This quiet state is not the same as being at 0 V. If you connect 0 V and
    5 V together, current would flow from the 5 V end to the 0 V end, but if you connect
    high impedance to 5 V, little or no current would flow. As explained earlier,
    high impedance is the AC equivalent of high resistance; this is why the current
    does not flow. Think of 0 V as like measuring the pressure at the surface of a
    puddle of water; high impedance is like closing the tap on the hose.
  prefs: []
  type: TYPE_NORMAL
- en: A high impedance state also means that a signal is very susceptible to swinging
    between high and low voltages, due to interferences even as minimal as crosstalk
    or radio signals. Sometimes we refer to these signals as floating; it’s like a
    raindrop hitting a water pressure sensor floating in the air, causing it to give
    meaningless and erratic readings.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that devices don’t interpret random and errant signals as valid data,
    we can use pullups and pulldowns to prevent those signals from “floating” unpredictably.
    A *pullup* is a resistor that attaches the signal to a high voltage, and a *pulldown*
    is a resistor that attaches a signal to ground or 0 V. Strong pullups (often around
    50 Ω to 470 Ω) are designed to produce a strong signal that would need a powerful
    interference signal to be overridden. Weak pullups (often around 10 kΩ to 100
    kΩ) will hold the signal high as long as no other more powerful signal drives
    it to low or high voltages. Some chips are designed with weak internal pullups
    at inputs to avoid signals from flapping around in the digital breeze. Note that
    pullup and pulldown resistors are used only to prevent random interference signals
    from being seen as an intended signal; they don’t prevent the stronger intended
    signals from being seen.
  prefs: []
  type: TYPE_NORMAL
- en: Push-Pull vs. Tristate vs. Open Collector or Open Drain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to have bidirectional communication, or even multiple senders and receivers
    on one wire, we need to do a bit more. Let’s say we have two parties that want
    to communicate, henceforth referred to as “I” and “you.” If I want to send data
    only to you, the simple 0 V to 5 V method used earlier would work fine. This is
    called a *push-pull output*, because I will push your input to 5 V, or I will
    pull your input to 0 V. You get no say in the matter, and neither does anyone
    else.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you now want to reverse direction and send data to me over the same
    interconnecting wires? I would need to keep quiet and go into high-impedance mode
    so that you’d have the opportunity to respond to me. For communication to happen,
    one party must be talking, while the other party must be listening. Though this
    seems elementary, talking and listening needs to be engineered in any communication
    system, and legions of humans also have not yet mastered this.
  prefs: []
  type: TYPE_NORMAL
- en: To communicate, I can be in the one state or the zero state (talking) or in
    the high impedance state (listening), which is also referred to as *Hi-Z* (impedance
    is abbreviated as Z) or *tristate* (since it’s a third state). Even better, if
    we coordinate when we “tristate,” we could allow several other devices to communicate
    on our wires. These groups of interconnecting wires are called *buses*. Buses
    share wires that everyone takes turns using. [Figure 2-4](#figure2-4) is a diagram
    of two communicating devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the upper circuit in [Figure 2-4](#figure2-4), Device 2 is controlling the
    wire because EN[2] = 1 and EN[1] = 0 (Hi-Z). It sets the value *B* on the wire,
    which Device 1 then sees. On the bottom, Device 1 is sending *A*, because EN[1]
    = 1 and EN[2] = 0 (Hi-Z).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02004](image_fi/278748c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: Two devices communicating via tristate buffers'
  prefs: []
  type: TYPE_NORMAL
- en: '*Open collector* and *open drain* refer to different ways of connecting transistors
    to wires. Instead of having zero and one outputs, open collector transistors have
    zero and Hi-Z states. If we combine several transistor collector outputs on a
    wire with a single pullup resistor, any one of those connected collectors can
    pull the wire to 0 V to send one bit of information along the common wire to the
    next input. This signal has to be carefully synchronized with the other collectors,
    which should remain in the Hi-Z state when the signal is being sent. This technique
    allows for communication using transistors.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous vs. Synchronous vs. Embedded Clock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One aspect we glossed over in our TTL communication example is *clocking*.
    If we alternately spit out 0 V and 5 V on the line, how do you know the difference
    between the sequence of ones and zeros represented like this: 10101 and 10010111?
    They will both look like 1 V, 0 V, 1 V, 0 V, 1 V because the repeated signals
    simply appear as one.'
  prefs: []
  type: TYPE_NORMAL
- en: When we use *asynchronous* communication, I won’t electrically be telling you
    when to expect data. At some point, I’ll just start sending data. If I actually
    did want to send 10010111 to you over an asynchronous wire intelligibly, we would
    need to agree ahead of time on the *data rate* at which I would be signaling you.
    The data rate specifies how long I will keep my signal high or low in order to
    represent one bit. For instance, if I specify that you’ll receive one bit every
    second, you would know that 0 V for one second means 0, but 0 V for three seconds
    means 000.
  prefs: []
  type: TYPE_NORMAL
- en: '*Synchronous*communication is the situation where we share a clock that allows
    us to synchronize the start and end of transmitted bits, but there are a number
    of different methods for sharing a clock.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Common clock* means that there’s a universal metronome ticking somewhere in
    our systems—a clock to which we both adhere. A clock in this sense is also carried
    by electrical signals: a high-voltage *tick* and a low-voltage *tock*. When the
    clock ticks, I set the communication line to 5 V. When it tocks, you read the
    5 V and decode a “1.” When the clock ticks again, I can leave the line at 5 V,
    and on the second tock, you know I’ve now sent “11.” This can become complicated
    if different interfaces in the system require different clock speeds.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Source synchronous clock* appears the same for the receiving party, but unlike
    a common clock, the sender sets the metronome. If I am the sender, I tick before
    setting a value, then I tock when done. You listen on the other end and check
    the value every time I tock. One benefit to a source synchronous clock is that,
    if I have nothing to say or need some time to compose my bits, I can just pause
    the clock. You, in your machine-like infinite patience and obedience, will wait
    an eternity until I am ready to continue. The downside of both common and source
    synchronous clocking is that you need extra pins on chips and extra wires on your
    boards over which to transmit the clock signal.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Embedded clock* or *self-clocking* signals include data and clock information
    in the same signal. Instead of saying 5 V is one and 0 V is zero, we could use
    more complicated patterns that incorporate the clock information. For example,
    [Figure 2-5](#figure2-5) shows how *Manchester encoding* defines one as a high
    voltage transitioning to a low voltage and zero as a low voltage transitioning
    to a high voltage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f02005](image_fi/278748c02/f02005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: Example of Manchester encoding, which combines data and clock in
    one signal'
  prefs: []
  type: TYPE_NORMAL
- en: Every single bit that gets transferred over equal periods includes a transition
    in the middle that allows the receiver to recover the clock.
  prefs: []
  type: TYPE_NORMAL
- en: Differential Signaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything we’ve discussed so far refers to *single-ended signaling*, which
    means we’re using a single wire to represent a stream of ones and zeros. This
    is easy to design and works well at low speeds with simple devices. If I begin
    to transmit single-ended signals to you into the MHz range, instead of seeing
    square waves with distinct high and low voltages, you’ll start seeing high and
    low levels with rounded edges and eventually have a hard time discerning high
    from low, as shown in [Figure 2-6](#figure2-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02006](image_fi/278748c02/f02006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: Square pulses distorted at high frequencies'
  prefs: []
  type: TYPE_NORMAL
- en: These edges are called *ringing effects*, and they are caused by impedance and
    capacitance of the transmission wire. Ringing effects make the signal less clearly
    digital and introduce an element of analog variation. Under the right conditions,
    lengths of wire can act as antennae and pick up environmental noise, thereby introducing
    analog variation into what was meant to be a purely digital signal.
  prefs: []
  type: TYPE_NORMAL
- en: '*Differential signaling* is a way of embracing the analog nature of signals
    and using it to cancel out the noise and interference. Instead of one wire, I
    use two wires that will carry inverted voltage levels: when one wire goes high,
    the other goes low, and vice versa. The reason for this is if I run the two wires
    right next to each other, they’ll experience the same interference from outside
    sources, which will be the same on both wires and therefore won’t be inverted
    with respect to each other. At the receiver end, I simply subtract one signal
    from the other to cancel out the analog part of the signals and leave behind the
    original digital signal. If I’m equipped with a differential transmitter, and
    you are equipped with a differential receiver, we can easily communicate in the
    GHz data rate over a pair of wires, as opposed to communicating in the MHz range
    over a single wire.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve described a variety of different ways to use wires to transmit
    and receive data at an electrical level. Don’t worry if this knowledge doesn’t
    all stick. Although it’s not essential for understanding and interacting with
    the different interfaces on a system, it will be helpful to know why we need to
    interact between various interfaces in different ways. It also will help you determine
    how to approach a new protocol you might encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Low-Speed Serial Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Would you believe us if we told you that you could access the root filesystem
    on a vast number of embedded systems by connecting only three wires? (The root
    filesystem contains the files and directories critical for system operation.)
    What if we told you that you can get a pristine copy of a device’s firmware with
    only four wires? You would just need to spend $30 or less on hardware (computer
    excluded) to do it. These attacks rely on your ability to communicate with the
    target device, a communication method we’ll also use for both power analysis and
    fault injection, so next let’s look at the various communications interfaces you’ll
    need to know.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Asynchronous Receiver/Transmitter Serial
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This protocol is known by several names—serial, RS-232, TTL Serial, and UART—but
    they all refer to the same thing with only minor potential differences.
  prefs: []
  type: TYPE_NORMAL
- en: '*UART* stands for *universal asynchronous receiver/transmitter* (sometimes
    called *USART* if it supports synchronous operation as well). Be sure not to confuse
    this with *universal serial bus (USB)*, which is a much more complicated protocol.
    The term *universal* is appropriate, because it is one of the most commonly encountered
    serial interfaces, and it’s easily identifiable if you’re observing the signal
    on a wire, such as by probing with an oscilloscope. The word *asynchronous* means
    it doesn’t carry its own clock; parties need to agree on a clock speed beforehand
    if they intend to communicate via UART. *Receiver/transmitter* refers to the fact
    that one device can communicate both ways if both wires in the serial cable are
    connected.'
  prefs: []
  type: TYPE_NORMAL
- en: A bidirectional UART interface needs two wires (and ground) for Device A and
    Device B to communicate (see [Figure 2-7](#figure2-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02007](image_fi/278748c02/f02007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: Three wires for UART, connecting transmit (TX) to receive (RX)
    and connecting grounds'
  prefs: []
  type: TYPE_NORMAL
- en: '*RS-232* is the most ubiquitous UART standard, but it has an interesting quirk.
    Designed many years ago for linking devices over cables that were several meters
    long, it defines logic one (which is also called a *mark*) as anything between
    –3 V and –15 V and logic zero (which is also called a *space*) as anything between
    +3 V and +15 V. At the far end of the cable, you were expected to be tolerant
    of any voltage between +25 V and –25 V in case of voltage drift, which is way
    out of the signal ranges in today’s low-voltage systems that rarely range far
    beyond 0 V and 3 V. You can imagine that these devices end up being rather unhappy
    if you connect a true higher-voltage RS-232 device directly to their logic level
    inputs. On the other hand, doing so did allow for multiplayer *Doom* across two
    different kids’ bedrooms.'
  prefs: []
  type: TYPE_NORMAL
- en: '*TTL serial*,using the TTL 0 V/5 V logic levels, is otherwise identical to
    RS-232 in format. This means you can use a UART to communicate without the need
    for any additional voltage converter chips. You may find people specifying different
    voltage levels (such as “3.3 V TTL serial”) to show they’re not using the classic
    0 V/5 V logic level, but rather a 0 V/3.3 V logic level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UART protocol is relatively straightforward. Getting back to our two-party
    communication scenario, if I am idle, I’ll continuously transmit a logic one (mark).
    When I’m ready to send you a byte’s worth of bits, I’ll begin with a logic zero
    “start bit” to signal the start of my transmission. I’ll follow that with the
    rest of my bits, the least significant bit in each byte being sent first. (A *byte*
    is a grouping of bits.) I can optionally include parity information for error
    detection in the byte. Finally, I can send one or more logic one “stop bits” to
    signal the end of my byte. In order for you to interpret my transmission properly,
    we need to agree on a few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Baud rate The number of bits per second that I will transmit and you will receive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Byte length The number of bits in a byte. This is almost universally eight now,
    but UART supports alternate lengths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parity N for no parity, E for even, and O for odd—the parity bit is added as
    an error detection measure to indicate whether the total number of ones in the
    byte is even or odd.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop bits The length of the stop signal bit, which is often 1, 1.5, or 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if I specified 9600/8N1, you should expect to see 9,600 bits per
    second, 8-bit bytes, no parity bit, and one stop bit (see [Figure 2-8](#figure2-8)).
  prefs: []
  type: TYPE_NORMAL
- en: Moving up from the electrical layer to the logical level, once you have connected
    your TX, RX, and ground and have connected your serial cable to your system, you
    can treat this interconnection the same way you would treat any other character-generating
    device. In *nix operating systems, the interconnection appears as a TTY device;
    in Windows operating systems, it appears as a COM port.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02008](image_fi/278748c02/f02008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: Example of the byte 0x71/bits 0b01110001 transmitted using a UART
    at 9600/8N1'
  prefs: []
  type: TYPE_NORMAL
- en: While a UART is most often used as a debug console on embedded devices, it is
    also frequently used to interface with communications equipment. Some phones or
    embedded systems with cellular communications use the UART protocol to communicate
    with a cellular radio using the Hayes AT command set developed for modem control.
    Many GPS modules communicate via NMEA 0183, a text protocol that depends on a
    UART for the data link layer.
  prefs: []
  type: TYPE_NORMAL
- en: Serial Peripheral Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *serial peripheral interface (SPI)* is a low pin-count, controller-peripheral,
    source-synchronous serial interface. Typically, it contains one *controller* on
    a bus and one or more *peripheral* devices. Whereas UART is a peer-to-peer interface,
    SPI is controller-peripheral, meaning that the peripheral only ever responds to
    the controller’s requests and can’t initiate communication. Also, unlike UART,
    SPI is source synchronous, so the SPI controller transmits the clock to the peripheral
    receiver. This means the peripheral and controller don’t need to agree ahead of
    time on baud rate (clock frequency) since it is provided. SPI usually runs much
    faster than UART protocols (UART typically runs at 115.2 kHz; SPI typically runs
    at 1–100 MHz).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-9](#figure2-9) shows the four wires that carry the signals for SPI
    communication between C (controller) and P (peripheral)—SCK (serial clock), COPI
    (controller out peripheral in), CIPO (controller in peripheral out), and *CS (chip
    select)—as well as GND (ground).'
  prefs: []
  type: TYPE_NORMAL
- en: As you might notice from the pinout names, no ambiguity or swapping of transmit
    and receive pins exists, since either side has a clearly defined controller and
    peripheral. Electrically, all the SPI outputs are push-pull, which is fine, because
    the SPI interface is designed to have only one controller on the wire.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02009](image_fi/278748c02/f02009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: Four wires for SPI, plus ground'
  prefs: []
  type: TYPE_NORMAL
- en: The *chip select* pin is labeled with an asterisk (*CS) to indicate that it’s
    active-low, meaning the high voltage is false and 0 V is true. If you were the
    peripheral device on an SPI interface, you would need to sit quietly (in high
    impedance mode) until I assert *CS by setting it to 0 V. At that point, you would
    have to listen to SCK and COPI for your commands, and only when it’s your turn
    could you respond on the CIPO pin.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of having a *CS pin is that I, as a controller, might actually
    have several different *CS pins, one for each peripheral. Since you’re required
    to stay in high impedance mode until your *CS pin is selected, other peripherals
    can share the SCK, COPI, and CIPO pins. This allows adding more SPI peripheral
    devices to a single controller at the cost of only the single additional *CS wire
    per peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: SPI is most frequently used to interface with EEPROMs. The BIOS/EFI code on
    nearly every personal computer is stored in an SPI EEPROM. Many network routers
    and USB devices store their entire firmware in an SPI EEPROM. SPI is well suited
    to devices that don’t necessarily need high speed or frequent interaction. Environmental
    sensors, cryptographic modules, wireless radios, and other devices are all available
    as SPI devices.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice some devices use only the notation *serial data out (SDO)* and
    *serial data in (SDI)*. This notation clarifies which pin is an output or input
    for a given device (there’s no confusion as to whether a device is the controller
    or peripheral), but the protocol is typically the same, regardless of the names
    used for the pins. You may also find devices that use MOSI instead of COPI, MISO
    instead of CIPO, and SS instead of CS, referring to main/secondary terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-IC Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *inter-IC interface*, also called IIC, I2C, I²C (pronounced “I-square-C”),
    two-wire (TWI), and SMBus, is a low pin-count, multicontroller, source-synchronous
    bus. The multitude of names is primarily due to minor differences and trademark
    issues. I²C was a claimed trademark, so companies used a different name for the
    same bus. You’ll see I2C is very similar to SPI in most respects, and you’re likely
    to find exactly the same devices with either SPI or I2C interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice, however, that I2C is “multicontroller,” whereas SPI is “controller-peripheral.”
    [Figure 2-10](#figure2-10) helps clarify this.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02010](image_fi/278748c02/f02010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: Two wires for I2C communication between controllers and peripherals'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete “bus” consists of two wires: SDA and SCL. Each wire connects to
    every SDA or SCL pin of all I2C ports connected to the bus. Each wire has a single
    pullup resistor. An inactive I2C port will put both SDA and SCL pins into high-impedance
    mode. This means if no other devices are talking, both lines will sit at logic
    one, and any device can take ownership of the bus by pulling down the SCA line.
    An I2C device can be a controller only, a peripheral only, or it can act as a
    controller or a peripheral at different points in time.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s pretend you and I are two bus controllers on an I2C bus, connected to
    an I2C peripheral EEPROM. If we want to access the EEPROM, we check to see what
    the SDA and SCL lines are doing. If they’re both sitting at logic one, the bus
    is not in use, and I can take control of it by sending a START condition (that
    is, by setting SDA to 0, while SCL stays at 1). At this point, you need to stand
    back and wait until I’m done with the bus. I’ll signal this with a STOP condition
    by setting SDA to 1 while SCL stays at 1\. [Figure 2-11](#figure2-11) shows the
    STOP conditions on the SCA and SCL lines.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02011](image_fi/278748c02/f02011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: STOP conditions on I2C lines SDA and SCL'
  prefs: []
  type: TYPE_NORMAL
- en: Once I’ve taken control of the bus, you, the EEPROM, and everyone else have
    to sit and listen for me to send out an address.
  prefs: []
  type: TYPE_NORMAL
- en: Each device has a unique 7-bit address. Usually several bits are hardcoded,
    and the remainder are programmable via flash or pullup/pulldown resistors to differentiate
    multiple identical components connected to the same I2C bus. Following the 7-bit
    address comes a Read/*Write bit to indicate the direction the next byte of data
    will go. In order to read data from the EEPROM, I first tell the EEPROM from which
    memory address I want to read (which is a write operation—that is, a one on the
    eighth bit), then I have to tell the EEPROM to send the data at that memory location
    (which is a read operation—that is, a zero on the eighth bit). After every byte
    has been transferred over I2C, the recipient is required to acknowledge the byte.
    The sender releases the SDA line, and the controller toggles the SCL line. If
    the receiver has received all eight bits, it should set the SDA line to zero during
    this time. [Figure 2-12](#figure2-12) shows what SDA and SCL look like over time
    as the entire transaction takes place.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02012](image_fi/278748c02/f02012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: I2C Read register sequence'
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete sequence on SCA between a controller device and an EEPROM looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start sequence**: The controller tells everyone else to be quiet and to listen
    for their device address.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Peripheral address**: The controller sends the 7-bit device address of the
    EEPROM it wants to read.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**R/*W bit**: The controller sends a zero because we first need to write an
    EEPROM memory address.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge**: The controller releases SDA and expects the EEPROM to signal
    reception of the device address by setting SDA to 0.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EEPROM address**: The controller sends the 8-bit byte, which is the EEPROM
    memory address.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge**: The controller releases SDA and expects the EEPROM to signal
    reception of the memory address by setting SDA to 0.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Start sequence**: The controller repeats the start sequence because it now
    wants to read.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Peripheral address**: The controller resends the 7-bit EEPROM device address.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**R/*W bit**: The controller sends a one because it now wants to read data
    from the memory address it has just set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge**: The controller releases SDA and expects the EEPROM to signal
    reception of the device address by setting SDA to zero.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EEPROM data**: The EEPROM sends the 8 data bits from the memory address on
    SDA to the controller at the moment the controller toggles SCL.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge**: The controller sets SDA to zero to acknowledge it has received
    the byte.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Repeat**: As long as the controller keeps toggling SDA and acknowledging
    at the right time, the EEPROM will continue to send successive bytes of data to
    the controller. When enough bytes are read, the controller will send a Not Acknowledge
    (NACK) to communicate to the peripheral.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stop sequence**: The controller tells everyone it is done, giving others
    a turn on the bus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the entire sequence, the controller toggles SCL in order to synchronize
    its communication with the peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: One great advantage of this multicontroller bus is that it requires only two
    wires, no matter how many devices share it. A downside is that because there’s
    only a single pullup and all the devices need to be listening on the line at all
    times, the effective maximum throughput has to be lower than the design speed
    at which the SPI can communicate due to dividing the throughput among the devices.
    For this reason, you’re more likely to find only SPI EEPROMs at bus speeds greater
    than 1 MHz, while most other devices are equally likely to have plain SPI or I2C
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Since it requires only two wires, I2C can be squeezed into a wide number of
    hardware applications. For example, VGA, DVI, and even HDMI connectors use I2C
    in order to read a data structure from the monitor that describes the monitor’s
    output capabilities. In most systems, this I2C bus is even accessible from software
    in the event that you want to plug auxiliary devices into your system via spare
    VGA ports.
  prefs: []
  type: TYPE_NORMAL
- en: Since I2C is a multicontroller bus, there is no problem whatsoever with jumping
    onto an I2C bus and acting as the controller, which is an option that does not
    always work as expected on an SPI bus.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Digital Input/Output and Embedded Multimedia Cards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Secure Digital Input/Output (SDIO)* uses the physical and electrical *SD card*
    interface for I/O operations. *Embedded multimedia cards (eMMCs)* are surface-mount
    chips that provide the same interface and protocol as memory cards, but without
    the need for a socket and extra packaging. MMC and SD are two closely related
    and overlapping specifications that are very commonly used for storage in embedded
    systems.'
  prefs: []
  type: TYPE_NORMAL
- en: SD cards are backward compatible with SPI. As long as you connect the SPI pins
    we previously discussed to any SD card (and most MMC cards too), you will be able
    to read and write data on the card.
  prefs: []
  type: TYPE_NORMAL
- en: SD modified the SPI by trading the COPI and CIPO lines for bidirectional control
    and data lines. SD also expanded from these two lines to include modes with two
    or four bidirectional data lines. eMMC expands these two or four lines further
    to include eight bidirectional data lines, and SDIO expands on the basic low-level
    protocol further by using the interface to interact with another device besides
    a storage device, and it adds an interrupt line.
  prefs: []
  type: TYPE_NORMAL
- en: During the progressive iterations of these specifications, a lowly 1 MHz, 1-bit
    SPI bus has expanded to up to eight parallel bits and clocks as high as 208 MHz.
    It may no longer be a “low-speed serial bus,” but conveniently, almost all devices
    are backward compatible, and when you can run them at low-speed SPI, you can still
    use low-cost sniffers to extract useful information from those devices. For various
    memory cards that still support SPI, [Table 2-1](#table2-1) shows the CS, COPI,
    CIPO, and SCLK pin locations for MMC, SD, miniSD, and microSD cards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: SPI Communication Pinouts for MMC, SD, miniSD, and microSD Cards
    (from [https://en.wikipedia.org/wiki/SD_card](https://en.wikipedia.org/wiki/SD_card),
    CC-BY 3.0 License)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **MMC** **pin** | **SD** **Pin** | **miniSD** **pin** | **microSD** **pin**
    | **Name** | **I/O** | **Logic** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 2 | nCS | I | PP | SPI Card Select [CS] (negative logic) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2 | 2 | 3 | DI | I | PP | SPI Serial Data In [COPI] |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 3 | 3 |  | VSS | S | S | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 4 | 4 | 4 | VDD | S | S | Power |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 5 | 5 | 5 | CLK | I | PP | SPI Serial Clock [SCLK] |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | 6 | 6 | VSS | S | S | Ground |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 7 | 7 | 7 | DO | O | PP | SPI Serial Data Out [CIPO] |'
  prefs: []
  type: TYPE_TB
- en: '|  | 8 | 8 | 8 | NC nIRQ | . O | . OD | Unused (memory cards) Interrupt (SDIO
    cards, negative logic) |'
  prefs: []
  type: TYPE_TB
- en: '|  | 9 | 9 | 1 | NC | . | . | Unused |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 10 |  | NC | . | . | Reserved |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 11 |  | NC | . | . | Reserved |'
  prefs: []
  type: TYPE_TB
- en: You can see the basic pins are shared between them, meaning that the naming
    of the device as an SD card, microSD card, MMC, or eMMC device really declares
    the upper boundary of the device protocol and performance. For most hardware work
    we’ll do, we can interact with the devices in the same fashion, as we’re not concerned
    with the highest possible performance. [Figure 2-13](#figure2-13) shows the physical
    pin locations corresponding to the table.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice there is some physical alignment between standards, such that
    an MMC card plugged in to an SD card reader still makes contact with pins 1–7\.
    Watch the odd numbering of the miniSD if you are interfacing directly with a miniSD
    card as well, because pins 10 and 11 are snuck in between pins 3 and 4!
  prefs: []
  type: TYPE_NORMAL
- en: '![f02013](image_fi/278748c02/f02013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: Physical locations of the SPI pins shown in [Table 2-1](#table2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: CAN Bus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many automotive applications use the *controller area network (CAN)* bus to
    connect microcontrollers that talk to sensors and actuators. For instance, buttons
    on a steering wheel may use CAN to send commands to the car stereo. You also can
    read out real-time engine data and diagnostics with CAN, which means you can use
    CAN to access the engine control via a compromised cellular connection to one
    of the vehicle’s microcontrollers. For an example, see “Remote Exploitation of
    an Unaltered Passenger Vehicle” by Dr. Charlie Miller and Chris Valasek. We were
    tinkering with the communication between an eBike display and its motor controller
    and also found out that it uses CAN.
  prefs: []
  type: TYPE_NORMAL
- en: 'CAN uses differential signaling, because the electrical environment in a car
    is noisy, and robustness is a strong safety requirement. A few variants of CAN
    exist, but the main ones are high- and low-speed fault-tolerant CAN. Both use
    a differential pair of wires called CAN high and CAN low, but the wire names do
    not relate to low-speed or high-speed CAN. Instead, a differential signal is sent
    across the two CAN pins, and the names correspond to voltage levels used for a
    logical one or zero:'
  prefs: []
  type: TYPE_NORMAL
- en: High-speed CAN has bit rates from 40Kbps to 1Mbps and uses CAN high = CAN low
    = 2.5 V for a logical one and CAN high = 3.75 V and CAN low = 1.25 V for a logical
    zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-speed CAN has bit rates from 40Kbps to 125Kbps and uses CAN high = 5 V and
    CAN low = 0 V for a logical one and CAN high ≤ 3.85 V and CAN low ≥ 1.15 V for
    a logical zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These voltages are specified for ideal circumstances and can vary in practice.
    An updated version of CAN called *CAN flexible data-rate (FD)* increases the speed
    up to 12Mbps, while also increasing the maximum bytes transferred in one packet
    to 64.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG and Other Debugging Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Joint Test Action Group (JTAG)* is a common hardware debugging interface
    and is critical to security. The JTAG created the IEEE 1149.1 standard, titled
    “Standard Test Access Port and Boundary-Scan Architecture.”The goal was to standardize
    a means for testing/debugging chips, as well as for testing printed circuit boards
    (PCBs) for manufacturing errors. Full coverage of JTAG is beyond the scope of
    this book, but we’ll provide an overview so you can find other resources.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this testing or debugging required? With the increased use of multilayer
    PCBs in the 1980s, it became necessary to provide a means to test freshly baked
    PCBs in the manufacturing facility without exposing the inner layers to the outside
    world. Engineers came up with the idea to use the existing chips on the PCB to
    test the connections.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re performing a *boundary scan*, you basically disable the actual functionality
    of each chip but enable control from a test apparatus over each of the chip pins.
    For example, if chip A pin 6 is connected to chip B pin 9, you can let chip A
    drive pin 6 low and then high, and you can then observe on chip B pin 9 whether
    that signal actually arrives. Extending this to all chips and all pins, you can
    verify correct manufacturing of a PCB by daisy-chaining all chips using the JTAG
    pins. To do a boundary scan properly, you need a definition of all chips on the
    daisy chain, which is specified in a *boundary scan description language (BSDL)*
    file. You can find these chip definitions online if you’re lucky.
  prefs: []
  type: TYPE_NORMAL
- en: A boundary scan lets you touch the PCB, not the chip itself, so it’s useful
    to consider using if you’re trying to access the PCB’s inner layers. Technically,
    you can do fun things like toggle SPI or I2C pins and speak those protocols over
    JTAG, but it’ll be pretty slow, so you may be better off actually connecting to
    the SPI or I2C wires where you can. Using boundary scan is fast enough to view
    UART or other lower-speed traffic, and if you use JTAG in the sample mode, it
    runs passively, which is to say it doesn’t take control of the chip and the chip
    continues to function normally.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for toggling port pins on a device given a BSDL file exist; well-known
    examples include UrJTAG (open source) and TopJTAG (low-cost with free trial, GUI
    based). These tools can be very helpful for PCB reverse engineering, as you can
    toggle a given pin on a chip and see what happens on the PCB. You can also drive
    nets or map a known pattern to a chip pin. [Figure 2-14](#figure2-14) shows an
    example of using TopJTAG to view a serial data waveform.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02014](image_fi/278748c02/f02014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: Using boundary scan to inspect a tiny BGA device we can’t easily
    probe'
  prefs: []
  type: TYPE_NORMAL
- en: An open source tool called JTAG Boundary Scanner by Viveris Technologies provides
    a simple library along with a Windows GUI for accessing pins based on the pin
    name learned from a BSDL file. If you would like to automate more complex tasks,
    such as recording power-on sequences or sending SPI commands over JTAG, the JTAG
    Boundary Scanner tool is a good starting point for this work. It’s the basis for
    the open source pyjtagbs ([https://github.com/colinoflynn/pyjtagbs/](https://github.com/colinoflynn/pyjtagbs/))Python
    bindings as well, allowing you to perform similar functionality through the JTAG
    port.
  prefs: []
  type: TYPE_NORMAL
- en: If using boundary scan mode, you have a choice of running a `SAMPLE` instruction
    that allows you to view the I/O pin state or an `EXTEST`instruction that allows
    you to control the I/O. Typically the `EXTEST` instruction may disable other features
    (such as the CPU core), so if you’re trying to inspect a running system, you should
    use the boundary scan tools in `SAMPLE` mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more chip-centric (not just I/O pin) control happens through the JTAG *test
    access port (TAP)* controller, which is what provides on-chip debugging capabilities.
    The good news is that it’s standardized up to a point; the bad news is that this
    level of standardization is rather low. Basically, the TAP controller can do IC
    resets and write and read from two registers: the *instruction register (IR)*
    and the *data register* *(DR)*. Debugging facilities, such as memory dumps, breakpoints,
    single stepping, and so on, are proprietary additions on top of this standard
    interface. Much of this has been reverse engineered and is available in software,
    such as OpenOCD. This means if you have a supported target, you can connect OpenOCD
    to a JTAG adapter and then use GDB to connect to OpenOCDand debug a CPU in place!'
  prefs: []
  type: TYPE_NORMAL
- en: 'JTAG uses four to six pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test data in (TDI)** Shifts data into the JTAG daisy chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test data out (TDO)** Shifts data out of the JTAG daisy chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test clock (TCK)** Clocks all test logic on the JTAG chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test mode select (TMS)** Selects a mode of operation for all devices (for
    example, boundary chain operations versus TAP operations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test reset (TRST, optional)** Resets the test logic. Another way of resetting
    is holding TMS=1 for five clock cycles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System reset (SRST, optional)** Resets the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JTAG has several standard headers. For instance, ARM has a standard 20-pin connector.
    You can also identify JTAG by tracing suspected chip JTAG pins. If you’re not
    sure whether a set of pins is JTAG, try a tool like Joe Grand’s JTAGulator, which
    uses a clever algorithm to identify each of JTAG’s pins. (We give an example of
    several of these headers in Appendix B.)
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder whether full debug access to a CPU is terribly insecure. The
    answer is yes. That’s why manufacturers who care about security do various things
    to disable JTAG, and those various things give an attacker more to do in order
    to attack the system (see [Table 2-2](#table2-2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-2: Overview of JTAG Port Disablement Measures and Attacks'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JTAG protection measure** | **Attack on protection** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Remove the PCB header. | Re-solder a header onto the PCB. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove the PCB traces. | Re-attach wires to JTAG pins on the CPU directly,
    which is a bit trickier for chip packages that don’t directly expose their pins.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Disable JTAG for secure operations. An example is the SPIDEN input signal
    on ARM cores, which can disable Secure World debugging. A separate input signal,
    SPNIDEN, can disable Normal World debugging. | If these CPU signals are brought
    out on a package pin, push them high. |'
  prefs: []
  type: TYPE_TB
- en: '| Use an OTP fuse configuration in the chip that is burned to disable JTAG
    after manufacturing. | Fault injection on the fuse readout or shadow register.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Put an authorization protocol on JTAG before enabling it. | Side channel
    on the crypto key used in case of a challenge/response protocol or fault the authorization.
    |'
  prefs: []
  type: TYPE_TB
- en: With this nice set of JTAG defenses and attacks, note that JTAG is far from
    the only debug interface you’ll see used. Manufacturers of other debug interfaces
    include the protocol used by the Atmel AVR (SPI-based protocol), the protocol
    used by the Atmel XMEGA (Atmel’s Program and Debug Interface, or PDI, which is
    something like SPI but with a single data line), and the TI Chipcon series.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also find that some interfaces will support only the on-chip debug mode
    and not the JTAG boundary scan mode (or vice versa). For example, the Microchip
    SAM3U has a physical pin called JTAGSEL that selects the JTAG port it runs in
    on-chip debug mode or boundary scan mode. If you want to use a nondefault mode,
    you may need to modify the board to pull this pin to the desired level. You may
    also find that some devices disable the JTAG debug mode but leave the JTAG boundary
    scan mode enabled. This is not directly a security flaw, but the boundary scan
    mode can be very helpful for all sorts of reverse engineering work. Technically,
    everything you can do in boundary scan mode you can also do by probing the physical
    PCB (which is why it’s not a security issue to leave boundary scan mode enabled),
    but using that mode can make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced ROM-based bootloaders in Chapter 1\. In some cases, you can use
    these bootloaders for programming, and sometimes they provide debug support by
    allowing you to read out memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Low-speed serial interfaces don’t always cut it. If you need to load only 4MB
    of compressed firmware once at boot, they are suitable, but if you have a 128MB
    writable filesystem or want a low-latency interface to external dynamic RAM (DRAM),
    serial buses won’t provide reasonable performance. Increasing the interface’s
    clock speed has real limits, and you still need to deserialize the data before
    you can use it. Using several data wires in parallel is a much more scalable approach.
    Laying down 8 or 16 wires makes many times more bandwidth available for memory
    access or fast storage. One of the main applications of parallel buses is for
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: An extract from the i.MX6 Rex board shown in [Figure 2-15](#figure2-15) depicts
    the many parallel bus lines from the chip to the external DRAM.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02015](image_fi/278748c02/f02015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-15: An extract from the i.MX6 Rex open source board'
  prefs: []
  type: TYPE_NORMAL
- en: See the pinout going to a double data rate (DDR) memory bus? Many data and address
    lines (labeled DRAM_D and DRAM_A, respectively) are shown as well.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike serial interfaces, where you can simply hook up two to four wires, a
    parallel bus may come with multiple lines for address, data, and control signals.
    For instance, you may find a flash chip with 24 address bits, 16 data input/output
    bits, and 8 or more control signals. You’re in for a larger probing party than
    with serial interfaces; for the really brave, DDR4 has 288 pins. Because various
    standards exist for bitrates, pin/wire assignments, and so on, it helps to research
    your target first (see Chapter 3). You’ll mostly encounter memory interfaces implemented
    as parallel buses, be it for DRAM or for flash, as shown in the example of a DDR
    interface in [Figure 2-15](#figure2-15).
  prefs: []
  type: TYPE_NORMAL
- en: A few options are available for connecting to parallel interfaces in circuit.
    If the pitch of pins is wide enough, you might be able to use a few dozen grabber
    probes and a rat’s nest of wires to connect to a logic analyzer or a universal
    programmer (see Appendix A for sample vendors). More often than not, you will
    find that when devices have many pins, the pins are much smaller and are routed
    to inner PCB layers. Most chips come in standard sizes, and although they may
    be expensive, you can buy in-circuit clips for most devices. Unlike the clips
    for less-dense components, these usually have a flexible printed circuit ribbon
    that carries all the traces out to a separate breakout board, which you might
    be able to adapt to your analyzer or programmer.
  prefs: []
  type: TYPE_NORMAL
- en: As long as you can reach the pins, you should be able to figure out some way
    to connect to them. A logic analyzer would let you capture all the traffic that
    goes across the interface for later analysis, if it’s fast enough, and then only
    for a passive analysis.
  prefs: []
  type: TYPE_NORMAL
- en: If you do need full control of the interface and can’t isolate it from the rest
    of the system, or if your target device is a ball grid array (BGA) package with
    no accessible pins, you might have to remove the chip from the board to read or
    write to it. De-soldering and replacing a device without damaging anything certainly
    isn’t foolproof and probably doesn’t sound easy, but with practice (or the help
    of a talented friend), you can do it reliably with a relatively low risk of failure.
    (Chapter 3 details readout of flash chips further, and Appendix A lists some useful
    tools.)
  prefs: []
  type: TYPE_NORMAL
- en: High-Speed Serial Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve discussed how it’s easier to lay down eight times as many traces than
    it is to run one wire reliably at eight times the speed. Although the term *high-speed
    serial interface* may sound like a contradiction, it isn’t. In the previous section,
    we described single-ended signals, and earlier in this chapter, we mentioned that
    differential signals can be run in the GHz range reliably in conditions where
    single-ended signals would be limited to a few MHz.
  prefs: []
  type: TYPE_NORMAL
- en: High-speed serial interfaces have facilitated most of the data rate increases
    in the past decade. Parallel ATA cables with 40 pins maxed out at 133 MHz were
    replaced by seven-pin Serial ATA cables that now run at 6 GHz. PCI slots with
    32 data lines made it to 33 or 66 MHz, but they were superseded by PCIe lanes
    that now run up to 8 GHz. This is the case for a few reasons.
  prefs: []
  type: TYPE_NORMAL
- en: First, with parallel wires, you need to make sure that all the signals are stable
    at the receiver end within one cycle of the clock. This becomes trickier with
    increasing frequencies, as that means all the wires must have very similar physical
    properties, such as length and electrical characteristics. Second, parallel wires
    suffer from crosstalk, which means one wire acts as an antenna and the adjacent
    wires as receivers, leading to data errors. Those issues have less impact in single
    wires than when dealing with parallel wires, and using differential signaling
    reduces the impact even further.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of all this progress is that it’s far more difficult to observe
    or inject data on a 6 GHz differential signal than it is on a 400 kHz single-ended
    signal. This difficulty usually translates to “more expensive.” You can easily
    sniff that 6 GHz signal, but you need a logic analyzer the price of a mid-size
    sedan.
  prefs: []
  type: TYPE_NORMAL
- en: The silver lining is that all of these interfaces are electrically very similar,
    and they are designed to perform reliably even in less-than-optimal conditions.
    This means if the probe you’ve attached to a PCIe lane loads it so much that it
    can no longer function at full speed, it will automatically retrain at a lower
    speed without the rest of the system even noticing.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Serial Bus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: USB was the first major external interface that used high-speed differential
    signaling, and it set a few excellent precedents. First, if you plug in a USB
    device to a host equipped with a different version of the USB standard, both ends
    of the connection automatically settle at the highest common standard. Second,
    if transmissions are lost, missed, or interrupted, they are automatically retried.
    Finally, USB actually defines many characteristics, such as the connector shapes
    and pinouts, the electrical protocol, and the data protocol, all the way up to
    device classes and how to interface with them. An example is the USB *Human Interface
    Device (HID)* specification used for equipment like keyboards and mice, which
    allows the operating system (OS) to have one driver for all USB keyboards, instead
    of one per manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: 'USB connections feature one host and up to 127 devices (including hubs). USB
    versions are capable of different bit rates, from 12Mbps at USB 1.1, 480Mbps at
    USB 2.0, and up to 5, 10, and 20Gbps in USB 3.0, 3.1, and 3.2, respectively. For
    data rates up to 480Mbps, four wires are used. Above 480Mbps, five additional
    wires are needed. All nine wires are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: VBUS A 5 V line that can be used to power a device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D+ and D- The differential pair for communication up to version USB 2.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GND Venerable ground (for power).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSRX+, SSRX-, SSTX+, SSTX- Two differential pairs, one for reception and one
    for transmission (USB 3.0 and above).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GND_DRAIN Another ground for signal; this additional ground has less noise than
    the power ground, which may be dealing with much larger currents (USB 3.0 and
    above).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The USB’s power line provides a minimum of 100 mA at 5 V, which you can tap
    to power things in your setup. Depending on the USB standard and the host, this
    available current can go up to 5 A at 48 V (5 A × 48 V = 240 W), but you actually
    need to talk to the USB host digitally before it will allow you that amount of
    juice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for fun, grab your nearest USB 2.0 micro-cable and count the number of
    pins. You’ll find five, whereas only four are needed for USB 2.0\. The fifth pin
    is the ID pin, originally used for USB On-The-Go (OTG). Devices that can be both
    host or peripheral use OTG, and they come with a special OTG cable with a host
    and a peripheral end.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ID pin signals which end is inserted so the device can sense whether its
    role should be host or peripheral: a grounded ID pin signals “host,” and a floating
    ID pin signals “peripheral.” However, as Michael Ossmann and Kyle Osborn showed
    in their 2013 Black Hat talk “Multiplexed Wired Attack Surfaces” ([https://www.youtube.com/watch?v=jYa6-R-piZ4](https://www.youtube.com/watch?v=jYa6-R-piZ4)),
    you can enable hidden functionality through resistance values other than “grounded”
    or “floating.” They show that if you present a Galaxy Nexus (GT-I9250M) with 150
    kΩ resistance on the ID pin, it then turns USB off and a TTL serial UART on, which
    then provides debugging access.'
  prefs: []
  type: TYPE_NORMAL
- en: USB is pervasive and has been around for two decades, so it’s likely to be the
    best example of a high-speed serial interface that you can observe or manipulate
    as readily as other much simpler and slower interfaces. It also has the advantage
    of standard communications protocols, which means you can request specific information
    from almost any USB device. The USB stack itself is relatively complicated, so
    fuzzing often produces interesting results, which fault injection can push further.
    Micah Scott has an excellent demonstration of this, which you can see in a video
    titled “Glitchy Descriptor Firmware Grab – scanlime:015” ([https://www.youtube.com/watch?v=TeCQatNcF20](https://www.youtube.com/watch?v=TeCQatNcF20)).
  prefs: []
  type: TYPE_NORMAL
- en: PCI Express
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*PCI Express (PCIe)* is the high-speed serial evolution of the old PCI bus,
    and its architecture is surprisingly similar to USB. Both use high-speed differential
    pairs to make point-to-point links. Both have clearly defined hierarchies and
    protocols for enumerating devices. Both are backward compatible and automatically
    negotiate the optimal interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Although PCIe was designed with personal computers rather than embedded systems
    in mind, ARM and MIPS-based System-on-Chips (SoCs) currently on the market support
    PCIe, and you can find them in embedded systems costing as little as $20\. PCIe
    starts at 2.5 GHz instead of only 12 MHz, as is the case with USB, so a simple
    sniffer isn’t going to cut it. However, a few PCIe devices are versatile enough
    to enable some unintended uses.
  prefs: []
  type: TYPE_NORMAL
- en: A unique characteristic of PCIe is that it’s usually very tightly coupled with
    the CPU or SoC. Whereas USB doesn’t work without all the applicable drivers in
    place, PCIe usually gets full access to system memory as well as to all other
    PCIe devices and other devices in the system. If you can manage to get a rogue
    PCI device into your target system, you might be able to control all of the hardware
    in the entire system. See [https://github.com/ufrisk/pcileech/](https://github.com/ufrisk/pcileech/)
    for some examples on how to use PCIe to get memory dumps.
  prefs: []
  type: TYPE_NORMAL
- en: Ethernet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ethernet was first standardized in 1983 for creating computer networks. It has
    variants in terms of physical cables, speeds, and frame types, but the most common
    types you’ll encounter on an embedded system are 100BASE-TX (100Mbps) and 1000BASE-T
    (1Gbps) with the familiar 8P8C plug. This plug connects to a cable that contains
    four *twisted pairs* of wires. Each pair is used for differential signaling, and
    the twisting reduces crosstalk and external interference.
  prefs: []
  type: TYPE_NORMAL
- en: Both standards run at a 125 MHz line baud rate, which means if you hook up an
    oscilloscope, you’ll see 125 MHz signals. The 10 times speed difference between
    100BASE-TX and 1000BASE-T is because 100BASE-TX uses +1 V, 0 V, or −1 V over a
    single wire pair, whereas 1000BASE-T uses −2 V, −1 V, 0 V, +1 V, and +2 V levels
    on all four wire pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Measurement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No hardware book is complete without some basics on measurement. You’ll use
    measurements to learn more about your target, but more important, understanding
    measurements will help you debug all the connection mishaps you may encounter.
    Let’s look at some basic tools—the trusty old multimeter, flashy oscilloscopes,
    and tragically hip logic analyzers—and discuss why and how to use them, what can
    go wrong, and some references for good additions to your lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multimeter: Volt'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Measuring voltage is important for determining supply voltages or communication
    voltages. If you intend to power a chip yourself using a lab supply, using a voltmeter
    is a good sanity check before attaching the power supply (where you’ve found the
    voltage from the device datasheet hopefully). Similarly, for communication voltages,
    you may need to match the voltages on the PCB to your communication interface
    using *level shifters*.
  prefs: []
  type: TYPE_NORMAL
- en: Set your multimeter to measure DC voltage. The multimeter’s AC measurement setting
    doesn’t come into play in the types of circuits we are interested in here. Some
    meters will have auto-ranging functions, and some meters will need you to set
    a “maximum range.” For measuring a 3.3 V voltage, you would need to set the range
    switch to above the 3.3 V, so a 10 V, 20 V, and 200 V range would all work. Consult
    your user manual for more details. Measure the voltage between ground (normally
    you can put the black probe on the chassis, but sometimes that isn’t ground) and
    the point where you want to know the voltage level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multimeter: Continuity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Measuring *continuity* lets you find out whether two points are connected, which
    can be useful for tracing wires, headers, pins, and so on, on a PCB. To measure
    continuity, set the multimeter to ohm, because a resistance close to zero means
    that two points are electrically connected. Again, check your manual on exactly
    how to connect it. Power down the target when you measure resistance so that there
    is almost no risk of damaging anything. Put the two probes on two points, and
    if the resistance is close to zero (or you hear a beep), you have a connection.
    Get a multimeter that beeps when there is a connection so you don’t need to monitor
    its screen all the time.
  prefs: []
  type: TYPE_NORMAL
- en: The continuity test is done by running a small current through the probe leads
    and measuring the voltage. If you attempt to measure a device that still has power,
    you will often get false readings since the meter will “see” a voltage that is
    actually supplied by your circuit under test.
  prefs: []
  type: TYPE_NORMAL
- en: Digital Oscilloscope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An *oscilloscope* measures and visualizes analog signals in the form of variations
    in voltage over time. When we say oscilloscope or scope, we mean *digital* sampling
    oscilloscopes, as analog scopes don’t have the features we need. Scopes can measure
    digital communication channels (although a logic analyzer is a more fitting tool),
    and with the right probes and target preparation scopes can measure power consumption
    or electromagnetic (EM) radiation when you’re performing side-channel analysis.
    It’s a critical tool for discovering what’s going on in your PCB’s analog domain.
    Appendix A describes oscilloscopes from the perspective of their features. Here
    we focus on their usage.
  prefs: []
  type: TYPE_NORMAL
- en: A scope has a number of *input channels* that areconnected via one or more *probes*to
    a signal source, which can be a PCB trace or header, a pin of a microcontroller,
    or simply a coil to measure EM signals. A probe often *attenuates* (reduces the
    amplitude of) the signal source before forwarding the signal to the oscilloscope.
    For the probes that come with a scope, this attenuation is usually 10× and should
    be marked on your probe somewhere. This means that a 1 V differential in your
    signal results in a 0.1 V differential on the input to your scope; however, your
    scope probe may be switchable between 1× (which does not attenuate) and 10× (which
    does attenuate).
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of attenuation is that it reduces the loading on your circuit
    and increases the frequency response of the scope. Using a scope probe in 1× mode
    typically means a low bandwidth (cannot measure high-frequency signals), and the
    electrical load of the scope probe may affect your circuit under test. For this
    reason, many high-performance oscilloscope probes are fixed in 10× mode, as most
    users prefer the high-frequency response advantage of the 10× mode.
  prefs: []
  type: TYPE_NORMAL
- en: Any probe also needs to be *impedance matched* with your scope. The scope will
    have an *input impedance* (for example, 50 Ω or 1 MΩ), and your probe’s impedance
    needs to be the same to avoid signal degradation. Imagine two pipes connected
    together. If one pipe is much narrower than the other, a wave of water cannot
    properly propagate between the pipes; part of the wave energy bounces back at
    the connection point. In measurement terms, RG58U probe cables have a 50 Ω characteristic
    impedance, meaning that for very fast changes (such as steep edges), the cable
    looks like a 50 Ω termination. If you leave the scope at 1 MΩ, then the discontinuity
    causes the edge to reflect (bounce back) when it arrives at the scope. This distorts
    the measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The impedance on the scope may be fixed or configurable, and that of the probe
    is fixed. Normal oscilloscope probes are designed for 1 MΩ impedance. If you have
    fancy (expensive) oscilloscopes, they may automatically detect the type of probe
    attached. You may need an *impedance matcher* if you have a mismatch. Some special
    probes (such as current probes) require a 50 Ω impedance, for example, and if
    your oscilloscope doesn’t have this option, you’ll need such an impedance matcher.
  prefs: []
  type: TYPE_NORMAL
- en: Both the scope and the probe will also have an analog *bandwidth*, expressed
    in Hz, which represents the maximum frequency they can measure. The probe and
    scope don’t need to be matched, but the total bandwidth of the probe and scope
    is limited by the component with the lowest bandwidth. The signal you want to
    measure should be within that bandwidth. For instance, with side-channel analysis,
    make sure your scope’s bandwidth is higher than your crypto’s clock frequency.
    (This, however, is not a hard requirement; sometimes crypto will leak at frequencies
    lower than the clock.)
  prefs: []
  type: TYPE_NORMAL
- en: You can insert a *low-pass filter* to limit the bandwidth artificially, which
    can be handy to filter out noise in your signal. Similarly, you can add a *high-pass
    filter*, often used to remove DC or low-frequency components (many power supplies
    have low-frequency noise, for example). Select these filters based on frequency
    analysis of earlier measurements or knowledge of the target signal. The Mini-Circuits
    brand has some easy-to-use analog filters; make sure to impedance-match those
    with the scope and probe.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the scope channel in AC or DC coupling mode. *DC coupling*
    means it can measure all the way down to 0 Hz voltage (*DC offsets*), whereas
    *AC coupling* means very low frequencies are filtered out. For side-channel analysis,
    it’s usually not a big difference, so AC is a bit easier to use, as you don’t
    need to center the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Now that an analog signal is entering the scope, it needs to be converted to
    a digital signal using an *analog-to-digital converter (ADC)*. These have a resolution
    normally measured in bits. For instance, many scopes have an 8-bit ADC, which
    means the voltage range of the scope is divided into 256 equally *quantized* ranges.
    [Figure 2-16](#figure2-16) shows a simple example of a 3-bit ADC output, where
    a nice sine wave input is converted to a digital output (resembling the world
    of a once-popular 8-bit computer game featuring an Italian plumber).
  prefs: []
  type: TYPE_NORMAL
- en: This digital output has only fixed values; thus, the ADC doesn’t perfectly represent
    the input signal. The amount of error depends partly on the resolution; for example,
    if we have an 8-bit ADC instead of a 3-bit ADC, the “staircase” in the output
    of [Figure 2-16](#figure2-16) would have much smaller steps. However, the error
    in terms of absolute voltage depends also on the total range we are asking the
    ADC to represent. A 10 V range represented in 3 bits (eight steps) means each
    bit is 1.25 V, but a 1 V range in the same 3 bits would mean each step is 0.125
    V.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02016](image_fi/278748c02/f02016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-16: The sine wave input is converted to the step sequence of the digital
    output.'
  prefs: []
  type: TYPE_NORMAL
- en: The scope will have a minimum and maximum voltage, denoted by the *voltage range*,
    which is often configurable. Almost every scope will have an adjustable *span*,
    but some will also have an adjustable *input offset* too. The span would show
    the maximum range we could measure; for example, a 10 V span could mean we measure
    from –5 V to 5 V. If we have an input offset, we could shift that same span to
    mean a measurement of 0 V to 10 V instead. Be sure to configure it so that it
    narrowly hugs the signal in which you’re interested. If you make the range too
    small, you’ll *clip* the signal as its voltage goes outside the range. If you
    make the range too large, you’ll get a large *quantization error*. If you are
    using only 10 percent of the range, you’re making use of only about 10 percent
    of 256 of the possible same values. Different scopes will have different ranges
    of the input offset and spans.
  prefs: []
  type: TYPE_NORMAL
- en: These ADCs operate at a programmable *sampling rate*, which means the number
    of times per second they output a new sample. A *sample* is simply one measurement
    output. Normally, the sampling rate should be at least twice as fast as the highest
    frequency you want to capture, as stated in the Nyquist-Shannon sampling theorem.
    In practice, sampling higher than twice the highest frequency is better; go up
    to five times higher. If your oscilloscope measurement is *synchronous* to the
    target device, where each sample point occurs on the target clock cycle, you can
    get away with reduced sample rates.
  prefs: []
  type: TYPE_NORMAL
- en: A series of samples is called a *trace*. A digital oscilloscope has a buffer
    to record traces, called the *memory depth*. Once the recording fills up the memory,
    traces either need to be sent to a PC for processing or be discarded for the next
    measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The depth and sampling rate together determine the maximum length of a trace.
    For efficiency, it’s important to limit the trace length. The length of the trace
    is configured by the number of samples to acquire in a single trace.
  prefs: []
  type: TYPE_NORMAL
- en: An oscilloscope can be continuously measuring (recording) data, or else it can
    be started by an external stimulus called the *trigger*. The trigger is a digital
    signal that also comes into the scope through a dedicated trigger channel or normal
    probe channel. Once a scope is *armed*, it waits for the trigger signal to go
    above a configurable *trigger level*, after which the oscilloscope starts measuring
    a trace. If the scope does not observe a high trigger before the *trigger timeout*,
    it assumes a *trigger miss* and starts a measurement anyway. Setting the trigger
    timeout to something noticeable (like 10 seconds) is useful. If you see your *acquisition
    campaign* (taking lots of measurements) slow down to one trace every 10 seconds,
    you know you’re missing triggers. Initially, measuring and also looking at the
    *trigger channel* trace is helpful in order to debug any trigger issues.
  prefs: []
  type: TYPE_NORMAL
- en: In lab situations, the target itself often generates the trigger. For instance,
    if you want to measure a particular cryptographic operation, first pull the trigger
    high through an external general-purpose input/output (GPIO) pin and then start
    the operation. This way, the scope starts capturing just before the operation
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: Once the trace is fully captured, high-end scopes have a built-in display for
    visualization, while more simple USB scopes send the digital signal to a PC for
    visualization. Both can send the traces to a PC for analysis—for instance, for
    finding side channels!
  prefs: []
  type: TYPE_NORMAL
- en: Just like when you’re measuring voltages with a multimeter, your target needs
    to be powered on, so take precautions not to hurt yourself or your equipment.
    Also, make doubly sure all of these tools are properly configured. Misconfiguring
    a scope is not always self-evident, so be a good person and save your future self
    a lot of time spent redoing borked measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Common errors include failing to ground the scope leads correctly. If you’re
    using multiple scope probes, each one should be grounded, and you must ensure
    you are grounding each one to the same ground plane (otherwise, current will flow
    through your oscilloscope). If you will be working with high frequency or low
    noise measurements, a good ground is essential. Many oscilloscope probes have
    a little *spring ground* option, as shown in [Figure 2-17](#figure2-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02017](image_fi/278748c02/f02017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-17: A spring ground lead on a small oscilloscope probe'
  prefs: []
  type: TYPE_NORMAL
- en: With this grounding method, there is a small spacing between the ground on the
    PCB and the oscilloscope probe. It often requires bending the spring lead to fit
    your PCB, but it’s a low-cost and simple way of getting good high-frequency performance.
  prefs: []
  type: TYPE_NORMAL
- en: When setting up your measurements, you also want your connections to be physically
    robust. Scope probes hanging off a bench may get snagged by clothing (or any lab
    pets) and pull your expensive development board and the scope off with it. Temporary
    cable ties, hot glue, sticky tape, or even just heavy objects, are perfect for
    ensuring your probe wires aren’t about to be snagged by a passing body.
  prefs: []
  type: TYPE_NORMAL
- en: As much as possible, it’s best to change equipment settings or probe positions
    with the circuit off. It’s easy to slip when attaching a scope probe, and shorting
    out a power supply with a probe tip will often lead to pitting of the probe tip
    itself if an arc forms. Even the low voltages present in typical development boards
    can cause small arcs that damage your probe tips. Of course, you can also damage
    your device under test by shorting it out—or even shorting a higher voltage (such
    as a 12 V input voltage) to the low-voltage circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: Logic Analyzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *logic analyzer* is a device that allows you to capture digital signals. It’s
    like the digital variant of an oscilloscope. With it, you can capture and decode
    communications channels that use voltages for encoding data. You could use a logic
    analyzer to decode I2C, SPI, or UART communications, or to probe much wider communication
    buses at various baud rates. Like an oscilloscope, a logic analyzer has a number
    of channels, a sampling rate, voltage levels, and an (optional) trigger (see [Figure
    2-18](#figure2-18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02018](image_fi/278748c02/f02018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-18: Sample time series measurement from logic analyzer'
  prefs: []
  type: TYPE_NORMAL
- en: Some oscilloscopes do rudimentary logic capture and protocol analysis, but they
    are more limited in the number of channels. Conversely, some logic analyzers do
    rudimentary analog signal capture, but at very low bandwidths and sampling rates.
  prefs: []
  type: TYPE_NORMAL
- en: Not much can go wrong with logic analyzers. Like with a scope, you need to use
    it on a powered-on system, so all safety precautions apply.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter discussed a range of topics relating to hardware interfaces: electrical
    basics, using those basics for communication, as well as the different types of
    communication ports and protocols you may encounter on embedded devices. We’ve
    covered more than you’ll need to be able to communicate with a single device,
    so think of this chapter as a reference to browse through later, when you’ll have
    questions about what a volt is, what differential signaling is, or what that six-pin
    header on the PCB might be (more on that in Appendix B as well). This book comes
    with an index to help you identify where to look for particular information. We’ll
    be using the most well-known interfaces in the labs later in this book, but when
    it comes time to do work, you’ll need to communicate with all sorts of devices.
    With some practice, connecting to interfaces becomes just a small hurdle to leap
    over before getting to the interesting work of actually sending data on the interfaces
    (and eventually getting secrets out of them). In the meantime, use your knowledge
    of measurements (digital or analog) to debug the inevitable connection issues
    you’ll have. Just beware of the blue smoke!'
  prefs: []
  type: TYPE_NORMAL
