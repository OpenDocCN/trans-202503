- en: '**7**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7**'
- en: '**VARIABLES IN A HIGH-LEVEL LANGUAGE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级语言中的变量**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'This chapter explores the low-level implementation of variables found in high-level
    languages. Although assembly language programmers usually have a good feel for
    the connection between variables and memory locations, HLLs add sufficient abstraction
    to obscure this relationship. We’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了高级语言中变量的低级实现。尽管汇编语言程序员通常能较好地理解变量与内存位置之间的联系，但高级语言通过足够的抽象来掩盖这种关系。我们将讨论以下主题：
- en: The runtime memory organization typical for most compilers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数编译器的典型运行时内存组织
- en: How the compiler breaks up memory into different sections and places variables
    into each
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器如何将内存分割成不同的区域，并将变量放入每个区域
- en: The attributes that differentiate variables from other objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分变量与其他对象的属性
- en: The difference between static, automatic, and dynamic variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量、自动变量和动态变量之间的区别
- en: How compilers organize automatic variables in a stack frame
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器如何在堆栈帧中组织自动变量
- en: The primitive data types that hardware provides for variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件为变量提供的基本数据类型
- en: How machine instructions encode the address of a variable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器指令如何编码变量的地址
- en: When you finish reading this chapter, you should have a good understanding of
    how to declare variables in your program to use the least amount of memory and
    produce fast-running code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读完本章后，应该能够清楚地了解如何在程序中声明变量，以使用最少的内存并生成运行速度较快的代码。
- en: '**7.1 Runtime Memory Organization**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.1 运行时内存组织**'
- en: As [Chapter 4](ch04.xhtml#ch04) discussed, operating systems (like macOS, Linux,
    or Windows) put different types of data into different sections (or *segments*)
    of main memory. Although it’s possible to control the memory organization by running
    a linker and specifying various command-line parameters, by default Windows loads
    a typical program into memory using an organization like the one shown in [Figure
    7-1](ch07.xhtml#ch7fig1) (macOS and Linux are similar, although they rearrange
    some of the sections).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第4章](ch04.xhtml#ch04)所讨论的，操作系统（如 macOS、Linux 或 Windows）将不同类型的数据放入主内存的不同区域（或*段*）。虽然通过运行链接器并指定各种命令行参数可以控制内存组织，但默认情况下，Windows
    会使用[图7-1](ch07.xhtml#ch7fig1)中所示的内存组织将典型程序加载到内存中（macOS 和 Linux 类似，尽管它们重新排列了一些区域）。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Typical runtime memory organization for Windows*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：Windows的典型运行时内存组织*'
- en: The operating system reserves the lowest memory addresses. Generally, your application
    cannot access data (or execute instructions) at the lowest addresses in memory.
    One reason the OS reserves this space is to help detect `NULL` pointer references.
    Programmers often initialize pointers with `NULL` (`0`) to indicate that the pointer
    is not valid. Should you attempt to access memory location `0` under such an OS,
    the OS will generate a *general protection fault* to indicate that it’s an invalid
    memory location.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 操系统保留最低的内存地址。通常，您的应用程序无法访问内存中最低地址的数据（或执行指令）。操作系统保留这一空间的原因之一是帮助检测`NULL`指针引用。程序员通常使用`NULL`（`0`）来初始化指针，表示该指针无效。如果在这样的操作系统下尝试访问内存地址`0`，操作系统将生成*一般保护故障*，以表示这是一个无效的内存位置。
- en: 'The remaining seven sections of memory hold different types of data associated
    with your program: the stack, the heap, the code, constants, read-only data, static
    (initialized) variables, and storage (uninitialized) variables.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的七个内存区域包含与程序相关的不同类型的数据：堆栈、堆、代码、常量、只读数据、静态（已初始化）变量和存储（未初始化）变量。
- en: Most of the time, a given application can live with the default layouts chosen
    for these sections by the compiler and linker/loader. In some cases, however,
    knowing the memory layout can help you develop shorter programs. For example,
    because the code section is usually read-only, you might be able to combine the
    code, constant, and read-only data sections into a single section, thereby saving
    any padding space that the compiler/linker may place between these sections. Although
    for large applications this is probably insignificant, for small programs it can
    have a big impact on the size of the executable.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，给定的应用程序可以使用编译器和链接器/加载器为这些段选择的默认布局。然而，在某些情况下，了解内存布局可以帮助你开发更简短的程序。例如，由于代码段通常是只读的，你可能可以将代码段、常量段和只读数据段合并为一个单独的段，从而节省编译器/链接器可能在这些段之间插入的任何填充空间。尽管对于大型应用程序来说，这可能并不显著，但对于小型程序而言，这可能对可执行文件的大小产生较大影响。
- en: Next we’ll discuss each of these sections in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将详细讨论这些段。
- en: '**7.1.1 The Code, Constant, and Read-Only Sections**'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.1.1 代码段、常量段和只读段**'
- en: The code (or *text*) section in memory contains the machine instructions for
    a program. Your compiler translates each statement you write into a sequence of
    one or more byte values (machine instruction opcodes). The CPU interprets these
    opcode values during program execution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的代码（或*文本*）段包含程序的机器指令。你的编译器将你写的每个语句转换为一个或多个字节值（机器指令操作码）序列。在程序执行过程中，CPU会解释这些操作码值。
- en: Most compilers also attach a program’s read-only data and constant pool (constant
    table) sections to the code section because, like the code instructions, the read-only
    data is already write-protected. However, it is perfectly possible under Windows,
    macOS, Linux, and many other operating systems to create a separate section in
    the executable file and mark it as read-only. As a result, some compilers do support
    a separate read-only data section, and some compilers even create a different
    section (the constant pool) for the constants that the compiler emits. These sections
    contain initialized data, tables, and other objects that the program should not
    change during program execution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器还将程序的只读数据和常量池（常量表）段附加到代码段，因为与代码指令一样，只有只读数据已经是写保护的。然而，在Windows、macOS、Linux和许多其他操作系统下，完全可以在可执行文件中创建一个独立的段并标记为只读。因此，一些编译器确实支持独立的只读数据段，甚至有些编译器为编译器生成的常量创建了一个不同的段（常量池）。这些段包含初始化数据、表格和程序在执行过程中不应修改的其他对象。
- en: 'Many compilers generate multiple code sections and leave it up to the linker
    to combine them into a single code segment prior to execution. To understand why,
    consider the following short Pascal code fragment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译器生成多个代码段，并将其交由链接器在执行之前合并为一个单一的代码段。为了理解为什么，考虑以下简短的Pascal代码片段：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Without worrying about how it does so, assume that the compiler can figure
    out that the `then` section of this `if` statement executes far more often than
    the `else` section. An assembly programmer, wanting to write the fastest possible
    code, might encode this sequence as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设编译器可以搞清楚，这个`if`语句的`then`部分比`else`部分执行得要频繁得多，而无需关心其具体实现。一个汇编程序员为了编写尽可能快的代码，可能会将这个序列编码如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This assembly code might seem a bit convoluted, but keep in mind that any control
    transfer instruction is probably going to consume a lot of time because of pipelined
    operation on modern CPUs (see [Chapter 9](ch09.xhtml#ch09) of *WGC1* for the details).
    Code that executes without branching (or that falls straight through) executes
    the fastest. In the previous example, the common case falls straight through 99.9
    percent of the time. The rare case winds up executing two branches (one to transfer
    to the `else` section and one to return to the normal control flow). But because
    this code rarely executes, it can afford to take longer to do so.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段汇编代码可能看起来有些复杂，但请记住，任何控制转移指令可能会因为现代 CPU 上的流水线操作而消耗大量时间（有关详细信息，请参见*WGC1*的[第9章](ch09.xhtml#ch09)）。没有分支（或者直接执行）的代码执行速度最快。在前面的例子中，常见情况是99.9%的时间都直接执行。罕见的情况则执行两个分支（一个跳转到`else`段，另一个返回正常控制流）。但因为这段代码很少执行，所以可以容忍执行时间较长。
- en: 'Many compilers use a little trick to move sections of code around like this
    in the machine code they generate—they emit the code sequentially, but place the
    `else` code in a separate section. The following MASM code demonstrates this technique:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编译器使用一个小技巧，在它们生成的机器代码中像这样移动代码段——它们顺序地发出代码，但将`else`代码放置在一个独立的段中。以下 MASM 代码演示了这种技术：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though the `else` section code appears to immediately follow the `then`
    section’s code, placing it in a different segment tells the assembler/linker to
    move this code and combine it with other code in the `alternateCode` segment.
    This little trick, because it relies upon the assembler or linker to move the
    code, can simplify HLL compilers. (GCC, for example, uses this approach to move
    code around in the assembly language file it emits.) As a result, you will see
    this trick being used on occasion and can expect some compilers to produce multiple
    code segments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`else`部分的代码似乎紧接着`then`部分的代码，但将其放置在不同的段落中会告诉汇编器/链接器将这段代码移动并与其他代码合并到`alternateCode`段中。这个小技巧依赖于汇编器或链接器来移动代码，因此可以简化高级语言编译器（例如，GCC
    就采用这种方法来移动它发出的汇编语言文件中的代码）。因此，你会偶尔看到这个技巧被使用，并且可以预期某些编译器会生成多个代码段。
- en: '**7.1.2 The Static Variables Section**'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.1.2 静态变量部分**'
- en: 'Many languages provide the ability to initialize a global variable during the
    compilation phase. For example, in C/C++ you could use statements like the following
    to provide initial values for these static objects:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言在编译阶段提供初始化全局变量的能力。例如，在 C/C++ 中，你可以使用如下语句为这些静态对象提供初始值：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In C/C++ and other languages, the compiler places these initial values in the
    executable file. When you execute the application, the OS loads the portion of
    the executable file that contains these static variables into memory so that the
    values appear at the addresses associated with those variables. Therefore, when
    the program in this example first begins execution, `i` and `ch` will have these
    values bound to them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 和其他语言中，编译器将这些初始值放置在可执行文件中。当你执行应用程序时，操作系统会将包含这些静态变量的可执行文件部分加载到内存中，以便这些值出现在与这些变量相关联的地址上。因此，当本示例中的程序第一次开始执行时，`i`和`ch`将会绑定这些初始值。
- en: 'The static section is often called the `DATA` or `_DATA` segment in the assembly
    listings that most compilers produce. As an example, consider the following C
    code fragment:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 静态部分通常在大多数编译器生成的汇编清单中被称为`DATA`或`_DATA`段。以下是一个 C 代码片段的示例：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the MASM assembly code that the Visual C++ compiler emits for those
    declarations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Visual C++ 编译器为这些声明生成的 MASM 汇编代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the Visual C++ compiler places these variables in the `_DATA`
    segment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Visual C++ 编译器将这些变量放置在`_DATA`段中。
- en: '**7.1.3 The Storage Variables Section**'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.1.3 存储变量部分**'
- en: Most operating systems zero out memory prior to program execution. Therefore,
    if an initial value of `0` is suitable, you don’t need to waste any disk space
    with the static object’s initial value. Generally, however, compilers treat uninitialized
    variables in a static section as though you’ve initialized them with `0`, which
    consumes disk space. Some operating systems provide another section type, the
    storage variables section (also known as the *BSS section*), to avoid this wasted
    disk space.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统会在程序执行前将内存清零。因此，如果初始值为`0`是合适的，你就不需要浪费磁盘空间存储静态对象的初始值。然而，通常情况下，编译器会将静态部分中的未初始化变量当作已初始化为`0`来处理，这会占用磁盘空间。一些操作系统提供了另一种段类型，存储变量部分（也称为*BSS段*），以避免浪费磁盘空间。
- en: 'This section is where compilers typically store static objects that don’t have
    an explicit initial value. BSS, as noted in [Chapter 4](ch04.xhtml#ch04), stands
    for “block started by a symbol,” which is an old assembly language term describing
    a pseudo-opcode you would use to allocate storage for an uninitialized static
    array. In modern operating systems like Windows and Linux, the compiler/linker
    puts all uninitialized variables into a BSS section that simply tells the OS how
    many bytes to set aside for that section. When the OS loads the program into memory,
    it reserves sufficient memory for all the objects in the BSS section and fills
    this range of memory with zeros. Note that the BSS section in the executable file
    doesn’t contain any actual data, so programs that declare large uninitialized
    static arrays in a BSS section will consume less disk space. The following is
    the C/C++ example from the previous section, modified to remove the initializers
    so that the compiler will place the variables in the BSS section:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分是编译器通常存储没有显式初始值的静态对象的地方。如[第4章](ch04.xhtml#ch04)中所述，BSS 代表“由符号开始的块”（block
    started by a symbol），这是一个旧的汇编语言术语，用来描述一个伪操作码，用来为未初始化的静态数组分配存储空间。在像 Windows 和 Linux
    这样的现代操作系统中，编译器/链接器会将所有未初始化的变量放入 BSS 区，这个区只告诉操作系统为该区域预留多少字节。当操作系统将程序加载到内存中时，它会为
    BSS 区中的所有对象保留足够的内存，并将这一内存区域填充为零。请注意，可执行文件中的 BSS 区并不包含实际数据，因此，在 BSS 区中声明大型未初始化静态数组的程序会占用较少的磁盘空间。以下是前一部分的
    C/C++ 示例，修改后去除了初始化程序，使得编译器会将变量放入 BSS 区：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the Visual C++ output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Visual C++ 的输出：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Not all compilers use a BSS section. Many Microsoft languages and linkers, for
    example, simply combine the uninitialized objects with the static/read-only data
    section and explicitly give them an initial value of `0`. Although Microsoft claims
    that this scheme is faster, it certainly makes executable files larger if your
    code has large, uninitialized arrays (because each byte of the array winds up
    in the executable file—something that would not happen if the compiler placed
    the array in a BSS section). Note, however, that this is a default condition and
    you can change it by setting the appropriate linker flags.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的编译器都会使用 BSS 区。例如，许多微软的语言和链接器会将未初始化的对象与静态/只读数据区合并，并明确地给它们一个初始值 `0`。尽管微软声称这种方案更快，但如果你的代码中有大型的未初始化数组，它会导致可执行文件变得更大（因为数组的每个字节都会出现在可执行文件中——如果编译器将数组放入
    BSS 区，这种情况是不会发生的）。不过，请注意，这是默认设置，你可以通过设置适当的链接器标志来更改它。
- en: '**7.1.4 The Stack Section**'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.1.4 栈区**'
- en: The stack is a data structure that expands and contracts in response to procedure
    invocations and returns, among other things. At runtime, the system places all
    automatic variables (nonstatic local variables), subroutine parameters, temporary
    values, and other objects in the stack section of memory in a special data structure
    called the *activation record* (which is aptly named, as the system creates it
    when a subroutine first begins execution and deallocates it when the subroutine
    returns to its caller). Therefore, the stack section in memory is very busy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种数据结构，它会根据过程调用和返回等操作进行扩展和收缩。在运行时，系统将所有自动变量（非静态局部变量）、子例程参数、临时值以及其他对象放入内存的栈区，并使用一种叫做*激活记录*的特殊数据结构（这个名字非常贴切，因为系统会在子例程开始执行时创建它，并在子例程返回时将其释放）。因此，内存中的栈区非常繁忙。
- en: Many CPUs implement the stack using a special-purpose register called the *stack
    pointer*. Other CPUs (particularly some RISC CPUs) don’t provide an explicit stack
    pointer, instead using a general-purpose register for stack implementation. If
    a CPU provides a stack pointer, we say that the CPU supports a *hardware stack*;
    if it uses a general-purpose register, then we say that it uses a *software-implemented
    stack*. The 80x86 is a good example of a CPU that provides a hardware stack, and
    the PowerPC family is a good example of a CPU family with a software-implemented
    stack (most PowerPC programs use R1 as the stack pointer register). The ARM CPU
    supports a pseudo–hardware stack; it assigns one of the general-purpose registers
    as the hardware stack pointer but still requires an application to explicitly
    maintain the stack. Systems that provide hardware stacks can generally manipulate
    data on the stack using fewer instructions than systems with a software-implemented
    stack. On the other hand, RISC CPU designers who’ve chosen to use a software stack
    implementation feel that the presence of a hardware stack actually slows down
    all instructions the CPU executes. In theory, you could argue that the RISC designers
    are right; in practice, the 80x86 family includes some of the fastest CPUs around,
    providing ample proof that having a hardware stack doesn’t necessarily mean you’ll
    wind up with a slow CPU.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多CPU使用一种特殊用途的寄存器，称为*栈指针*，来实现栈操作。其他一些CPU（特别是一些RISC CPU）不提供明确的栈指针，而是使用一个通用寄存器来实现栈。如果CPU提供栈指针，我们称该CPU支持*硬件栈*；如果它使用通用寄存器，则我们称其使用*软件实现的栈*。80x86就是一个支持硬件栈的CPU的良好例子，而PowerPC家族则是使用软件实现栈的CPU家族的典型例子（大多数PowerPC程序使用R1作为栈指针寄存器）。ARM
    CPU支持伪硬件栈；它将一个通用寄存器指定为硬件栈指针，但仍然要求应用程序显式地维护栈。提供硬件栈的系统通常可以使用更少的指令来操作栈上的数据，而使用软件实现栈的系统则相对较多。另一方面，选择使用软件栈实现的RISC
    CPU设计师认为，硬件栈的存在实际上会减慢CPU执行的所有指令。理论上，你可以说RISC设计师是对的；但实际上，80x86家族包含一些最快的CPU，充分证明了拥有硬件栈并不意味着你会得到一款慢速CPU。
- en: '**7.1.5 The Heap Section and Dynamic Memory Allocation**'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.1.5 堆区和动态内存分配**'
- en: 'Although simple programs may need only static and automatic variables, sophisticated
    programs need to be able to allocate and deallocate storage dynamically under
    program control. In the C and HLA languages, you would use the `malloc()` and
    `free()` functions for this purpose. C++ provides the `new` and `delete` (and
    `std::unique_ptr`) operators. Pascal uses `new` and `dispose`. Java and Swift
    use `new` (deallocation is automatic in these languages). Other languages provide
    comparable routines. These memory allocation routines have a few things in common:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管简单的程序可能只需要静态和自动变量，但复杂的程序需要能够在程序控制下动态地分配和释放存储空间。在C和HLA语言中，您可以使用`malloc()`和`free()`函数来完成此任务。C++提供了`new`和`delete`（以及`std::unique_ptr`）操作符。Pascal使用`new`和`dispose`。Java和Swift使用`new`（这些语言中的内存释放是自动的）。其他语言也提供了类似的例程。这些内存分配例程有一些共同点：
- en: They let the programmer request how many bytes of storage to allocate (either
    by explicitly specifying the number of bytes to allocate or by specifying some
    data type whose size is known).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许程序员请求分配多少字节的存储空间（可以通过显式指定要分配的字节数或指定已知大小的数据类型来实现）。
- en: They return a *pointer* to the newly allocated storage (that is, the address
    of that storage).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们返回一个指向新分配存储区的*指针*（即该存储区的地址）。
- en: They provide a facility for returning the storage space to the system once it
    is no longer needed so the system can reuse it in a future allocation call.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了一种机制，当存储空间不再需要时，将其归还给系统，以便系统可以在未来的分配调用中重新使用它。
- en: Dynamic memory allocation takes place in a section of memory known as the *heap*.
    Generally, an application refers to data on the heap using pointer variables,
    either implicitly or explicitly; some languages, like Java and Swift, implicitly
    use pointers behind the scenes. Thus, these objects in heap memory are usually
    referred to as *anonymous variables* because they are referred to by their memory
    address (via pointers) rather than by a name.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配发生在称为*堆区*的内存区域。通常，应用程序通过指针变量隐式或显式地引用堆中的数据；一些语言，如Java和Swift，在幕后隐式使用指针。因此，这些堆内存中的对象通常被称为*匿名变量*，因为它们是通过其内存地址（通过指针）而不是名称来引用的。
- en: The OS and application create the heap section in memory after the program begins
    execution; the heap is never a part of the executable file. Generally, the OS
    and language runtime libraries maintain the heap for an application. Despite the
    variations in memory management implementations, it’s a good idea for you to have
    a basic idea of how heap allocation and deallocation operate, because using them
    inappropriately will have a very negative impact on your application performance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统和应用程序在程序开始执行后创建堆内存部分；堆内存永远不是可执行文件的一部分。通常，操作系统和语言运行时库维护着应用程序的堆内存。尽管内存管理的实现方式有所不同，但了解堆内存分配和释放的基本原理是个好主意，因为不当使用它们会对应用程序性能产生非常负面的影响。
- en: '**7.2 What Is a Variable?**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.2 变量是什么？**'
- en: If you consider the word *variable*, it’s obvious that it describes something
    that *varies*. But exactly what is it that varies? Most programmers would say
    that it’s the value that can vary during program execution. In fact, though, there
    are several things that can vary, so before defining a variable explicitly, we’ll
    discuss some characteristics that variables (and other objects) may possess.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下“*变量*”这个词，很明显它描述的是某些*变化*的事物。但究竟是什么在变化呢？大多数程序员会说是程序执行过程中可能变化的值。实际上，有几件事是可以变化的，因此，在明确地定义一个变量之前，我们先来讨论一下变量（以及其他对象）可能具备的一些特征。
- en: '**7.2.1 Attributes**'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.1 属性**'
- en: An *attribute* is some feature that is associated with an object. For example,
    common attributes of a variable include its name, its memory address, its size
    (in bytes), its runtime value, and a data type associated with that value. Different
    objects may have different sets of attributes. For example, a data type is an
    object that has attributes such as a name and size, but it won’t usually have
    a value or memory location associated with it. A constant can have attributes
    such as a value and a data type, but it doesn’t have a memory location and it
    might not have a name (for example, if it’s a literal constant). A variable may
    possess all of these attributes. Indeed, the attribute list usually determines
    whether an object is a constant, data type, variable, or something else.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*属性*是与某个对象相关联的某个特性。例如，变量的常见属性包括其名称、内存地址、大小（以字节为单位）、运行时值以及与该值相关联的数据类型。不同的对象可能拥有不同的属性集。例如，数据类型是一个对象，具有如名称和大小等属性，但通常没有与之关联的值或内存位置。常量可能具有如值和数据类型等属性，但它没有内存位置，且可能没有名称（例如，如果它是一个字面常量）。一个变量可能拥有所有这些属性。实际上，属性列表通常决定了一个对象是常量、数据类型、变量还是其他什么。
- en: '**7.2.2 Binding**'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.2 绑定**'
- en: '*Binding*, introduced in [Chapter 6](ch06.xhtml#ch06), is the process of associating
    an attribute with an object. For example, when a value is assigned to a variable,
    the value is bound to that variable at the point of the assignment. This bond
    remains until some other value is bound to the variable (via another assignment
    operation). Likewise, if you allocate memory for a variable while the program
    is running, the variable is bound to the memory address at that point. The variable
    and address are bound until you associate a different address with the variable.
    Binding needn’t occur at runtime. For example, values are bound to constant objects
    during compilation, and these bonds cannot change while the program is running.
    Similarly, addresses are bound to some variables at compile time, and those memory
    addresses cannot change during program execution (see “Binding Times” on [page
    150](ch06.xhtml#page_150) for more details).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*绑定*，在[第六章](ch06.xhtml#ch06)中介绍，是将一个属性与一个对象关联的过程。例如，当一个值被赋给一个变量时，这个值在赋值时被绑定到该变量。这个绑定将持续存在，直到某个其他值被绑定到该变量（通过另一次赋值操作）。同样，如果你在程序运行时为变量分配内存，变量就会在那个时刻与内存地址绑定。变量和地址会一直绑定，直到你为变量关联一个不同的地址。绑定不一定发生在运行时。例如，值在编译时就会被绑定到常量对象，这些绑定在程序运行时无法更改。同样，地址在编译时会与某些变量绑定，这些内存地址在程序执行过程中不能更改（有关详细信息，请参见[第150页](ch06.xhtml#page_150)中的“绑定时间”）。'
- en: '**7.2.3 Static Objects**'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.3 静态对象**'
- en: '*Static* objects have an attribute bound to them prior to the application’s
    execution. Constants are good examples of static objects; they have the same value
    bound to them throughout program execution.^([1](footnotes.xhtml#ch7fn1)) Global
    (program-level) variables in programming languages like Pascal, C/C++, and Ada
    are also examples of static objects because they have the same memory address
    bound to them throughout the program’s lifetime. The system binds attributes to
    a static object before the program begins execution (usually during compilation,
    linking, or even loading, though it is possible to bind values even earlier).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态*对象在应用程序执行之前绑定了某个属性。常量是静态对象的典型例子；它们在整个程序执行过程中绑定了相同的值。^([1](footnotes.xhtml#ch7fn1))
    在Pascal、C/C++和Ada等编程语言中，程序级别的全局变量也是静态对象的例子，因为它们在程序的生命周期中始终绑定相同的内存地址。系统在程序开始执行之前将属性绑定到静态对象（通常是在编译、链接，甚至加载期间，尽管也可以在更早的阶段绑定值）。'
- en: '**7.2.4 Dynamic Objects**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.4 动态对象**'
- en: '*Dynamic* objects have some attribute bound to them during program execution.
    While it is running, the program may choose to change that attribute (*dynamically*).
    Dynamic attributes usually cannot be determined at compile time. Examples of dynamic
    attributes include values bound to variables at runtime and memory addresses bound
    to certain variables at runtime (for example, via a `malloc()` or other memory
    allocation function call).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态*对象在程序执行期间绑定某些属性。在程序运行时，程序可能会选择动态地更改该属性（*动态地*）。动态属性通常无法在编译时确定。动态属性的例子包括在运行时绑定到变量的值，以及在运行时绑定到某些变量的内存地址（例如，通过`malloc()`或其他内存分配函数调用）。'
- en: '**7.2.5 Scope**'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.5 作用域**'
- en: The *scope* of an identifier is the section of the program where the identifier’s
    name is bound to the object. Because names in most compiled languages exist only
    during compilation, scope is usually a static attribute (although in some languages
    it can be dynamic, as I’ll explain shortly). By controlling where a name is bound
    to an object, you can reuse that name elsewhere in the program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符的*作用域*是程序中标识符名称与对象绑定的部分。由于大多数编译语言中的名称仅在编译期间存在，因此作用域通常是一个静态属性（尽管在某些语言中它可以是动态的，稍后我会解释）。通过控制名称与对象绑定的位置，你可以在程序的其他地方重用该名称。
- en: Most modern programming languages (such as C/C++/C#, Java, Pascal, Swift, and
    Ada) support the concept of *local* and *global* variables. A local variable’s
    name is bound to a particular object only within a given section of a program
    (for example, within a particular function). Outside the scope of that object,
    the name can be bound to a different object. This allows a global and a local
    object to share the same name without any ambiguity. This may seem potentially
    confusing, but being able to reuse variable names like `i` or `j` throughout a
    project can spare you from having to dream up equally meaningless unique variable
    names for loop indexes and other uses in the program. The scope of the object’s
    declaration determines where the name applies to a given object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言（如C/C++/C#、Java、Pascal、Swift和Ada）支持*局部*和*全局*变量的概念。局部变量的名称仅在程序的某个特定部分内绑定到特定对象（例如，在某个特定函数内）。在该对象的作用域之外，名称可以绑定到不同的对象。这允许全局对象和局部对象共享相同的名称，而不会产生歧义。这看起来可能会引起混淆，但能够在整个项目中重用像`i`或`j`这样的变量名称，可以避免为循环索引和程序中的其他用途发明同样无意义的唯一变量名称。对象声明的作用域决定了名称在哪个地方应用于给定对象。
- en: In interpretive languages, where the interpreter maintains the identifier names
    during program execution, scope can be a dynamic attribute. For example, in various
    versions of the BASIC programming language, `dim` is an executable statement.
    Before you execute `dim`, the name you define might have a completely different
    meaning than it does after you execute `dim`. SNOBOL4 is another language that
    supports dynamic scope. Still, most programming languages avoid dynamic scope
    because using it can result in difficult-to-understand programs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释型语言中，解释器在程序执行期间维护标识符名称，因此作用域可以是动态属性。例如，在BASIC编程语言的不同版本中，`dim`是一个可执行语句。在执行`dim`之前，你定义的名称可能与执行`dim`之后完全不同。SNOBOL4是另一种支持动态作用域的语言。然而，大多数编程语言避免使用动态作用域，因为使用它可能导致程序难以理解。
- en: Technically, scope can apply to any attribute, not just names, but this book
    will use the term only in contexts where a name is bound to a given variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，作用域可以应用于任何属性，而不仅仅是名称，但本书将在名称绑定到给定变量的上下文中使用该术语。
- en: '**7.2.6 Lifetime**'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.6 生命周期**'
- en: The *lifetime* of an attribute extends from the point when you first bind an
    attribute to an object to the point you break that bond, perhaps by binding a
    different attribute to the object. If the program associates some attribute with
    an object and never breaks that bond, the lifetime of the attribute is from the
    point of association to the point the program terminates. For example, the lifetime
    of a variable is from the time you first allocate memory for the variable to the
    moment you deallocate that variable’s storage. Because a program binds static
    objects prior to execution (and static attributes do not change during program
    execution), the lifetime of a static object extends from when the program begins
    execution to when it terminates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个属性的*lifetime*从你第一次将该属性绑定到一个对象时开始，到你断开这个绑定的时刻为止，可能是通过将另一个属性绑定到该对象来实现。如果程序将某个属性与对象关联，并且从未断开该关联，那么该属性的生命周期从关联时开始，到程序终止时结束。例如，变量的生命周期从你第一次为该变量分配内存开始，到你释放该变量的存储时结束。因为程序在执行之前就绑定了静态对象（并且静态属性在程序执行期间不会改变），所以静态对象的生命周期从程序开始执行时起，直到程序终止。
- en: '**7.2.7 Variable Definition**'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.2.7 变量定义**'
- en: To return to the question that started this section, we can now define *variable*
    as an object that can have a value bound to it dynamically. That is, the program
    can change the variable’s value attribute at runtime. Note the operative word
    *can*. It is necessary only for the program *to be able* to change a variable’s
    value at runtime; it doesn’t *have* to do so for the object to be considered a
    variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本节开头的问题，我们现在可以将*变量*定义为一个可以动态绑定值的对象。也就是说，程序可以在运行时改变变量的值属性。请注意，“可以”这个关键词。程序*能够*在运行时改变变量的值才是必要的；但它并不*必须*这么做，才能将对象视为一个变量。
- en: While dynamic binding of a value to an object is the defining attribute of a
    variable, other attributes may be dynamic or static. For example, the memory address
    of a variable can be statically bound to the variable at compile time or dynamically
    bound at runtime. Likewise, variables in some languages have dynamic types that
    change during program execution, while other variables have static types that
    remain fixed over an application’s execution. Only the binding of the value determines
    whether the object is a variable or something else (such as a constant).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将一个值动态绑定到一个对象是变量的定义特征，但其他属性可能是动态的或静态的。例如，变量的内存地址可以在编译时静态绑定到变量，或者在运行时动态绑定。同样，某些语言中的变量具有动态类型，类型会在程序执行期间变化，而其他变量则具有静态类型，在应用程序执行过程中保持固定。只有值的绑定决定了对象是变量还是其他类型（例如常量）。
- en: '**7.3 Variable Storage**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.3 变量存储**'
- en: Values must be stored in and retrieved from memory.^([2](footnotes.xhtml#ch7fn2))
    To do this, a compiler must bind a variable to one or more memory locations. The
    variable’s type determines the amount of storage it requires. Character variables
    may require as little as a single byte of storage, while large arrays or records
    can require thousands, millions, or more. To associate a variable with some memory,
    a compiler (or runtime system) binds the address of that memory location to that
    variable. When a variable requires two or more memory locations, the system usually
    binds the address of the first memory location to the variable and assumes that
    the contiguous locations following that address are also bound to the variable
    at runtime.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 值必须存储在内存中，并从内存中检索。^([2](footnotes.xhtml#ch7fn2)) 为了实现这一点，编译器必须将一个变量绑定到一个或多个内存位置。变量的类型决定了它需要多少存储空间。字符变量可能只需要一个字节的存储，而大型数组或记录可能需要成千上万、甚至更多的存储空间。为了将变量与某块内存关联，编译器（或运行时系统）会将该内存位置的地址绑定到该变量上。当一个变量需要两个或更多内存位置时，系统通常将第一个内存位置的地址绑定到该变量上，并假设在运行时该地址后面的连续位置也会与该变量绑定。
- en: 'Three types of bindings are possible between variables and memory locations:
    static binding, pseudo-static (automatic) binding, and dynamic binding. Variables
    are generally classified as static, automatic, or dynamic based upon how they
    are bound to their memory locations.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和内存位置之间可能存在三种类型的绑定：静态绑定、伪静态（自动）绑定和动态绑定。根据它们如何与内存位置绑定，变量通常被分类为静态、自动或动态。
- en: '**7.3.1 Static Binding and Static Variables**'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.3.1 静态绑定和静态变量**'
- en: 'Static binding occurs prior to runtime, at one of four possible times: at language
    design time, at compile time, at link time, or when the system loads the application
    into memory (but prior to execution). Binding at language design time is not all
    that common, but it does occur in some languages (especially assembly languages).
    Binding at compile time is common in assemblers and compilers that directly produce
    executable code. Binding at link time is fairly common (for example, some Windows
    compilers do this). Binding at load time, when the OS copies the executable into
    memory, is probably the most common for static variables. We’ll look at each possibility
    in turn.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 静态绑定发生在运行时之前，可能在四个时间点之一：语言设计时、编译时、链接时，或者当系统将应用程序加载到内存时（但在执行之前）。语言设计时绑定并不常见，但在一些语言中（尤其是汇编语言）会出现。编译时绑定在直接生成可执行代码的汇编器和编译器中很常见。链接时绑定也相当常见（例如，一些Windows编译器就是这样做的）。加载时绑定，当操作系统将可执行文件复制到内存中时，可能是静态变量最常见的绑定方式。我们将依次查看每一种可能性。
- en: '**7.3.1.1 Binding at Language Design Time**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.3.1.1 语言设计时绑定**'
- en: An address can be assigned at language design time when a language designer
    associates a language-defined variable with a specific hardware address (for example,
    an I/O device or a special kind of memory), and that address never changes in
    any program. Such objects are common in embedded systems and rarely found in applications
    on general-purpose computer systems. For example, on an 8051 microcontroller,
    many C compilers and assemblers automatically associate certain names with fixed
    locations in the 128 bytes of data space found on the CPU. CPU register references
    in assembly language are good examples of variables bound to some location at
    language design time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 地址可以在语言设计时分配，当语言设计者将语言定义的变量与特定的硬件地址（例如，I/O设备或特殊类型的内存）关联时，这个地址在任何程序中都不会改变。这类对象在嵌入式系统中很常见，但在通用计算机系统的应用程序中很少见。例如，在8051微控制器上，许多C编译器和汇编器会自动将某些名称与CPU的128字节数据空间中的固定位置关联。汇编语言中的CPU寄存器引用是绑定到语言设计时某个位置的变量的典型例子。
- en: '**7.3.1.2 Binding at Compile Time**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.3.1.2 编译时绑定**'
- en: An address can be assigned at compile time when the compiler knows the memory
    region where it can place static variables at runtime. Generally, such compilers
    generate absolute machine code that must be loaded at a specific address in memory
    prior to execution. Most modern compilers generate relocatable code and, therefore,
    don’t fall into this category. Nevertheless, lower-end compilers, high-speed student
    compilers, and compilers for embedded systems often use this binding technique.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 地址可以在编译时分配，当编译器知道它可以在运行时将静态变量放置到内存中的哪个区域时。通常，这种编译器会生成绝对机器代码，该代码必须在执行前加载到内存中的特定地址。大多数现代编译器生成可重定位代码，因此不属于这一类。然而，低端编译器、高速学生编译器以及嵌入式系统的编译器通常使用这种绑定技术。
- en: '**7.3.1.3 Binding at Link Time**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.3.1.3 链接时绑定**'
- en: Certain linkers and related tools can link together various relocatable object
    modules of an application and create an absolute load module. So, while the compiler
    produces relocatable code, the linker binds memory addresses to the variables
    (and machine instructions). Usually, the programmer specifies (via command-line
    parameters or a linker script file) the base address of all the static variables
    in the program; the linker will bind the static variables to consecutive addresses
    starting at the base address. Programmers who are placing their applications in
    read-only memory (ROM), such as a BIOS (Basic Input/Output System) ROM for a PC,
    often employ this scheme.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 某些链接器和相关工具可以将应用程序的各种可重定位目标模块链接在一起，创建一个绝对加载模块。因此，虽然编译器生成可重定位代码，但链接器会将内存地址绑定到变量（以及机器指令）上。通常，程序员会通过命令行参数或链接脚本文件指定程序中所有静态变量的基地址；链接器将把静态变量绑定到从基地址开始的连续地址上。将应用程序放置在只读存储器（ROM）中的程序员（例如，PC的BIOS（基本输入/输出系统）ROM）通常会采用这种方案。
- en: '**7.3.1.4 Binding at Load Time**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.3.1.4 加载时绑定**'
- en: The most common form of static binding occurs at load time. Executable formats
    such as Microsoft’s PE/COFF and Linux’s ELF usually embed relocation information
    in the executable file. The OS, when it loads the application into memory, decides
    where to place the block of static variable objects and then patches all the addresses
    within instructions that reference those static objects. This allows the loader
    (for example, the OS) to assign a different address to a static object each time
    it loads it into memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 静态绑定最常见的形式发生在加载时。微软的 PE/COFF 和 Linux 的 ELF 等可执行格式通常将重定位信息嵌入可执行文件中。当操作系统将应用程序加载到内存中时，它决定将静态变量对象的块放置在哪个位置，然后修补所有引用这些静态对象的指令中的地址。这使得加载器（例如操作系统）在每次加载静态对象到内存时都能为其分配一个不同的地址。
- en: '**7.3.1.5 Static Variable Binding**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**7.3.1.5 静态变量绑定**'
- en: A static variable has a memory address bound to it prior to program execution,
    and enjoys a couple of advantages over other variable types. Because the compiler
    knows a static variable’s address prior to runtime, it can often use an *absolute
    addressing mode* or some other simple addressing mode to access that variable.
    Static variable access is often more efficient than other variable accesses because
    it doesn’t require any additional setup.^([3](footnotes.xhtml#ch7fn3))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量在程序执行之前就已经绑定了内存地址，并且相较于其他变量类型，它享有几个优势。由于编译器在运行时之前就知道静态变量的地址，因此它通常可以使用*绝对寻址模式*或其他简单的寻址模式来访问该变量。静态变量的访问通常比其他变量的访问更高效，因为它不需要任何额外的设置。^([3](footnotes.xhtml#ch7fn3))
- en: Another benefit of static variables is that they retain any value bound to them
    until you explicitly bind another value or until the program terminates. This
    means that static variables retain values while other events (such as procedure
    activation and deactivation) occur. Different threads in a multithreaded application
    can also share data using static variables.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量的另一个优点是它们保留与之绑定的任何值，直到你显式地绑定另一个值，或者程序终止。这意味着静态变量在其他事件（例如过程激活和停用）发生时仍然保留其值。在多线程应用程序中，不同线程也可以使用静态变量共享数据。
- en: Static variables also have a few disadvantages worth mentioning. First of all,
    because the lifetime of a static variable matches that of the program, it consumes
    memory the entire time the program is running. This is true even if the program
    no longer requires the value held by the static object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量也有一些值得注意的缺点。首先，由于静态变量的生命周期与程序相同，它在程序运行期间一直占用内存。即使程序不再需要静态对象所持有的值，这一点依然成立。
- en: Another disadvantage to static variables (particularly when using the absolute
    addressing mode) is that the entire absolute address must usually be encoded as
    part of the instruction, which makes the instruction much larger. Indeed, on most
    RISC processors an absolute addressing mode isn’t even available because you cannot
    encode an absolute address in a single instruction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量的另一个缺点（尤其是在使用绝对寻址模式时）是整个绝对地址通常必须作为指令的一部分进行编码，这使得指令变得更大。事实上，在大多数 RISC 处理器上，甚至没有绝对寻址模式，因为你无法在单个指令中编码绝对地址。
- en: Finally, code that uses static objects is not *reentrant* (meaning two threads
    or processes can concurrently execute the same code sequence); this means more
    effort is required to use that code in a multithreaded environment (where two
    copies of a section of code could be executing simultaneously, both accessing
    the same static object). However, multithreaded operation introduces a lot of
    complexity that is beyond the scope of this chapter, so we’ll ignore this issue
    for now.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用静态对象的代码不是*可重入*的（即两个线程或进程不能并发执行相同的代码序列）；这意味着在多线程环境中使用这些代码时需要更多的努力（在多线程环境中，可能有两份相同的代码同时执行，并且都访问同一个静态对象）。然而，多线程操作引入了很多复杂性，超出了本章的范围，因此我们暂时忽略这个问题。
- en: '**NOTE**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*See any good textbook on operating system design or concurrent programming
    for more details concerning the use of static objects.* Foundations of Multithreaded,
    Parallel, and Distributed Programming *by Gregory R. Andrews (Addison-Wesley,
    1999) is a good place to start.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关静态对象使用的更多细节，请参阅任何一本好的操作系统设计或并发编程教科书。* 《多线程、并行与分布式编程基础*》由 Gregory R. Andrews（Addison-Wesley，1999）出版，是一个很好的起点。'
- en: 'The following example demonstrates the use of static variables in a C program
    and shows the 80x86 code that the Visual C++ compiler generates to access them:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在 C 程序中使用静态变量，并展示了 Visual C++ 编译器生成的用于访问它们的 80x86 代码：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the comments point out, the assembly language code the compiler emits uses
    the displacement-only addressing mode to access all the static variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如注释所示，编译器生成的汇编语言代码使用仅有位移的寻址模式来访问所有静态变量。
- en: '**7.3.2 Pseudo-Static Binding and Automatic Variables**'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.3.2 伪静态绑定与自动变量**'
- en: Automatic variables have an address bound to them when a procedure or other
    block of code begins execution. The program releases that storage when the block
    or procedure completes execution. We call these objects *automatic* variables
    because the runtime code automatically allocates and deallocates storage for them,
    as needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 自动变量在一个过程或其他代码块开始执行时会绑定一个地址。当该代码块或过程执行完毕时，程序会释放这些存储空间。我们称这些对象为*自动*变量，因为运行时代码会根据需要自动分配和释放它们的存储空间。
- en: In most programming languages, automatic variables use a combination of static
    and dynamic binding known as *pseudo-static binding*. The compiler assigns an
    offset from a base address to a variable name during compilation. At runtime the
    offset always remains fixed, but the base address can vary. For example, a procedure
    or function allocates storage for a block of local variables (the activation record,
    introduced earlier in the chapter) and then accesses the local variables at fixed
    offsets from the start of that block of storage. Although the program cannot determine
    the final memory address of the variable until runtime, the compiler can select
    an offset that never changes during program execution, hence the name *pseudo-static*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，自动变量使用一种结合了静态绑定和动态绑定的方式，称为*伪静态绑定*。编译器在编译期间将一个偏移量分配给变量名，偏移量相对于基地址。在运行时，偏移量始终保持固定，但基地址可能会变化。例如，一个过程或函数为一块局部变量（即前面章节中提到的激活记录）分配存储空间，然后以固定的偏移量访问该块存储中的局部变量。虽然程序在运行时才能确定变量的最终内存地址，但编译器可以选择一个在程序执行期间始终不变的偏移量，因此称之为*伪静态*。
- en: Some programming languages use the term *local variables* in place of automatic
    variables. A local variable’s name is statically bound to a given procedure or
    block (that is, the scope of the name is limited to that procedure or block of
    code). Therefore, *local* is a static attribute in this context. It’s easy to
    see why the terms *local variable* and *automatic variable* are often confused.
    In some programming languages, such as Pascal, local variables are always automatic
    variables and vice versa. Nonetheless, always keep in mind that *local* is a static
    attribute and *automatic* is a dynamic one.^([4](footnotes.xhtml#ch7fn4))
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言用*局部变量*来代替自动变量。局部变量的名称静态绑定到某个给定的过程或代码块（即该名称的作用域仅限于该过程或代码块）。因此，*局部*在这个上下文中是一个静态属性。可以很容易理解为什么*局部变量*和*自动变量*这两个术语经常被混淆。在某些编程语言中，如Pascal，局部变量总是自动变量，反之亦然。尽管如此，始终要记住，*局部*是静态属性，而*自动*是动态属性。^([4](footnotes.xhtml#ch7fn4))
- en: Automatic variables have a couple of important advantages. First, they consume
    storage only while the procedure or block containing them is executing. This allows
    multiple blocks and procedures to share the same pool of memory for their automatic
    variable needs. Although some extra code must execute in order to manage automatic
    variables (in the activation record), this requires only a few machine instructions
    on most CPUs and has to be done only once for each procedure/block entry and exit.
    While in certain circumstances, the cost can be significant, the extra time and
    space needed to set up and tear down the activation record is usually inconsequential.
    Another advantage of automatic variables is that they often use a *base-plus-offset*
    addressing mode, where the base of the activation record is kept in a register
    and the offsets into the activation record are small—often 256 bytes or fewer.
    Therefore, CPUs don’t have to encode a full 32-bit (for example) address as part
    of the machine instruction—just an 8-bit (or other small) displacement, yielding
    shorter instructions. It’s also worth noting that automatic variables are “thread-safe”
    and code that uses automatic variables can be reentrant. This is because each
    thread maintains its own stack space (or similar data structure) where compilers
    maintain automatic variables; therefore, each thread will have its own copy of
    any automatic variables the program uses.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 自动变量有一些重要的优势。首先，它们仅在包含它们的过程或块执行时占用存储空间。这使得多个块和过程可以共享同一内存池中的自动变量需求。尽管需要执行一些额外的代码来管理自动变量（在激活记录中），但在大多数CPU上，这只需要几条机器指令，并且每个过程/块的进入和退出时仅需要执行一次。虽然在某些情况下，成本可能会比较高，但设置和销毁激活记录所需的额外时间和空间通常是微不足道的。自动变量的另一个优势是它们通常使用*基址加偏移量*寻址模式，其中激活记录的基址保存在寄存器中，而激活记录中的偏移量较小——通常是256字节或更少。因此，CPU无需将完整的32位（例如）地址编码为机器指令的一部分——只需编码一个8位（或其他小）偏移量，从而生成较短的指令。还值得注意的是，自动变量是“线程安全”的，使用自动变量的代码可以重新进入。这是因为每个线程都有自己的栈空间（或类似的数据结构），编译器在其中维护自动变量；因此，每个线程将拥有程序使用的任何自动变量的副本。
- en: Automatic variables do have some disadvantages, though. If you want to initialize
    an automatic variable, you have to use machine instructions to do so. You can’t
    initialize an automatic variable, as you can static variables, when the program
    loads into memory. Also, any values maintained in automatic variables are lost
    whenever you exit the block or procedure containing them. As noted, automatic
    variables require a small amount of overhead; some machine instructions must execute
    in order to build and destroy the activation record containing those variables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自动变量也有一些缺点。如果你想初始化一个自动变量，你必须使用机器指令来完成。你不能像静态变量那样，在程序加载到内存时初始化自动变量。此外，任何保存在自动变量中的值，在你退出包含它们的块或过程时都会丢失。如前所述，自动变量需要少量的开销；必须执行一些机器指令来构建和销毁包含这些变量的激活记录。
- en: 'Here’s a short C example that uses automatic variables and the 80x86 assembly
    code that the Microsoft Visual C++ compiler produces for it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简短的C示例，使用自动变量以及Microsoft Visual C++编译器为其生成的80x86汇编代码：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that when accessing automatic variables, the assembly code uses a *base-plus-displacement*
    addressing mode (for example, `j$[rsp]`). This addressing mode is often shorter
    than the displacement-only or RIP-relative addressing mode that static variables
    use (assuming, of course, that the offset to the automatic object is within 127
    bytes of the base address held in RSP).^([5](footnotes.xhtml#ch7fn5))
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在访问自动变量时，汇编代码使用*基址加位移*寻址模式（例如，`j$[rsp]`）。这种寻址模式通常比静态变量使用的仅位移或RIP相对寻址模式更短（当然，前提是自动对象的偏移量在基址地址RSP的127字节以内）。^([5](footnotes.xhtml#ch7fn5))
- en: '**7.3.3 Dynamic Binding and Dynamic Variables**'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.3.3 动态绑定和动态变量**'
- en: A dynamic variable has storage bound to it at runtime. In some languages, the
    application programmer is completely responsible for binding addresses to dynamic
    objects; in other languages, the runtime system automatically allocates and deallocates
    storage for a dynamic variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量在运行时绑定存储。在一些语言中，应用程序员完全负责将地址绑定到动态对象；在其他语言中，运行时系统自动为动态变量分配和释放存储。
- en: Dynamic variables are generally allocated on the heap via a memory allocation
    function such as `malloc()` or `new()` (or `std::unique_ptr`). The compiler has
    no way of determining the runtime address of a dynamic object, so the program
    must always refer to a dynamic object indirectly—that is, by using a pointer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量通常通过堆中的内存分配函数，如`malloc()`或`new()`（或`std::unique_ptr`）进行分配。编译器无法确定动态对象的运行时地址，因此程序必须始终通过间接引用动态对象——即通过使用指针。
- en: The big advantage to dynamic variables is that the application controls their
    lifetimes. Dynamic variables consume storage only as long as necessary, and the
    runtime system can reclaim that storage when the variable no longer requires it.
    Unlike automatic variables, the lifetime of a dynamic variable is not tied to
    the lifetime of some other object, such as a procedure or code block entry and
    exit. Memory is bound to a dynamic variable at the point the variable first needs
    it, and can be released when the variable no longer needs it. For variables that
    require considerable storage, then, dynamic allocation can make efficient use
    of memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量的一个主要优点是应用程序可以控制它们的生命周期。动态变量只在必要时消耗存储空间，当变量不再需要时，运行时系统可以回收该存储空间。与自动变量不同，动态变量的生命周期与其他对象（如过程或代码块的入口和出口）无关。内存分配给动态变量的时机是在该变量首次需要内存时，且当变量不再需要时可以释放这部分内存。因此，对于需要大量存储的变量，动态分配可以有效利用内存。
- en: Another advantage to dynamic variables is that most code references dynamic
    objects using a pointer. If that pointer value is already sitting in a CPU register,
    the program can usually reference that data using a short machine instruction,
    requiring no extra bits to encode an offset or address.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量的另一个优点是，大多数代码通过指针引用动态对象。如果该指针值已经存储在CPU寄存器中，程序通常可以使用简短的机器指令来引用该数据，无需额外的位数来编码偏移量或地址。
- en: Dynamic variables have several disadvantages as well. First, some storage overhead
    is often necessary to maintain them. Static and automatic objects usually don’t
    require extra storage; the runtime system, on the other hand, often requires some
    number of bytes to keep track of each dynamic variable in the system. This overhead
    ranges anywhere from 4 or 8 bytes to many dozens of bytes (in an extreme case)
    and keeps track of things like the current memory address of the object, the size
    of the object, and its type. If you’re allocating small objects, like integers
    or characters, the amount of storage required for bookkeeping purposes could exceed
    the storage required for the actual data. Also, since most languages reference
    dynamic objects using pointer variables, those pointers require some additional
    storage above and beyond the actual storage for the dynamic data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量也有几个缺点。首先，通常需要一些存储开销来维护它们。静态和自动对象通常不需要额外的存储；而运行时系统则通常需要一定数量的字节来跟踪系统中的每个动态变量。这个开销范围从4或8字节到几十字节（在极端情况下），它跟踪如对象的当前内存地址、对象的大小及其类型等信息。如果你正在分配小对象，如整数或字符，用于记录的存储开销可能会超过实际数据所需的存储空间。另外，由于大多数语言通过指针变量引用动态对象，这些指针需要额外的存储空间，超过实际存储动态数据的空间。
- en: Another problem with dynamic variables is performance. Because dynamic data
    is usually found in memory, the CPU has to access memory (which is slower than
    cached memory) on nearly every dynamic variable access. Even worse, accessing
    dynamic data often requires two memory accesses—one to fetch the pointer’s value
    and one to fetch the dynamic data, indirectly through the pointer. Managing the
    heap, where the runtime system keeps the dynamic data, can also impact performance.
    Whenever an application requests storage for a dynamic object, the runtime system
    has to search for a contiguous block of free memory large enough to satisfy the
    request. This search operation can be computationally expensive, depending on
    the heap’s organization (which affects the amount of overhead storage associated
    with each dynamic variable). Furthermore, when releasing a dynamic object, the
    runtime system may need to execute some code in order to free up that storage
    for use by other dynamic objects. These runtime heap allocation and deallocation
    operations are usually far more expensive than allocating and deallocating a block
    of automatic variables during procedure entry/exit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量的另一个问题是性能。由于动态数据通常存储在内存中，CPU 必须访问内存（这比缓存内存慢）来访问几乎每个动态变量。更糟糕的是，访问动态数据通常需要两次内存访问——一次是获取指针的值，另一次是通过指针间接获取动态数据。管理堆，运行时系统存储动态数据的地方，也可能影响性能。每当应用程序请求动态对象的存储时，运行时系统必须寻找一个足够大的连续空闲内存块来满足请求。这种搜索操作可能在计算上是昂贵的，这取决于堆的组织方式（这会影响与每个动态变量相关的额外存储开销）。此外，在释放动态对象时，运行时系统可能需要执行一些代码，以便为其他动态对象释放存储空间。这些运行时堆分配和释放操作通常比在过程入口/退出时分配和释放自动变量的开销要大得多。
- en: Another consideration with dynamic variables is that some languages (such as
    Pascal and C/C++^([6](footnotes.xhtml#ch7fn6))) require the application programmer
    to explicitly allocate and deallocate storage for dynamic variables. Without automatic
    allocation and deallocation, defects due to human error can creep into the code.
    This is why languages such as C#, Java, and Swift attempt to handle dynamic allocation
    automatically, even though this process can be slower.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 动态变量的另一个考虑因素是，有些语言（如 Pascal 和 C/C++^([6](footnotes.xhtml#ch7fn6)))要求应用程序员显式地分配和释放动态变量的存储空间。如果没有自动分配和释放，因人为错误而导致的缺陷可能会渗入代码中。这就是为什么像
    C#、Java 和 Swift 这样的语言试图自动处理动态分配，尽管这个过程可能会比较慢。
- en: Here’s a short example in C that demonstrates the kind of code that the Microsoft
    Visual C++ compiler generates in order to access dynamic objects allocated with
    `malloc()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 C 语言的简短示例，演示了 Microsoft Visual C++ 编译器为了访问通过 `malloc()` 分配的动态对象所生成的代码。
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s the machine code the compiler generates, including (manually inserted)
    comments that describe the extra work needed to access dynamically allocated objects:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是编译器生成的机器代码，包括（手动插入的）注释，描述了访问动态分配对象所需的额外工作：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, accessing dynamically allocated variables via a pointer requires
    a lot of extra work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过指针访问动态分配的变量需要额外的工作。
- en: '**7.4 Common Primitive Data Types**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.4 常见的原始数据类型**'
- en: 'Computer data always has a data type attribute that describes how the program
    interprets that data. The data type also determines the size (in bytes) of the
    data in memory. Data types can be divided into two categories: *primitive data
    types*, which the CPU can hold in a CPU register and operate upon directly, and
    *composite data types*, which are composed of smaller primitive data types. In
    the following sections we’ll review (from *WGC1*) the primitive data types found
    on most modern CPUs, and in the next chapter I’ll begin discussing composite data
    types.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机数据总是具有一个数据类型属性，用于描述程序如何解释该数据。数据类型还决定了数据在内存中的大小（以字节为单位）。数据类型可以分为两类：*原始数据类型*，这些数据类型可以被
    CPU 存储在 CPU 寄存器中并直接操作；以及*复合数据类型*，它们由较小的原始数据类型组成。在接下来的章节中，我们将回顾（来自 *WGC1*）大多数现代
    CPU 中的原始数据类型，而在下一章中，我将开始讨论复合数据类型。
- en: '**7.4.1 Integer Variables**'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.4.1 整型变量**'
- en: Most programming languages provide some mechanism for storing integer values
    in memory variables. In general, a programming language uses either unsigned binary
    representation, two’s-complement representation, or binary-coded decimal representation
    (or a combination of these) to represent integer values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供某种机制，用于在内存变量中存储整数值。通常，编程语言使用无符号二进制表示法、二补码表示法或二进制编码十进制表示法（或这些的组合）来表示整数值。
- en: Perhaps the most fundamental property of an integer variable in a programming
    language is the number of bits allocated to represent that integer value. In most
    modern programming languages, the number of bits used to represent an integer
    value is usually 8, 16, 32, 64, or some other power of two. Many languages provide
    only a single size for representing integers, but some languages let you select
    from several different sizes. You choose the size based on the range of values
    you want to represent, the amount of memory you want the variable to consume,
    and the performance of arithmetic operations involving that value. [Table 7-1](ch07.xhtml#ch7tab1)
    lists some common sizes and ranges for various signed, unsigned, and decimal integer
    variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 也许编程语言中整数变量最基本的属性是用于表示该整数值的位数。在大多数现代编程语言中，用于表示整数值的位数通常是 8、16、32、64 或其他某个二的幂。许多语言只提供一种表示整数的大小，但一些语言允许你从几种不同的大小中进行选择。你根据想要表示的值的范围、希望变量消耗的内存量以及涉及该值的算术运算的性能来选择大小。[表
    7-1](ch07.xhtml#ch7tab1)列出了各种有符号、无符号和十进制整数变量的一些常见大小和范围。
- en: Not all languages support all of these different sizes (indeed, to support all
    of them in the same program, you’d probably have to use assembly language). As
    noted earlier, some languages provide only a single size, which is usually the
    processor’s native integer size (that is, the size of a CPU general-purpose integer
    register).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的编程语言都支持这些不同的大小（实际上，要在同一个程序中支持所有这些大小，可能需要使用汇编语言）。如前所述，一些编程语言只提供一种大小，通常是处理器的本地整数大小（即
    CPU 通用整数寄存器的大小）。
- en: 'Languages that do provide multiple integer sizes often don’t give you an explicit
    selection of sizes from which to choose. For example, the C programming language
    provides up to five different integer sizes: `char` (which is always 1 byte),
    `short`, `int`, `long`, and `long long`. With the exception of the `char` type,
    C does not specify the sizes of these integer types other than to state that `short`
    integers are less than or equal to `int` objects in size, `int` objects are less
    than or equal to `long` integers in size, and `long` integers are less than or
    equal to `long long` integers in size. (In fact, all four could be the same size.)
    C programs that depend on integers being a certain size may fail when compiled
    with different compilers that don’t use the same sizes as the original compiler.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提供多种整数大小的编程语言通常并不会明确提供可以选择的大小。例如，C 语言提供最多五种不同的整数大小：`char`（始终为 1 字节）、`short`、`int`、`long`
    和 `long long`。除了 `char` 类型外，C 语言并没有指定这些整数类型的具体大小，只是指出 `short` 整数的大小小于或等于 `int`
    对象，`int` 对象的大小小于或等于 `long` 整数，而 `long` 整数的大小小于或等于 `long long` 整数。（实际上，这四种类型的大小可能是相同的。）依赖于整数具有特定大小的
    C 程序，可能会在使用不同编译器编译时失败，因为这些编译器使用的整数大小与原编译器不同。
- en: '**NOTE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*C99 and C++11 include types of exact sizes: int8_t, int16_t, int32_t, int64_t,
    and so on.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*C99 和 C++11 包括了确切大小的类型：int8_t, int16_t, int32_t, int64_t，依此类推。*'
- en: '**Table 7-1:** Common Integer Sizes and Their Ranges'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 常见整数大小及其范围'
- en: '| **Size, in bits** | **Representation** | **Unsigned range** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **大小（位数）** | **表示** | **无符号范围** |'
- en: '| 8 | Unsigned | `0..255` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 无符号 | `0..255` |'
- en: '|  | Signed | `-128..+127` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  | 有符号 | `-128..+127` |'
- en: '|  | Decimal | `0..99` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  | 十进制 | `0..99` |'
- en: '| 16 | Unsigned | `0..65,536` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 无符号 | `0..65,536` |'
- en: '|  | Signed | `-32768..+32,767` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  | 有符号 | `-32768..+32,767` |'
- en: '|  | Decimal | `0..9999` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  | 十进制 | `0..9999` |'
- en: '| 32 | Unsigned | `0..4,294,967,295` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 无符号 | `0..4,294,967,295` |'
- en: '|  | Signed | `-2,147,483,648..+2,147,483,647` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  | 有符号 | `-2,147,483,648..+2,147,483,647` |'
- en: '|  | Decimal | `0..99999999` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  | 十进制 | `0..99999999` |'
- en: '| 64 | Unsigned | `0..18,466,744,073,709,551,615` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 无符号 | `0..18,466,744,073,709,551,615` |'
- en: '|  | Signed | `-9,223,372,036,854,775,808.. +9,223,372,036,854,775,807` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  | 有符号 | `-9,223,372,036,854,775,808.. +9,223,372,036,854,775,807` |'
- en: '|  | Decimal | `0..9999999999999999` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  | 十进制 | `0..9999999999999999` |'
- en: '| 128 | Unsigned | `0..340,282,366,920,938,463,563,374,607,431,768,211,455`
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 无符号 | `0..340,282,366,920,938,463,563,374,607,431,768,211,455` |'
- en: '|  | Signed | `-170,141,183,460,469,231,731,687,303,715,884,105,728.. +170,141,183,460,469,231,731,687,303,715,884,105,727`
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | 有符号 | `-170,141,183,460,469,231,731,687,303,715,884,105,728.. +170,141,183,460,469,231,731,687,303,715,884,105,727`
    |'
- en: '|  | Decimal | `0..99999999999999999999999999999999` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | 十进制 | `0..99999999999999999999999999999999` |'
- en: While it may seem inconvenient that various programming languages avoid specifying
    an exact size for an integer variable, keep in mind that this ambiguity is intentional.
    When you declare an “integer” variable in a given programming language, the language
    leaves it up to the compiler’s implementer to choose the *best* size for that
    integer, based on performance and other considerations. The definition of “best”
    may change based on the CPU for which the compiler generates code. For example,
    a compiler for a 16-bit processor may choose to implement 16-bit integers because
    the CPU processes them most efficiently. A compiler for a 32-bit processor, however,
    may choose to implement 32-bit integers (for the same reason). Languages that
    specify the exact size of various integer formats (such as Java) can suffer as
    processor technology evolves and it becomes more efficient to process larger data
    objects. For example, when the world switched from 16-bit processors to 32-bit
    processors in general-purpose computer systems, it was actually faster to do 32-bit
    arithmetic on most of the newer processors. Therefore, compiler writers redefined
    *integer* to mean “32-bit integer” in order to maximize the performance of programs
    employing integer arithmetic.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管各编程语言没有明确指定整数变量的精确大小可能会显得不便，但请记住，这种模糊性是故意的。当你在某编程语言中声明一个“整数”变量时，语言会将选择该整数最佳大小的任务交给编译器的实现者，基于性能和其他考虑因素来决定。“最佳”定义可能会根据编译器为其生成代码的CPU而变化。例如，针对16位处理器的编译器可能会选择实现16位整数，因为该CPU处理它们最有效。然而，针对32位处理器的编译器可能会选择实现32位整数（出于同样的原因）。那些明确指定各种整数格式精确大小的语言（如Java）可能会随着处理器技术的发展而受到影响，因为随着大数据对象处理变得更加高效，编译器可能需要进行调整。例如，当世界从16位处理器过渡到32位处理器时，在大多数新的处理器上执行32位算术运算实际上更快。因此，编译器编写者重新定义了*整数*为“32位整数”，以最大化使用整数算术的程序的性能。
- en: Some programming languages provide support for unsigned integer variables as
    well as signed integers. At first glance, it might seem that the whole purpose
    behind supporting unsigned integers is to provide twice the number of positive
    values when negative values aren’t required. In fact, there are many other reasons
    great programmers might choose unsigned over signed integers when writing efficient
    code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言提供对无符号整数变量和有符号整数的支持。乍一看，似乎支持无符号整数的唯一目的是在不需要负值的情况下提供两倍的正数值。实际上，当编写高效代码时，很多优秀的程序员可能会选择无符号整数而非有符号整数，这背后有许多其他原因。
- en: The Swift programming language gives you explicit control over the size of integers.
    Swift provides 8-bit (signed) integers (`Int8`), 16-bit integers (`Int16`), 32-bit
    integers (`Int32`), and 64-bit integers (`Int64`). Swift also provides an `Int`
    type that’s either 32 bits or 64 bits depending on the native (most efficient)
    integer format for the underlying CPU. Swift further provides 8-bit unsigned integers
    (`UInt8`), 16-bit unsigned integers (`UInt16`), 32-bit unsigned integers (`UInt32`),
    64-bit unsigned integers (`UInt64`), and a generic `UInt` type whose size is determined
    by the native CPU size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Swift编程语言让你对整数的大小有明确的控制。Swift提供了8位（有符号）整数（`Int8`）、16位整数（`Int16`）、32位整数（`Int32`）和64位整数（`Int64`）。Swift还提供了一个`Int`类型，它的大小为32位或64位，具体取决于底层CPU的原生（最有效）整数格式。Swift进一步提供了8位无符号整数（`UInt8`）、16位无符号整数（`UInt16`）、32位无符号整数（`UInt32`）、64位无符号整数（`UInt64`），以及一个通用的`UInt`类型，其大小由原生CPU大小决定。
- en: On some CPUs, unsigned integer multiplication and division are faster than their
    signed counterparts. You can compare values within the range `0..n` more efficiently
    using unsigned integers rather than signed integers (the unsigned case requires
    only a single comparison against n); this is especially important when checking
    bounds of array indices where the array’s element index begins at `0`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些CPU上，无符号整数的乘法和除法比有符号整数更快。你可以更高效地比较`0..n`范围内的值，使用无符号整数而不是有符号整数（无符号情况只需要对n进行一次比较）；这一点在检查数组索引的边界时尤其重要，因为数组的元素索引从`0`开始。
- en: 'Many programming languages allow you to include variables of different sizes
    within the same arithmetic expression. The compiler automatically sign-extends
    or zero-extends operands to the larger size within an expression as needed to
    compute the final result. The problem with this automatic conversion is that it
    hides the fact that extra work is required to process the expression, and the
    expressions themselves don’t explicitly show this. An assignment statement such
    as:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言允许在同一个算术表达式中包含不同大小的变量。编译器会根据需要自动将操作数符号扩展或零扩展到表达式中的较大大小，以计算最终结果。这个自动转换的问题在于，它隐藏了处理表达式时需要额外工作这一事实，而表达式本身并没有明确显示这一点。像这样的赋值语句：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'could be a short sequence of machine instructions if the operands are all the
    same size, or it could require some additional instructions if the operands have
    different sizes. For example, consider the following C code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数的大小相同，则可以是一个简短的机器指令序列，或者如果操作数的大小不同，可能需要一些额外的指令。例如，考虑以下C代码：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compiling it with the Visual C++ compiler gives the following two assembly
    language sequences for the two assignment statements:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual C++编译器编译它时，给出了以下两个赋值语句的汇编语言序列：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the statement that operates on variables whose sizes are all
    the same uses fewer instructions than the one that mixes operand sizes in the
    expression.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，操作在大小相同的变量上的语句比操作混合操作数大小的表达式使用的指令少。
- en: When using different-sized integers in an expression, it’s also important to
    note that not all CPUs support all operand sizes equally efficiently. While it
    makes sense that using an integer size larger than the CPU’s general-purpose integer
    registers will produce inefficient code, it might not be quite as obvious that
    using *smaller* integer values can be inefficient as well. Many RISC CPUs work
    only on operands that are exactly the same size as the general-purpose registers.
    Smaller operands must first be zero-extended or sign-extended to the size of a
    general-purpose register prior to any calculations involving those values. Even
    on CISC processors, such as the 80x86, that have hardware support for different
    sizes of integers, using certain sizes can be more expensive. For example, under
    32-bit operating systems, instructions that manipulate 16-bit operands require
    an extra *opcode prefix byte* and are therefore larger than instructions that
    operate on 8-bit or 32-bit operands.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式中使用不同大小的整数时，还需要注意，并非所有的CPU对所有操作数大小的支持效率相同。虽然使用大于CPU通用寄存器整数大小的整数会产生低效代码是有道理的，但使用*更小*的整数值也可能低效，这一点可能不那么显而易见。许多RISC
    CPU只处理与通用寄存器大小完全相同的操作数。更小的操作数必须首先通过零扩展或符号扩展到通用寄存器的大小，然后才能进行任何涉及这些值的计算。即使在有硬件支持不同大小整数的CISC处理器上，如80x86，使用某些大小的整数也可能更昂贵。例如，在32位操作系统下，操作16位操作数的指令需要额外的*操作码前缀字节*，因此比操作8位或32位操作数的指令要大。
- en: '**7.4.2 Floating-Point/Real Variables**'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.4.2 浮点/实数变量**'
- en: 'Like integers, many HLLs provide multiple floating-point variable sizes. Most
    languages provide at least two different sizes: a 32-bit single-precision floating-point
    format and a 64-bit double-precision floating-point format, based on the IEEE
    754 floating-point standard. A few languages provide 80-bit floating-point variables
    (Swift is a good example), based on Intel’s 80-bit extended-precision floating-point
    format, but that usage is increasingly rare. The later ARM processors support
    quad-precision floating-point arithmetic (128-bit); some variants of GCC support
    a `_float128` type that uses quad-precision arithmetic.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 像整数一样，许多高级编程语言（HLL）提供多种浮点变量大小。大多数语言至少提供两种不同的大小：基于IEEE 754浮点标准的32位单精度浮点格式和64位双精度浮点格式。少数语言提供80位浮点变量（Swift就是一个很好的例子），它基于Intel的80位扩展精度浮点格式，但这种用法越来越少。后来的ARM处理器支持四倍精度浮点运算（128位）；一些GCC变体支持使用四倍精度运算的`_float128`类型。
- en: Different floating-point formats trade off space and performance for precision.
    Calculations involving smaller floating-point formats are usually quicker than
    calculations involving the larger formats. However, you give up precision to achieve
    improved performance and size savings (see [Chapter 4](ch04.xhtml#ch04) of *WGC1*
    for the details).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的浮点格式在精度、空间和性能之间做出权衡。涉及较小浮点格式的计算通常比涉及较大格式的计算更快。然而，为了提高性能和节省空间，你需要牺牲精度（有关详细信息，请参见*WGC1*的[第4章](ch04.xhtml#ch04)）。
- en: As with expressions involving integer arithmetic, you should avoid mixing different-sized
    floating-point operands in an expression. The CPU (or FPU) must convert all floating-point
    values to the same format before using them. This can involve additional instructions
    (consuming more memory) and additional time. Therefore, you should try to use
    the same floating-point types throughout an expression wherever possible.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与涉及整数运算的表达式一样，你应该避免在一个表达式中混合不同大小的浮点操作数。CPU（或FPU）必须在使用之前将所有浮点值转换为相同的格式。这可能涉及额外的指令（消耗更多内存）和额外的时间。因此，你应该尽量在整个表达式中使用相同的浮点类型。
- en: Conversion between integer and floating-point formats is another expensive operation
    you should avoid. Modern HLLs attempt to keep variables’ values in registers as
    much as possible. Unfortunately, on some modern CPUs it’s impossible to move data
    between the integer and floating-point registers without first copying that data
    to memory (which is expensive, because memory is slow). Furthermore, conversion
    between integer and floating-point numbers often involves several specialized
    instructions, all of which consume time and memory. Whenever possible, avoid these
    conversions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 整数与浮点格式之间的转换是另一项昂贵的操作，你应该避免。现代高级语言尽量将变量的值保存在寄存器中。不幸的是，在一些现代CPU上，无法在整数和浮点寄存器之间移动数据，而不先将数据复制到内存中（这很昂贵，因为内存比较慢）。此外，整数与浮点数之间的转换通常涉及几条专门的指令，这些指令都会消耗时间和内存。尽可能避免这些转换。
- en: '**7.4.3 Character Variables**'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.4.3 字符变量**'
- en: Standard character data in most modern HLLs consumes 1 byte per character. On
    CPUs that support byte addressing, such as the Intel 80x86 processor, a compiler
    can reserve a single byte of storage for each character variable and efficiently
    access that character variable in memory. Some RISC CPUs, however, cannot access
    data in memory except in 32-bit chunks (or another size other than 8 bits).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代高级语言中的标准字符数据每个字符消耗1字节。在支持字节寻址的CPU上，例如Intel 80x86处理器，编译器可以为每个字符变量保留一个字节的存储空间，并高效地在内存中访问该字符变量。然而，一些RISC
    CPU不能访问内存中的数据，除非是32位块（或者其他非8位的大小）。
- en: For CPUs that cannot address individual bytes in memory, HLL compilers usually
    reserve 32 bits for a character variable and use only the LO byte of that double-word
    variable for the character data. Because few programs have a large number of scalar
    character variables,^([7](footnotes.xhtml#ch7fn7)) the amount of space wasted
    is hardly an issue in most systems. However, if you have an unpacked array of
    characters, then the wasted space can become significant. We’ll return to this
    issue in [Chapter 8](ch08.xhtml#ch08).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法在内存中单独寻址字节的CPU，高级语言编译器通常为字符变量保留32位，并仅使用该双字变量的低字节存储字符数据。由于很少有程序需要大量的标量字符变量^([7](footnotes.xhtml#ch7fn7))，因此大多数系统中的空间浪费问题并不严重。然而，如果你有一个未打包的字符数组，那么浪费的空间可能会变得显著。我们将在[第8章](ch08.xhtml#ch08)中回到这个问题。
- en: Modern programming languages support the Unicode character set. Unicode characters
    can require between 1 and 4 bytes of memory to hold the character’s data value
    (depending on the underlying encoding, such as UTF-8, UTF-16, or UTF-32). As time
    passes, Unicode will likely replace the ASCII character set for most character-
    and string-oriented operations except in those programs that require high-performance
    random access to characters within strings (where Unicode performance suffers).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言支持Unicode字符集。Unicode字符可能需要1到4字节的内存来存储字符的数据值（具体取决于底层编码，例如UTF-8、UTF-16或UTF-32）。随着时间的推移，Unicode可能会取代ASCII字符集，成为大多数面向字符和字符串操作的程序的标准，除了那些需要高效随机访问字符串中字符的程序（在这些程序中，Unicode的性能较差）。
- en: '**7.4.4 Boolean Variables**'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.4.4 布尔变量**'
- en: A Boolean variable requires only a single bit to represent the two values `true`
    or `false`. HLLs usually reserve the smallest amount of memory possible for these
    variables (a byte on machines that support byte addressing, and a larger amount
    of memory on those CPUs that can address only 16-bit, 32-bit, or 64-bit memory
    values). However, this isn’t always the case. Some languages (like FORTRAN) allow
    you to create multibyte Boolean variables (for example, the FORTRAN `LOGICAL*4`
    data type).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量只需要一个位来表示`true`或`false`两个值。高级语言通常为这些变量保留最小的内存空间（在支持字节寻址的机器上为1字节，而在只能寻址16位、32位或64位内存值的CPU上，则保留更大的内存空间）。然而，这并不总是如此。有些语言（如FORTRAN）允许你创建多字节布尔变量（例如，FORTRAN中的`LOGICAL*4`数据类型）。
- en: Some languages (early versions of C/C++, for example) don’t support an explicit
    Boolean data type. Instead, they use an integer data type to represent Boolean
    values. Those C/C++ implementations use `0` and nonzero to represent `false` and
    `true`, respectively. In such languages, you get to choose the size of your Boolean
    variables by choosing the size of the integer you use to hold them. For example,
    in a typical older 32-bit implementation of the C/C++ languages, you can define
    1-byte, 2-byte, or 4-byte Boolean values as shown in [Table 7-2](ch07.xhtml#ch7tab2).^([8](footnotes.xhtml#ch7fn8))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（例如C/C++的早期版本）不支持显式的布尔数据类型。相反，它们使用整数数据类型来表示布尔值。这些C/C++实现使用`0`和非零值分别表示`false`和`true`。在这些语言中，你可以通过选择用于存储布尔值的整数大小来决定布尔变量的大小。例如，在一个典型的旧版32位C/C++实现中，你可以定义1字节、2字节或4字节的布尔值，如[表7-2](ch07.xhtml#ch7tab2)所示。^([8](footnotes.xhtml#ch7fn8))
- en: '**Table 7-2:** Defining Boolean Value Sizes'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 定义布尔值大小'
- en: '| **C integer data type** | **Size of Boolean object** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **C 整型数据类型** | **布尔对象的大小** |'
- en: '| `char` | 1 byte |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 1 字节 |'
- en: '| `short int` | 2 bytes |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | 2 字节 |'
- en: '| `long int` | 4 bytes |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `long int` | 4 字节 |'
- en: Some languages, under certain circumstances, use only a single bit of storage
    for a Boolean variable when that variable is a field of a record or an element
    of an array. We’ll return to this discussion in [Chapters 8](ch08.xhtml#ch08)–[11](ch11.xhtml#ch11)
    when considering composite data structures.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言在特定情况下，当布尔变量是记录的字段或数组的元素时，仅使用一个存储位。我们将在[第8章](ch08.xhtml#ch08)–[第11章](ch11.xhtml#ch11)中讨论复合数据结构时再回到这个话题。
- en: '**7.5 Variable Addresses and High-Level Languages**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.5 变量地址和高级语言**'
- en: The organization, class, and type of variables in your programs can affect the
    efficiency of the code that a compiler produces. Additionally, issues like the
    order of declaration, the size of the object, and the placement of the object
    in memory can have a big impact on the running time of your programs. This section
    describes how you can organize your variable declarations to produce efficient
    code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中变量的组织、类别和类型会影响编译器生成的代码效率。此外，声明顺序、对象大小以及对象在内存中的位置等问题，会对程序的运行时间产生巨大影响。本节将介绍如何组织变量声明以生成高效的代码。
- en: As for immediate constants encoded in machine instructions, many CPUs provide
    specialized addressing modes that access memory more efficiently than other, more
    general, addressing modes. Just as you can reduce the size and improve the speed
    of your programs by carefully selecting the constants you use, you can make your
    programs more efficient by carefully choosing how you declare variables. Whereas
    with constants you’re primarily concerned with their values, with variables you
    must consider the address in memory where the compiler places them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 至于机器指令中编码的立即数，许多CPU提供了专门的寻址模式，比其他更通用的寻址模式更高效地访问内存。就像通过仔细选择常量来减少程序的大小并提高速度一样，通过仔细选择变量的声明方式，也可以使程序更高效。对于常量，你主要关心它们的值；而对于变量，你必须考虑编译器将它们放置在内存中的地址。
- en: 'The 80x86 is a typical example of a CISC processor that provides multiple address
    sizes. When running on a modern 32- or 64-bit operating system like macOS, Linux,
    or Windows, the 80x86 CPU supports three address sizes: 0 bit, 8 bit, and 32 bit.
    The 80x86 uses 0-bit displacements for register-indirect addressing modes. We’ll
    ignore the 0-bit displacement addressing mode for now because 80x86 compilers
    generally don’t use it to access variables you explicitly declare in your code.
    The 8-bit and 32-bit displacement addressing modes are the more interesting ones
    for the current discussion.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86是一个典型的CISC处理器，提供多种地址大小。在现代32位或64位操作系统上运行时，如macOS、Linux或Windows，80x86 CPU支持三种地址大小：0位、8位和32位。80x86使用0位位移来进行寄存器间接寻址模式。我们暂时忽略0位位移寻址模式，因为80x86编译器通常不使用它来访问你在代码中显式声明的变量。8位和32位位移寻址模式是当前讨论中更有趣的部分。
- en: '**7.5.1 Allocating Storage for Global and Static Variables**'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.5.1 为全局和静态变量分配存储空间**'
- en: The 32-bit displacement is, perhaps, the easiest to understand. Variables you
    declare in your program, which the compiler allocates in memory rather than in
    a register, have to appear somewhere in memory. On most 32-bit processors, the
    address bus is 32 bits wide, so it takes a 32-bit address to access a variable
    at an arbitrary location in memory. An instruction that encodes this 32-bit address
    can access any memory variable. The 80x86 provides the *displacement-only* addressing
    mode, whose effective address is exactly the 32-bit constant embedded in the instruction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位位移也许是最容易理解的。你在程序中声明的变量，编译器会将它们分配到内存中，而不是寄存器中，这些变量必须出现在内存的某个地方。在大多数 32 位处理器中，地址总线宽度为
    32 位，因此需要一个 32 位地址来访问内存中任意位置的变量。编码此 32 位地址的指令可以访问任何内存变量。80x86 提供了 *仅位移* 寻址模式，其有效地址就是嵌入指令中的
    32 位常量。
- en: A problem with 32-bit addresses (one that gets even worse as we move to 64-bit
    processors with a 64-bit address) is that the address winds up consuming the largest
    portion of the instruction’s encoding. Certain forms of the displacement-only
    addressing mode on the 80x86, for example, have a 1-byte opcode and a 4-byte address.
    Therefore, 80 percent of the instruction’s size is consumed by the address. Were
    the 64-bit variants of the 80x86 (x86-64) to actually encode a 64-bit absolute
    address as part of the instruction, the instruction would be 9 bytes long and
    consume nearly 90 percent of the instruction’s bytes. To avoid this, the x86-64
    modified the displacement-only addressing mode. It no longer encodes the absolute
    address in memory as part of the instruction; instead, it encodes a signed 32-bit
    offset (±2 billion bytes) into the instruction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位地址的一个问题（随着我们转向使用 64 位处理器和 64 位地址，这个问题会变得更加严重）是，地址最终会占用指令编码中最大的一部分。例如，80x86
    上某些形式的仅位移寻址模式，拥有 1 字节的操作码和 4 字节的地址。因此，地址占用了指令大小的 80%。如果 80x86 的 64 位变体（x86-64）真的将一个
    64 位的绝对地址作为指令的一部分进行编码，那么该指令将是 9 字节长，并且几乎占用了指令字节的 90%。为了避免这种情况，x86-64 修改了仅位移寻址模式。它不再将绝对地址编码到指令中；相反，它将一个带符号的
    32 位偏移量（±20 亿字节）编码到指令中。
- en: On typical RISC processors, the situation is even worse. Because the instructions
    are uniformly 32 bits long on typical RISC CPUs, you cannot encode a 32-bit address
    as part of the instruction. In order to access a variable at an arbitrary 32-
    or 64-bit address in memory, you need to load the 32- or 64-bit address of that
    variable into a register and then use the register-indirect addressing mode to
    access it. For a 32-bit address, this could require three 32-bit instructions,
    as [Figure 7-2](ch07.xhtml#ch7fig2) demonstrates; that’s expensive in terms of
    both speed and space. It gets even more expensive with 64-bit addresses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 RISC 处理器上，情况甚至更糟。由于典型的 RISC CPU 上的指令都是 32 位长，因此无法将 32 位地址作为指令的一部分进行编码。为了访问内存中任意的
    32 位或 64 位地址的变量，你需要将该变量的 32 位或 64 位地址加载到寄存器中，然后使用寄存器间接寻址模式来访问它。对于 32 位地址，这可能需要三条
    32 位指令，正如 [图 7-2](ch07.xhtml#ch7fig2) 所示；这在速度和空间上都是昂贵的。对于 64 位地址，情况则更加昂贵。
- en: Because RISC CPUs don’t run horribly slower than CISC processors, compilers
    rarely generate code this bad. In reality, programs running on RISC CPUs often
    keep base addresses to blocks of objects in registers, so they can efficiently
    access variables in those blocks using short offsets from the base register. But
    how do compilers deal with arbitrary addresses in memory?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RISC CPU 的运行速度并不会比 CISC 处理器慢得离谱，编译器很少生成如此糟糕的代码。实际上，运行在 RISC CPU 上的程序通常将对象块的基地址保存在寄存器中，这样可以通过基寄存器的短偏移量高效地访问这些块中的变量。但编译器如何处理内存中的任意地址呢？
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: RISC CPU access of an absolute address*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：RISC CPU 访问绝对地址*'
- en: '**7.5.2 Using Automatic Variables to Reduce Offset Sizes**'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.5.2 使用自动变量来减少偏移量大小**'
- en: One way to avoid large instruction sizes with large displacements is to use
    an addressing mode with a smaller displacement. The 80x86 (and x86-64), for example,
    provide an 8-bit displacement form for the base-plus-indexed addressing mode.
    This form allows you to access data at an offset of –128 through +127 bytes around
    a base address contained in a register. RISC processors have similar features,
    although the number of displacement bits is usually larger, allowing a greater
    range of addresses.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用大位移的一个方法是使用较小位移的寻址模式。例如，80x86（以及x86-64）提供了一种8位位移形式，用于基址加索引寻址模式。该形式允许你在基地址（存储在寄存器中）附近，以–128到+127字节的偏移量访问数据。RISC处理器也有类似的特性，尽管位移位数通常较大，从而允许更大的地址范围。
- en: By pointing a register at some base address in memory and placing your variables
    near that base address, you can use the shorter forms of these instructions so
    your program will be smaller and run faster. This isn’t too difficult if you’re
    working in assembly language and you have direct access to the CPU’s registers.
    However, if you’re working in an HLL you may not have direct access to the CPU’s
    registers, and even if you did, you probably couldn’t convince the compiler to
    allocate your variables at convenient addresses. How do you take advantage of
    this small-displacement addressing mode in your HLL programs? The answer is that
    you don’t explicitly specify the use of this addressing mode; the compiler does
    it for you automatically.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将寄存器指向内存中的某个基地址，并将变量放置在该基地址附近，你可以使用这些指令的简短形式，从而使程序更小且运行更快。如果你在汇编语言中工作并能直接访问CPU的寄存器，这并不难。然而，如果你在高级语言（HLL）中工作，你可能无法直接访问CPU的寄存器，即使能访问，你也可能无法说服编译器将变量分配到方便的地址。那么，如何在HLL程序中利用这种小位移寻址模式呢？答案是，你并不需要显式指定使用这种寻址模式；编译器会自动为你处理。
- en: 'Consider the following trivial function in Pascal:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下在Pascal中的简单函数：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Upon entry into this function, the compiled code constructs an activation record
    (sometimes called a *stack frame*). An activation record, as you saw earlier in
    the chapter, is a data structure in memory where the system keeps the local data
    associated with a function or procedure. The activation record includes parameter
    data, automatic variables, the return address, temporary variables that the compiler
    allocates, and machine state information (for example, saved register values).
    The runtime system allocates storage for an activation record on the fly and,
    in fact, two different calls to the procedure or function may place the activation
    record at different addresses in memory. In order to access the data in an activation
    record, most HLLs point a register (usually called the *frame pointer*) at the
    activation record, and then the procedure or function references automatic variables
    and parameters at some offset from this frame pointer. Unless you have many automatic
    variables and parameters, or your automatic variables and parameters are quite
    large, these variables generally appear in memory at an offset near the base address.
    This means that the CPU can use a small offset when referencing variables near
    the base address held in the frame pointer. In the Pascal example given earlier,
    parameters `i` and `j` and the local variable `k` would most likely be within
    a few bytes of the frame pointer’s address, so the compiler can encode these instructions
    using a small displacement rather than a large displacement. If your compiler
    allocates local variables and parameters in an activation record, all you have
    to do is arrange your variables in the activation record so that they appear near
    its base address. But how do you do that?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这个函数时，编译后的代码构造了一个激活记录（有时称为*堆栈帧*）。如你在本章之前看到的，激活记录是内存中的一种数据结构，系统在其中保存与函数或过程相关的局部数据。激活记录包括参数数据、自动变量、返回地址、编译器分配的临时变量和机器状态信息（例如，保存的寄存器值）。运行时系统动态分配存储空间用于激活记录，实际上，对同一过程或函数的两次调用可能会将激活记录放置在内存中的不同地址。为了访问激活记录中的数据，大多数高级语言（HLL）会将一个寄存器（通常称为*帧指针*）指向激活记录，然后过程或函数在该帧指针的某个偏移量处引用自动变量和参数。除非你有许多自动变量和参数，或者你的自动变量和参数非常大，否则这些变量通常会出现在内存中接近基地址的偏移量处。这意味着CPU在引用接近帧指针持有的基地址的变量时，可以使用较小的偏移量。在前面给出的Pascal示例中，参数`i`和`j`以及局部变量`k`最有可能位于离帧指针地址几字节的地方，因此编译器可以使用小的位移编码这些指令，而不是大的位移。如果你的编译器在激活记录中分配局部变量和参数，你需要做的就是将你的变量安排在激活记录中，使它们出现在其基地址附近。但你该如何做到这一点呢？
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller places the parameter data (if any) in the activation record. Then the
    execution of an assembly language `call` (or equivalent) instruction adds the
    return address to the activation record. At this point, construction of the activation
    record continues within the procedure itself. The procedure copies the register
    values and other important state information and then makes room in the activation
    record for local variables. The procedure must also update the frame-pointer register
    (such as EBP on the 80x86, or RBP on the x86-64) so that it points at the base
    address of the activation record.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录的构建从调用过程的代码开始。调用者将参数数据（如果有的话）放入激活记录中。然后，执行一个汇编语言的`call`（或等效）指令将返回地址添加到激活记录中。此时，激活记录的构建继续在过程内部进行。过程复制寄存器值和其他重要的状态信息，然后为局部变量在激活记录中腾出空间。过程还必须更新帧指针寄存器（例如，在80x86中是EBP，或在x86-64中是RBP），使其指向激活记录的基地址。
- en: 'To see what a typical activation record looks like, consider the following
    HLA procedure declaration:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看典型的激活记录是什么样的，考虑以下HLA过程声明：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Whenever an HLA program calls this `ARDemo` procedure, it builds the activation
    record by pushing the data for the parameters onto the stack in the order they
    appear in the parameter list, from left to right. Therefore, the calling code
    first pushes the value for the `i` parameter, then for the `j` parameter, and
    finally for the `k` parameter. After pushing the parameters, the program calls
    the `ARDemo` procedure. Immediately upon entry into the procedure, the stack contains
    these four items, arranged as shown in [Figure 7-3](ch07.xhtml#ch7fig3), assuming
    the stack grows from high-memory addresses to low-memory addresses (as it does
    on most processors).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 HLA 程序调用这个 `ARDemo` 过程时，它会通过按照参数列表中的顺序将参数数据从左到右依次推送到栈上来构建激活记录。因此，调用代码首先将
    `i` 参数的值推送到栈上，然后是 `j` 参数的值，最后是 `k` 参数的值。在推送参数之后，程序调用 `ARDemo` 过程。进入该过程时，栈中包含这四个项，按照
    [图 7-3](ch07.xhtml#ch7fig3) 所示的方式排列，假设栈是从高地址向低地址增长的（如大多数处理器一样）。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Stack organization immediately upon entry into ARDemo*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：进入 ARDemo 时的栈组织*'
- en: The first few instructions in `ARDemo` push the current value of the frame-pointer
    register (such as EBP on the 32-bit 80x86, or RBP on the x86-64) onto the stack
    and then copy the value of the stack pointer (ESP/RSP on the 80x86/x86-64) into
    the frame pointer. Next, the code drops the stack pointer down in memory to make
    room for the local variables. This produces the stack organization shown in [Figure
    7-4](ch07.xhtml#ch7fig4) on the 80x86 CPU.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARDemo` 中的前几条指令将当前的框架指针寄存器值（例如，32 位 80x86 上的 EBP，或 x86-64 上的 RBP）推送到栈上，然后将栈指针（80x86/x86-64
    上的 ESP/RSP）的值复制到框架指针中。接下来，代码将栈指针向下移动到内存中，以便为局部变量腾出空间。这就产生了如 [图 7-4](ch07.xhtml#ch7fig4)
    所示的栈组织（在 80x86 CPU 上）。'
- en: To access objects in the activation record, you must use offsets from the frame-pointer
    register (EBP in [Figure 7-4](ch07.xhtml#ch7fig4)) to the desired object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问激活记录中的对象，必须使用框架指针寄存器（如 [图 7-4](ch07.xhtml#ch7fig4) 中的 EBP）到目标对象的偏移量。
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig04.jpg)'
- en: '*Figure 7-4: Activation record for ARDemo (32-bit 80x86)*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：ARDemo 的激活记录（32 位 80x86）*'
- en: The two items of immediate interest are the parameters and the local variables.
    As [Figure 7-5](ch07.xhtml#ch7fig5) shows, you can access the parameters at positive
    offsets from the frame-pointer register, and the local variables at negative offsets
    from the frame-pointer register.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最关心的两个项目是参数和局部变量。如 [图 7-5](ch07.xhtml#ch7fig5) 所示，您可以通过框架指针寄存器的正偏移量访问参数，通过框架指针寄存器的负偏移量访问局部变量。
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig05.jpg)'
- en: '*Figure 7-5: Offsets of objects in the ARDemo activation record on the 32-bit
    80x86*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：32 位 80x86 中 ARDemo 激活记录中对象的偏移量*'
- en: Intel specifically reserves the EBP/RBP (base-pointer register) to point at
    the base of the activation record. Therefore, compilers typically use this register
    as the frame-pointer register when allocating activation records on the stack.
    Some compilers instead attempt to use the 80x86 ESP/RSP (stack pointer) register
    to point to the activation record because this reduces the number of instructions
    in the program. Whether the compiler uses EBP/RBP, ESP/RSP, or some other register
    as the frame pointer, the bottom line is that the compiler typically points some
    register at the activation record, and most of the local variables and parameters
    are near the activation record’s base address.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔专门保留了 EBP/RBP（基指针寄存器）用于指向激活记录的基址。因此，编译器通常会使用这个寄存器作为框架指针寄存器，在栈上分配激活记录。有些编译器则尝试使用
    80x86 的 ESP/RSP（栈指针）寄存器指向激活记录，因为这样可以减少程序中的指令数量。无论编译器使用 EBP/RBP、ESP/RSP 还是其他寄存器作为框架指针，最终的结论是编译器通常会将某个寄存器指向激活记录，而大多数局部变量和参数都位于激活记录基址附近。
- en: As you can see in [Figure 7-5](ch07.xhtml#ch7fig5), all the local variables
    and parameters in the `ARDemo` procedure are within 127 bytes of the frame-pointer
    register (EBP). This means that on the 80x86 CPU, an instruction that references
    one of these variables or parameters will be able to encode the offset from EBP
    using a single byte. As mentioned earlier, because of the way the program builds
    the activation record, parameters appear at positive offsets from the frame-pointer
    register, and local variables appear at negative offsets from the frame-pointer
    register.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图7-5](ch07.xhtml#ch7fig5)中看到的，`ARDemo`过程中的所有局部变量和参数都在帧指针寄存器（EBP）127字节范围内。这意味着，在80x86
    CPU上，引用这些变量或参数的指令将能够使用单字节编码EBP的偏移量。如前所述，由于程序构建激活记录的方式，参数出现在帧指针寄存器的正偏移量处，而局部变量则出现在帧指针寄存器的负偏移量处。
- en: 'For procedures that have only a few parameters and local variables, the CPU
    will be able to access all parameters and local variables using a small offset
    (that is, 8 bits on the 80x86, some possibly larger value on various RISC processors).
    Consider, however, the following C/C++ function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只有少数参数和局部变量的过程，CPU能够使用较小的偏移量（即80x86上的8位，某些RISC处理器上可能更大）访问所有参数和局部变量。然而，请考虑以下C/C++函数：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The activation record for this function on the 32-bit 80x86 appears in [Figure
    7-6](ch07.xhtml#ch7fig6).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在32位80x86上的激活记录如[图7-6](ch07.xhtml#ch7fig6)所示。
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig06.jpg)'
- en: '*Figure 7-6: Activation record for BigLocals() function*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-6：BigLocals()函数的激活记录*'
- en: '**NOTE**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One difference between this activation record and the ones for the Pascal
    and HLA functions is that C pushes its parameters on the stack in the reverse
    order (that is, it pushes the last parameter first and the first parameter last).
    This difference, however, does not impact our discussion at all.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个激活记录与Pascal和HLA函数的激活记录之间的一个区别是，C语言将参数逆序压入栈中（即先压入最后一个参数，再压入第一个参数）。然而，这一差异对我们的讨论没有任何影响。*'
- en: The important thing to note in [Figure 7-6](ch07.xhtml#ch7fig6) is that the
    local variables `array` and `k` have large negative offsets. With offsets of –1,024
    and –1,028, the displacements from EBP to `array` and `k` are well outside the
    range that the compiler can encode into a single byte on the 80x86\. Therefore,
    the compiler has no choice but to encode these displacements using a 32-bit value.
    Of course, this makes accessing these local variables in the function quite a
    bit more expensive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7-6](ch07.xhtml#ch7fig6)中需要注意的重要一点是，局部变量`array`和`k`有较大的负偏移量。由于偏移量为–1,024和–1,028，从EBP到`array`和`k`的位移远超编译器能够在80x86上用单字节编码的范围。因此，编译器别无选择，只能使用32位值来编码这些位移。当然，这使得在函数中访问这些局部变量变得更加昂贵。
- en: Nothing can be done about the array variable in this example (no matter where
    you put it, the offset to the base address of the array will be at least 1,024
    bytes from the activation record’s base address). However, consider the activation
    record in [Figure 7-7](ch07.xhtml#ch7fig7).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子中的数组变量，无法做任何处理（无论你把它放在哪里，数组基地址的偏移量至少会比激活记录的基地址远1,024字节）。然而，请考虑[图7-7](ch07.xhtml#ch7fig7)中的激活记录。
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig07.jpg)'
- en: '*Figure 7-7: Another possible activation record layout for the BigLocals()
    function*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-7：BigLocals()函数的另一种可能的激活记录布局*'
- en: 'The compiler has rearranged the local variables in this activation record.
    Although it still takes a 32-bit displacement to access the `array` variable,
    accessing `k` now uses an 8-bit displacement (on the 32-bit 80x86) because `k`’s
    offset is –4\. You can produce these offsets with the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器已重新排列了此激活记录中的局部变量。尽管访问`array`变量仍然需要一个32位的位移，但访问`k`时现在使用8位位移（在32位80x86上），因为`k`的偏移量为–4。你可以使用以下代码生成这些偏移量：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In theory, rearranging the order of the variables in the activation record isn’t
    terribly difficult for a compiler to do, so you’d expect the compiler to make
    this modification so that it can access as many local variables as possible using
    small displacements. In practice, not all compilers actually do this optimization,
    for various technical and practical reasons (specifically, it can break some poorly
    written code that makes assumptions about the placement of variables in the activation
    record).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，重新排列激活记录中变量的顺序对编译器来说并不十分困难，因此你可以预期编译器会进行此修改，以便通过小的偏移量尽可能访问更多的局部变量。但实际上，并非所有编译器都会进行此优化，原因有很多，包括技术性和实际性的原因（具体来说，它可能会破坏一些对激活记录中变量位置做假设的写得不好的代码）。
- en: 'If you want to ensure that the maximum number of local variables in your procedure
    have the smallest possible displacements, the solution is trivial: declare all
    your 1-byte variables first, your 2-byte variables second, your 4-byte variables
    next, and so on, up to the largest local variable in your function. Generally,
    though, you’re probably more interested in reducing the size of the maximum number
    of instructions in your function rather than reducing the size of the offsets
    required by the maximum number of variables in your function. For example, if
    you have 128 1-byte variables and you declare these variables first, you’ll need
    only a 1-byte displacement if you access them. However, if you never access these
    variables, the fact that they have a 1-byte displacement rather than a 4-byte
    displacement saves you nothing. The only time you save any space is when you actually
    access that variable’s value in memory via some machine instruction that uses
    a 1-byte rather than a 4-byte displacement. Therefore, to reduce your function’s
    object code size, you want to maximize the number of instructions that use a small
    displacement. If you refer to a 100-byte array far more often than any other variable
    in your function, you’re probably better off declaring that array first, even
    if it leaves only 28 bytes of storage (on the 80x86) for other variables that
    will use the shorter displacement.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保在你的过程中的局部变量有尽可能小的偏移量，解决方案很简单：首先声明所有的 1 字节变量，其次是 2 字节变量，再然后是 4 字节变量，依此类推，直到函数中最大的局部变量。一般来说，然而，你可能更关心的是减少函数中最大数量的指令的大小，而不是减少函数中最大数量的变量所需的偏移量的大小。例如，如果你有
    128 个 1 字节变量，并且首先声明这些变量，那么访问它们时只需要 1 字节的偏移量。然而，如果你从未访问这些变量，那么它们有 1 字节偏移量而不是 4
    字节偏移量对你并没有任何帮助。你唯一节省空间的时刻是当你通过某个使用 1 字节而不是 4 字节偏移量的机器指令实际访问该变量的值时。因此，为了减少函数的目标代码大小，你希望最大化使用小偏移量的指令数量。如果你在函数中比任何其他变量更频繁地引用一个
    100 字节的数组，那么你可能更好地首先声明这个数组，即使这会导致（在 80x86 上）只为其他将使用较短偏移量的变量留下 28 字节的存储空间。
- en: RISC processors typically use a signed 12-bit or 16-bit offset to access fields
    of the activation record. Thus, you have more latitude with your declarations
    when using a RISC chip (which is good, because when you do exceed the 12-bit or
    16-bit limitation, accessing a local variable gets really expensive). Unless you’re
    declaring one or more arrays that consume more than 2,048 (12 bits) or 32,768
    bytes (combined), the typical compiler for a RISC chip will generate decent code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: RISC 处理器通常使用有符号的 12 位或 16 位偏移量来访问激活记录的字段。因此，使用 RISC 芯片时，你在声明时有更多的灵活性（这很好，因为当你超出
    12 位或 16 位的限制时，访问局部变量会变得非常昂贵）。除非你声明一个或多个数组，它们消耗超过 2,048 字节（12 位）或 32,768 字节（合计），否则典型的
    RISC 编译器会生成高效的代码。
- en: This same argument applies to parameters as well as local variables. However,
    it’s rare to find code passing a large data structure (by value) to a function
    because of the expense involved.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的理由也适用于参数和局部变量。然而，代码中传递大型数据结构（按值传递）给函数的情况很少，因为这样做的开销较大。
- en: '**7.5.3 Allocating Storage for Intermediate Variables**'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.5.3 分配中间变量的存储**'
- en: 'Intermediate variables are local to one procedure/function but global to another.
    You’ll find them in block-structured languages—like Free Pascal, Delphi, Ada,
    Modula-2, Swift, and HLA—that support nested procedures. Consider the following
    example program in Swift:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 中间变量对一个过程/函数来说是局部的，但对另一个过程/函数来说是全局的。你会在支持嵌套过程的块结构语言中看到它们——比如 Free Pascal、Delphi、Ada、Modula-2、Swift
    和 HLA。考虑一下下面这个用 Swift 写的示例程序：
- en: '[PRE19]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that nested procedures can access variables found in the main program (that
    is, global variables) as well as variables found in procedures containing the
    nested procedure (that is, the intermediate variables). As you’ve seen, local
    variable access is inexpensive compared to global variable access (because you
    always have to use a larger offset to access global objects within a procedure).
    Intermediate variable access, as is done in the `procTwo` procedure, is expensive.
    The difference between local and global variable accesses is the size of the offset/displacement
    coded into the instruction, with local variables typically using a shorter offset
    than is possible for global objects. Intermediate accesses, on the other hand,
    typically require several machine instructions. This makes the instruction sequence
    that accesses an intermediate variable several times slower and several times
    larger than accessing a local (or even global) variable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，嵌套过程可以访问在主程序中找到的变量（即全局变量），以及在包含嵌套过程的过程中找到的变量（即中间变量）。正如你所看到的，与全局变量访问相比，本地变量的访问成本较低（因为你总是需要使用较大的偏移量来访问过程中的全局对象）。如`procTwo`过程中所做的，中间变量访问是昂贵的。本地和全局变量访问的区别在于指令中编码的偏移量/位移的大小，本地变量通常使用比全局对象更短的偏移量。另一方面，中间变量访问通常需要多个机器指令。这使得访问一个中间变量的指令序列比访问本地（甚至全局）变量要慢几倍，且指令的体积也要大几倍。
- en: The problem with using intermediate variables is that the compiler must maintain
    either a linked list of activation records or a table of pointers to the activation
    records (a *display*) in order to reference intermediate objects. To access an
    intermediate variable, the `procTwo` procedure must either follow a chain of links
    (there would be only one link in this example) or do a table lookup in order to
    get a pointer to `procOne`’s activation record. Worse still, maintaining the display
    of this linked list of pointers isn’t exactly cheap. The work needed to maintain
    these objects has to be done on every procedure/function entry and exit, even
    when the procedure or function doesn’t access any intermediate variables on a
    particular call. Although there are, arguably, some software engineering benefits
    to using intermediate variables (having to do with information hiding) versus
    a global variable, keep in mind that accessing intermediate objects is expensive.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中间变量的问题在于，编译器必须维护一个激活记录的链表，或者维护一个指向激活记录的指针表（*显示表*），以便引用中间对象。为了访问一个中间变量，`procTwo`过程必须跟随一条链（在这个例子中只有一条链），或者进行表查找，以便获取指向`procOne`激活记录的指针。更糟糕的是，维护这个指针链表的显示表并不便宜。维护这些对象的工作必须在每次过程/函数的入口和出口时完成，即使该过程或函数在某次调用中并不访问任何中间变量。尽管使用中间变量（与全局变量相比，涉及信息隐藏）在某些软件工程方面可能有好处，但请记住，访问中间对象是昂贵的。
- en: '**7.5.4 Allocating Storage for Dynamic Variables and Pointers**'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.5.4 动态变量和指针的存储分配**'
- en: Pointer access in an HLL provides another opportunity for optimization in your
    code. Pointers can be expensive to use but, under certain circumstances, they
    can actually make your programs more efficient by reducing displacement sizes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言中的指针访问提供了代码优化的另一个机会。指针的使用可能非常昂贵，但在某些情况下，它们实际上可以通过减少位移大小来提高程序的效率。
- en: 'A pointer is simply a memory variable whose value is the address of some other
    memory object (therefore, pointers are the same size as an address on the machine).
    Because most modern CPUs support indirection only via a machine register, indirectly
    accessing an object is typically a two-step process: first the code has to load
    the value of the pointer variable into a register, and then it has to refer (indirectly)
    to the object through that register.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 指针只是一个内存变量，其值是某个其他内存对象的地址（因此，指针的大小与机器上的地址相同）。因为大多数现代CPU只通过机器寄存器支持间接访问，所以间接访问一个对象通常是一个两步过程：首先，代码必须将指针变量的值加载到寄存器中，然后通过该寄存器间接引用对象。
- en: 'Consider the following C/C++ code fragment:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下C/C++代码片段：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the corresponding 80x86/HLA assembly code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的80x86/HLA汇编代码：
- en: '[PRE21]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Had `pi` been a regular variable rather than pointer object, this code could
    have dispensed with the `mov([ebx], eax);` instruction and simply moved `pi` directly
    into `eax`. Therefore, the use of this pointer variable has both increased the
    program’s size and reduced the execution speed by inserting an extra instruction
    into the code sequence that the compiler generates.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pi`是一个普通变量而不是指针对象，这段代码本可以省略`mov([ebx], eax);`指令，直接将`pi`移动到`eax`中。因此，使用这个指针变量既增加了程序的大小，又通过在编译器生成的代码序列中插入了额外的指令，降低了执行速度。
- en: 'However, if you indirectly refer to an object several times in close succession,
    the compiler may be able to reuse the pointer value it has loaded into the register,
    amortizing the cost of the extra instruction across several different instructions.
    Consider the following C/C++ code sequence:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你多次间接引用一个对象，编译器可能会重新利用它已加载到寄存器中的指针值，从而将额外指令的开销分摊到几条不同的指令上。考虑以下的C/C++代码序列：
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the corresponding 80x86/HLA code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的80x86/HLA代码：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code loads the actual pointer value into EBX only once. From that point
    forward, the code will simply use the pointer value contained in EBX to reference
    the object at which `pi` is pointing. Of course, any compiler that can do this
    optimization can probably eliminate five redundant memory loads and stores from
    this assembly language sequence, but let’s assume they’re not redundant for the
    time being. Because the code didn’t have to reload EBX with the value of `pi`
    every time it wanted to access the object at which `pi` points, there’s only one
    instruction of overhead (`mov(pi, ebx);`) amortized across six instructions. That’s
    not too bad at all.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仅在一次操作中将实际指针值加载到EBX寄存器。从那时起，代码将仅使用EBX中包含的指针值来引用`pi`所指向的对象。当然，任何能够进行这种优化的编译器可能会从这段汇编语言序列中去除五次冗余的内存加载和存储操作，但我们暂时假设它们并非冗余。因为代码在每次需要访问`pi`所指向的对象时无需重新加载EBX中的`pi`值，所以只有一条开销指令（`mov(pi,
    ebx);`）被分摊到六条指令中。这样看起来并不算太差。
- en: Indeed, you could make a good argument that this code is more optimal than accessing
    a local or global variable directly. An instruction of the form
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你完全可以提出一个很好的论点，认为这段代码比直接访问本地或全局变量更加优化。一条形式为
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: encodes a 0-bit displacement. Therefore, this move instruction is only 2 bytes
    long rather than 3, 5, or even 6 bytes long. If `pi` is a local variable, it’s
    quite possible that the original instruction that copies `pi` into EBX is only
    3 bytes long (a 2-byte opcode and a 1-byte displacement). Because instructions
    of the form `mov([ebx],eax);` are only 2 bytes long, it only takes three instructions
    to “break even” on the byte count using indirection rather than an 8-bit displacement.
    After the third instruction that references whatever `pi` points at, the code
    involving the pointer is actually shorter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的是一个0位偏移量。因此，这条移动指令只有2个字节长，而不是3、5甚至6个字节长。如果`pi`是一个局部变量，那么原始将`pi`复制到EBX的指令很可能只有3个字节长（2字节操作码和1字节偏移量）。因为形式为`mov([ebx],
    eax);`的指令只有2个字节长，所以使用间接寻址而不是8位偏移量时，只有三条指令“达到平衡”。在第三条引用`pi`指向的内容的指令之后，涉及指针的代码实际上变得更短了。
- en: You can even use indirection to provide efficient access to a block of global
    variables. As noted earlier, the compiler generally cannot determine the address
    of a global object while it’s compiling your program. Therefore, it has to assume
    the worst case and allow for the largest possible displacement/offset when generating
    machine code to access a global variable. Of course, you’ve just seen that you
    can reduce the size of the displacement value from 32 bits down to 0 bits by using
    a pointer to the object rather than accessing the object directly. Therefore,
    you could take the address of the global object (with the C/C++ `&` operator,
    for example) and then use indirection to access the variable. The problem with
    this approach is that it requires a register (a precious commodity on any processor,
    but especially on the 32-bit 80x86, which has only six general-purpose registers
    to utilize). If you access the same variable many times in rapid succession, this
    0-bit displacement trick can make your code more efficient. However, it’s somewhat
    rare to access the same variable repeatedly in a short sequence of code without
    also needing to access several other variables. This means the compiler may have
    to flush the pointer from the register and reload the pointer value later, reducing
    the efficiency of this approach. If you’re working on a RISC chip or x86-64 with
    many registers, you can probably employ this trick to your advantage. On a processor
    with a limited number of registers, though, you won’t be able to employ it as
    often.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用间接寻址来高效地访问一块全局变量。如前所述，编译器通常无法在编译程序时确定全局对象的地址。因此，它必须假设最坏的情况，并在生成机器代码以访问全局变量时允许最大的位移/偏移量。当然，你刚刚看到，通过使用指向对象的指针而不是直接访问对象，你可以将位移值的大小从32位减少到0位。因此，你可以获取全局对象的地址（例如，使用C/C++中的`&`运算符），然后使用间接寻址来访问变量。这种方法的问题是，它需要一个寄存器（寄存器在任何处理器中都是宝贵资源，尤其是在32位的80x86中，它只有六个通用寄存器可供使用）。如果你在快速连续的代码中多次访问同一变量，这个0位位移技巧可以提高代码效率。然而，在短序列代码中反复访问同一变量而不需要同时访问其他多个变量的情况相对较少。这意味着编译器可能需要将指针从寄存器中刷新出来，稍后重新加载指针值，从而降低这种方法的效率。如果你在RISC芯片或具有多个寄存器的x86-64处理器上工作，你可能能利用这个技巧来提高效率。然而，在寄存器数量有限的处理器上，你就无法频繁使用它了。
- en: '**7.5.5 Using Records/Structures to Reduce Instruction Offset Sizes**'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.5.5 使用记录/结构体来减少指令偏移量大小**'
- en: 'There’s also a trick you can use to access several variables with a single
    pointer: put all those variables into a structure and then use the structure’s
    address. By accessing the fields of the structure via the pointer, you can get
    away with using smaller instructions to access the objects. This works almost
    exactly as you’ve seen for activation records (indeed, activation records are,
    literally, records that the program references indirectly via the frame-pointer
    register). About the only difference between accessing objects indirectly in a
    user-defined record/structure and accessing objects in the activation record is
    that most compilers won’t let you refer to fields in a user structure/record using
    negative offsets. Therefore, you’re limited to about half the number of bytes
    that are normally accessible in an activation record. For example, on the 80x86
    you can access the object at offset 0 from a pointer using a 0-bit displacement
    and objects at offsets 1 through +127 using a single-byte displacement. Consider
    the following C/C++ example that uses this trick:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一个技巧，通过单一指针访问多个变量：将这些变量放入一个结构体中，然后使用结构体的地址。通过指针访问结构体的字段，你可以使用更小的指令来访问对象。这几乎与激活记录的方式完全相同（实际上，激活记录就是程序通过帧指针寄存器间接引用的记录）。在用户定义的记录/结构体中间接访问对象和在激活记录中访问对象之间的唯一区别是，大多数编译器不允许你使用负偏移量来引用用户结构体/记录中的字段。因此，你只能访问激活记录中通常可以访问的字节数量的一半。例如，在80x86架构中，你可以使用0位位移从指针访问偏移量为0的对象，使用单字节位移访问偏移量为1到+127的对象。考虑以下使用此技巧的C/C++示例：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A well-designed compiler will load the value of `pv` into a register exactly
    once for this code fragment. Because all the fields of the `vars` structure are
    within 127 bytes of the base address of the structure in memory, an 80x86 compiler
    can emit a sequence of instructions that require only 1-byte offsets, even though
    the `v` variable itself is a static/global object. Note, by the way, that the
    first field in the `vars` structure is special. Because this is at offset 0 in
    the structure, you can use a 0-bit displacement when accessing this field. Therefore,
    it’s a good idea to put your most-often-referenced field first in a structure
    if you’re going to refer to that structure indirectly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的编译器会在这段代码中将`pv`的值加载到寄存器中，只会加载一次。因为`vars`结构体的所有字段都位于结构体基地址内存的127字节以内，80x86编译器可以发出一系列仅需1字节偏移的指令，即使`v`变量本身是静态/全局对象。顺便提一下，`vars`结构体中的第一个字段是特殊的。由于这个字段位于结构体的0偏移位置，因此在访问这个字段时，你可以使用0位偏移。因此，如果你打算间接访问某个结构体，最好将最常访问的字段放在结构体的第一个位置。
- en: Using indirection in your code does come at a cost. On a limited-register CPU
    such as the 32-bit 80x86, using this approach will tie up a register for a while,
    and that may effectively cause the compiler to generate worse code. If the compiler
    must constantly reload the register with the address of the structure in memory,
    the savings from this technique evaporate rather quickly. Tricks such as this
    one vary in effectiveness across different processors (and different compilers
    for the same processor), so be sure to look at the code your compiler generates
    to verify that a trick is actually saving rather than costing you something.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用间接寻址确实是有代价的。对于像32位80x86这样的有限寄存器CPU，使用这种方法会占用一个寄存器一段时间，这可能会导致编译器生成较差的代码。如果编译器必须不断地重新加载寄存器，以获取结构体在内存中的地址，那么这种技巧带来的节省就会很快消失。此类技巧在不同处理器（以及同一处理器的不同编译器）上效果不同，因此一定要查看编译器生成的代码，确认一个技巧是否真正节省了资源，而不是让你付出了更多的代价。
- en: '**7.5.6 Storing Variables in Machine Registers**'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**7.5.6 将变量存储在机器寄存器中**'
- en: 'While we’re on the subject of registers, it’s worthwhile to point out one other
    0-bit displacement way to access variables in your programs: by keeping them in
    machine registers. Machine registers are always the most efficient place to store
    variables and parameters. Unfortunately, only in assembly language and, to a limited
    extent, C/C++, do you have any control over whether the compiler should keep a
    variable or parameter in a register. In some respects, this is not bad. Good compilers
    do a much better job of register allocation than the casual programmer does. However,
    an expert programmer can do a better job of register allocation than a compiler,
    because the expert programmer understands the data the program will be processing
    and the frequency of access to a particular memory location. (And of course, the
    expert programmer can first look at what the compiler is doing, whereas the compiler
    doesn’t have the benefit of seeing what the programmer has done.)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 说到寄存器，值得指出的是，另一种通过0位偏移来访问程序中变量的方式：将它们保存在机器寄存器中。机器寄存器始终是存储变量和参数的最有效地方。不幸的是，只有在汇编语言中，以及在C/C++中有限地，你才可以控制编译器是否将变量或参数保存在寄存器中。在某些方面，这并不坏。优秀的编译器在寄存器分配方面比随便的程序员做得更好。然而，专家程序员可以比编译器做得更好，因为专家程序员理解程序将要处理的数据以及对特定内存位置的访问频率。（当然，专家程序员可以先查看编译器的做法，而编译器无法看到程序员的处理方式。）
- en: Some languages, such as Delphi, provide limited support for programmer-directed
    register allocation. In particular, the Delphi compiler allows you to tell it
    to pass the first three (ordinal) parameters for a function or procedure in the
    EAX, EDX, and ECX registers. This option is known as the *fastcall calling convention*,
    and several C/C++ compilers support it as well.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如Delphi，提供了对程序员控制寄存器分配的有限支持。特别是，Delphi编译器允许你指示它将函数或过程的前三个（顺序）参数传递到EAX、EDX和ECX寄存器中。这个选项被称为*fastcall调用约定*，多个C/C++编译器也支持它。
- en: In Delphi and certain other languages, opting for the fastcall parameter passing
    convention is the only control you get. The C/C++ language, however, provides
    the `register` keyword, a storage specifier (much like the `const`, `static`,
    and `auto` keywords) that tells the compiler that the programmer expects to use
    the variable frequently so the compiler should attempt to keep it in a register.
    Note that the compiler can also choose to ignore the `register` keyword (in which
    case it reserves variable storage using automatic allocation). Many compilers
    ignore the `register` keyword altogether because the compiler’s authors assume,
    somewhat arrogantly, that they can do a better job of register allocation than
    any programmer. Of course, on some register-starved machines such as the 32-bit
    80x86, there are so few registers to work with that it might not even be possible
    to allocate a variable to a register throughout the execution of some function.
    Nevertheless, some compilers do respect the programmer’s wishes and *will* allocate
    a few variables in registers if you request that they do so.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Delphi和某些其他语言中，选择fastcall参数传递约定是你唯一能控制的方式。然而，C/C++语言提供了`register`关键字，它是一个存储说明符（类似于`const`、`static`和`auto`关键字），告诉编译器程序员期望频繁使用该变量，因此编译器应尝试将其保留在寄存器中。请注意，编译器也可以选择忽略`register`关键字（此时，它会使用自动分配来保留变量存储）。许多编译器完全忽略`register`关键字，因为编译器的作者有点傲慢地认为，他们可以比任何程序员做得更好，进行寄存器分配。当然，在一些寄存器稀缺的机器上，比如32位的80x86，寄存器数量极少，可能甚至无法在某些函数的执行过程中将一个变量分配到寄存器中。然而，一些编译器确实会尊重程序员的要求，并*确实*会将一些变量分配到寄存器中，如果你要求它们这么做。
- en: Most RISC compilers reserve several registers for passing parameters and several
    registers for local variables. Therefore, it’s a good idea (if possible) to place
    the parameters you access most frequently first in the parameter declaration because
    they’re probably the ones the compiler would allocate in a register.^([9](footnotes.xhtml#ch7fn9))
    The same is true for local variable declarations. Always declare frequently used
    local variables first, because many compilers may allocate those (ordinal) variables
    in registers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数RISC编译器会为传递参数保留几个寄存器，为局部变量保留几个寄存器。因此，最好（如果可能的话）将你最常访问的参数放在参数声明的最前面，因为它们很可能是编译器分配到寄存器中的参数。^([9](footnotes.xhtml#ch7fn9))
    局部变量声明也是如此。总是先声明经常使用的局部变量，因为许多编译器可能会将这些（顺序）变量分配到寄存器中。
- en: One problem with compiler register allocation is that it is static. That is,
    the compiler determines which variables to place in registers based on an analysis
    of your source code during compilation, not during runtime. Compilers often make
    assumptions (which are usually correct) like “this function references variable
    `xyz` far more often than any other variable, so it’s a good candidate for a register
    variable.” Indeed, by placing the variable in a register, the compiler will certainly
    reduce the size of the program. However, it could also be the case that all those
    references to `xyz` sit in code that rarely, if ever, executes. Although the compiler
    might save some space (by emitting smaller instructions to access registers rather
    than memory), the code won’t run appreciably faster. After all, if the code rarely
    or never executes, then making that code run faster does not contribute much to
    the program’s execution time. On the other hand, it’s also quite possible to bury
    a single reference to some variable in a deeply nested loop that executes many
    times. With only one reference in the entire function, the compiler’s optimizer
    may overlook the fact that the executing program references the variable frequently.
    Although compilers have gotten smarter about handling variables inside loops,
    the fact is, no compiler can predict how many times an arbitrary loop will execute
    at runtime. Human beings are much better at predicting this sort of behavior (or,
    at least, measuring it with a profiler) and thus are best positioned to make good
    decisions about variable allocation in registers.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器寄存器分配的一个问题是它是静态的。也就是说，编译器在编译过程中根据对源代码的分析来决定将哪些变量放入寄存器，而不是在运行时决定。编译器通常会做出一些假设（这些假设通常是正确的），比如“这个函数比任何其他变量更频繁地引用变量`xyz`，因此它是寄存器变量的良好候选。”的确，通过将变量放入寄存器，编译器肯定会减少程序的大小。然而，也有可能是所有这些对`xyz`的引用出现在一些很少执行甚至从不执行的代码中。虽然编译器可能通过发出较小的指令来访问寄存器而不是内存，从而节省一些空间，但代码不会显著变得更快。毕竟，如果代码很少或从不执行，那么让这段代码更快运行对程序的执行时间没有太大贡献。另一方面，也很有可能将对某个变量的单次引用埋藏在一个深度嵌套的循环中，而这个循环会执行多次。整个函数中只有一次引用时，编译器的优化器可能会忽视程序执行过程中频繁引用该变量的事实。虽然编译器在处理循环中的变量时已经变得更加智能，但事实上，没有任何编译器能够预测任意循环在运行时会执行多少次。人类在预测这种行为（或者至少通过分析工具进行测量）方面要比编译器强得多，因此在寄存器中进行变量分配时，人类通常能够做出更好的决策。
- en: '**7.6 Variable Alignment in Memory**'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**7.6 内存中变量的对齐**'
- en: On many processors (particularly RISC), there is another efficiency concern
    you must take into consideration. Many modern processors will not let you access
    data at an arbitrary address in memory. Instead, all accesses must take place
    on some native boundary (usually 4 bytes) that the CPU supports.^([10](footnotes.xhtml#ch7fn10))
    Even when a CISC processor allows memory accesses at arbitrary byte boundaries,
    it’s often more efficient to access primitive objects (bytes, words, and double
    words) on a boundary that is a multiple of the object’s size (see [Figure 7-8](ch07.xhtml#ch7fig8)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多处理器（特别是RISC处理器）中，你必须考虑另一个效率问题。许多现代处理器不允许你在内存中的任意地址访问数据。相反，所有访问都必须在CPU支持的某个原生边界上进行（通常是4字节）。^([10](footnotes.xhtml#ch7fn10))
    即使CISC处理器允许在任意字节边界上访问内存，通常将原始对象（字节、字和双字）在对象大小的倍数边界上进行访问，效率更高（见[图 7-8](ch07.xhtml#ch7fig8)）。
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig08.jpg)'
- en: '*Figure 7-8: Variable alignment in memory*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：内存中的变量对齐*'
- en: If the CPU supports unaligned accesses—that is, if the CPU allows you to access
    a memory object on a boundary that is not a multiple of the object’s primitive
    size—then you should be able to pack the variables into the activation record.
    This way, you would obtain the maximum number of variables having a short offset.
    However, because unaligned accesses are sometimes slower than aligned accesses,
    many optimizing compilers insert *padding bytes* into the activation record in
    order to ensure that all variables are aligned on a reasonable boundary for their
    native size (see [Figure 7-9](ch07.xhtml#ch7fig9)). This trades off slightly better
    performance for a slightly larger program.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CPU支持不对齐访问——也就是说，如果CPU允许你在不是对象原始大小的倍数的边界上访问内存对象——那么你应该能够将变量打包到激活记录中。这样，你就可以获得最大数量的变量，并且这些变量的偏移量较小。然而，由于不对齐访问有时比对齐访问更慢，许多优化编译器会在激活记录中插入*填充字节*，以确保所有变量都按照合理的边界对齐，以适应它们的原生大小（见[图
    7-9](ch07.xhtml#ch7fig9)）。这种做法以稍微更大的程序换取了略微更好的性能。
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig09.jpg)'
- en: '*Figure 7-9: Padding bytes in an activation record*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：激活记录中的填充字节*'
- en: 'However, if you put all your double-word declarations first, your word declarations
    second, your byte declarations third, and your array/structure declarations last,
    you can improve both the speed and size of your code. The compiler usually ensures
    that the first local variable you declare appears at a reasonable boundary (typically
    a double-word boundary). By declaring all your double-word variables first, you
    ensure that they all appear at an address that is a multiple of 4 (because compilers
    usually allocate adjacent variables in your declarations in adjacent locations
    in memory). The first word-sized object you declare will also appear at an address
    that is a multiple of 4—and that means its address is also a multiple of 2 (which
    is best for word accesses). By declaring all your word variables together, you
    ensure that each one appears at an address that is a multiple of 2\. On processors
    that allow byte access to memory, the placement of the byte variables (with respect
    to efficiently accessing the byte data) is irrelevant. By declaring all your local
    byte variables last in a procedure or function, you generally ensure that such
    declarations do not impact the performance of the double-word and word variables
    you also use in the function. [Figure 7-10](ch07.xhtml#ch7fig10) shows what a
    typical activation record will look like if you declare your variables as in the
    following function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将所有的双字声明放在前面，字声明放在第二，字节声明放在第三，数组/结构声明放在最后，你可以提高代码的速度和大小。编译器通常会确保你声明的第一个局部变量出现在一个合理的边界上（通常是双字边界）。通过先声明所有的双字变量，你可以确保它们都出现在一个地址，该地址是
    4 的倍数（因为编译器通常将相邻的变量按声明顺序分配到内存中的相邻位置）。你声明的第一个字大小的对象也会出现在一个 4 的倍数地址上——这意味着它的地址也是
    2 的倍数（这对于字访问是最佳的）。通过将所有的字变量一起声明，你可以确保每个变量都出现在一个 2 的倍数地址上。在允许字节访问内存的处理器上，字节变量的放置（相对于高效访问字节数据）并不重要。通过将所有的局部字节变量放在过程或函数的最后，你通常可以确保这些声明不会影响你在函数中使用的双字和字变量的性能。[图
    7-10](ch07.xhtml#ch7fig10)展示了如果你按照以下函数中的方式声明变量，典型的激活记录会是什么样子：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig10.jpg)'
- en: '*Figure 7-10: Aligned variables in an activation record (32-bit 80x86)*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-10：激活记录中的对齐变量（32位 80x86）*'
- en: Note how all the double-word variables (`d1`, `d2`, and `d3`) begin at addresses
    that are multiples of 4 (–4, –8, and –12). Also, notice how all the word-sized
    variables (`w1` and `w2`) begin at addresses that are multiples of 2 (–14 and
    –16). The byte variables (`b1`, `b2`, and `b3`) begin at arbitrary addresses in
    memory (both even and odd addresses).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有的双字变量（`d1`、`d2` 和 `d3`）的地址都是 4 的倍数（–4、–8 和 –12）。同时，注意到所有的字大小变量（`w1` 和
    `w2`）的地址是 2 的倍数（–14 和 –16）。字节变量（`b1`、`b2` 和 `b3`）的地址是内存中的任意地址（包括偶数和奇数地址）。
- en: 'Now consider the following function, which has arbitrary (unordered) variable
    declarations, and the corresponding activation record shown in [Figure 7-11](ch07.xhtml#ch7fig11):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下函数，它具有任意（无序的）变量声明，以及在[图 7-11](ch07.xhtml#ch7fig11)中显示的相应激活记录：
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig11.jpg)'
- en: '*Figure 7-11: Unaligned variables in an activation record (32-bit 80x86)*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-11：激活记录中的未对齐变量（32位 80x86）*'
- en: As you can see, every variable except the byte variables appears at an address
    that is inappropriate for the object. On processors that allow memory accesses
    at arbitrary addresses, it may take more time to access a variable that is not
    aligned on an appropriate address boundary.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了字节变量外，其他所有变量都出现在不适合该对象的地址上。在允许在任意地址访问内存的处理器上，访问未对齐到合适地址边界的变量可能需要更长的时间。
- en: Some processors don’t allow a program to access an object at an unaligned address.
    Most RISC processors, for example, can’t access memory except at 32-bit address
    boundaries. To access a short or byte value, some RISC processors require the
    software to read a 32-bit value and extract the 16-bit or 8-bit value (that is,
    the CPU forces the software to treat bytes and words as packed data). The extra
    instructions and memory accesses needed to pack and unpack this data reduce the
    speed of memory access by a considerable amount (two or more instructions—usually
    more—may be needed to fetch a byte or word from memory). Writing data to memory
    is even worse because the CPU must first fetch the data from memory, merge the
    new data with the old data, and then write the result back to memory. Therefore,
    most RISC compilers won’t create an activation record similar to the one in [Figure
    7-11](ch07.xhtml#ch7fig11). Instead, they’ll add padding bytes so that every memory
    object begins at an address boundary that is a multiple of 4 bytes (see [Figure
    7-12](ch07.xhtml#ch7fig12)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: RISC compilers force aligned access by adding padding bytes.*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Notice in [Figure 7-12](ch07.xhtml#ch7fig12) that all of the variables are at
    addresses that are multiples of 32 bits. Therefore, a RISC processor has no problems
    accessing any of these variables. The cost, of course, is that the activation
    record is quite a bit larger (the local variables consume 32 bytes rather than
    19 bytes).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Although the example in [Figure 7-12](ch07.xhtml#ch7fig12) is typical for 32-bit
    RISC-based compilers, that’s not to suggest that compilers for CISC CPUs don’t
    do this as well. Many compilers for the 80x86, for example, also build this activation
    record in order to improve the performance of the code the compiler generates.
    Although declaring your variables in a misaligned fashion may not slow down your
    code on a CISC CPU, it may use additional memory.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you work in assembly language, it’s generally up to you to declare
    your variables in a manner that is appropriate or efficient for your particular
    processor. In HLA (on the 80x86), for example, the following two procedure declarations
    result in the activation records shown in [Figures 7-10](ch07.xhtml#ch7fig10),
    [7-11](ch07.xhtml#ch7fig11), and [7-12](ch07.xhtml#ch7fig12).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: HLA procedures someFunction and someFunction3 will produce the fastest-running
    code on any 80x86 processor because all variables are aligned on an appropriate
    boundary; HLA procedures someFunction and someFunction2 will produce the most
    compact activation records on an 80x86 CPU, because there is no padding between
    variables in the activation record. If you’re working in assembly language on
    a RISC CPU, you’ll probably want to choose the equivalent of someFunction or someFunction3
    to make it easier to access the variables in memory.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**7.6.1 Records and Alignment**'
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Records/structures in HLLs also have alignment issues that should concern you.
    Recently, CPU manufacturers have been promoting *application binary interface
    (ABI)* standards to promote interoperability between different programming languages
    and their implementations. Although not all languages and compilers adhere to
    these suggestions, many of the newer compilers do. Among other things, these ABI
    specifications describe how the compilers should organize fields within a record
    or structure object in memory. Although the rules vary by CPU, one that applies
    to most ABIs is that a compiler should align a record/structure field at an offset
    that is a multiple of the object’s size. If two adjacent fields in the record
    or structure have different sizes, and the placement of the first field in the
    structure would cause the second field to appear at an offset that is not a multiple
    of that second field’s native size, then the compiler will insert some padding
    bytes to push the second field to a higher offset that is appropriate for that
    second object’s size.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言（HLL）中的记录/结构也存在对齐问题，这些问题是你应该关注的。最近，CPU 制造商提倡 *应用二进制接口（ABI）* 标准，以促进不同编程语言及其实现之间的互操作性。虽然并非所有语言和编译器都遵循这些建议，但许多新型编译器是遵循的。其中，ABI
    规范描述了编译器应如何在内存中组织记录或结构对象中的字段。虽然规则因 CPU 而异，但适用于大多数 ABI 的一条规则是：编译器应该将记录/结构字段对齐到一个是该对象大小倍数的偏移量。如果记录或结构中的两个相邻字段具有不同的大小，并且第一个字段的放置会导致第二个字段出现在一个不是该第二个字段原生大小倍数的偏移量位置，那么编译器将插入一些填充字节，将第二个字段推到一个适合该第二个对象大小的更高偏移量。
- en: In actual practice, ABIs for different CPUs and OSes have minor differences
    based on the CPUs’ ability to access objects at different addresses in memory.
    Intel, for example, suggests that compiler writers align bytes at any offset,
    words at even offsets, and everything else at offsets that are a multiple of 4\.
    Some ABIs recommend placing 64-bit objects at 8-byte boundaries within a record.
    The x86-64 SSE and AVX instructions require 16- and 32-byte alignment for 128-bit
    and 256-bit data values. Some CPUs, which have a difficult time accessing objects
    smaller than 32 bits, may suggest a minimum alignment of 32 bits for all objects
    in a record/structure. The rules vary depending on the CPU and whether the manufacturer
    wants to promote faster-executing code (the usual case) or smaller data structures.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，不同 CPU 和操作系统的 ABI 存在细微的差异，这些差异主要取决于 CPU 访问内存中不同地址的对象的能力。例如，英特尔建议编译器将字节对齐到任何偏移量，将字对齐到偶数偏移量，并将其他所有内容对齐到
    4 的倍数的偏移量。一些 ABI 建议将 64 位对象放置在记录中的 8 字节边界上。x86-64 SSE 和 AVX 指令要求对 128 位和 256 位数据值进行
    16 字节和 32 字节对齐。一些 CPU 在访问小于 32 位的对象时会遇到困难，可能会建议对记录/结构中的所有对象使用最小 32 位的对齐。规则会根据
    CPU 的不同以及制造商是希望优化代码执行速度（通常情况）还是减小数据结构的大小而有所不同。
- en: If you are writing code for a single CPU (such as an Intel-based PC) with a
    single compiler, learn that compiler’s rules for padding fields and adjust your
    declarations for maximum performance and minimal waste. However, if you ever need
    to compile your code using several different compilers, particularly compilers
    for several different CPUs, following one set of rules will work fine on one machine
    and produce less efficient code on several others. Fortunately, there are some
    rules that can help reduce the inefficiencies created by recompiling for a different
    ABI.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为单一 CPU（例如基于英特尔的 PC）编写代码，并使用单一编译器，请了解该编译器的填充字段规则，并根据最大性能和最小浪费调整声明。然而，如果你需要使用多个不同的编译器进行编译，特别是针对不同
    CPU 的编译器，遵循一套规则可能在一台机器上工作得很好，但在其他几台机器上却会生成低效的代码。幸运的是，有一些规则可以帮助减少由于重新编译不同 ABI 所产生的低效问题。
- en: 'From a performance/memory usage standpoint, the best solution is the same rule
    we saw earlier for activation records: when declaring fields in a record, group
    all like-sized objects together and put all the larger (scalar) objects first
    and the smaller objects last in the record/structure. This scheme produces the
    least amount of waste (padding bytes) and provides the highest performance across
    most of the existing ABIs. The only drawback to this approach is that you have
    to organize the fields by their native size rather than by their logical relationship
    to one another. However, because all fields of a record/structure are logically
    related insofar as they are all members of that same record/structure, this problem
    isn’t as bad as employing this organization for all of a particular function’s
    local variables.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能/内存使用的角度来看，最佳解决方案与我们之前看到的激活记录规则相同：在声明记录字段时，将所有相同大小的对象放在一起，并将所有较大的（标量）对象放在前面，较小的对象放在记录/结构体的最后。这个方案产生的浪费（填充字节）最少，并且在大多数现有的
    ABI 中提供了最高的性能。唯一的缺点是你必须根据字段的原生大小而非它们之间的逻辑关系来组织字段。然而，由于记录/结构体的所有字段在逻辑上都与该记录/结构体相关联，因此这个问题并不像为某个特定函数的所有局部变量采用这种组织方式那么严重。
- en: 'Many programmers try to add padding fields themselves to a structure. For example,
    the following type of code is common in the Linux kernel and other bits and pieces
    of overly hacked software:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员尝试自己为结构体添加填充字段。例如，以下类型的代码在 Linux 内核及其他被过度修改的软件中非常常见：
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `padding0` and `padding1` fields in this structure were added to manually
    align the `dwordValue` and `dwordValue2` fields at offsets that are even multiples
    of 4.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体中的`padding0`和`padding1`字段是为了手动对齐`dwordValue`和`dwordValue2`字段，使它们的偏移量成为4的偶数倍。
- en: While this padding is not unreasonable, if you’re using a compiler that doesn’t
    automatically align the fields, remember that an attempt to compile this code
    on a different machine can produce unexpected results. For example, if a compiler
    aligns all fields on a 32-bit boundary, regardless of size, then this structure
    declaration will consume two extra double words to hold the two `paddingX` arrays.
    This winds up wasting space for no good reason. Keep this fact in mind if you
    decide to manually add the padding fields.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种填充并不不合理，但如果你使用的编译器没有自动对齐字段，请记住，在不同的机器上尝试编译这段代码可能会产生意外的结果。例如，如果一个编译器将所有字段对齐到32位边界，不管字段的大小，那么这个结构体声明将需要两个额外的双字来存放两个`paddingX`数组。这样就会无缘无故浪费空间。如果你决定手动添加填充字段，请记住这一点。
- en: Many compilers that automatically align fields in a structure provide an option
    to turn off this feature. This is particularly true for compilers generating code
    for CPUs where the alignment is optional and the compiler does it only to achieve
    a slight performance boost. If you’re going to manually add padding fields to
    your record/structure, you need to specify this option so that the compiler doesn’t
    realign the fields after you’ve manually aligned them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自动对齐结构体字段的编译器提供关闭此功能的选项。对于生成 CPU 代码的编译器尤其如此，其中字段对齐是可选的，编译器只会在轻微提升性能的情况下进行对齐。如果你打算手动为记录/结构体添加填充字段，你需要指定这个选项，以防编译器在你手动对齐后重新对齐字段。
- en: In theory, a compiler is free to rearrange the offsets of local variables within
    an activation record. However, it would be extremely rare for a compiler to rearrange
    the fields of a user-defined record or structure. Too many external programs and
    data structures depend on the fields of a record appearing in the same order as
    they are declared. This is particularly true when passing record/structure data
    between code written in two separate languages (for example, when calling a function
    written in assembly language) or when dumping record data directly to a disk file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，编译器可以自由地重新排列激活记录中局部变量的偏移量。然而，编译器重新排列用户定义的记录或结构体的字段是极为罕见的。太多外部程序和数据结构依赖于记录的字段按声明的顺序出现。尤其是在两个不同语言编写的代码之间传递记录/结构体数据时（例如，在调用汇编语言编写的函数时）或直接将记录数据转储到磁盘文件时，情况尤为如此。
- en: 'In assembly language, the amount of effort needed to align fields varies from
    pure manual labor to a rich set of features capable of automatically handling
    almost any ABI. Some (low-end) assemblers don’t even provide record or structure
    data types. In such systems, the assembly programmer has to manually specify the
    offsets into a record structure (typically by declaring, as constants, the numeric
    offsets into the structure). Other assemblers (for example, NASM) provide macros
    that automatically generate the equates for you. In these systems, the programmer
    has to manually provide padding fields to align certain fields on a given boundary.
    Some assemblers, such as MASM, provide simple alignment facilities. You may specify
    the value `1`, `2`, or `4` when declaring a `struct` in MASM and the assembler
    will align all fields on either the alignment value you specify or at an offset
    that is a multiple of the object’s size, whichever is smaller, by automatically
    adding padding bytes to the structure. Also, note that MASM adds a sufficient
    number of padding bytes to the end of the structure so that the whole structure’s
    length is a multiple of the alignment size. Consider the following `struct` declaration
    in MASM:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, MASM will add an extra byte of padding to the end of the structure
    so that its length is a multiple of 2 bytes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM also lets you control the alignment of individual fields within a structure
    by using the `align` directive. The following structure declaration is equivalent
    to the current example (note the absence of the alignment value operand in the
    `struct` operand field):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The default field alignment for MASM structures is unaligned. That is, a field
    begins at the next available offset within the structure, regardless of the field’s
    (and the previous field’s) size.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'The High-Level Assembly (HLA) language probably provides the greatest control
    (both automatic and manual) over record field alignment. As with MASM, the default
    record alignment is unaligned. Also as with MASM, you can use HLA’s `align` directive
    to manually align fields in an HLA record. The following is the HLA version of
    the previous MASM example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'HLA also lets you specify an automatic alignment for all fields in a record.
    For example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a subtle difference between this HLA record and the earlier MASM structure
    (with automatic alignment). Remember, when you specify a directive of the form
    `Student struct 2`, MASM aligns all fields on a boundary that is a multiple of
    2 or a multiple of the object’s size, *whichever is smaller*. HLA, on the other
    hand, will always align all fields on a 2-byte boundary using this declaration,
    even if the field is a byte.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to force field alignment to a minimum size is a nice feature if
    you’re working with data structures generated on a different machine (or compiler)
    that forces this kind of alignment. However, this type of alignment can unnecessarily
    waste space in a record for certain declarations if you only want the fields to
    be aligned on their natural boundaries (which is what MASM does). Fortunately,
    HLA provides another syntax for record declarations that lets you specify both
    the maximum and minimum alignment that HLA will apply to a field:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `maxAlign` item specifies the largest alignment that HLA will use within
    the record. HLA will align any object whose native size is larger than `maxAlign`
    on a boundary of `maxAlign` bytes. Similarly, HLA will align any object whose
    size is smaller than `minAlign` on a boundary of at least `minAlign` bytes. HLA
    will align objects whose native size is between `minAlign` and `maxAlign` on a
    boundary that is a multiple of that object’s size. The following HLA and MASM
    record/structure declarations are equivalent:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the MASM code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s the HLA code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although few HLLs provide facilities within the language’s design to control
    the alignment of fields within records (or other data structures), many compilers
    provide extensions to those languages, in the form of compiler pragmas, that let
    programmers specify default variable and field alignment. Because few languages
    have standards for this, you’ll have to check your particular compiler’s reference
    manual (note that C++11 is one of the few languages that provides alignment support).
    Although such extensions are nonstandard, they are often quite useful, especially
    when you’re linking code compiled by different languages or trying to squeeze
    the last bit of performance out of a system.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**7.7 For More Information**'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Aho, Alfred V., Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. *Compilers:
    Principles, Techniques, and Tools*. 2nd ed. Essex, UK: Pearson Education Limited,
    1986.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Barrett, William, and John Couch. *Compiler Construction: Theory and Practice*.
    Chicago: SRA, 1986.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Dershem, Herbert, and Michael Jipping. *Programming Languages, Structures and
    Models*. Belmont, CA: Wadsworth, 1990.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Fraser, Christopher, and David Hansen. *A Retargetable C Compiler: Design and
    Implementation*. Boston: Addison-Wesley Professional, 1995.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Ghezzi, Carlo, and Jehdi Jazayeri. *Programming Language Concepts*. 3rd ed.
    New York: Wiley, 2008.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Hoxey, Steve, Faraydon Karim, Bill Hay, and Hank Warren, eds. *The PowerPC
    Compiler Writer’s Guide*. Palo Alto, CA: Warthman Associates for IBM, 1996.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated
    November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Ledgard, Henry, and Michael Marcotty. *The Programming Language Landscape*.
    Chicago: SRA, 1986.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ledgard, Henry, 和 Michael Marcotty. *The Programming Language Landscape*. 芝加哥:
    SRA, 1986.'
- en: 'Louden, Kenneth C. *Compiler Construction: Principles and Practice*. Boston:
    Cengage, 1997.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'Louden, Kenneth C. *Compiler Construction: Principles and Practice*. 波士顿: Cengage,
    1997.'
- en: 'Louden, Kenneth C., and Kenneth A. Lambert. *Programming Languages: Principles
    and Practice*. 3rd ed. Boston: Course Technology, 2012.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'Louden, Kenneth C., 和 Kenneth A. Lambert. *Programming Languages: Principles
    and Practice*. 第3版. 波士顿: Course Technology, 2012.'
- en: 'Parsons, Thomas W. *Introduction to Compiler Construction*. New York: W. H.
    Freeman, 1992.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'Parsons, Thomas W. *Introduction to Compiler Construction*. 纽约: W. H. Freeman,
    1992.'
- en: 'Pratt, Terrence W., and Marvin V. Zelkowitz. *Programming Languages, Design
    and Implementation*. 4th ed. Upper Saddle River, NJ: Prentice Hall, 2001.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pratt, Terrence W., 和 Marvin V. Zelkowitz. *Programming Languages, Design and
    Implementation*. 第4版. Upper Saddle River, NJ: Prentice Hall, 2001.'
- en: 'Sebesta, Robert. *Concepts of Programming Languages*. 11th ed. Boston: Pearson,
    2016.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'Sebesta, Robert. *Concepts of Programming Languages*. 第11版. 波士顿: Pearson, 2016.'
