<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="3" id="Page_3"/>1</span><br/>
<span class="ChapterTitle">Hello World</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll create and execute your first program, “Hello World.” This is about the simplest program you can make and the first program in almost all C books. But you’ll go beyond just creating it: you’ll learn what’s actually going on behind the scenes during its creation.</p>
<p>The tools you’ll use are designed to make things quick and easy, which is good for regular programming but can be bad for embedded programming. The compiler, GCC, is actually a wrapper that runs a whole bunch of other tools. We’ll look at what each tool does to get your program from code to execution. In the process, you’ll discover that the GCC optimizer has a surprise for us. Although our program is very simple, the optimizer will decide to rewrite part of it to make it more efficient—<em>and it won’t tell us about the rewrite!</em> In fact, we would never know about it if we didn’t look under the hood to see what’s going on. (I won’t tell you what it will do to us; you’ll have to read the rest of the chapter to find that out.)</p>
<h2 id="h1-501621c01-0001"><span epub:type="pagebreak" title="4" id="Page_4"/>Installing GCC</h2>
<p class="BodyFirst">In order to run the program in this chapter, you’ll need to download and install the GNU C compiler (GCC) on your system, along with related tools. The instructions for doing so vary based on your operating system.</p>
<p>On Windows, install Minimalist GNU for Windows (MinGW), which can be found at <a href="http://www.mingw.org" class="LinkURL">http://www.mingw.org</a>. See <a href="https://nostarch.com/bare-metal-c" class="LinkURL">https://nostarch.com/bare-metal-c</a> for detailed instructions.</p>
<p>On macOS, the GCC compiler is part of the developer packages that can be accessed with the following command:</p>
<pre><code>$ <b>xcode-select --install</b></code></pre>
<p>Select the <b>Command Line Tools</b> option for installation.</p>
<p>Linux installation instructions depend on which distribution you are using. For Debian systems such as Ubuntu and Linux Mint, use the following commands:</p>
<pre><code>$ <b>sudo apt-get install build-essential</b>
$ <b>sudo apt-get install manpages-dev</b></code></pre>
<p>For Red Hat–based systems (such as Fedora or CentOS), use the following command:</p>
<pre><code>$ <b>dnf groupinstall "Development Tools"</b></code></pre>
<p>For any other Linux-based system, use the package manager that came with the system or search online to find the command needed for installation.</p>
<p>After installing the software, open a terminal window and issue the command <code class="bold">gcc</code>. If you get a “no input files” error, you’ve installed successfully.</p>
<pre><code>$ <b>gcc</b>
gcc: fatal error: no input files
compilation terminated.</code></pre>
<h2 id="h1-501621c01-0002">Downloading System Workbench for STM32</h2>
<p class="BodyFirst">System Workbench for STM32 is an IDE we’ll use to write C programs for our embedded devices. We won’t use it until <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, but the download will take some time, so I recommend you start it now. By the time you finish reading this chapter, the download should be complete.</p>
<p>Go to <a href="http://openstm32.org/HomePage" class="LinkURL">http://openstm32.org/HomePage</a>, locate the link for System Workbench for STM32, and click it. Register (it’s free), or log in if you have an account, and then follow the links to the installation instructions. Install the IDE from the installer and not from Eclipse. When the download starts, return here and continue reading.</p>
<p><span epub:type="pagebreak" title="5" id="Page_5"/>Tools and installation procedures may change over time. If you encounter any issues, visit <a href="https://nostarch.com/bare-metal-c" class="LinkURL">https://nostarch.com/bare-metal-c</a> to check for updated instructions.</p>
<h2 id="h1-501621c01-0003">Our First Program</h2>
<p class="BodyFirst">Our first program is called <em>hello.c</em>. Begin by creating a directory to hold this program and jump into it. Navigate to the root directory of your workspace, open a command line window, and enter these commands:</p>
<pre><code>$ <b>mkdir hello</b>
$ <b>cd hello</b></code></pre>
<p>Using a text editor such as Notepad, Vim, or Gedit, create a file called <em>hello.c</em> and enter the following code:</p>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    printf("Hello World!\n");
    return (0);
}</code></pre>
<p>We’ll walk through this program in detail in the following sections. First, though, we have to run it.</p>
<h3 id="h2-501621c01-0001">Compiling the Program</h3>
<p class="BodyFirst">The file you just created is known as a <em>source file</em>, and it contains code in human-readable format. (Yes, really; this is supposed to be human readable.) It’s the source of all the other files we are going to produce. The content of the file is called <em>source code</em>. The computer does not understand source code; it only understands <em>machine code</em>, a set of instructions in a numeric format. So, we need to transform our source code into machine code, a process called <em>compiling</em>.</p>
<p>To do this, we execute the following compiler command on macOS or Linux:</p>
<pre><code>$ <b>gcc -o hello hello.c</b></code></pre>
<p>On Windows, we execute the following command:</p>
<pre><code>$ <b>gcc -o hello.exe hello.c</b></code></pre>
<p>If you get no output, just a command prompt, the command was successful. Otherwise, you’ll get error messages.</p>
<p><span epub:type="pagebreak" title="6" id="Page_6"/>This command tells the program <em>GCC</em> to <em>compile</em> and <em>link</em> the program, putting the output in a file called <em>hello</em> on macOS and Linux or <em>hello.exe</em> on Windows. We can now run our program using the following command on macOS or Linux:</p>
<pre><code>$ <b>./hello</b>
Hello World!</code></pre>
<p>On Windows, run the following:</p>
<pre><code>$ <b>hello</b>
Hello World!</code></pre>
<h3 id="h2-501621c01-0002">Making Mistakes</h3>
<p class="BodyFirst">Let’s introduce a mistake and see what happens. Change the second line so that it looks like this:</p>
<pre><code><b>intxxx main()</b></code></pre>
<p>Now let’s try to compile the program:</p>
<pre><code>$ <b>gcc -o hello hello.c</b>
hello.c:2:1: error: unknown type name 'intxxx'
 intxxx main()
 ^</code></pre>
<p>The output tells us that there is a problem in line 2 of the program and that the error was discovered at character position 1. In this case, where the compiler was expecting a type, it got something different—namely, the garbage we deliberately put in. Fix the program by changing the line back.</p>
<p>Next let’s take something out—specifically, the semicolon on the fourth line:</p>
    <pre><code><b>printf("Hello World!\n")</b></code></pre>
<p>This gives us a different error message:</p>
<pre><code>$ <b>gcc -o hello hello.c</b>
hello.c: In function 'main':
hello.c:5:5: error: expected ';' before 'return'
 return (0);
 ^</code></pre>
<p>You’ll notice that the compiler pointed to line 5 when issuing the error message. That’s because although we made a mistake on line 4, the compiler didn’t detect it until it looked at line 5.</p>
<p>Sometimes errors on a previous line will not be detected for one or more lines, so don’t look just at the line specified by the error; look above it as well.</p>
<h3 id="h2-501621c01-0003"><span epub:type="pagebreak" title="7" id="Page_7"/>Understanding the Program</h3>
<p class="BodyFirst">Now let’s go through our program line by line to see what it is doing. Take a look at the first line:</p>
<pre><code>#include &lt;stdio.h&gt;</code></pre>
<p>In order to build our program, we are using components that come with the compiler—namely, the standard input/output (I/O) package. The functions in this package are defined in the <em>/usr/include/stdio.h</em> file. (Windows may use a slightly different directory.) Specifically, we use the standard I/O function <code>printf</code> later in the program.</p>
<p>Next, we define the starting point for our program:</p>
<pre><code>int main()</code></pre>
<p>The name <code>main</code> is special and indicates the main body of the program. All programs start at <code>main</code>. This is followed by a set of statements enclosed in curly brackets:</p>
<pre><code>{
...
}</code></pre>
<p>The curly brackets denote the body of <code>main</code>. In other words, they’re used to group the statements that follow. We indent the statements inside the curly brackets by four spaces for readability, but you are free to use other indentation sizes. In fact, the C compiler doesn’t care how much whitespace we use. We could have used no indentation at all, but no indentation makes the program hard to read, so most C programmers indent their code.</p>
<p>Inside the curly brackets is our first executable statement:</p>
<pre><code>    printf("Hello World!\n");</code></pre>
<p>This tells the program to use the standard I/O function <code>printf</code> to output a string to the standard output location (our terminal). The <code>\n</code> is a special character in this string. The backslash (<code>\</code>) is called the <em>escape character</em>. It tells C that the following character should be treated as code. In this case, the <code>n</code> tells C to output a “newline,” which means the next character will be printed on a new line. Some of the more common escape characters are shown in <a href="#table1-1" id="tableanchor1-1">Table 1-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table1-1">Table 1-1</a>: Common Escape Characters</p></figcaption>
<table id="table-501621c01-0001" border="1">
<thead>
<tr>
<td><b>Escape character</b></td>
<td><b>Result</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>Newline (also known as <em>line feed</em>)</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>Tab</td>
</tr>
<tr>
<td><code>\"</code></td>
<td><code>"</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td><code>\</code></td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="8" id="Page_8"/>Finally, the program ends with this statement:</p>
<pre><code>    return (0);</code></pre>
<p>This causes the program to stop and exit, returning an exit code of 0 to the operating system, which indicates that the program terminated normally. A nonzero exit code indicates an error.</p>
<h3 id="h2-501621c01-0004">Adding Comments</h3>
<p class="BodyFirst">So far we’ve confined ourselves exclusively to writing code. In other words, everything we’ve seen is designed to be read by the computer and processed. Programs can also contain <em>comments</em>, which aren’t seen by the compiler; instead, they’re designed to be read by the person viewing the program. Comments commonly begin with <code>/*</code> and end with <code>*/</code>. For example, the following is a comment:</p>
<pre><code>/* Hello World – A nothing program */</code></pre>
<p>It tells you what the programmer who wrote this thought of the program. Let’s put some comments at the beginning of our program:</p>
<pre><code>/*
 * Hello World -- not the most complicated program in
 *      the universe but useful as a starting point.
 *
 * Usage:
 *      1. Run the program.
 *      2. See the world.
 */</code></pre>
<p>Another style of comment starts with <code>//</code> and goes to the end of the line. As you see more programs, you’ll be able to determine for yourself which is better to use.</p>
<p>Always add comments to your code when you write a program, because that’s when you know what you are doing. Five minutes later, you might forget. Five days later, you <em>will</em> forget. For example, I once had to do a complex bitmap transformation in order to translate a raster image into a firing command for an inkjet nozzle. The transformation involved taking a horizontal raster image, turning the row data into column data for the nozzles, and then, since the nozzles were offset, shifting the data left to match the nozzle location. I wrote out a page of comments describing every factor that affected the firing order. Then I added half a page of ASCII art diagramming what I had just described. Only after doing this and making sure I understood the problem did I write the code. And because I had to organize my thoughts in order to document them, the program worked on the first try.</p>
<p>When creating the answers to the programming problems presented in this book, get in the habit of writing comments. The really good programmers are fanatical comment writers.</p>
<h2 id="h1-501621c01-0004"><span epub:type="pagebreak" title="9" id="Page_9"/>Improving the Program and Build Process</h2>
<p class="BodyFirst">When it comes to our little “Hello World” program, manually compiling it isn’t a problem. But for a program with thousands of modules in it, keeping track of what needs to be compiled and what doesn’t can be quite difficult. We need to automate the process to be efficient and avoid human error.</p>
<p>In this section, we’ll tweak our program to improve it and automate the build process. Ideally, you should be able to build a program using a single command and no parameters, which would indicate you have a consistent and precise build process.</p>
<h3 id="h2-501621c01-0005">The make Program</h3>
<p class="BodyFirst">One problem with our build process is that we have to enter the compilation command each time we build the program. This would be tedious for a program with several thousand files in it, each of which would need to be compiled. To automate the build process, we’ll use the <code>make</code> program. It takes as its input a file called a makefile, which tells <code>make</code> how to build a program.</p>
<p>Create a file called <em>Makefile</em> containing the following on macOS or Linux:</p>
<pre><code>CFLAGS=-ggdb -Wall -Wextra
 
all: hello

hello: hello.c
       gcc $(CFLAGS) -o hello hello.c</code></pre>
<p>On Windows, the makefile should contain the following:</p>
<pre><code>CFLAGS=-ggdb -Wall -Wextra
 
all: hello.exe
 
hello.exe: hello.c
       gcc $(CFLAGS) -o hello.exe hello.c</code></pre>
<p>It’s important that the indented lines begin with a tab character. Eight spaces won’t work. (Horrible file design, but we’re stuck with it.) The first line defines a macro. As a result of this definition, whenever we specify <code>$(CFLAGS)</code> in the makefile, the <code>make</code> program will replace this with <code>-ggdb -Wall -Wextra</code>. Next, we define the target <code>all</code>, which is the default target by convention. When <code>make</code> is run with no parameters, it tries to build the first one it sees. The definition of this target, <code>all: hello</code>, tells the <code>make</code> program, “When you try to build <code>all</code>, you need to build <code>hello</code>.” The final two lines of the makefile are the specification for <code>hello</code> (or <code>hello.exe</code> on Windows). These tell <code>make</code> that <code>hello</code> is made from <em>hello.c</em> by executing the command <code>gcc $(CFLAGS) -o hello hello.c</code>. This command contains the macro we defined, <code>$(CFLAGS)</code>, which expands to <code>-ggdb -Wall -Wextra</code>. You’ll notice that we added a couple of extra flags to our compilation. We’ll discuss those in the next section.</p>
<p><span epub:type="pagebreak" title="10" id="Page_10"/>Now let’s make the program using the <code>make</code> command:</p>
<pre><code>$ <b>make</b>
gcc -ggdb -Wall -Wextra -o hello hello.c</code></pre>
<p>As you can see, the program ran the commands to build the executable. The <code>make</code> program is smart. It knows that <code>hello</code> is made from <em>hello.c</em>, so it will check the modification dates of these two files. If<em> </em><code>hello</code> is newer, then it does not need to be recompiled, so if you attempt to build the program twice, you’ll get the following message:</p>
<pre><code>make: Nothing to be done for 'all'.</code></pre>
<p>This is not always the correct behavior. If we change the flags in our makefile, we’ve changed the compilation process and should rebuild our program. However, <code>make</code> doesn’t know about this change and won’t rebuild the program unless we edit <em>hello.c</em> and save the file or delete the output file.</p>
<h3 id="h2-501621c01-0006">Compiler Flags</h3>
<p class="BodyFirst">The GCC compiler takes a number of options. In fact, the list of options for this compiler exceeds eight pages. Fortunately, we don’t have to worry about them all. Let’s take a look at the ones we used for our program:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">-ggdb</code></span>  Compiles the program so we can debug it. Mostly, this adds debugging information to the output file that allows the debugger to understand what is going on.</li>
<li><span class="RunInHead"><code class="bold">-Wall</code></span>  Turns on a set of warnings that will flag correct but questionable code. (This book will teach you not to write questionable code.)</li>
<li><span class="RunInHead"><code class="bold">-Wextra</code></span>  Turns on extra warnings in an effort to make our code more precise.</li>
<li><span class="RunInHead"><code class="bold">-o hello</code></span>  Puts the output of our program in the file <em>hello</em>. (This option is <code>-o hello.exe</code> for Windows users.)</li>
</ol>
<h2 id="h1-501621c01-0005">How the Compiler Works Behind the Scenes</h2>
<p class="BodyFirst">In order to best make use of the compiler, you need to understand what goes on behind the scenes when you run it. That’s because when you’re writing software for embedded devices, you’ll often need to circumvent some of the operations the compiler performs automatically, which consist of a number of steps:</p>
<ol class="decimal">
<li value="1">The source code is run through a <em>preprocessor</em>, which handles all the lines that begin with <code>#</code>, called <em>directives</em>. In our original source file, this is the <code>#include</code> statement. Later, you will learn about additional directives.</li>
<li value="2">The compiler proper takes the preprocessed source code and turns it into <em>assembly language</em> code. C code is supposedly machine-independent and can be compiled and run on multiple platforms. Assembly language <span epub:type="pagebreak" title="11" id="Page_11"/>is machine-dependent and can be run on only one type of platform. (Of course, it is still possible to write C code that will work on only one machine. C tries to hide the underlying machine from you, but it does not prevent you from directly accessing it.)</li>
<li value="3">The assembly language file is passed through an <em>assembler</em>,<em> </em>which turns it into an <em>object file</em>. The object file contains just our code. However, the program needs additional code to work. In our case, the object file for <em>hello.c</em> needs a copy of the <code>printf</code> function.</li>
<li value="4">The <em>linker</em> takes the object code in the object file and combines (links) it with useful code already present on your computer. In this case, it’s <code>printf</code> and all the code needed to support it.</li>
</ol>
<p><a href="#figure1-1" id="figureanchor1-1">Figure 1-1</a> illustrates the process. All these steps are hidden from you by the <code>gcc</code> command.</p>
<figure>
<img src="image_fi/501621c01/f01001.png" alt="f01001" class=""/>
<figcaption><p><a id="figure1-1">Figure 1-1</a>: The steps needed to produce a program</p></figcaption>
</figure>
<p>You’ll notice that the <code>gcc</code> command is acting as both compiler and linker. In fact, <code>gcc</code> is designed as a sort of executive program. It looks at the arguments and decides which other programs it needs to run in order to do its job. This might include the preprocessor (<code>cpp</code>), the C compiler (<code>cc1</code>), the assembler (<code>as</code>), the linker (<code>ld</code>), or other programs as needed. Let’s walk through these components in more detail.</p>
<h3 id="h2-501621c01-0007"><span epub:type="pagebreak" title="12" id="Page_12"/>The Preprocessor</h3>
<p class="BodyFirst">The first program run is the preprocessor, which is a <em>macro processor</em> (a type of automatic text editor) that handles all the lines that begin with <code>#</code>. In our program, it processes the <code>#include</code> line. We can get the output of the preprocessor with this command:</p>
<pre><code>$ <b>gcc -E hello.c &gt;hello.i</b></code></pre>
<p>The output of this command is stored in the <em>hello.i</em> file. If we look at this file, we see that it’s more than 850 lines long. That’s because the <code>#include &lt;stdio.h&gt;</code> line causes the entire <em>stdio.h</em> file to be copied into our program, and because the <em>stdio.h</em> file has its own <code>#include</code> directives, the files included by <em>stdio.h</em> get copied in as well.</p>
<p>We needed <em>stdio.h</em> for the <code>printf</code> function, and if we look through <em>hello.i</em>, we find the definition of this function, which is now included in our program:</p>
<pre><code>extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));</code></pre>
<p>The preprocessor also removes all the comments and annotates the text with information indicating what file is being processed.</p>
<h3 id="h2-501621c01-0008">The Compiler</h3>
<p class="BodyFirst">Next, the compiler turns the C language code into assembly language. We can see what’s generated with this command:</p>
<pre><code>$ <b>gcc -S hello.c</b></code></pre>
<p>This should produce a file that starts with the following lines:</p>
<pre><code>        .file   "hello.c"
        .section        .rodata
.LC0:
        .string "Hello World!"</code></pre>
<p>Notice that the compiler translated the C string <code>"Hello World!\n"</code> to the assembly language <code>.string</code> command. If you have sharp eyes, you’ll also notice that the <code>\n</code> is missing. We’ll discover why a little later.</p>
<h3 id="h2-501621c01-0009">The Assembler</h3>
<p class="BodyFirst">The assembly language file goes into the assembler, where it is translated into machine code. The <code>gcc</code> command has an option (<code>-Wa</code>) that lets us pass flags to the assembler. Since it’s impossible to understand the machine code unless you’re a machine, we will use the following command to ask for an <span epub:type="pagebreak" title="13" id="Page_13"/>assembly language listing that prints the machine code in human-readable format, with the corresponding assembly language statements that generated that code:</p>
<pre><code>$ <b>gcc -Wall -Wextra -g -Wextra -Wa,-a=hello.lst -c hello.c</b></code></pre>
<p>The <code>-Wa</code> option tells GCC that what follows is to be passed to the assembler. The <code>-a=hello.lst</code> option tells the assembler to produce a listing called <em>hello.lst</em>. Let’s take a look at that file. It begins as follows:</p>
<pre><code>4                            .section        .rodata
5                    .LC0:
6 0000 48656C6C              .string "Hello World!"
6      6F20776F
6      726C6421
6      00</code></pre>
<p>Assembly language differs on each machine. In this file, you’re looking at x86 assembly language. It might seem like a confused mess, even in comparison to other assembly languages. You probably won’t understand it completely, and that’s okay; this chapter should only give you a sense of what assembly language looks like. In later chapters, when we get to the ARM processor, you’ll see a much saner and easier-to-understand assembly.</p>
<p>The first column is a line number from the assembly language file. The second column, if present, indicates the address of the data being stored. All computer memory slots have a numerical address. In this case, the string <code>"Hello World!"</code> is being stored at address 0000 relative to the section that is currently being used (in this case, a section titled <code>.rodata</code>). When we discuss the linker in the next section, we’ll see how this relative address is translated into an absolute one.</p>
<p>The next column contains the numerical values to be stored in memory in hexadecimal format. Then comes the text of the assembly language code itself. In the file, we can see that the <code>.string</code> directive tells the assembler to generate the codes for a text string.</p>
<p>Later in the file, we find the code for <code>main</code>:</p>
<pre><code>15 0000 55                    pushq   %rbp
16                            .cfi_def_cfa_offset 16
17                            .cfi_offset 6, -16
18 0001 4889E5                movq    %rsp, %rbp
19                            .cfi_def_cfa_register 6
12:hello.c       ****     printf("Hello World!\n");
20                            .loc 1 12 0
21 0004 BF000000              movl    $.LC0, %edi
21      00
22 0009 E8000000              call    puts
22      00</code></pre>
<p>On line 15, we can see the assembly language instruction <code>55</code>, which will be stored at location 0 in this section. This instruction corresponds to <code>pushq %rbp</code>, which does some bookkeeping at the start of the procedure. Also <span epub:type="pagebreak" title="14" id="Page_14"/>notice that some machine instructions are 1 byte long and others as long as 5 bytes. The instruction at line 21 is an example of a 5-byte instruction. You can see that this instruction is doing something with <code>.LC0</code>. If we look at the top of our listing, we see that <code>.LC0</code> is our string.</p>
<p>As a C programmer, you’re not expected to fully understand what the assembly language does. Complete understanding would require absorbing several thousand pages of reference material. But we can, sort of, understand the instruction at line 22, which calls the function <code>puts</code>. This is where things get interesting. Remember that our C program didn’t call <code>puts</code>—it called <code>printf</code>.</p>
<p>It seems that our code has been optimized behind the scenes. In embedded programming, “optimized” can be a dirty word, so it’s important to understand what happened here. Essentially, the C compiler looked at the line <code>printf("Hello World!\n");</code> and decided it was identical to the following:</p>
    <pre><code>puts("Hello World!");</code></pre>
<p>The truth is that these functions aren’t actually identical: <code>puts</code> is a simple, efficient function, whereas <code>printf</code> is a large, complex one. But the programmer isn’t using any of the advanced <code>printf</code> features, so the optimizer decided to rewrite the code to make it better. As a result, our <code>printf</code> call became <code>puts</code> and the end-of-line character (<code>\n</code>) was removed from the string, as the <code>puts</code> call adds one automatically. When you get especially close to the hardware, little things like this can make a big difference, so it’s important to know how to view and sort of understand assembly code.</p>
<p>The output of the assembler is an object file containing the code we wrote and nothing more. In particular, it does not contain the <code>puts</code> function, which we need. The <code>puts</code> function resides, along with hundreds of other functions, in the C standard library (<em>libc</em>).</p>
<h3 id="h2-501621c01-0010">The Linker</h3>
<p class="BodyFirst">Our object file and some of the components of <em>libc</em> need to be combined to make our program. The linker’s job is to take the files needed to make up the program, combine them, and assign real memory addresses to each component. As we did with the assembler, we can tell the <code>gcc</code> command to pass flags to the linker using this command:</p>
<pre><code>$ <b>gcc -Wall -Wextra -static -Wl,-Map=hello.map -o hello hello.o</b></code></pre>
<p>The <code>-Wl</code> tells GCC to pass the option that follows (<code>-Map=hello.map</code>) to the linker. The map tells us where the linker put things in memory. (More on this later.) We’ve also added the directive <code>-static</code>, which changes the executable from dynamic to statically linked so that the memory map will look more like what we will see with our embedded systems. That way, we can avoid having to discuss the complexities of dynamic linking.</p>
<p>Object files such as <em>hello.o</em> are relocatable. That is, they can go anywhere in memory. It is the job of the linker to decide exactly where in memory <span epub:type="pagebreak" title="15" id="Page_15"/>they go. It is also the linker’s job to go through the libraries used by the program, extract any needed object files, and include them in the final program. The linker map tells us where things went and what library components were included in our program. For example, a typical linker entry might look like this:</p>
<pre><code> .text          0x000000000040fa90      0x1c8 /usr/lib/gcc/x86_64-linux-gnu/5/../../../                x86_64-linux-gnu/libc.a(ioputs.o)
                0x000000000040fa90                puts
                0x000000000040fa90                _IO_puts
 *fill*         0x000000000040fc58        0x8</code></pre>
<p>Remember that we didn’t write <code>puts</code>, even though it appears in this linker entry. As mentioned, it came from the standard C library file (<em>libc.a</em>). We can see here that the code for this function is located at <code>0x000000000040fa90</code>. This information could be useful if, say, our program crashed somewhere between <code>0x40fa90</code> and <code>0x40fc58</code>. In that case, we would know that <code>puts</code> caused the crash.</p>
<p>We also know that <code>puts</code> takes up <code>0x1c8</code> bytes (<code>40fc58–40fa90</code>). This is 456 decimal bytes, or a little under .5K. The amount of memory will concern us when we start programming our microprocessor, which has limited memory.</p>
<p>You should now have a good idea of every element of a C program and what these various pieces do. Most of the time, you can let the compiler take care of these details without worrying about what’s going on under the hood. But when you’re programming small chips with limited resources, you do need to worry about what’s going on inside.</p>
<h2 id="h1-501621c01-0006">Adding to Your Makefile</h2>
<p class="BodyFirst">Explore the various aspects of the GCC compiler, assembler, and linker on your own by amending your makefile to generate all the files described in the previous section:</p>
<pre><code>CFLAGS=-Wall -Wextra -ggdb

all: hello hello.i hello.s

hello.o: hello.c
        gcc $(CFLAGS) -Wa,-a=hello.lst -c hello.c

hello: hello.o
        gcc $(CFLAGS) -static -Wl,-Map=hello.map -o hello hello.o

hello.i: hello.c
        gcc -E hello.c &gt;hello.i

hello.s: hello.c
        gcc -S hello.c

<span epub:type="pagebreak" title="16" id="Page_16"/># Type "make verbose" to see the whole command line
verbose:
        gcc -v $(CFLAGS) -Wextra -c hello.c

clean:
        rm -f hello hello.i hello.s hello.o</code></pre>
<p>As described earlier, the first non-blank line defines a macro that tells <code>make</code> to replace <code>$(CFLAGS)</code> with <code>-Wall -Wextra -ggdb</code> everywhere in the rest of the file. Next, we define a <em>target</em> (an item that needs to be built) named <code>all</code>. Since this is the first target in the file, it is also the default one, which means you can build it simply by entering the following:</p>
<pre><code>$ <b>make</b></code></pre>
<p>This target is what we call a <em>phony target</em>, as it doesn’t result in a file named <em>all</em>. Instead, every time you execute the <code>make all</code> command, <code>make</code> will check whether it needs to re-create its dependencies. You can see these dependencies listed in the makefile after the keyword <code>all</code> and the colon. In order to make the target <code>all</code>, we need to make the targets <code>hello</code>, <code>hello.i</code>, and <code>hello.s</code>. The following lines clarify how to make those targets. For example, to make the target <code>hello.i</code>, we must use the target <code>hello.c</code>. If <code>hello.i</code> is newer than <code>hello.c</code>, then <code>make</code> will do nothing. If <code>hello.c</code> has undergone recent changes and <code>hello.i</code> is not up to date, <code>make</code> will produce <code>hello.i</code> using the following command:</p>
<pre><code>gcc -E hello.c &gt;hello.i</code></pre>
<p>Thus, if you edit <code>hello.c</code> and then execute the command <code>make hello.i</code>, you’ll see <code>make</code> do its job:</p>
<pre><code>$ <var class="bold">(Change hello.c)</var>
$ <b>make hello.i</b>
gcc =E hello.c &gt; hello.i</code></pre>
<p>Another target in our makefile, <code>clean</code>, removes all the generated files. To get rid of the generated files, execute the following command:</p>
<pre><code>$ <b>make clean</b></code></pre>
<p>GNU <code>make</code> is a very sophisticated program with a manual that is more than 300 pages long. The good news is you need to deal with only a very small subset of its commands in order to be productive.</p>
<h2 id="h1-501621c01-0007">Summary</h2>
<p class="BodyFirst">Making a “Hello World” program is one of the simplest things a C programmer can do. However, understanding everything that happens behind the scenes to create and run that C program is a bit more difficult. Luckily, you don’t have to be an expert. But while you don’t need to master every bit of <span epub:type="pagebreak" title="17" id="Page_17"/>the assembly language generated by the program, any embedded programmer should understand enough to be able to spot potential problems or unusual behavior, such as <code>puts</code> showing up in a program that calls <code>printf</code>. Paying attention to these details will allow us to get the most out of our small machines.</p>
<h2 id="h1-501621c01-0008">Questions</h2>
<ol class="decimal">
<li value="1">Where does the documentation for GNU <code>make</code> reside?</li>
<li value="2">Is C code portable between different types of machines?</li>
<li value="3">Is assembly language code portable between different types of machines?</li>
<li value="4">Why does a single statement in assembly language code generate just one machine instruction when one statement in C can generate many?</li>
</ol>
</section>
</body></html>