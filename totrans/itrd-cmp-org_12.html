<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_227"/><strong><span class="big">12</span><br/>INSTRUCTION DETAILS</strong></h2>&#13;
<div class="image1"><img src="../images/pg255_Image_259.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindentz">In <a href="ch02.xhtml">Chapters 2</a> and <a href="ch03.xhtml">3</a>, you learned how bit patterns can be used to represent data. Then, in <a href="ch04.xhtml">Chapters 4</a> to <a href="ch08.xhtml">8</a>, you learned how bits can be implemented in hardware and used to perform computations. In this chapter, I’ll explain some of the details of how instructions are encoded in bit patterns that specify the operations and the locations of the data they operate on.</p>&#13;
<p class="indent">The primary goal of this chapter is to give you an overall view of how computer instructions know where the data they operate on is located. The details of the machine code for each instruction are not the sort of thing that people memorize—you’ll need to consult the manual for those—but being able to interpret them has helped me to better understand and debug many of my programs during my career.</p>&#13;
<p class="indent">The <em>Arm Architecture Reference Manual for A-Profile Architecture</em>, available at <em><a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a></em>, gives an in-depth description of how each bit in a given instruction affects what the instruction does, which can be a little daunting to read. To help you learn how to read the details in the manual, I’ll cover several instructions here, adding my own explanations to the manual’s descriptions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_228"/>As mentioned in <a href="ch10.xhtml">Chapter 10</a>, A64 instructions fall into three general categories:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Load and store</strong> These instructions are used to transfer data between memory and general-purpose registers.</p>&#13;
<p class="noindentin"><strong>Data processing</strong> These instructions operate on data items in registers and constants that are encoded as part of the instruction.</p>&#13;
<p class="noindentin"><strong>Program flow control</strong> These instructions are used to change the order of instruction execution from the order they are loaded into memory.</p>&#13;
</div>&#13;
<p class="indent">We’ll look at a few examples of each type of instruction in this chapter.</p>&#13;
<h3 class="h3" id="ch12lev1sec1"><strong>Looking at Machine Code</strong></h3>&#13;
<p class="noindent">An <em>assembly listing</em> is a specific type of file generated by the assembler from assembly language source code that shows the machine code corresponding to each assembly language instruction. I’ll use the program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> to show the machine language for several instructions.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_consts.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add three constants to show some machine code.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    z, 28&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
format:&#13;
        .string "%i + %i + 456 = %i\n"&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp       fp, lr, [sp, FRAME]!  // Create stack frame&#13;
        mov       fp, sp&#13;
 &#13;
        mov       w19, 123              // 1st constant&#13;
        mov       w20, -123             // 2nd constant&#13;
        add       w21, w19, w20         // Add them&#13;
        add       w22, w21, 456         // Another constant&#13;
        str       w22, [sp, z]          // Store sum&#13;
 &#13;
        ldr       w3, [sp, z]           // Get sum&#13;
     <span class="ent">➊</span> mov       w2, w20               // Get 2nd constant&#13;
     <span class="ent">➋</span> orr       w2, wzr, w20          // Alias&#13;
        mov       w1, w19               // Get 1st constant&#13;
        adr       x0, format            // Assume on same page<span epub:type="pagebreak" id="page_229"/>&#13;
        bl        printf&#13;
 &#13;
        mov       w0, wzr               // Return 0&#13;
        ldp       fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret</pre>&#13;
<p class="list" id="ch12list1"><em>Listing 12-1: A program to add some constants</em></p>&#13;
<p class="indent">Of course, this is a silly program—all the data is constant—but it does allow me to illustrate a few points. For example, I’ve used two different instructions, <span class="literal">mov</span> <span class="ent">❶</span> and <span class="literal">orr</span> <span class="ent">❷</span>, to copy the value in <span class="literal">w20</span> into <span class="literal">w2</span>. This will allow us to compare the machine code for two ways of accomplishing the same effect.</p>&#13;
<p class="indent">We can produce an assembly listing by passing the <span class="literal">-al</span> option to the assembler. This causes the assembly listing to be written to standard output, which defaults to the screen. We can capture this with the redirection operator, <span class="literal">&gt;</span>. For example, I used the command</p>&#13;
<pre class="pre">$ <span class="codestrong1">as --gstabs -al -o add_consts.o add_consts.s &gt; add_consts.lst</span></pre>&#13;
<p class="noindent">to produce the assembly listing file shown in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_consts.lst</em></p>&#13;
</div>&#13;
<pre class="pre">AARCH64 GAS  add_consts.s     <a href="ch01.xhtml#page_1">page 1</a>&#13;
&#13;
&#13;
    1               // Add three constants to show some machine code.&#13;
    2                       .arch armv8-a&#13;
    3               // Stack frame&#13;
    4                       .equ    z, 28&#13;
    5                       .equ    FRAME, 32&#13;
    6               // Constant data&#13;
    7                       .section  .rodata&#13;
    8               format:&#13;
    9 0000 2569202B         .string "%i + %i + 456 = %i\n"&#13;
    9      20256920&#13;
    9      2B203435&#13;
    9      36203D20&#13;
    9      25690A00&#13;
   10               // Code&#13;
   11                       .text&#13;
   12                       .align 2&#13;
   13                       .global main&#13;
   14                       .type main, %function&#13;
   15               main:&#13;
<span class="ent">➊</span> 16 0000 FD7B82A9           stp     fp, lr, [sp, FRAME]!  // Create stack frame&#13;
   17 0004 FD030091           mov     fp, sp&#13;
   18&#13;
   19 0008 730F8052           mov     w19, 123              // 1st constant&#13;
   20 000c 540F8012           mov     w20, -123             // 2nd constant&#13;
   21 0010 7502140B           add     w21, w19, w20         // Add them<span epub:type="pagebreak" id="page_230"/>&#13;
   22 0014 B6220711           add     w22, w21, 456         // Another constant&#13;
   23 0018 F61F00B9           str     w22, [sp, z]          // Store sum&#13;
   24&#13;
   25 001c E31F40B9           ldr     w3, [sp, z]           // Get sum&#13;
<span class="ent">➋</span> 26 0020 E203142A           mov     w2, w20               // Get 2nd constant&#13;
<span class="ent">➌</span> 27 0024 E203142A           orr     w2, wzr, w20          // Alias instruction&#13;
   28 0028 E103132A           mov     w1, w19               // Get 1st constant&#13;
   29 002c 00000010           adr     x0, format            // Assume on same page&#13;
   30 0030 00000094           bl      printf&#13;
   31&#13;
   32 0034 E0031F2A           mov     w0, wzr               // Return 0&#13;
   33 0038 FD7BC2A8           ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
   34 003c C0035FD6           ret</pre>&#13;
<p class="list" id="ch12list2"><em>Listing 12-2: The assembly listing file for the program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a></em></p>&#13;
<p class="indent">The first column in the assembly listing file shows the corresponding line number in the source file. The next column shows the 16-bit relative address from the beginning of each section, in hexadecimal.</p>&#13;
<p class="indent">The third column gives the machine code for the instruction or data, also in hexadecimal. All A64 instructions are 32 bits wide. The assembly listing shows the 4 bytes in each instruction in the order that they’ll be stored in memory. Since ours is a little-endian environment, the 4 bytes appear backward in the assembly listing. For example, the first instruction in this program <span class="ent">❶</span> is the 32-bit word <span class="literal">0xa9827bfd</span>. (We’ll look at the other instructions that I’ve called out in this listing a bit later, in “Moving Data from Register to Register” on <a href="ch12.xhtml#ch12lev2sec1">page 232</a>.)</p>&#13;
<p class="indent">In some cases, the names for the bit fields in my descriptions are different from those in the manual. Note that some of the names I use might have a different meaning in other places in the manual. Here are the names I’m using:</p>&#13;
<div class="indL">&#13;
<p class="noindentin"><span class="codestrong">sf</span> The size flag. The operands are 32-bit values when it’s <span class="literal">0</span> or 64-bit when it’s <span class="literal">1</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">imm</span> A constant integer used by the instruction.</p>&#13;
<p class="noindentin"><span class="codestrong">hw</span> The number of halfwords (16 bits) to shift a 16-bit <span class="literal">imm</span> value left before loading it into a register.</p>&#13;
<p class="noindentin"><span class="codestrong">b_offset</span> The number of bytes from the current instruction to an address.</p>&#13;
<p class="noindentin"><span class="codestrong">b_offset:hi</span> The high-order part of a <span class="literal">b_offset</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">b:lo</span> The low-order part of a <span class="literal">b_offset</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">w_offset</span> The number of 32-bit words from the current instruction to an address.</p>&#13;
<p class="noindentin"><span class="codestrong">rb</span> The number of a register holding a 64-bit base address for this instruction.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_231"/><span class="codestrong">rd</span> The number of the destination register, which will hold the result of the instruction’s operation. Where there are two destination registers, I use <span class="literal">rd1</span> and <span class="literal">rd2</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">rs</span> The number of a source register, which holds a value used in the instruction’s operation. Where there are two source registers, I use <span class="literal">rs1</span> and <span class="literal">rs2</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">pi</span> Tells the instruction how to treat the base register: <span class="literal">01</span> for post-index, <span class="literal">11</span> for pre-index, or <span class="literal">10</span> for don’t change.</p>&#13;
<p class="noindentin"><span class="codestrong">sh</span> Tells the instruction whether to shift an operand before using it in the operation: yes if it’s <span class="literal">1</span>, and no if it’s <span class="literal">0</span>. For a 2-bit <span class="literal">sh</span> field, <span class="literal">00</span> is <span class="literal">lsl</span>, <span class="literal">01</span> is <span class="literal">lsr</span>, <span class="literal">10</span> is <span class="literal">asr</span>, and <span class="literal">11</span> is <span class="literal">ror</span>.</p>&#13;
<p class="noindentin"><span class="codestrong">shft_amnt</span> The number of bits to shift an operand.</p>&#13;
</div>&#13;
<p class="indent">Bits 28 to 25 show which group the instruction is in: load and store (<span class="literal">0x4, 0x6, 0xc, 0xe</span>), data processing (<span class="literal">0x5, 0x7, 0x8, 0x9, 0xd, 0xf</span>), or program flow control (<span class="literal">0xa, 0xb</span>). Many instructions have variants. The assembler will pick the variant appropriate for the operands we use. I’ll start by showing you the load and store instructions in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>.</p>&#13;
<h3 class="h3" id="ch12lev1sec2"><strong>Encoding Load and Store Instructions</strong></h3>&#13;
<p class="noindent"><a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows the basic load instruction.</p>&#13;
<div class="image"><img id="ch12fig1" src="../images/pg259_Image_260.jpg" alt="Image" width="669" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-1: A basic load instruction: <span class="literal">Idr w3, [sp, z]</span></em></p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig2">Figure 12-2</a> shows the basic store instruction.</p>&#13;
<div class="image"><img id="ch12fig2" src="../images/pg259_Image_261.jpg" alt="Image" width="669" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-2: A basic store instruction:</em> <span class="codeitalic">str w22, [sp, z]</span></p>&#13;
<p class="indent">In both instructions, bit 24 is <span class="literal">1</span>, which shows us that the assembler has used the immediate, unsigned offset variant. Other variants have <span class="literal">0</span> in bit 24. Both instructions use <span class="literal">sp</span> as the base address register, giving <span class="literal">11111</span> in the <span class="literal">rb</span> field, and in both instructions the offset from the base register is the number of 32-bit words. The offset in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> is <span class="literal">z</span>, which equates to 28. We use the number of bytes in assembly language, but the assembler divides this value by 4 to encode the number of words in the machine code for the instruction, giving 7 in the <span class="literal">w_offset</span> field.</p>&#13;
<p class="indent">In <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>, the <span class="literal">0</span> in the <span class="literal">sf</span> field together with <span class="literal">00011</span> in the <span class="literal">rd</span> field tells the CPU to use <span class="literal">w3</span> for the destination register, and the <span class="literal">0</span> in the <span class="literal">sf</span> field <span epub:type="pagebreak" id="page_232"/>together with <span class="literal">10110</span> in the <span class="literal">rs</span> field in <a href="ch12.xhtml#ch12fig2">Figure 12-2</a> tells the CPU to use <span class="literal">w22</span> for the source register.</p>&#13;
<p class="indent">The stack frame is created with the <span class="literal">stp</span> instruction, shown in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>.</p>&#13;
<div class="image"><img id="ch12fig3" src="../images/pg260_Image_262.jpg" alt="Image" width="668" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-3: The instruction to push</em> <span class="codeitalic">fp</span> <em>and</em> <span class="codeitalic">sp</span> <em>onto the stack:</em> <span class="codeitalic">stp fp, lr, [sp, FRAME]!</span></p>&#13;
<p class="indent">It is deleted with the <span class="literal">ldp</span> instruction, shown in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>.</p>&#13;
<div class="image"><img id="ch12fig4" src="../images/pg260_Image_263.jpg" alt="Image" width="668" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-4: The instruction to pop</em> <span class="codeitalic">fp</span> <em>and</em> <span class="codeitalic">sp</span> <em>from the stack:</em> <span class="codeitalic">ldp fp, lr, [sp], FRAME</span></p>&#13;
<p class="indent">Both of these instructions use <span class="literal">sp</span> for their base register. In <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>, the <span class="literal">11</span> in the <span class="literal">pi</span> field tells the CPU to subtract the <span class="literal">w_offset</span>, 4 words (32 bytes), from <span class="literal">sp</span> before (pre-index) storing the contents of registers <span class="literal">x29</span> and <span class="literal">x30</span> at that address. The CPU stores the entire 64 bits of each register because <span class="literal">sf</span> is <span class="literal">1</span>.</p>&#13;
<p class="indent">The <span class="literal">pi</span> field is <span class="literal">01</span> in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>, so 32 is added to <span class="literal">sp</span> after (post-index) the two 64-bit values are loaded into registers <span class="literal">x29</span> and <span class="literal">x30</span>. The CPU loads 64 bits from memory into each register because <span class="literal">sf</span> is <span class="literal">1</span>. Next, I’ll explain the data processing instructions in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>.</p>&#13;
<h3 class="h3" id="ch12lev1sec3"><strong>Encoding Data Processing Instructions</strong></h3>&#13;
<p class="noindent">Data processing instructions operate on values that are already in the CPU, either in registers or as part of the instruction itself. They are used to move data or perform arithmetic and logic operations on data. In some cases, these operations overlap.</p>&#13;
<h4 class="h4" id="ch12lev2sec1"><em><strong>Moving Data from Register to Register</strong></em></h4>&#13;
<p class="noindent">We’ll start by looking at the instruction that moves the value from the <span class="literal">sp</span> register to the <span class="literal">fp</span> register, shown in <a href="ch12.xhtml#ch12fig5">Figure 12-5</a>.</p>&#13;
<div class="image"><img id="ch12fig5" src="../images/pg260_Image_264.jpg" alt="Image" width="668" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-5: A basic register-to-register move instruction:</em> <span class="codeitalic">mov fp, sp</span></p>&#13;
<p class="indent">Next, we’ll look at an instruction that uses a logical operation to effectively move a value from one register to another, shown in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_233"/><img id="ch12fig6" src="../images/pg261_Image_265.jpg" alt="Image" width="669" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-6: A logical operation to move data:</em> <span class="codeitalic">orr w2, wzr, w20</span></p>&#13;
<p class="indent">Notice that the <span class="literal">rs</span> field in <a href="ch12.xhtml#ch12fig5">Figure 12-5</a> is the same as the <span class="literal">rs1</span> field in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a>, but in the first case it’s the code for the stack pointer and in the second it’s the zero register. This shows that the way register 31 is treated, as a stack pointer or zero register, depends on the instruction.</p>&#13;
<p class="indent">You’re probably wondering why I’m showing an <span class="literal">orr</span> instruction instead of a <span class="literal">mov</span> instruction in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a>. As you might guess from the name, the <span class="literal">orr</span> instruction performs a bitwise OR operation between the values in the two source registers, <span class="literal">rs1</span> and <span class="literal">rs2</span>, and stores the result in the destination register, <span class="literal">rd</span>. Since <span class="literal">rs1</span> is the zero register in our instruction, this operation simply moves the value in <span class="literal">rs2</span> to <span class="literal">rd</span>, which is equivalent to <span class="literal">mov w2, w20</span> here. I’ll describe the <span class="literal">orr</span> instruction in more detail when we look at logic operators in <a href="ch16.xhtml">Chapter 16</a>.</p>&#13;
<p class="indent">The <span class="literal">mov w2, w20</span> <span class="ent">❷</span> and <span class="literal">orr w2, wzr, w20</span> <span class="ent">❸</span> instructions in <a href="ch12.xhtml#ch12list2">Listing 12-2</a> (on <a href="ch12.xhtml#page_229">page 229</a>) use exactly the same machine code. The two names for the same instruction are said to be <em>aliases</em>. For the instructions that have aliases, you should use the name that better expresses your intent in the algorithm. In our example program, <span class="literal">mov w2, w20</span> is a better choice.</p>&#13;
<h4 class="h4" id="ch12lev2sec2"><em><strong>Moving a Constant to a Register</strong></em></h4>&#13;
<p class="noindent"><a href="ch12.xhtml#ch12fig7">Figure 12-7</a> shows the instruction for moving a positive or unsigned constant into a register.</p>&#13;
<div class="image"><img id="ch12fig7" src="../images/pg261_Image_266.jpg" alt="Image" width="668" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-7: The instruction for moving a positive constant:</em> <span class="codeitalic">mov w19, 123</span></p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig8">Figure 12-8</a> shows the instruction for moving a negative constant into a register.</p>&#13;
<div class="image"><img id="ch12fig8" src="../images/pg261_Image_267.jpg" alt="Image" width="668" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-8: The instruction for moving a negative constant:</em> <span class="codeitalic">mov w20, -123</span></p>&#13;
<p class="indent">Although both instructions use the <span class="literal">mov</span> mnemonic, in <a href="ch12.xhtml#ch12fig7">Figure 12-7</a> bit 30 is <span class="literal">1</span>, and in <a href="ch12.xhtml#ch12fig8">Figure 12-8</a> it’s <span class="literal">0</span>. The difference is that the first instruction is moving a positive number and the second a negative number. When the constant in a <span class="literal">mov</span> instruction is negative, the assembler uses the <span class="literal">movn</span> (move with NOT) instruction from <a href="ch10.xhtml">Chapter 10</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_234"/>In <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>, the constant +123 is encoded as <span class="literal">0x007b</span>, as we would expect, but in <a href="ch12.xhtml#ch12fig8">Figure 12-8</a> we see that –123 is encoded as <span class="literal">0x007a</span>, which is +122 in decimal.</p>&#13;
<p class="indent">You learned in <a href="ch03.xhtml">Chapter 3</a> that in the two’s complement notation, the negative of a number can be computed by taking the complement of the number and adding 1. In other words, –123 is the complement of +122 in two’s complement notation. The <span class="literal">mov</span> instruction in <a href="ch12.xhtml#ch12fig8">Figure 12-8</a> computes the NOT of the value in the <span class="literal">imm</span> field and sign-extends it to the size of the destination register before storing the result there. So, this instruction uses the <span class="literal">0x007a</span> to store <span class="literal">0xffffff85</span> in the <span class="literal">w20</span> register, as shown in the debugger:</p>&#13;
<pre class="pre">Breakpoint 1, main () at add_consts.s:24&#13;
24              str     w22, [sp, z]          // Store sum&#13;
(gdb) <span class="codestrong1">i r w19 w20 w21 w22</span>&#13;
w19            0x7b                123&#13;
w20            0xffffff85          4294967173&#13;
w21            0x0                 0&#13;
w22            0x1c8               456</pre>&#13;
<p class="indent">In both instructions, the constant has to fit within the 16-bit immediate value. The range for positive numbers is 0 to +65,535, and for negative numbers it’s –1 to –65,536.</p>&#13;
<h4 class="h4" id="ch12lev2sec3"><em><strong>Performing Arithmetic</strong></em></h4>&#13;
<p class="noindent">Let’s look at the instruction for adding a constant to a value in a register, shown in <a href="ch12.xhtml#ch12fig9">Figure 12-9</a>.</p>&#13;
<div class="image"><img id="ch12fig9" src="../images/pg262_Image_268.jpg" alt="Image" width="668" height="81"/></div>&#13;
<p class="figcap"><em>Figure 12-9: The instruction for adding a constant to a value:</em> <span class="codeitalic">add w22, w21, 456</span></p>&#13;
<p class="indent">This instruction adds the 12-bit <span class="literal">imm</span> value to the value in <span class="literal">rs</span> and stores the result in the <span class="literal">rd</span> register. When the shift bit, <span class="literal">sh</span>, is <span class="literal">1</span>, the <span class="literal">imm</span> value is shifted left 12 bits before performing the addition. The shift option allows us to add a 24-bit constant in two <span class="literal">add</span> operations. The first will add the low-order 12 bits and the second the high-order 12 bits.</p>&#13;
<p class="indent">Comparing <a href="ch12.xhtml#ch12fig9">Figure 12-9</a> with <a href="ch12.xhtml#ch12fig5">Figure 12-5</a>, you can see another example of an alias. If <span class="literal">imm</span> is 0 and one of <span class="literal">rd</span> or <span class="literal">rs</span> is 31, this <span class="literal">add</span> instruction is the same as a <span class="literal">mov</span> to or from the <span class="literal">sp</span> register.</p>&#13;
<h4 class="h4" id="ch12lev2sec4"><em><strong>Computing Addresses</strong></em></h4>&#13;
<p class="noindent">Now, let’s look at the instruction that loads the address of the <span class="literal">printf</span> format string into the <span class="literal">x0</span> register, as shown in <a href="ch12.xhtml#ch12fig10">Figure 12-10</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_235"/><img id="ch12fig10" src="../images/pg263_Image_269.jpg" alt="Image" width="669" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-10: The instruction to load an address:</em> <span class="codeitalic">adr x0, format</span></p>&#13;
<p class="indent">You learned in <a href="ch11.xhtml">Chapter 11</a> that this instruction computes the address of <span class="literal">format</span> by adding the offset from this instruction to <span class="literal">format</span> and the value in <span class="literal">pc</span>, then loads the result into <span class="literal">x0</span>. The <span class="literal">b_offset</span> field in this instruction shows that all 21 bits are <span class="literal">0</span> (don’t forget to include the two low-order bits in the <span class="literal">b:lo</span> field). This seems to indicate that the <span class="literal">format</span> text string is located at the same place as this instruction, which is clearly not possible. This text string is in the <span class="literal">.rodata</span> section. The linker will decide where to locate that section and fill in the <span class="literal">b_offset:hi</span> and <span class="literal">b:lo</span> fields during the linking process.</p>&#13;
<h4 class="h4" id="ch12lev2sec5"><em><strong>Looking at the Details of an Executable File</strong></em></h4>&#13;
<p class="noindent">You can use a program called <span class="literal">objdump</span> to look at the code in an executable program file. For example, to dump the contents of the <em>add_consts</em> file, you can use the following command:</p>&#13;
<pre class="pre">   $ <span class="codestrong1">objdump -D add_consts</span>&#13;
   --<span class="codeitalic1">snip</span>--&#13;
   0000000000000774 &lt;main&gt;:&#13;
   774:   a9827bfd        stp     x29, x30, [sp, #32]!&#13;
   778:   910003fd        mov     x29, sp&#13;
   77c:   52800f73        mov     w19, #0x7b                      // #123&#13;
   780:   12800f54        mov     w20, #0xffffff85                // #-123&#13;
   784:   0b140275        add     w21, w19, w20&#13;
   788:   110722b6        add     w22, w21, #0x1c8&#13;
   78c:   b9001ff6        str     w22, [sp, #28]&#13;
   790:   b9401fe3        ldr     w3, [sp, #28]&#13;
   794:   2a1403e2        mov     w2, w20&#13;
   798:   2a1403e2        mov     w2, w20&#13;
   79c:   2a1303e1        mov     w1, w19&#13;
<span class="ent">➊</span> 7a0:   100005c0        adr     x0, 858 &lt;format&gt;&#13;
   7a4:   97ffffab        bl      650 &lt;printf@plt&gt;&#13;
   7a8:   2a1f03e0        mov     w0, wzr&#13;
   7ac:   a8c27bfd        ldp     x29, x30, [sp], #32&#13;
   7b0:   d65f03c0        ret&#13;
   7b4:   d503201f        nop&#13;
   7b8:   d503201f        nop&#13;
   7bc:   d503201f        nop&#13;
   --<span class="codeitalic1">snip</span>--&#13;
   0000000000000858 &lt;format&gt;:&#13;
   858:   2b206925        adds    w5, w9, w0, uxtx #2&#13;
   85c:   20692520        .inst   0x20692520 ; undefined&#13;
   860:   3534202b        cbnz    w11, 68c64 &lt;__bss_end__+0x57c24&gt;<span epub:type="pagebreak" id="page_236"/>&#13;
   864:   203d2036        .inst   0x203d2036 ; undefined&#13;
   868:   000a6925        .inst   0x000a6925 ; undefined&#13;
   --<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">The <span class="literal">-D</span> option dumps all the sections in the file, assumes that they all contain instructions, and disassembles them as such. I’m showing only the two sections that interest us here.</p>&#13;
<p class="indent">The first column shows the relative address where each instruction will be loaded into memory. The operating system will decide the base loading address when loading the program.</p>&#13;
<p class="indent">The second column shows the machine code of the instruction at that address. Note that <span class="literal">objdump</span> displays the machine code in 32-bit instruction order, not in the little-endian byte order we see in assembly listing files.</p>&#13;
<p class="indent">The linker has filled in the offset to the <span class="literal">format</span> text string in the <span class="literal">adr</span> instruction <span class="ent">❶</span>. Per <a href="ch12.xhtml#ch12fig10">Figure 12-10</a>, the offset is <span class="literal">000000000000010110100</span>. Adding this to the relative address of the instruction gives <span class="literal">0x7a4</span> + <span class="literal">0x0b4</span> = <span class="literal">0x858</span>.</p>&#13;
<p class="indent">The machine code at relative address <span class="literal">0x858</span> begins with the bytes <span class="literal">0x25</span>, <span class="literal">0x69</span>, <span class="literal">0x20</span>, <span class="literal">0x2b</span>, which are the code points for the first four characters in the format text string: <span class="literal">%</span>, <span class="literal">i</span>, space, and <span class="literal">+</span>. The assembly listing file, shown in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>, displays the bytes in the proper order. Next, I’ll show you the two instructions in this program that cause program flow to go someplace other than the next instruction in memory.</p>&#13;
<h3 class="h3" id="ch12lev1sec4"><strong>Encoding Program Flow Control Instructions</strong></h3>&#13;
<p class="noindent">I’ll start with the instruction used to call the <span class="literal">printf</span> function, shown in <a href="ch12.xhtml#ch12fig11">Figure 12-11</a>.</p>&#13;
<div class="image"><img id="ch12fig11" src="../images/pg264_Image_270.jpg" alt="Image" width="668" height="83"/></div>&#13;
<p class="figcap"><em>Figure 12-11: The function call instruction:</em> <span class="codeitalic">bl printf</span></p>&#13;
<p class="indent">The <span class="literal">bl</span> instruction copies the address in <span class="literal">pc</span>, plus 4, to the link register, <span class="literal">x30</span>. It then shifts <span class="literal">w_offset</span> 2 bits to the left to give a byte offset, sign-extends it to 64 bits, and adds the result to <span class="literal">pc</span>. The result is to save the address of the instruction immediately after the <span class="literal">bl</span> instruction in memory to the link register and then transfer program flow to <span class="literal">w_offset</span> words from the address of the <span class="literal">bl</span> instruction. Since <span class="literal">w_offset</span> is 26 bits wide, the offset in bytes is limited to 28 bits, giving a transfer limit of ±128MB away in memory.</p>&#13;
<p class="indent">The last instruction we’ll look at is <span class="literal">ret</span>, shown in <a href="ch12.xhtml#ch12fig12">Figure 12-12</a>.</p>&#13;
<div class="image"><img id="ch12fig12" src="../images/pg264_Image_271.jpg" alt="Image" width="667" height="82"/></div>&#13;
<p class="figcap"><em>Figure 12-12: The return from function instruction:</em> <span class="codeitalic">ret</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_237"/>The <span class="literal">ret</span> instruction moves the address from the register specified in the <span class="literal">rs</span> field to <span class="literal">pc</span>. Although I didn’t specify a register in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>, the assembler uses <span class="literal">x30</span> by default. We could use another register, but that would be inconsistent with the published standards and likely lead to program bugs.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch12exe1">12.1     Enter the program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> and use the debugger to determine when the <span class="literal">adr</span> instruction knows the address of the format text string.</p>&#13;
<p class="box-list1" id="ch12exe2">12.2     Experiment with the constants in the program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> to find the magnitude limits of the constants.</p>&#13;
<p class="box-list1" id="ch12exe3">12.3     Modify the program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a> to use 64-bit integers (<span class="literal">long int</span> in C). Does this allow you to use larger constants?</p>&#13;
<p class="box-list1" id="ch12exe4">12.4     Write a program in C that does the same thing as our assembly language program in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>. Does your C program allow you to use larger constants? If so, why?</p>&#13;
</div>&#13;
<p class="indent">Now that you know what machine code looks like, we’ll look at how an assembler program translates assembly language into machine code. The general algorithm is similar for linking functions together; I’ll cover that too.</p>&#13;
<h3 class="h3" id="ch12lev1sec5"><strong>Translating Assembly into Machine Code</strong></h3>&#13;
<p class="noindent">The presentation in this section is meant to be an overview, so it ignores most of the details. My intention is to give you only a rough idea of how an assembler translates the source code into machine language and how a linker connects the different modules that make up an entire program.</p>&#13;
<h4 class="h4" id="ch12lev2sec6"><em><strong>The Assembler</strong></em></h4>&#13;
<p class="noindent">The simplest approach for an assembler to translate assembly language into machine code would be to go through the source one line at a time, translating each one in turn. This would work fine, except for situations where an instruction refers to a label on a line after the current line.</p>&#13;
<p class="indent">To see how the assembler deals with these forward references, I’ll make a forward reference to <a href="ch13.xhtml#ch13list11">Listing 13-11</a> in <a href="ch13.xhtml">Chapter 13</a>, where we’ll be making use of them. <a href="ch12.xhtml#ch12list3">Listing 12-3</a> shows a portion of the assembly listing file from that program.</p>&#13;
<pre class="pre">--<span class="codeitalic1">snip</span>--&#13;
33 0024 3F00006B                cmp     w1, w0                // Above or below middle?&#13;
34 0028 88000054                b.hi    tails                 // Above -&gt; tails&#13;
35 002c 00000010                adr     x0, heads_msg         // Below -&gt; heads message&#13;
36 0030 00000094                bl      puts                  // Print message&#13;
37 0034 03000014                b       continue              // Skip else part&#13;
38               tails:<span epub:type="pagebreak" id="page_238"/>&#13;
39 0038 00000010                adr     x0, tails_msg         // Tails message page address&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="list" id="ch12list3"><em>Listing 12-3: Part of the listing file for the program in <a href="ch13.xhtml#ch13list11">Listing 13-11</a> from <a href="ch13.xhtml">Chapter 13</a></em></p>&#13;
<p class="indent">I’ll cover the details in <a href="ch13.xhtml">Chapter 13</a>, but this section of code compares the values in registers <span class="literal">w0</span> and <span class="literal">w1</span>. If the value in <span class="literal">w1</span> is higher, the <span class="literal">b.hi</span> instruction causes the program flow to branch to the address labeled <span class="literal">tails</span>.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig13">Figure 12-13</a> shows the machine code that the assembler produced for the <span class="literal">b.hi</span> instruction.</p>&#13;
<div class="image"><img id="ch12fig13" src="../images/pg266_Image_272.jpg" alt="Image" width="668" height="83"/></div>&#13;
<p class="figcap"><em>Figure 12-13: A conditional branch:</em> <span class="codeitalic">b.hi tails</span></p>&#13;
<p class="indent">The <span class="literal">tails</span> label is at relative location <span class="literal">0x38</span>, which is <span class="literal">0x10</span> bytes beyond the <span class="literal">b.hi</span> instruction at <span class="literal">0x28</span>. In <a href="ch12.xhtml#ch12fig13">Figure 12-13</a>, the <span class="literal">w_offset</span> is <span class="literal">0x00004</span>, or <span class="literal">0x10</span> bytes. The question is how the assembler knew the location of the forward reference to the <span class="literal">tails</span> label.</p>&#13;
<p class="indent">A common way to deal with forward references is to use a <em>two-pass assembler</em>, which scans the program twice. During the first pass, the assembler creates a <em>local symbol table</em>, associating each symbol with a numerical value. Those symbols defined with a <span class="literal">.equ</span> directive are entered directly in the table.</p>&#13;
<p class="indent">For the labeled locations in the code, the assembler needs to determine the location of each label relative to the beginning of the module being assembled and then enter that value and the label in the table. A separate local symbol table is created for each <span class="literal">.text</span> and <span class="literal">.data</span> segment in the file.</p>&#13;
<p class="indent">Here’s the general algorithm for the first pass of a two-pass assembler, which generates a local symbol table:</p>&#13;
<pre class="pre">Let location_counter = 0&#13;
do&#13;
    Read a line of source code&#13;
    if (.equ directive)&#13;
        local_symbol_table.symbol = symbol&#13;
        local_symbol_table.value = expression value&#13;
    else if (line has a label)&#13;
        local_symbol_table.symbol = label&#13;
        local_symbol_table.value = location_counter&#13;
    Determine number_of_bytes required by line when assembled&#13;
    location_counter = location_counter + number_of_bytes&#13;
while (more lines of source code)</pre>&#13;
<p class="indent">Once the local symbol table is created, the assembler does a second pass through the source code file. It uses a built-in <em>opcode table</em> to determine the machine code, and when a symbol is used in an instruction, it looks up the value of the symbol in the local symbol table. If it does not find the symbol <span epub:type="pagebreak" id="page_239"/>in the local symbol table, it leaves space in the instruction for a number and records the symbol and its location in the object file.</p>&#13;
<p class="indent">The general algorithm looks like this:</p>&#13;
<pre class="pre">Let location_counter = 0&#13;
do&#13;
    Read a line of source code&#13;
    Find machine code from opcode table&#13;
    if (symbol is used in instruction)&#13;
        if (symbol found in local_symbol_table)&#13;
            Get value of symbol&#13;
        else&#13;
            Let value = 0&#13;
            Write symbol and location_counter to object file&#13;
        Add symbol value to instruction&#13;
    Write assembled instruction to object file&#13;
    Determine number_of_bytes used by the assembled instruction&#13;
    location_counter = location_counter + number_of_bytes&#13;
while (more lines of source code)</pre>&#13;
<p class="indent">As an alternative, we could create a <em>one-pass assembler</em>. It would need to maintain a list of the locations of each forward reference and, when the label is found, use the table to go back and fill in the appropriate value.</p>&#13;
<p class="indent">Again, this is a highly simplified overview of the assembly process that is intended only to show you the general idea of how an assembler works. <a href="ch07.xhtml">Chapter 7</a> in Andrew S. Tanenbaum and Todd Austin’s <em>Structured Computer Organization</em>, 6th edition (Pearson, 2012), has a section that provides more details about the assembly process. There is a thorough discussion of the design of assembler programs in <a href="ch02.xhtml">Chapter 2</a> of Leland Beck’s <em>System Software: An Introduction to Systems Programming</em>, 3rd edition (Pearson, 1997).</p>&#13;
<p class="indent">Most functions will have function calls, which are references to labels in <span class="literal">.text</span> segments defined in other files that cannot be resolved by the assembler. The same is true of any labels in <span class="literal">.data</span> segments, even if they’re defined in the same source code file. I’ll show you the program that resolves these references in the next section.</p>&#13;
<h4 class="h4" id="ch12lev2sec7"><em><strong>The Linker</strong></em></h4>&#13;
<p class="noindent">The job of the linker is to figure out the relative locations of the labels in a program so it can enter the offset to each label wherever there is a reference to the label. A linker works in much the same way as an assembler, except the basic unit is a block of machine code instead of a line of assembly language. A typical program comprises many object files, each of which often has more than one <span class="literal">.text</span> segment and may have <span class="literal">.data</span> segments, all of which must be linked together. As with an assembler, two passes can be used to resolve forward references.</p>&#13;
<p class="indent">An object file created by the assembler includes the size of each segment in the file, together with a list of all the global symbols and where they are <span epub:type="pagebreak" id="page_240"/>used in the segment. During the first pass, the linker reads each object file and creates a <em>global symbol table</em> that contains the relative location of each global symbol from the beginning of the program. In the second pass, the linker creates an executable file that includes all the machine code from the object files with the relative location values from the global symbol table plugged into the locations where they are referenced.</p>&#13;
<p class="indent">This process resolves all the references to names defined in the modules that comprise the program, but it will leave unresolved all references to externally defined names, such as function or variable names that are defined in the C standard library. The linker enters these unresolved references into the <em>global offset table (GOT)</em>.</p>&#13;
<p class="indent">If the external reference is a function call, the linker also enters this information into the <em>procedure linkage table (PLT)</em>, along with the location in the machine code where the reference is made. You can see how the linker has done this by looking at how we wrote a call to a C standard library function in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>:</p>&#13;
<pre class="pre">bl     printf</pre>&#13;
<p class="noindent">Using the <span class="literal">objdump</span> program to look at the contents of the executable file for this program, we see what the linker has added:</p>&#13;
<pre class="pre">7a4:   97ffffab      bl     650 &lt;printf@plt&gt;</pre>&#13;
<p class="indent">From the encoding of the <span class="literal">bl</span> instruction in <a href="ch12.xhtml#ch12fig11">Figure 12-11</a>, we see that the <span class="literal">w_offset</span> is the 26-bit value <span class="literal">0x3ffffab</span>. There are 4 bytes in a word, so this is equal to the 28-bit byte offset of <span class="literal">0xffffeac</span>. Adding the byte offset to the relative address of the instruction gives <span class="literal">0x00007a4</span> + <span class="literal">0xffffeac</span> = <span class="literal">0x0000650</span>. (Don’t forget that these are signed integers, so the carry from this addition is irrelevant.) This is the offset from this <span class="literal">bl</span> instruction to where the link to <span class="literal">printf</span> is located in the PLT.</p>&#13;
<p class="indent">When the program runs, the operating system also loads the GOT and the PLT for the program. During execution, if the program accesses an external variable, the operating system loads the library module where the variable is defined and enters its relative address in the GOT. When the program calls one of the functions in the PLT, if the function has not already been loaded, the operating system loads it, inserts its address into the program’s GOT, and adjusts the corresponding entry in the PLT accordingly.</p>&#13;
<p class="indent">I want to reemphasize that, as with the previous discussion of assemblers, this is only a rough overview of how linkers work. If you would like to learn more about linkers, I recommend John R. Levine’s <em>Linkers &amp; Loaders</em> (Morgan Kaufmann, 1999).</p>&#13;
<h3 class="h3" id="ch12lev1sec6"><strong>What You’ve Learned</strong></h3>&#13;
<div class="indL">&#13;
<p class="noindentin"><strong>Machine code</strong> The instruction bit patterns that control the CPU.</p>&#13;
<p class="noindentin"><strong>Assembly listing</strong> The machine code corresponding to each instruction in a program, optionally generated by the assembler.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_241"/><strong>Registers</strong> The number of the register is encoded in 5 bits.</p>&#13;
<p class="noindentin"><strong>Register size</strong> A single bit encodes whether the full 64 bits or the low-order 32 bits is used.</p>&#13;
<p class="noindentin"><strong>Immediate data</strong> A constant encoded within the instruction.</p>&#13;
<p class="noindentin"><strong>Address offset</strong> The distance from the referencing instruction to a memory address, which can be encoded within the referencing instruction.</p>&#13;
<p class="noindentin"><strong>Aliases</strong> The assembler can have more than one name for some instructions, to better show the intent of using the instruction.</p>&#13;
<p class="noindentin"><strong>Assembler</strong> A program that translates assembly language to machine code and creates a global symbol table.</p>&#13;
<p class="noindentin"><strong>Linker</strong> A program that resolves cross-references between the segments in the program and creates a procedure linkage table that is used by the operating system.</p>&#13;
</div>&#13;
<p class="indent">So far, all our programs have used sequential program flow and called subfunctions. In the next chapter, we’ll return to programming and you’ll learn about the other two necessary program flow constructs: repetition and two-way branching.<span epub:type="pagebreak" id="page_242"/></p>&#13;
</div>
</div>
</body></html>