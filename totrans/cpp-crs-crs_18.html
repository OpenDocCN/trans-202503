<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_480"/><span epub:type="pagebreak" id="page_481"/><strong><span class="big">15</span><br/>STRINGS</strong></h2>&#13;
<p class="quote"><em>If you talk to a man in a language he understands, that goes to his head. If you talk to him in his language, that goes to his heart.<br/>—Nelson Mandela</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The STL provides a special <em>string container</em> for human-language data, such as words, sentences, and markup languages. Available in the <code>&lt;string&gt;</code> header, the <code>std::basic_string</code> is a class template that you can specialize on a string’s underlying character type. As a sequential container, <code>basic_string</code> is essentially similar to a <code>vector</code> but with some special facilities for manipulating language.</p>&#13;
<p class="indent">STL <code>basic_string</code> provides major safety and feature improvements over C-style or null-terminated strings, and because human-language data inundates most modern programs, you’ll probably find <code>basic_string</code> indispensable.</p>&#13;
<h3 class="h3" id="ch15lev1sec1"><span epub:type="pagebreak" id="page_482"/><strong>std::string</strong></h3>&#13;
<p class="noindent">The STL provides four <code>basic_string</code> specializations in the <code>&lt;string&gt;</code> header. Each specialization implements a string using one of the fundamental character types that you learned about in <a href="ch02.xhtml#ch02">Chapter 2</a>:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::string</code> for <code>char</code> is used for character sets like ASCII.</li>&#13;
<li class="noindent"><code>std::wstring</code> for <code>wchar_t</code> is large enough to contain the largest character of the implementation’s locale.</li>&#13;
<li class="noindent"><code>std::u16string</code> for <code>char16_t</code> is used for character sets like UTF-16.</li>&#13;
<li class="noindent"><code>std::u32string</code> for <code>char32_t</code> is used for character sets like UTF-32.</li>&#13;
</ul>&#13;
<p class="indent">You’ll use the specialization with the appropriate underlying type. Because these specializations have the same interface, all the examples in this chapter will use <code>std::string</code>.</p>&#13;
<h4 class="h4" id="ch15lev2sec1"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <code>basic_string</code> container takes three template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The underlying character type, <code>T</code></li>&#13;
<li class="noindent">The underlying type’s traits, <code>Traits</code></li>&#13;
<li class="noindent">An allocator, <code>Alloc</code></li>&#13;
</ul>&#13;
<p class="indent">Of these, only <code>T</code> is required. The STL’s <code>std::char_traits</code> template class in the <code>&lt;string&gt;</code> header abstracts character and string operations from the underlying character type. Also, unless you plan on supporting a custom character type, you won’t need to implement your own type traits, because <code>char_traits</code> has specializations available for <code>char, wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code>. When the stdlib provides specializations for a type, you won’t need to provide it yourself unless you require some kind of exotic behavior.</p>&#13;
<p class="indent">Together, a <code>basic_string</code> specialization looks like this, where <code>T</code> is a character type:</p>&#13;
<pre>std::basic_string&lt;T, Traits=std::char_traits&lt;T&gt;, Alloc=std::allocator&lt;T&gt;&gt;</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In most cases, you’ll be dealing with one of the predefined specializations, especially <span class="codeitalic">string</span> or <span class="codeitalic">wstring</span>. However, if you need a custom allocator, you’ll need to specialize <span class="codeitalic">basic_string</span> appropriately.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>basic_string&lt;T&gt;</code> container supports the same constructors as <code>vector&lt;T&gt;</code>, plus additional convenience constructors for converting a C-style string. In other words, a <code>string</code> supports the constructors of <code>vector&lt;char&gt;</code>, a <code>wstring</code> supports the constructors of <code>vector&lt;wchar_t&gt;</code>, and so on. As with <code>vector</code>, use parentheses for all <code>basic_string</code> constructors except when you actually want an initializer list.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_483"/>You can default construct an empty string, or if you want to fill a <code>string</code> with a repeating character, you can use the fill constructor by passing a <code>size_t</code> and a <code>char</code>, as <a href="ch15.xhtml#ch15ex01">Listing 15-1</a> illustrates.</p>&#13;
<pre>#include &lt;string&gt;&#13;
TEST_CASE("std::string supports constructing") {&#13;
  SECTION("empty strings") {&#13;
    std::string cheese; <span class="ent">➊</span>&#13;
    REQUIRE(cheese.empty()); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("repeated characters") {&#13;
    std::string roadside_assistance(3, 'A'); <span class="ent">➌</span>&#13;
    REQUIRE(roadside_assistance == "AAA"); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex01"/><em>Listing 15-1: The default and fill constructors of <code>string</code></em></p>&#13;
<p class="indent">After you default construct a <code>string</code> <span class="ent">➊</span>, it contains no elements <span class="ent">➋</span>. If you want to fill the <code>string</code> with repeating characters, you can use the fill constructor by passing in the number of elements you want to fill and their value <span class="ent">➌</span>. The example fills a string with three <code>A</code> characters <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll learn about <span class="codeitalic">std::string</span> comparisons with <span class="codeitalic">operator==</span> later in the chapter. Because you generally handle C-style strings with raw pointers or raw arrays, <span class="codeitalic">operator==</span> returns true only when given the same object. However, for <span class="codeitalic">std::string</span>, <span class="codeitalic">operator==</span> returns true if the contents are equivalent. As you can see in <a href="ch15.xhtml#ch15ex01">Listing 15-1</a>, the comparison works even when one of the operands is a C-style string literal.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>string</code> constructor also offers two <code>const char*</code>-based constructors. If the argument points to a null-terminated <code>string</code>, the <code>string</code> constructor can determine the input’s length on its own. If the pointer does <em>not</em> point to a null-terminated string or if you only want to use the first part of a <code>string</code>, you can pass a length argument that informs the <code>string</code> constructor of how many elements to copy, as <a href="ch15.xhtml#ch15ex02">Listing 15-2</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::string supports constructing substrings ") {&#13;
  auto word = "gobbledygook"; <span class="ent">➊</span>&#13;
  REQUIRE(std::string(word) == "gobbledygook"); <span class="ent">➋</span>&#13;
  REQUIRE(std::string(word, 6) == "gobble"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex02"/><em>Listing 15-2: Constructing a <code>string</code> from C-style strings</em></p>&#13;
<p class="indent">You create a <code>const char*</code> called <code>word</code> pointing to the C-style string literal <code>gobbledygook</code> <span class="ent">➊</span>. Next, you construct a <code>string</code> by passing <code>word</code>. As expected, the resulting <code>string</code> contains <code>gobbledygook</code> <span class="ent">➋</span>. In the next test, you pass the number <code>6</code> as a second argument. This causes <code>string</code> to only take the first six characters of <code>word</code>, resulting in the <code>string</code> containing <code>gobble</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_484"/>Additionally, you can construct <code>string</code>s from other <code>string</code>s. As an STL container, <code>string</code> fully supports copy and move semantics. You can also construct a <code>string</code> from a <em>substring</em>—a contiguous subset of another string. <a href="ch15.xhtml#ch15ex03">Listing 15-3</a> illustrates these three constructors.</p>&#13;
<pre>TEST_CASE("std::string supports") {&#13;
  std::string word("catawampus"); <span class="ent">➊</span>&#13;
  SECTION("copy constructing") {&#13;
    REQUIRE(std::string(word) == "catawampus"); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("move constructing") {&#13;
    REQUIRE(std::string(move(word)) == "catawampus"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("constructing from substrings") {&#13;
    REQUIRE(std::string(word, 0, 3) == "cat"); <span class="ent">➍</span>&#13;
    REQUIRE(std::string(word, 4) == "wampus"); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex03"/><em>Listing 15-3: Copy, move, and substring construction of <code>string</code> objects</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In <a href="ch15.xhtml#ch15ex03">Listing 15-3</a>, <code>word</code> is in a moved-from state, which, you’ll recall from “Move Semantics” on <a href="ch04.xhtml#page_122">page 122</a>, means it can only be reassigned or destructed.</em></p>&#13;
</div>&#13;
<p class="indent">Here, you construct a <code>string</code> called <code>word</code> containing the characters <code>catawampus</code> <span class="ent">➊</span>. Copy construction yields another <code>string</code> containing a copy of the characters of <code>word</code> <span class="ent">➋</span>. Move construction steals the characters of <code>word</code>, resulting in a new <code>string</code> containing <code>catawampus</code> <span class="ent">➌</span>. Finally, you can construct a new <code>string</code> based on substrings. By passing <code>word</code>, a starting position of 0, and a length of 3, you construct a new <code>string</code> containing the characters <code>cat</code> <span class="ent">➍</span>. If you instead pass <code>word</code> and a starting position of 4 (without a length), you get all the characters from the fourth to the end of the original string, resulting in <code>wampus</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">The <code>string</code> class also supports literal construction with <code>std::string_</code><code>literals::operator""s</code>. The major benefit is notational convenience, but you can also use <code>operator""s</code> to embed null characters within a <code>string</code> easily, as <a href="ch15.xhtml#ch15ex04">Listing 15-4</a> illustrates.</p>&#13;
<pre>TEST_CASE("constructing a string with") {&#13;
  SECTION("std::string(char*) stops at embedded nulls") {&#13;
    std::string str("idioglossia\0ellohay!"); <span class="ent">➊</span>&#13;
    REQUIRE(str.length() == 11); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("operator\"\"s incorporates embedded nulls") {&#13;
    using namespace std::string_literals; <span class="ent">➌</span>&#13;
    auto str_lit = "idioglossia\0ellohay!"s; <span class="ent">➍</span>&#13;
    REQUIRE(str_lit.length() == 20); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex04"/><em>Listing 15-4: Constructing a <code>string</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_485"/>In the first test, you construct a <code>string</code> using the literal <code>idioglossia\0ellohay!</code> <span class="ent">➊</span>, which results in a <code>string</code> containing <code>idioglossia</code> <span class="ent">➋</span>, The remainder of the literal didn’t get copied into the <code>string</code> due to embedded nulls. In the second test, you bring in the <code>std::string_literals</code> namespace <span class="ent">➌</span> so you can use <code>operator""s</code> to construct a <code>string</code> from a literal directly <span class="ent">➍</span>. Unlike the <code>std::string</code> constructor <span class="ent">➊</span>, <code>operator""s</code> yields a string containing the entire literal—embedded null bytes and all <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab01">Table 15-1</a> summarizes the options for constructing a <code>string</code>. In this table, <code>c</code> is a <code>char, n</code> and <code>pos</code> are <code>size_t, str</code> is a <code>string</code> or a C-style string, <code>c_str</code> is a C-style string, and <code>beg</code> and <code>end</code> are input iterators.</p>&#13;
<p class="tabcap"><a id="ch15tab01"/><strong>Table 15-1:</strong> Supported <code>std::string</code> Constructors</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Constructor</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Produces</strong> a <span class="codestrong">string</span> <strong>containing</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>string()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">No characters.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>string(</code><span class="codestrong">n</span><code>,</code> <span class="codestrong">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">c</span> repeated <span class="codestrong">n</span> times.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>string(</code><span class="codestrong">str</span><code>,</code> <span class="codestrong">pos</span><code>, [</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The half-open range <span class="codestrong">pos</span> to <span class="codestrong">pos</span><code>+</code><span class="codestrong">n</span> of <span class="codestrong">str</span>. Substring extends from <span class="codestrong">pos</span> to <span class="codestrong">str</span>’s end if <span class="codestrong">n</span> is omitted.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>string(</code><span class="codestrong">c_str</span><code>, [</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A copy of <span class="codestrong">c_str</span>, which has length <span class="codestrong">n</span>. If <span class="codestrong">c_str</span> is null terminated, <span class="codestrong">n</span> defaults to the null-terminated string’s length.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>string(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A copy of the elements in the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>string(</code><span class="codestrong">str</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A copy of <span class="codestrong">str</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>string(move(</code><span class="codestrong">str</span><code>))</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The contents of <span class="codestrong">str</span>, which is in a moved-from state after construction.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>string{</code>  <span class="codestrong">c1</span><code>,</code> <span class="codestrong">c2</span><code>,</code> <span class="codestrong">c3</span> <code>}</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The characters <span class="codestrong">c1</span>, <span class="codestrong">c2</span>, and<span class="codestrong"> c3</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>"</code><span class="codestrong">my string literal</span><code>"s</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">A string containing the characters <code>my string literal</code>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec2"><strong><em>String Storage and Small String Optimizations</em></strong></h4>&#13;
<p class="noindent">Exactly like <code>vector, string</code> uses dynamic storage to store its constituent elements contiguously. Accordingly, <code>vector</code> and <code>string</code> have very similar copy/move-construction/assignment semantics. For example, copy operations are potentially more expensive than move operations because the contained elements reside in dynamic memory.</p>&#13;
<p class="indent">The most popular STL implementations have <em>small string optimizations (SSO)</em>. The SSO places the contents of a <code>string</code> within the object’s storage (rather than dynamic storage) if the contents are small enough. As a general rule, a <code>string</code> with fewer than 24 bytes is an SSO candidate. Implementers make this optimization because in many modern programs, most <code>string</code>s are short. (A <code>vector</code> doesn’t have any small optimizations.)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Practically, SSO affects moves in two ways. First, any references to the elements of a <code>string</code> will invalidate if the <code>string</code> moves. Second, moves are potentially slower for <code>string</code>s than <code>vector</code>s because <code>string</code>s need to check for SSO.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_486"/>A <code>string</code> has a <em>size</em> (or <em>length</em>) and a <em>capacity</em>. The size is the number of characters contained in the <code>string</code>, and the capacity is the number of characters that the string can hold before needing to resize.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab02">Table 15-2</a> contains methods for reading and manipulating the size and capacity of a <code>string</code>. In this table, <code>n</code> is a <code>size_t</code>. An asterisk (*) indicates that this operation invalidates raw pointers and iterators to the elements of <code>s</code> in at least some circumstances.</p>&#13;
<p class="tabcap"><a id="ch15tab02"/><strong>Table 15-2:</strong> Supported <code>std::string</code> Storage and Length Methods</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>true</code> if <span class="codestrong">s</span> contains no characters; otherwise <code>false</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The number of characters in <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.length()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Identical to <span class="codestrong">s</span><code>.size()</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.max_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum possible size of <span class="codestrong">s</span> (due to system/runtime limitations).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.capacity()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The number of characters <span class="codestrong">s</span> can hold before needing to resize.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.shrink_to_fit()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>void</code>; issues a non-binding request to reduce <span class="codestrong">s</span><code>.capacity()</code> to <span class="codestrong">s</span><code>.size()</code>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">s</span><code>.reserve([</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>void</code>; if <code>n &gt;</code>  <span class="codestrong">s</span><code>.capacity()</code>, resizes so <span class="codestrong">s</span> can hold at least <span class="codestrong">n</span> elements; otherwise, issues a non-binding request* to reduce <span class="codestrong">s</span><code>.capacity()</code> to <span class="codestrong">n</span> or <span class="codestrong">s</span><code>.size()</code>, whichever is greater.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At press time, the draft C++20 standard changes the behavior of the <code>reserve</code> method when its argument is less than the size of the <code>string</code>. This will match the behavior of <code>vector</code>, where there is no effect rather than being equivalent to invoking <code>shrink_to_fit</code>.</em></p>&#13;
</div>&#13;
<p class="indent">Note that the size and capacity methods of <code>string</code> match those of <code>vector</code> very closely. This is a direct result of the closeness of their storage models.</p>&#13;
<h4 class="h4" id="ch15lev2sec3"><strong><em>Element and Iterator Access</em></strong></h4>&#13;
<p class="noindent">Because <code>string</code> offers random-access iterators to contiguous elements, it accordingly exposes similar element- and iterator-access methods to <code>vector</code>.</p>&#13;
<p class="indent">For interoperation with C-style APIs, <code>string</code> also exposes a <code>c_str</code> method, which returns a non-modifiable, null-terminated version of the string as a <code>const char*</code>, as <a href="ch15.xhtml#ch15ex05">Listing 15-5</a> illustrates.</p>&#13;
<pre>TEST_CASE("string's c_str method makes null-terminated strings") {&#13;
  std::string word("horripilation"); <span class="ent">➊</span>&#13;
  auto as_cstr = word.c_str(); <span class="ent">➋</span>&#13;
  REQUIRE(as_cstr[0] ==  'h'); <span class="ent">➌</span>&#13;
  REQUIRE(as_cstr[1] ==  'o');&#13;
  REQUIRE(as_cstr[11] == 'o');&#13;
  REQUIRE(as_cstr[12] == 'n');&#13;
  REQUIRE(as_cstr[13] == '\0'); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex05"/><em>Listing 15-5: Extracting a null-terminated string from a <code>string</code></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_487"/>You construct a <code>string</code> called <code>word</code> containing the characters <code>horripilation</code> <span class="ent">➊</span> and use its <code>c_str</code> method to extract a null-terminated string called <code>as_cstr</code> <span class="ent">➋</span>. Because <code>as_cstr</code> is a <code>const char*</code>, you can use <code>operator[]</code> to illustrate that it contains the same characters as <code>word</code> <span class="ent">➌</span> and that it is null terminated <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <code>std::string</code> class also supports <code>operator[]</code>, which has the same behavior as with a C-style string.</em></p>&#13;
</div>&#13;
<p class="indent">Generally, <code>c_str</code> and <code>data</code> produce identical results except that references returned by <code>data</code> can be non-<code>const</code>. Whenever you manipulate a <code>string</code>, implementations usually ensure that the contiguous memory backing the <code>string</code> ends with a null terminator. The program in <a href="ch15.xhtml#ch15ex06">Listing 15-6</a> illustrates this behavior by printing the results of calling <code>data</code> and <code>c_str</code> alongside their addresses.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  std::string word("pulchritudinous");&#13;
  printf("c_str: %s at 0x%p\n", word.c_str(), word.c_str()); <span class="ent">➊</span>&#13;
  printf("data:  %s at 0x%p\n", word.data(), word.data()); <span class="ent">➋</span>&#13;
}&#13;
<span class="color1">--------------------------------------------------------------------------</span>&#13;
<span class="color1">c_str: pulchritudinous at 0x0000002FAE6FF8D0 <span class="ent">➊</span></span>&#13;
<span class="color1">data:  pulchritudinous at 0x0000002FAE6FF8D0 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch15ex06"/><em>Listing 15-6: Illustrating that <code>c_str</code> and <code>data</code> return equivalent addresses</em></p>&#13;
<p class="indent">Both <code>c_str</code> and <code>data</code> produce identical results because they point to the same addresses <span class="ent">➊ ➋</span>. Because the address is the beginning of a null-terminated <code>string, printf</code> yields identical output for both invocations.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab03">Table 15-3</a> lists the access methods of <code>string</code>. Note that <code>n</code> is a <code>size_t</code> in the table.</p>&#13;
<p class="tabcap"><a id="ch15tab03"/><strong>Table 15-3:</strong> Supported <code>std::string</code> Element and Iterator Access Methods</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.begin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.cbegin()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <code>const</code> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.end()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An iterator pointing to one past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.cend()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <code>const</code> iterator pointing to one past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.at(</code><span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference to element <span class="codestrong">n</span> of <span class="codestrong">s</span>. Throws <code>std::out_of_range</code> if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>[</code><span class="codestrong">n</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A reference to element <span class="codestrong">n</span> of <span class="codestrong">s</span>. Undefined behavior if <span class="codestrong">n</span> <code>&gt;</code> <span class="codestrong">s</span><code>.size()</code>. Also <span class="codestrong">s</span><code>[</code><span class="codestrong">s</span><code>.size()]</code> must be 0, so writing a non-zero value into this character is undefined behavior.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.front()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference to first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.back()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A reference to last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_488"/><span class="codestrong">s</span><code>.data()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A raw pointer to the first element if string is non-empty. For an empty string, returns a pointer to a null character.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s</span><code>.c_str()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a non-modifiable, null-terminated version of the contents of <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec4"><strong><em>String Comparisons</em></strong></h4>&#13;
<p class="noindent">Note that <code>string</code> supports comparisons with other strings and with raw C-style strings using the usual comparison operators. For example, the equality <code>operator==</code> returns <code>true</code> if the size and contents of the left and right size are equal, whereas the inequality <code>operator!=</code> returns the opposite. The remaining comparison operators perform <em>lexicographical comparison</em>, meaning they sort alphabetically where <em>A</em> &lt; <em>Z</em> &lt; <em>a</em> &lt; <em>z</em> and where, if all else is equal, shorter words are less than longer words (for example, <em>pal</em> &lt; <em>palindrome</em>). <a href="ch15.xhtml#ch15ex07">Listing 15-7</a> illustrates comparisons.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Technically, lexicographical comparison depends on the encoding of the <code>string</code>. It’s theoretically possible that a system could use a default encoding where the alphabet is in some completely jumbled order (such as the nearly obsolete EBCDIC encoding, which put lowercase letters before uppercase letters), which would affect <code>string</code> comparison. For ASCII-compatible encodings, you don’t need to worry since they imply the expected lexicographical behavior.</em></p>&#13;
</div>&#13;
<pre>TEST_CASE("std::string supports comparison with") {&#13;
  using namespace std::literals::string_literals; <span class="ent">➊</span>&#13;
  std::string word("allusion"); <span class="ent">➋</span>&#13;
  SECTION("operator== and !=") {&#13;
    REQUIRE(word == "allusion"); <span class="ent">➌</span>&#13;
    REQUIRE(word == "allusion"s); <span class="ent">➍</span>&#13;
    REQUIRE(word != "Allusion"s); <span class="ent">➎</span>&#13;
    REQUIRE(word != "illusion"s); <span class="ent">➏</span>&#13;
    REQUIRE_FALSE(word == "illusion"s); <span class="ent">➐</span>&#13;
  }&#13;
  SECTION("operator&lt;") {&#13;
    REQUIRE(word &lt; "illusion"); <span class="ent">➑</span>&#13;
    REQUIRE(word &lt; "illusion"s); <span class="ent">➒</span>&#13;
    REQUIRE(word &gt; "Illusion"s); <span class="ent">➓</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex07"/><em>Listing 15-7: The <code>string</code> class supports comparison</em></p>&#13;
<p class="indent">Here, you bring in the <code>std::literals::string_literals</code> namespace so you can easily construct a <code>string</code> with <code>operator""s</code> <span class="ent">➊</span>. You also construct a <code>string</code> called <code>word</code> containing the characters <code>allusion</code> <span class="ent">➋</span>. In the first set of tests, you examine <code>operator==</code> and <code>operator!=</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_489"/>You can see that <code>word</code> equals (<code>==</code>) <code>allusion</code> as both a C-style string <span class="ent">➌</span> and a <code>string</code> <span class="ent">➍</span>, but it doesn’t equal (<code>!=</code>) <code>string</code>s containing <code>Allusion</code> <span class="ent">➎</span> or <code>illusion</code> <span class="ent">➏</span>. As usual, <code>operator==</code> and <code>operator!=</code> always return opposite results <span class="ent">➐</span>.</p>&#13;
<p class="indent">The next set of tests uses <code>operator&lt;</code> to show that <code>allusion</code> is less than <code>illu</code><code>sion</code> <span class="ent">➑</span>, because <em>a</em> is lexicographically less than <em>i</em>. Comparisons work with C-style strings and <code>string</code>s <span class="ent">➒</span>. <a href="ch15.xhtml#ch15ex07">Listing 15-7</a> also shows that <code>Allusion</code> is less than <code>allusion</code> <span class="ent">➓</span> because <em>A</em> is lexicographically less than <em>a</em>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab04">Table 15-4</a> lists the comparison methods of <code>string</code>. Note that <code>other</code> is a <code>string</code> or <code>char*</code> C-style string in the table.</p>&#13;
<p class="tabcap"><a id="ch15tab04"/><strong>Table 15-4:</strong> Supported <code>std::string</code> Comparison Operators</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span>  <code>==</code>  <span class="codestrong">other</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>true</code> if <span class="codestrong">s</span> and <span class="codestrong">other</span> have identical characters and lengths; otherwise <code>false</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span>  <code>!=</code> <span class="codestrong">other</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The opposite of <code>operator==</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.compare(</code><span class="codestrong">other</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns 0 if <span class="codestrong">s</span>  <code>==</code>  <span class="codestrong">other</span>, a negative number if <span class="codestrong">s</span>  <code>&lt;</code>  <span class="codestrong">other</span>, and a positive number if <span class="codestrong">s</span>  <code>&gt;</code>  <span class="codestrong">other</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s</span>  <code>&lt;</code>  <span class="codestrong">other</span></p>&#13;
<p class="taba"><span class="codestrong">s</span>  <code>&gt;</code>  <span class="codestrong">other</span></p>&#13;
<p class="taba"><span class="codestrong">s</span>  <code>&lt;=</code>  <span class="codestrong">other</span></p>&#13;
<p class="taba"><span class="codestrong">s</span>  <code>&gt;=</code>  <span class="codestrong">other</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">The result of the corresponding comparison operation, according to lexicographical sort</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec5"><strong><em>Manipulating Elements</em></strong></h4>&#13;
<p class="noindent">For manipulating elements, <code>string</code> has <em>a lot</em> of methods. It supports all the methods of <code>vector&lt;char&gt;</code> plus many others useful to manipulating human-language data.</p>&#13;
<h5 class="h5" id="ch15lev3sec1"><strong>Adding Elements</strong></h5>&#13;
<p class="noindent">To add elements to a <code>string</code>, you can use <code>push_back</code>, which inserts a single character at the end. When you want to insert more than one character to the end of a <code>string</code>, you can use <code>operator+=</code> to append a character, a null-terminated <code>char*</code> string, or a <code>string</code>. You can also use the <code>append</code> method, which has three overloads. First, you can pass a <code>string</code> or a null-terminated <code>char*</code> string, an optional offset into that <code>string</code>, and an optional number of characters to append. Second, you can pass a length and a <code>char</code>, which will append that number of <code>char</code>s to the string. Third, you can append a half-open range. <a href="ch15.xhtml#ch15ex08">Listing 15-8</a> illustrates all of these operations.</p>&#13;
<pre>TEST_CASE("std::string supports appending with") {&#13;
  std::string word("butt"); <span class="ent">➊</span>&#13;
  SECTION("push_back") {&#13;
    word.push_back('e'); <span class="ent">➋</span>&#13;
    REQUIRE(word == "butte");&#13;
  }&#13;
  SECTION("operator+=") {&#13;
    word += "erfinger"; <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_490"/>    REQUIRE(word == "butterfinger");&#13;
  }&#13;
  SECTION("append char") {&#13;
    word.append(1, 's'); <span class="ent">➍</span>&#13;
    REQUIRE(word == "butts");&#13;
  }&#13;
  SECTION("append char*") {&#13;
    word.append("stockings", 5); <span class="ent">➎</span>&#13;
    REQUIRE(word == "buttstock");&#13;
  }&#13;
  SECTION("append (half-open range)") {&#13;
    std::string other("onomatopoeia"); <span class="ent">➏</span>&#13;
    word.append(other.begin(), other.begin()+2); <span class="ent">➐</span>&#13;
    REQUIRE(word == "button");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex08"/><em>Listing 15-8: Appending to a <code>string</code></em></p>&#13;
<p class="indent">To begin, you initialize a <code>string</code> called <code>word</code> containing the characters <code>butt</code> <span class="ent">➊</span>. In the first test, you invoke <code>push_back</code> with the letter <code>e</code> <span class="ent">➋</span>, which yields <code>butte</code>. Next, you add <code>erfinger</code> to <code>word</code> using <code>operator+=</code> <span class="ent">➌</span>, yielding <code>butterfinger</code>. In the first invocation of <code>append</code>, you append a single <code>s</code> <span class="ent">➍</span> to yield <code>butts</code>. (This setup works just like <code>push_back</code>.) A second overload of <code>append</code> allows you to provide a <code>char*</code> and a length. By providing <code>stockings</code> and length <code>5</code>, you add <code>stock</code> to <code>word</code> to yield <code>buttstock</code> <span class="ent">➎</span>. Because <code>append</code> works with half-open ranges, you can also construct a <code>string</code> called <code>other</code> containing the characters <code>onomatopoeia</code> <span class="ent">➏</span> and append the first two characters via a half-open range to yield <code>button</code> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall from “Test Cases and Sections” on <a href="ch10.xhtml#page_308">page 308</a> that each <code>SECTION</code> of a Catch unit test runs independently, so modifications to <code>word</code> are independent of each other: the setup code resets <code>word</code> for each test.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec2"><strong>Removing Elements</strong></h5>&#13;
<p class="noindent">To remove elements from a <code>string</code>, you have several options. The simplest method is to use <code>pop_back</code>, which follows <code>vector</code> in removing the last character from a <code>string</code>. If you want to instead remove all the characters (to yield an empty <code>string</code>), use the <code>clear</code> method. When you need more precision in removing elements, use the <code>erase</code> method, which provides several overloads. You can provide an index and a length, which removes the corresponding characters. You can also provide an iterator to remove a single element or a half-open range to remove many. <a href="ch15.xhtml#ch15ex09">Listing 15-9</a> illustrates removing elements from a <code>string</code>.</p>&#13;
<pre>TEST_CASE("std::string supports removal with") {&#13;
  std::string word("therein"); <span class="ent">➊</span>&#13;
  SECTION("pop_back") {&#13;
    word.pop_back();&#13;
    word.pop_back(); <span class="ent">➋</span>&#13;
    REQUIRE(word == "there");&#13;
  }&#13;
<span epub:type="pagebreak" id="page_491"/>  SECTION("clear") {&#13;
    word.clear(); <span class="ent">➌</span>&#13;
    REQUIRE(word.empty());&#13;
  }&#13;
  SECTION("erase using half-open range") {&#13;
    word.erase(word.begin(), word.begin()+3); <span class="ent">➍</span>&#13;
    REQUIRE(word == "rein");&#13;
  }&#13;
  SECTION("erase using an index and length") {&#13;
    word.erase(5, 2);&#13;
    REQUIRE(word == "there"); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex09"/><em>Listing 15-9: Removing elements from a <code>string</code></em></p>&#13;
<p class="indent">You construct a <code>string</code> called <code>word</code> containing the characters <code>therein</code> <span class="ent">➊</span>. In the first test, you call <code>pop_back</code> twice to first remove the letter <code>n</code> followed by the letter <code>i</code> so <code>word</code> contains the characters <code>there</code> <span class="ent">➋</span>. Next, you invoke <code>clear</code>, which removes all the characters from <code>word</code> so it’s <code>empty</code> <span class="ent">➌</span>. The last two tests use <code>erase</code> to remove some subset of the characters in <code>word</code>. In the first usage, you remove the first three characters with a half-open range so <code>word</code> contains <code>rein</code> <span class="ent">➍</span>. In the second, you remove the characters starting at index 5 (<code>i</code> in <code>therein</code>) and extending two characters <span class="ent">➎</span>. Like the first test, this yields the characters <code>there</code>.</p>&#13;
<h5 class="h5" id="ch15lev3sec3"><strong>Replacing Elements</strong></h5>&#13;
<p class="noindent">To insert and remove elements simultaneously, use <code>string</code> to expose the <code>replace</code> method, which has many overloads.</p>&#13;
<p class="indent">First, you can provide a half-open range and a null-terminated <code>char*</code> or a <code>string</code>, and <code>replace</code> will perform a simultaneous <code>erase</code> of all the elements within the half-open range and an <code>insert</code> of the provided <code>string</code> where the range used to be. Second, you can provide two half-open ranges, and <code>replace</code> will insert the second range instead of a <code>string</code>.</p>&#13;
<p class="indent">Instead of replacing a range, you can use either an index or a single iterator and a length. You can supply a new half-open range, a character and a size, or a <code>string</code>, and <code>replace</code> will substitute new elements over the implied range. <a href="ch15.xhtml#ch15ex10">Listing 15-10</a> demonstrates some of these possibilities.</p>&#13;
<pre>TEST_CASE("std::string replace works with") {&#13;
  std::string word("substitution"); <span class="ent">➊</span>&#13;
  SECTION("a range and a char*") {&#13;
    word.replace(word.begin()+9, word.end(), "e"); <span class="ent">➋</span>&#13;
    REQUIRE(word == "substitute");&#13;
  }&#13;
  SECTION("two ranges") {&#13;
    std::string other("innuendo");&#13;
    word.replace(word.begin(), word.begin()+3,&#13;
                 other.begin(), other.begin()+2); <span class="ent">➌</span>&#13;
    REQUIRE(word == "institution");&#13;
  }&#13;
<span epub:type="pagebreak" id="page_492"/>  SECTION("an index/length and a string") {&#13;
    std::string other("vers");&#13;
    word.replace(3, 6, other); <span class="ent">➍</span>&#13;
    REQUIRE(word == "subversion");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex10"/><em>Listing 15-10: Replacing elements of a <code>string</code></em></p>&#13;
<p class="indent">Here, you construct a <code>string</code> called <code>word</code> containing <code>substitution</code> <span class="ent">➊</span>. In the first test, you replace all the characters from index 9 to the end with the letter <code>e</code>, resulting in the word <code>substitute</code> <span class="ent">➋</span>. Next, you replace the first three letters of <code>word</code> with the first two letters of a <code>string</code> containing <code>innuendo</code> <span class="ent">➌</span>, resulting in <code>institution</code>. Finally, you use an alternate way of specifying the target sequence with an index and a length to replace the characters <code>stitut</code> with the characters <code>vers</code>, yielding <code>subversion</code> <span class="ent">➍</span>.</p>&#13;
<p class="indent">The <code>string</code> class offers a <code>resize</code> method to manually set the length of <code>string</code>. The <code>resize</code> method takes two arguments: a new length and an optional <code>char</code>. If the new length of <code>string</code> is smaller, <code>resize</code> ignores the <code>char</code>. If the new length of <code>string</code> is larger, <code>resize</code> appends the <code>char</code> the implied number of times to achieve the desired length. <a href="ch15.xhtml#ch15ex11">Listing 15-11</a> illustrates the <code>resize</code> method.</p>&#13;
<pre>TEST_CASE("std::string resize") {&#13;
  std::string word("shamp"); <span class="ent">➊</span>&#13;
  SECTION("can remove elements") {&#13;
    word.resize(4); <span class="ent">➋</span>&#13;
    REQUIRE(word == "sham");&#13;
  }&#13;
  SECTION("can add elements") {&#13;
    word.resize(7, 'o'); <span class="ent">➌</span>&#13;
    REQUIRE(word == "shampoo");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex11"/><em>Listing 15-11: Resizing a <code>string</code></em></p>&#13;
<p class="indent">You construct a <code>string</code> called <code>word</code> containing the characters <code>shamp</code> <span class="ent">➊</span>. In the first test, you resize <code>word</code> to length <code>4</code> so it contains <code>sham</code> <span class="ent">➋</span>. In the second, you <code>resize</code> to a length of 7 and provide the optional character <code>o</code> as the value to extend <code>word</code> with <span class="ent">➌</span>. This results in <code>word</code> containing <code>shampoo</code>.</p>&#13;
<p class="indent">The “Constructing” section on <a href="ch15.xhtml#page_482">page 482</a> explained a substring constructor that can extract contiguous sequences of characters to create a new <code>s</code><code>tring</code>. You can also generate substrings using the <code>substr</code> method, which takes two optional arguments: a position argument and a length. The position defaults to 0 (the beginning of the <code>string</code>), and the length defaults to the remainder of the <code>string</code>. <a href="ch15.xhtml#ch15ex12">Listing 15-12</a> illustrates how to use <code>substr</code>.</p>&#13;
<pre>TEST_CASE("std::string substr with") {&#13;
  std::string word("hobbits"); <span class="ent">➊</span>&#13;
  SECTION("no arguments copies the string") {&#13;
<span epub:type="pagebreak" id="page_493"/>    REQUIRE(word.substr() == "hobbits"); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("position takes the remainder") {&#13;
    REQUIRE(word.substr(3) == "bits"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("position/index takes a substring") {&#13;
    REQUIRE(word.substr(3, 3) == "bit"); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex12"/><em>Listing 15-12: Extracting substrings from a <code>string</code></em></p>&#13;
<p class="indent">You declare a <code>string</code> called <code>word</code> containing <code>hobbits</code> <span class="ent">➊</span>. If you invoke <code>sub</code><code>str</code> with no arguments, you simply copy the <code>string</code> <span class="ent">➋</span>. When you provide the position argument <code>3, substr</code> extracts the substring beginning at element 3 and extending to the end of the <code>string</code>, yielding <code>bits</code> <span class="ent">➌</span>. Finally, when you provide a position (3) and a length (3), you instead get <code>bit</code> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec4"><strong>Summary of string Manipulation Methods</strong></h5>&#13;
<p class="noindent"><a href="ch15.xhtml#ch15tab05">Table 15-5</a> lists many of the insertion and deletion methods of <code>string</code>. In this table, <code>str</code> is a string or a C-style <code>char*</code> string, <code>p</code> and <code>n</code> are <code>size_t, ind</code> is a <code>size_t</code> index or an iterator into <code>s, n</code> and <code>i</code> are a <code>size_t, c</code> is a <code>char</code>, and <code>beg</code> and <code>end</code> are iterators. An asterisk (*) indicates that this operation invalidates raw pointers and iterators to <code>v</code>’s elements in at least some circumstances.</p>&#13;
<p class="tabcap"><a id="ch15tab05"/><strong>Table 15-5:</strong> Supported <code>std::string</code> Element Manipulation Methods</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.insert(</code><span class="codestrong">ind</span><code>,</code> <span class="codestrong">str</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts the <span class="codestrong">n</span> elements of <span class="codestrong">str</span>, starting at <span class="codestrong">p</span>, into <span class="codestrong">s</span> just before <span class="codestrong">ind</span>. If no <span class="codestrong">n</span> supplied, inserts the entire <code>string</code> or up to the first null of a <code>char*</code>; <span class="codestrong">p</span> defaults to 0.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.insert(</code><span class="codestrong">ind</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts <span class="codestrong">n</span> copies of <span class="codestrong">c</span> just before <span class="codestrong">ind</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.insert(</code><span class="codestrong">ind</span><code>,</code> <span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span> just before <span class="codestrong">ind</span>. *</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.append(</code><span class="codestrong">str</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Equivalent to <span class="codestrong">s</span><code>.insert(</code><span class="codestrong">s</span><code>.end(),</code> <span class="codestrong">str</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">n</span><code>])</code>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.append(</code><span class="codestrong">n</span><code>,</code> <span class="codestrong">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Equivalent to <span class="codestrong">s</span><code>.insert(</code><span class="codestrong">s</span><code>.end(),</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">c</span><code>)</code>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.append(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Appends the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span> to the end of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span> <code>+=</code> <span class="codestrong">c</span><br/><span class="codestrong">s</span> <code>+=</code> <span class="codestrong">str</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Appends <span class="codestrong">c</span> or <span class="codestrong">str</span> to the end of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.push_back(</code><span class="codestrong">c</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Appends <span class="codestrong">c</span> to the end of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.clear()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all characters from <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.erase([</code><span class="codestrong">i</span><code>], [</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes <span class="codestrong">n</span> characters starting at position <span class="codestrong">i</span>; <span class="codestrong">i</span> defaults to 0, and <span class="codestrong">n</span> defaults to the remainder of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.erase(</code><span class="codestrong">itr</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the element pointed to by <span class="codestrong">itr</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.erase(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Erases the elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.pop_back()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the last element of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><span epub:type="pagebreak" id="page_494"/><p class="taba"><span class="codestrong">s</span><code>.resize(</code><span class="codestrong">n</span><code>,</code><code>[</code><span class="codestrong">c</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Resizes the string so it contains <span class="codestrong">n</span> characters. If this operation increases the string’s length, it adds copies of <span class="codestrong">c</span>, which defaults to 0.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.replace(</code><span class="codestrong">i</span><code>,</code> <span class="codestrong">n1</span><code>,</code> <span class="codestrong">str</span><code>,</code> <code>[</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">n2</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the <span class="codestrong">n1</span> characters starting at index <span class="codestrong">i</span> with the <span class="codestrong">n2</span> elements in <span class="codestrong">str</span> starting at <span class="codestrong">p</span>. By default, <span class="codestrong">p</span> is 0 and <span class="codestrong">n2</span> is <span class="codestrong">str</span><code>.length()</code>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.replace(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>,</code> <span class="codestrong">str</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span> with <span class="codestrong">str</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.replace(</code><span class="codestrong">p</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">str</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces from index <span class="codestrong">p</span> to <span class="codestrong">p+n</span> with <span class="codestrong">str</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.replace(</code><span class="codestrong">beg1</span><code>,</code> <span class="codestrong">end1</span><code>,</code> <span class="codestrong">beg2</span><code>,</code> <span class="codestrong">end2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the half-open range <span class="codestrong">beg1</span> to <span class="codestrong">end1</span> with the half-open range <span class="codestrong">beg2</span> to <span class="codestrong">end2</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.replace(</code><span class="codestrong">ind</span><code>,</code> <span class="codestrong">c</span><code>, [</code><span class="codestrong">n</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces <span class="codestrong">n</span> elements starting at <span class="codestrong">ind</span> with <span class="codestrong">c</span>s.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.replace(</code><span class="codestrong">ind</span><code>,</code> <span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces elements starting at <span class="codestrong">ind</span> with the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.substr([</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">c</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the substring starting at <span class="codestrong">p</span> with length <span class="codestrong">c</span>. By default, <span class="codestrong">p</span> is 0 and <span class="codestrong">c</span> is the remainder of the string.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s1</span><code>.swap(</code><span class="codestrong">s2</span><code>)</code><br/>&#13;
<code>swap(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges the contents of <span class="codestrong">s1</span> and <span class="codestrong">s2</span>.*</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec6"><strong><em>Search</em></strong></h4>&#13;
<p class="noindent">In addition to the preceding methods, <code>string</code> offers several <em>search methods</em>, which enable you to locate substrings and characters that you’re interested in. Each method performs a particular kind of search, so which you choose depends on the particulars of the application.</p>&#13;
<h5 class="h5" id="ch15lev3sec5"><strong>find</strong></h5>&#13;
<p class="noindent">The first method <code>string</code> offers is <code>find</code>, which accepts a <code>string</code>, a C-style <code>string</code>, or a <code>char</code> as its first argument. This argument is an element that you want to locate within <code>this</code>. Optionally, you can provide a second <code>size_t</code> position argument that tells <code>find</code> where to start looking. If <code>find</code> fails to locate the substring, it returns the special <code>size_t</code>-valued, constant, <code>static</code> member <code>std::string::npos</code>. <a href="ch15.xhtml#ch15ex13">Listing 15-13</a> illustrates the <code>find</code> method.</p>&#13;
<pre>TEST_CASE("std::string find") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string word("pizzazz"); <span class="ent">➊</span>&#13;
  SECTION("locates substrings from strings") {&#13;
    REQUIRE(word.find("zz"s) == 2); // pi(z)zazz <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("accepts a position argument") {&#13;
    REQUIRE(word.find("zz"s, 3) == 5); // pizza(z)z <span class="ent">➌</span>&#13;
  }&#13;
<span epub:type="pagebreak" id="page_495"/>  SECTION("locates substrings from char*") {&#13;
    REQUIRE(word.find("zaz") == 3); // piz(z)azz <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("returns npos when not found") {&#13;
    REQUIRE(word.find('x') == std::string::npos); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex13"/><em>Listing 15-13: Finding substrings within a <code>string</code></em></p>&#13;
<p class="indent">Here, you construct the <code>string</code> called <code>word</code> containing <code>pizzazz</code> <span class="ent">➊</span>. In the first test, you invoke <code>find</code> with a <code>string</code> containing <code>zz</code>, which returns <code>2</code> <span class="ent">➋</span>, the index of the first <em>z</em> in <code>pi</code><code>z</code><code>zazz</code>. When you provide a position argument of <code>3</code> corresponding to the second <em>z</em> in <code>piz</code><code>z</code><code>azz, find</code> locates the second <em>zz</em> beginning at <code>5</code> <span class="ent">➌</span>. In the third test, you use the C-style string <code>zaz</code>, and <code>find</code> returns 3, again corresponding to the second <em>z</em> in <code>piz</code><code>z</code><code>azz</code> <span class="ent">➍</span>. Finally, you attempt to find the character <em>x</em>, which doesn’t appear in <code>pizzazz</code>, so <code>find</code> returns <code>std::string::npos</code> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec6"><strong>rfind</strong></h5>&#13;
<p class="noindent">The <code>rfind</code> method is an alternative to <code>find</code> that takes the same arguments but searches <em>in reverse</em>. You might want to use this functionality if, for example, you were looking for particular punctuation at the end of a <code>string</code>, as <a href="ch15.xhtml#ch15ex14">Listing 15-14</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::string rfind") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string word("pizzazz"); <span class="ent">➊</span>&#13;
  SECTION("locates substrings from strings") {&#13;
    REQUIRE(word.rfind("zz"s) == 5); // pizza(z)z <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("accepts a position argument") {&#13;
    REQUIRE(word.rfind("zz"s, 3) == 2); // pi(z)zazz <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("locates substrings from char*") {&#13;
    REQUIRE(word.rfind("zaz") == 3); // piz(z)azz <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("returns npos when not found") {&#13;
    REQUIRE(word.rfind('x') == std::string::npos); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex14"/><em>Listing 15-14: Finding substrings in reverse within a <code>string</code></em></p>&#13;
<p class="indent">Using the same <code>word</code> <span class="ent">➊</span>, you use the same arguments as in <a href="ch15.xhtml#ch15ex13">Listing 15-13</a> to test <code>rfind</code>. Given <code>zz, rfind</code> returns <code>5</code>, the second to last <em>z</em> in <code>pizza</code><code>z</code><code>z</code> <span class="ent">➋</span>. When you provide the positional argument <code>3, rfind</code> instead returns the first <em>z</em> in <code>pi</code><code>z</code><code>zazz</code> <span class="ent">➌</span>. Because there’s only one occurrence of the substring <code>zaz, rfind</code> returns the same position as <code>find</code> <span class="ent">➍</span>. Also like <code>find, rfind</code> returns <code>std::string::npos</code> when given <code>x</code> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec7"><strong>find_*_of</strong></h5>&#13;
<p class="noindent">Whereas <code>find</code> and <code>rfind</code> locate exact subsequences in a <code>string</code>, a family of related functions finds the first character contained in a given argument.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_496"/>The <code>find_first_of</code> function accepts a <code>string</code> and locates the first character in this contained in the argument. Optionally, you can provide a <code>size_t</code> position argument to indicate to <code>find_first_of</code> where to start in the string. If <code>find_first_of</code> cannot find a matching character, it will return <code>std::string::npos</code>. <a href="ch15.xhtml#ch15ex15">Listing 15-15</a> illustrates the <code>find_first_of</code> function.</p>&#13;
<pre>TEST_CASE("std::string find_first_of") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string sentence("I am a Zizzer-Zazzer-Zuzz as you can plainly see."); <span class="ent">➊</span>&#13;
  SECTION("locates characters within another string") {&#13;
    REQUIRE(sentence.find_first_of("Zz"s) == 7); // (Z)izzer <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("accepts a position argument") {&#13;
    REQUIRE(sentence.find_first_of("Zz"s, 11) == 14); // (Z)azzer <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("returns npos when not found") {&#13;
    REQUIRE(sentence.find_first_of("Xx"s) == std::string::npos); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex15"/><em>Listing 15-15: Finding the first element from a set within a <code>string</code></em></p>&#13;
<p class="indent">The <code>string</code> called <code>sentence</code> contains <code>I am a Zizzer-Zazzer-Zuzz as you</code> <code>can plainly see.</code> <span class="ent">➊</span>. Here, you invoke <code>find_first_of</code> with the string <code>Zz</code>, which matches both lowercase and uppercase <em>z</em>. This returns <code>7</code>, which corresponds to the first <code>Z</code> in <code>sentence, Z</code><code>izzer</code> <span class="ent">➋</span>. In the second test, you again provide the string <code>Zz</code> but also pass the position argument <code>11</code>, which corresponds to the <code>e</code> in <code>Zizz</code><code>e</code><code>r</code>. This results in <code>14</code>, which corresponds to the <code>Z</code> in <code>Z</code><code>azzer</code> <span class="ent">➌</span>. Finally, you invoke <code>find_first_of</code> with <code>Xx</code>, which results in <code>std::string::npos</code> because <code>sentence</code> doesn’t contain an <code>x</code> (or an <code>X</code>) <span class="ent">➍</span>.</p>&#13;
<p class="indent">A <code>string</code> offers three <code>find_first_of</code> variations:</p>&#13;
<ul>&#13;
<li class="noindent"><code>find_first_not_of</code> returns the first character <em>not</em> contained in the <code>string</code> argument. Rather than providing a <code>string</code> containing the elements you want to find, you provide a <code>string</code> of characters you <em>don’t</em> want to find.</li>&#13;
<li class="noindent"><code>find_last_of</code> performs matching in reverse; rather than searching from the beginning of the <code>string</code> or from the position argument and proceeding to the end, <code>find_last_of</code> begins at the end of the <code>string</code> or from the position argument and proceeds to the beginning.</li>&#13;
<li class="noindent"><code>find_last_not_of</code> combines the two prior variations: you pass a <code>string</code> containing elements you don’t want to find, and <code>find_last_not_of</code> searches in reverse.</li>&#13;
</ul>&#13;
<p class="indent">Your choice of <code>find</code> function boils down to what your algorithmic requirements are. Do you need to search from the back of a <code>string</code>, say for a punctuation mark? If so, use <code>find_last_of</code>. Are you looking for the first space in a <code>string</code>? If so, use <code>find_first_of</code>. Do you want to invert your search and look for the first element that is not a member of some set? Then use the alternatives <code>find_first_not_of</code> and <code>find_last_not_of</code>, depending on whether you want to start from the beginning or end of the <code>string</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_497"/><a href="ch15.xhtml#ch15ex16">Listing 15-16</a> illustrates these three <code>find_first_of</code> variations.</p>&#13;
<pre>TEST_CASE("std::string") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string sentence("I am a Zizzer-Zazzer-Zuzz as you can plainly see."); <span class="ent">➊</span>&#13;
  SECTION("find_last_of finds last element within another string") {&#13;
    REQUIRE(sentence.find_last_of("Zz"s) == 24); // Zuz(z) <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("find_first_not_of finds first element not within another string") {&#13;
    REQUIRE(sentence.find_first_not_of(" -IZaeimrz"s) == 22); // Z(u)zz <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("find_last_not_of finds last element not within another string") {&#13;
    REQUIRE(sentence.find_last_not_of(" .es"s) == 43); // plainl(y) <span class="ent">➍</span>&#13;
     }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex16"/><em>Listing 15-16: Alternatives to the <code>find_first_of</code> method of <code>string</code></em></p>&#13;
<p class="indent">Here, you initialize the same <code>sentence</code> as in <a href="ch15.xhtml#ch15ex15">Listing 15-15</a> <span class="ent">➊</span>. In the first test, you use <code>find_last_of</code> on <code>Zz</code>, which searches in reverse for any <em>z</em> or <em>Z</em> and returns <code>24</code>, the last <em>z</em> in the sentence <code>Zuz</code><code>z</code> <span class="ent">➋</span>. Next, you use <code>find_first_not_of</code> and pass a farrago of characters (not including the letter <em>u</em>), which results in <code>22</code>, the position of the first <em>u</em> in <code>Z</code><code>u</code><code>zz</code> <span class="ent">➌</span>. Finally, you use <code>find_last_not_of</code> to find the last character not equal to space, period, <em>e</em>, or <em>s</em>. This results in <code>43</code>, the position of <em>y</em> in <code>plainl</code><code>y</code> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec8"><strong>Summary of string Search Methods</strong></h5>&#13;
<p class="noindent"><a href="ch15.xhtml#ch15tab06">Table 15-6</a> lists many of the search methods for <code>string</code>. Note that <code>s2</code> is a string; <code>cstr</code> is a C-style <code>char*</code> string; <code>c</code> is a <code>char</code>; and <code>n, l</code>, and <code>pos</code> are <code>size_t</code> in the table.</p>&#13;
<p class="tabcap"><a id="ch15tab06"/><strong>Table 15-6:</strong> Supported <code>std::string</code> Search Algorithms</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Searches</strong> <span class="codestrong">s</span> <strong>starting at</strong> <span class="codestrong">p</span> <strong>and returns the position of the . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find(</code><span class="codestrong">s2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First substring equal to <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find(</code><span class="codestrong">cstr</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">l</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First substring equal to the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find(</code><span class="codestrong">c</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.rfind(</code><span class="codestrong">s2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last substring equal to <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to <code>npos</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.rfind(</code><span class="codestrong">cstr</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">l</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last substring equal to the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to <code>npos</code>; <code>l</code> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.rfind(</code><span class="codestrong">c</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to <code>npos</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find_first_of(</code><span class="codestrong">s2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find_first_of(</code><span class="codestrong">cstr</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">l</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First character contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <code>l</code> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find_first_of(</code><span class="codestrong">c</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find_last_of(</code><span class="codestrong">s2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find_last_of(</code><span class="codestrong">cstr</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">l</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last character contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find_last_of(</code><span class="codestrong">c</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find_first_not_of(</code><span class="codestrong">s2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character not contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find_first_not_of(</code><span class="codestrong">cstr</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">l</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First character not contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find_first_not_of(</code><span class="codestrong">c</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_498"/>First character not equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><code>.find_last_not_of(</code><span class="codestrong">s2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character not contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><code>.find_last_not_of(</code><span class="codestrong">cstr</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">l</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last character not contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s</span><code>.find_last_not_of(</code><span class="codestrong">c</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Last character not equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec7"><strong><em>Numeric Conversions</em></strong></h4>&#13;
<p class="noindent">The STL provides functions for converting between <code>string</code> or <code>wstring</code> and the fundamental numeric types. Given a numeric type, you can use the <code>std::to_string</code> and <code>std::to_wstring</code> functions to generate its <code>string</code> or <code>wstring</code> representation. Both functions have overloads for all the numeric types. <a href="ch15.xhtml#ch15ex17">Listing 15-17</a> illustrates <code>string</code> and <code>wstring</code>.</p>&#13;
<pre>TEST_CASE("STL string conversion function") {&#13;
  using namespace std::literals::string_literals;&#13;
  SECTION("to_string") {&#13;
    REQUIRE("8675309"s == std::to_string(8675309)); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("to_wstring") {&#13;
    REQUIRE(L"109951.1627776"s == std::to_wstring(109951.1627776)); <span class="ent">➋</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex17"/><em>Listing 15-17: Numeric conversion functions of <code>string</code></em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Thanks to the inherent inaccuracy of the double type, the second unit test</em> <span class="ent">➋</span> <em>might fail on your system.</em></p>&#13;
</div>&#13;
<p class="indent">The first example uses <code>to_string</code> to convert the <code>int 8675309</code> into a <code>string</code> <span class="ent">➊</span>; the second example uses <code>to_wstring</code> to convert the <code>double 109951.1627776</code> into a <code>wstring</code> <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_499"/>You can also convert the other way, going from a <code>string</code> or <code>wstring</code> to a numeric type. Each numeric conversion function accepts a <code>string</code> or <code>wstring</code> containing a string-encoded number as its first argument. Next, you can provide an optional pointer to a <code>size_t</code>. If provided, the conversion function will write the index of the last character it was able to convert (or the length of the input <code>string</code> if it decoded all characters). By default, this index argument is <code>nullptr</code>, in which case the conversion function doesn’t write the index. When the target type is integral, you can provide a third argument: an <code>int</code> corresponding to the base of the encoded <code>string</code>. This base argument is optional and defaults to 10.</p>&#13;
<p class="indent">Each conversion function throws <code>std::invalid_argument</code> if no conversion could be performed and throws <code>std::out_of_range</code> if the converted value is out of range for the corresponding type.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab07">Table 15-7</a> lists each of these conversion functions along with its target type. In this table, <code>s</code> is a string. If <code>p</code> is not <code>nullptr</code>, the conversion function will write the position of the first unconverted character in <code>s</code> to the memory pointed to by <code>p</code>. If all characters are encoded, returns the length of <code>s</code>. Here, <code>b</code> is the number’s base representation in <code>s</code>. Note that <code>p</code> defaults to <code>nullptr</code>, and <code>b</code> defaults to 10.</p>&#13;
<p class="tabcap"><a id="ch15tab07"/><strong>Table 15-7:</strong> Supported Numeric Conversion Functions for <code>std::string</code> and <code>std::wstring</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Converts</strong> <code>s</code> to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>stoi(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">b</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An <code>int</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>stol(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">b</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <code>long</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>stoll(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">b</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <code>long long</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>stoul(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">b</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An <code>unsigned long</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>stoull(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>], [</code><span class="codestrong">b</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An <code>unsigned long long</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>stof(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <code>float</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>stod(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <code>double</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>stold(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <code>long double</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>to_string(</code><span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <code>string</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>to_wstring(</code><span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">A <code>wstring</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex18">Listing 15-18</a> illustrates several numeric conversion functions.</p>&#13;
<pre>TEST_CASE("STL string conversion function") {&#13;
  using namespace std::literals::string_literals;&#13;
  SECTION("stoi") {&#13;
    REQUIRE(std::stoi("8675309"s) == 8675309); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("stoi") {&#13;
    REQUIRE_THROWS_AS(std::stoi("1099511627776"s), std::out_of_range); <span class="ent">➋</span>&#13;
  }&#13;
<span epub:type="pagebreak" id="page_500"/>  SECTION("stoul with all valid characters") {&#13;
    size_t last_character{};&#13;
    const auto result = std::stoul("0xD3C34C3D"s, &amp;last_character, 16); <span class="ent">➌</span>&#13;
    REQUIRE(result == 0xD3C34C3D);&#13;
    REQUIRE(last_character == 10);&#13;
  }&#13;
  SECTION("stoul") {&#13;
    size_t last_character{};&#13;
    const auto result = std::stoul("42six"s, &amp;last_character); <span class="ent">➍</span>&#13;
    REQUIRE(result == 42);&#13;
    REQUIRE(last_character == 2);&#13;
  }&#13;
  SECTION("stod") {&#13;
    REQUIRE(std::stod("2.7182818"s) == Approx(2.7182818)); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex18"/><em>Listing 15-18: String conversion functions of <code>string</code></em></p>&#13;
<p class="indent">First, you use <code>stoi</code> to convert <code>8675309</code> to an integer <span class="ent">➊</span>. In the second test, you attempt to use <code>stoi</code> to convert the <code>string 1099511627776</code> into an integer. Because this value is too large for an <code>int, stoi</code> throws <code>std::out_of_range</code> <span class="ent">➋</span>. Next, you convert <code>0xD3C34C3D</code> with <code>stoi</code>, but you provide the two optional arguments: a pointer to a <code>size_t</code> called <code>last_character</code> and a hexadecimal base <span class="ent">➌</span>. The <code>last_character</code> object is <code>10</code>, the length of <code>0xD3C34C3D</code>, because <code>stoi</code> can parse every character. The <code>string</code> in the next test, <code>42six</code>, contains the unparsable characters <code>six</code>. When you invoke <code>stoul</code> this time, the <code>result</code> is <code>42</code> and <code>last_character</code> equals <code>2</code>, the position of <code>s</code> in <code>six</code> <span class="ent">➍</span>. Finally, you use <code>stod</code> to convert the <code>string 2.7182818</code> to a <code>double</code> <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost’s Lexical Cast provides an alternative, template-based approach to numeric conversions. Refer to the documentation for <code>boost::lexical_cast</code> available in the <code>&lt;boost/lexical_cast.hpp&gt;</code> header.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch15lev1sec2"><strong>String View</strong></h3>&#13;
<p class="noindent">A <em>string view</em> is an object that represents a constant, contiguous sequence of characters. It’s very similar to a <code>const string</code> reference. In fact, string view classes are often implemented as a pointer to a character sequence and a length.</p>&#13;
<p class="indent">The STL offers the class template <code>std::basic_string_view</code> in the <code>&lt;string_view&gt;</code> header, which is analogous to <code>std::basic_string</code>. The template <code>std::basic_string_view</code> has a specialization for each of the four commonly used character types:</p>&#13;
<ul>&#13;
<li class="noindent"><code>char</code> has <code>string_view</code></li>&#13;
<li class="noindent"><code>wchar_t</code> has <code>wstring_view</code></li>&#13;
<li class="noindent"><code>char16_t</code> has <code>u16string_view</code></li>&#13;
<li class="noindent"><code>char32_t</code> has <code>u32string_view</code></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_501"/>This section discusses the <code>string_view</code> specialization for demonstration purposes, but the discussion generalizes to the other three specializations.</p>&#13;
<p class="indent">The <code>string_view</code> class supports most of the same methods as <code>string</code>; in fact, it’s designed to be a drop-in replacement for a <code>const string&amp;</code>.</p>&#13;
<h4 class="h4" id="ch15lev2sec8"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <code>string_view</code> class supports default construction, so it has zero length and points to <code>nullptr</code>. Importantly, <code>string_view</code> supports implicit construction from a <code>const string&amp;</code> or a C-style string. You can construct <code>string_view</code> from a <code>char*</code> and a <code>size_t</code>, so you can manually specify the desired length in case you want a substring or you have embedded nulls. <a href="ch15.xhtml#ch15ex19">Listing 15-19</a> illustrates the use of <code>string_view</code>.</p>&#13;
<pre>TEST_CASE("std::string_view supports") {&#13;
  SECTION("default construction") {&#13;
    std::string_view view; <span class="ent">➊</span>&#13;
    REQUIRE(view.data() == nullptr);&#13;
    REQUIRE(view.size() == 0);&#13;
    REQUIRE(view.empty());&#13;
  }&#13;
  SECTION("construction from string") {&#13;
    std::string word("sacrosanct");&#13;
    std::string_view view(word); <span class="ent">➋</span>&#13;
    REQUIRE(view == "sacrosanct");&#13;
  }&#13;
  SECTION("construction from C-string") {&#13;
    auto word = "viewership";&#13;
    std::string_view view(word); <span class="ent">➌</span>&#13;
    REQUIRE(view == "viewership");&#13;
  }&#13;
  SECTION("construction from C-string and length") {&#13;
    auto word = "viewership";&#13;
    std::string_view view(word, 4); <span class="ent">➍</span>&#13;
    REQUIRE(view == "view");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex19"/><em>Listing 15-19: The constructors of <code>string_view</code></em></p>&#13;
<p class="indent">The default-constructed <code>string_view</code> points to <code>nullptr</code> and is empty <span class="ent">➊</span>. When you construct a <code>string_view</code> from a <code>string</code> <span class="ent">➋</span> or a C-style string <span class="ent">➌</span>, it points to the original’s contents. The final test provides the optional length argument <code>4</code>, which means the <code>string_view</code> refers to only the first four characters instead <span class="ent">➍</span>.</p>&#13;
<p class="indent">Although <code>string_view</code> also supports copy construction and assignment, it doesn’t support move construction or assignment. This design makes sense when you consider that <code>string_view</code> doesn’t own the sequence to which it points.</p>&#13;
<h4 class="h4" id="ch15lev2sec9"><strong><em><span epub:type="pagebreak" id="page_502"/>Supported string_view Operations</em></strong></h4>&#13;
<p class="noindent">The <code>string_view</code> class supports many of the same operations as a <code>const</code> <code>string&amp;</code> with identical semantics. The following lists all the shared methods between <code>string</code> and <code>string_view</code>:</p>&#13;
<p class="bq"><strong>Iterators</strong> <code>begin, end</code>, <code>rbegin, rend</code>, <code>cbegin, cend</code>, <code>crbegin</code>, <code>crend</code></p>&#13;
<p class="bq"><strong>Element Access</strong> <code>operator[], at</code>, <code>front, back</code>, <code>data</code></p>&#13;
<p class="bq"><strong>Capacity</strong> <code>size, length</code>, <code>max_size</code>, <code>empty</code></p>&#13;
<p class="bq"><strong>Search</strong> <code>find, rfind</code>, <code>find_first_of, find_last_of</code>, <code>find_first_not_of</code>, <code>find_last_not_of</code></p>&#13;
<p class="bq"><strong>Extraction</strong> <code>copy</code>, <code>substr</code></p>&#13;
<p class="bq"><strong>Comparison</strong> <code>compare, operator==, operator!= </code>, <code>operator&lt;</code>, <code>operator&gt;</code>, <code>operator&lt;=</code>, <code>operator&gt;=</code></p>&#13;
<p class="indent">In addition to these shared methods, <code>string_view</code> supports the <code>remove_prefix</code> method, which removes the given number of characters from the beginning of the <code>string_view</code>, and the <code>remove_suffix</code> method, which instead removes characters from the end. <a href="ch15.xhtml#ch15ex20">Listing 15-20</a> illustrates both methods.</p>&#13;
<pre>TEST_CASE("std::string_view is modifiable with") {&#13;
  std::string_view view("previewing"); <span class="ent">➊</span>&#13;
  SECTION("remove_prefix") {&#13;
    view.remove_prefix(3); <span class="ent">➋</span>&#13;
    REQUIRE(view == "viewing");&#13;
  }&#13;
  SECTION("remove_suffix") {&#13;
    view.remove_suffix(3); <span class="ent">➌</span>&#13;
    REQUIRE(view == "preview");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex20"/><em>Listing 15-20: Modifying a <code>string_view</code> with <code>remove_prefix</code> and <code>remove_suffix</code></em></p>&#13;
<p class="indent">Here, you declare a <code>string_view</code> referring to the string literal <code>previewing</code> <span class="ent">➊</span>. The first test invokes <code>remove_prefix</code> with <code>3</code> <span class="ent">➋</span>, which removes three characters from the front of <code>string_view</code> so it now refers to <code>viewing</code>. The second test instead invokes <code>remove_suffix</code> with <code>3</code> <span class="ent">➌</span>, which removes three characters from the back of the <code>string_view</code> and results in <code>preview</code>.</p>&#13;
<h4 class="h4" id="ch15lev2sec10"><strong><em>Ownership, Usage, and Efficiency</em></strong></h4>&#13;
<p class="noindent">Because <code>string_view</code> doesn’t own the sequence to which it refers, it’s up to you to ensure that the lifetime of the <code>string_view</code> is a subset of the referred-to sequence’s lifetime.</p>&#13;
<p class="indent">Perhaps the most common usage of <code>string_view</code> is as a function parameter. When you need to interact with an immutable sequence of characters, it’s the first port of call. Consider the <code>count_vees</code> function in <a href="ch15.xhtml#ch15ex21">Listing 15-21</a>, which counts the frequency of the letter <code>v</code> in a sequence of characters.</p>&#13;
<pre><span epub:type="pagebreak" id="page_503"/>#include &lt;string_view&gt;&#13;
&#13;
size_t count_vees(std::string_view my_view<span class="ent">➊</span>) {&#13;
  size_t result{};&#13;
  for(auto letter : my_view) <span class="ent">➋</span>&#13;
    if (letter == 'v') result++; <span class="ent">➌</span>&#13;
  return result; <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex21"/><em>Listing 15-21: The <code>count_vees</code> function</em></p>&#13;
<p class="indent">The <code>count_vees</code> function takes a <code>string_view</code> called <code>my_view</code> <span class="ent">➊</span>, which you iterate over using a range-based <code>for</code> loop <span class="ent">➋</span>. Each time a character in <code>my_view</code> equals <code>v</code>, you increment a <code>result</code> variable <span class="ent">➌</span>, which you return after exhausting the sequence <span class="ent">➍</span>.</p>&#13;
<p class="indent">You could reimplement <a href="ch15.xhtml#ch15ex21">Listing 15-21</a> by simply replacing <code>string_view</code> with <code>const string&amp;</code>, as demonstrated in <a href="ch15.xhtml#ch15ex22">Listing 15-22</a>.</p>&#13;
<pre>#include &lt;string&gt;&#13;
&#13;
size_t count_vees(const std::string&amp; my_view) {&#13;
<span class="codeitalic1">--snip--</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex22"/><em>Listing 15-22: The <code>count_vees</code> function reimplemented to use a <code>const string&amp;</code> instead of a <code>string_view</code></em></p>&#13;
<p class="indent">If <code>string_view</code> is just a drop-in replacement for a <code>const string&amp;</code>, why bother having it? Well, if you invoke <code>count_vees</code> with a <code>std::string</code>, there’s no difference: modern compilers will emit the same code.</p>&#13;
<p class="indent">If you instead invoke <code>count_vees</code> with a string literal, there’s a big difference: when you pass a string literal for a <code>const string&amp;</code>, you construct a <code>string</code>. When you pass a string literal for a <code>string_view</code>, you construct a <code>string_view</code>. Constructing a <code>string</code> is probably more expensive, because it might have to allocate dynamic memory and it definitely has to copy characters. A <code>string_view</code> is just a pointer and a length (no copying or allocating is required).</p>&#13;
<h3 class="h3" id="ch15lev1sec3"><strong>Regular Expressions</strong></h3>&#13;
<p class="noindent">A <em>regular expression</em>, also called a <em>regex</em>, is a string that defines a search pattern. Regexes have a long history in computer science and form a sort of mini-language for searching, replacing, and extracting language data. The STL offers regular expression support in the <code>&lt;regex&gt;</code> header.</p>&#13;
<p class="indent">When used judiciously, regular expressions can be tremendously powerful, declarative, and concise; however, it’s also easy to write regexes that are totally inscrutable. Use regexes deliberately.</p>&#13;
<h4 class="h4" id="ch15lev2sec11"><strong><em><span epub:type="pagebreak" id="page_504"/>Patterns</em></strong></h4>&#13;
<p class="noindent">You build regular expressions using strings called <em>patterns</em>. Patterns represent a desired set of strings using a particular regular expression grammar that sets the syntax for building patterns. In other words, a pattern defines the subset of all possible strings that you’re interested in. The STL supports a handful of grammars, but the focus here will be on the very basics of the default grammar, the modified ECMAScript regular expression grammar (see [re.grammar] for details).</p>&#13;
<h5 class="h5" id="ch15lev3sec9"><strong>Character Classes</strong></h5>&#13;
<p class="noindent">In the ECMAScript grammar, you intermix literal characters with special markup to describe your desired strings. Perhaps the most common markup is a <em>character class</em>, which stands in for a set of possible characters: <code>\d</code> matches any digit, <code>\s</code> matches any whitespace, and <code>\w</code> matches any alphanumeric (“word”) character.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab08">Table 15-8</a> lists a few example regular expressions and possible interpretations.</p>&#13;
<p class="tabcap"><a id="ch15tab08"/><strong>Table 15-8:</strong> Regular Expression Patterns Using Only Character Classes and Literals</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Regex pattern</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Possibly describes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>\d\d\d-\d\d\d-\d\d\d\d</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An American phone number, such as 202-456-1414</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>\d\d:\d\d \wM</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A time in HH:MM AM/PM format, such as 08:49 <small>PM</small></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>\w\w\d\d\d\d\d\d</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An American ZIP code including a prepended state code, such as NJ07932</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>\w\d-\w\d</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An astromech droid identifier, such as R2-D2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>c\wt</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">A three-letter word starting with <em>c</em> and ending with <em>t</em>, such as <em>cat</em> or <em>cot</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can also invert a character class by capitalizing the <em>d</em>, <em>s</em>, or <em>w</em> to give the opposite: <code>\D</code> matches any non-digit, <code>\S</code> matches any non-whitespace, and <code>\W</code> matches any non-word character.</p>&#13;
<p class="indent">In addition, you can build your own character classes by explicitly enumerating them between square brackets <code>[]</code>. For example, the character class <code>[02468]</code> includes even digits. You can also use hyphens as shortcuts to include implied ranges, so the character class <code>[0-9a-fA-F]</code> includes any hexadecimal digit whether the letter is capitalized or not. Finally, you can invert a custom character class by prepending the list with a caret <code>^</code>. For example, the character class <code>[^aeiou]</code> includes all non-vowel characters.</p>&#13;
<h5 class="h5" id="ch15lev3sec10"><strong>Quantifiers</strong></h5>&#13;
<p class="noindent">You can save some typing by using <em>quantifiers</em>, which specify that the character directly to the left should be repeated some number of times. <a href="ch15.xhtml#ch15tab09">Table 15-9</a> lists the regex quantifiers.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_505"/><a id="ch15tab09"/><strong>Table 15-9:</strong> Regular Expression Quantifiers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Regex quantifier</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specifies a quantity of</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">*</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0 or more</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">+</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">1 or more</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">?</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0 or 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">{n}</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exactly n</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">{n,m}</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Between n and m, inclusive</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">{n,}</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">At least n</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Using quantifiers, you can specify all words beginning with <em>c</em> and ending with <em>t</em> using the pattern <code>c\w*t</code>, because <code>\w*</code> matches any number of word characters.</p>&#13;
<h5 class="h5" id="ch15lev3sec11"><strong>Groups</strong></h5>&#13;
<p class="noindent">A <em>group</em> is a collection of characters. You can specify a group by placing it within parentheses. Groups are useful in several ways, including specifying a particular collection for eventual extraction and for quantification.</p>&#13;
<p class="indent">For example, you could improve the ZIP pattern in <a href="ch15.xhtml#ch15tab08">Table 15-8</a> to use quantifiers and groups, like this:</p>&#13;
<pre>(\w{2})?<span class="ent">➊</span>(\d{5})<span class="ent">➋</span>(-\d{4})?<span class="ent">➌</span></pre>&#13;
<p class="indent">Now you have three groups: the optional state <span class="ent">➊</span>, the ZIP code <span class="ent">➋</span>, and an optional four-digit suffix <span class="ent">➌</span>. As you’ll see later on, these groups make parsing from regexes much easier.</p>&#13;
<h5 class="h5" id="ch15lev3sec12"><strong>Other Special Characters</strong></h5>&#13;
<p class="noindent"><a href="ch15.xhtml#ch15tab10">Table 15-10</a> lists several other special characters available for use in regex patterns.</p>&#13;
<p class="tabcap"><a id="ch15tab10"/><strong>Table 15-10:</strong> Example Special Characters</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specifies</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">X|Y</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Character X or Y</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">\Y</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The special character Y as a literal (in other words, escape it)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">\n</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Newline</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">\r</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Carriage return</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">\t</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Tab</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">\0</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Null</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">\xYY</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">The hexadecimal character corresponding to YY</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec12"><strong><em><span epub:type="pagebreak" id="page_506"/>basic_regex</em></strong></h4>&#13;
<p class="noindent">The STL’s <code>std::basic_regex</code> class template in the <code>&lt;regex&gt;</code> header represents a regular expression constructed from a pattern. The <code>basic_regex</code> class accepts two template parameters, a character type and an optional traits class. You’ll almost always want to use one of the convenience specializations: <code>std::regex</code> for <code>std::basic_regex&lt;char&gt;</code> or <code>std::wregex</code> for <code>std::basic_regex&lt;wchar_t&gt;</code>.</p>&#13;
<p class="indent">The primary means of constructing a <code>regex</code> is by passing a string literal containing your regex pattern. Because patterns will require a lot of escaped characters—especially the backslash <code>\</code>—it’s a good idea to use raw string literals, such as <code>R"()"</code>. The constructor accepts a second, optional parameter for specifying syntax flags like the regex grammar.</p>&#13;
<p class="indent">Although <code>regex</code> is used primarily as input into regular expression algorithms, it does offer a few methods that users can interact with. It supports the usual copy and move construction and assignment suite and <code>swap</code>, plus the following:</p>&#13;
<ul>&#13;
<li class="noindent"><code>assign(</code><code>s</code><code>)</code> reassigns the pattern to <code>s</code></li>&#13;
<li class="noindent"><code>mark_count()</code> returns the number of groups in the pattern</li>&#13;
<li class="noindent"><code>flags()</code> returns the syntax flags issued at construction</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex23">Listing 15-23</a> illustrates how you could construct a ZIP code <code>regex</code> and inspect its subgroups.</p>&#13;
<pre>#include &lt;regex&gt;&#13;
&#13;
TEST_CASE("std::basic_regex constructs from a string literal") {&#13;
  std::regex zip_regex{ R"((\w{2})?(\d{5})(-\d{4})?)" }; <span class="ent">➊</span>&#13;
  REQUIRE(zip_regex.mark_count() == 3); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex23"/><em>Listing 15-23: Constructing a <code>regex</code> using a raw string literal and extracting its group count</em></p>&#13;
<p class="indent">Here, you construct a <code>regex</code> called <code>zip_regex</code> using the pattern <code>(\w{2})?(\d{5})(-\d{4})?</code> <span class="ent">➊</span>. Using the <code>mark_count</code> method, you see that <code>zip_regex</code> contains three groups <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch15lev2sec13"><strong><em>Algorithms</em></strong></h4>&#13;
<p class="noindent">The <code>&lt;regex&gt;</code> class contains three algorithms for applying <code>std::basic_regex</code> to a target string: matching, searching, or replacing. Which you choose depends on the task at hand.</p>&#13;
<h5 class="h5" id="ch15lev3sec13"><strong>Matching</strong></h5>&#13;
<p class="noindent"><em>Matching</em> attempts to marry a regular expression to an <em>entire</em> <code>string</code>. The STL provides the <code>std::regex_match</code> function for matching, which has four overloads.</p>&#13;
<p class="indent">First, you can provide <code>regex_match</code> a <code>string</code>, a C-string, or a begin and end iterator forming a half-open range. The next parameter is an optional <span epub:type="pagebreak" id="page_507"/>reference to a <code>std::match_results</code> object that receives details about the match. The next parameter is a <code>std::basic_regex</code> that defines the matching, and the final parameter is an optional <code>std::regex_constants::match_flag_type</code> that specifies additional matching options for advanced use cases. The <code>regex_match</code> function returns a <code>bool</code>, which is <code>true</code> if it found a match; otherwise, it’s <code>false</code>.</p>&#13;
<p class="indent">To summarize, you can invoke <code>regex_match</code> in the following ways:</p>&#13;
<pre>regex_match(beg, end, [mr], rgx, [flg])&#13;
regex_match(str, [mr], rgx, [flg])</pre>&#13;
<p class="indent">Either provide a half-open range from <code>beg</code> to <code>end</code> or a <code>string</code>/C-string <code>str</code> to search. Optionally, you can provide a <code>match_results</code> called <code>mr</code> to store all the details of any matches found. You obviously have to provide a regex <code>rgx</code>. Finally, the flags <code>flg</code> are seldom used.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For details on match flags <code>flg</code>, refer to [re.alg.match].</em></p>&#13;
</div>&#13;
<p class="indent">A <em>submatch</em> is a subsequence of the matched string that corresponds to a group. The ZIP code–matching regular expression <code>(\w{2})(\d{5})(-\d{4})?</code> can produce two or three submatches depending on the string. For example, TX78209 contains the two submatches TX and 78209, and NJ07936-3173 contains the three submatches NJ, 07936, and -3173.</p>&#13;
<p class="indent">The <code>match_results</code> class stores zero or more <code>std::sub_match</code> instances. A <code>sub_match</code> is a simple class template that exposes a <code>length</code> method to return the length of a submatch and a <code>str</code> method to build a <code>string</code> from the <code>sub_match</code>.</p>&#13;
<p class="indent">Somewhat confusingly, if <code>regex_match</code> successfully matches a string, <code>match_results</code> stores the entire matched string as its first element and then stores any submatches as subsequent elements.</p>&#13;
<p class="indent">The <code>match_results</code> class provides the operations listed in <a href="ch15.xhtml#ch15tab11">Table 15-11</a>.</p>&#13;
<p class="tabcap"><a id="ch15tab11"/><strong>Table 15-11:</strong> Supported Operations of <code>match_results</code></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span><code>.empty()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Checks whether the match was successful.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><code>.size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of submatches.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span><code>.max_size()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the maximum number of submatches.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><code>.length([</code><span class="codestrong">i</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the length of the submatch <code>i</code>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span><code>.position([</code><span class="codestrong">i</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the character of the first position of submatch <code>i</code>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><code>.str([</code><span class="codestrong">i</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the string representing submatch <code>i</code>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span> <code>[</code><span class="codestrong">i</span><code>]</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to a <code>std::sub_match</code> class corresponding to submatch <code>i</code>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><code>.prefix()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to a <code>std::sub_match</code> class corresponding to the sequence before the match.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_508"/><span class="codestrong">mr</span><code>.suffix()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to a <code>std::sub_match</code> class corresponding to the sequence after the match.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><code>.format(</code><span class="codestrong">str</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <code>string</code> with contents according to the format string <span class="codestrong">str</span>. There are three special sequences: <span class="codestrong">$'</span> for the characters before a match, <span class="codestrong">$'</span> for the characters after the match, and <span class="codestrong">$&amp;</span> for the matched characters.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">mr</span><code>.begin()</code></p>&#13;
<p class="taba"><span class="codestrong">mr</span><code>.end()</code></p>&#13;
<p class="taba"><span class="codestrong">mr</span><code>.cbegin()</code></p>&#13;
<p class="taba"><span class="codestrong">mr</span><code>.cend()</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Returns the corresponding iterator to the sequence of submatches.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <code>std::sub_match</code> class template has predefined specializations to work with common string types:</p>&#13;
<ul>&#13;
<li class="noindent"><code>std::csub_match</code> for a <code>const char*</code></li>&#13;
<li class="noindent"><code>std::wcsub_match</code> for a <code>const wchar_t*</code></li>&#13;
<li class="noindent"><code>std::ssub_match</code> for a <code>std::string</code></li>&#13;
<li class="noindent"><code>std::wssub_match</code> for a <code>std::wstring</code></li>&#13;
</ul>&#13;
<p class="indent">Unfortunately, you’ll have to keep track of all these specializations manually due to the design of <code>std::regex_match</code>. This design generally befuddles newcomers, so let’s look at an example. <a href="ch15.xhtml#ch15ex24">Listing 15-24</a> uses the ZIP code regular expression <code>(\w{2})(\d{5})(-\d{4})?</code> to match against the strings <code>NJ07936-3173</code> and <code>Iomega Zip 100</code>.</p>&#13;
<pre>#include &lt;regex&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
TEST_CASE("std::sub_match") {&#13;
  std::regex regex{ R"((\w{2})(\d{5})(-\d{4})?)" }; <span class="ent">➊</span>&#13;
  std::smatch results; <span class="ent">➋</span>&#13;
  SECTION("returns true given matching string") {&#13;
    std::string zip("NJ07936-3173");&#13;
    const auto matched = std::regex_match(zip, results, regex); <span class="ent">➌</span>&#13;
    REQUIRE(matched); <span class="ent">➍</span>&#13;
    REQUIRE(results[0] == "NJ07936-3173"); <span class="ent">➎</span>&#13;
    REQUIRE(results[1] == "NJ"); <span class="ent">➏</span>&#13;
    REQUIRE(results[2] == "07936");&#13;
    REQUIRE(results[3] == "-3173");&#13;
  }&#13;
  SECTION("returns false given non-matching string") {&#13;
    std::string zip("Iomega Zip 100");&#13;
    const auto matched = std::regex_match(zip, results, regex); <span class="ent">➐</span>&#13;
    REQUIRE_FALSE(matched); <span class="ent">➑</span>&#13;
    }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex24"/><em>Listing 15-24: A <code>regex_match</code> attempts to match a <code>regex</code> to a <code>string</code>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_509"/>You construct a <code>regex</code> with the raw literal <code>R"((\w{2})(\d{5})(-\d{4})?)"</code> <span class="ent">➊</span> and default construct an <code>smatch</code> <span class="ent">➋</span>. In the first test, you <code>regex_match</code> the valid ZIP code <code>NJ07936-3173</code> <span class="ent">➌</span>, which returns the <code>true</code> value <code>matched</code> to indicate success <span class="ent">➍</span>. Because you provide an <code>smatch</code> to <code>regex_match</code>, it contains the valid ZIP code as the first element <span class="ent">➎</span>, followed by each of the three subgroups <span class="ent">➏</span>.</p>&#13;
<p class="indent">In the second test, you <code>regex_match</code> the invalid ZIP code <code>Iomega Zip 100</code> <span class="ent">➐</span>, which fails to match and returns <code>false</code> <span class="ent">➑</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec14"><strong>Searching</strong></h5>&#13;
<p class="noindent"><em>Searching</em> attempts to match a regular expression to a <em>part</em> of a string. The STL provides the <code>std::regex_search</code> function for searching, which is essentially a replacement for <code>regex_match</code> that succeeds even when only a part of a string matches a <code>regex</code>.</p>&#13;
<p class="indent">For example, <code>The string NJ07936-3173 is a ZIP Code.</code> contains a ZIP code. But applying the ZIP regular expression to it using <code>std::regex_match</code> will return <code>false</code> because the <code>regex</code> doesn’t match the <em>entire</em> string. However, applying <code>std::regex_search</code> instead would yield <code>true</code> because the string embeds a valid ZIP code. <a href="ch15.xhtml#ch15ex25">Listing 15-25</a> illustrates <code>regex_match</code> and <code>regex_search</code>.</p>&#13;
<pre>TEST_CASE("when only part of a string matches a regex, std::regex_ ") {&#13;
  std::regex regex{ R"((\w{2})(\d{5})(-\d{4})?)" }; <span class="ent">➊</span>&#13;
  std::string sentence("The string NJ07936-3173 is a ZIP Code."); <span class="ent">➋</span>&#13;
  SECTION("match returns false") {&#13;
    REQUIRE_FALSE(std::regex_match(sentence, regex)); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("search returns true") {&#13;
    REQUIRE(std::regex_search(sentence, regex)); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex25"/><em>Listing 15-25: Comparing <code>regex_match</code> and <code>regex_search</code></em></p>&#13;
<p class="indent">As before, you construct the ZIP <code>regex</code> <span class="ent">➊</span>. You also construct the example string <code>sentence</code>, which embeds a valid ZIP code <span class="ent">➋</span>. The first test calls <code>regex_</code><code>match</code> with <code>sentence</code> and <code>regex</code>, which returns <code>false</code> <span class="ent">➌</span>. The second test instead calls <code>regex_search</code> with the same arguments and returns <code>true</code> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec15"><strong>Replacing</strong></h5>&#13;
<p class="noindent"><em>Replacing</em> substitutes regular expression occurrences with replacement text. The STL provides the <code>std::regex_replace</code> function for replacing.</p>&#13;
<p class="indent">In its most basic usage, you pass <code>regex_replace</code> three arguments:</p>&#13;
<ul>&#13;
<li class="noindent">A source <code>string</code>/C-string/half-open range to search</li>&#13;
<li class="noindent">A regular expression</li>&#13;
<li class="noindent">A replacement string</li>&#13;
</ul>&#13;
<p class="indent">As an example, <a href="ch15.xhtml#ch15ex26">Listing 15-26</a> replaces all the vowels in the phrase <code>queue</code><code>ing and cooeeing in eutopia</code> with underscores (<code>_</code>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_510"/>TEST_CASE("std::regex_replace") {&#13;
  std::regex regex{ "[aeoiu]" }; <span class="ent">➊</span>&#13;
  std::string phrase("queueing and cooeeing in eutopia"); <span class="ent">➋</span>&#13;
  const auto result = std::regex_replace(phrase, regex, "_"); <span class="ent">➌</span>&#13;
  REQUIRE(result == "q_____ng _nd c_____ng _n __t_p__"); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex26"/><em>Listing 15-26: Using <code>std::regex_replace</code> to substitute underscores for vowels in a <code>string</code></em></p>&#13;
<p class="indent">You construct a <code>std::regex</code> that contains the set of all vowels <span class="ent">➊</span> and a <code>string</code> called <code>phrase</code> containing the vowel-rich contents <code>queueing and cooeeing in eutopia</code> <span class="ent">➋</span>. Next, you invoke <code>std::regex_replace</code> with <code>phrase</code>, the regex, and the string literal <code>_</code> <span class="ent">➌</span>, which replaces all vowels with underscores <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost Regex provides regular expression support mirroring the STL’s in the <code>&lt;boost/regex.hpp&gt;</code> header. Another Boost library, Xpressive, offers an alternative approach with regular expressions that you can express directly in C++ code. It has some major advantages, such as expressiveness and compile-time syntax checking, but the syntax necessarily diverges from standard regular expression syntaxes like POSIX, Perl, and ECMAScript.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch15lev1sec4"><strong>Boost String Algorithms</strong></h3>&#13;
<p class="noindent">Boost’s String Algorithms library offers a bounty of <code>string</code> manipulation functions. It contains functions for common tasks related to <code>string</code>, such as trimming, case conversion, finding/replacing, and evaluating characteristics. You can access all the Boost String Algorithms functions in the <code>boost::algorithm</code> namespace and in the <code>&lt;boost/algorithm/string.hpp&gt;</code> convenience header.</p>&#13;
<h4 class="h4" id="ch15lev2sec14"><strong><em>Boost Range</em></strong></h4>&#13;
<p class="noindent"><em>Range</em> is a concept (in the <a href="ch06.xhtml#ch06">Chapter 6</a> compile-time polymorphism sense of the word) that has a beginning and an end that allow you to iterate over constituent elements. The range aims to improve the practice of passing a half-open range as a pair of iterators. By replacing the pair with a single object, you can <em>compose</em> algorithms together by using the range result of one algorithm as the input to another. For example, if you wanted to transform a range of strings to all uppercase and sort them, you could pass the results of one operation directly into the other. This is not generally possible to do with iterators alone.</p>&#13;
<p class="indent">Ranges are not currently part of the C++ standard, but several experimental implementations exist. One such implementation is Boost Range, and because Boost String Algorithms uses Boost Range extensively, let’s look at it now.</p>&#13;
<p class="indent">The Boost Range concept is like the STL container concept. It provides the usual complement of <code>begin</code>/<code>end</code> methods to expose iterators over the <span epub:type="pagebreak" id="page_511"/>elements in the range. Each range has a <em>traversal category</em>, which indicates the range’s supported operations:</p>&#13;
<ul>&#13;
<li class="noindent">A <em>single-pass range</em> allows one-time, forward iteration.</li>&#13;
<li class="noindent">A <em>forward range</em> allows (unlimited) forward iteration and satisfies single-pass range.</li>&#13;
<li class="noindent">A <em>bidirectional range</em> allows forward and backward iteration and satisfies forward range.</li>&#13;
<li class="noindent">A <em>random-access range</em> allows arbitrary element access and satisfies bidirectional range.</li>&#13;
</ul>&#13;
<p class="indent">Boost String Algorithms is designed for <code>std::string</code>, which satisfies the random-access range concept. For the most part, the fact that Boost String Algorithms accepts Boost Range rather than <code>std::string</code> is a totally transparent abstraction to users. When reading the documentation, you can mentally substitute <code>Range</code> with <code>string</code>.</p>&#13;
<h4 class="h4" id="ch15lev2sec15"><strong><em>Predicates</em></strong></h4>&#13;
<p class="noindent">Boost String Algorithms incorporates predicates extensively. You can use them directly by bringing in the <code>&lt;boost/algorithm/string/predicate.hpp&gt;</code> header. Most of the predicates contained in this header accept two ranges, <code>r1</code> and <code>r2</code>, and return a <code>bool</code> based on their relationship. The predicate <code>starts_with</code>, for example, returns <code>true</code> if <code>r1</code> begins with <code>r2</code>.</p>&#13;
<p class="indent">Each predicate has a case-insensitive version, which you can use by prepending the letter <code>i</code> to the method name, such as <code>istarts_with</code>. <a href="ch15.xhtml#ch15ex27">Listing 15-27</a> illustrates <code>starts_with</code> and <code>istarts_with</code>.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;boost/algorithm/string/predicate.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm") {&#13;
  using namespace boost::algorithm;&#13;
  using namespace std::literals::string_literals;&#13;
  std::string word("cymotrichous"); <span class="ent">➊</span>&#13;
  SECTION("starts_with tests a string's beginning") {&#13;
    REQUIRE(starts_with(word, "cymo"s)); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("istarts_with is case insensitive") {&#13;
    REQUIRE(istarts_with(word, "cYmO"s)); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex27"/><em>Listing 15-27: Both <code>starts_with</code> and <code>istarts_with</code> check a range’s beginning characters.</em></p>&#13;
<p class="indent">You initialize a <code>string</code> containing <code>cymotrichous</code> <span class="ent">➊</span>. The first test shows that <code>starts_with</code> returns <code>true</code> when with <code>word</code> and <code>cymo</code> <span class="ent">➋</span>. The case-insensitive version <code>istarts_with</code> also returns <code>true</code> given <code>word</code> and <code>cYmO</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_512"/>Note that <code>&lt;boost/algorithm/string/predicate.hpp&gt;</code> also contains an <code>all</code> predicate, which accepts a single range <code>r</code> and a predicate <code>p</code>. It returns <code>true</code> if <code>p</code> evaluates to <code>true</code> for all elements of <code>r</code>, as <a href="ch15.xhtml#ch15ex28">Listing 15-28</a> illustrates.</p>&#13;
<pre>TEST_CASE("boost::algorithm::all evaluates a predicate for all elements") {&#13;
  using namespace boost::algorithm;&#13;
  std::string word("juju"); <span class="ent">➊</span>&#13;
  REQUIRE(all(word<span class="ent">➋</span>, [](auto c) { return c == 'j' || c =='u'; }<span class="ent">➌</span>));&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex28"/><em>Listing 15-28: The <code>all</code> predicate evaluates if all elements in a range satisfy a predicate.</em></p>&#13;
<p class="indent">You initialize a string containing <code>juju</code> <span class="ent">➊</span>, which you pass to <code>all</code> as the range <span class="ent">➋</span>. You pass a lambda predicate, which returns <code>true</code> for the letters <code>j</code> and <code>u</code> <span class="ent">➌</span>. Because <code>juju</code> contains only these letters, <code>all</code> returns <code>true</code>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab12">Table 15-12</a> lists the predicates available in <code>&lt;boost/algorithm/string/predicate.hpp&gt;</code>.In this table, <code>r, r1</code>, and <code>r2</code> are string ranges, and <code>p</code> is an element comparison predicate.</p>&#13;
<p class="tabcap"><a id="ch15tab12"/><strong>Table 15-12:</strong> Predicates in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Predicate</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong> <span class="codestrong">true</span> <strong>if</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>starts_with(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>istarts_with(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r1</span> starts with <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>ends_with(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>iends_with(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">r1</span> ends with <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>contains(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>icontains(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r1</span> contains <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>equals(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>iequals(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">r1</span> equals <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>lexicographical_compare(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>ilexicographical_compare(</code><span class="codestrong">r1</span><code>,</code> <span class="codestrong">r2)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r1</span> lexicographically less than <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>all(</code><span class="codestrong">r</span><code>, [</code><span class="codestrong">p</span><code>])</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">All elements of <span class="codestrong">r</span> return <code>true</code> for <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Function permutations beginning with <code>i</code> are case-insensitive.</p>&#13;
<h4 class="h4" id="ch15lev2sec16"><strong><em>Classifiers</em></strong></h4>&#13;
<p class="noindent"><em>Classifiers</em> are predicates that evaluate some characteristics about a character. The <code>&lt;boost/algorithm/string/classification.hpp&gt;</code> header offers generators for creating classifiers. A <em>generator</em> is a non-member function that acts like a constructor. Some generators accept arguments for customizing the classifier.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Of course, you can create your own predicates just as easily with your own function objects, like lambdas, but Boost provides a menu of premade classifiers for convenience.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_513"/>The <code>is_alnum</code> generator, for example, creates a classifier that determines whether a character is alphanumeric. <a href="ch15.xhtml#ch15ex29">Listing 15-29</a> illustrates how to use this classifier independently or in conjunction with <code>all</code>.</p>&#13;
<pre>#include &lt;boost/algorithm/string/classification.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::is_alnum") {&#13;
  using namespace boost::algorithm;&#13;
  const auto classifier = is_alnum(); <span class="ent">➊</span>&#13;
  SECTION("evaluates alphanumeric characters") {&#13;
    REQUIRE(classifier('a')); <span class="ent">➋</span>&#13;
    REQUIRE_FALSE(classifier('$')); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("works with all") {&#13;
    REQUIRE(all("nostarch", classifier)); <span class="ent">➍</span>&#13;
    REQUIRE_FALSE(all("@nostarch", classifier)); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex29"/><em>Listing 15-29: The <code>is_alum</code> generator determines whether a character is alphanumeric.</em></p>&#13;
<p class="indent">Here, you construct a <code>classifier</code> from the <code>is_alnum</code> generator <span class="ent">➊</span>. The first test uses the <code>classifier</code> to evaluate that <code>a</code> is alphanumeric <span class="ent">➋</span> and <code>$</code> is not <span class="ent">➌</span>. Because all classifiers are predicates that operate on characters, you can use them in conjunction with the <code>all</code> predicate discussed in the previous section to determine that <code>nostarch</code> contains all alphanumeric characters <span class="ent">➍</span> and <code>@nostarch</code> doesn’t <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab13">Table 15-13</a> lists the character classifications available in <code>&lt;boost/algorithm/string/classification.hpp&gt;</code>. In this table, <code>r</code> is a string range, and <code>beg</code> and <code>end</code> are element comparison predicates.</p>&#13;
<p class="tabcap"><a id="ch15tab13"/><strong>Table 15-13:</strong> Character Predicates in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Predicate</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong> <span class="codestrong">true</span> <strong>if element is . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_space</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A space</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_alnum</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An alphanumeric character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_alpha</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An alphabetical character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_cntrl</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A control character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_digit</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A decimal digit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_graph</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A graphical character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_lower</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A lowercase character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_print</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A printable character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_punct</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A punctuation character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_upper</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An uppercase character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_xdigit</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A hexadecimal digit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_any_of(</code><span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Contained in <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>is_from_range(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Contained in the range from <span class="codestrong">beg</span> to <span class="codestrong">end</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec17"><strong><em><span epub:type="pagebreak" id="page_514"/>Finders</em></strong></h4>&#13;
<p class="noindent">A <em>finder</em> is a concept that determines a position in a range corresponding to some specified criteria, usually a predicate or a regular expression. Boost String Algorithms provides some generators for producing finders in the <code>&lt;boost/algorithm/string/finder.hpp&gt;</code> header.</p>&#13;
<p class="indent">For example, the <code>nth_finder</code> generator accepts a range <code>r</code> and an index <code>n</code>, and it creates a finder that will search a range (taken as a <code>begin</code> and an <code>end</code> iterator) for the <code>n</code>th occurrence of <code>r</code>, as <a href="ch15.xhtml#ch15ex30">Listing 15-30</a> illustrates.</p>&#13;
<pre>#include &lt;boost/algorithm/string/finder.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::nth_finder finds the nth occurrence") {&#13;
  const auto finder = boost::algorithm::nth_finder("na", 1); <span class="ent">➊</span>&#13;
  std::string name("Carl Brutananadilewski"); <span class="ent">➋</span>&#13;
  const auto result = finder(name.begin(), name.end()); <span class="ent">➌</span>&#13;
  REQUIRE(result.begin() == name.begin() + 12); <span class="ent">➍</span> // Brutana(n)adilewski&#13;
  REQUIRE(result.end() == name.begin() + 14); <span class="ent">➎</span> // Brutanana(d)ilewski&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex30"/><em>Listing 15-30: The <code>nth_finder</code> generator creates a finder that locates the <em>n</em>th occurrence of a sequence.</em></p>&#13;
<p class="indent">You use the <code>nth_finder</code> generator to create <code>finder</code>, which will locate the second instance of <code>na</code> in a range (<code>n</code> is zero based) <span class="ent">➊</span>. Next, you construct <code>name</code> containing <code>Carl Brutananadilewski</code> <span class="ent">➋</span> and invoke <code>finder</code> with the <code>begin</code> and <code>end</code> iterators of <code>name</code> <span class="ent">➌</span>. The <code>result</code> is a range whose <code>begin</code> points to the second <em>n</em> in <code>Brutana</code><code>n</code><code>adilewski</code> <span class="ent">➍</span> and whose <code>end</code> points to the first <em>d</em> in <code>Brutanana</code><code>d</code><code>ilewski</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab14">Table 15-14</a> lists the finders available in <code>&lt;boost/algorithm/string/finder.hpp&gt;</code>. In this table, <code>s</code> is a string, <code>p</code> is an element comparison predicate, <code>n</code> is an integral value, <code>beg</code> and <code>end</code> are iterators, <code>rgx</code> is a regular expression, and <code>r</code> is a string range.</p>&#13;
<p class="tabcap"><a id="ch15tab14"/><strong>Table 15-14:</strong> Finders in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Generator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Creates a finder that, when invoked, returns . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>first_finder(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">p</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The first element matching <span class="codestrong">s</span> using <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>last_finder(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">p)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The last element matching <span class="codestrong">s</span> using <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>nth_finder(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">p</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The <span class="codestrong">n</span>th element matching <span class="codestrong">s</span> using <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>head_finder(</code><span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The first <span class="codestrong">n</span> elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>tail_finder(</code><span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">the last <span class="codestrong">n</span> elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>token_finder(</code><span class="codestrong">p</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The character matching <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>range_finder(</code><span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>range_finder(</code><span class="codestrong">beg</span><code>,</code> <span class="codestrong">end</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r</span> regardless of input</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>regex_finder(</code><span class="codestrong">rgx</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">The first substring matching <span class="codestrong">rgx</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_515"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost String Algorithms specifies a formatter concept, which presents the results of a finder to a replace algorithm. Only an advanced user will need these algorithms. Refer to the documentation for the <code>find_format</code> algorithms in the <code>&lt;boost/algorithm/string/find_format.hpp&gt;</code> header for more information.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch15lev2sec18"><strong><em>Modifying Algorithms</em></strong></h4>&#13;
<p class="noindent">Boost contains a <em>lot</em> of algorithms for modifying a <code>string</code> (range). Between the <code>&lt;boost/algorithm/string/case_conv.hpp&gt;</code><code>, &lt;boost/algorithm/string/trim.hpp&gt;</code>, and <code>&lt;boost/algorithm/string/replace.hpp&gt;</code> headers, algorithms exist to convert case, trim, replace, and erase many different ways.</p>&#13;
<p class="indent">For example, the <code>to_upper</code> function will convert all of a string’s letters to uppercase. If you want to keep the original unmodified, you can use the <code>to_upper_copy</code> function, which will return a new object. <a href="ch15.xhtml#ch15ex31">Listing 15-31</a> illustrates <code>to_upper</code> and <code>to_upper_copy</code>.</p>&#13;
<pre>#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::to_upper") {&#13;
  std::string powers("difficulty controlling the volume of my voice"); <span class="ent">➊</span>&#13;
  SECTION("upper-cases a string") {&#13;
    boost::algorithm::to_upper(powers); <span class="ent">➋</span>&#13;
    REQUIRE(powers == "DIFFICULTY CONTROLLING THE VOLUME OF MY VOICE"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("_copy leaves the original unmodified") {&#13;
    auto result = boost::algorithm::to_upper_copy(powers); <span class="ent">➍</span>&#13;
    REQUIRE(powers == "difficulty controlling the volume of my voice"); <span class="ent">➎</span>&#13;
    REQUIRE(result == "DIFFICULTY CONTROLLING THE VOLUME OF MY VOICE"); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex31"/><em>Listing 15-31: Both <code>to_upper</code> and <code>to_upper_copy</code> convert the case of a <code>string</code>.</em></p>&#13;
<p class="indent">You create a <code>string</code> called <code>powers</code> <span class="ent">➊</span>. The first test invokes <code>to_upper</code> on <code>powers</code> <span class="ent">➋</span>, which modifies it in place to contain all uppercase letters <span class="ent">➌</span>. The second test uses the <code>_copy</code> variant to create a new <code>string</code> called <code>result</code> <span class="ent">➍</span>. The <code>powers</code> string is unaffected <span class="ent">➎</span>, whereas <code>result</code> contains an all uppercase version <span class="ent">➏</span>.</p>&#13;
<p class="indent">Some Boost String Algorithms, such as <code>replace_first</code>, also have case-insensitive versions. Just prepend an <code>i</code>, and matching will proceed regardless of case. For algorithms like <code>replace_first</code> that also have <code>_copy</code> variants, any permutation will work (<code>replace_first</code>, <code>ireplace_first</code><code>, replace_first_copy</code>, and <code>ireplace_first_copy</code>).</p>&#13;
<p class="indent">The <code>replace_first</code> algorithm and its variants accept an input range <code>s</code>, a match range <code>m</code>, and a replace range <code>r</code>, and replaces the first instance of <code>m</code> in <code>s</code> with <code>r</code>. <a href="ch15.xhtml#ch15ex32">Listing 15-32</a> illustrates <code>replace_first</code> and <code>i_replace_first</code>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_516"/>#include &lt;boost/algorithm/string/replace.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::replace_first") {&#13;
  using namespace boost::algorithm;&#13;
  std::string publisher("No Starch Press"); <span class="ent">➊</span>&#13;
  SECTION("replaces the first occurrence of a string") {&#13;
    replace_first(publisher, "No", "Medium"); <span class="ent">➋</span>&#13;
    REQUIRE(publisher == "Medium Starch Press"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("has a case-insensitive variant") {&#13;
    auto result = ireplace_first_copy(publisher, "NO", "MEDIUM"); <span class="ent">➍</span>&#13;
    REQUIRE(publisher == "No Starch Press"); <span class="ent">➎</span>&#13;
    REQUIRE(result == "MEDIUM Starch Press"); <span class="ent">➏</span>&#13;
  }}</pre>&#13;
<p class="listing"><a id="ch15ex32"/><em>Listing 15-32: Both <code>replace_first</code> and <code>i_replace_first</code> replace matching <code>string</code> sequences.</em></p>&#13;
<p class="indent">Here, you construct a <code>string</code> called <code>publisher</code> containing <code>No Starch Press</code> <span class="ent">➊</span>. The first test invokes <code>replace_first</code> with <code>publisher</code> as the input string, <code>No</code> as the match string, and <code>Medium</code> as the replacement string <span class="ent">➋</span>. Afterward, <code>publisher</code> contains <code>Medium Starch Press</code> <span class="ent">➌</span>. The second test uses the <code>ireplace_first_copy</code> variant, which is case insensitive and performs a copy. You pass <code>NO</code> and <code>MEDIUM</code> as the match and replace strings <span class="ent">➍</span>, respectively, and the <code>result</code> contains <code>MEDIUM Starch Press</code> <span class="ent">➏</span>, whereas <code>publisher</code> is unaffected <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab15">Table 15-15</a> lists many of the modifying algorithms available in Boost String Algorithms. In this table, <code>r, s, s1</code>, and <code>s2</code> are strings; <code>p</code> is an element comparison predicate; <code>n</code> is an integral value; and <code>rgx</code> is a regular expression.</p>&#13;
<p class="tabcap"><a id="ch15tab15"/><strong>Table 15-15:</strong> Modifying Algorithms in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>to_upper(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><code>to_upper_copy(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Converts <span class="codestrong">s</span> to all uppercase</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>to_lower(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><code>to_lower_copy(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Converts <span class="codestrong">s</span> to all lowercase</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>trim_left_copy_if(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>trim_left_if(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>trim_left_copy(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><code>trim_left(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes leading spaces from <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>trim_right_copy_if(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>trim_right_if(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>trim_right_copy(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><code>trim_right(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes trailing spaces from <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>trim_copy_if(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>trim_if(</code><span class="codestrong">s</span><code>, [</code><span class="codestrong">p</span><code>])</code></p>&#13;
<p class="taba"><code>trim_copy(</code><span class="codestrong">s</span><code>)</code></p>&#13;
<p class="taba"><code>trim(</code><span class="codestrong">s</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes leading and trailing spaces from <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_first(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_first_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_first(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_first_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the first occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_first(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>erase_first_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_first(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_first_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_517"/>Erases the first occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_last(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_last_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_last(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_last_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the last occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_last(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>erase_last_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_last(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_last_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the last occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_nth(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_nth_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_nth(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_nth_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the <span class="codestrong">n</span>th occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_nth(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><code>erase_nth_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_nth(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_nth_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the <span class="codestrong">n</span>th occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_all(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_all_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_all(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>ireplace_all_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces all occurrences of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_all(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>erase_all_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_all(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ierase_all_copy(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases all occurrences of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_head(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_head_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the first <span class="codestrong">n</span> characters of <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_head(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><code>erase_head_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the first <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_tail(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_tail_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the last <span class="codestrong">n</span> characters of <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_tail(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><code>erase_tail_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the last <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_regex(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_regex_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the first instance of <span class="codestrong">rgx</span> in <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>erase_regex(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p>&#13;
<p class="taba"><code>erase_regex_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the first instance of <span class="codestrong">rgx</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>replace_all_regex(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>,</code> <span class="codestrong">r</span><code>)</code></p>&#13;
<p class="taba"><code>replace_all_regex_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>,</code> <span class="codestrong">r</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces all instances of <span class="codestrong">rgx</span> in <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>erase_all_regex(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p>&#13;
<p class="taba"><code>erase_all_regex_copy(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Erases all instances of <span class="codestrong">rgx</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec19"><strong><em>Splitting and Joining</em></strong></h4>&#13;
<p class="noindent">Boost String Algorithms contains functions for splitting and joining strings in the <code>&lt;boost/algorithm/string/split.hpp&gt;</code> and <code>&lt;boost/algorithm/string/join.</code><code>hpp&gt;</code> headers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_518"/>To split a <code>string</code>, you provide the <code>split</code> function with an STL container <code>res</code>, a range <code>s</code>, and a predicate <code>p</code>. It will tokenize the range <code>s</code> using the predicate <code>p</code> to determine delimiters and insert the results into <code>res</code>. <a href="ch15.xhtml#ch15ex33">Listing 15-33</a> illustrates the <code>split</code> function.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
#include &lt;boost/algorithm/string/split.hpp&gt;&#13;
#include &lt;boost/algorithm/string/classification.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::split splits a range based on a predicate") {&#13;
  using namespace boost::algorithm;&#13;
  std::string publisher("No Starch Press"); <span class="ent">➊</span>&#13;
  std::vector&lt;std::string&gt; tokens; <span class="ent">➋</span>&#13;
  split(tokens, publisher, is_space()); <span class="ent">➌</span>&#13;
  REQUIRE(tokens[0] == "No"); <span class="ent">➍</span>&#13;
  REQUIRE(tokens[1] == "Starch");&#13;
  REQUIRE(tokens[2] == "Press");&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex33"/><em>Listing 15-33: The <code>split</code> function tokenizes a <code>string</code>.</em></p>&#13;
<p class="indent">Armed again with <code>publisher</code> <span class="ent">➊</span>, you create a <code>vector</code> called <code>tokens</code> to contain the results <span class="ent">➋</span>. You invoke <code>split</code> with <code>tokens</code> as the results container, <code>publisher</code> as the range, and an <code>is_space</code> as your predicate <span class="ent">➌</span>. This splits the publisher into pieces by spaces. Afterward, <code>tokens</code> contains <code>No, Starch</code>, and <code>Press</code> as expected <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can perform the inverse operation with <code>join</code>, which accepts an STL container <code>seq</code> and a separator string <code>sep</code>. The <code>join</code> function will bind each element of <code>seq</code> together with <code>sep</code> between each.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex34">Listing 15-34</a> illustrates the utility of <code>join</code> and the indispensability of the Oxford comma.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
#include &lt;boost/algorithm/string/join.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::join staples tokens together") {&#13;
  std::vector&lt;std::string&gt; tokens{ "We invited the strippers",&#13;
                                   "JFK", "and Stalin." }; <span class="ent">➊</span>&#13;
  auto result = boost::algorithm::join(tokens, ", "); <span class="ent">➋</span>&#13;
  REQUIRE(result == "We invited the strippers, JFK, and Stalin."); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex34"/><em>Listing 15-34: The <code>join</code> function attaches <code>string</code> tokens together with a separator.</em></p>&#13;
<p class="indent">You instantiate a <code>vector</code> called <code>tokens</code> with three <code>string</code> objects <span class="ent">➊</span>. Next, you use <code>join</code> to bind token’s constituent elements together with a comma followed by a space <span class="ent">➋</span>. The result is a single <code>string</code> containing the constituent elements bound together with commas and spaces <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_519"/><a href="ch15.xhtml#ch15tab16">Table 15-16</a> lists many of the split/join algorithms available in <code>&lt;boost/algorithm/string/split.hpp&gt;</code> and <code>&lt;boost/algorithm/string/join.hpp&gt;</code>. In this table, <code>res, s, s1</code>, <code>s2</code>, and <code>sep</code> are strings; <code>seq</code> is a range of strings; <code>p</code> is an element comparison predicate; and <code>rgx</code> is a regular expression.</p>&#13;
<p class="tabcap"><a id="ch15tab16"/><strong>Table 15-16:</strong> <code>split</code> and <code>join</code> Algorithms in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>find_all(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ifind_all(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>find_all_regex(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s1</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p>&#13;
<p class="taba"><code>iter_find(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Finds all instances of <span class="codestrong">s2</span> or <span class="codestrong">rgx</span> in <span class="codestrong">s1</span>, writing each into <span class="codestrong">res</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>split(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s</span><code>,</code> <span class="codestrong">p</span><code>)</code></p>&#13;
<p class="taba"><code>split_regex(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p>&#13;
<p class="taba"><code>iter_split(</code><span class="codestrong">res</span><code>,</code> <span class="codestrong">s</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Split <span class="codestrong">s</span> using <span class="codestrong">p</span>, <span class="codestrong">rgx</span>, or <span class="codestrong">s2</span>, writing tokens into <span class="codestrong">res</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>join(</code><span class="codestrong">seq</span><code>,</code> <span class="codestrong">sep</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <code>string</code> joining <span class="codestrong">seq</span> using <span class="codestrong">sep</span> as a separator</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>join_if(</code><span class="codestrong">seq</span><code>,</code> <span class="codestrong">sep</span><code>,</code> <span class="codestrong">p</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a <code>string</code> joining all elements of <span class="codestrong">seq</span> matching <span class="codestrong">p</span> using <span class="codestrong">sep</span> as a separator</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec20"><strong><em>Searching</em></strong></h4>&#13;
<p class="noindent">Boost String Algorithms offers a handful of functions for searching ranges in the <code>&lt;boost/algorithm/string/find.hpp&gt;</code> header. These are essentially convenient wrappers around the finders in <a href="ch15.xhtml#ch15tab08">Table 15-8</a>.</p>&#13;
<p class="indent">For example, the <code>find_head</code> function accepts a range <code>s</code> and a length <code>n</code>, and it returns a range containing the first <code>n</code> elements of <code>s</code>. <a href="ch15.xhtml#ch15ex35">Listing 15-35</a> illustrates the <code>find_head</code> function.</p>&#13;
<pre>#include &lt;boost/algorithm/string/find.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::find_head computes the head") {&#13;
  std::string word("blandishment"); <span class="ent">➊</span>&#13;
  const auto result = boost::algorithm::find_head(word, 5); <span class="ent">➋</span>&#13;
  REQUIRE(result.begin() == word.begin()); <span class="ent">➌</span> // (b)landishment&#13;
  REQUIRE(result.end() == word.begin()+5); <span class="ent">➍</span> // bland(i)shment&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex35"/><em>Listing 15-35: The <code>find_head</code> function creates a range from the beginning of a <code>string</code>.</em></p>&#13;
<p class="indent">You construct a <code>string</code> called <code>word</code> containing <code>blandishment</code> <span class="ent">➊</span>. You pass it into <code>find_head</code> along with the length argument <code>5</code> <span class="ent">➋</span>. The <code>begin</code> of <code>result</code> points to the beginning of <code>word</code> <span class="ent">➌</span>, and its <code>end</code> points to 1 past the fifth element <span class="ent">➍</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab17">Table 15-17</a> lists many of the find algorithms available in <code>&lt;boost/algorithm/string/find.hpp&gt;</code>. In this table, <code>s, s1</code>, and <code>s2</code> are strings; <code>p</code> is an element comparison predicate; <code>rgx</code> is a regular expression; and <code>n</code> is an integral value.</p>&#13;
<p class="tabcap"><a id="ch15tab17"/><strong>Table 15-17:</strong><span epub:type="pagebreak" id="page_520"/> Find Algorithms in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Predicate</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Finds the . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>find_first(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ifind_first(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First instance of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>find_last(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p>&#13;
<p class="taba"><code>ifind_last(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First instance of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>find_nth(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>)</code></p>&#13;
<p class="taba"><code>ifind_nth(</code><span class="codestrong">s1</span><code>,</code> <span class="codestrong">s2</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">n</span>th instance of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>find_head(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>find_tail(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">n</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>find_token(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">p</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First character matching <span class="codestrong">p</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>find_regex(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">rgx</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First substring matching <span class="codestrong">rgx</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>find(</code><span class="codestrong">s</span><code>,</code> <span class="codestrong">fnd</span><code>)</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Result of applying <span class="codestrong">fnd</span> to <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch15lev1sec5"><strong>Boost Tokenizer</strong></h3>&#13;
<p class="noindent">Boost Tokenizer’s <code>boost::tokenizer</code> is a class template that provides a view of a series of tokens contained in a <code>string</code>. A <code>tokenizer</code> takes three optional template parameters: a tokenizer function, an iterator type, and a string type.</p>&#13;
<p class="indent">The <em>tokenizer function</em> is a predicate that determines whether a character is a delimiter (returns <code>true</code>) or not (returns <code>false</code>). The default tokenizer function interprets spaces and punctuation marks as separators. If you want to specify the delimiters explicitly, you can use the <code>boost::char_separator&lt;char&gt;</code> class, which accepts a C-string containing all the delimiting characters. For example, a <code>boost::char_separator&lt;char&gt;(";|,")</code> would separate on semicolons (<code>;</code>), pipes (<code>|</code>), and commas (<code>,</code>).</p>&#13;
<p class="indent">The iterator type and string type correspond with the type of <code>string</code> you want to split. By default, these are <code>std::string::const_iterator</code> and <code>std::string</code>, respectively.</p>&#13;
<p class="indent">Because <code>tokenizer</code> doesn’t allocate memory and <code>boost::algorithm::split</code> does, you should strongly consider using the former whenever you only need to iterate over the tokens of a <code>string</code> once.</p>&#13;
<p class="indent">A <code>tokenizer</code> exposes <code>begin</code> and <code>end</code> methods that return input iterators, so you can treat it as a range of values corresponding to the underlying token sequence.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex36">Listing 15-36</a> tokenizes the iconic palindrome <code>A man, a plan, a canal, Panama!</code> by comma.</p>&#13;
<pre>#include&lt;boost/tokenizer.hpp&gt;&#13;
#include&lt;string&gt;&#13;
&#13;
TEST_CASE("boost::tokenizer splits token-delimited strings") {&#13;
  std::string palindrome("A man, a plan, a canal, Panama!"); <span class="ent">➊</span>&#13;
  boost::char_separator&lt;char&gt; comma{ "," }; <span class="ent">➋</span>&#13;
  boost::tokenizer&lt;boost::char_separator&lt;char&gt;&gt; tokens{ palindrome, comma }; <span class="ent">➌</span>&#13;
  auto itr = tokens.begin(); <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_521"/>  REQUIRE(*itr == "A man"); <span class="ent">➎</span>&#13;
  itr++; <span class="ent">➏</span>&#13;
  REQUIRE(*itr == " a plan");&#13;
  itr++;&#13;
  REQUIRE(*itr == " a canal");&#13;
  itr++;&#13;
  REQUIRE(*itr == " Panama!");&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex36"/><em>Listing 15-36: The <code>boost::tokenizer</code> splits strings by specified delimiters.</em></p>&#13;
<p class="indent">Here, you construct <code>palindrome</code> <span class="ent">➊, char_separator</span> <span class="ent">➋</span>, and the corresponding <code>tokenizer</code> <span class="ent">➌</span>. Next, you extract an iterator from the tokenizer using its <code>begin</code> method <span class="ent">➍</span>. You can treat the resulting iterator as usual, dereferencing its value <span class="ent">➎</span> and incrementing to the next element <span class="ent">➏</span>.</p>&#13;
<h3 class="h3" id="ch15lev1sec6"><strong>Localizations</strong></h3>&#13;
<p class="noindent">A <em>locale</em> is a class for encoding cultural preferences. The locale concept is typically encoded in whatever operating environment your application runs within. It also controls many preferences, such as string comparison; date and time, money, and numeric formatting; postal and ZIP codes; and phone numbers.</p>&#13;
<p class="indent">The STL offers the <code>std::locale</code> class and many helper functions and classes in the <code>&lt;locale&gt;</code> header.</p>&#13;
<p class="indent">Mainly for brevity (and partially because English speakers are the primary intended audience for this book), this chapter won’t explore locales any further.</p>&#13;
<h3 class="h3" id="ch15lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter covered <code>std::string</code> and its ecosystem in detail. After exploring its similarities to <code>std::vector</code>, you learned about its built-in methods for handling human-language data, such as comparing, adding, removing, replacing, and searching. You looked at how the numeric conversion functions allow you to convert between numbers and strings, and you examined the role that <code>std::string_view</code> plays in passing strings around your programs. You also learned how to employ regular expressions to perform intricate match, search, and replacement based on potentially complicated patterns. Finally, you trekked through the Boost String Algorithms library, which complements and extends the built-in methods of <code>std::string</code> with additional methods for searching, replacing, trimming, erasing, splitting, and joining.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong><span epub:type="pagebreak" id="page_522"/>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>15-1.</strong> Refactor the histogram calculator in <a href="ch09.xhtml#ch09ex30">Listings 9-30</a> and <a href="ch09.xhtml#ch09ex31">9-31</a> to use <code>std::string</code>. Construct a <code>string</code> from the program’s input and modify <code>AlphaHistogram</code> to accept a <code>string_view</code> or a <code>const string&amp;</code> in its <code>ingest</code> method. Use a range-based <code>for</code> loop to iterate over the ingested elements of <code>string</code>. Replace the <code>counts</code> field’s type with an associative container.</p>&#13;
<p class="noindent"><strong>15-2.</strong> Implement a program that determines whether the user’s input is a palindrome.</p>&#13;
<p class="noindent"><strong>15-3.</strong> Implement a program that counts the number of vowels in the user’s input.</p>&#13;
<p class="noindent"><strong>15-4.</strong> Implement a calculator program that supports addition, subtraction, multiplication, and division of any two numbers. Consider using the <code>find</code> method of <code>std::string</code> and the numeric conversion functions.</p>&#13;
<p class="noindent"><strong>15-5.</strong> Extend your calculator program in some of the following ways: permit multiple operations or the modulo operator and accept floating-point numbers or parentheses.</p>&#13;
<p class="noindent"><strong>15-6.</strong> Optional: Read more about locales in [localization].</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li><li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>