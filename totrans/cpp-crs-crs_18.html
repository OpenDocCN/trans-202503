<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_480"/><span epub:type="pagebreak" id="page_481"/><strong><span class="big">15</span><br/>STRINGS</strong></h2>&#13;
<p class="quote"><em>If you talk to a man in a language he understands, that goes to his head. If you talk to him in his language, that goes to his heart.<br/>—Nelson Mandela</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">The STL provides a special <em>string container</em> for human-language data, such as words, sentences, and markup languages. Available in the <span class="literal">&lt;string&gt;</span> header, the <span class="literal">std::basic_string</span> is a class template that you can specialize on a string’s underlying character type. As a sequential container, <span class="literal">basic_string</span> is essentially similar to a <span class="literal">vector</span> but with some special facilities for manipulating language.</p>&#13;
<p class="indent">STL <span class="literal">basic_string</span> provides major safety and feature improvements over C-style or null-terminated strings, and because human-language data inundates most modern programs, you’ll probably find <span class="literal">basic_string</span> indispensable.</p>&#13;
<h3 class="h3" id="ch15lev1sec1"><span epub:type="pagebreak" id="page_482"/><strong>std::string</strong></h3>&#13;
<p class="noindent">The STL provides four <span class="literal">basic_string</span> specializations in the <span class="literal">&lt;string&gt;</span> header. Each specialization implements a string using one of the fundamental character types that you learned about in <a href="ch02.xhtml#ch02">Chapter 2</a>:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::string</span> for <span class="literal">char</span> is used for character sets like ASCII.</li>&#13;
<li class="noindent"><span class="literal">std::wstring</span> for <span class="literal">wchar_t</span> is large enough to contain the largest character of the implementation’s locale.</li>&#13;
<li class="noindent"><span class="literal">std::u16string</span> for <span class="literal">char16_t</span> is used for character sets like UTF-16.</li>&#13;
<li class="noindent"><span class="literal">std::u32string</span> for <span class="literal">char32_t</span> is used for character sets like UTF-32.</li>&#13;
</ul>&#13;
<p class="indent">You’ll use the specialization with the appropriate underlying type. Because these specializations have the same interface, all the examples in this chapter will use <span class="literal">std::string</span>.</p>&#13;
<h4 class="h4" id="ch15lev2sec1"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">basic_string</span> container takes three template parameters:</p>&#13;
<ul>&#13;
<li class="noindent">The underlying character type, <span class="literal">T</span></li>&#13;
<li class="noindent">The underlying type’s traits, <span class="literal">Traits</span></li>&#13;
<li class="noindent">An allocator, <span class="literal">Alloc</span></li>&#13;
</ul>&#13;
<p class="indent">Of these, only <span class="literal">T</span> is required. The STL’s <span class="literal">std::char_traits</span> template class in the <span class="literal">&lt;string&gt;</span> header abstracts character and string operations from the underlying character type. Also, unless you plan on supporting a custom character type, you won’t need to implement your own type traits, because <span class="literal">char_traits</span> has specializations available for <span class="literal">char, wchar_t</span>, <span class="literal">char16_t</span>, and <span class="literal">char32_t</span>. When the stdlib provides specializations for a type, you won’t need to provide it yourself unless you require some kind of exotic behavior.</p>&#13;
<p class="indent">Together, a <span class="literal">basic_string</span> specialization looks like this, where <span class="literal">T</span> is a character type:</p>&#13;
<pre>std::basic_string&lt;T, Traits=std::char_traits&lt;T&gt;, Alloc=std::allocator&lt;T&gt;&gt;</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In most cases, you’ll be dealing with one of the predefined specializations, especially <span class="codeitalic">string</span> or <span class="codeitalic">wstring</span>. However, if you need a custom allocator, you’ll need to specialize <span class="codeitalic">basic_string</span> appropriately.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">basic_string&lt;T&gt;</span> container supports the same constructors as <span class="literal">vector&lt;T&gt;</span>, plus additional convenience constructors for converting a C-style string. In other words, a <span class="literal">string</span> supports the constructors of <span class="literal">vector&lt;char&gt;</span>, a <span class="literal">wstring</span> supports the constructors of <span class="literal">vector&lt;wchar_t&gt;</span>, and so on. As with <span class="literal">vector</span>, use parentheses for all <span class="literal">basic_string</span> constructors except when you actually want an initializer list.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_483"/>You can default construct an empty string, or if you want to fill a <span class="literal">string</span> with a repeating character, you can use the fill constructor by passing a <span class="literal">size_t</span> and a <span class="literal">char</span>, as <a href="ch15.xhtml#ch15ex01">Listing 15-1</a> illustrates.</p>&#13;
<pre>#include &lt;string&gt;&#13;
TEST_CASE("std::string supports constructing") {&#13;
  SECTION("empty strings") {&#13;
    std::string cheese; <span class="ent">➊</span>&#13;
    REQUIRE(cheese.empty()); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("repeated characters") {&#13;
    std::string roadside_assistance(3, 'A'); <span class="ent">➌</span>&#13;
    REQUIRE(roadside_assistance == "AAA"); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex01"/><em>Listing 15-1: The default and fill constructors of <span class="literal">string</span></em></p>&#13;
<p class="indent">After you default construct a <span class="literal">string</span> <span class="ent">➊</span>, it contains no elements <span class="ent">➋</span>. If you want to fill the <span class="literal">string</span> with repeating characters, you can use the fill constructor by passing in the number of elements you want to fill and their value <span class="ent">➌</span>. The example fills a string with three <span class="literal">A</span> characters <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll learn about <span class="codeitalic">std::string</span> comparisons with <span class="codeitalic">operator==</span> later in the chapter. Because you generally handle C-style strings with raw pointers or raw arrays, <span class="codeitalic">operator==</span> returns true only when given the same object. However, for <span class="codeitalic">std::string</span>, <span class="codeitalic">operator==</span> returns true if the contents are equivalent. As you can see in <a href="ch15.xhtml#ch15ex01">Listing 15-1</a>, the comparison works even when one of the operands is a C-style string literal.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">string</span> constructor also offers two <span class="literal">const char*</span>-based constructors. If the argument points to a null-terminated <span class="literal">string</span>, the <span class="literal">string</span> constructor can determine the input’s length on its own. If the pointer does <em>not</em> point to a null-terminated string or if you only want to use the first part of a <span class="literal">string</span>, you can pass a length argument that informs the <span class="literal">string</span> constructor of how many elements to copy, as <a href="ch15.xhtml#ch15ex02">Listing 15-2</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::string supports constructing substrings ") {&#13;
  auto word = "gobbledygook"; <span class="ent">➊</span>&#13;
  REQUIRE(std::string(word) == "gobbledygook"); <span class="ent">➋</span>&#13;
  REQUIRE(std::string(word, 6) == "gobble"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex02"/><em>Listing 15-2: Constructing a <span class="literal">string</span> from C-style strings</em></p>&#13;
<p class="indent">You create a <span class="literal">const char*</span> called <span class="literal">word</span> pointing to the C-style string literal <span class="literal">gobbledygook</span> <span class="ent">➊</span>. Next, you construct a <span class="literal">string</span> by passing <span class="literal">word</span>. As expected, the resulting <span class="literal">string</span> contains <span class="literal">gobbledygook</span> <span class="ent">➋</span>. In the next test, you pass the number <span class="literal">6</span> as a second argument. This causes <span class="literal">string</span> to only take the first six characters of <span class="literal">word</span>, resulting in the <span class="literal">string</span> containing <span class="literal">gobble</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_484"/>Additionally, you can construct <span class="literal">string</span>s from other <span class="literal">string</span>s. As an STL container, <span class="literal">string</span> fully supports copy and move semantics. You can also construct a <span class="literal">string</span> from a <em>substring</em>—a contiguous subset of another string. <a href="ch15.xhtml#ch15ex03">Listing 15-3</a> illustrates these three constructors.</p>&#13;
<pre>TEST_CASE("std::string supports") {&#13;
  std::string word("catawampus"); <span class="ent">➊</span>&#13;
  SECTION("copy constructing") {&#13;
    REQUIRE(std::string(word) == "catawampus"); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("move constructing") {&#13;
    REQUIRE(std::string(move(word)) == "catawampus"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("constructing from substrings") {&#13;
    REQUIRE(std::string(word, 0, 3) == "cat"); <span class="ent">➍</span>&#13;
    REQUIRE(std::string(word, 4) == "wampus"); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex03"/><em>Listing 15-3: Copy, move, and substring construction of <span class="literal">string</span> objects</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In <a href="ch15.xhtml#ch15ex03">Listing 15-3</a>, <span class="literal">word</span> is in a moved-from state, which, you’ll recall from “Move Semantics” on <a href="ch04.xhtml#page_122">page 122</a>, means it can only be reassigned or destructed.</em></p>&#13;
</div>&#13;
<p class="indent">Here, you construct a <span class="literal">string</span> called <span class="literal">word</span> containing the characters <span class="literal">catawampus</span> <span class="ent">➊</span>. Copy construction yields another <span class="literal">string</span> containing a copy of the characters of <span class="literal">word</span> <span class="ent">➋</span>. Move construction steals the characters of <span class="literal">word</span>, resulting in a new <span class="literal">string</span> containing <span class="literal">catawampus</span> <span class="ent">➌</span>. Finally, you can construct a new <span class="literal">string</span> based on substrings. By passing <span class="literal">word</span>, a starting position of 0, and a length of 3, you construct a new <span class="literal">string</span> containing the characters <span class="literal">cat</span> <span class="ent">➍</span>. If you instead pass <span class="literal">word</span> and a starting position of 4 (without a length), you get all the characters from the fourth to the end of the original string, resulting in <span class="literal">wampus</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">The <span class="literal">string</span> class also supports literal construction with <span class="literal">std::string_</span><span class="literal">literals::operator""s</span>. The major benefit is notational convenience, but you can also use <span class="literal">operator""s</span> to embed null characters within a <span class="literal">string</span> easily, as <a href="ch15.xhtml#ch15ex04">Listing 15-4</a> illustrates.</p>&#13;
<pre>TEST_CASE("constructing a string with") {&#13;
  SECTION("std::string(char*) stops at embedded nulls") {&#13;
    std::string str("idioglossia\0ellohay!"); <span class="ent">➊</span>&#13;
    REQUIRE(str.length() == 11); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("operator\"\"s incorporates embedded nulls") {&#13;
    using namespace std::string_literals; <span class="ent">➌</span>&#13;
    auto str_lit = "idioglossia\0ellohay!"s; <span class="ent">➍</span>&#13;
    REQUIRE(str_lit.length() == 20); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex04"/><em>Listing 15-4: Constructing a <span class="literal">string</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_485"/>In the first test, you construct a <span class="literal">string</span> using the literal <span class="literal">idioglossia\0ellohay!</span> <span class="ent">➊</span>, which results in a <span class="literal">string</span> containing <span class="literal">idioglossia</span> <span class="ent">➋</span>, The remainder of the literal didn’t get copied into the <span class="literal">string</span> due to embedded nulls. In the second test, you bring in the <span class="literal">std::string_literals</span> namespace <span class="ent">➌</span> so you can use <span class="literal">operator""s</span> to construct a <span class="literal">string</span> from a literal directly <span class="ent">➍</span>. Unlike the <span class="literal">std::string</span> constructor <span class="ent">➊</span>, <span class="literal">operator""s</span> yields a string containing the entire literal—embedded null bytes and all <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab01">Table 15-1</a> summarizes the options for constructing a <span class="literal">string</span>. In this table, <span class="literal">c</span> is a <span class="literal">char, n</span> and <span class="literal">pos</span> are <span class="literal">size_t, str</span> is a <span class="literal">string</span> or a C-style string, <span class="literal">c_str</span> is a C-style string, and <span class="literal">beg</span> and <span class="literal">end</span> are input iterators.</p>&#13;
<p class="tabcap"><a id="ch15tab01"/><strong>Table 15-1:</strong> Supported <span class="literal">std::string</span> Constructors</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Constructor</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Produces</strong> a <span class="codestrong">string</span> <strong>containing</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">string()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">No characters.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">string(</span><span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">c</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">c</span> repeated <span class="codestrong">n</span> times.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">string(</span><span class="codestrong">str</span><span class="literal">,</span> <span class="codestrong">pos</span><span class="literal">, [</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The half-open range <span class="codestrong">pos</span> to <span class="codestrong">pos</span><span class="literal">+</span><span class="codestrong">n</span> of <span class="codestrong">str</span>. Substring extends from <span class="codestrong">pos</span> to <span class="codestrong">str</span>’s end if <span class="codestrong">n</span> is omitted.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">string(</span><span class="codestrong">c_str</span><span class="literal">, [</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A copy of <span class="codestrong">c_str</span>, which has length <span class="codestrong">n</span>. If <span class="codestrong">c_str</span> is null terminated, <span class="codestrong">n</span> defaults to the null-terminated string’s length.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">string(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A copy of the elements in the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">string(</span><span class="codestrong">str</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A copy of <span class="codestrong">str</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">string(move(</span><span class="codestrong">str</span><span class="literal">))</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The contents of <span class="codestrong">str</span>, which is in a moved-from state after construction.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">string{</span>  <span class="codestrong">c1</span><span class="literal">,</span> <span class="codestrong">c2</span><span class="literal">,</span> <span class="codestrong">c3</span> <span class="literal">}</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The characters <span class="codestrong">c1</span>, <span class="codestrong">c2</span>, and<span class="codestrong"> c3</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">"</span><span class="codestrong">my string literal</span><span class="literal">"s</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">A string containing the characters <span class="literal">my string literal</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec2"><strong><em>String Storage and Small String Optimizations</em></strong></h4>&#13;
<p class="noindent">Exactly like <span class="literal">vector, string</span> uses dynamic storage to store its constituent elements contiguously. Accordingly, <span class="literal">vector</span> and <span class="literal">string</span> have very similar copy/move-construction/assignment semantics. For example, copy operations are potentially more expensive than move operations because the contained elements reside in dynamic memory.</p>&#13;
<p class="indent">The most popular STL implementations have <em>small string optimizations (SSO)</em>. The SSO places the contents of a <span class="literal">string</span> within the object’s storage (rather than dynamic storage) if the contents are small enough. As a general rule, a <span class="literal">string</span> with fewer than 24 bytes is an SSO candidate. Implementers make this optimization because in many modern programs, most <span class="literal">string</span>s are short. (A <span class="literal">vector</span> doesn’t have any small optimizations.)</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Practically, SSO affects moves in two ways. First, any references to the elements of a <span class="literal">string</span> will invalidate if the <span class="literal">string</span> moves. Second, moves are potentially slower for <span class="literal">string</span>s than <span class="literal">vector</span>s because <span class="literal">string</span>s need to check for SSO.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_486"/>A <span class="literal">string</span> has a <em>size</em> (or <em>length</em>) and a <em>capacity</em>. The size is the number of characters contained in the <span class="literal">string</span>, and the capacity is the number of characters that the string can hold before needing to resize.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab02">Table 15-2</a> contains methods for reading and manipulating the size and capacity of a <span class="literal">string</span>. In this table, <span class="literal">n</span> is a <span class="literal">size_t</span>. An asterisk (*) indicates that this operation invalidates raw pointers and iterators to the elements of <span class="literal">s</span> in at least some circumstances.</p>&#13;
<p class="tabcap"><a id="ch15tab02"/><strong>Table 15-2:</strong> Supported <span class="literal">std::string</span> Storage and Length Methods</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">true</span> if <span class="codestrong">s</span> contains no characters; otherwise <span class="literal">false</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The number of characters in <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.length()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Identical to <span class="codestrong">s</span><span class="literal">.size()</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.max_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The maximum possible size of <span class="codestrong">s</span> (due to system/runtime limitations).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.capacity()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The number of characters <span class="codestrong">s</span> can hold before needing to resize.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.shrink_to_fit()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">void</span>; issues a non-binding request to reduce <span class="codestrong">s</span><span class="literal">.capacity()</span> to <span class="codestrong">s</span><span class="literal">.size()</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">s</span><span class="literal">.reserve([</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">void</span>; if <span class="literal">n &gt;</span>  <span class="codestrong">s</span><span class="literal">.capacity()</span>, resizes so <span class="codestrong">s</span> can hold at least <span class="codestrong">n</span> elements; otherwise, issues a non-binding request* to reduce <span class="codestrong">s</span><span class="literal">.capacity()</span> to <span class="codestrong">n</span> or <span class="codestrong">s</span><span class="literal">.size()</span>, whichever is greater.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At press time, the draft C++20 standard changes the behavior of the <span class="literal">reserve</span> method when its argument is less than the size of the <span class="literal">string</span>. This will match the behavior of <span class="literal">vector</span>, where there is no effect rather than being equivalent to invoking <span class="literal">shrink_to_fit</span>.</em></p>&#13;
</div>&#13;
<p class="indent">Note that the size and capacity methods of <span class="literal">string</span> match those of <span class="literal">vector</span> very closely. This is a direct result of the closeness of their storage models.</p>&#13;
<h4 class="h4" id="ch15lev2sec3"><strong><em>Element and Iterator Access</em></strong></h4>&#13;
<p class="noindent">Because <span class="literal">string</span> offers random-access iterators to contiguous elements, it accordingly exposes similar element- and iterator-access methods to <span class="literal">vector</span>.</p>&#13;
<p class="indent">For interoperation with C-style APIs, <span class="literal">string</span> also exposes a <span class="literal">c_str</span> method, which returns a non-modifiable, null-terminated version of the string as a <span class="literal">const char*</span>, as <a href="ch15.xhtml#ch15ex05">Listing 15-5</a> illustrates.</p>&#13;
<pre>TEST_CASE("string's c_str method makes null-terminated strings") {&#13;
  std::string word("horripilation"); <span class="ent">➊</span>&#13;
  auto as_cstr = word.c_str(); <span class="ent">➋</span>&#13;
  REQUIRE(as_cstr[0] ==  'h'); <span class="ent">➌</span>&#13;
  REQUIRE(as_cstr[1] ==  'o');&#13;
  REQUIRE(as_cstr[11] == 'o');&#13;
  REQUIRE(as_cstr[12] == 'n');&#13;
  REQUIRE(as_cstr[13] == '\0'); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex05"/><em>Listing 15-5: Extracting a null-terminated string from a <span class="literal">string</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_487"/>You construct a <span class="literal">string</span> called <span class="literal">word</span> containing the characters <span class="literal">horripilation</span> <span class="ent">➊</span> and use its <span class="literal">c_str</span> method to extract a null-terminated string called <span class="literal">as_cstr</span> <span class="ent">➋</span>. Because <span class="literal">as_cstr</span> is a <span class="literal">const char*</span>, you can use <span class="literal">operator[]</span> to illustrate that it contains the same characters as <span class="literal">word</span> <span class="ent">➌</span> and that it is null terminated <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal">std::string</span> class also supports <span class="literal">operator[]</span>, which has the same behavior as with a C-style string.</em></p>&#13;
</div>&#13;
<p class="indent">Generally, <span class="literal">c_str</span> and <span class="literal">data</span> produce identical results except that references returned by <span class="literal">data</span> can be non-<span class="literal">const</span>. Whenever you manipulate a <span class="literal">string</span>, implementations usually ensure that the contiguous memory backing the <span class="literal">string</span> ends with a null terminator. The program in <a href="ch15.xhtml#ch15ex06">Listing 15-6</a> illustrates this behavior by printing the results of calling <span class="literal">data</span> and <span class="literal">c_str</span> alongside their addresses.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
int main() {&#13;
  std::string word("pulchritudinous");&#13;
  printf("c_str: %s at 0x%p\n", word.c_str(), word.c_str()); <span class="ent">➊</span>&#13;
  printf("data:  %s at 0x%p\n", word.data(), word.data()); <span class="ent">➋</span>&#13;
}&#13;
<span class="color1">--------------------------------------------------------------------------</span>&#13;
<span class="color1">c_str: pulchritudinous at 0x0000002FAE6FF8D0 <span class="ent">➊</span></span>&#13;
<span class="color1">data:  pulchritudinous at 0x0000002FAE6FF8D0 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch15ex06"/><em>Listing 15-6: Illustrating that <span class="literal">c_str</span> and <span class="literal">data</span> return equivalent addresses</em></p>&#13;
<p class="indent">Both <span class="literal">c_str</span> and <span class="literal">data</span> produce identical results because they point to the same addresses <span class="ent">➊ ➋</span>. Because the address is the beginning of a null-terminated <span class="literal">string, printf</span> yields identical output for both invocations.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab03">Table 15-3</a> lists the access methods of <span class="literal">string</span>. Note that <span class="literal">n</span> is a <span class="literal">size_t</span> in the table.</p>&#13;
<p class="tabcap"><a id="ch15tab03"/><strong>Table 15-3:</strong> Supported <span class="literal">std::string</span> Element and Iterator Access Methods</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.begin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.cbegin()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <span class="literal">const</span> iterator pointing to the first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.end()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An iterator pointing to one past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.cend()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <span class="literal">const</span> iterator pointing to one past the last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.at(</span><span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference to element <span class="codestrong">n</span> of <span class="codestrong">s</span>. Throws <span class="literal">std::out_of_range</span> if out of bounds.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">[</span><span class="codestrong">n</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A reference to element <span class="codestrong">n</span> of <span class="codestrong">s</span>. Undefined behavior if <span class="codestrong">n</span> <span class="literal">&gt;</span> <span class="codestrong">s</span><span class="literal">.size()</span>. Also <span class="codestrong">s</span><span class="literal">[</span><span class="codestrong">s</span><span class="literal">.size()]</span> must be 0, so writing a non-zero value into this character is undefined behavior.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.front()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference to first element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.back()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A reference to last element.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_488"/><span class="codestrong">s</span><span class="literal">.data()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A raw pointer to the first element if string is non-empty. For an empty string, returns a pointer to a null character.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s</span><span class="literal">.c_str()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a non-modifiable, null-terminated version of the contents of <span class="codestrong">s</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec4"><strong><em>String Comparisons</em></strong></h4>&#13;
<p class="noindent">Note that <span class="literal">string</span> supports comparisons with other strings and with raw C-style strings using the usual comparison operators. For example, the equality <span class="literal">operator==</span> returns <span class="literal">true</span> if the size and contents of the left and right size are equal, whereas the inequality <span class="literal">operator!=</span> returns the opposite. The remaining comparison operators perform <em>lexicographical comparison</em>, meaning they sort alphabetically where <em>A</em> &lt; <em>Z</em> &lt; <em>a</em> &lt; <em>z</em> and where, if all else is equal, shorter words are less than longer words (for example, <em>pal</em> &lt; <em>palindrome</em>). <a href="ch15.xhtml#ch15ex07">Listing 15-7</a> illustrates comparisons.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Technically, lexicographical comparison depends on the encoding of the <span class="literal">string</span>. It’s theoretically possible that a system could use a default encoding where the alphabet is in some completely jumbled order (such as the nearly obsolete EBCDIC encoding, which put lowercase letters before uppercase letters), which would affect <span class="literal">string</span> comparison. For ASCII-compatible encodings, you don’t need to worry since they imply the expected lexicographical behavior.</em></p>&#13;
</div>&#13;
<pre>TEST_CASE("std::string supports comparison with") {&#13;
  using namespace std::literals::string_literals; <span class="ent">➊</span>&#13;
  std::string word("allusion"); <span class="ent">➋</span>&#13;
  SECTION("operator== and !=") {&#13;
    REQUIRE(word == "allusion"); <span class="ent">➌</span>&#13;
    REQUIRE(word == "allusion"s); <span class="ent">➍</span>&#13;
    REQUIRE(word != "Allusion"s); <span class="ent">➎</span>&#13;
    REQUIRE(word != "illusion"s); <span class="ent">➏</span>&#13;
    REQUIRE_FALSE(word == "illusion"s); <span class="ent">➐</span>&#13;
  }&#13;
  SECTION("operator&lt;") {&#13;
    REQUIRE(word &lt; "illusion"); <span class="ent">➑</span>&#13;
    REQUIRE(word &lt; "illusion"s); <span class="ent">➒</span>&#13;
    REQUIRE(word &gt; "Illusion"s); <span class="ent">➓</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex07"/><em>Listing 15-7: The <span class="literal">string</span> class supports comparison</em></p>&#13;
<p class="indent">Here, you bring in the <span class="literal">std::literals::string_literals</span> namespace so you can easily construct a <span class="literal">string</span> with <span class="literal">operator""s</span> <span class="ent">➊</span>. You also construct a <span class="literal">string</span> called <span class="literal">word</span> containing the characters <span class="literal">allusion</span> <span class="ent">➋</span>. In the first set of tests, you examine <span class="literal">operator==</span> and <span class="literal">operator!=</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_489"/>You can see that <span class="literal">word</span> equals (<span class="literal">==</span>) <span class="literal">allusion</span> as both a C-style string <span class="ent">➌</span> and a <span class="literal">string</span> <span class="ent">➍</span>, but it doesn’t equal (<span class="literal">!=</span>) <span class="literal">string</span>s containing <span class="literal">Allusion</span> <span class="ent">➎</span> or <span class="literal">illusion</span> <span class="ent">➏</span>. As usual, <span class="literal">operator==</span> and <span class="literal">operator!=</span> always return opposite results <span class="ent">➐</span>.</p>&#13;
<p class="indent">The next set of tests uses <span class="literal">operator&lt;</span> to show that <span class="literal">allusion</span> is less than <span class="literal">illu</span><span class="literal">sion</span> <span class="ent">➑</span>, because <em>a</em> is lexicographically less than <em>i</em>. Comparisons work with C-style strings and <span class="literal">string</span>s <span class="ent">➒</span>. <a href="ch15.xhtml#ch15ex07">Listing 15-7</a> also shows that <span class="literal">Allusion</span> is less than <span class="literal">allusion</span> <span class="ent">➓</span> because <em>A</em> is lexicographically less than <em>a</em>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab04">Table 15-4</a> lists the comparison methods of <span class="literal">string</span>. Note that <span class="literal">other</span> is a <span class="literal">string</span> or <span class="literal">char*</span> C-style string in the table.</p>&#13;
<p class="tabcap"><a id="ch15tab04"/><strong>Table 15-4:</strong> Supported <span class="literal">std::string</span> Comparison Operators</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span>  <span class="literal">==</span>  <span class="codestrong">other</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">true</span> if <span class="codestrong">s</span> and <span class="codestrong">other</span> have identical characters and lengths; otherwise <span class="literal">false</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span>  <span class="literal">!=</span> <span class="codestrong">other</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The opposite of <span class="literal">operator==</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.compare(</span><span class="codestrong">other</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns 0 if <span class="codestrong">s</span>  <span class="literal">==</span>  <span class="codestrong">other</span>, a negative number if <span class="codestrong">s</span>  <span class="literal">&lt;</span>  <span class="codestrong">other</span>, and a positive number if <span class="codestrong">s</span>  <span class="literal">&gt;</span>  <span class="codestrong">other</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s</span>  <span class="literal">&lt;</span>  <span class="codestrong">other</span></p>&#13;
<p class="taba"><span class="codestrong">s</span>  <span class="literal">&gt;</span>  <span class="codestrong">other</span></p>&#13;
<p class="taba"><span class="codestrong">s</span>  <span class="literal">&lt;=</span>  <span class="codestrong">other</span></p>&#13;
<p class="taba"><span class="codestrong">s</span>  <span class="literal">&gt;=</span>  <span class="codestrong">other</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">The result of the corresponding comparison operation, according to lexicographical sort</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec5"><strong><em>Manipulating Elements</em></strong></h4>&#13;
<p class="noindent">For manipulating elements, <span class="literal">string</span> has <em>a lot</em> of methods. It supports all the methods of <span class="literal">vector&lt;char&gt;</span> plus many others useful to manipulating human-language data.</p>&#13;
<h5 class="h5" id="ch15lev3sec1"><strong>Adding Elements</strong></h5>&#13;
<p class="noindent">To add elements to a <span class="literal">string</span>, you can use <span class="literal">push_back</span>, which inserts a single character at the end. When you want to insert more than one character to the end of a <span class="literal">string</span>, you can use <span class="literal">operator+=</span> to append a character, a null-terminated <span class="literal">char*</span> string, or a <span class="literal">string</span>. You can also use the <span class="literal">append</span> method, which has three overloads. First, you can pass a <span class="literal">string</span> or a null-terminated <span class="literal">char*</span> string, an optional offset into that <span class="literal">string</span>, and an optional number of characters to append. Second, you can pass a length and a <span class="literal">char</span>, which will append that number of <span class="literal">char</span>s to the string. Third, you can append a half-open range. <a href="ch15.xhtml#ch15ex08">Listing 15-8</a> illustrates all of these operations.</p>&#13;
<pre>TEST_CASE("std::string supports appending with") {&#13;
  std::string word("butt"); <span class="ent">➊</span>&#13;
  SECTION("push_back") {&#13;
    word.push_back('e'); <span class="ent">➋</span>&#13;
    REQUIRE(word == "butte");&#13;
  }&#13;
  SECTION("operator+=") {&#13;
    word += "erfinger"; <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_490"/>    REQUIRE(word == "butterfinger");&#13;
  }&#13;
  SECTION("append char") {&#13;
    word.append(1, 's'); <span class="ent">➍</span>&#13;
    REQUIRE(word == "butts");&#13;
  }&#13;
  SECTION("append char*") {&#13;
    word.append("stockings", 5); <span class="ent">➎</span>&#13;
    REQUIRE(word == "buttstock");&#13;
  }&#13;
  SECTION("append (half-open range)") {&#13;
    std::string other("onomatopoeia"); <span class="ent">➏</span>&#13;
    word.append(other.begin(), other.begin()+2); <span class="ent">➐</span>&#13;
    REQUIRE(word == "button");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex08"/><em>Listing 15-8: Appending to a <span class="literal">string</span></em></p>&#13;
<p class="indent">To begin, you initialize a <span class="literal">string</span> called <span class="literal">word</span> containing the characters <span class="literal">butt</span> <span class="ent">➊</span>. In the first test, you invoke <span class="literal">push_back</span> with the letter <span class="literal">e</span> <span class="ent">➋</span>, which yields <span class="literal">butte</span>. Next, you add <span class="literal">erfinger</span> to <span class="literal">word</span> using <span class="literal">operator+=</span> <span class="ent">➌</span>, yielding <span class="literal">butterfinger</span>. In the first invocation of <span class="literal">append</span>, you append a single <span class="literal">s</span> <span class="ent">➍</span> to yield <span class="literal">butts</span>. (This setup works just like <span class="literal">push_back</span>.) A second overload of <span class="literal">append</span> allows you to provide a <span class="literal">char*</span> and a length. By providing <span class="literal">stockings</span> and length <span class="literal">5</span>, you add <span class="literal">stock</span> to <span class="literal">word</span> to yield <span class="literal">buttstock</span> <span class="ent">➎</span>. Because <span class="literal">append</span> works with half-open ranges, you can also construct a <span class="literal">string</span> called <span class="literal">other</span> containing the characters <span class="literal">onomatopoeia</span> <span class="ent">➏</span> and append the first two characters via a half-open range to yield <span class="literal">button</span> <span class="ent">➐</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall from “Test Cases and Sections” on <a href="ch10.xhtml#page_308">page 308</a> that each <span class="literal">SECTION</span> of a Catch unit test runs independently, so modifications to <span class="literal">word</span> are independent of each other: the setup code resets <span class="literal">word</span> for each test.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch15lev3sec2"><strong>Removing Elements</strong></h5>&#13;
<p class="noindent">To remove elements from a <span class="literal">string</span>, you have several options. The simplest method is to use <span class="literal">pop_back</span>, which follows <span class="literal">vector</span> in removing the last character from a <span class="literal">string</span>. If you want to instead remove all the characters (to yield an empty <span class="literal">string</span>), use the <span class="literal">clear</span> method. When you need more precision in removing elements, use the <span class="literal">erase</span> method, which provides several overloads. You can provide an index and a length, which removes the corresponding characters. You can also provide an iterator to remove a single element or a half-open range to remove many. <a href="ch15.xhtml#ch15ex09">Listing 15-9</a> illustrates removing elements from a <span class="literal">string</span>.</p>&#13;
<pre>TEST_CASE("std::string supports removal with") {&#13;
  std::string word("therein"); <span class="ent">➊</span>&#13;
  SECTION("pop_back") {&#13;
    word.pop_back();&#13;
    word.pop_back(); <span class="ent">➋</span>&#13;
    REQUIRE(word == "there");&#13;
  }&#13;
<span epub:type="pagebreak" id="page_491"/>  SECTION("clear") {&#13;
    word.clear(); <span class="ent">➌</span>&#13;
    REQUIRE(word.empty());&#13;
  }&#13;
  SECTION("erase using half-open range") {&#13;
    word.erase(word.begin(), word.begin()+3); <span class="ent">➍</span>&#13;
    REQUIRE(word == "rein");&#13;
  }&#13;
  SECTION("erase using an index and length") {&#13;
    word.erase(5, 2);&#13;
    REQUIRE(word == "there"); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex09"/><em>Listing 15-9: Removing elements from a <span class="literal">string</span></em></p>&#13;
<p class="indent">You construct a <span class="literal">string</span> called <span class="literal">word</span> containing the characters <span class="literal">therein</span> <span class="ent">➊</span>. In the first test, you call <span class="literal">pop_back</span> twice to first remove the letter <span class="literal">n</span> followed by the letter <span class="literal">i</span> so <span class="literal">word</span> contains the characters <span class="literal">there</span> <span class="ent">➋</span>. Next, you invoke <span class="literal">clear</span>, which removes all the characters from <span class="literal">word</span> so it’s <span class="literal">empty</span> <span class="ent">➌</span>. The last two tests use <span class="literal">erase</span> to remove some subset of the characters in <span class="literal">word</span>. In the first usage, you remove the first three characters with a half-open range so <span class="literal">word</span> contains <span class="literal">rein</span> <span class="ent">➍</span>. In the second, you remove the characters starting at index 5 (<span class="literal">i</span> in <span class="literal">therein</span>) and extending two characters <span class="ent">➎</span>. Like the first test, this yields the characters <span class="literal">there</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec3"><strong>Replacing Elements</strong></h5>&#13;
<p class="noindent">To insert and remove elements simultaneously, use <span class="literal">string</span> to expose the <span class="literal">replace</span> method, which has many overloads.</p>&#13;
<p class="indent">First, you can provide a half-open range and a null-terminated <span class="literal">char*</span> or a <span class="literal">string</span>, and <span class="literal">replace</span> will perform a simultaneous <span class="literal">erase</span> of all the elements within the half-open range and an <span class="literal">insert</span> of the provided <span class="literal">string</span> where the range used to be. Second, you can provide two half-open ranges, and <span class="literal">replace</span> will insert the second range instead of a <span class="literal">string</span>.</p>&#13;
<p class="indent">Instead of replacing a range, you can use either an index or a single iterator and a length. You can supply a new half-open range, a character and a size, or a <span class="literal">string</span>, and <span class="literal">replace</span> will substitute new elements over the implied range. <a href="ch15.xhtml#ch15ex10">Listing 15-10</a> demonstrates some of these possibilities.</p>&#13;
<pre>TEST_CASE("std::string replace works with") {&#13;
  std::string word("substitution"); <span class="ent">➊</span>&#13;
  SECTION("a range and a char*") {&#13;
    word.replace(word.begin()+9, word.end(), "e"); <span class="ent">➋</span>&#13;
    REQUIRE(word == "substitute");&#13;
  }&#13;
  SECTION("two ranges") {&#13;
    std::string other("innuendo");&#13;
    word.replace(word.begin(), word.begin()+3,&#13;
                 other.begin(), other.begin()+2); <span class="ent">➌</span>&#13;
    REQUIRE(word == "institution");&#13;
  }&#13;
<span epub:type="pagebreak" id="page_492"/>  SECTION("an index/length and a string") {&#13;
    std::string other("vers");&#13;
    word.replace(3, 6, other); <span class="ent">➍</span>&#13;
    REQUIRE(word == "subversion");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex10"/><em>Listing 15-10: Replacing elements of a <span class="literal">string</span></em></p>&#13;
<p class="indent">Here, you construct a <span class="literal">string</span> called <span class="literal">word</span> containing <span class="literal">substitution</span> <span class="ent">➊</span>. In the first test, you replace all the characters from index 9 to the end with the letter <span class="literal">e</span>, resulting in the word <span class="literal">substitute</span> <span class="ent">➋</span>. Next, you replace the first three letters of <span class="literal">word</span> with the first two letters of a <span class="literal">string</span> containing <span class="literal">innuendo</span> <span class="ent">➌</span>, resulting in <span class="literal">institution</span>. Finally, you use an alternate way of specifying the target sequence with an index and a length to replace the characters <span class="literal">stitut</span> with the characters <span class="literal">vers</span>, yielding <span class="literal">subversion</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">The <span class="literal">string</span> class offers a <span class="literal">resize</span> method to manually set the length of <span class="literal">string</span>. The <span class="literal">resize</span> method takes two arguments: a new length and an optional <span class="literal">char</span>. If the new length of <span class="literal">string</span> is smaller, <span class="literal">resize</span> ignores the <span class="literal">char</span>. If the new length of <span class="literal">string</span> is larger, <span class="literal">resize</span> appends the <span class="literal">char</span> the implied number of times to achieve the desired length. <a href="ch15.xhtml#ch15ex11">Listing 15-11</a> illustrates the <span class="literal">resize</span> method.</p>&#13;
<pre>TEST_CASE("std::string resize") {&#13;
  std::string word("shamp"); <span class="ent">➊</span>&#13;
  SECTION("can remove elements") {&#13;
    word.resize(4); <span class="ent">➋</span>&#13;
    REQUIRE(word == "sham");&#13;
  }&#13;
  SECTION("can add elements") {&#13;
    word.resize(7, 'o'); <span class="ent">➌</span>&#13;
    REQUIRE(word == "shampoo");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex11"/><em>Listing 15-11: Resizing a <span class="literal">string</span></em></p>&#13;
<p class="indent">You construct a <span class="literal">string</span> called <span class="literal">word</span> containing the characters <span class="literal">shamp</span> <span class="ent">➊</span>. In the first test, you resize <span class="literal">word</span> to length <span class="literal">4</span> so it contains <span class="literal">sham</span> <span class="ent">➋</span>. In the second, you <span class="literal">resize</span> to a length of 7 and provide the optional character <span class="literal">o</span> as the value to extend <span class="literal">word</span> with <span class="ent">➌</span>. This results in <span class="literal">word</span> containing <span class="literal">shampoo</span>.</p>&#13;
<p class="indent">The “Constructing” section on <a href="ch15.xhtml#page_482">page 482</a> explained a substring constructor that can extract contiguous sequences of characters to create a new <span class="literal">s</span><span class="literal">tring</span>. You can also generate substrings using the <span class="literal">substr</span> method, which takes two optional arguments: a position argument and a length. The position defaults to 0 (the beginning of the <span class="literal">string</span>), and the length defaults to the remainder of the <span class="literal">string</span>. <a href="ch15.xhtml#ch15ex12">Listing 15-12</a> illustrates how to use <span class="literal">substr</span>.</p>&#13;
<pre>TEST_CASE("std::string substr with") {&#13;
  std::string word("hobbits"); <span class="ent">➊</span>&#13;
  SECTION("no arguments copies the string") {&#13;
<span epub:type="pagebreak" id="page_493"/>    REQUIRE(word.substr() == "hobbits"); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("position takes the remainder") {&#13;
    REQUIRE(word.substr(3) == "bits"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("position/index takes a substring") {&#13;
    REQUIRE(word.substr(3, 3) == "bit"); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex12"/><em>Listing 15-12: Extracting substrings from a <span class="literal">string</span></em></p>&#13;
<p class="indent">You declare a <span class="literal">string</span> called <span class="literal">word</span> containing <span class="literal">hobbits</span> <span class="ent">➊</span>. If you invoke <span class="literal">sub</span><span class="literal">str</span> with no arguments, you simply copy the <span class="literal">string</span> <span class="ent">➋</span>. When you provide the position argument <span class="literal">3, substr</span> extracts the substring beginning at element 3 and extending to the end of the <span class="literal">string</span>, yielding <span class="literal">bits</span> <span class="ent">➌</span>. Finally, when you provide a position (3) and a length (3), you instead get <span class="literal">bit</span> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec4"><strong>Summary of string Manipulation Methods</strong></h5>&#13;
<p class="noindent"><a href="ch15.xhtml#ch15tab05">Table 15-5</a> lists many of the insertion and deletion methods of <span class="literal">string</span>. In this table, <span class="literal">str</span> is a string or a C-style <span class="literal">char*</span> string, <span class="literal">p</span> and <span class="literal">n</span> are <span class="literal">size_t, ind</span> is a <span class="literal">size_t</span> index or an iterator into <span class="literal">s, n</span> and <span class="literal">i</span> are a <span class="literal">size_t, c</span> is a <span class="literal">char</span>, and <span class="literal">beg</span> and <span class="literal">end</span> are iterators. An asterisk (*) indicates that this operation invalidates raw pointers and iterators to <span class="literal">v</span>’s elements in at least some circumstances.</p>&#13;
<p class="tabcap"><a id="ch15tab05"/><strong>Table 15-5:</strong> Supported <span class="literal">std::string</span> Element Manipulation Methods</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.insert(</span><span class="codestrong">ind</span><span class="literal">,</span> <span class="codestrong">str</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts the <span class="codestrong">n</span> elements of <span class="codestrong">str</span>, starting at <span class="codestrong">p</span>, into <span class="codestrong">s</span> just before <span class="codestrong">ind</span>. If no <span class="codestrong">n</span> supplied, inserts the entire <span class="literal">string</span> or up to the first null of a <span class="literal">char*</span>; <span class="codestrong">p</span> defaults to 0.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.insert(</span><span class="codestrong">ind</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">c</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Inserts <span class="codestrong">n</span> copies of <span class="codestrong">c</span> just before <span class="codestrong">ind</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.insert(</span><span class="codestrong">ind</span><span class="literal">,</span> <span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Inserts the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span> just before <span class="codestrong">ind</span>. *</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.append(</span><span class="codestrong">str</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Equivalent to <span class="codestrong">s</span><span class="literal">.insert(</span><span class="codestrong">s</span><span class="literal">.end(),</span> <span class="codestrong">str</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">n</span><span class="literal">])</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.append(</span><span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">c</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Equivalent to <span class="codestrong">s</span><span class="literal">.insert(</span><span class="codestrong">s</span><span class="literal">.end(),</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">c</span><span class="literal">)</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.append(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Appends the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span> to the end of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span> <span class="literal">+=</span> <span class="codestrong">c</span><br/><span class="codestrong">s</span> <span class="literal">+=</span> <span class="codestrong">str</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Appends <span class="codestrong">c</span> or <span class="codestrong">str</span> to the end of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.push_back(</span><span class="codestrong">c</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Appends <span class="codestrong">c</span> to the end of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.clear()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes all characters from <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.erase([</span><span class="codestrong">i</span><span class="literal">], [</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes <span class="codestrong">n</span> characters starting at position <span class="codestrong">i</span>; <span class="codestrong">i</span> defaults to 0, and <span class="codestrong">n</span> defaults to the remainder of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.erase(</span><span class="codestrong">itr</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the element pointed to by <span class="codestrong">itr</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.erase(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Erases the elements on the half-open range from <span class="codestrong">beg</span> to <span class="codestrong">end</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.pop_back()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes the last element of <span class="codestrong">s</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><span epub:type="pagebreak" id="page_494"/><p class="taba"><span class="codestrong">s</span><span class="literal">.resize(</span><span class="codestrong">n</span><span class="literal">,</span><span class="literal">[</span><span class="codestrong">c</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Resizes the string so it contains <span class="codestrong">n</span> characters. If this operation increases the string’s length, it adds copies of <span class="codestrong">c</span>, which defaults to 0.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.replace(</span><span class="codestrong">i</span><span class="literal">,</span> <span class="codestrong">n1</span><span class="literal">,</span> <span class="codestrong">str</span><span class="literal">,</span> <span class="literal">[</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">n2</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces the <span class="codestrong">n1</span> characters starting at index <span class="codestrong">i</span> with the <span class="codestrong">n2</span> elements in <span class="codestrong">str</span> starting at <span class="codestrong">p</span>. By default, <span class="codestrong">p</span> is 0 and <span class="codestrong">n2</span> is <span class="codestrong">str</span><span class="literal">.length()</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.replace(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">,</span> <span class="codestrong">str</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span> with <span class="codestrong">str</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.replace(</span><span class="codestrong">p</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">str</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces from index <span class="codestrong">p</span> to <span class="codestrong">p+n</span> with <span class="codestrong">str</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.replace(</span><span class="codestrong">beg1</span><span class="literal">,</span> <span class="codestrong">end1</span><span class="literal">,</span> <span class="codestrong">beg2</span><span class="literal">,</span> <span class="codestrong">end2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the half-open range <span class="codestrong">beg1</span> to <span class="codestrong">end1</span> with the half-open range <span class="codestrong">beg2</span> to <span class="codestrong">end2</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.replace(</span><span class="codestrong">ind</span><span class="literal">,</span> <span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">n</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Replaces <span class="codestrong">n</span> elements starting at <span class="codestrong">ind</span> with <span class="codestrong">c</span>s.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.replace(</span><span class="codestrong">ind</span><span class="literal">,</span> <span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces elements starting at <span class="codestrong">ind</span> with the half-open range <span class="codestrong">beg</span> to <span class="codestrong">end</span>.*</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.substr([</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">c</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the substring starting at <span class="codestrong">p</span> with length <span class="codestrong">c</span>. By default, <span class="codestrong">p</span> is 0 and <span class="codestrong">c</span> is the remainder of the string.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s1</span><span class="literal">.swap(</span><span class="codestrong">s2</span><span class="literal">)</span><br/>&#13;
<span class="literal">swap(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exchanges the contents of <span class="codestrong">s1</span> and <span class="codestrong">s2</span>.*</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec6"><strong><em>Search</em></strong></h4>&#13;
<p class="noindent">In addition to the preceding methods, <span class="literal">string</span> offers several <em>search methods</em>, which enable you to locate substrings and characters that you’re interested in. Each method performs a particular kind of search, so which you choose depends on the particulars of the application.</p>&#13;
<h5 class="h5" id="ch15lev3sec5"><strong>find</strong></h5>&#13;
<p class="noindent">The first method <span class="literal">string</span> offers is <span class="literal">find</span>, which accepts a <span class="literal">string</span>, a C-style <span class="literal">string</span>, or a <span class="literal">char</span> as its first argument. This argument is an element that you want to locate within <span class="literal">this</span>. Optionally, you can provide a second <span class="literal">size_t</span> position argument that tells <span class="literal">find</span> where to start looking. If <span class="literal">find</span> fails to locate the substring, it returns the special <span class="literal">size_t</span>-valued, constant, <span class="literal">static</span> member <span class="literal">std::string::npos</span>. <a href="ch15.xhtml#ch15ex13">Listing 15-13</a> illustrates the <span class="literal">find</span> method.</p>&#13;
<pre>TEST_CASE("std::string find") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string word("pizzazz"); <span class="ent">➊</span>&#13;
  SECTION("locates substrings from strings") {&#13;
    REQUIRE(word.find("zz"s) == 2); // pi(z)zazz <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("accepts a position argument") {&#13;
    REQUIRE(word.find("zz"s, 3) == 5); // pizza(z)z <span class="ent">➌</span>&#13;
  }&#13;
<span epub:type="pagebreak" id="page_495"/>  SECTION("locates substrings from char*") {&#13;
    REQUIRE(word.find("zaz") == 3); // piz(z)azz <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("returns npos when not found") {&#13;
    REQUIRE(word.find('x') == std::string::npos); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex13"/><em>Listing 15-13: Finding substrings within a <span class="literal">string</span></em></p>&#13;
<p class="indent">Here, you construct the <span class="literal">string</span> called <span class="literal">word</span> containing <span class="literal">pizzazz</span> <span class="ent">➊</span>. In the first test, you invoke <span class="literal">find</span> with a <span class="literal">string</span> containing <span class="literal">zz</span>, which returns <span class="literal">2</span> <span class="ent">➋</span>, the index of the first <em>z</em> in <span class="literal">pi</span><span class="literal">z</span><span class="literal">zazz</span>. When you provide a position argument of <span class="literal">3</span> corresponding to the second <em>z</em> in <span class="literal">piz</span><span class="literal">z</span><span class="literal">azz, find</span> locates the second <em>zz</em> beginning at <span class="literal">5</span> <span class="ent">➌</span>. In the third test, you use the C-style string <span class="literal">zaz</span>, and <span class="literal">find</span> returns 3, again corresponding to the second <em>z</em> in <span class="literal">piz</span><span class="literal">z</span><span class="literal">azz</span> <span class="ent">➍</span>. Finally, you attempt to find the character <em>x</em>, which doesn’t appear in <span class="literal">pizzazz</span>, so <span class="literal">find</span> returns <span class="literal">std::string::npos</span> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec6"><strong>rfind</strong></h5>&#13;
<p class="noindent">The <span class="literal">rfind</span> method is an alternative to <span class="literal">find</span> that takes the same arguments but searches <em>in reverse</em>. You might want to use this functionality if, for example, you were looking for particular punctuation at the end of a <span class="literal">string</span>, as <a href="ch15.xhtml#ch15ex14">Listing 15-14</a> illustrates.</p>&#13;
<pre>TEST_CASE("std::string rfind") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string word("pizzazz"); <span class="ent">➊</span>&#13;
  SECTION("locates substrings from strings") {&#13;
    REQUIRE(word.rfind("zz"s) == 5); // pizza(z)z <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("accepts a position argument") {&#13;
    REQUIRE(word.rfind("zz"s, 3) == 2); // pi(z)zazz <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("locates substrings from char*") {&#13;
    REQUIRE(word.rfind("zaz") == 3); // piz(z)azz <span class="ent">➍</span>&#13;
  }&#13;
  SECTION("returns npos when not found") {&#13;
    REQUIRE(word.rfind('x') == std::string::npos); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex14"/><em>Listing 15-14: Finding substrings in reverse within a <span class="literal">string</span></em></p>&#13;
<p class="indent">Using the same <span class="literal">word</span> <span class="ent">➊</span>, you use the same arguments as in <a href="ch15.xhtml#ch15ex13">Listing 15-13</a> to test <span class="literal">rfind</span>. Given <span class="literal">zz, rfind</span> returns <span class="literal">5</span>, the second to last <em>z</em> in <span class="literal">pizza</span><span class="literal">z</span><span class="literal">z</span> <span class="ent">➋</span>. When you provide the positional argument <span class="literal">3, rfind</span> instead returns the first <em>z</em> in <span class="literal">pi</span><span class="literal">z</span><span class="literal">zazz</span> <span class="ent">➌</span>. Because there’s only one occurrence of the substring <span class="literal">zaz, rfind</span> returns the same position as <span class="literal">find</span> <span class="ent">➍</span>. Also like <span class="literal">find, rfind</span> returns <span class="literal">std::string::npos</span> when given <span class="literal">x</span> <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec7"><strong>find_*_of</strong></h5>&#13;
<p class="noindent">Whereas <span class="literal">find</span> and <span class="literal">rfind</span> locate exact subsequences in a <span class="literal">string</span>, a family of related functions finds the first character contained in a given argument.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_496"/>The <span class="literal">find_first_of</span> function accepts a <span class="literal">string</span> and locates the first character in this contained in the argument. Optionally, you can provide a <span class="literal">size_t</span> position argument to indicate to <span class="literal">find_first_of</span> where to start in the string. If <span class="literal">find_first_of</span> cannot find a matching character, it will return <span class="literal">std::string::npos</span>. <a href="ch15.xhtml#ch15ex15">Listing 15-15</a> illustrates the <span class="literal">find_first_of</span> function.</p>&#13;
<pre>TEST_CASE("std::string find_first_of") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string sentence("I am a Zizzer-Zazzer-Zuzz as you can plainly see."); <span class="ent">➊</span>&#13;
  SECTION("locates characters within another string") {&#13;
    REQUIRE(sentence.find_first_of("Zz"s) == 7); // (Z)izzer <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("accepts a position argument") {&#13;
    REQUIRE(sentence.find_first_of("Zz"s, 11) == 14); // (Z)azzer <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("returns npos when not found") {&#13;
    REQUIRE(sentence.find_first_of("Xx"s) == std::string::npos); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex15"/><em>Listing 15-15: Finding the first element from a set within a <span class="literal">string</span></em></p>&#13;
<p class="indent">The <span class="literal">string</span> called <span class="literal">sentence</span> contains <span class="literal">I am a Zizzer-Zazzer-Zuzz as you</span> <span class="literal">can plainly see.</span> <span class="ent">➊</span>. Here, you invoke <span class="literal">find_first_of</span> with the string <span class="literal">Zz</span>, which matches both lowercase and uppercase <em>z</em>. This returns <span class="literal">7</span>, which corresponds to the first <span class="literal">Z</span> in <span class="literal">sentence, Z</span><span class="literal">izzer</span> <span class="ent">➋</span>. In the second test, you again provide the string <span class="literal">Zz</span> but also pass the position argument <span class="literal">11</span>, which corresponds to the <span class="literal">e</span> in <span class="literal">Zizz</span><span class="literal">e</span><span class="literal">r</span>. This results in <span class="literal">14</span>, which corresponds to the <span class="literal">Z</span> in <span class="literal">Z</span><span class="literal">azzer</span> <span class="ent">➌</span>. Finally, you invoke <span class="literal">find_first_of</span> with <span class="literal">Xx</span>, which results in <span class="literal">std::string::npos</span> because <span class="literal">sentence</span> doesn’t contain an <span class="literal">x</span> (or an <span class="literal">X</span>) <span class="ent">➍</span>.</p>&#13;
<p class="indent">A <span class="literal">string</span> offers three <span class="literal">find_first_of</span> variations:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">find_first_not_of</span> returns the first character <em>not</em> contained in the <span class="literal">string</span> argument. Rather than providing a <span class="literal">string</span> containing the elements you want to find, you provide a <span class="literal">string</span> of characters you <em>don’t</em> want to find.</li>&#13;
<li class="noindent"><span class="literal">find_last_of</span> performs matching in reverse; rather than searching from the beginning of the <span class="literal">string</span> or from the position argument and proceeding to the end, <span class="literal">find_last_of</span> begins at the end of the <span class="literal">string</span> or from the position argument and proceeds to the beginning.</li>&#13;
<li class="noindent"><span class="literal">find_last_not_of</span> combines the two prior variations: you pass a <span class="literal">string</span> containing elements you don’t want to find, and <span class="literal">find_last_not_of</span> searches in reverse.</li>&#13;
</ul>&#13;
<p class="indent">Your choice of <span class="literal">find</span> function boils down to what your algorithmic requirements are. Do you need to search from the back of a <span class="literal">string</span>, say for a punctuation mark? If so, use <span class="literal">find_last_of</span>. Are you looking for the first space in a <span class="literal">string</span>? If so, use <span class="literal">find_first_of</span>. Do you want to invert your search and look for the first element that is not a member of some set? Then use the alternatives <span class="literal">find_first_not_of</span> and <span class="literal">find_last_not_of</span>, depending on whether you want to start from the beginning or end of the <span class="literal">string</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_497"/><a href="ch15.xhtml#ch15ex16">Listing 15-16</a> illustrates these three <span class="literal">find_first_of</span> variations.</p>&#13;
<pre>TEST_CASE("std::string") {&#13;
  using namespace std::literals::string_literals;&#13;
  std::string sentence("I am a Zizzer-Zazzer-Zuzz as you can plainly see."); <span class="ent">➊</span>&#13;
  SECTION("find_last_of finds last element within another string") {&#13;
    REQUIRE(sentence.find_last_of("Zz"s) == 24); // Zuz(z) <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("find_first_not_of finds first element not within another string") {&#13;
    REQUIRE(sentence.find_first_not_of(" -IZaeimrz"s) == 22); // Z(u)zz <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("find_last_not_of finds last element not within another string") {&#13;
    REQUIRE(sentence.find_last_not_of(" .es"s) == 43); // plainl(y) <span class="ent">➍</span>&#13;
     }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex16"/><em>Listing 15-16: Alternatives to the <span class="literal">find_first_of</span> method of <span class="literal">string</span></em></p>&#13;
<p class="indent">Here, you initialize the same <span class="literal">sentence</span> as in <a href="ch15.xhtml#ch15ex15">Listing 15-15</a> <span class="ent">➊</span>. In the first test, you use <span class="literal">find_last_of</span> on <span class="literal">Zz</span>, which searches in reverse for any <em>z</em> or <em>Z</em> and returns <span class="literal">24</span>, the last <em>z</em> in the sentence <span class="literal">Zuz</span><span class="literal">z</span> <span class="ent">➋</span>. Next, you use <span class="literal">find_first_not_of</span> and pass a farrago of characters (not including the letter <em>u</em>), which results in <span class="literal">22</span>, the position of the first <em>u</em> in <span class="literal">Z</span><span class="literal">u</span><span class="literal">zz</span> <span class="ent">➌</span>. Finally, you use <span class="literal">find_last_not_of</span> to find the last character not equal to space, period, <em>e</em>, or <em>s</em>. This results in <span class="literal">43</span>, the position of <em>y</em> in <span class="literal">plainl</span><span class="literal">y</span> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec8"><strong>Summary of string Search Methods</strong></h5>&#13;
<p class="noindent"><a href="ch15.xhtml#ch15tab06">Table 15-6</a> lists many of the search methods for <span class="literal">string</span>. Note that <span class="literal">s2</span> is a string; <span class="literal">cstr</span> is a C-style <span class="literal">char*</span> string; <span class="literal">c</span> is a <span class="literal">char</span>; and <span class="literal">n, l</span>, and <span class="literal">pos</span> are <span class="literal">size_t</span> in the table.</p>&#13;
<p class="tabcap"><a id="ch15tab06"/><strong>Table 15-6:</strong> Supported <span class="literal">std::string</span> Search Algorithms</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Searches</strong> <span class="codestrong">s</span> <strong>starting at</strong> <span class="codestrong">p</span> <strong>and returns the position of the . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find(</span><span class="codestrong">s2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First substring equal to <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find(</span><span class="codestrong">cstr</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">l</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First substring equal to the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find(</span><span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.rfind(</span><span class="codestrong">s2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last substring equal to <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to <span class="literal">npos</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.rfind(</span><span class="codestrong">cstr</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">l</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last substring equal to the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to <span class="literal">npos</span>; <span class="literal">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.rfind(</span><span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to <span class="literal">npos</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_first_of(</span><span class="codestrong">s2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_first_of(</span><span class="codestrong">cstr</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">l</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First character contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="literal">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_first_of(</span><span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_last_of(</span><span class="codestrong">s2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_last_of(</span><span class="codestrong">cstr</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">l</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last character contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_last_of(</span><span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_first_not_of(</span><span class="codestrong">s2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First character not contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_first_not_of(</span><span class="codestrong">cstr</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">l</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First character not contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_first_not_of(</span><span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_498"/>First character not equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_last_not_of(</span><span class="codestrong">s2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Last character not contained in <span class="codestrong">s2</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_last_not_of(</span><span class="codestrong">cstr</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">l</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last character not contained in the first <span class="codestrong">l</span> characters of <span class="codestrong">cstr</span>; <span class="codestrong">p</span> defaults to 0; <span class="codestrong">l</span> defaults to <span class="codestrong">cstr</span>’s length per null termination.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="codestrong">s</span><span class="literal">.find_last_not_of(</span><span class="codestrong">c</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Last character not equal to <span class="codestrong">c</span>; <span class="codestrong">p</span> defaults to 0.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec7"><strong><em>Numeric Conversions</em></strong></h4>&#13;
<p class="noindent">The STL provides functions for converting between <span class="literal">string</span> or <span class="literal">wstring</span> and the fundamental numeric types. Given a numeric type, you can use the <span class="literal">std::to_string</span> and <span class="literal">std::to_wstring</span> functions to generate its <span class="literal">string</span> or <span class="literal">wstring</span> representation. Both functions have overloads for all the numeric types. <a href="ch15.xhtml#ch15ex17">Listing 15-17</a> illustrates <span class="literal">string</span> and <span class="literal">wstring</span>.</p>&#13;
<pre>TEST_CASE("STL string conversion function") {&#13;
  using namespace std::literals::string_literals;&#13;
  SECTION("to_string") {&#13;
    REQUIRE("8675309"s == std::to_string(8675309)); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("to_wstring") {&#13;
    REQUIRE(L"109951.1627776"s == std::to_wstring(109951.1627776)); <span class="ent">➋</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex17"/><em>Listing 15-17: Numeric conversion functions of <span class="literal">string</span></em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Thanks to the inherent inaccuracy of the double type, the second unit test</em> <span class="ent">➋</span> <em>might fail on your system.</em></p>&#13;
</div>&#13;
<p class="indent">The first example uses <span class="literal">to_string</span> to convert the <span class="literal">int 8675309</span> into a <span class="literal">string</span> <span class="ent">➊</span>; the second example uses <span class="literal">to_wstring</span> to convert the <span class="literal">double 109951.1627776</span> into a <span class="literal">wstring</span> <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_499"/>You can also convert the other way, going from a <span class="literal">string</span> or <span class="literal">wstring</span> to a numeric type. Each numeric conversion function accepts a <span class="literal">string</span> or <span class="literal">wstring</span> containing a string-encoded number as its first argument. Next, you can provide an optional pointer to a <span class="literal">size_t</span>. If provided, the conversion function will write the index of the last character it was able to convert (or the length of the input <span class="literal">string</span> if it decoded all characters). By default, this index argument is <span class="literal">nullptr</span>, in which case the conversion function doesn’t write the index. When the target type is integral, you can provide a third argument: an <span class="literal">int</span> corresponding to the base of the encoded <span class="literal">string</span>. This base argument is optional and defaults to 10.</p>&#13;
<p class="indent">Each conversion function throws <span class="literal">std::invalid_argument</span> if no conversion could be performed and throws <span class="literal">std::out_of_range</span> if the converted value is out of range for the corresponding type.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab07">Table 15-7</a> lists each of these conversion functions along with its target type. In this table, <span class="literal">s</span> is a string. If <span class="literal">p</span> is not <span class="literal">nullptr</span>, the conversion function will write the position of the first unconverted character in <span class="literal">s</span> to the memory pointed to by <span class="literal">p</span>. If all characters are encoded, returns the length of <span class="literal">s</span>. Here, <span class="literal">b</span> is the number’s base representation in <span class="literal">s</span>. Note that <span class="literal">p</span> defaults to <span class="literal">nullptr</span>, and <span class="literal">b</span> defaults to 10.</p>&#13;
<p class="tabcap"><a id="ch15tab07"/><strong>Table 15-7:</strong> Supported Numeric Conversion Functions for <span class="literal">std::string</span> and <span class="literal">std::wstring</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Converts</strong> <span class="literal">s</span> to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stoi(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">b</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An <span class="literal">int</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">stol(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">b</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <span class="literal">long</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stoll(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">b</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <span class="literal">long long</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">stoul(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">b</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An <span class="literal">unsigned long</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stoull(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">], [</span><span class="codestrong">b</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An <span class="literal">unsigned long long</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">stof(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <span class="literal">float</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">stod(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <span class="literal">double</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">stold(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <span class="literal">long double</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">to_string(</span><span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <span class="literal">string</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">to_wstring(</span><span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">A <span class="literal">wstring</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex18">Listing 15-18</a> illustrates several numeric conversion functions.</p>&#13;
<pre>TEST_CASE("STL string conversion function") {&#13;
  using namespace std::literals::string_literals;&#13;
  SECTION("stoi") {&#13;
    REQUIRE(std::stoi("8675309"s) == 8675309); <span class="ent">➊</span>&#13;
  }&#13;
  SECTION("stoi") {&#13;
    REQUIRE_THROWS_AS(std::stoi("1099511627776"s), std::out_of_range); <span class="ent">➋</span>&#13;
  }&#13;
<span epub:type="pagebreak" id="page_500"/>  SECTION("stoul with all valid characters") {&#13;
    size_t last_character{};&#13;
    const auto result = std::stoul("0xD3C34C3D"s, &amp;last_character, 16); <span class="ent">➌</span>&#13;
    REQUIRE(result == 0xD3C34C3D);&#13;
    REQUIRE(last_character == 10);&#13;
  }&#13;
  SECTION("stoul") {&#13;
    size_t last_character{};&#13;
    const auto result = std::stoul("42six"s, &amp;last_character); <span class="ent">➍</span>&#13;
    REQUIRE(result == 42);&#13;
    REQUIRE(last_character == 2);&#13;
  }&#13;
  SECTION("stod") {&#13;
    REQUIRE(std::stod("2.7182818"s) == Approx(2.7182818)); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex18"/><em>Listing 15-18: String conversion functions of <span class="literal">string</span></em></p>&#13;
<p class="indent">First, you use <span class="literal">stoi</span> to convert <span class="literal">8675309</span> to an integer <span class="ent">➊</span>. In the second test, you attempt to use <span class="literal">stoi</span> to convert the <span class="literal">string 1099511627776</span> into an integer. Because this value is too large for an <span class="literal">int, stoi</span> throws <span class="literal">std::out_of_range</span> <span class="ent">➋</span>. Next, you convert <span class="literal">0xD3C34C3D</span> with <span class="literal">stoi</span>, but you provide the two optional arguments: a pointer to a <span class="literal">size_t</span> called <span class="literal">last_character</span> and a hexadecimal base <span class="ent">➌</span>. The <span class="literal">last_character</span> object is <span class="literal">10</span>, the length of <span class="literal">0xD3C34C3D</span>, because <span class="literal">stoi</span> can parse every character. The <span class="literal">string</span> in the next test, <span class="literal">42six</span>, contains the unparsable characters <span class="literal">six</span>. When you invoke <span class="literal">stoul</span> this time, the <span class="literal">result</span> is <span class="literal">42</span> and <span class="literal">last_character</span> equals <span class="literal">2</span>, the position of <span class="literal">s</span> in <span class="literal">six</span> <span class="ent">➍</span>. Finally, you use <span class="literal">stod</span> to convert the <span class="literal">string 2.7182818</span> to a <span class="literal">double</span> <span class="ent">➎</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost’s Lexical Cast provides an alternative, template-based approach to numeric conversions. Refer to the documentation for <span class="literal">boost::lexical_cast</span> available in the <span class="literal">&lt;boost/lexical_cast.hpp&gt;</span> header.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch15lev1sec2"><strong>String View</strong></h3>&#13;
<p class="noindent">A <em>string view</em> is an object that represents a constant, contiguous sequence of characters. It’s very similar to a <span class="literal">const string</span> reference. In fact, string view classes are often implemented as a pointer to a character sequence and a length.</p>&#13;
<p class="indent">The STL offers the class template <span class="literal">std::basic_string_view</span> in the <span class="literal">&lt;string_view&gt;</span> header, which is analogous to <span class="literal">std::basic_string</span>. The template <span class="literal">std::basic_string_view</span> has a specialization for each of the four commonly used character types:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">char</span> has <span class="literal">string_view</span></li>&#13;
<li class="noindent"><span class="literal">wchar_t</span> has <span class="literal">wstring_view</span></li>&#13;
<li class="noindent"><span class="literal">char16_t</span> has <span class="literal">u16string_view</span></li>&#13;
<li class="noindent"><span class="literal">char32_t</span> has <span class="literal">u32string_view</span></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_501"/>This section discusses the <span class="literal">string_view</span> specialization for demonstration purposes, but the discussion generalizes to the other three specializations.</p>&#13;
<p class="indent">The <span class="literal">string_view</span> class supports most of the same methods as <span class="literal">string</span>; in fact, it’s designed to be a drop-in replacement for a <span class="literal">const string&amp;</span>.</p>&#13;
<h4 class="h4" id="ch15lev2sec8"><strong><em>Constructing</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">string_view</span> class supports default construction, so it has zero length and points to <span class="literal">nullptr</span>. Importantly, <span class="literal">string_view</span> supports implicit construction from a <span class="literal">const string&amp;</span> or a C-style string. You can construct <span class="literal">string_view</span> from a <span class="literal">char*</span> and a <span class="literal">size_t</span>, so you can manually specify the desired length in case you want a substring or you have embedded nulls. <a href="ch15.xhtml#ch15ex19">Listing 15-19</a> illustrates the use of <span class="literal">string_view</span>.</p>&#13;
<pre>TEST_CASE("std::string_view supports") {&#13;
  SECTION("default construction") {&#13;
    std::string_view view; <span class="ent">➊</span>&#13;
    REQUIRE(view.data() == nullptr);&#13;
    REQUIRE(view.size() == 0);&#13;
    REQUIRE(view.empty());&#13;
  }&#13;
  SECTION("construction from string") {&#13;
    std::string word("sacrosanct");&#13;
    std::string_view view(word); <span class="ent">➋</span>&#13;
    REQUIRE(view == "sacrosanct");&#13;
  }&#13;
  SECTION("construction from C-string") {&#13;
    auto word = "viewership";&#13;
    std::string_view view(word); <span class="ent">➌</span>&#13;
    REQUIRE(view == "viewership");&#13;
  }&#13;
  SECTION("construction from C-string and length") {&#13;
    auto word = "viewership";&#13;
    std::string_view view(word, 4); <span class="ent">➍</span>&#13;
    REQUIRE(view == "view");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex19"/><em>Listing 15-19: The constructors of <span class="literal">string_view</span></em></p>&#13;
<p class="indent">The default-constructed <span class="literal">string_view</span> points to <span class="literal">nullptr</span> and is empty <span class="ent">➊</span>. When you construct a <span class="literal">string_view</span> from a <span class="literal">string</span> <span class="ent">➋</span> or a C-style string <span class="ent">➌</span>, it points to the original’s contents. The final test provides the optional length argument <span class="literal">4</span>, which means the <span class="literal">string_view</span> refers to only the first four characters instead <span class="ent">➍</span>.</p>&#13;
<p class="indent">Although <span class="literal">string_view</span> also supports copy construction and assignment, it doesn’t support move construction or assignment. This design makes sense when you consider that <span class="literal">string_view</span> doesn’t own the sequence to which it points.</p>&#13;
<h4 class="h4" id="ch15lev2sec9"><strong><em><span epub:type="pagebreak" id="page_502"/>Supported string_view Operations</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">string_view</span> class supports many of the same operations as a <span class="literal">const</span> <span class="literal">string&amp;</span> with identical semantics. The following lists all the shared methods between <span class="literal">string</span> and <span class="literal">string_view</span>:</p>&#13;
<p class="bq"><strong>Iterators</strong> <span class="literal">begin, end</span>, <span class="literal">rbegin, rend</span>, <span class="literal">cbegin, cend</span>, <span class="literal">crbegin</span>, <span class="literal">crend</span></p>&#13;
<p class="bq"><strong>Element Access</strong> <span class="literal">operator[], at</span>, <span class="literal">front, back</span>, <span class="literal">data</span></p>&#13;
<p class="bq"><strong>Capacity</strong> <span class="literal">size, length</span>, <span class="literal">max_size</span>, <span class="literal">empty</span></p>&#13;
<p class="bq"><strong>Search</strong> <span class="literal">find, rfind</span>, <span class="literal">find_first_of, find_last_of</span>, <span class="literal">find_first_not_of</span>, <span class="literal">find_last_not_of</span></p>&#13;
<p class="bq"><strong>Extraction</strong> <span class="literal">copy</span>, <span class="literal">substr</span></p>&#13;
<p class="bq"><strong>Comparison</strong> <span class="literal">compare, operator==, operator!= </span>, <span class="literal">operator&lt;</span>, <span class="literal">operator&gt;</span>, <span class="literal">operator&lt;=</span>, <span class="literal">operator&gt;=</span></p>&#13;
<p class="indent">In addition to these shared methods, <span class="literal">string_view</span> supports the <span class="literal">remove_prefix</span> method, which removes the given number of characters from the beginning of the <span class="literal">string_view</span>, and the <span class="literal">remove_suffix</span> method, which instead removes characters from the end. <a href="ch15.xhtml#ch15ex20">Listing 15-20</a> illustrates both methods.</p>&#13;
<pre>TEST_CASE("std::string_view is modifiable with") {&#13;
  std::string_view view("previewing"); <span class="ent">➊</span>&#13;
  SECTION("remove_prefix") {&#13;
    view.remove_prefix(3); <span class="ent">➋</span>&#13;
    REQUIRE(view == "viewing");&#13;
  }&#13;
  SECTION("remove_suffix") {&#13;
    view.remove_suffix(3); <span class="ent">➌</span>&#13;
    REQUIRE(view == "preview");&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex20"/><em>Listing 15-20: Modifying a <span class="literal">string_view</span> with <span class="literal">remove_prefix</span> and <span class="literal">remove_suffix</span></em></p>&#13;
<p class="indent">Here, you declare a <span class="literal">string_view</span> referring to the string literal <span class="literal">previewing</span> <span class="ent">➊</span>. The first test invokes <span class="literal">remove_prefix</span> with <span class="literal">3</span> <span class="ent">➋</span>, which removes three characters from the front of <span class="literal">string_view</span> so it now refers to <span class="literal">viewing</span>. The second test instead invokes <span class="literal">remove_suffix</span> with <span class="literal">3</span> <span class="ent">➌</span>, which removes three characters from the back of the <span class="literal">string_view</span> and results in <span class="literal">preview</span>.</p>&#13;
<h4 class="h4" id="ch15lev2sec10"><strong><em>Ownership, Usage, and Efficiency</em></strong></h4>&#13;
<p class="noindent">Because <span class="literal">string_view</span> doesn’t own the sequence to which it refers, it’s up to you to ensure that the lifetime of the <span class="literal">string_view</span> is a subset of the referred-to sequence’s lifetime.</p>&#13;
<p class="indent">Perhaps the most common usage of <span class="literal">string_view</span> is as a function parameter. When you need to interact with an immutable sequence of characters, it’s the first port of call. Consider the <span class="literal">count_vees</span> function in <a href="ch15.xhtml#ch15ex21">Listing 15-21</a>, which counts the frequency of the letter <span class="literal">v</span> in a sequence of characters.</p>&#13;
<pre><span epub:type="pagebreak" id="page_503"/>#include &lt;string_view&gt;&#13;
&#13;
size_t count_vees(std::string_view my_view<span class="ent">➊</span>) {&#13;
  size_t result{};&#13;
  for(auto letter : my_view) <span class="ent">➋</span>&#13;
    if (letter == 'v') result++; <span class="ent">➌</span>&#13;
  return result; <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex21"/><em>Listing 15-21: The <span class="literal">count_vees</span> function</em></p>&#13;
<p class="indent">The <span class="literal">count_vees</span> function takes a <span class="literal">string_view</span> called <span class="literal">my_view</span> <span class="ent">➊</span>, which you iterate over using a range-based <span class="literal">for</span> loop <span class="ent">➋</span>. Each time a character in <span class="literal">my_view</span> equals <span class="literal">v</span>, you increment a <span class="literal">result</span> variable <span class="ent">➌</span>, which you return after exhausting the sequence <span class="ent">➍</span>.</p>&#13;
<p class="indent">You could reimplement <a href="ch15.xhtml#ch15ex21">Listing 15-21</a> by simply replacing <span class="literal">string_view</span> with <span class="literal">const string&amp;</span>, as demonstrated in <a href="ch15.xhtml#ch15ex22">Listing 15-22</a>.</p>&#13;
<pre>#include &lt;string&gt;&#13;
&#13;
size_t count_vees(const std::string&amp; my_view) {&#13;
<span class="codeitalic1">--snip--</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex22"/><em>Listing 15-22: The <span class="literal">count_vees</span> function reimplemented to use a <span class="literal">const string&amp;</span> instead of a <span class="literal">string_view</span></em></p>&#13;
<p class="indent">If <span class="literal">string_view</span> is just a drop-in replacement for a <span class="literal">const string&amp;</span>, why bother having it? Well, if you invoke <span class="literal">count_vees</span> with a <span class="literal">std::string</span>, there’s no difference: modern compilers will emit the same code.</p>&#13;
<p class="indent">If you instead invoke <span class="literal">count_vees</span> with a string literal, there’s a big difference: when you pass a string literal for a <span class="literal">const string&amp;</span>, you construct a <span class="literal">string</span>. When you pass a string literal for a <span class="literal">string_view</span>, you construct a <span class="literal">string_view</span>. Constructing a <span class="literal">string</span> is probably more expensive, because it might have to allocate dynamic memory and it definitely has to copy characters. A <span class="literal">string_view</span> is just a pointer and a length (no copying or allocating is required).</p>&#13;
<h3 class="h3" id="ch15lev1sec3"><strong>Regular Expressions</strong></h3>&#13;
<p class="noindent">A <em>regular expression</em>, also called a <em>regex</em>, is a string that defines a search pattern. Regexes have a long history in computer science and form a sort of mini-language for searching, replacing, and extracting language data. The STL offers regular expression support in the <span class="literal">&lt;regex&gt;</span> header.</p>&#13;
<p class="indent">When used judiciously, regular expressions can be tremendously powerful, declarative, and concise; however, it’s also easy to write regexes that are totally inscrutable. Use regexes deliberately.</p>&#13;
<h4 class="h4" id="ch15lev2sec11"><strong><em><span epub:type="pagebreak" id="page_504"/>Patterns</em></strong></h4>&#13;
<p class="noindent">You build regular expressions using strings called <em>patterns</em>. Patterns represent a desired set of strings using a particular regular expression grammar that sets the syntax for building patterns. In other words, a pattern defines the subset of all possible strings that you’re interested in. The STL supports a handful of grammars, but the focus here will be on the very basics of the default grammar, the modified ECMAScript regular expression grammar (see [re.grammar] for details).</p>&#13;
<h5 class="h5" id="ch15lev3sec9"><strong>Character Classes</strong></h5>&#13;
<p class="noindent">In the ECMAScript grammar, you intermix literal characters with special markup to describe your desired strings. Perhaps the most common markup is a <em>character class</em>, which stands in for a set of possible characters: <span class="literal">\d</span> matches any digit, <span class="literal">\s</span> matches any whitespace, and <span class="literal">\w</span> matches any alphanumeric (“word”) character.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab08">Table 15-8</a> lists a few example regular expressions and possible interpretations.</p>&#13;
<p class="tabcap"><a id="ch15tab08"/><strong>Table 15-8:</strong> Regular Expression Patterns Using Only Character Classes and Literals</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Regex pattern</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Possibly describes</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">\d\d\d-\d\d\d-\d\d\d\d</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An American phone number, such as 202-456-1414</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">\d\d:\d\d \wM</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A time in HH:MM AM/PM format, such as 08:49 <small>PM</small></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">\w\w\d\d\d\d\d\d</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An American ZIP code including a prepended state code, such as NJ07932</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">\w\d-\w\d</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An astromech droid identifier, such as R2-D2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">c\wt</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">A three-letter word starting with <em>c</em> and ending with <em>t</em>, such as <em>cat</em> or <em>cot</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can also invert a character class by capitalizing the <em>d</em>, <em>s</em>, or <em>w</em> to give the opposite: <span class="literal">\D</span> matches any non-digit, <span class="literal">\S</span> matches any non-whitespace, and <span class="literal">\W</span> matches any non-word character.</p>&#13;
<p class="indent">In addition, you can build your own character classes by explicitly enumerating them between square brackets <span class="literal">[]</span>. For example, the character class <span class="literal">[02468]</span> includes even digits. You can also use hyphens as shortcuts to include implied ranges, so the character class <span class="literal">[0-9a-fA-F]</span> includes any hexadecimal digit whether the letter is capitalized or not. Finally, you can invert a custom character class by prepending the list with a caret <span class="literal">^</span>. For example, the character class <span class="literal">[^aeiou]</span> includes all non-vowel characters.</p>&#13;
<h5 class="h5" id="ch15lev3sec10"><strong>Quantifiers</strong></h5>&#13;
<p class="noindent">You can save some typing by using <em>quantifiers</em>, which specify that the character directly to the left should be repeated some number of times. <a href="ch15.xhtml#ch15tab09">Table 15-9</a> lists the regex quantifiers.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_505"/><a id="ch15tab09"/><strong>Table 15-9:</strong> Regular Expression Quantifiers</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Regex quantifier</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specifies a quantity of</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">*</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0 or more</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">+</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">1 or more</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">?</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">0 or 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">{n}</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Exactly n</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">{n,m}</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Between n and m, inclusive</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">{n,}</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">At least n</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Using quantifiers, you can specify all words beginning with <em>c</em> and ending with <em>t</em> using the pattern <span class="literal">c\w*t</span>, because <span class="literal">\w*</span> matches any number of word characters.</p>&#13;
<h5 class="h5" id="ch15lev3sec11"><strong>Groups</strong></h5>&#13;
<p class="noindent">A <em>group</em> is a collection of characters. You can specify a group by placing it within parentheses. Groups are useful in several ways, including specifying a particular collection for eventual extraction and for quantification.</p>&#13;
<p class="indent">For example, you could improve the ZIP pattern in <a href="ch15.xhtml#ch15tab08">Table 15-8</a> to use quantifiers and groups, like this:</p>&#13;
<pre>(\w{2})?<span class="ent">➊</span>(\d{5})<span class="ent">➋</span>(-\d{4})?<span class="ent">➌</span></pre>&#13;
<p class="indent">Now you have three groups: the optional state <span class="ent">➊</span>, the ZIP code <span class="ent">➋</span>, and an optional four-digit suffix <span class="ent">➌</span>. As you’ll see later on, these groups make parsing from regexes much easier.</p>&#13;
<h5 class="h5" id="ch15lev3sec12"><strong>Other Special Characters</strong></h5>&#13;
<p class="noindent"><a href="ch15.xhtml#ch15tab10">Table 15-10</a> lists several other special characters available for use in regex patterns.</p>&#13;
<p class="tabcap"><a id="ch15tab10"/><strong>Table 15-10:</strong> Example Special Characters</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specifies</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">X|Y</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Character X or Y</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">\Y</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The special character Y as a literal (in other words, escape it)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">\n</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Newline</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">\r</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Carriage return</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">\t</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Tab</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">\0</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Null</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">\xYY</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">The hexadecimal character corresponding to YY</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec12"><strong><em><span epub:type="pagebreak" id="page_506"/>basic_regex</em></strong></h4>&#13;
<p class="noindent">The STL’s <span class="literal">std::basic_regex</span> class template in the <span class="literal">&lt;regex&gt;</span> header represents a regular expression constructed from a pattern. The <span class="literal">basic_regex</span> class accepts two template parameters, a character type and an optional traits class. You’ll almost always want to use one of the convenience specializations: <span class="literal">std::regex</span> for <span class="literal">std::basic_regex&lt;char&gt;</span> or <span class="literal">std::wregex</span> for <span class="literal">std::basic_regex&lt;wchar_t&gt;</span>.</p>&#13;
<p class="indent">The primary means of constructing a <span class="literal">regex</span> is by passing a string literal containing your regex pattern. Because patterns will require a lot of escaped characters—especially the backslash <span class="literal">\</span>—it’s a good idea to use raw string literals, such as <span class="literal">R"()"</span>. The constructor accepts a second, optional parameter for specifying syntax flags like the regex grammar.</p>&#13;
<p class="indent">Although <span class="literal">regex</span> is used primarily as input into regular expression algorithms, it does offer a few methods that users can interact with. It supports the usual copy and move construction and assignment suite and <span class="literal">swap</span>, plus the following:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">assign(</span><span class="literal">s</span><span class="literal">)</span> reassigns the pattern to <span class="literal">s</span></li>&#13;
<li class="noindent"><span class="literal">mark_count()</span> returns the number of groups in the pattern</li>&#13;
<li class="noindent"><span class="literal">flags()</span> returns the syntax flags issued at construction</li>&#13;
</ul>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex23">Listing 15-23</a> illustrates how you could construct a ZIP code <span class="literal">regex</span> and inspect its subgroups.</p>&#13;
<pre>#include &lt;regex&gt;&#13;
&#13;
TEST_CASE("std::basic_regex constructs from a string literal") {&#13;
  std::regex zip_regex{ R"((\w{2})?(\d{5})(-\d{4})?)" }; <span class="ent">➊</span>&#13;
  REQUIRE(zip_regex.mark_count() == 3); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex23"/><em>Listing 15-23: Constructing a <span class="literal">regex</span> using a raw string literal and extracting its group count</em></p>&#13;
<p class="indent">Here, you construct a <span class="literal">regex</span> called <span class="literal">zip_regex</span> using the pattern <span class="literal">(\w{2})?(\d{5})(-\d{4})?</span> <span class="ent">➊</span>. Using the <span class="literal">mark_count</span> method, you see that <span class="literal">zip_regex</span> contains three groups <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch15lev2sec13"><strong><em>Algorithms</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">&lt;regex&gt;</span> class contains three algorithms for applying <span class="literal">std::basic_regex</span> to a target string: matching, searching, or replacing. Which you choose depends on the task at hand.</p>&#13;
<h5 class="h5" id="ch15lev3sec13"><strong>Matching</strong></h5>&#13;
<p class="noindent"><em>Matching</em> attempts to marry a regular expression to an <em>entire</em> <span class="literal">string</span>. The STL provides the <span class="literal">std::regex_match</span> function for matching, which has four overloads.</p>&#13;
<p class="indent">First, you can provide <span class="literal">regex_match</span> a <span class="literal">string</span>, a C-string, or a begin and end iterator forming a half-open range. The next parameter is an optional <span epub:type="pagebreak" id="page_507"/>reference to a <span class="literal">std::match_results</span> object that receives details about the match. The next parameter is a <span class="literal">std::basic_regex</span> that defines the matching, and the final parameter is an optional <span class="literal">std::regex_constants::match_flag_type</span> that specifies additional matching options for advanced use cases. The <span class="literal">regex_match</span> function returns a <span class="literal">bool</span>, which is <span class="literal">true</span> if it found a match; otherwise, it’s <span class="literal">false</span>.</p>&#13;
<p class="indent">To summarize, you can invoke <span class="literal">regex_match</span> in the following ways:</p>&#13;
<pre>regex_match(beg, end, [mr], rgx, [flg])&#13;
regex_match(str, [mr], rgx, [flg])</pre>&#13;
<p class="indent">Either provide a half-open range from <span class="literal">beg</span> to <span class="literal">end</span> or a <span class="literal">string</span>/C-string <span class="literal">str</span> to search. Optionally, you can provide a <span class="literal">match_results</span> called <span class="literal">mr</span> to store all the details of any matches found. You obviously have to provide a regex <span class="literal">rgx</span>. Finally, the flags <span class="literal">flg</span> are seldom used.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For details on match flags <span class="literal">flg</span>, refer to [re.alg.match].</em></p>&#13;
</div>&#13;
<p class="indent">A <em>submatch</em> is a subsequence of the matched string that corresponds to a group. The ZIP code–matching regular expression <span class="literal">(\w{2})(\d{5})(-\d{4})?</span> can produce two or three submatches depending on the string. For example, TX78209 contains the two submatches TX and 78209, and NJ07936-3173 contains the three submatches NJ, 07936, and -3173.</p>&#13;
<p class="indent">The <span class="literal">match_results</span> class stores zero or more <span class="literal">std::sub_match</span> instances. A <span class="literal">sub_match</span> is a simple class template that exposes a <span class="literal">length</span> method to return the length of a submatch and a <span class="literal">str</span> method to build a <span class="literal">string</span> from the <span class="literal">sub_match</span>.</p>&#13;
<p class="indent">Somewhat confusingly, if <span class="literal">regex_match</span> successfully matches a string, <span class="literal">match_results</span> stores the entire matched string as its first element and then stores any submatches as subsequent elements.</p>&#13;
<p class="indent">The <span class="literal">match_results</span> class provides the operations listed in <a href="ch15.xhtml#ch15tab11">Table 15-11</a>.</p>&#13;
<p class="tabcap"><a id="ch15tab11"/><strong>Table 15-11:</strong> Supported Operations of <span class="literal">match_results</span></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span><span class="literal">.empty()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Checks whether the match was successful.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><span class="literal">.size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the number of submatches.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span><span class="literal">.max_size()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the maximum number of submatches.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><span class="literal">.length([</span><span class="codestrong">i</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the length of the submatch <span class="literal">i</span>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span><span class="literal">.position([</span><span class="codestrong">i</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns the character of the first position of submatch <span class="literal">i</span>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><span class="literal">.str([</span><span class="codestrong">i</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns the string representing submatch <span class="literal">i</span>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">mr</span> <span class="literal">[</span><span class="codestrong">i</span><span class="literal">]</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to a <span class="literal">std::sub_match</span> class corresponding to submatch <span class="literal">i</span>, which defaults to 0.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><span class="literal">.prefix()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a reference to a <span class="literal">std::sub_match</span> class corresponding to the sequence before the match.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_508"/><span class="codestrong">mr</span><span class="literal">.suffix()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a reference to a <span class="literal">std::sub_match</span> class corresponding to the sequence after the match.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">mr</span><span class="literal">.format(</span><span class="codestrong">str</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Returns a <span class="literal">string</span> with contents according to the format string <span class="codestrong">str</span>. There are three special sequences: <span class="codestrong">$'</span> for the characters before a match, <span class="codestrong">$'</span> for the characters after the match, and <span class="codestrong">$&amp;</span> for the matched characters.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="codestrong">mr</span><span class="literal">.begin()</span></p>&#13;
<p class="taba"><span class="codestrong">mr</span><span class="literal">.end()</span></p>&#13;
<p class="taba"><span class="codestrong">mr</span><span class="literal">.cbegin()</span></p>&#13;
<p class="taba"><span class="codestrong">mr</span><span class="literal">.cend()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Returns the corresponding iterator to the sequence of submatches.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <span class="literal">std::sub_match</span> class template has predefined specializations to work with common string types:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">std::csub_match</span> for a <span class="literal">const char*</span></li>&#13;
<li class="noindent"><span class="literal">std::wcsub_match</span> for a <span class="literal">const wchar_t*</span></li>&#13;
<li class="noindent"><span class="literal">std::ssub_match</span> for a <span class="literal">std::string</span></li>&#13;
<li class="noindent"><span class="literal">std::wssub_match</span> for a <span class="literal">std::wstring</span></li>&#13;
</ul>&#13;
<p class="indent">Unfortunately, you’ll have to keep track of all these specializations manually due to the design of <span class="literal">std::regex_match</span>. This design generally befuddles newcomers, so let’s look at an example. <a href="ch15.xhtml#ch15ex24">Listing 15-24</a> uses the ZIP code regular expression <span class="literal">(\w{2})(\d{5})(-\d{4})?</span> to match against the strings <span class="literal">NJ07936-3173</span> and <span class="literal">Iomega Zip 100</span>.</p>&#13;
<pre>#include &lt;regex&gt;&#13;
#include &lt;string&gt;&#13;
&#13;
TEST_CASE("std::sub_match") {&#13;
  std::regex regex{ R"((\w{2})(\d{5})(-\d{4})?)" }; <span class="ent">➊</span>&#13;
  std::smatch results; <span class="ent">➋</span>&#13;
  SECTION("returns true given matching string") {&#13;
    std::string zip("NJ07936-3173");&#13;
    const auto matched = std::regex_match(zip, results, regex); <span class="ent">➌</span>&#13;
    REQUIRE(matched); <span class="ent">➍</span>&#13;
    REQUIRE(results[0] == "NJ07936-3173"); <span class="ent">➎</span>&#13;
    REQUIRE(results[1] == "NJ"); <span class="ent">➏</span>&#13;
    REQUIRE(results[2] == "07936");&#13;
    REQUIRE(results[3] == "-3173");&#13;
  }&#13;
  SECTION("returns false given non-matching string") {&#13;
    std::string zip("Iomega Zip 100");&#13;
    const auto matched = std::regex_match(zip, results, regex); <span class="ent">➐</span>&#13;
    REQUIRE_FALSE(matched); <span class="ent">➑</span>&#13;
    }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex24"/><em>Listing 15-24: A <span class="literal">regex_match</span> attempts to match a <span class="literal">regex</span> to a <span class="literal">string</span>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_509"/>You construct a <span class="literal">regex</span> with the raw literal <span class="literal">R"((\w{2})(\d{5})(-\d{4})?)"</span> <span class="ent">➊</span> and default construct an <span class="literal">smatch</span> <span class="ent">➋</span>. In the first test, you <span class="literal">regex_match</span> the valid ZIP code <span class="literal">NJ07936-3173</span> <span class="ent">➌</span>, which returns the <span class="literal">true</span> value <span class="literal">matched</span> to indicate success <span class="ent">➍</span>. Because you provide an <span class="literal">smatch</span> to <span class="literal">regex_match</span>, it contains the valid ZIP code as the first element <span class="ent">➎</span>, followed by each of the three subgroups <span class="ent">➏</span>.</p>&#13;
<p class="indent">In the second test, you <span class="literal">regex_match</span> the invalid ZIP code <span class="literal">Iomega Zip 100</span> <span class="ent">➐</span>, which fails to match and returns <span class="literal">false</span> <span class="ent">➑</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec14"><strong>Searching</strong></h5>&#13;
<p class="noindent"><em>Searching</em> attempts to match a regular expression to a <em>part</em> of a string. The STL provides the <span class="literal">std::regex_search</span> function for searching, which is essentially a replacement for <span class="literal">regex_match</span> that succeeds even when only a part of a string matches a <span class="literal">regex</span>.</p>&#13;
<p class="indent">For example, <span class="literal">The string NJ07936-3173 is a ZIP Code.</span> contains a ZIP code. But applying the ZIP regular expression to it using <span class="literal">std::regex_match</span> will return <span class="literal">false</span> because the <span class="literal">regex</span> doesn’t match the <em>entire</em> string. However, applying <span class="literal">std::regex_search</span> instead would yield <span class="literal">true</span> because the string embeds a valid ZIP code. <a href="ch15.xhtml#ch15ex25">Listing 15-25</a> illustrates <span class="literal">regex_match</span> and <span class="literal">regex_search</span>.</p>&#13;
<pre>TEST_CASE("when only part of a string matches a regex, std::regex_ ") {&#13;
  std::regex regex{ R"((\w{2})(\d{5})(-\d{4})?)" }; <span class="ent">➊</span>&#13;
  std::string sentence("The string NJ07936-3173 is a ZIP Code."); <span class="ent">➋</span>&#13;
  SECTION("match returns false") {&#13;
    REQUIRE_FALSE(std::regex_match(sentence, regex)); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("search returns true") {&#13;
    REQUIRE(std::regex_search(sentence, regex)); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex25"/><em>Listing 15-25: Comparing <span class="literal">regex_match</span> and <span class="literal">regex_search</span></em></p>&#13;
<p class="indent">As before, you construct the ZIP <span class="literal">regex</span> <span class="ent">➊</span>. You also construct the example string <span class="literal">sentence</span>, which embeds a valid ZIP code <span class="ent">➋</span>. The first test calls <span class="literal">regex_</span><span class="literal">match</span> with <span class="literal">sentence</span> and <span class="literal">regex</span>, which returns <span class="literal">false</span> <span class="ent">➌</span>. The second test instead calls <span class="literal">regex_search</span> with the same arguments and returns <span class="literal">true</span> <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch15lev3sec15"><strong>Replacing</strong></h5>&#13;
<p class="noindent"><em>Replacing</em> substitutes regular expression occurrences with replacement text. The STL provides the <span class="literal">std::regex_replace</span> function for replacing.</p>&#13;
<p class="indent">In its most basic usage, you pass <span class="literal">regex_replace</span> three arguments:</p>&#13;
<ul>&#13;
<li class="noindent">A source <span class="literal">string</span>/C-string/half-open range to search</li>&#13;
<li class="noindent">A regular expression</li>&#13;
<li class="noindent">A replacement string</li>&#13;
</ul>&#13;
<p class="indent">As an example, <a href="ch15.xhtml#ch15ex26">Listing 15-26</a> replaces all the vowels in the phrase <span class="literal">queue</span><span class="literal">ing and cooeeing in eutopia</span> with underscores (<span class="literal">_</span>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_510"/>TEST_CASE("std::regex_replace") {&#13;
  std::regex regex{ "[aeoiu]" }; <span class="ent">➊</span>&#13;
  std::string phrase("queueing and cooeeing in eutopia"); <span class="ent">➋</span>&#13;
  const auto result = std::regex_replace(phrase, regex, "_"); <span class="ent">➌</span>&#13;
  REQUIRE(result == "q_____ng _nd c_____ng _n __t_p__"); <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex26"/><em>Listing 15-26: Using <span class="literal">std::regex_replace</span> to substitute underscores for vowels in a <span class="literal">string</span></em></p>&#13;
<p class="indent">You construct a <span class="literal">std::regex</span> that contains the set of all vowels <span class="ent">➊</span> and a <span class="literal">string</span> called <span class="literal">phrase</span> containing the vowel-rich contents <span class="literal">queueing and cooeeing in eutopia</span> <span class="ent">➋</span>. Next, you invoke <span class="literal">std::regex_replace</span> with <span class="literal">phrase</span>, the regex, and the string literal <span class="literal">_</span> <span class="ent">➌</span>, which replaces all vowels with underscores <span class="ent">➍</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost Regex provides regular expression support mirroring the STL’s in the <span class="literal">&lt;boost/regex.hpp&gt;</span> header. Another Boost library, Xpressive, offers an alternative approach with regular expressions that you can express directly in C++ code. It has some major advantages, such as expressiveness and compile-time syntax checking, but the syntax necessarily diverges from standard regular expression syntaxes like POSIX, Perl, and ECMAScript.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch15lev1sec4"><strong>Boost String Algorithms</strong></h3>&#13;
<p class="noindent">Boost’s String Algorithms library offers a bounty of <span class="literal">string</span> manipulation functions. It contains functions for common tasks related to <span class="literal">string</span>, such as trimming, case conversion, finding/replacing, and evaluating characteristics. You can access all the Boost String Algorithms functions in the <span class="literal">boost::algorithm</span> namespace and in the <span class="literal">&lt;boost/algorithm/string.hpp&gt;</span> convenience header.</p>&#13;
<h4 class="h4" id="ch15lev2sec14"><strong><em>Boost Range</em></strong></h4>&#13;
<p class="noindent"><em>Range</em> is a concept (in the <a href="ch06.xhtml#ch06">Chapter 6</a> compile-time polymorphism sense of the word) that has a beginning and an end that allow you to iterate over constituent elements. The range aims to improve the practice of passing a half-open range as a pair of iterators. By replacing the pair with a single object, you can <em>compose</em> algorithms together by using the range result of one algorithm as the input to another. For example, if you wanted to transform a range of strings to all uppercase and sort them, you could pass the results of one operation directly into the other. This is not generally possible to do with iterators alone.</p>&#13;
<p class="indent">Ranges are not currently part of the C++ standard, but several experimental implementations exist. One such implementation is Boost Range, and because Boost String Algorithms uses Boost Range extensively, let’s look at it now.</p>&#13;
<p class="indent">The Boost Range concept is like the STL container concept. It provides the usual complement of <span class="literal">begin</span>/<span class="literal">end</span> methods to expose iterators over the <span epub:type="pagebreak" id="page_511"/>elements in the range. Each range has a <em>traversal category</em>, which indicates the range’s supported operations:</p>&#13;
<ul>&#13;
<li class="noindent">A <em>single-pass range</em> allows one-time, forward iteration.</li>&#13;
<li class="noindent">A <em>forward range</em> allows (unlimited) forward iteration and satisfies single-pass range.</li>&#13;
<li class="noindent">A <em>bidirectional range</em> allows forward and backward iteration and satisfies forward range.</li>&#13;
<li class="noindent">A <em>random-access range</em> allows arbitrary element access and satisfies bidirectional range.</li>&#13;
</ul>&#13;
<p class="indent">Boost String Algorithms is designed for <span class="literal">std::string</span>, which satisfies the random-access range concept. For the most part, the fact that Boost String Algorithms accepts Boost Range rather than <span class="literal">std::string</span> is a totally transparent abstraction to users. When reading the documentation, you can mentally substitute <span class="literal">Range</span> with <span class="literal">string</span>.</p>&#13;
<h4 class="h4" id="ch15lev2sec15"><strong><em>Predicates</em></strong></h4>&#13;
<p class="noindent">Boost String Algorithms incorporates predicates extensively. You can use them directly by bringing in the <span class="literal">&lt;boost/algorithm/string/predicate.hpp&gt;</span> header. Most of the predicates contained in this header accept two ranges, <span class="literal">r1</span> and <span class="literal">r2</span>, and return a <span class="literal">bool</span> based on their relationship. The predicate <span class="literal">starts_with</span>, for example, returns <span class="literal">true</span> if <span class="literal">r1</span> begins with <span class="literal">r2</span>.</p>&#13;
<p class="indent">Each predicate has a case-insensitive version, which you can use by prepending the letter <span class="literal">i</span> to the method name, such as <span class="literal">istarts_with</span>. <a href="ch15.xhtml#ch15ex27">Listing 15-27</a> illustrates <span class="literal">starts_with</span> and <span class="literal">istarts_with</span>.</p>&#13;
<pre>#include &lt;string&gt;&#13;
#include &lt;boost/algorithm/string/predicate.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm") {&#13;
  using namespace boost::algorithm;&#13;
  using namespace std::literals::string_literals;&#13;
  std::string word("cymotrichous"); <span class="ent">➊</span>&#13;
  SECTION("starts_with tests a string's beginning") {&#13;
    REQUIRE(starts_with(word, "cymo"s)); <span class="ent">➋</span>&#13;
  }&#13;
  SECTION("istarts_with is case insensitive") {&#13;
    REQUIRE(istarts_with(word, "cYmO"s)); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex27"/><em>Listing 15-27: Both <span class="literal">starts_with</span> and <span class="literal">istarts_with</span> check a range’s beginning characters.</em></p>&#13;
<p class="indent">You initialize a <span class="literal">string</span> containing <span class="literal">cymotrichous</span> <span class="ent">➊</span>. The first test shows that <span class="literal">starts_with</span> returns <span class="literal">true</span> when with <span class="literal">word</span> and <span class="literal">cymo</span> <span class="ent">➋</span>. The case-insensitive version <span class="literal">istarts_with</span> also returns <span class="literal">true</span> given <span class="literal">word</span> and <span class="literal">cYmO</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_512"/>Note that <span class="literal">&lt;boost/algorithm/string/predicate.hpp&gt;</span> also contains an <span class="literal">all</span> predicate, which accepts a single range <span class="literal">r</span> and a predicate <span class="literal">p</span>. It returns <span class="literal">true</span> if <span class="literal">p</span> evaluates to <span class="literal">true</span> for all elements of <span class="literal">r</span>, as <a href="ch15.xhtml#ch15ex28">Listing 15-28</a> illustrates.</p>&#13;
<pre>TEST_CASE("boost::algorithm::all evaluates a predicate for all elements") {&#13;
  using namespace boost::algorithm;&#13;
  std::string word("juju"); <span class="ent">➊</span>&#13;
  REQUIRE(all(word<span class="ent">➋</span>, [](auto c) { return c == 'j' || c =='u'; }<span class="ent">➌</span>));&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex28"/><em>Listing 15-28: The <span class="literal">all</span> predicate evaluates if all elements in a range satisfy a predicate.</em></p>&#13;
<p class="indent">You initialize a string containing <span class="literal">juju</span> <span class="ent">➊</span>, which you pass to <span class="literal">all</span> as the range <span class="ent">➋</span>. You pass a lambda predicate, which returns <span class="literal">true</span> for the letters <span class="literal">j</span> and <span class="literal">u</span> <span class="ent">➌</span>. Because <span class="literal">juju</span> contains only these letters, <span class="literal">all</span> returns <span class="literal">true</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab12">Table 15-12</a> lists the predicates available in <span class="literal">&lt;boost/algorithm/string/predicate.hpp&gt;</span>.In this table, <span class="literal">r, r1</span>, and <span class="literal">r2</span> are string ranges, and <span class="literal">p</span> is an element comparison predicate.</p>&#13;
<p class="tabcap"><a id="ch15tab12"/><strong>Table 15-12:</strong> Predicates in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Predicate</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong> <span class="codestrong">true</span> <strong>if</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">starts_with(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">istarts_with(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r1</span> starts with <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ends_with(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">iends_with(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">r1</span> ends with <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">contains(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">icontains(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r1</span> contains <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">equals(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">iequals(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codestrong">r1</span> equals <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">lexicographical_compare(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">ilexicographical_compare(</span><span class="codestrong">r1</span><span class="literal">,</span> <span class="codestrong">r2)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r1</span> lexicographically less than <span class="codestrong">r2</span>; <span class="codestrong">p</span> used for character-wise comparison.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">all(</span><span class="codestrong">r</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">All elements of <span class="codestrong">r</span> return <span class="literal">true</span> for <span class="codestrong">p</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Function permutations beginning with <span class="literal">i</span> are case-insensitive.</p>&#13;
<h4 class="h4" id="ch15lev2sec16"><strong><em>Classifiers</em></strong></h4>&#13;
<p class="noindent"><em>Classifiers</em> are predicates that evaluate some characteristics about a character. The <span class="literal">&lt;boost/algorithm/string/classification.hpp&gt;</span> header offers generators for creating classifiers. A <em>generator</em> is a non-member function that acts like a constructor. Some generators accept arguments for customizing the classifier.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Of course, you can create your own predicates just as easily with your own function objects, like lambdas, but Boost provides a menu of premade classifiers for convenience.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_513"/>The <span class="literal">is_alnum</span> generator, for example, creates a classifier that determines whether a character is alphanumeric. <a href="ch15.xhtml#ch15ex29">Listing 15-29</a> illustrates how to use this classifier independently or in conjunction with <span class="literal">all</span>.</p>&#13;
<pre>#include &lt;boost/algorithm/string/classification.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::is_alnum") {&#13;
  using namespace boost::algorithm;&#13;
  const auto classifier = is_alnum(); <span class="ent">➊</span>&#13;
  SECTION("evaluates alphanumeric characters") {&#13;
    REQUIRE(classifier('a')); <span class="ent">➋</span>&#13;
    REQUIRE_FALSE(classifier('$')); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("works with all") {&#13;
    REQUIRE(all("nostarch", classifier)); <span class="ent">➍</span>&#13;
    REQUIRE_FALSE(all("@nostarch", classifier)); <span class="ent">➎</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex29"/><em>Listing 15-29: The <span class="literal">is_alum</span> generator determines whether a character is alphanumeric.</em></p>&#13;
<p class="indent">Here, you construct a <span class="literal">classifier</span> from the <span class="literal">is_alnum</span> generator <span class="ent">➊</span>. The first test uses the <span class="literal">classifier</span> to evaluate that <span class="literal">a</span> is alphanumeric <span class="ent">➋</span> and <span class="literal">$</span> is not <span class="ent">➌</span>. Because all classifiers are predicates that operate on characters, you can use them in conjunction with the <span class="literal">all</span> predicate discussed in the previous section to determine that <span class="literal">nostarch</span> contains all alphanumeric characters <span class="ent">➍</span> and <span class="literal">@nostarch</span> doesn’t <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab13">Table 15-13</a> lists the character classifications available in <span class="literal">&lt;boost/algorithm/string/classification.hpp&gt;</span>. In this table, <span class="literal">r</span> is a string range, and <span class="literal">beg</span> and <span class="literal">end</span> are element comparison predicates.</p>&#13;
<p class="tabcap"><a id="ch15tab13"/><strong>Table 15-13:</strong> Character Predicates in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Predicate</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Returns</strong> <span class="codestrong">true</span> <strong>if element is . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_space</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A space</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_alnum</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An alphanumeric character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_alpha</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An alphabetical character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_cntrl</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A control character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_digit</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A decimal digit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_graph</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A graphical character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_lower</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A lowercase character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_print</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A printable character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_punct</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A punctuation character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_upper</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An uppercase character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_xdigit</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A hexadecimal digit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_any_of(</span><span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Contained in <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">is_from_range(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Contained in the range from <span class="codestrong">beg</span> to <span class="codestrong">end</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec17"><strong><em><span epub:type="pagebreak" id="page_514"/>Finders</em></strong></h4>&#13;
<p class="noindent">A <em>finder</em> is a concept that determines a position in a range corresponding to some specified criteria, usually a predicate or a regular expression. Boost String Algorithms provides some generators for producing finders in the <span class="literal">&lt;boost/algorithm/string/finder.hpp&gt;</span> header.</p>&#13;
<p class="indent">For example, the <span class="literal">nth_finder</span> generator accepts a range <span class="literal">r</span> and an index <span class="literal">n</span>, and it creates a finder that will search a range (taken as a <span class="literal">begin</span> and an <span class="literal">end</span> iterator) for the <span class="literal">n</span>th occurrence of <span class="literal">r</span>, as <a href="ch15.xhtml#ch15ex30">Listing 15-30</a> illustrates.</p>&#13;
<pre>#include &lt;boost/algorithm/string/finder.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::nth_finder finds the nth occurrence") {&#13;
  const auto finder = boost::algorithm::nth_finder("na", 1); <span class="ent">➊</span>&#13;
  std::string name("Carl Brutananadilewski"); <span class="ent">➋</span>&#13;
  const auto result = finder(name.begin(), name.end()); <span class="ent">➌</span>&#13;
  REQUIRE(result.begin() == name.begin() + 12); <span class="ent">➍</span> // Brutana(n)adilewski&#13;
  REQUIRE(result.end() == name.begin() + 14); <span class="ent">➎</span> // Brutanana(d)ilewski&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex30"/><em>Listing 15-30: The <span class="literal">nth_finder</span> generator creates a finder that locates the <em>n</em>th occurrence of a sequence.</em></p>&#13;
<p class="indent">You use the <span class="literal">nth_finder</span> generator to create <span class="literal">finder</span>, which will locate the second instance of <span class="literal">na</span> in a range (<span class="literal">n</span> is zero based) <span class="ent">➊</span>. Next, you construct <span class="literal">name</span> containing <span class="literal">Carl Brutananadilewski</span> <span class="ent">➋</span> and invoke <span class="literal">finder</span> with the <span class="literal">begin</span> and <span class="literal">end</span> iterators of <span class="literal">name</span> <span class="ent">➌</span>. The <span class="literal">result</span> is a range whose <span class="literal">begin</span> points to the second <em>n</em> in <span class="literal">Brutana</span><span class="literal">n</span><span class="literal">adilewski</span> <span class="ent">➍</span> and whose <span class="literal">end</span> points to the first <em>d</em> in <span class="literal">Brutanana</span><span class="literal">d</span><span class="literal">ilewski</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab14">Table 15-14</a> lists the finders available in <span class="literal">&lt;boost/algorithm/string/finder.hpp&gt;</span>. In this table, <span class="literal">s</span> is a string, <span class="literal">p</span> is an element comparison predicate, <span class="literal">n</span> is an integral value, <span class="literal">beg</span> and <span class="literal">end</span> are iterators, <span class="literal">rgx</span> is a regular expression, and <span class="literal">r</span> is a string range.</p>&#13;
<p class="tabcap"><a id="ch15tab14"/><strong>Table 15-14:</strong> Finders in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Generator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Creates a finder that, when invoked, returns . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">first_finder(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">p</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The first element matching <span class="codestrong">s</span> using <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">last_finder(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">p)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The last element matching <span class="codestrong">s</span> using <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">nth_finder(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">p</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The <span class="codestrong">n</span>th element matching <span class="codestrong">s</span> using <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">head_finder(</span><span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The first <span class="codestrong">n</span> elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">tail_finder(</span><span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">the last <span class="codestrong">n</span> elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">token_finder(</span><span class="codestrong">p</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The character matching <span class="codestrong">p</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">range_finder(</span><span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">range_finder(</span><span class="codestrong">beg</span><span class="literal">,</span> <span class="codestrong">end</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">r</span> regardless of input</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">regex_finder(</span><span class="codestrong">rgx</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">The first substring matching <span class="codestrong">rgx</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_515"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Boost String Algorithms specifies a formatter concept, which presents the results of a finder to a replace algorithm. Only an advanced user will need these algorithms. Refer to the documentation for the <span class="literal">find_format</span> algorithms in the <span class="literal">&lt;boost/algorithm/string/find_format.hpp&gt;</span> header for more information.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch15lev2sec18"><strong><em>Modifying Algorithms</em></strong></h4>&#13;
<p class="noindent">Boost contains a <em>lot</em> of algorithms for modifying a <span class="literal">string</span> (range). Between the <span class="literal">&lt;boost/algorithm/string/case_conv.hpp&gt;</span><span class="literal">, &lt;boost/algorithm/string/trim.hpp&gt;</span>, and <span class="literal">&lt;boost/algorithm/string/replace.hpp&gt;</span> headers, algorithms exist to convert case, trim, replace, and erase many different ways.</p>&#13;
<p class="indent">For example, the <span class="literal">to_upper</span> function will convert all of a string’s letters to uppercase. If you want to keep the original unmodified, you can use the <span class="literal">to_upper_copy</span> function, which will return a new object. <a href="ch15.xhtml#ch15ex31">Listing 15-31</a> illustrates <span class="literal">to_upper</span> and <span class="literal">to_upper_copy</span>.</p>&#13;
<pre>#include &lt;boost/algorithm/string/case_conv.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::to_upper") {&#13;
  std::string powers("difficulty controlling the volume of my voice"); <span class="ent">➊</span>&#13;
  SECTION("upper-cases a string") {&#13;
    boost::algorithm::to_upper(powers); <span class="ent">➋</span>&#13;
    REQUIRE(powers == "DIFFICULTY CONTROLLING THE VOLUME OF MY VOICE"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("_copy leaves the original unmodified") {&#13;
    auto result = boost::algorithm::to_upper_copy(powers); <span class="ent">➍</span>&#13;
    REQUIRE(powers == "difficulty controlling the volume of my voice"); <span class="ent">➎</span>&#13;
    REQUIRE(result == "DIFFICULTY CONTROLLING THE VOLUME OF MY VOICE"); <span class="ent">➏</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex31"/><em>Listing 15-31: Both <span class="literal">to_upper</span> and <span class="literal">to_upper_copy</span> convert the case of a <span class="literal">string</span>.</em></p>&#13;
<p class="indent">You create a <span class="literal">string</span> called <span class="literal">powers</span> <span class="ent">➊</span>. The first test invokes <span class="literal">to_upper</span> on <span class="literal">powers</span> <span class="ent">➋</span>, which modifies it in place to contain all uppercase letters <span class="ent">➌</span>. The second test uses the <span class="literal">_copy</span> variant to create a new <span class="literal">string</span> called <span class="literal">result</span> <span class="ent">➍</span>. The <span class="literal">powers</span> string is unaffected <span class="ent">➎</span>, whereas <span class="literal">result</span> contains an all uppercase version <span class="ent">➏</span>.</p>&#13;
<p class="indent">Some Boost String Algorithms, such as <span class="literal">replace_first</span>, also have case-insensitive versions. Just prepend an <span class="literal">i</span>, and matching will proceed regardless of case. For algorithms like <span class="literal">replace_first</span> that also have <span class="literal">_copy</span> variants, any permutation will work (<span class="literal">replace_first</span>, <span class="literal">ireplace_first</span><span class="literal">, replace_first_copy</span>, and <span class="literal">ireplace_first_copy</span>).</p>&#13;
<p class="indent">The <span class="literal">replace_first</span> algorithm and its variants accept an input range <span class="literal">s</span>, a match range <span class="literal">m</span>, and a replace range <span class="literal">r</span>, and replaces the first instance of <span class="literal">m</span> in <span class="literal">s</span> with <span class="literal">r</span>. <a href="ch15.xhtml#ch15ex32">Listing 15-32</a> illustrates <span class="literal">replace_first</span> and <span class="literal">i_replace_first</span>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_516"/>#include &lt;boost/algorithm/string/replace.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::replace_first") {&#13;
  using namespace boost::algorithm;&#13;
  std::string publisher("No Starch Press"); <span class="ent">➊</span>&#13;
  SECTION("replaces the first occurrence of a string") {&#13;
    replace_first(publisher, "No", "Medium"); <span class="ent">➋</span>&#13;
    REQUIRE(publisher == "Medium Starch Press"); <span class="ent">➌</span>&#13;
  }&#13;
  SECTION("has a case-insensitive variant") {&#13;
    auto result = ireplace_first_copy(publisher, "NO", "MEDIUM"); <span class="ent">➍</span>&#13;
    REQUIRE(publisher == "No Starch Press"); <span class="ent">➎</span>&#13;
    REQUIRE(result == "MEDIUM Starch Press"); <span class="ent">➏</span>&#13;
  }}</pre>&#13;
<p class="listing"><a id="ch15ex32"/><em>Listing 15-32: Both <span class="literal">replace_first</span> and <span class="literal">i_replace_first</span> replace matching <span class="literal">string</span> sequences.</em></p>&#13;
<p class="indent">Here, you construct a <span class="literal">string</span> called <span class="literal">publisher</span> containing <span class="literal">No Starch Press</span> <span class="ent">➊</span>. The first test invokes <span class="literal">replace_first</span> with <span class="literal">publisher</span> as the input string, <span class="literal">No</span> as the match string, and <span class="literal">Medium</span> as the replacement string <span class="ent">➋</span>. Afterward, <span class="literal">publisher</span> contains <span class="literal">Medium Starch Press</span> <span class="ent">➌</span>. The second test uses the <span class="literal">ireplace_first_copy</span> variant, which is case insensitive and performs a copy. You pass <span class="literal">NO</span> and <span class="literal">MEDIUM</span> as the match and replace strings <span class="ent">➍</span>, respectively, and the <span class="literal">result</span> contains <span class="literal">MEDIUM Starch Press</span> <span class="ent">➏</span>, whereas <span class="literal">publisher</span> is unaffected <span class="ent">➎</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab15">Table 15-15</a> lists many of the modifying algorithms available in Boost String Algorithms. In this table, <span class="literal">r, s, s1</span>, and <span class="literal">s2</span> are strings; <span class="literal">p</span> is an element comparison predicate; <span class="literal">n</span> is an integral value; and <span class="literal">rgx</span> is a regular expression.</p>&#13;
<p class="tabcap"><a id="ch15tab15"/><strong>Table 15-15:</strong> Modifying Algorithms in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Algorithm</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">to_upper(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">to_upper_copy(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Converts <span class="codestrong">s</span> to all uppercase</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">to_lower(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">to_lower_copy(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Converts <span class="codestrong">s</span> to all lowercase</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">trim_left_copy_if(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">trim_left_if(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">trim_left_copy(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">trim_left(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes leading spaces from <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">trim_right_copy_if(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">trim_right_if(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">trim_right_copy(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">trim_right(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Removes trailing spaces from <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">trim_copy_if(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">trim_if(</span><span class="codestrong">s</span><span class="literal">, [</span><span class="codestrong">p</span><span class="literal">])</span></p>&#13;
<p class="taba"><span class="literal">trim_copy(</span><span class="codestrong">s</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">trim(</span><span class="codestrong">s</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Removes leading and trailing spaces from <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_first(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_first_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_first(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_first_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the first occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_first(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_first_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_first(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_first_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span epub:type="pagebreak" id="page_517"/>Erases the first occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_last(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_last_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_last(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_last_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the last occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_last(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_last_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_last(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_last_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the last occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_nth(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_nth_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_nth(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_nth_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the <span class="codestrong">n</span>th occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_nth(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_nth_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_nth(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_nth_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the <span class="codestrong">n</span>th occurrence of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_all(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_all_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_all(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ireplace_all_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces all occurrences of <span class="codestrong">s2</span> in <span class="codestrong">s1</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_all(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_all_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_all(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ierase_all_copy(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases all occurrences of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_head(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_head_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the first <span class="codestrong">n</span> characters of <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_head(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_head_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the first <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_tail(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_tail_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the last <span class="codestrong">n</span> characters of <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_tail(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_tail_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the last <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_regex(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_regex_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces the first instance of <span class="codestrong">rgx</span> in <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">erase_regex(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_regex_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Erases the first instance of <span class="codestrong">rgx</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">replace_all_regex(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">replace_all_regex_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">,</span> <span class="codestrong">r</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Replaces all instances of <span class="codestrong">rgx</span> in <span class="codestrong">s</span> with <span class="codestrong">r</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">erase_all_regex(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">erase_all_regex_copy(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Erases all instances of <span class="codestrong">rgx</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec19"><strong><em>Splitting and Joining</em></strong></h4>&#13;
<p class="noindent">Boost String Algorithms contains functions for splitting and joining strings in the <span class="literal">&lt;boost/algorithm/string/split.hpp&gt;</span> and <span class="literal">&lt;boost/algorithm/string/join.</span><span class="literal">hpp&gt;</span> headers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_518"/>To split a <span class="literal">string</span>, you provide the <span class="literal">split</span> function with an STL container <span class="literal">res</span>, a range <span class="literal">s</span>, and a predicate <span class="literal">p</span>. It will tokenize the range <span class="literal">s</span> using the predicate <span class="literal">p</span> to determine delimiters and insert the results into <span class="literal">res</span>. <a href="ch15.xhtml#ch15ex33">Listing 15-33</a> illustrates the <span class="literal">split</span> function.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
#include &lt;boost/algorithm/string/split.hpp&gt;&#13;
#include &lt;boost/algorithm/string/classification.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::split splits a range based on a predicate") {&#13;
  using namespace boost::algorithm;&#13;
  std::string publisher("No Starch Press"); <span class="ent">➊</span>&#13;
  std::vector&lt;std::string&gt; tokens; <span class="ent">➋</span>&#13;
  split(tokens, publisher, is_space()); <span class="ent">➌</span>&#13;
  REQUIRE(tokens[0] == "No"); <span class="ent">➍</span>&#13;
  REQUIRE(tokens[1] == "Starch");&#13;
  REQUIRE(tokens[2] == "Press");&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex33"/><em>Listing 15-33: The <span class="literal">split</span> function tokenizes a <span class="literal">string</span>.</em></p>&#13;
<p class="indent">Armed again with <span class="literal">publisher</span> <span class="ent">➊</span>, you create a <span class="literal">vector</span> called <span class="literal">tokens</span> to contain the results <span class="ent">➋</span>. You invoke <span class="literal">split</span> with <span class="literal">tokens</span> as the results container, <span class="literal">publisher</span> as the range, and an <span class="literal">is_space</span> as your predicate <span class="ent">➌</span>. This splits the publisher into pieces by spaces. Afterward, <span class="literal">tokens</span> contains <span class="literal">No, Starch</span>, and <span class="literal">Press</span> as expected <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can perform the inverse operation with <span class="literal">join</span>, which accepts an STL container <span class="literal">seq</span> and a separator string <span class="literal">sep</span>. The <span class="literal">join</span> function will bind each element of <span class="literal">seq</span> together with <span class="literal">sep</span> between each.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex34">Listing 15-34</a> illustrates the utility of <span class="literal">join</span> and the indispensability of the Oxford comma.</p>&#13;
<pre>#include &lt;vector&gt;&#13;
#include &lt;boost/algorithm/string/join.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::join staples tokens together") {&#13;
  std::vector&lt;std::string&gt; tokens{ "We invited the strippers",&#13;
                                   "JFK", "and Stalin." }; <span class="ent">➊</span>&#13;
  auto result = boost::algorithm::join(tokens, ", "); <span class="ent">➋</span>&#13;
  REQUIRE(result == "We invited the strippers, JFK, and Stalin."); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex34"/><em>Listing 15-34: The <span class="literal">join</span> function attaches <span class="literal">string</span> tokens together with a separator.</em></p>&#13;
<p class="indent">You instantiate a <span class="literal">vector</span> called <span class="literal">tokens</span> with three <span class="literal">string</span> objects <span class="ent">➊</span>. Next, you use <span class="literal">join</span> to bind token’s constituent elements together with a comma followed by a space <span class="ent">➋</span>. The result is a single <span class="literal">string</span> containing the constituent elements bound together with commas and spaces <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_519"/><a href="ch15.xhtml#ch15tab16">Table 15-16</a> lists many of the split/join algorithms available in <span class="literal">&lt;boost/algorithm/string/split.hpp&gt;</span> and <span class="literal">&lt;boost/algorithm/string/join.hpp&gt;</span>. In this table, <span class="literal">res, s, s1</span>, <span class="literal">s2</span>, and <span class="literal">sep</span> are strings; <span class="literal">seq</span> is a range of strings; <span class="literal">p</span> is an element comparison predicate; and <span class="literal">rgx</span> is a regular expression.</p>&#13;
<p class="tabcap"><a id="ch15tab16"/><strong>Table 15-16:</strong> <span class="literal">split</span> and <span class="literal">join</span> Algorithms in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">find_all(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ifind_all(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">find_all_regex(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">iter_find(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Finds all instances of <span class="codestrong">s2</span> or <span class="codestrong">rgx</span> in <span class="codestrong">s1</span>, writing each into <span class="codestrong">res</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">split(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">p</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">split_regex(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">iter_split(</span><span class="codestrong">res</span><span class="literal">,</span> <span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Split <span class="codestrong">s</span> using <span class="codestrong">p</span>, <span class="codestrong">rgx</span>, or <span class="codestrong">s2</span>, writing tokens into <span class="codestrong">res</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">join(</span><span class="codestrong">seq</span><span class="literal">,</span> <span class="codestrong">sep</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns a <span class="literal">string</span> joining <span class="codestrong">seq</span> using <span class="codestrong">sep</span> as a separator</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">join_if(</span><span class="codestrong">seq</span><span class="literal">,</span> <span class="codestrong">sep</span><span class="literal">,</span> <span class="codestrong">p</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Returns a <span class="literal">string</span> joining all elements of <span class="codestrong">seq</span> matching <span class="codestrong">p</span> using <span class="codestrong">sep</span> as a separator</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="ch15lev2sec20"><strong><em>Searching</em></strong></h4>&#13;
<p class="noindent">Boost String Algorithms offers a handful of functions for searching ranges in the <span class="literal">&lt;boost/algorithm/string/find.hpp&gt;</span> header. These are essentially convenient wrappers around the finders in <a href="ch15.xhtml#ch15tab08">Table 15-8</a>.</p>&#13;
<p class="indent">For example, the <span class="literal">find_head</span> function accepts a range <span class="literal">s</span> and a length <span class="literal">n</span>, and it returns a range containing the first <span class="literal">n</span> elements of <span class="literal">s</span>. <a href="ch15.xhtml#ch15ex35">Listing 15-35</a> illustrates the <span class="literal">find_head</span> function.</p>&#13;
<pre>#include &lt;boost/algorithm/string/find.hpp&gt;&#13;
&#13;
TEST_CASE("boost::algorithm::find_head computes the head") {&#13;
  std::string word("blandishment"); <span class="ent">➊</span>&#13;
  const auto result = boost::algorithm::find_head(word, 5); <span class="ent">➋</span>&#13;
  REQUIRE(result.begin() == word.begin()); <span class="ent">➌</span> // (b)landishment&#13;
  REQUIRE(result.end() == word.begin()+5); <span class="ent">➍</span> // bland(i)shment&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex35"/><em>Listing 15-35: The <span class="literal">find_head</span> function creates a range from the beginning of a <span class="literal">string</span>.</em></p>&#13;
<p class="indent">You construct a <span class="literal">string</span> called <span class="literal">word</span> containing <span class="literal">blandishment</span> <span class="ent">➊</span>. You pass it into <span class="literal">find_head</span> along with the length argument <span class="literal">5</span> <span class="ent">➋</span>. The <span class="literal">begin</span> of <span class="literal">result</span> points to the beginning of <span class="literal">word</span> <span class="ent">➌</span>, and its <span class="literal">end</span> points to 1 past the fifth element <span class="ent">➍</span>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15tab17">Table 15-17</a> lists many of the find algorithms available in <span class="literal">&lt;boost/algorithm/string/find.hpp&gt;</span>. In this table, <span class="literal">s, s1</span>, and <span class="literal">s2</span> are strings; <span class="literal">p</span> is an element comparison predicate; <span class="literal">rgx</span> is a regular expression; and <span class="literal">n</span> is an integral value.</p>&#13;
<p class="tabcap"><a id="ch15tab17"/><strong>Table 15-17:</strong><span epub:type="pagebreak" id="page_520"/> Find Algorithms in the Boost String Algorithms Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Predicate</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Finds the . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">find_first(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ifind_first(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First instance of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">find_last(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ifind_last(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First instance of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">find_nth(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p>&#13;
<p class="taba"><span class="literal">ifind_nth(</span><span class="codestrong">s1</span><span class="literal">,</span> <span class="codestrong">s2</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codestrong">n</span>th instance of <span class="codestrong">s2</span> in <span class="codestrong">s1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">find_head(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">find_tail(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">n</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Last <span class="codestrong">n</span> characters of <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">find_token(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">p</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">First character matching <span class="codestrong">p</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">find_regex(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">rgx</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">First substring matching <span class="codestrong">rgx</span> in <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">find(</span><span class="codestrong">s</span><span class="literal">,</span> <span class="codestrong">fnd</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Result of applying <span class="codestrong">fnd</span> to <span class="codestrong">s</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="ch15lev1sec5"><strong>Boost Tokenizer</strong></h3>&#13;
<p class="noindent">Boost Tokenizer’s <span class="literal">boost::tokenizer</span> is a class template that provides a view of a series of tokens contained in a <span class="literal">string</span>. A <span class="literal">tokenizer</span> takes three optional template parameters: a tokenizer function, an iterator type, and a string type.</p>&#13;
<p class="indent">The <em>tokenizer function</em> is a predicate that determines whether a character is a delimiter (returns <span class="literal">true</span>) or not (returns <span class="literal">false</span>). The default tokenizer function interprets spaces and punctuation marks as separators. If you want to specify the delimiters explicitly, you can use the <span class="literal">boost::char_separator&lt;char&gt;</span> class, which accepts a C-string containing all the delimiting characters. For example, a <span class="literal">boost::char_separator&lt;char&gt;(";|,")</span> would separate on semicolons (<span class="literal">;</span>), pipes (<span class="literal">|</span>), and commas (<span class="literal">,</span>).</p>&#13;
<p class="indent">The iterator type and string type correspond with the type of <span class="literal">string</span> you want to split. By default, these are <span class="literal">std::string::const_iterator</span> and <span class="literal">std::string</span>, respectively.</p>&#13;
<p class="indent">Because <span class="literal">tokenizer</span> doesn’t allocate memory and <span class="literal">boost::algorithm::split</span> does, you should strongly consider using the former whenever you only need to iterate over the tokens of a <span class="literal">string</span> once.</p>&#13;
<p class="indent">A <span class="literal">tokenizer</span> exposes <span class="literal">begin</span> and <span class="literal">end</span> methods that return input iterators, so you can treat it as a range of values corresponding to the underlying token sequence.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex36">Listing 15-36</a> tokenizes the iconic palindrome <span class="literal">A man, a plan, a canal, Panama!</span> by comma.</p>&#13;
<pre>#include&lt;boost/tokenizer.hpp&gt;&#13;
#include&lt;string&gt;&#13;
&#13;
TEST_CASE("boost::tokenizer splits token-delimited strings") {&#13;
  std::string palindrome("A man, a plan, a canal, Panama!"); <span class="ent">➊</span>&#13;
  boost::char_separator&lt;char&gt; comma{ "," }; <span class="ent">➋</span>&#13;
  boost::tokenizer&lt;boost::char_separator&lt;char&gt;&gt; tokens{ palindrome, comma }; <span class="ent">➌</span>&#13;
  auto itr = tokens.begin(); <span class="ent">➍</span>&#13;
<span epub:type="pagebreak" id="page_521"/>  REQUIRE(*itr == "A man"); <span class="ent">➎</span>&#13;
  itr++; <span class="ent">➏</span>&#13;
  REQUIRE(*itr == " a plan");&#13;
  itr++;&#13;
  REQUIRE(*itr == " a canal");&#13;
  itr++;&#13;
  REQUIRE(*itr == " Panama!");&#13;
}</pre>&#13;
<p class="listing"><a id="ch15ex36"/><em>Listing 15-36: The <span class="literal">boost::tokenizer</span> splits strings by specified delimiters.</em></p>&#13;
<p class="indent">Here, you construct <span class="literal">palindrome</span> <span class="ent">➊, char_separator</span> <span class="ent">➋</span>, and the corresponding <span class="literal">tokenizer</span> <span class="ent">➌</span>. Next, you extract an iterator from the tokenizer using its <span class="literal">begin</span> method <span class="ent">➍</span>. You can treat the resulting iterator as usual, dereferencing its value <span class="ent">➎</span> and incrementing to the next element <span class="ent">➏</span>.</p>&#13;
<h3 class="h3" id="ch15lev1sec6"><strong>Localizations</strong></h3>&#13;
<p class="noindent">A <em>locale</em> is a class for encoding cultural preferences. The locale concept is typically encoded in whatever operating environment your application runs within. It also controls many preferences, such as string comparison; date and time, money, and numeric formatting; postal and ZIP codes; and phone numbers.</p>&#13;
<p class="indent">The STL offers the <span class="literal">std::locale</span> class and many helper functions and classes in the <span class="literal">&lt;locale&gt;</span> header.</p>&#13;
<p class="indent">Mainly for brevity (and partially because English speakers are the primary intended audience for this book), this chapter won’t explore locales any further.</p>&#13;
<h3 class="h3" id="ch15lev1sec7"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter covered <span class="literal">std::string</span> and its ecosystem in detail. After exploring its similarities to <span class="literal">std::vector</span>, you learned about its built-in methods for handling human-language data, such as comparing, adding, removing, replacing, and searching. You looked at how the numeric conversion functions allow you to convert between numbers and strings, and you examined the role that <span class="literal">std::string_view</span> plays in passing strings around your programs. You also learned how to employ regular expressions to perform intricate match, search, and replacement based on potentially complicated patterns. Finally, you trekked through the Boost String Algorithms library, which complements and extends the built-in methods of <span class="literal">std::string</span> with additional methods for searching, replacing, trimming, erasing, splitting, and joining.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><strong><span epub:type="pagebreak" id="page_522"/>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>15-1.</strong> Refactor the histogram calculator in <a href="ch09.xhtml#ch09ex30">Listings 9-30</a> and <a href="ch09.xhtml#ch09ex31">9-31</a> to use <span class="literal">std::string</span>. Construct a <span class="literal">string</span> from the program’s input and modify <span class="literal">AlphaHistogram</span> to accept a <span class="literal">string_view</span> or a <span class="literal">const string&amp;</span> in its <span class="literal">ingest</span> method. Use a range-based <span class="literal">for</span> loop to iterate over the ingested elements of <span class="literal">string</span>. Replace the <span class="literal">counts</span> field’s type with an associative container.</p>&#13;
<p class="noindent"><strong>15-2.</strong> Implement a program that determines whether the user’s input is a palindrome.</p>&#13;
<p class="noindent"><strong>15-3.</strong> Implement a program that counts the number of vowels in the user’s input.</p>&#13;
<p class="noindent"><strong>15-4.</strong> Implement a calculator program that supports addition, subtraction, multiplication, and division of any two numbers. Consider using the <span class="literal">find</span> method of <span class="literal">std::string</span> and the numeric conversion functions.</p>&#13;
<p class="noindent"><strong>15-5.</strong> Extend your calculator program in some of the following ways: permit multiple operations or the modulo operator and accept floating-point numbers or parentheses.</p>&#13;
<p class="noindent"><strong>15-6.</strong> Optional: Read more about locales in [localization].</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>ISO International Standard ISO/IEC (2017) — Programming Language C++</em> (International Organization for Standardization; Geneva, Switzerland; <em><a href="https://isocpp.org/std/the-standard/">https://isocpp.org/std/the-standard/</a></em>)</li>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li><li class="noindent"><em>The Boost C++ Libraries</em>, 2nd Edition, by Boris Schäling (XML Press, 2014)</li>&#13;
<li class="noindent"><em>The C++ Standard Library: A Tutorial and Reference</em>, 2nd Edition, by Nicolai M. Josuttis (Addison-Wesley Professional, 2012)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>