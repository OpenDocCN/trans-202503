["```\nfun babylonianSquareRoot(num: Double): Double {\n    val TOL = 0.000001\n    var iter = 1\n    var guess = num / 2.0\n\n    while(Math.abs(guess * guess - num) > TOL) {\n        println(\"iter: $iter  guess=$guess\")\n        guess = (guess + num / guess) / 2.0\n        iter ++\n    }\n    return guess\n}\n```", "```\nfun main() {\n    println(\"\\n*** Finding Square Root Using Babylonian Algorithm ***\\n\")\n    println(\"Enter a number (>=1) to find its square root:\")\n    val num = readln().toDouble()\n    println(\"You have entered: $num\\n\")\n    val squareRoot = babylonianSquareRoot(num)\n    println(\"\\nThe estimated square root of $num is: $squareRoot\\n\")\n}\n```", "```\n*** Finding Square Root Using Babylonian Algorithm ***\n\nEnter a number (>=1) to find its square root:\n**25**\nYou have entered: 25.0\n\niter: 1  guess=12.5\niter: 2  guess=7.25\niter: 3  guess=5.349137931034482\niter: 4  guess=5.011394106532552\niter: 5  guess=5.000012953048684\n\nThe estimated square root of 25.0 is: 5.000000000016778\n```", "```\nfun generatePythagoreanTriple(m: Int, n: Int):\n    Triple<Int, Int, Int> {\n    val a = m * m - n * n\n    val b = 2 * m * n\n    val c = m * m + n * n\n    return Triple(a, b, c)\n}\n```", "```\nfun main() {\n    var m = 2               // value of m\n    var n = 1               // value of n\n    val numTriples = 10     // number of triples\n\n println(\"\\n*** Pythagorean Triples Using Euclid's Formula ***\\n\")\n    println(\"Number of Pythagorean triples: $numTriples\\n\")\n\n    // Generate the first \"numTriples\" triples.\n    for (i in 1..numTriples) {\n        val pythagoreanTriple =\n            generatePythagoreanTriple(m, n)\n        print(\"i=${\"%2d\".format(i)}    \" +\n              \"m=${\"%2d\".format(m)}    n=${\"%2d\".format(n)}  \")\n        println(\"Pythagorean triple: $pythagoreanTriple\")\n        n++\n        m++\n    }\n}\n```", "```\n*** Pythagorean Triples Using Euclid's Formula ***\n\nNumber of Pythagorean triples: 10\n\ni= 1    m= 2    n= 1  Pythagorean triple: (3, 4, 5)\ni= 2    m= 3    n= 2  Pythagorean triple: (5, 12, 13)\ni= 3    m= 4    n= 3  Pythagorean triple: (7, 24, 25)\ni= 4    m= 5    n= 4  Pythagorean triple: (9, 40, 41)\ni= 5    m= 6    n= 5  Pythagorean triple: (11, 60, 61)\ni= 6    m= 7    n= 6  Pythagorean triple: (13, 84, 85)\ni= 7    m= 8    n= 7  Pythagorean triple: (15, 112, 113)\ni= 8    m= 9    n= 8  Pythagorean triple: (17, 144, 145)\ni= 9    m=10    n= 9  Pythagorean triple: (19, 180, 181)\ni=10    m=11    n=10  Pythagorean triple: (21, 220, 221)\n```", "```\nfun sieveOfEratosthenes(n: Int): List<Int> {\n    // Create a Boolean array with all values set to true.\n    val primes = BooleanArray(n + 1) {true}\n    // Create a mutable list of integers to save prime numbers.\n    val primeNumbers = mutableListOf<Int>()\n\n    // Set 0 and 1 to not be prime.\n    primes[0] = false\n    primes[1] = false\n\n    // Iterate over all numbers until i^2 > N.\n    var i = 2\n  ❶ while (i*i <= n) {\n        // If i is prime, mark all multiples of i as not prime.\n      ❷ if (primes[i]) {\n          ❸ for (j in i * i..n step i) {\n                primes[j] = false\n            }\n        }\n        i++\n    }\n\n    // Collect all prime numbers into a list and return it.\n  ❹ for ((index, value) in primes.withIndex())\n        if (value) primeNumbers.add(index)\n\n  ❺ return primeNumbers\n}\n```", "```\nfun main() {\n    println(\"\\n*** Find All Prime Numbers Up to 'n' ***\\n\")\n    println(\"Enter a number > 2 to generate the list of primes:\")\n    val num = readln().toInt()\n    println(\"You have entered: $num\")\n\n    val primeNumbers = sieveOfEratosthenes(num)\n    println(\"\\nThe prime numbers <= $num are:\")\n    printPrimes(primeNumbers)\n}\n\nfun printPrimes(primeNumbers: List<Int>) {\n    for (i in primeNumbers.indices) {\n        if (i != 0 && i % 6 == 0) println()\n        print(\"${\"%8d\".format(primeNumbers[i])} \")\n    }\n}\n```", "```\n*** Find All Prime Numbers Up to 'n' ***\n\nEnter a number > 2 to generate the list of primes:\n**251**\nYou have entered: 251\n\nThe prime numbers <= 251 are:\n       2        3        5        7       11       13\n      17       19       23       29       31       37\n      41       43       47       53       59       61\n      67       71       73       79       83       89\n      97      101      103      107      109      113\n     127      131      137      139      149      151\n     157      163      167      173      179      181\n     191      193      197      199      211      223\n     227      229      233      239      241      251\n```", "```\nimport kotlin.math.atan\n\ndata class Earth(\n    val alpha: Double,\n    val circumference: Int,\n    val radius: Int\n)\n\nfun calculateEarthMetrics(s1: Double, h1: Double,\n                          s2: Double, h2: Double, d: Double): Earth {\n    // Calculate the angles of the shadows.\n    val theta1 = atan(s1 / h1)\n    val theta2 = atan(s2 / h2)\n\n    // Calculate the angle at the center of Earth.\n    val alpha = theta2 - theta1\n\n    // Calculate the circumference and radius.\n    val circumference = (2 * Math.PI * d / alpha).toInt()\n    val radius = (d / alpha).toInt()\n\n    return Earth(alpha, circumference, radius)\n}\n\nfun main() {\n    // known values\n    val shadow1 = 0.0    // m\n    val height1 = 7.0    // m\n    val shadow2 = 0.884  // m\n    val height2 = 7.0    // m\n    val distanceBetweenCities = 800.0 // in km\n    val (alpha, circumference, radius) =\n calculateEarthMetrics(s1=shadow1, h1=height1,\n            s2=shadow2, h2=height2,\n            d=distanceBetweenCities)\n\n    // Output the estimated circumference and radius.\n    println(\"\\n*** Measuring Earth's Circumference and Radius ***\\n\")\n    println(\"Angle (alpha): ${\"%7.5f\".format(alpha)} radian\")\n    println(\"Circumference: $circumference kilometers\")\n    println(\"Radius: $radius kilometers\")\n}\n```", "```\n*** Measuring Earth's Circumference and Radius ***\n\nAngle (alpha): 0.12562 radian\nCircumference: 40013 kilometers\nRadius: 6368 kilometers\n```", "```\nimport javafx.application.Application\nimport javafx.scene.Scene\nimport javafx.scene.canvas.Canvas\nimport javafx.scene.canvas.GraphicsContext\nimport javafx.scene.layout.Pane\nimport javafx.scene.paint.Color\nimport javafx.scene.shape.ArcType\nimport javafx.scene.text.Font\nimport javafx.stage.Stage\n\n// number of Fibonacci numbers in the list\nval N = 9\nval fibs = mutableListOf<Int>()\n\n// canvas-related parameters\nval canvasW = 1000.0\nval canvasH = 750.0\n\n// Scaling parameters: adjust as needed.\nval xOffset = 150\nval yOffset = 50\nval amplify = 25.0\n\nclass FibonacciSpiral : Application() {\n    override fun start(stage: Stage) {\n        val root = Pane()\n        val canvas = Canvas(canvasW, canvasH)\n        val gc = canvas.graphicsContext2D\n        gc.translate(canvas.width / 2 + xOffset,\n            canvas.height / 2 + yOffset)\n        root.children.add(canvas)\n\n        val scene1 = Scene(root, canvasW, canvasH)\n        scene1.fill = Color.WHITE\n        with(stage) {\n            title = \"Fibonacci Spiral\"\n scene = scene1\n            show()\n        }\n\n        // code for Fibonacci sequence and spiral\n        generateFibonacciNumbers()\n        drawFibonacciSpiral(gc)\n        printFibonacciSequenceAndRatios()\n    }\n}\n\nfun main() {\n    Application.launch(FibonacciSpiral::class.java)\n}\n```", "```\nfun generateFibonacciNumbers() {\n    // Add the starting pair.\n    fibs.add(0)\n    fibs.add(1)\n\n    // Generate the sequence.\n    for (i in 2 until N) {\n        fibs.add(fibs[i-1] + fibs[i-2])\n    }\n}\n```", "```\nfun drawFibonacciSpiral(gc: GraphicsContext) {\n    for (i in 1 until N) {\n      ❶ val side = fibs[i] * amplify\n      ❷ with(gc) {\n            strokeRect(0.0, 0.0, side, side)\n            drawText(i, gc, side)\n            drawArc(gc, side)\n            // Move to the opposite corner by adding\n            // side to both x- and y-coordinates.\n            translate(side, side)\n            // Rotate the axes counterclockwise.\n            rotate(-90.0)\n        }\n    }\n}\n\nfun drawText(i: Int, gc: GraphicsContext, side: Double) {\n    gc.fill = Color.BLACK\n    with(gc) {\n      ❸ font = when {\n            i <= 2 -> Font.font(12.0)\n            else -> Font.font(24.0)\n        }\n        fillText(fibs[i].toString(), side/2, side/2)\n    }\n}\n\nfun drawArc(gc: GraphicsContext, side: Double) {\n    val x = 0.0\n    val y = -side\n    with(gc) {\n        lineWidth = 3.0\n        strokeArc(x, y, 2*side, 2*side,\n            -90.0, -90.0, ArcType.OPEN)\n    }\n}\n```", "```\nprivate fun printFibonacciSequenceAndRatios() {\n    println(\"\\n*** Fibonacci sequence and ratios ***\\n\")\n    println(\"Length of Fibonacci sequence=${fibs.size}\")\n    println(\"Generated sequence:\")\n  ❶ println(fibs)\n    println(\"\\nRatio F(n+1)/F(n) [starting from (1,1) pair]:\")\n    for (i in 2 until fibs.size) {\n        println(\"%5d\".format(fibs[i-1]) +\n                \"%5d\".format(fibs[i]) +\n                \"%12.6f\".format(fibs[i].toDouble()/fibs[i-1])\n        )\n    }\n}\n```", "```\n*** Fibonacci sequence and ratios ***\n\nLength of Fibonacci sequence=9\nGenerated sequence:\n[0, 1, 1, 2, 3, 5, 8, 13, 21]\n\nRatio F(n+1)/F(n) [starting from (1,1) pair]:\n    1    1    1.000000\n    1    2    2.000000\n    2    3    1.500000\n    3    5    1.666667\n    5    8    1.600000\n    8   13    1.625000\n   13   21    1.615385\n```", "```\n// Import math functions.\nimport kotlin.math.sin\nimport kotlin.math.asin\nimport kotlin.math.cos\nimport kotlin.math.PI\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.pow\nimport kotlin.math.sqrt\n\n// Define a Location data class.\ndata class Location(\n    val name: String = \"\",\n    var lat: Double,\n    val latDir: String,\n    var lon: Double,\n    val lonDir: String\n)\n\n//  global variables and parameters\n//  N = north, S = south, E = east, W = west\nval L1 = Location(name = \"Big Ben\", lat=51.5004,\n    latDir = \"N\", lon=0.12143, lonDir = \"W\")\nval L2 = Location(name=\"Statue of Liberty\", lat = 40.689978,\n    latDir = \"N\", lon = 74.045448, lonDir = \"W\")\nval locations = listOf(L1, L2)\n\nval R = 6371.009  // radius of Earth in km\n\nfun main() {\n    println(\"\\n*** Measuring Distance Between Two Locations on Earth ***\\n\")\n    printLatLong(category = \"input\", locations)\n    val d = haversineDistance()\n    printLatLong(category = \"adjusted\", locations)\n    println(\"\\nThe distance between the two given locations:\")\n    println(\"d = ${\"%10.2f\".format(d)} km\")\n}\n\nfun printLatLong(category: String, locationsToPrint: List<Location>) {\n    when(category) {\n        \"input\" ->\n            println(\"...inputted coordinates...\\n\")\n        \"adjusted\" ->\n            println(\"\\n...adjusted coordinates...\\n\")\n    }\n    locationsToPrint.forEach {location -> println(location)}\n}\n\nfun haversineDistance(): Double {\n    // Adjust signs based on N-S and E-W directions.\n  ❶ for (location in locations) {\n        with(location) {\n            if(latDir == \"S\" && lat > 0.0) lat = - lat\n            if(lonDir == \"W\" && lon > 0.0) lon = - lon\n        }\n    }\n    // Calculate the angles in radians.\n    val phi1 = L1.lat * PI/180\n    val phi2 = L2.lat * PI/180\n    val delPhi = phi2 - phi1\n    val delLambda = (L2.lon - L1.lon) * PI/180\n\n    // Calculate the distance using haversine formula.\n  ❷ val a = sin(delPhi/2).pow(2) +\n            cos(phi1) * cos(phi2) *\n            sin(delLambda/2).pow(2)\n    // Ensure that 0 <= a <= 1 before calculating c.\n  ❸ val c = 2 * asin(sqrt(max(0.0, min(1.0, a))))\n  ❹ val d = R * c\n    return d\n}\n```", "```\n*** Measuring Distance Between Two Locations on Earth ***\n\n...inputted coordinates...\n\nLocation(name=Big Ben, lat=51.5004, latDir=N, lon=0.12143, lonDir=W)\nLocation(name=Statue of Liberty, lat=40.689978, latDir=N, lon=74.045448,\nlonDir=W)\n\n...adjusted coordinates...\n\nLocation(name=Big Ben, lat=51.5004, latDir=N, lon=-0.12143, lonDir=W)\nLocation(name=Statue of Liberty, lat=40.689978, latDir=N, lon=-74.045448,\nlonDir=W)\n\nThe distance between the two given locations:\nd =   5575.08 km\n```", "```\n/*  --- Hill's method for encrypting and decrypting texts --- */\n\n// Declare the key matrix and its inverse.\n// keyInv is based on mod 29.\nval key = arrayOf(\n intArrayOf(13, 11, 6),\n    intArrayOf(15, 21, 8),\n    intArrayOf(5, 7, 9)\n)\n\nval keyInv = arrayOf(\n    intArrayOf(1, 12, 8),\n    intArrayOf(20, 0, 6),\n    intArrayOf(0, 3, 20)\n)\n\nval dim = key.size\nconst val alphabet = \"abcdefghijklmnopqrstuvwxyz .?\"\n\ndata class Block(\n    val t1: Char,\n    val t2: Char,\n    val t3: Char,\n)\n\nval indexVector = IntArray(dim)\nval processedVector = IntArray(dim)\nval blocks = mutableListOf<Block>()\nval processedText = mutableListOf<Char>()\n```", "```\nfun main() {\n    println(\"\\n*** Cryptography with Hill's Method ***\\n\")\n    runValidation()\n    println(\"\\nEnter 1 for encryption or 2 for decryption:\")\n\n  ❶ when(val choice = readln().toInt()) {\n        1 -> {\n println(\"You have chosen encryption\\n\")\n            getText()\n            encrypt()\n            printProcessedText(choice)\n        }\n        2 -> {\n            println(\"You have chosen decryption\\n\")\n            getText()\n            decrypt()\n            printProcessedText(choice)\n        }\n        else -> println(\"\\nInvalid choice...exiting program\\n\")\n    }\n}\n```", "```\nfun runValidation() {\n    println(\"key matrix dimension:\")\n    println(\"${key.size}  x  ${key[0].size}\\n\")\n\n    // validation of key and keyInv\n    val productMatrix = multiplyMatricesMod29(key, keyInv,\n        r1=dim, c1=dim, c2=dim)\n    displayProduct(productMatrix)\n}\n\nfun multiplyMatricesMod29(firstMatrix: Array <IntArray>,\n                          secondMatrix: Array <IntArray>,\n                          r1: Int,\n                          c1: Int,\n                          c2: Int): Array <IntArray> {\n    val product = Array(r1) {IntArray(c2)}\n    for (i in 0 until r1) {\n        for (j in 0 until c2) {\n for (k in 0 until c1) {\n                product[i][j] += (firstMatrix[i][k] *\n                                  secondMatrix[k][j])\n            }\n          ❶ product[i][j] = product[i][j] % 29\n        }\n    }\n    return product\n}\n\nfun displayProduct(product: Array <IntArray>) {\n    println(\"[key * keyInv] mod 29 =\")\n    for (row in product) {\n        for (column in row) {\n            print(\"$column    \")\n        }\n        println()\n    }\n}\n```", "```\nfun getText() {\n    println(\"Enter text for processing:\")\n    var text = readln().lowercase()\n    val tmp = \" \" // Use a space for padding.\n\n  ❶ when(text.length % 3) {\n        1 -> text = text + tmp + tmp\n        2 -> text += tmp\n    }\n    for (i in text.indices step 3)\n        blocks.add(Block(text[i], text[i+1], text[i+2]))\n}\n```", "```\nfun encrypt() {\n    for (block in blocks) {\n        getIndexBlock(block)\n        encryptIndexBlock()\n        addToProcessedText()\n    }\n}\n\nfun decrypt() {\n    for (block in blocks) {\n        getIndexBlock(block)\n        decryptIndexBlock()\n        addToProcessedText()\n    }\n}\n\nfun getIndexBlock(block: Block) {\n    val (x,y,z) = block\n    indexVector[0] = alphabet.indexOf(x)\n    indexVector[1] = alphabet.indexOf(y)\n    indexVector[2] = alphabet.indexOf(z)\n}\n\nfun encryptIndexBlock() {\n    for (j in 0 until  3) {\n        var sum = 0\n        for (i in 0 until  3) {\n            sum += indexVector[i] * key[i][j]\n        }\n        processedVector[j] = sum % 29\n    }\n}\n\nfun decryptIndexBlock() {\n    for (j in 0 until  3) {\n        var sum = 0\n        for (i in 0 until  3) {\n            sum += indexVector[i] * keyInv[i][j]\n        }\n        processedVector[j] = sum % 29\n    }\n}\n\nfun addToProcessedText() {\n    processedVector.forEach {i ->\n        processedText += alphabet[i]\n    }\n}\n\nfun printProcessedText(choice: Int) {\n    when(choice) {\n        1 -> println(\"\\nHere is the encrypted text:\")\n        2 -> println(\"\\nHere is the decrypted text:\")\n    }\n    print(processedText.joinToString(\"\"))\n}\n```", "```\n*** Cryptography with Hill's Method ***\n\nkey matrix dimension:\n3  x  3\n\n[key * keyInv] mod 29 =\n1    0    0\n0    1    0\n0    0    1\n\nEnter 1 for encryption or 2 for decryption:\n**1**\nYou have chosen encryption\n\nEnter text for processing:\n**Code is like humor. It is bad code when you have to explain it.**\n\nHere is the encrypted text:\ntsgsiomjjnhtvwpqxs.ahk?ru gbn tsgbtynurosksdoqfb a?ujsmtexvjcji\n```", "```\n// import block\nimport javafx.application.Application\nimport javafx.scene.Node\nimport javafx.scene.Scene\nimport javafx.scene.chart.LineChart\nimport javafx.scene.chart.NumberAxis\nimport javafx.scene.chart.XYChart\nimport javafx.scene.control.ScrollPane\nimport javafx.scene.layout.Background\nimport javafx.scene.layout.BackgroundFill\nimport javafx.scene.layout.CornerRadii\nimport javafx.geometry.Insets\nimport javafx.scene.layout.VBox\nimport javafx.scene.paint.Color\nimport javafx.stage.Stage\nimport kotlin.math.sqrt\n\n// data class\n❶ data class State(\n    var step: Double,\n    var dist: Double\n)\n\n// global parameters\nval numStep = 1000\nval numSim = 500\n\n❷ // Create lists needed for plotting line charts.\nval xList  : List<State> = List(numStep) {State(0.0, 0.0)}\nval avgList: List<State> = List(numStep) {State(0.0, 0.0)}\nval rmsList: List<State> = List(numStep) {State(0.0, 0.0)}\nval expList: List<State> = List(numStep) {State(0.0, 0.0)}\n\nval states1 = mutableListOf<List<State>>()\nval states2 = mutableListOf<List<State>>()\n\nclass RandomWalk1D : Application() {\n    override fun start(primaryStage: Stage) {\n      ❸ val root = VBox()\n        /*------------------------------------------*/\n      ❹ root.styleClass.add(\"color-palette\")\n        root.background = Background(BackgroundFill(Color.WHITE,\n             CornerRadii.EMPTY, Insets.EMPTY))\n        /*------------------------------------------*/\n      ❺ val scroll = ScrollPane()\n        scroll.setContent = root\n        val scene = Scene(scroll, 550.0, 850.0, Color.WHITE)\n        primaryStage.title = \"1D random Walk Simulation\"\n        primaryStage.scene = scene\n        primaryStage.show()\n\n        // ----- Random walk simulation starts here. -----\n        // Call random walk function.\n        randomWalk1d()\n        // Get the theoretical RMS values.\n        calcRMS1d()\n        // Create line charts.\n        createRWChart1(root)\n        createRWChart2(root)\n    }\n}\n\nfun main() {\n    Application.launch(RandomWalk1D::class.java)\n}\n```", "```\nfun randomWalk1d() {\n    // Create local arrays.\n  ❶ val s = Array (numSim) {DoubleArray(numStep)}\n    val sumX = DoubleArray(numStep)\n    val sumX2 = DoubleArray(numStep)\n\n    // Walk numStep steps numSim times.\n    for (i in 0 until numSim) {\n        var draw: Int\n        var step: Int\n for (j in 1 until numStep) {\n          ❷ draw = (0..1).random()\n            step = if (draw == 0) -1 else 1\n          ❸ s[i][j] = s[i][j-1] + step\n            sumX[j] += s[i][j]\n            sumX2[j] += (s[i][j] * s[i][j])\n            xList[j].step = j.toDouble()\n            xList[j].dist = s[i][j]\n        }\n      ❹ states1.add(xList.map {it.copy()})\n    }\n\n    // Create average (mean) and RMS for distances traveled.\n    for (j in 0 until numStep) {\n        avgList[j].step = j.toDouble()\n        avgList[j].dist = sumX[j] / numSim\n        rmsList[j].step = j.toDouble()\n        rmsList[j].dist = sqrt(sumX2[j] / numSim)\n    }\n  ❺ states2.addAll(listOf(avgList, rmsList))\n}\n```", "```\nfun calcRMS1d() {\n    // Create the theoretical (exponential) rms/list.\n for (j in 0 until numStep) {\n        expList[j].step = j.toDouble()\n      ❶ expList[j].dist = sqrt(j.toDouble())\n    }\n    states2.add(expList)\n}\n```", "```\nfun createRWChart1(root: VBox) {\n    val xyChart1 =\n        singleXYChart(states1,\n            title = \"Random Walk 1D Experiment\",\n            xLabel = \"Steps\",\n            yLabel = \"Cumulative distance traveled\")\n    root.children.add(xyChart1)\n}\n\nfun createRWChart2(root: VBox) {\n    val xyChart2 =\n        singleXYChart(states2,\n            title = \"Random Walk 1D Experiment\",\n            xLabel = \"Steps\",\n            yLabel = \"Mean and RMS distance traveled\")\n    root.children.add(xyChart2)\n}\n```"]