<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<span aria-label="143" epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/>
<hgroup>
<h2 class="CHAPTER" id="ch8">
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">8</span></span>
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">SOPHISTICATED ARRAYS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="380" src="../images/opener.jpg" width="380"/>
</figure>
<p class="INTRO">In this chapter, we’ll take a more sophisticated approach to PHP arrays and explore how to manually assign an array’s keys. This opens up the possibility of using meaningful strings as keys instead of PHP’s default behavior of using sequential integers. We’ll also discuss multidimensional arrays, where the value of an array element is itself another array, and we’ll look at more functions and operators for working with arrays. With this expanded look at PHP arrays, you’ll begin to see how they can store and manipulate more complex data structures.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="144" epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/>
<h3 class="H1" id="sec1"><span id="toc-link_118"/><span class="SANS_Futura_Std_Bold_B_11">Declaring Array Keys Explicitly</span></h3>
<p class="TNI1">We’ve discussed how PHP will automatically assign sequential integer keys to array elements, starting from 0, in which case the resulting array will meet the definition of a <i>list</i>. Rather than relying on this default behavior, however, you can use the double-arrow operator (<span class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</span>) when declaring an array to explicitly map a key to each value. Then you aren’t obligated to follow the default pattern for keys. For example, you can use nonsequential integers as keys, or start counting from a number other than 0. Either way, the resulting array will no longer be considered a list, but it will be a valid array nonetheless. To illustrate, <a href="#lis8-1">Listing 8-1</a> shows a script that explicitly uses nonsequential integer keys in an array.</p>
<span id="lis8-1"/>
<pre><code>&lt;?php&#13;
$rainfallValues = [&#13;
    0 =&gt; 10,&#13;
    4 =&gt; 8,&#13;
    3 =&gt; 12&#13;
];&#13;
&#13;
print "-- Monthly rainfall --\n";&#13;
foreach ($rainfallValues as $key =&gt; $rainfallValue) {&#13;
    print "$key: $rainfallValue\n";&#13;
}&#13;
&#13;
var_dump(array_is_list($rainfallValues));</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-1: Explicitly declaring integer array keys out of sequence</span></p>
<p class="TX">Here we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">$rainfallValues</span> array. Inside the square brackets of the array, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</span> operator to explicitly assign a key to each array element. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">0 =&gt; 10</span> adds an element to the array with a value of <span class="SANS_TheSansMonoCd_W5Regular_11">10</span> and a key of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. The key/value pairs are separated by commas, just as we separated the array values by commas in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> when we weren’t explicitly declaring the keys. In this case, we’ve also placed each key/value pair on its own indented line, for clarity. With the array declared, the script continues by looping through it and printing its key/value pairs.</p>
<p class="TX">Notice that the array keys we’ve declared aren’t sequential. The second array element has a key of <span class="SANS_TheSansMonoCd_W5Regular_11">4</span>, and the third element has a key of <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. This may not be the most intuitive scheme for assigning keys, but if that’s what we want, PHP is perfectly fine with it. The array won’t meet the definition of a list (so the call to <span class="SANS_TheSansMonoCd_W5Regular_11">array_is_list()</span> at the end of the script should return <span class="SANS_TheSansMonoCd_W5Regular_11">false</span>), but the array is still valid. Here’s the output of running the script:</p>
<pre><code>-- Monthly rainfall --&#13;
0: 10&#13;
4: 8&#13;
3: 12&#13;
bool(false)</code></pre>
<p class="TX"><span aria-label="145" epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop works even though the array isn’t a proper list, iterating through the array’s key/value pairs and printing them out. Notice that the element with key <span class="SANS_TheSansMonoCd_W5Regular_11">4</span> prints before key <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. What matters is the order in which the elements are <i>declared</i>, not the numerical order of the keys themselves. The <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> at the end of the output confirms that the array no longer meets the requirements of a list.</p>
<p class="TX">Once you start explicitly declaring keys, you don’t necessarily have to declare one for <i>every</i> array element. If an element is declared without a key, PHP will automatically look for the most recent integer key, increment it, and use that as the new key. This can be useful if you want an array to have sequential keys that don’t start from <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>.</p>
<p class="TX">For example, say you have a class of students and want an array mapping the students’ IDs to their grades. Each ID is a seven-digit number, beginning with the year and followed by three digits that increment sequentially. In 2025, for instance, the first student would have a numeric ID of <span class="SANS_TheSansMonoCd_W5Regular_11">2025001</span>, the next <span class="SANS_TheSansMonoCd_W5Regular_11">2025002</span>, and so on. In this case, you can explicitly declare just the first array key and let PHP automatically assign the rest. <a href="#lis8-2">Listing 8-2</a> shows how.</p>
<span id="lis8-2"/>
<pre><code>&lt;?php&#13;
$studentGrades = [&#13;
    2025001 =&gt; 'A',&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> 'B',&#13;
    'A',&#13;
    'D',&#13;
    'F'&#13;
];&#13;
&#13;
print "-- Student grades--\n";&#13;
foreach ($studentGrades as $studentId =&gt; $grade) {&#13;
    print "$studentId =&gt; $grade\n";&#13;
}&#13;
&#13;
var_dump(array_is_list($studentGrades));</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-2: Declaring the first array key explicitly and the rest automatically</span></p>
<p class="TX">Within the <span class="SANS_TheSansMonoCd_W5Regular_11">$studentGrades</span> array, we explicitly give the first element a key of <span class="SANS_TheSansMonoCd_W5Regular_11">2025001</span>. Then, beginning with the second element <span aria-label="annotation1" class="CodeAnnotation">❶</span>, we supply only the values. By default, PHP will map these values to the integer keys <span class="SANS_TheSansMonoCd_W5Regular_11">2025002</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">2025003</span>, and so on. As before, we finish the script by looping through and printing the key/value pairs and testing whether the array counts as a list. The output is shown here:</p>
<pre><code>-- Student grades--&#13;
2025001 =&gt; A&#13;
2025002 =&gt; B&#13;
2025003 =&gt; A&#13;
2025004 =&gt; D&#13;
2025005 =&gt; F&#13;
bool(false)</code></pre>
<p class="TX"><span aria-label="146" epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/>Notice that PHP has assigned the remaining keys sequentially, incrementing from the explicitly declared key of <span class="SANS_TheSansMonoCd_W5Regular_11">2025001</span>. However, even though the keys are sequential, they don’t start from 0. Therefore, the array isn’t a list, as the <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> at the end of the output confirms.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="toc-link_119"/><span class="SANS_Futura_Std_Bold_B_11">Arrays with Strings as Keys</span></h3>
<p class="TNI1">Let’s take our coding a step further: now that we’re assigning array keys explicitly, who’s to say they have to be integers? They can just as easily be strings, in which case each value in the array can be given a meaningful name as a key. Returning to the <span class="SANS_TheSansMonoCd_W5Regular_11">$rainfallValues</span> array from <a href="#lis8-1">Listing 8-1</a>, for example, we can use month names as keys instead of integers. This change will better indicate that each value in the array is a monthly rainfall total. <a href="#lis8-3">Listing 8-3</a> revises the script accordingly.</p>
<span id="lis8-3"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$rainfallValues = [</span>&#13;
    'jan' =&gt; 10,&#13;
    'feb' =&gt; 8,&#13;
    'march' =&gt; 12&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">];</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print "-- Monthly rainfall --\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">foreach ($rainfallValues as $key =&gt; $rainfallValue) {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    print "$key: $rainfallValue\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">var_dump(array_is_list($rainfallValues));</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-3: Using strings as array keys</span></p>
<p class="TX">This time we’ve assigned the key <span class="SANS_TheSansMonoCd_W5Regular_11">'jan'</span> to the value <span class="SANS_TheSansMonoCd_W5Regular_11">10</span>, the key <span class="SANS_TheSansMonoCd_W5Regular_11">'feb'</span> to the value <span class="SANS_TheSansMonoCd_W5Regular_11">8</span>, and the key <span class="SANS_TheSansMonoCd_W5Regular_11">'march'</span> to the value <span class="SANS_TheSansMonoCd_W5Regular_11">12</span>. We use the same <span class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</span> operator as before to pair keys with values. The only difference is that the keys are now strings. Here’s the script’s output:</p>
<pre><code>-- Monthly rainfall --&#13;
jan: 10&#13;
feb: 8&#13;
march: 12&#13;
bool(false)</code></pre>
<p class="BodyContinued">The string keys clarify what the values actually represent. The <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> at the end of the output shows that this array isn’t a list. This isn’t surprising, since the keys aren’t even integers.</p>
<p class="TX">Accessing individual values from an array with string keys works just like accessing values from arrays with integer keys: provide the key in square brackets, after the array name. For example, here’s how to print the rainfall value for the month of March:</p>
<pre><code>print $rainfallValues['march'];</code></pre>
<p class="TX"><span aria-label="147" epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/>Similarly, you can also use square-bracket notation to add or update array elements with string keys. Here we add a new rainfall total for April:</p>
<pre><code>$rainfallValues['april'] = 14;</code></pre>
<p class="TX">This is a simple example, but hopefully you can begin to see the potential power of PHP arrays to build meaningful collections of data. When you don’t need the full range of features of object-oriented programming (discussed in <span class="Xref"><a href="part5.xhtml">Part V</a></span>), using arrays with string keys allows you to work with data whose values are naturally associated with keys that make sense for the task (such as dates or months, people’s names or IDs, or product names or codes).</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="H1" id="sec3"><span id="toc-link_120"/><span class="SANS_Futura_Std_Bold_B_11">Multidimensional Arrays</span></h3>
<p class="TNI1">Up to now, the arrays we’ve been exploring have been <i>single-dimensional</i>: they contain a sequence of elements, and each element is a scalar (single) value mapped to a key. However, you can also declare arrays containing elements that are arrays themselves, resulting in a <i>multidimensional array</i>. For example, say you want to create an array of tasks and the time each task will take in minutes. Each element in the array could itself be an array holding the name of a task and its associated duration, as shown here:</p>
<pre><code>$tasksAndMinutes = [&#13;
    ['shopping', 30],&#13;
    ['gym', 60],&#13;
    ['nap', 15]&#13;
];</code></pre>
<p class="TX">Here <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span> is a multidimensional array. Its first element, <span class="SANS_TheSansMonoCd_W5Regular_11">['shopping', 30]</span>, is a two-element array holding a string task name and the integer number of minutes to allocate for that task. The other array elements follow this same format. With a multidimensional array like this, we refer to the overall <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span> as the <i>outer</i> array and its elements as the <i>inner</i> arrays.</p>
<p class="TX">One way to work with a multidimensional array is to use a nested set of <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loops, one to iterate over the elements of the outer array and the other to iterate over the elements of each inner array. In the <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span> array, however, all the inner arrays have the same structure (which won’t always be a given). Therefore, in cases like these, you can use your knowledge of that structure to extract the values from each inner array by using a single <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop that iterates over the outer array. <a href="#lis8-4">Listing 8-4</a> illustrates this approach.</p>
<span id="lis8-4"/>
<pre><code>&lt;?php&#13;
$tasksAndMinutes = [&#13;
    ['shopping', 30],&#13;
    ['gym', 60],&#13;
    ['nap', 15]&#13;
];&#13;
&#13;
<span aria-label="148" epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/>foreach ($tasksAndMinutes as $item) {&#13;
    $task = $item[0];&#13;
    $minutes = $item[1];&#13;
    print "allow $minutes minutes today for task: $task\n";&#13;
}</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-4: Working with a multidimensional array</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span> array as shown previously. Next, we declare a <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop that iterates through the elements of <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span>, using the <span class="SANS_TheSansMonoCd_W5Regular_11">$item</span> variable to represent the current element. As we’ve seen, each element is itself an array containing a task name and a time in minutes. We can therefore extract the first element of <span class="SANS_TheSansMonoCd_W5Regular_11">$item</span> (using integer index <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) into the <span class="SANS_TheSansMonoCd_W5Regular_11">$task</span> variable and the second element (index <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>) into <span class="SANS_TheSansMonoCd_W5Regular_11">$minutes</span>. Then we print a message about the current task by using these two variables, producing the following output:</p>
<pre><code>allow 30 minutes today for task: shopping&#13;
allow 60 minutes today for task: gym&#13;
allow 15 minutes today for task: nap</code></pre>
<p class="BodyContinued">The times and task names have successfully been extracted from each inner array during the <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop.</p>
<p class="TX">In this example, the inner arrays use integer keys by default, but as you know, arrays can also use non-numeric keys. Pairing the values in each inner array with meaningful string keys like <span class="SANS_TheSansMonoCd_W5Regular_11">'task'</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">'minutes'</span> will make the code much more readable. For example, we’ll be able to access the task from the current element of <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">$task = $item['task']</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">$task = $item[0]</span>. <a href="#lis8-5">Listing 8-5</a> shows this improvement.</p>
<span id="lis8-5"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$tasksAndMinutes = [</span>&#13;
    ['task' =&gt; 'shopping', 'minutes' =&gt; 30],&#13;
    ['task' =&gt; 'gym', 'minutes' =&gt; 60],&#13;
    ['task' =&gt; 'nap', 'minutes' =&gt; 15],&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">];</span>&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">foreach ($tasksAndMinutes as $item) {</span>&#13;
    $task = $item['task'];&#13;
    $minutes = $item['minutes'];&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    print "allow $minutes minutes today for task: $task\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-5: Refactoring <a href="#lis8-4">Listing 8-4</a> to use string keys in the inner arrays</span></p>
<p class="TX">This time we explicitly assign the string keys <span class="SANS_TheSansMonoCd_W5Regular_11">'task'</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">'minutes'</span> to the values in each of the arrays inside <span class="SANS_TheSansMonoCd_W5Regular_11">$tasksAndMinutes</span>. Then we use those meaningful keys inside the <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop to extract the values from the current inner array being processed. The result is exactly the same as before, but the code is easier to read. Before PHP allowed for object-oriented programming, well-labeled multidimensional arrays like this were an integral part of the code for the data-related features of many programs.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<span aria-label="149" epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>
<h3 class="H1" id="sec4"><span id="toc-link_121"/><span class="SANS_Futura_Std_Bold_B_11">More Array Operations</span></h3>
<p class="TNI1">In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a>,</span> we discussed array operations such as adding an element to and removing an element from the end of a simple array. Now that we’ve explored sophisticated arrays, let’s consider more array operations. We’ll look at how to remove an element from anywhere in an array, how to use array operators like union (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span>) and spread (<span class="SANS_TheSansMonoCd_W5Regular_11">...</span>), and how to extract the elements of an array into separate variables.</p>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="toc-link_122"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Removing Any Element from an Array</span></h4>
<p class="TNI1">You can remove an element from an array by passing the element’s key to the <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> function. Unlike the <span class="SANS_TheSansMonoCd_W5Regular_11">array_pop()</span> function covered in the previous chapter, which specifically removes the <i>last</i> element in an array, <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> can remove an element from <i>any</i> position. Also unlike <span class="SANS_TheSansMonoCd_W5Regular_11">array_pop()</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> function doesn’t return the deleted element; it’s simply gone.</p>
<p class="TX">Using <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> becomes more appropriate when you start assigning strings rather than integers as array keys. With string keys, the order of the array elements often loses its significance, so it’s more meaningful to remove an element based on its key rather than its position in the array. <a href="#lis8-6">Listing 8-6</a> revisits the <span class="SANS_TheSansMonoCd_W5Regular_11">$rainfallValues</span> array as an example.</p>
<span id="lis8-6"/>
<pre><code><span class="TheSansMonoCd_W5Regular_Grey_11">&lt;?php</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">$rainfallValues = [</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    'jan' =&gt; 10,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    'feb' =&gt; 8,</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    'march' =&gt; 12</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">];</span>&#13;
&#13;
unset($rainfallValues['feb']);&#13;
&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">print "-- Monthly rainfall --\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">foreach ($rainfallValues as $key =&gt; $rainfallValue) {</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">    print "$key: $rainfallValue\n";</span>&#13;
<span class="TheSansMonoCd_W5Regular_Grey_11">}</span></code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-6: Using</span> <span class="TheSansMonoCd_W5Regular_Italic_11">unset()</span> <span class="SANS_Futura_Std_Book_Oblique_11">to remove an element from an array</span></p>
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">unset()</span> to remove the element with the <span class="SANS_TheSansMonoCd_W5Regular_11">'feb'</span> key from the <span class="SANS_TheSansMonoCd_W5Regular_11">$rainfallValues</span> array. Then we loop through the array to print details for the remaining elements as before. Here’s the result:</p>
<pre><code>-- Monthly rainfall --&#13;
jan: 10&#13;
march: 12</code></pre>
<p class="BodyContinued">Notice that no data is printed for an element with the key <span class="SANS_TheSansMonoCd_W5Regular_11">'feb'</span>, since that element no longer exists within the array.</p>
<blockquote>
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>
</blockquote>
<p class="NOTE-TXT"><i>Calling</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">unset()</span> <i>on a whole array, such as</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">unset($rainfallValues)</span><i>, would delete the entire array, just as calling</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">unset()</span> <i>on any other variable would clear that variable.</i></p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="150" epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/>
<h4 class="H2" id="sec6"><span id="toc-link_123"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Combining and Comparing Arrays</span></h4>
<p class="TNI1">You can combine or compare arrays by using some of the same addition, equality, and identity operators that apply to scalar (single-value) variables. <a href="#tab8-1">Table 8-1</a> summarizes the six array operators available.</p>
<p class="TT"><a id="tab8-1"/><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 8-1:</span></span> <span class="SANS_Futura_Std_Book_11">Array Operators</span></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Name</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Symbol</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Example</span></p></th>
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Union</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">+</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">$a + $b</span></p></td>
<td class="TBF"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Returns an array with the elements of arrays</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$a</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$b</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Spread</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">...</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">[1, ...$a]</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Returns an array that has</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> <span class="SANS_Futura_Std_Book_11">as the first element, followed by the elements of array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$a</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Equal</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">==</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">$a == $b</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Returns</span> <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span class="SANS_Futura_Std_Book_11">if arrays</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$a</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$b</span> <span class="SANS_Futura_Std_Book_11">have the same key/value pairs.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Identical</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">===</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$a === $b</span></p></td>
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Returns</span> <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span class="SANS_Futura_Std_Book_11">if arrays</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$a</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$b</span> <span class="SANS_Futura_Std_Book_11">are identical: they have the same key/value pairs, and their elements are in the same order and of the same types.</span></p></td>
</tr>
<tr>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Not equal</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">!=</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&gt;</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">$a != $b</span></p>
<p class="TB_Grey"><span class="SANS_TheSansMonoCd_W5Regular_11">$a &lt;&gt; $b</span></p></td>
<td class="TB"><p class="TB_Grey"><span class="SANS_Futura_Std_Book_11">Returns</span> <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span class="SANS_Futura_Std_Book_11">if arrays</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$a</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$b</span> <span class="SANS_Futura_Std_Book_11">do</span> <span class="SANS_Futura_Std_Book_Oblique_11">not</span> <span class="SANS_Futura_Std_Book_11">have the same key/value pairs.</span></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not identical</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">!==</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">$a !== $b</span></p></td>
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Returns</span> <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> <span class="SANS_Futura_Std_Book_11">if array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$a</span> <span class="SANS_Futura_Std_Book_11">is</span> <span class="SANS_Futura_Std_Book_Oblique_11">not</span> <span class="SANS_Futura_Std_Book_11">identical to array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">$b</span><span class="SANS_Futura_Std_Book_11">.</span></p></td>
</tr>
</tbody>
</table>
<p class="TX"><a href="#lis8-7">Listing 8-7</a> shows some of these operators in action.</p>
<span id="lis8-7"/>
<pre><code>&lt;?php&#13;
$cars1 = ['audi' =&gt; 'silver', 'bmw' =&gt; 'black'];&#13;
$cars2 = ['audi' =&gt; 'white', 'ferrari' =&gt; 'red'];&#13;
$names1 = ['matt' =&gt; 'smith', 'joelle' =&gt; 'murphy'];&#13;
$names2 = ['joelle' =&gt; 'murphy', 'matt' =&gt; 'smith',];&#13;
&#13;
print_r($cars1 + $cars2);&#13;
var_dump($names1 == $names2);&#13;
var_dump($names1 === $names2);&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> print_r(['rolls royce' =&gt; 'yellow', ...$cars1, ...$names1]);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-7: Using array operators</span></p>
<p class="TX">First, we declare some example arrays to work with: <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$cars2</span> have car makes as keys and car colors as values, while <span class="SANS_TheSansMonoCd_W5Regular_11">$names1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$names2</span> have first names as keys and last names as values. (Notice that <span class="SANS_TheSansMonoCd_W5Regular_11">$names1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$names2</span> have the same elements, but in the opposite order.)</p>
<p class="TX">Then we apply operators to these arrays and print the results. We use the union (<span class="SANS_TheSansMonoCd_W5Regular_11">+</span>) operator to combine <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$cars2</span>, and we test the equal (<span class="SANS_TheSansMonoCd_W5Regular_11">==</span>) and identical (<span class="SANS_TheSansMonoCd_W5Regular_11">===</span>) operators on <span class="SANS_TheSansMonoCd_W5Regular_11">$names1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$names2</span>. We also use the array spread operator (<span class="SANS_TheSansMonoCd_W5Regular_11">...</span>) to create a new array with a key of <span class="SANS_TheSansMonoCd_W5Regular_11">'rolls royce'</span> mapped to a value of <span class="SANS_TheSansMonoCd_W5Regular_11">'yellow'</span>, as well as all the elements of the <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$names1</span> arrays <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Notice that we use <span class="SANS_TheSansMonoCd_W5Regular_11">print_r()</span> to show the results of the <span aria-label="151" epub:type="pagebreak" id="pg_151" role="doc-pagebreak"/>operations that return arrays; this function displays arrays more succinctly than <span class="SANS_TheSansMonoCd_W5Regular_11">var_dump()</span>. Running the script results in this output:</p>
<pre><code><span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> Array&#13;
(&#13;
    [audi] =&gt; silver&#13;
    [bmw] =&gt; black&#13;
    [ferrari] =&gt; red&#13;
)&#13;
<span aria-label="annotation2" class="codeannotated_CodeAnnotation">❷</span> bool(true)&#13;
bool(false)&#13;
<span aria-label="annotation3" class="codeannotated_CodeAnnotation">❸</span> Array&#13;
(&#13;
    [rolls royce] =&gt; yellow&#13;
    [audi] =&gt; silver&#13;
    [bmw] =&gt; black&#13;
    [matt] =&gt; smith&#13;
    [joelle] =&gt; murphy&#13;
)</code></pre>
<p class="TX">The first part of the output shows the result of <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1 + $cars2</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Both arrays of cars have an element with a key of <span class="SANS_TheSansMonoCd_W5Regular_11">'audi'</span>, but an array can’t have two identical keys. As such, the union operator takes the <span class="SANS_TheSansMonoCd_W5Regular_11">'audi' =&gt; 'silver'</span> element from <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> but ignores <span class="SANS_TheSansMonoCd_W5Regular_11">'audi' =&gt; 'white'</span> from <span class="SANS_TheSansMonoCd_W5Regular_11">$cars2</span>, resulting in a three-element array. Next, the <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> outputs <span aria-label="annotation2" class="CodeAnnotation">❷</span> indicate that the <span class="SANS_TheSansMonoCd_W5Regular_11">$names1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$names2</span> arrays are <i>equal</i>, since they have the same keys and values, but not <i>identical</i>, since the sequence of elements is different. The final array shows the result of using the spread operator (<span class="SANS_TheSansMonoCd_W5Regular_11">...</span>) <span aria-label="annotation3" class="CodeAnnotation">❸</span>. The new array has a <span class="SANS_TheSansMonoCd_W5Regular_11">'rolls royce'</span> element, followed by the elements from <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$names1</span>.</p>
<p class="TX">It’s worth underscoring what the spread operator (<span class="SANS_TheSansMonoCd_W5Regular_11">...</span>) is doing here: it extracts the elements from one array and inserts them, one at a time, into another array. Without the spread operator, the entire array would be inserted as a single element into the new array, thus creating a multidimensional array, rather than its individual elements being spread into the new array. To illustrate, say we had omitted the spread operator before <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> <span aria-label="annotation1" class="CodeAnnotation">❶</span> in <a href="#lis8-7">Listing 8-7</a>, like this:</p>
<pre><code>print_r(['rolls royce' =&gt; 'yellow', $cars1, ...$names1]);</code></pre>
<p class="BodyContinued">The resulting array would have an element containing the whole <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> array, as shown here:</p>
<pre><code>Array&#13;
(&#13;
    [rolls royce] =&gt; yellow&#13;
    [0] =&gt; Array&#13;
        (&#13;
            [audi] =&gt; silver&#13;
            [bmw] =&gt; black&#13;
        )&#13;
&#13;
<span aria-label="152" epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/>    [matt] =&gt; smith&#13;
    [joelle] =&gt; murphy&#13;
)</code></pre>
<p class="TX">Now the second element in the array, with key <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, is itself an array containing the complete contents of <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span>. This example also illustrates how an array can mix integer keys with non-integer keys. When the whole <span class="SANS_TheSansMonoCd_W5Regular_11">$cars1</span> array is added as an element to the new array, it’s automatically given the first available integer key, <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, since it wasn’t given a key manually. Meanwhile, the other elements in the new array all have explicitly assigned string keys. Arrays with mixed keys like this are rare; usually such an array would indicate something has gone wrong, such as the missing spread operator here.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="toc-link_124"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Destructuring an Array into Multiple Variables</span></h4>
<p class="TNI1">Sometimes it can be useful to extract the values from an array and assign them to separate variables, a process known as <i>destructuring</i>. If you know the number of elements in the array, you can destructure it in a single statement, as shown in <a href="#lis8-8">Listing 8-8</a>.</p>
<span id="lis8-8"/>
<pre><code>&lt;?php&#13;
$rainfallValues = [10, 8, 12];&#13;
&#13;
<span aria-label="annotation1" class="codeannotated_CodeAnnotation">❶</span> [$jan, $feb, $march] = $rainfallValues;&#13;
&#13;
print "-- Monthly rainfall --\n";&#13;
print "Jan: $jan \n";&#13;
print "Feb: $feb \n";&#13;
print "Mar: $march \n";</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-8: Destructuring a three-element array into three separate variables</span></p>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">$rainfallValues</span> array to have three elements. Then we destructure the array into the <span class="SANS_TheSansMonoCd_W5Regular_11">$jan</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$feb</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">$march</span> variables <span aria-label="annotation1" class="CodeAnnotation">❶</span>. For that, we list the target variables inside square brackets on the left of an assignment operator (<span class="SANS_TheSansMonoCd_W5Regular_11">=</span>) and provide the variable containing the whole array on the right. Finally, we print out the values in the three variables, producing the following output:</p>
<pre><code>-- Monthly rainfall --&#13;
Jan: 10&#13;
Feb: 8&#13;
Mar: 12</code></pre>
<p class="BodyContinued">Notice that the values from the array are successfully assigned into, and print out from, the individual <span class="SANS_TheSansMonoCd_W5Regular_11">$jan</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">$feb</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">$march</span> variables.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<span aria-label="153" epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/>
<h3 class="H1" id="sec8"><span id="toc-link_125"/><span class="SANS_Futura_Std_Bold_B_11">Callback Functions and Arrays</span></h3>
<p class="TNI1">A <i>callback function</i>, or simply a <i>callback</i>, is a function that isn’t called directly, but rather is passed as an argument to another function. The other function then calls the callback function for you. PHP has several functions that use callbacks in conjunction with arrays.</p>
<p class="TX">For example, <span class="SANS_TheSansMonoCd_W5Regular_11">array_walk()</span> takes in an array and a callback function as arguments and applies the callback function to each element in the array, transforming the original array in the process. Similarly, <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span> takes in an array and a callback function, applies the callback to each array element, and returns a new array containing the results. Both <span class="SANS_TheSansMonoCd_W5Regular_11">array_walk()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span> are known as <i>higher-order functions</i>, since they take in a function as an argument.</p>
<p class="TX">If you’ve declared a function in a separate file (as previously discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>) or are using one of PHP’s built-in functions, you can use that function as a callback by passing a string containing the function’s name to a higher-order function. For example, say we’ve declared a function called <span class="SANS_TheSansMonoCd_W5Regular_11">my_function()</span> and we want to apply it to every element in <span class="SANS_TheSansMonoCd_W5Regular_11">$my_array</span> by using <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span>. Here’s how to do it:</p>
<pre><code>$my_new_array = array_map('my_function', $my_array);</code></pre>
<p class="TX">We pass the string <span class="SANS_TheSansMonoCd_W5Regular_11">'my_function'</span> (the name of the desired callback) and the array as arguments to <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span>, which will call <span class="SANS_TheSansMonoCd_W5Regular_11">my_function()</span> for each element in the array. The results are returned in a new array, which we store in the <span class="SANS_TheSansMonoCd_W5Regular_11">$my_new_array</span> variable.</p>
<p class="TX">Rather than declare the callback function separately, another common approach is to define an <i>anonymous</i> (unnamed) callback function directly in the argument list for the higher-order function. Before we look at an anonymous function in the context of a higher-order function like <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span>, though, let’s consider an anonymous function by itself to better understand the syntax. Here’s a simple anonymous function that takes in a number and returns double its value:</p>
<pre><code>function (int $n): int {return $n * 2;}</code></pre>
<p class="TX">The function begins with the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword, followed by the function’s signature, <span class="SANS_TheSansMonoCd_W5Regular_11">(int $n): int</span>, which indicates that the function takes a single integer parameter <span class="SANS_TheSansMonoCd_W5Regular_11">$n</span> and returns an integer value. Notice that the function signature doesn’t include a name, since the function is anonymous. After the signature comes the anonymous function’s body, which is enclosed in curly brackets. The body returns twice the value of the provided <span class="SANS_TheSansMonoCd_W5Regular_11">$n</span> argument.</p>
<p class="TX"><span aria-label="154" epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/>Another option is to write the anonymous callback as an <i>arrow function</i>, using a more concise syntax that uses the double-arrow operator (<span class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</span>) to separate the function’s signature and body. This syntax removes the need for the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword, the curly brackets around the body, and the semicolon to end the statement in the body. Here’s the arrow-function version of our doubling operation:</p>
<pre><code>fn (int $n): int =&gt; $n * 2</code></pre>
<p class="TX">Instead of <span class="SANS_TheSansMonoCd_W5Regular_11">function</span>, we now begin with <span class="SANS_TheSansMonoCd_W5Regular_11">fn</span>, a reserved keyword for declaring arrow functions. Then comes the function’s signature as before. Next, we write the double-arrow operator (<span class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</span>), followed by an expression defining the function’s return value (in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">$n * 2</span>). Without the curly brackets, semicolon, and <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword, the arrow function is extremely compact.</p>
<p class="TX">Now let’s try using this arrow function as a callback. <a href="#lis8-9">Listing 8-9</a> shows how to pass the arrow function to <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span> in order to double every value in an array.</p>
<span id="lis8-9"/>
<pre><code>&lt;?php&#13;
$numbers = [10, 20, 30];&#13;
&#13;
$doubleNumbers = array_map(&#13;
  <span aria-label="annotation1" class="Code_CodeAnnotation">❶</span> fn (int $n): int =&gt; $n * 2,&#13;
    $numbers&#13;
);&#13;
&#13;
var_dump($doubleNumbers);</code></pre>
<p class="CodeListingCaption"><span class="SANS_Futura_Std_Book_Oblique_11">Listing 8-9: Passing an arrow callback function to</span> <span class="TheSansMonoCd_W5Regular_Italic_11">array_map()</span></p>
<p class="TX">We declare a <span class="SANS_TheSansMonoCd_W5Regular_11">$numbers</span> array containing <span class="SANS_TheSansMonoCd_W5Regular_11">10</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">20</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">30</span>. We then call the <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span> function. For the first argument, we use arrow-function syntax to declare the doubling callback function we just discussed <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Notice that the arrow function ends with a comma, since it’s part of the list of arguments to <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span>. The second argument is the <span class="SANS_TheSansMonoCd_W5Regular_11">$numbers</span> array. The <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span> function will automatically apply the arrow function to each element in the array and return a new array containing the results. We store that new array in the <span class="SANS_TheSansMonoCd_W5Regular_11">$doubleNumbers</span> variable. Here’s the output of running this script and printing the resulting array:</p>
<pre><code>array(3) {&#13;
    [0]=&gt;&#13;
    int(20)&#13;
    [1]=&gt;&#13;
    int(40)&#13;
    [2]=&gt;&#13;
    int(60)&#13;
}</code></pre>
<p class="TX"><span aria-label="155" epub:type="pagebreak" id="pg_155" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">$doubleNumbers</span> array contains the values <span class="SANS_TheSansMonoCd_W5Regular_11">20</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">40</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">60</span>. This indicates that the <span class="SANS_TheSansMonoCd_W5Regular_11">array_map()</span> function successfully accessed each value in the <span class="SANS_TheSansMonoCd_W5Regular_11">$numbers</span> array and applied the doubling arrow function to it.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="toc-link_126"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>
<p class="TNI1">Arrays are flexible data structures, especially when we begin assigning meaningful string keys to the values of the elements instead of using the default integer keys. In this chapter, you learned how to work with string-keyed arrays. You also saw how to embed arrays inside other arrays to create multidimensional arrays, and how to apply callback functions (written with arrow-function syntax) to every element of an array. Techniques like this are what make the array a sophisticated structure for representing and manipulating complex data.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="H1" id="sec10"><span id="toc-link_127"/><span class="SANS_Futura_Std_Bold_B_11">Exercises</span></h3>
<p class="ListNumber">1.   Use an array with string keys to store the following pairs of names and heights in meters:</p>
<pre><code>Fred      1.82&#13;
Joelle    1.55&#13;
Robin     1.70</code></pre>
<p class="ListBody1">Write a <span class="SANS_TheSansMonoCd_W5Regular_11">foreach</span> loop to iterate through the array elements and print them out.</p>
<p class="ListNumber">2.   Create a multidimensional array to represent the following data about movies:</p>
<pre><code>Back to the Future&#13;
    duration        116&#13;
    leadingActor    Michael J. Fox&#13;
The Fifth Element&#13;
    duration        126&#13;
    leadingActor    Bruce Willis&#13;
Alien&#13;
    duration        117&#13;
    leadingActor    Sigourney Weaver</code></pre>
<p class="ListNumber">3.   Declare one array containing the odd numbers up to nine (1, 3, 5, 7, 9) and another with the even numbers (2, 4, 6, 8). Use the array spread operator (<span class="SANS_TheSansMonoCd_W5Regular_11">...</span>) to combine the two arrays, and then sort them into numerical order with PHP’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">sort()</span> function.</p>
</section>
</section>
</div></body></html>