["```\n          0101\n\n        + 0011\n\n        ------\n\nStep 1: Add the LO bits (1 + 1 = 0 + carry).\n\n            c\n\n          0101\n\n        + 0011\n\n        ------\n\n             0\n\nStep 2: Add the carry plus the bits in bit position 1 (carry + 0 + 1 = 0 + carry).\n\n           c\n\n          0101\n\n        + 0011\n\n        -------\n\n            00\n\nStep 3: Add the carry plus the bits in bit position 2 (carry + 1 + 0 = 0 + carry).\n\n          c\n\n          0101\n\n        + 0011\n\n        ------\n\n           000\n\nStep 4: Add the carry plus the bits in bit position 3 (carry + 0 + 0 = 1).\n\n          0101\n\n        + 0011\n\n        ------\n\n          1000\n```", "```\n  1100_1101       1001_1111       0111_0111\n\n+ 0011_1011     + 0001_0001     + 0000_1001\n\n-----------     -----------     -----------\n\n1_0000_1000       1011_0000       1000_0000\n```", "```\n          0101\n\n        - 0011\n\n        ------\n\nStep 1: Subtract the LO bits (1 – 1 = 0).\n\n          0101\n\n        - 0011\n\n        ------\n\n             0\n\nStep 2: Subtract the bits in bit position 1 (0 – 1 = 1 + borrow).\n\n          0101\n\n        - 0011\n\n           b\n\n        ------\n\n            10\n\nStep 3: Subtract the borrow and the bits in bit position 2 (1 – 0 – b = 0).\n\n          0101\n\n        - 0011\n\n        ------\n\n           010\n\nStep 4: Subtract the bits in bit position 3 (0 – 0 = 0).\n\n          0101\n\n        - 0011\n\n        ------\n\n          0010\n```", "```\n  1100_1101       1001_1111       0111_0111\n\n- 0011_1011     - 0001_0001     - 0000_1001\n\n-----------     -----------     -----------  \n\n  1001_0010       1000_1110       0110_1110\n```", "```\n      1010\n\n   ×  0101\n\n   -------\n\nStep 1: Multiply the LO bit of the multiplier times the multiplicand.\n\n      1010\n\n   ×  0101\n\n   -------\n\n      1010    (1 × 1010)\n\nStep 2: Multiply bit 1 of the multiplier times the multiplicand.\n\n      1010\n\n   ×  0101\n\n   -------\n\n      1010    (1 × 1010)\n\n      0000    (0 × 1010)\n\n   -------\n\n     01010    (partial sum)\n\nStep 3: Multiply bit 2 of the multiplier times the multiplicand.\n\n      1010\n\n   ×  0101\n\n   -------\n\n    001010    (previous partial sum)\n\n    1010      (1 × 1010)\n\n   -------\n\n    110010    (partial sum)\n\nStep 4: Multiply bit 3 of the multiplier times the multiplicand.\n\n      1010\n\n   ×  0101\n\n   -------\n\n    110010    (previous partial sum)\n\n   0000       (0 × 1010)\n\n   -------\n\n   0110010    (product)\n```", "```\nAND:\n\n            0 and 0 = 0\n\n            0 and 1 = 0\n\n            1 and 0 = 0\n\n            1 and 1 = 1\n\nOR:\n\n            0 or 0 = 0\n\n            0 or 1 = 1\n\n            1 or 0 = 1\n\n            1 or 1 = 1\n\nXOR:\n\n            0 xor 0 = 0\n\n            0 xor 1 = 1\n\n            1 xor 0 = 1\n\n            1 xor 1 = 0\n```", "```\n%1011_0101\n\n%1110_1110\n\n-----------\n\n%1010_0100\n```", "```\n// Here's a C/C++ example:\n\n    i = j & k;    // Bitwise AND\n\n    i = j | k;    // Bitwise OR\n\n    i = j ^ k;    // Bitwise XOR\n\n    i = ~j;       // Bitwise NOT\n```", "```\nIsOdd = (ValueToTest & 1) != 0;\n```", "```\nxxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx  // Assuming ValueToTest is 32 bits\n\n0000_0000_0000_0000_0000_0000_0000_0001  // Bitwise AND with the value 1\n\n---------------------------------------\n\n0000_0000_0000_0000_0000_0000_0000_000x  // Result of bitwise AND\n```", "```\nIsDivisibleBy16 := (ValueToTest and $f) = 0;\n```", "```\nxxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx  // Assuming ValueToTest is 32 bits\n\n0000_0000_0000_0000_0000_0000_0000_1111  // Bitwise AND with $F\n\n---------------------------------------\n\n0000_0000_0000_0000_0000_0000_0000_xxxx  // Result of bitwise AND\n```", "```\n%1xxxxxx0xxxxxxx1xxxxx0xxxxxxxx10\n\n%1xxxxxx0xxxxxxx1xxxxx0xxxxxxxx10\n\n%1xxxxxx1xxxxxxx1xxxxx1xxxxxxxx11\n```", "```\n// C/C++ example\n\n    if( (value1 & 0x81010403) == (value2 & 0x81010403))\n\n    {\n\n        // Do something if bits 31, 24, 16, 10, 1, and 0 of\n\n        // value1 and value2 are equal\n\n    }\n\n    if( (value1 & 0x81010403) != (value3 & 0x81010403))\n\n    {\n\n        // Do something if bits 31, 24, 16, 10, 1, and 0 of\n\n        // value1 and value3 are not equal\n\n    }\n\n// HLA/x86 assembly example:\n\n    mov( value1, eax );        // EAX = value1\n\n    and( $8101_0403, eax );   // Mask out unwanted bits in EAX\n\n    mov( value2, edx );        // EDX = value2\n\n    and( $8101_0403, edx );   // Mask out the same set of unwanted bits in EDX\n\n    if( eax = edx ) then      // See if the remaining bits match\n\n        // Do something if bits 31, 24, 16, 10, 1, and 0 of\n\n        // value1 and value2 are equal\n\n    endif;\n\n    mov( value1, eax );       // EAX = value1\n\n    and( $8101_0403, eax );  // Mask out unwanted bits in EAX\n\n    mov( value3, edx );       // EDX = value2\n\n    and( $8101_0403, edx );  // Mask out the same set of unwanted bits in EDX\n\n    if( eax <> edx ) then    // See if the remaining bits do not match\n\n        // Do something if bits 31, 24, 16, 10, 1, and 0 of\n\n        // value1 and value3 are not equal\n\n    endif;\n```", "```\ncntr = (cntr + 1 ) % n;    // C/C++/Java/Swift\n\ncntr := (cntr + 1) mod n;  // Pascal/Delphi\n\ncntr = (cntr + 1) Mod n     ' Visual Basic\n```", "```\ncntr := cntr + 1;      // Pascal example\n\nif( cntr >= n ) then\n\n    cntr := 0;\n```", "```\n//Note: 0x1f = 31 = 25 – 1, so n = 32 and m = 5\n\n    cntr = (cntr + 1) & 0x1f;    // C/C++/Java/Swift example\n\n    cntr := (cntr + 1) and $1f;  // Pascal/Delphi example\n\n    cntr = (cntr + 1) and &h1f    ' Visual Basic example\n```", "```\ninc( eax );                      // Compute (eax + 1) mod 32\n\nand( $1f, eax );\n```", "```\n// C:\n\n        cLang = d << 1;     // Assigns d shifted left one position to\n\n                            // variable \"cLang\"\n\n// Delphi:\n\n        Delphi := d shl 1;  // Assigns d shifted left one position to\n\n                            // variable \"Delphi\"\n```", "```\nvb = d * 2\n```", "```\n// Written in C/C++, assuming 32-bit integers, logical shift right:\n\n    // Compute bit 30.\n\n    Bit30 = ((ShiftThisValue & 0x80000000) != 0) ? 0x40000000 : 0;\n\n    // Shifts bits 0..30.\n\n    ShiftThisValue = (ShiftThisValue & 0x7fffffff) >> 1;\n\n    // Merge in Bit #30.\n\n    ShiftThisValue = ShiftThisValue | Bit30; \n\n// Arithmetic shift right operation\n\n    Bits3031 = ((ShiftThisValue & 0x80000000) != 0) ? 0xC0000000 : 0;\n\n    // Shifts bits 0..30.\n\n    ShiftThisValue = (ShiftThisValue & 0x7fffffff) >> 1;\n\n    // Merge bits 30/31.\n\n    ShiftThisValue = ShiftThisValue | Bits3031;\n```", "```\n// Pascal/Delphi Rotate Left, 32-bit example:\n\n// Puts bit 31 into bit 0, clears other bits.\n\nCarryOut := (ValueToRotate shr 31); \n\nValueToRotate := (ValueToRotate shl 1) or CarryOut;\n```", "```\n0100    00010    0000001    = %0100_0001_0000_0001 or $4101\n\n 04      02       01\n```", "```\nprogram dateDemo;\n\n#include( \"stdlib.hhf\" )\n\nstatic\n\n    day:        uns8;\n\n    month:      uns8;\n\n    year:       uns8;\n\n    packedDate: word;\n\nbegin dateDemo;\n\n    stdout.put( \"Enter the current month, day, and year: \" );\n\n    stdin.get( month, day, year );\n\n    // Pack the data into the following bits:\n\n    //\n\n    //  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n\n    //   m  m  m  m  d  d  d  d  d  y  y  y  y  y  y  y\n\n    mov( 0, ax );\n\n    mov( ax, packedDate );  // Just in case there is an error.\n\n    if( month > 12 ) then \n\n        stdout.put( \"Month value is too large\", nl );\n\n    elseif( month = 0 ) then \n\n        stdout.put( \"Month value must be in the range 1..12\", nl );\n\n    elseif( day > 31 ) then \n\n        stdout.put( \"Day value is too large\", nl );\n\n    elseif( day = 0 ) then \n\n        stdout.put( \"Day value must be in the range 1..31\", nl );\n\n    elseif( year > 99 ) then \n\n        stdout.put( \"Year value must be in the range 0..99\", nl );\n\n    else\n\n        mov( month, al );\n\n        shl( 5, ax );\n\n        or( day, al );\n\n        shl( 7, ax );\n\n        or( year, al );\n\n        mov( ax, packedDate );\n\n    endif;\n\n    // Okay, display the packed value:\n\n    stdout.put( \"Packed data = $\", packedDate, nl );\n\n    // Unpack the date:\n\n    mov( packedDate, ax );\n\n    and( $7f, al );         // Retrieve the year value.\n\n    mov( al, year );\n\n    mov( packedDate, ax );  // Retrieve the day value.\n\n    shr( 7, ax );\n\n    and( %1_1111, al );\n\n    mov( al, day );\n\n    mov( packedDate, ax );  // Retrieve the month value.\n\n    rol( 4, ax );\n\n    and( %1111, al );\n\n    mov( al, month );\n\n    stdout.put( \"The date is \", month, \"/\", day, \"/\", year, nl ); \n\nend dateDemo;\n```", "```\nmov( Date1, eax );        // Assume Date1 and Date2 are double-word variables\n\nif( eax > Date2 ) then    // using the long packed date format.\n\n    << do something if Date1 > Date2 >>\n\nendif;\n```", "```\nstruct\n\n{\n\n    unsigned bits0_3   :4;\n\n    unsigned bits4_11  :8;\n\n    unsigned bits12_15 :4;\n\n    unsigned bits16_23 :8;\n\n    unsigned bits24_31 :8;\n\n} packedData;\n```", "```\nstruct\n\n{\n\n    unsigned year  :7;\n\n    unsigned month :4;\n\n    unsigned day   :5;\n\n} ShortDate;\n\n        . . .\n\n    ShortDate.day = 28;\n\n    ShortDate.month = 2;\n\n    ShortDate.year = 3;  // 2003\n```", "```\nXXX–XX–XXXX\n```", "```\nSSN :record\n\n        FirstField:  smallint;  // smallints are 16 bits in Free Pascal/Delphi\n\n        SecondField: byte;\n\n        ThirdField:  smallint;\n\nend;\n```", "```\nSecondField = packedValue & 0x7f;   // 0x7f = %0111_1111\n```", "```\nThirdField := (packedValue and $3fff00) shr 8;\n```", "```\nThirdField = (packedValue >> 8) & 0x3FFF;\n```", "```\nFirstField := packedValue shr 22; // Delphi's SHR is a logical shift right.\n```", "```\nmovzx( (type byte packedValue), eax );\n```", "```\nmov( (type word packedValue[1]), ax );    // Extracts bytes 1 & 2 \n\n                                        // from packedValue.\n\nand( $3FFF, eax );                      // Clears all the undesired bits.\n```", "```\nmov( packedValue, eax );\n\nshr( 22, eax );\n```", "```\npackedValue = (packedValue & 0xFFc000FF) | (ThirdField << 8 );\n```"]