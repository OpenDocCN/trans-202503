<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch13">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch13">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label=" Page 207. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BUILDING THE GRAPHQL API</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In this chapter, you’ll add a GraphQL API to the middleware by defining its schema, as well as resolvers for each query and mutation. These resolvers will complement the Mongoose services created in <span class="chapterintro_Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. The queries will be public; however, we’ll expose our mutations as protected APIs by adding an authorization layer via OAuth.</p>&#13;
<p class="TX">Unlike in the GraphQL API of <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, we’ll follow a pattern of modularization to implement these schemas and resolvers. Instead of writing everything in one big file, we’ll split the elements into separate files. Like using modules in modern JavaScript, this approach has the benefit of breaking down the code into smaller logical units, each with a clear focus. These units enhance the code’s readability and maintainability.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-75"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label=" Page 208. "/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp></h3>&#13;
<p class="TNI">We’ll create the API’s single-entry point <i>/api/graphql</i> with the Apollo server, which integrates into Next.js with the <i>@as-integrations/next</i> package. Start by installing the packages necessary for the GraphQL setup from the npm registry:</p>&#13;
&#13;
<pre class="pre-227"><code>$ <b>docker exec -it foodfinder-application npm install @apollo/server graphql graphql-tag</b>&#13;
<b>@as-integrations/next \</b>&#13;
</code></pre>&#13;
<p class="TX">After the installation is complete, create the folder <i>graphql/locations</i> next to the <i>middleware</i> folder in the application’s root.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-76"/><samp class="SANS_Futura_Std_Bold_B_11">The Schemas</samp></h3>&#13;
<p class="TNI">The first step to writing the schemas is to define the query and mutation typedefs, as well as any custom types we use for the schema. To do so, we’ll split the schema into three files, <i>custom.gql.ts</i>, <i>queries.gql.ts</i>, and <i>mutations.gql.ts</i>, in the <i>graphql/locations</i> folder. Then we’ll use an ordinary template literal to merge them into the final schema definition.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-156"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Custom Types and Directives</samp></h4>&#13;
<p class="TNI">Add the code from <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a> to the <i>custom.gql.ts</i> file to define the schema for the GraphQL queries.</p>&#13;
<span id="Lis13-1"/>&#13;
<pre class="pre-228"><code>export default `&#13;
    directive @cacheControl(maxAge: Int) on FIELD_DEFINITION | OBJECT&#13;
    type Location @cacheControl(maxAge: 86400) {&#13;
        address: String&#13;
        street: String&#13;
        zipcode: String&#13;
        borough: String&#13;
        cuisine: String&#13;
        grade: String&#13;
        name: String&#13;
        on_wishlist: [String] @cacheControl(maxAge: 60)&#13;
        location_id: String&#13;
    }&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-1: The</span> <span class="Futura_Std_Book_11">graphql/locations/custom.gql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The GraphQL API will return location objects from the Mongoose schema. Therefore, we must define a custom type representing these location objects. Create a custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Location</samp> type. To instruct the server to cache the retrieved values, set an <samp class="SANS_TheSansMonoCd_W5Regular_11">@cacheControl</samp> directive for the whole custom type and a shorter one for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property because we expect this particular property to change frequently.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-157"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label=" Page 209. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Query Schema</samp></h4>&#13;
<p class="TNI">Now add the code from <a href="chapter13.xhtml#Lis13-2">Listing 13-2</a> to the <i>queries.gql.ts</i> file to define the schema for the queries.</p>&#13;
<span id="Lis13-2"/>&#13;
<pre class="pre-229"><code>export default `&#13;
    allLocations: [Location]!&#13;
    locationsById(location_ids: [String]!): [Location]!&#13;
    onUserWishlist(user_id: String!): [Location]!&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-2: The</span> <span class="Futura_Std_Book_11">graphql/locations/queries.gql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We define a template literal with three GraphQL queries, all of which are entry points to the services we implemented for the Mongoose locations model in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. The names and parameters are similar to those in the services, and the queries follow the GraphQL syntax you learned about in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-158"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Mutation Schema</samp></h4>&#13;
<p class="TNI">To define the mutation schema, paste the code from <a href="chapter13.xhtml#Lis13-3">Listing 13-3</a> into the <i>mutations.gql.ts</i> file.</p>&#13;
<span id="Lis13-3"/>&#13;
<pre class="pre-230"><code>export default `&#13;
    addWishlist(location_id: String!, user_id: String!): Location!&#13;
    removeWishlist(location_id: String!, user_id: String!): Location!&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-3: The</span> <span class="Futura_Std_Book_11">graphql/locations/mutations.gql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We create two mutations as template literals using GraphQL syntax: one for adding an item to the user’s wish list and one for removing it. Both will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp> function we implemented on the location services, so they require the <samp class="SANS_TheSansMonoCd_W5Regular_11">location_id</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp> as parameters.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1" id="sec6"><span id="h1-77"/><samp class="SANS_Futura_Std_Bold_B_11">Merging the Typedefs into the Final Schema</samp></h3>&#13;
<p class="TNI">We’ve split the location schema into two files, one for the queries and one for the mutations, and placed their custom types in a third file; however, to initiate the Apollo server, we’ll need a unified schema. Luckily, the typedefs are nothing more than template literals, and if we use template literal placeholders, the parser can interpolate these into a complete string. To accomplish this, create a new file, <i>schema.ts</i>, in the <i>graphql</i> folder and add the code from <a href="chapter13.xhtml#Lis13-4">Listing 13-4</a>.</p>&#13;
<span id="Lis13-4"/>&#13;
<pre class="pre-231"><code>import gql from "graphql-tag";&#13;
&#13;
import locationTypeDefsCustom from "graphql/locations/custom.gql";&#13;
import locationTypeDefsQueries from "graphql/locations/queries.gql";&#13;
import locationTypeDefsMutations from "graphql/locations/mutations.gql";&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label=" Page 210. "/>export const typeDefs = gql`&#13;
&#13;
    ${locationTypeDefsCustom}&#13;
&#13;
    type Query {&#13;
<b>  </b>      ${locationTypeDefsQueries}&#13;
    }&#13;
&#13;
    type Mutation {&#13;
        ${locationTypeDefsMutations}&#13;
    }&#13;
&#13;
`;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-4: The</span> <span class="Futura_Std_Book_11">graphql/schema.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">gql</samp> tag from the <i>graphql-tag</i> package. Even though doing so is optional when working with the Apollo server, we keep the <samp class="SANS_TheSansMonoCd_W5Regular_11">gql</samp> tag in front of our tagged template to ensure compatibility with all other GraphQL implementations. This also produces proper syntax highlighting in the IDE, which statically analyzes type definitions as GraphQL tags.</p>&#13;
<p class="TX">Next, we import the dependencies and schema fragments we’ll use to implement the unified schema. Finally, we create a tagged template literal with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gql</samp> function, using template literal placeholders to merge the schema fragments into the schema skeleton. We add the custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Location</samp> type and then merge the queries’ typedefs into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> object and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutations</samp> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">mutation</samp> object and export the schema <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> as typedefs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H1" id="sec7"><span id="h1-78"/><samp class="SANS_Futura_Std_Bold_B_11">The GraphQL Resolvers</samp></h3>&#13;
<p class="TNI">Now that we have the schema, we’ll turn to the resolvers. We’ll use a similar development pattern, writing the queries and mutations in separate files, then merging them into the single file we need for the Apollo server. Start by creating the <i>queries.ts</i> and <i>mutations.ts</i> files in the <i>graphql/locations</i> folder and then add the code from <a href="chapter13.xhtml#Lis13-5">Listing 13-5</a> to <i>queries.ts</i>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label=" Page 211. "/>&#13;
<span id="Lis13-5"/>&#13;
<pre class="pre-232"><code>import {&#13;
    findAllLocations,&#13;
    findLocationsById,&#13;
    onUserWishlist,&#13;
} from "mongoose/locations/services";&#13;
&#13;
export const locationQueries = {&#13;
    allLocations: async (_: any) =&gt; {&#13;
        return await findAllLocations();&#13;
    },&#13;
    locationsById: async (_: any, param: {location_ids: string[]}) =&gt; {&#13;
        return await findLocationsById(param.location_ids);&#13;
    },&#13;
    onUserWishlist: async (_: any, param: {user_id: string}) =&gt; {&#13;
        return await onUserWishlist(param.user_id);&#13;
    },&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-5: The</span> <span class="Futura_Std_Book_11">graphql/locations/queries.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import our services from the Mongoose folder and then create and export the location query object. The structure of each query follows the structure discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. We make one query for each service, and their parameters match those in the services.</p>&#13;
<p class="TX">For our mutations, add the code from <a href="chapter13.xhtml#Lis13-6">Listing 13-6</a> to the <i>mutations.ts</i> file.</p>&#13;
<span id="Lis13-6"/>&#13;
<pre class="pre-233"><code>import {updateWishlist} from "mongoose/locations/services";&#13;
&#13;
interface UpdateWishlistInterface {&#13;
    user_id: string;&#13;
    location_id: string;&#13;
}&#13;
&#13;
export const locationMutations = {&#13;
    removeWishlist: async (&#13;
        _: any,&#13;
        param: UpdateWishlistInterface,&#13;
        context: {}&#13;
    ) =&gt; {&#13;
        return await updateWishlist(param.location_id, param.user_id,&#13;
            "remove"&#13;
        );&#13;
    },&#13;
    addWishlist: async (_: any, param: UpdateWishlistInterface, context: {}) =&gt; {&#13;
        return await updateWishlist(param.location_id, param.user_id, "add");&#13;
    },&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-6: The</span> <span class="Futura_Std_Book_11">graphql/locations/mutations.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Here we import only the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp> function from our services. This is because we defined it as the single entry point for updating our documents, and we opted to use the third parameter, with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>, to distinguish between the two actions the mutation should perform. We also create the <samp class="SANS_TheSansMonoCd_W5Regular_11">UpdateWishlistInterface</samp>, which we don’t export. Instead, we’ll use it inside this file to avoid repeating code when we define the interface for the functions’ <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> argument.</p>&#13;
<p class="TX">As mutations, we create two functions at the <samp class="SANS_TheSansMonoCd_W5Regular_11">locationMutations</samp> object, one for adding an item from a user’s wish list and one for removing it. Both use the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp> service and supply the value parameter corresponding to the action the user would like to take. The two mutations, <samp class="SANS_TheSansMonoCd_W5Regular_11">removeWishlist</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">addWishlist</samp>, also take a third object called <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>. For now, it’s an empty object, but in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span>, we’ll replace it with the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label=" Page 212. "/>session information necessary to verify the identity of the user performing the action.</p>&#13;
<p class="TX">Create the final resolvers file, <i>resolvers.ts</i>, in the <i>graphql</i> folder and add the code from <a href="chapter13.xhtml#Lis13-7">Listing 13-7</a> to it. This code will merge the mutation and query definitions.</p>&#13;
<span id="Lis13-7"/>&#13;
<pre class="pre-234"><code>import {locationQueries} from "graphql/locations/queries";&#13;
import {locationMutations} from "graphql/locations/mutations";&#13;
&#13;
export const resolvers = {&#13;
    Query: {&#13;
<b>       </b><b> </b>...locationQueries,&#13;
    },&#13;
    Mutation: {&#13;
<b>       </b><b> </b>...locationMutations,&#13;
    },&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-7: The</span> <span class="Futura_Std_Book_11">graphql/resolvers.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">In addition to the schema, we must pass the Apollo server an object containing all resolvers, as discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>. To be able to do so, we must import the queries and mutations. Then we use the spread operator to merge the imported objects into the <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp> object, which we export. Now, with the schema and <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp> object available, we can create the API endpoint and instantiate the Apollo server.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-79"/><samp class="SANS_Futura_Std_Bold_B_11">Adding the API Endpoint to Next.js</samp></h3>&#13;
<p class="TNI">When we discussed the differences between REST and GraphQL APIs, we pointed out that unlike REST, where every API has its own endpoint, GraphQL provides only one endpoint, typically exposed as <i>/graphql</i>. To create this endpoint, we’ll use the Apollo server’s Next.js integration, as we did in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<p class="TX">Create the <i>graphql.ts</i> file in the <i>pages/api</i> folder and copy the code in <a href="chapter13.xhtml#Lis13-8">Listing 13-8</a>, which defines the API handler and its single entry point.</p>&#13;
<span id="Lis13-8"/>&#13;
<pre class="pre-235"><code>import {ApolloServer, BaseContext} from "@apollo/server";&#13;
import {startServerAndCreateNextHandler} from "@as-integrations/next";&#13;
&#13;
import {resolvers} from "graphql/resolvers";&#13;
import {typeDefs} from "graphql/schema";&#13;
import dbConnect from "middleware/db-connect";&#13;
&#13;
import {NextApiHandler, NextApiRequest, NextApiResponse} from "next";&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> const server = new ApolloServer&lt;BaseContext&gt;({&#13;
    resolvers,&#13;
    typeDefs,&#13;
});&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label=" Page 213. "/><span class="CodeAnnotationHang" aria-label="annotation2">❷</span> const handler = startServerAndCreateNextHandler(server, {&#13;
    context: async () =&gt; {&#13;
        const token = {};&#13;
        return {token};&#13;
    },&#13;
});&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> const allowCors =&#13;
    (fn: NextApiHandler) =&gt;&#13;
    async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
        res.setHeader("Allow", "POST");&#13;
        res.setHeader("Access-Control-Allow-Origin", "*");&#13;
        res.setHeader("Access-Control-Allow-Methods", "POST");&#13;
        res.setHeader("Access-Control-Allow-Headers", "*");&#13;
        res.setHeader("Access-Control-Allow-Credentials", "true");&#13;
&#13;
        if (req.method === "OPTIONS") {&#13;
            res.status(200).end();&#13;
        }&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">❹</span> const connectDB =&#13;
    (fn: NextApiHandler) =&gt;&#13;
    async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
        await dbConnect();&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
export default connectDB(allowCors(handler));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 13-8: The</span> <span class="Futura_Std_Book_11">pages/api/graphql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import all the elements we need to create the API handler: the Apollo server, a helper for the Apollo–Next.js integration, our resolvers, the GraphQL schema files, the function used to connect to the database, and the Next.js API helpers.</p>&#13;
<p class="TX">We create a new Apollo server with the resolvers and schema <span class="AnnotationCode" aria-label="annotation1">❶</span>. Then we use the Next.js integration helper <span class="AnnotationCode" aria-label="annotation2">❷</span> to start the Apollo server and return a Next.js handler. The integration helper uses a serverless Apollo setup to smoothly integrate into the Next.js custom server instead of creating its own. In addition, we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> with an empty <samp class="SANS_TheSansMonoCd_W5Regular_11">token</samp> to the handler. This is how we’ll access the JWT we receive in the OAuth flow and pass it to the resolvers later.</p>&#13;
<p class="TX">Next, we create the wrapper functions discussed in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> to add the CORS headers <span class="AnnotationCode" aria-label="annotation3">❸</span> and ensure that we have a database connection on each API call <span class="AnnotationCode" aria-label="annotation4">❹</span>. We can safely do so because we set up our database connection in a way that returns the existing cached connection. Finally, we export the returned asynchronous wrapped handler.</p>&#13;
<p class="TX">Visit the Apollo sandbox at <i>http:/localhost:3000/api/graphql</i> and run a few queries to test the GraphQL API before moving on to the next chapter. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label=" Page 214. "/>If you see the weather queries and mutations instead of the Food Finder’s, clear your browser’s cache and do a hard reload.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-80"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">We’ve successfully added the GraphQL API to the middleware. With the code in this chapter, we can now use the Apollo sandbox to read and update values in the database. We’ve also already prepared the Apollo handler for authentication by providing it with an empty token. Now we’re ready to use the JWT token we’ll receive from the OAuth flow in <span class="Xref"><a href="chapter15.xhtml">Chapter 15</a></span> to protect the API’s mutations. But before we add this authentication, let’s build the frontend.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>