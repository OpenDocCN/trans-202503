["```\ndef is_hamiltonian_path(g: Graph, path: list) -> bool: \n    num_nodes: int = len(path)\n  ❶ if num_nodes != g.num_nodes:\n        return False\n\n    visited: list = [False] * g.num_nodes\n  ❷ prev_node: int = path[0]\n    visited[prev_node] = True\n\n    for step in range(1, num_nodes):\n        next_node: int = path[step]\n\n      ❸ if not g.is_edge(prev_node, next_node):\n            return False\n      ❹ if visited[next_node]:\n            return False\n\n        visited[next_node] = True\n        prev_node = next_node\n\n    return True \n```", "```\ndef hamiltonian_dfs_rec(g: Graph, current: int, path: list,\n                        seen: list) -> Union[list, None]: \n    path.append(current)\n    seen[current] = True\n  ❶ if len(path) == g.num_nodes:\n        return path\n\n    for edge in g.nodes[current].get_edge_list():\n        n: int = edge.to_node\n        if not seen[n]:\n          ❷ result: Union[list, None] = hamiltonian_dfs_rec(g, n, path, seen) if result is not None:\n                return result\n\n  ❸ _ = path.pop()\n    seen[current] = False\n    return None \n```", "```\ndef hamiltonian_dfs(g: Graph) -> Union[list, None]: \n    seen: list = [False] * g.num_nodes\n    for start in range(g.num_nodes):\n        path: Union[list, None] = hamiltonian_dfs_rec(g, start, [], seen)\n        if path is not None:\n            return path\n    return None \n```", "```\ndef tsp_dfs_rec(g: Graph, path: list, seen: list, cost: float) -> tuple: \n    current: int = path[-1]\n\n  ❶ if len(path) == g.num_nodes:\n        last_edge: Union[Edge, None] = g.get_edge(current, path[0])\n        if last_edge is not None:\n            return (cost + last_edge.weight, path + [path[0]])\n        else:\n            return (math.inf, [])\n\n    best_path: list = []\n    best_score: float = math.inf\n    for edge in g.nodes[current].get_edge_list():\n        n: int = edge.to_node\n        if not seen[n]:\n          ❷ seen[n] = True\n            path.append(n)\n\n          ❸ result: tuple = tsp_dfs_rec(g, path, seen, cost + edge.weight)\n          ❹ seen[n] = False\n            _ = path.pop()\n\n            if result[0] < best_score:\n                best_score = result[0]\n                best_path = result[1]\n\n    return (best_score, best_path) \n```", "```\ndef tsp_dfs(g: Graph) -> tuple: \n    if (g.num_nodes == 1):\n        return (0.0, [0])\n\n    seen: list = [False] * g.num_nodes\n    path: list = [0]\n    seen[0] = True\n\n    return tsp_dfs_rec(g, path, seen, 0.0) \n```", "```\ndef has_eulerian_cycle(g: Graph) -> bool: \n  ❶ components: list = dfs_connected_components(g)\n    for i in range(g.num_nodes):\n      ❷ if components[i] != 0:\n            return False\n\n      ❸ degree: int = g.nodes[i].num_edges()\n        if i in g.nodes[i].edges:\n            degree += 1\n        if degree % 2 == 1:\n            return False\n    return True \n```", "```\ndef is_eulerian_cycle(g: Graph, path: list) -> bool: \n    num_nodes: int = len(path)\n  ❶ if num_nodes == 0:\n        return g.num_nodes == 0\n\n  ❷ used: dict = {}\n    for node in g.nodes:\n        for edge in node.get_edge_list():\n            used[(edge.from_node, edge.to_node)] = False\n\n    prev_node: int = path[0]\n    for step in range(1, num_nodes):\n        next_node: int = path[step]\n      ❸ if not g.is_edge(prev_node, next_node):\n            return False\n      ❹ if used[(prev_node, next_node)]:\n            return False ❺ used[(prev_node, next_node)] = True\n        if g.undirected:\n            used[(next_node, prev_node)] = True\n\n        prev_node = next_node\n\n  ❻ for value in used.values():\n        if not value:\n            return False\n  ❼ return path[0] == path[-1] \n```", "```\ndef hierholzers(g: Graph) -> Union[list, None]: \n  ❶ if not has_eulerian_cycle(g):\n        return None\n\n    g_r: Graph = g.make_copy()\n    options: set = set([0])\n    full_cycle: list = [0]\n\n    while len(options) > 0:\n      ❷ start: int = options.pop()\n        current: int = start\n        subcycle: list = [start]\n\n      ❸ while current != start or len(subcycle) == 1:\n          ❹ neighbor: int = list(g_r.nodes[current].edges.keys())[0] subcycle.append(neighbor)\n            g_r.remove_edge(current, neighbor)\n\n          ❺ new_num_edges: int = g_r.nodes[current].num_edges()\n            if new_num_edges > 0:\n                options.add(current)\n            elif new_num_edges == 0 and current in options:\n                options.remove(current)\n\n            current = neighbor\n\n      ❻ if g_r.nodes[start].num_edges() == 0 and start in options:\n            options.remove(start)\n\n        loc: int = full_cycle.index(start)\n      ❼ full_cycle = full_cycle[0:loc] + subcycle + full_cycle[loc+1:]\n\n    return full_cycle \n```"]