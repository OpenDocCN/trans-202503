- en: '**15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SPECIAL USES OF SUBFUNCTIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg297_Image_276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you learned in [Chapter 14](ch14.xhtml), the most common use of a subfunction
    is to break a problem into smaller, easier-to-solve subproblems. This is the foundation
    of *recursion*, the subject of the first half of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'After I cover recursion, I’ll show you another use of subfunctions: directly
    accessing hardware features in assembly language that may not be easily accessible
    in a higher-level language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recursion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many computer solutions involve repetitive actions. You learned how to use iteration—`while`,
    `for`, and `do-while` loops—to perform repetitive actions in [Chapter 13](ch13.xhtml).
    While iteration can be used to solve any repetitive problem, some solutions are
    described more succinctly using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: A *recursive algorithm* is an algorithm that calls itself to compute a simpler
    case of the problem and uses that result to compute the more complex case at hand.
    The recursive calls continue until the simpler case reaches a *base case*, which
    is a case that is easily computed by itself. At this point, the recursive algorithm
    returns the base case value to the next more complex case, where the value is
    used in that computation. This return/compute process continues, performing increasingly
    complex computations along the way, until we arrive at the solution for the original
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. In mathematics, we denote the factorial operation
    on positive integers with an !, which can be defined recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg334_Image_282a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first equation shows that *n*! is defined by computing a simpler case of
    itself, (*n* – 1)!. This computation is performed repetitively until we reach
    the base case of *n* = 0\. Then we work our way back out, computing each *n*!
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, the iterative definition of the factorial operation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg334_Image_282b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although both forms of defining the factorial operation involve the same number
    of computations, the recursive form is more concise and perhaps more intuitive
    to some people.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listings 15-1](ch15.xhtml#ch15list1) to [15-3](ch15.xhtml#ch15list3) show
    a program that uses a function, `factorial`, to compute 3!. You’ll see the reason
    for using a small, fixed value when we use `gdb` to examine the behavior of the
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: '*three_factorial.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-1: A program to compute 3!*'
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical factorial function is defined for nonnegative integers, so
    we use `unsigned int`s.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing remarkable about the header file for the `factorial` function,
    shown in [Listing 15-2](ch15.xhtml#ch15list2).
  prefs: []
  type: TYPE_NORMAL
- en: '*factorial.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-2: The header file for the function to compute* n*!*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-3](ch15.xhtml#ch15list3) shows that the `factorial` function calls
    itself to perform a simpler computation, (*n* – 1)!, so it can easily compute
    *n*!.'
  prefs: []
  type: TYPE_NORMAL
- en: '*factorial.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-3: A function to compute* n*!*'
  prefs: []
  type: TYPE_NORMAL
- en: The `factorial` function first checks for the base case of *n* = 0 ❶. If we’re
    at the base case, the current result is 1\. If we’re not at the base case, the
    `factorial` function calls the `factorial` function to compute (*n* – 1)! and
    multiplies the result by *n* to get *n*!❷.
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language for the `main` function is unremarkable, but let’s look
    at what the compiler generated for the `factorial` function, shown in [Listing
    15-4](ch15.xhtml#ch15list4).
  prefs: []
  type: TYPE_NORMAL
- en: '*factorial.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-4: The compiler-generated assembly language for the function in
    [Listing 15-3](ch15.xhtml#ch15list3)*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used in the `factorial` function is a simple `if` construct, which
    you learned about in [Chapter 13](ch13.xhtml) ❷. The important part of a recursive
    function is that we need to save any arguments passed to it in registers so these
    registers can be reused to pass arguments in the recursive call to the function.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `factorial` function takes one argument, `n`, which is passed
    in the `w0` register. From [Table 11-3](ch11.xhtml#ch11tab3) in [Chapter 11](ch11.xhtml),
    we know that we don’t need to save the content of `x0` in our function, but we
    need to use the `w0` portion of `x0` for the recursive call with the new value,
    `(n - 1)` ❸. And when the recursive call returns, we need the original value of
    `n` to compute `n * (n - 1)!`. The compiler has allocated space in the stack frame
    for saving `n` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t discussed the `mul` instruction yet. As you might guess, the `mul`
    instruction in [Listing 15-4](ch15.xhtml#ch15list4) multiplies the integer in
    `w0` by the one in `w1`, leaving the product in `w0` ❹. The details of multiplication
    instructions are somewhat complex. I’ll cover them in [Chapter 16](ch16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: We can simplify the `factorial` function a little by writing it directly in
    assembly language. Let’s start by designing our stack frame, as shown in [Figure
    15-1](ch15.xhtml#ch15fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg336_Image_282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: The stack frame design for the* factorial *function*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-5](ch15.xhtml#ch15list5) shows our assembly language version.'
  prefs: []
  type: TYPE_NORMAL
- en: '*factorial.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-5: A function to compute* n*!*'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few key differences to note here. First, I don’t know why the compiler
    allocated 48 bytes for the stack frame (see [Listing 15-4](ch15.xhtml#ch15list4)),
    but we only need 32 bytes ❶. Second, we’re using a local variable for the input
    `n`. The compiler uses a local variable for the result of the computation `n *
    (n - 1)!`, but we’re leaving it in the `w0` register ❸. Third, we use the `cbz`
    instruction instead of the `cmp`/`beq` pair the compiler used ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursive algorithms can be simple and elegant, but they make heavy use of
    the stack. I used our assembly language version of `factorial` (and the C header
    file in [Listing 15-2](ch15.xhtml#ch15list2)) with the `main` function of [Listing
    15-1](ch15.xhtml#ch15list1) and ran the program under `gdb` so we can take a look
    at the stack usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I set two breakpoints, one at the recursive call to `factorial` ❶ and the other
    at the point where the function’s algorithm ends ❷. Each time the program breaks
    back into `gdb`, we’ll look at the input value to this call to `factorial`, the
    input value we’re passing to the next call to `factorial`, `pc`, and the stack
    frame for each call to `factorial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function called the `factorial` function with `3` as the input, which
    is saved on the stack ❷. When viewing this display, remember that the input is
    a 32-bit `int`. Each item on the stack is 64 bits wide, so this `int` is stored
    in the low-order 32 bits of this stack location. Looking at the 32 bytes of the
    stack frame, we see the return address back to `main` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to call `factorial` with the input `(3 - 1) = 2` in register
    `w0`. When we continue running the program, it will break at the same place in
    `factorial` because the function calls itself before returning to `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `factorial` function has added another 32-byte stack frame onto the stack
    ❶. The input to this call to `factorial`, `2`, has been saved in this new stack
    frame ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The program counter, `pc`, shows that the `bl factorial` instruction is located
    at `0x55555507cc`. All instructions in the A64 architecture are 32 bits wide,
    so all recursive calls to the `factorial` function will return to location `0x55555507cc
    + 0x4 = 0x55555507d0` in the function. This is the return address stored in the
    frame record ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we enter c (continue) two more times, we finally reach the point where the
    program flow leaves the fourth call to `factorial`, breaking at the second breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This view shows that each time `factorial` was called, it created a new stack
    frame. It also shows where the input to each call of `factorial` has been saved
    on the stack, the last one being `0` ❶. Since this is the base case, the program
    flow went directly to the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return address stored in the frame records of the top three stack frames
    is `0x00000055555507d0`. When each recursive call to `factorial` returns, it returns
    to the instruction immediately following the `bl factorial` instruction in the
    `factorial` function itself. When we continue execution of the program, it again
    breaks at our second breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this display with the previous display, we can see that the top frame
    record—the one created when `factorial` was called with the base case of `0` as
    input—has been removed from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we continue, the program breaks again at the second breakpoint before
    returning from this invocation of `factorial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the continue command (`c`) once more takes us back to the original call
    to `factorial` from `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The return address in the frame record is back in `main` ❶. When we continue,
    `main` prints the result for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The debugger has also printed some information about the process for us. We’re
    still in `gdb` and need to quit that.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the stack display when the program is at the base case ([page
    311](ch15.xhtml#page_311)), notice that each call to the recursive function creates
    another stack frame. We used a small number in this example, but computing the
    factorial of a large number would use a lot of stack space. And since there is
    a call to a function in each repetition, recursive algorithms can be time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Every recursive solution has an equivalent iterative solution, which is usually
    more efficient, both in time and in stack usage. For example, the iterative algorithm
    to compute the factorial of an integer (see [page 306](ch15.xhtml#page_306)) is
    simple, so an iterative solution might be preferable. However, many problems (such
    as some sorting algorithms) lend themselves more naturally to a recursive solution.
    For such problems, the increased simplicity of the code is often worth the cost
    of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: We would typically write a recursive function in a higher-level language, but
    I used assembly language here so you can gain an understanding of how recursion
    works. Next, I’ll show you how to use assembly language to access hardware features
    that might not be directly accessible in the high-level language you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 15.1     Enter the C program in [Listings 15-1](ch15.xhtml#ch15list1) to [15-3](ch15.xhtml#ch15list3).
    Run your program under `gdb`, with breakpoints at the beginning of the `if` statement
    and at the `return` statement. Each time it breaks, you should see the value of
    `n` that was the input to the current call to `factorial`. The `bt` (backtrace)
    and `info f` (frame information) `gdb` commands will give you more information
    about the stack frames, which can be helpful in debugging recursive C functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing CPU Features in Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 14](ch14.xhtml), it may have seemed a bit silly to create a whole
    subfunction just to add two integers for the `sum_ints` program (see [Listing
    14-8](ch14.xhtml#ch14list8)), which can be done with a single instruction. But
    as you learned in [Chapter 3](ch03.xhtml), even simple addition can produce carry
    or overflow.
  prefs: []
  type: TYPE_NORMAL
- en: The `add` and `sub` instructions you learned about in [Chapter 11](ch11.xhtml)
    have no effect on the condition flags, but the A64 architecture includes variants
    of `add` and `sub`, `adds` and `subs`, that will set the condition flags in the
    `nzcv` register according to the result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'C and C++ don’t provide a way to check the overflow or carry flags in the `nzcv`
    register. In this section, I’ll show you two ways to use assembly language in
    C programs to indicate when there is overflow from addition: we can write a separate
    function in assembly language that is callable from our C code, or we can embed
    assembly language directly within our C code.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing a Separate Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ll start by rewriting the `sum_ints` program from [Chapter 14](ch14.xhtml)
    in C so that it warns the user if the addition produces overflow. I’ll check for
    overflow in the subfunction `add_two`, and I’ll pass the result back to the `main`
    function using the return mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-6](ch15.xhtml#ch15list6) shows the modified `main` function that
    checks the return value from the `add_two` function for overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-6: A program to add two integers and show if there is overflow*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll rewrite the `add_two` function such that it returns 0 if there is
    no overflow and 1 if there is overflow (recall that in C, zero is logically false
    and a nonzero value is true). I’ll assign this result to the variable `overflow`
    in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-7](ch15.xhtml#ch15list7) shows the header file for the new `add_two`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.h*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-7: The header file for the* add_two *function*'
  prefs: []
  type: TYPE_NORMAL
- en: The only change in the function declaration is returning an `int` instead of
    `void`. We need to add a check for overflow in the definition of the `add_two`
    function, as shown in [Listing 15-8](ch15.xhtml#ch15list8).
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-8: A function to add two integers and return an overflow indication*'
  prefs: []
  type: TYPE_NORMAL
- en: You learned in [Chapter 3](ch03.xhtml) that if adding two integers of the same
    sign gives a result of the opposite sign, you have overflow, so we use this logic
    as the check for overflow ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 15-9](ch15.xhtml#ch15list9) shows the assembly language generated
    by the compiler from this C source.'
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-9: The compiler-generated assembly language for the* add_two *function
    in [Listing 15-8](ch15.xhtml#ch15list8)*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it takes about 20 instructions to check for overflow in C ❶.
    In [Listing 15-10](ch15.xhtml#ch15list10), I rewrite the `add_two` function in
    assembly language so I can use the `adds` instruction for the addition operation
    and then detect overflow from the condition flags in the `nzcv` register.
  prefs: []
  type: TYPE_NORMAL
- en: '*add_two.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-10: The* add_two *function with overflow detection in assembly
    language*'
  prefs: []
  type: TYPE_NORMAL
- en: I didn’t create a stack frame for this very simple leaf function because it
    is unlikely we would ever modify this function to call another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'I used the `cinc` instruction ❶ to read the overflow flag in the `nzcv` register
    and load the `w0` register with either a `0` or a `1`, depending on whether the
    overflow flag is `0` or `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: cinc**—Conditional increment**
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`cinc w`d `, w`s `,` cond moves the value in `w`s to `w`d, adding 1 to the
    value if cond is true.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cinc x`d `, x`s `,` cond moves the value in `x`s to `x`d, adding 1 to the
    value if cond is true.'
  prefs: []
  type: TYPE_NORMAL
- en: The possible values for cond are given in [Table 13-1](ch13.xhtml#ch13tab1)
    in [Chapter 13](ch13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Using the assembly language version of `add_two` in [Listing 15-10](ch15.xhtml#ch15list10)
    with the `main` function in [Listing 15-6](ch15.xhtml#ch15list6) shows one of
    the reasons for writing a subfunction in assembly language. It allows us to access
    a feature of the CPU, the `V` flag in the `nzcv` register, that is not accessible
    in C, the higher-level language we’re using. Writing in assembly language allows
    us to ensure that there are no intervening instructions that might change the
    flags between the operation (addition, in this example) and the flag check.
  prefs: []
  type: TYPE_NORMAL
- en: This example also illustrates a common use of the return value. Inputs and outputs
    are often passed in the argument list, with supplemental information about the
    computation carried in the return value.
  prefs: []
  type: TYPE_NORMAL
- en: That said, calling a function to simply add two numbers is inefficient. In the
    next section, we’ll look at a common extension to C that allows us to insert assembly
    language directly in our C code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Inline Assembly Language***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like many C compilers, `gcc` includes an extension to the standard C language
    that allows us to embed assembly language in our C code, usually called *inline
    assembly*. Doing so can be complex. We’ll look at a simple case here. You can
    read the details at *[https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html](https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html)*,
    or you can use the `info gcc` command and select **C Extensions ▶ Using Assembly
    Language with C ▶ Extended Asm**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gcc` compiler uses the following general form for embedding assembly language
    in C, which starts with the `asm` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The asm-qualifiers are used to help the compiler optimize the C code, a topic
    that is beyond the scope of this book. We’re not asking the compiler to optimize
    our C code, so we won’t use asm-qualifiers.
  prefs: []
  type: TYPE_NORMAL
- en: The output operands are the C variables that could be changed by the assembly
    language statements, thus acting as outputs from the assembly language statements.
    The input operands refer to the C variables that are used by the assembly language
    statements but are not changed, thus acting as inputs to the assembly language
    statements. The clobbers are the registers that get explicitly changed by the
    assembly language statements, thus telling the compiler about the possible changes
    in these registers.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 15-11](ch15.xhtml#ch15list11), I use inline assembly language to
    check for overflow in the addition.
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints.c*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-11: A program to add two integers and show if there’s overflow*'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note about the code here is that it’s important to place
    the `adds` instruction in assembly language so we can check for overflow immediately
    after the instruction is executed ❶. If we were to do the addition in C, the compiler
    would use the `add` instruction, as in [Listing 15-9](ch15.xhtml#ch15list9), which
    does not set the condition flags.
  prefs: []
  type: TYPE_NORMAL
- en: There is a template for each assembly language instruction as a text string
    enclosed in quotes ❶. The operands for each instruction are numbered according
    to their relative position on the *output:input* operand list, starting from 0\.
    I preface the variable numbers with `w` in the assembly language template to tell
    the compiler that these are word (32-bit) values. Remember that assembly language
    code is line-oriented, so it’s important to place a newline character, `\n`, at
    the end of each assembly language statement. The newline is not needed at the
    end of the last assembly language statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful not to confuse operand numbers with register numbers.* %w0 *is
    the 32-bit value of the first operand on our* output:input *operand list, and*
    w0 *is the low-order 32 bits of the* x0 *register.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for each output or input operand is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In our program, `z` is in position 0 and `overflow` is in position 1 ❷; `x`
    is in position 2 and `y` is in position 3 ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The constraint tells the compiler what kind of operand it can use in the assembly
    language template. For example, `"m"` means the compiler should use a memory location
    and `"r"` means it should use a register. Prefixing the kind with `=` tells the
    compiler that our assembly language stores a value there. The `"=r" (z)` constraint
    thus tells the compiler that it needs to use a register for the `%w0` operand,
    that our assembly language will store a value in that register, and to store the
    value in that register in the C variable `z` ❷. The `"r" (x)` constraint tells
    the compiler to use a register for the value in the C variable `x`, but our assembly
    language does not change the value in that register ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that when you use inline assembly language, the compiler could generate
    assembly language for your C code that does not work well with your assembly language.
    It’s a good idea to generate the assembly language for the entire function (using
    the `-S` compiler option) and read it carefully to make sure the function is doing
    what you intend. We’ll do this in [Listing 15-12](ch15.xhtml#ch15list12).
  prefs: []
  type: TYPE_NORMAL
- en: '*sum_ints.s*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 15-12: The compiler-generated code for inline assembly*'
  prefs: []
  type: TYPE_NORMAL
- en: We told the compiler that the assembly language we’ve inserted uses registers
    for the inputs (`"r"`), so it loads the values from the C variables into registers
    ❶. Similarly, we specified that we’re using registers for the outputs in our assembly
    language (`"=r"`), and the compiler stores the values from the registers into
    the C variables ❷.
  prefs: []
  type: TYPE_NORMAL
- en: If you think inline assembly looks tricky, you’re right. The C language standard
    lists inline assembly as a common extension to the language but points out that
    extensions are not part of the standard. This means that using inline assembly
    in C code may not work if you use a different compiler, even on the same computer.
    In most cases, if I need to use assembly language, I use a separate function,
    as we did in [Listing 15-10](ch15.xhtml#ch15list10), which is portable between
    compilers.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: '15.2     Modify the C program in [Listings 15-6](ch15.xhtml#ch15list6), [15-7](ch15.xhtml#ch15list7),
    and [15-8](ch15.xhtml#ch15list8) to use `unsigned int`s and tell the user when
    the addition produces carry. It will declare the variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The formatting code for reading and printing the values of the `unsigned int`s
    is `%u`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 15.3     Modify the program in [Listing 15-11](ch15.xhtml#ch15list11) to use
    `unsigned int`s and tell the user when the addition produces carry.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4     Modify the program in [Listing 15-11](ch15.xhtml#ch15list11) to use
    `register int`s for the `z` and `overflow` variables. How does this change the
    compiler-generated assembly language?
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Recursion** Allows for simple and elegant solutions to some problems, but
    uses a lot of stack space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing hardware features** Most programming languages do not allow direct
    access to all the hardware features in a computer. Using an assembly language
    subfunction or inline assembly language may be the best solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inline assembly** Allows us to embed assembly language in our C code frame
    pointer and the return address to the calling function.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know some common ways to use functions in a program, we’ll move
    on to multiplication, division, and logic operations. In the next chapter, you’ll
    learn how to convert a string of numerals in ASCII code to the integer they represent.
  prefs: []
  type: TYPE_NORMAL
