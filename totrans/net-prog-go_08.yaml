- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Ensuring UDP Reliability
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 确保UDP的可靠性
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Chapter 5 introduced basic network applications using UDP and demonstrated the
    flexibility of Go’s `net` package and interfaces for writing portable code. This
    chapter picks up where the last one left off to introduce one method of ensuring
    reliability when communicating over UDP.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第五章介绍了使用UDP的基本网络应用，并展示了Go语言的`net`包和接口在编写可移植代码时的灵活性。本章接着上章的内容，介绍了一种确保UDP通信可靠性的方法。
- en: This chapter starts by introducing an application protocol built on top of UDP.
    We’ll cover a subset of types used by this protocol and demonstrate how they are
    used to reliably transfer data. We’ll then implement a server that allows clients
    to download files using the application protocol. Finally, we’ll download a file
    from our server and verify its integrity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时介绍了一个建立在UDP之上的应用协议。我们将覆盖该协议所使用的一部分类型，并展示如何利用它们可靠地传输数据。接着，我们将实现一个服务器，允许客户端使用该应用协议下载文件。最后，我们将从我们的服务器下载一个文件并验证其完整性。
- en: Reliable File Transfers Using TFTP
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TFTP进行可靠的文件传输
- en: As discussed in the preceding chapter, UDP is inherently unreliable. That means
    it’s your application’s job to make the UDP connection reliable. Since we spent
    the last chapter covering UDP and how it’s best used in situations that require
    a subset of TCP features, it’s only appropriate that we look at an example of
    such an application-level protocol.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，UDP本身是不可靠的。这意味着让UDP连接可靠是你的应用程序的工作。既然我们在上一章中讨论了UDP，以及它在需要部分TCP特性的情况下的最佳使用方式，那么现在回过头来看这样一个应用层协议的例子是很合适的。
- en: The *Trivial File Transfer Protocol (TFTP)* is an example of an application
    protocol that ensures reliable data transfers over UDP. It allows two nodes to
    transfer files over UDP by implementing a subset of the features that make TCP
    reliable. A TFTP server implements ordered packet delivery, acknowledgments, and
    retransmissions. To distill this example down to the essential bits, your server
    allows clients to download binary data only. It does not support uploads, American
    Standard Code for Information Interchange (ASCII) transfers, or some of the later
    additions to TFTP specified outside RFC 1350\. Your server expediently serves
    the same file, no matter what file the client requests, in the name of simplicity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单文件传输协议（TFTP）*是一个应用层协议的例子，它确保了通过UDP进行可靠的数据传输。它允许两个节点通过实现一部分使TCP可靠的特性，来通过UDP传输文件。TFTP服务器实现了有序的数据包传输、确认和重传。为了将这个例子简化到最基本的内容，你的服务器只允许客户端下载二进制数据。它不支持上传、美国信息交换标准代码（ASCII）传输或TFTP的后续添加功能，这些功能在RFC
    1350之外进行了规定。为了简化，你的服务器无论客户端请求哪个文件，都会快速地提供相同的文件。'
- en: Please keep in mind that TFTP is not appropriate for secure file transmission.
    Though it adds reliability to UDP connections, it does not support encryption
    or authentication. If your application requires communication over UDP, you may
    want to use WireGuard ([https://github.com/WireGuard/wireguard-go/](https://github.com/WireGuard/wireguard-go/)),
    an application that allows for secure communication over UDP.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，TFTP不适合用于安全文件传输。虽然它为UDP连接增加了可靠性，但它不支持加密或认证。如果你的应用需要通过UDP进行通信，你可能会想使用WireGuard（[https://github.com/WireGuard/wireguard-go/](https://github.com/WireGuard/wireguard-go/)），这是一个支持通过UDP进行安全通信的应用程序。
- en: The next few sections will implement a read-only TFTP server to teach you the
    basics of adding reliability to UDP. By *read-only*, I mean your server will allow
    clients to only download files, not upload them. You will start by defining the
    subset of constants and types your TFTP server supports. You will encapsulate
    as much of the type-related logic in each type’s methods. You’ll then implement
    the TFTP server portion of the code that will interact with clients and use the
    types we define to facilitate reliable file transfers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个部分将实现一个只读的TFTP服务器，教你如何将可靠性添加到UDP中。所谓*只读*，我的意思是你的服务器只允许客户端下载文件，而不允许上传文件。你将从定义你的TFTP服务器支持的常量和类型的子集开始。你将把与类型相关的逻辑封装在每个类型的方法中。接着，你将实现TFTP服务器的代码部分，与客户端交互，并使用我们定义的类型来促进可靠的文件传输。
- en: TFTP Types
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP类型
- en: Your TFTP server will accept read requests from the client, send data packets,
    transmit error packets, and accept acknowledgments from the client. To do this,
    you must define a few types in your code to represent client requests, transmitted
    data, acknowledgments, and errors. [Listing 6-1](#listing6-1) outlines key types
    used to cap packet sizes, identify operations, and codify various errors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 TFTP 服务器将接受来自客户端的读取请求，发送数据包，传输错误包，并接受来自客户端的确认。为此，你必须在代码中定义一些类型来表示客户端请求、传输的数据、确认和错误。[列表
    6-1](#listing6-1) 概述了用于限制数据包大小、识别操作和编码各种错误的关键类型。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Types and codes used by the TFTP server (*types.go*)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-1：TFTP 服务器使用的类型和代码（*types.go*）
- en: TFTP limits datagram packets to 516 bytes or fewer to avoid fragmentation. You
    define two constants to enforce the datagram size limit 1 and the maximum data
    block size 2. The maximum block size is the datagram size minus a 4-byte header.
    The first 2 bytes of a TFTP packet’s header is an operation code 3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP 限制数据报数据包的大小不得超过 516 字节，以避免分段。你定义了两个常量来强制执行数据报大小限制 1 和最大数据块大小 2。最大块大小是数据报大小减去
    4 字节的头部。TFTP 数据包头的前 2 字节是操作码 3。
- en: 'Each operation code is a 2-byte, unsigned integer. Your server supports four
    operations: a read request (RRQ), a data operation, an acknowledgment, and an
    error. Since your server is read-only, you skip the write request (WRQ) definition.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作码是一个 2 字节的无符号整数。你的服务器支持四种操作：读取请求（RRQ）、数据操作、确认和错误。由于你的服务器是只读的，因此跳过了写请求（WRQ）的定义。
- en: As with the operation codes, you define a series of unsigned 16-bit integer
    error codes 4 per the RFC. Although you don’t use all error codes in your server
    since it allows only downloads, a client could return these error codes in lieu
    of an acknowledgment packet.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作码类似，你根据 RFC 定义了一系列无符号的 16 位整数错误代码 4。虽然在你的服务器中并未使用所有错误代码，因为它只允许下载，但客户端可以返回这些错误代码代替确认包。
- en: The following sections detail the types that implement your server’s four supported
    operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节详细说明了实现服务器支持的四种操作的类型。
- en: Read Requests
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取请求
- en: The server receives a *read request* packet when the client wants to download
    a file. The server must then respond with either a data packet or an error packet,
    both of which you’ll look at in the next few sections. Either packet serves as
    an acknowledgment to the client that the server received the read request. If
    the client does not receive a data or error packet, it may retransmit the read
    request until the server responds or the client gives up.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端希望下载文件时，服务器会接收到一个 *读取请求* 数据包。然后，服务器必须回应一个数据包或一个错误包，接下来的几个章节中你将看到这两种包。任何一个数据包都可以作为对客户端的确认，表明服务器已接收到读取请求。如果客户端未收到数据包或错误包，它可以重新传输读取请求，直到服务器响应或客户端放弃。
- en: '[Figure 6-1](#figure6-1) illustrates the structure of a read request packet.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-1](#figure6-1) 说明了读取请求数据包的结构。'
- en: '![f06001](image_fi/500884c06/f06001.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/500884c06/f06001.png)'
- en: 'Figure 6-1: Read request packet structure'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：读取请求数据包结构
- en: 'The read request packet consists of a 2-byte operation code, a filename, a
    null byte, a mode, and a trailing null byte. An *operation code* is an integer
    that is unique to each of your operation types. Each type’s operation code corresponds
    to the integer detailed in RFC 1350\. For example, a read request’s operation
    code is 1\. The filename and mode are strings of varying lengths. The mode indicates
    to the server how it should send the file: netascii or octet. If a client requests
    a file using the *netascii* mode, the client must convert the file to match its
    own line-ending format. For our purposes, you will accept only the *octet* mode,
    which tells the server to send the file in a binary format, or as is.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 读取请求数据包由 2 字节的操作码、文件名、一个空字节、模式和一个尾随空字节组成。*操作码*是一个整数，对应每种操作类型的唯一标识。每个类型的操作码对应
    RFC 1350 中详细说明的整数。例如，读取请求的操作码是 1。文件名和模式是长度可变的字符串。模式指示服务器如何发送文件：netascii 或 octet。如果客户端使用
    *netascii* 模式请求文件，则客户端必须将文件转换为符合其自身行结束格式的格式。对于我们的目的，你只会接受 *octet* 模式，这要求服务器以二进制格式或原样发送文件。
- en: '[Listing 6-2](#listing6-2) is a continuation of [Listing 6-1](#listing6-1).
    Here, you define the read request and its method that allows the server to marshal
    the request into a slice of bytes in preparation for writing to a network connection.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6-2](#listing6-2) 是 [列表 6-1](#listing6-1) 的延续。在这里，你定义了读取请求及其方法，使服务器能够将请求编排成字节切片，以准备写入网络连接。'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: Read request and its binary marshaling method (*types.go* continued)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：读取请求及其二进制序列化方法（*types.go* 续）
- en: The struct representing your read request 1 needs to keep track of the filename
    and the mode. You insert the operation code 2 and null bytes 3 into the buffer
    while marshaling the packet to a byte slice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表示读取请求的结构体1需要跟踪文件名和模式。在将数据包序列化为字节切片时，您将操作码2和空字节3插入到缓冲区中。
- en: '[Listing 6-3](#listing6-3) continues where [Listing 6-2](#listing6-2) left
    off and rounds out the read request’s implementation by defining a method that
    allows the server to unmarshal a read request from a byte slice, typically read
    from a network connection with a client.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 6-3](#listing6-3)延续了[清单 6-2](#listing6-2)的内容，并通过定义一个方法，完成了读取请求的实现，该方法允许服务器从字节切片中反序列化读取请求，通常是从与客户端的网络连接中读取的。'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: Read request type implementation (*types.go* continued)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-3：读取请求类型实现（*types.go* 续）
- en: Your TFTP server’s read request, data, acknowledgment, and error packets all
    implement the `encoding.BinaryMarshaler` and `encoding.BinaryUnmarshaler` interfaces.
    These methods allow your types to marshal themselves to a binary format suitable
    for transmission over the network and from network bytes back into the original
    types. For example, the read request type can marshal itself into a byte slice
    that matches the read request format showed in [Figure 6-1](#figure6-1) by using
    its `MarshalBinary` method from [Listing 6-2](#listing6-2). Likewise, it can constitute
    itself from a byte slice read from the network using its `UnmarshalBinary` method
    1. Although your server does not send a read request and make use of its `MarshalBinary`
    method, I encourage you to write a TFTP client that will marshal a read request
    to its binary form as you progress through this chapter. I leave it as an exercise
    for you to implement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您的TFTP服务器的读取请求、数据、确认和错误数据包都实现了`encoding.BinaryMarshaler`和`encoding.BinaryUnmarshaler`接口。这些方法允许您的类型将自身序列化为适合通过网络传输的二进制格式，并将网络字节反序列化回原始类型。例如，读取请求类型可以使用其`MarshalBinary`方法将自身序列化为与[图6-1](#figure6-1)所示的读取请求格式匹配的字节切片，正如[清单6-2](#listing6-2)中所示。类似地，它可以使用其`UnmarshalBinary`方法1，从网络中读取的字节切片中构建自身。尽管您的服务器不会发送读取请求并使用其`MarshalBinary`方法，但我鼓励您在本章学习过程中编写一个TFTP客户端，该客户端将读取请求序列化为二进制形式。我将此作为练习留给您来实现。
- en: The `UnmarshalBinary` method returns `nil` only if the given byte slice matches
    the read request format. If you are unsure of whether a given byte slice is a
    read request, you can pass the byte slice to this method and make that determination
    based on the return value. You will see this in action when you look at the server
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnmarshalBinary`方法仅在给定的字节切片匹配读取请求格式时才返回`nil`。如果您不确定给定的字节切片是否是读取请求，可以将字节切片传递给此方法，并根据返回值来确定。您将在查看服务器代码时看到这一点。'
- en: The `UnmarshalBinary` method reads in the first 2 bytes 2 and confirms the operation
    code is that of a read request. It then reads all bytes up to the first null byte
    3 and strips the null byte delimiter 4. The resulting string of bytes represents
    the filename. Similarly, you read in the mode, returning `nil` if everything is
    as expected. The server can then use the populated `ReadReq` to retrieve the requested
    file for the client.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnmarshalBinary`方法读取前2个字节2并确认操作码是读取请求的操作码。然后它读取所有字节直到第一个空字节3，并去除空字节分隔符4。结果字节串表示文件名。类似地，您读取模式，如果一切符合预期则返回`nil`。服务器随后可以使用填充好的`ReadReq`来为客户端检索请求的文件。'
- en: Data Packets
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据包
- en: Clients receive *data packets* in response to their read requests, provided
    the server was able to retrieve the requested file. The server sends the file
    in a series of data packets, each of which has an assigned block number, starting
    at 1 and incrementing with every subsequent data packet. The block number allows
    the client to properly order the received data and account for duplicates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端收到*数据包*作为其读取请求的响应，前提是服务器能够检索到请求的文件。服务器将文件分成一系列数据包发送，每个数据包都有一个分配的块号，从1开始，随后的每个数据包递增。块号帮助客户端正确地对接收到的数据进行排序，并处理重复数据包。
- en: All data packets have a payload of 512 bytes except for the last packet. The
    client continues to read data packets until it receives a data packet whose payload
    is less than 512 bytes, indicating the end of the transmission. At any point,
    the client can return an error packet in place of an acknowledgment, and the server
    can return an error packet instead of a data packet. An error packet immediately
    terminates the transfer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据包的有效负载大小为512字节，最后一个数据包除外。客户端会继续读取数据包，直到接收到一个有效负载小于512字节的数据包，表示传输结束。在任何时候，客户端都可以返回一个错误数据包来代替确认包，服务器也可以返回一个错误数据包来代替数据包。错误数据包会立即终止传输。
- en: '[Figure 6-2](#figure6-2) shows the format of a data packet.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-2](#figure6-2)显示了数据包的格式。'
- en: '![f06002](image_fi/500884c06/f06002.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](image_fi/500884c06/f06002.png)'
- en: 'Figure 6-2: Data packet structure'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：数据包结构
- en: Like the read request packet, the data packet’s first 2 bytes contain its operation
    code. The next 2 bytes represent the block number. The remaining bytes, up to
    512, are the payload.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取请求包类似，数据包的前2个字节包含其操作码。接下来的2个字节表示块号。其余字节（最多512字节）是有效负载。
- en: The server requires an acknowledgment from the client after each data packet.
    If the server does not receive a timely acknowledgment or an error from the client,
    the server will retry the transmission until it receives a reply or exhausts its
    number of retries. [Figure 6-3](#figure6-3) illustrates the initial communication
    between a client downloading a file from a TFTP server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器要求客户端在每个数据包后进行确认。如果服务器没有及时收到客户端的确认或错误，服务器将重试传输，直到收到回复或用尽重试次数。[图6-3](#figure6-3)展示了客户端从TFTP服务器下载文件的初步通信。
- en: '![f06003](image_fi/500884c06/f06003.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](image_fi/500884c06/f06003.png)'
- en: 'Figure 6-3: Downloading a file by using the Trivial File Transfer Protocol'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：使用简单文件传输协议下载文件
- en: Once the client has sent the initial read request packet, the server responds
    with the first block of data. Next, the client acknowledges receipt of block 1\.
    The server receives the acknowledgment and replies with the second block of data.
    But in this contrived example, the server does not receive a timely reply from
    the client, so it resends block 2\. The client receives block 2 and sends its
    acknowledgment. This back-and-forth continues until the server sends the last
    block with a payload of fewer than 512 bytes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端发送了初始读取请求包，服务器就会响应并发送第一块数据。接下来，客户端确认接收到块1。服务器收到确认后，回复第二块数据。但在这个模拟示例中，服务器没有及时收到客户端的回复，因此它重新发送了块2。客户端接收到块2并发送确认。这个来回过程会持续进行，直到服务器发送最后一块有效负载小于512字节的数据包。
- en: '[Listing 6-4](#listing6-4) details the data type that is used for the actual
    data transfer.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-4](#listing6-4)详细介绍了用于实际数据传输的数据类型。'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Data type and its binary marshaling method (*types.go* continued)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-4：数据类型及其二进制序列化方法（*types.go*继续）
- en: The `Data` struct 1 keeps track of the current block number and the data source.
    In this case, your payload is an `io.Reader` instead of a byte slice, the reasoning
    being that an `io.Reader` allows greater flexibility about where you retrieve
    the payload. You could just as easily use an `*os.File` object to read a file
    from the filesystem as you could use a `net.Conn` to read the data from another
    network connection. The `io.Reader` interface gives you options that a simple
    byte slice doesn’t. You’re relying on the reader to keep track of the bytes left
    to read, eliminating a lot of code you’d otherwise have to write.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data`结构体1跟踪当前块号和数据源。在这种情况下，负载是`io.Reader`，而不是字节切片，原因是`io.Reader`提供了更大的灵活性，允许你从不同来源获取负载。你可以像使用`*os.File`对象从文件系统读取文件一样，使用`net.Conn`对象从其他网络连接读取数据。`io.Reader`接口提供了简单字节切片无法提供的选项。你依赖读取器来跟踪剩余的字节数，这省去了你需要编写的大量代码。'
- en: Every call to `MarshalBinary`2 will return 516 bytes per call at most by relying
    on the `io.CopyN` function 3 and the `BlockSize` constant. Since you want `MarshalBinary`
    to modify the state, you need to use a pointer receiver. The intention is that
    the server can keep calling this method to get sequential blocks of data, each
    with an increasing block number, from the `io.Reader` until it exhausts the reader.
    Just like the client, the server needs to monitor the packet size returned by
    this method. When the packet size is less than 516 bytes, the server knows it
    received the last packet and should stop calling `MarshalBinary`. You’ll see this
    in action in the server code later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`MarshalBinary`方法时，最多会返回516个字节的数据，依赖于`io.CopyN`函数3和`BlockSize`常量。由于你希望`MarshalBinary`修改状态，因此需要使用指针接收器。其目的是服务器可以不断调用此方法，从`io.Reader`中获取顺序递增的块号的连续数据块，直到读取器耗尽。与客户端一样，服务器也需要监控此方法返回的数据包大小。当数据包大小小于516字节时，服务器就知道它已经接收到最后一个数据包，并应该停止调用`MarshalBinary`。你将在本章后面看到此方法在服务器代码中的实际应用。
- en: You may have recognized the potential for an integer overflow of the 16-bit,
    unsigned block number. If you send a payload larger than about 33.5MB (65,535
    × 512 bytes), the block number will overflow back to 0\. Your server will happily
    continue sending data packets, but the client may not be as graceful handling
    the overflow. You should consider mitigating overflow risks by limiting the file
    size the TFTP server will support so as not to trigger the overflow, recognizing
    that an overflow can occur and determining whether it is acceptable to the client,
    or using a different protocol altogether.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到16位无符号块号可能发生整数溢出的风险。如果你发送一个超过33.5MB（65,535 × 512字节）的有效负载，块号将会溢出并回绕到0。你的服务器将继续愉快地发送数据包，但客户端可能无法优雅地处理这一溢出。你应该考虑通过限制TFTP服务器支持的文件大小来减轻溢出风险，以避免触发溢出，识别溢出发生的可能性，并判断客户端是否可以接受，或者完全使用另一种协议。
- en: '[Listing 6-5](#listing6-5) finishes up the data type implementation with its
    binary unmarshaling method. This method follows the code in [Listing 6-4](#listing6-4).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-5](#listing6-5)完成了数据类型实现及其二进制反序列化方法的定义。该方法遵循[Listing 6-4](#listing6-4)中的代码。'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Data type implementation (*types.go* continued)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-5：数据类型实现（*types.go*续）
- en: To unmarshal data, you perform an initial sanity check 1 to determine whether
    the packet size is within the expected bounds, making it worth reading the remaining
    bytes. You then read the operation code 2 and check it, then the block number
    3. Finally, you stuff the remaining bytes into a new buffer 4 and assign it to
    the `Payload` field.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反序列化数据，首先需要进行初步的合理性检查1，以确定数据包的大小是否在预期范围内，确保读取剩余字节是值得的。然后读取操作码2并进行检查，接着读取块号3。最后，将剩余字节填充到一个新的缓冲区4，并将其分配给`Payload`字段。
- en: The client uses the block number to send a corresponding acknowledgment to the
    server and to properly order this block of data among the other received blocks
    of data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用块号向服务器发送相应的确认消息，并在其他接收到的数据块中正确排序这一数据块。
- en: Acknowledgments
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认
- en: '*Acknowledgment packets* are only 4 bytes long, as shown in [Figure 6-4](#figure6-4).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*确认数据包*的长度仅为4字节，如[图6-4](#figure6-4)所示。'
- en: '![f06004](image_fi/500884c06/f06004.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](image_fi/500884c06/f06004.png)'
- en: 'Figure 6-4: Acknowledgment packet structure'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：确认数据包结构
- en: As in the other types, the first 2 bytes represent the operation code. The final
    2 bytes contain the number of the acknowledged block.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型一样，前2个字节表示操作码。最后2个字节包含已确认的数据块号。
- en: '[Listing 6-6](#listing6-6) shows the entire implementation of the acknowledgment
    type, which follows [Listing 6-5](#listing6-5)’s code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-6](#listing6-6)展示了确认类型的完整实现，遵循[Listing 6-5](#listing6-5)的代码。'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: Acknowledgment type implementation (*types.go* continued)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 6-6：确认类型实现（*types.go*续）
- en: You represent an acknowledgment packet by using a 16-bit, unsigned integer 1.
    This integer is set to the acknowledged block number. The `MarshalBinary` and
    `UnmarshalBinary` methods should look familiar by this point. They handle marshaling
    the operation code and block number to a byte slice and populating an `Ack` object
    from bytes read from the network, respectively.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用一个16位的无符号整数1来表示确认数据包。该整数被设置为已确认的数据块号。到目前为止，`MarshalBinary`和`UnmarshalBinary`方法应该已经很熟悉了，它们分别处理将操作码和块号序列化为字节切片，以及从网络读取的字节填充到`Ack`对象中。
- en: Handling Errors
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: In TFTP, clients and servers convey errors by using an *error packet*, illustrated
    in [Figure 6-5](#figure6-5).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在TFTP中，客户端和服务器通过使用*错误数据包*来传递错误，如[图 6-5](#figure6-5)所示。
- en: '![f06005](image_fi/500884c06/f06005.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](image_fi/500884c06/f06005.png)'
- en: 'Figure 6-5: Error packet structure'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5：错误数据包结构
- en: Error packets consist of a 2-byte operation code, a 2-byte error code, an error
    message of variable length, and a terminating null byte.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 错误数据包由一个2字节的操作码、一个2字节的错误码、一个可变长度的错误消息和一个终止的空字节组成。
- en: '[Listing 6-7](#listing6-7) details the error type and its binary marshal method,
    a continuation of [Listing 6-6](#listing6-6).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-7](#listing6-7)详细描述了错误类型及其二进制序列化方法，这是[示例 6-6](#listing6-6)的延续。'
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Error type used for conveying errors between the client and server
    (*types.go* continued)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-7：用于在客户端和服务器之间传递错误的错误类型（*types.go*继续）
- en: 'Like the read request, the error type 1 contains the minimum data required
    to craft an error packet: an error code and an error message. The `MarshalBinary`
    method populates a bytes buffer following the byte sequence detailed in [Figure
    6-5](#figure6-5).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取请求类似，错误类型1包含构建错误数据包所需的最小数据：错误码和错误消息。`MarshalBinary`方法会按照[图 6-5](#figure6-5)中详细描述的字节顺序填充字节缓冲区。
- en: '[Listing 6-8](#listing6-8) completes the error type implementation with its
    binary unmarshaler method. This code is appended to the code in [Listing 6-7](#listing6-7).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-8](#listing6-8)通过其二进制反序列化方法完成了错误类型的实现。此代码附加到[示例 6-7](#listing6-7)中的代码。'
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-8: Error type’s binary unmarshaler implementation (*types.go* continued)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-8：错误类型的二进制反序列化实现（*types.go*继续）
- en: The `UnmarshalBinary` method is quite simple in that it reads and verifies the
    operation code 1, consumes the error code 2 and error message 3, and strips the
    trailing null byte 4.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnmarshalBinary`方法非常简单，它读取并验证操作码1，处理错误码2和错误消息3，并去掉末尾的空字节4。'
- en: The TFTP Server
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP 服务器
- en: Now you’ll write the server code, which will use the types you defined to interact
    with TFTP clients.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将编写服务器代码，使用你定义的类型与TFTP客户端进行交互。
- en: Writing the Server Code
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写服务器代码
- en: '[Listing 6-9](#listing6-9) describes your server type and the methods that
    allow it to serve incoming requests. The fact that your packet types implement
    the `encoding.BinaryMarshaler` and `encoding.BinaryUnmarshaler` interfaces means
    that your server code can act as a conduit between the network interface and these
    types, leading to simpler code. All your server must concern itself with is transferring
    byte slices between your types and the network connection. The logic in the type
    interfaces takes care of the rest.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-9](#listing6-9)描述了你的服务器类型以及允许其处理传入请求的方法。你的数据包类型实现了`encoding.BinaryMarshaler`和`encoding.BinaryUnmarshaler`接口，这意味着你的服务器代码可以充当网络接口和这些类型之间的桥梁，从而简化代码。你的服务器只需关注在你的类型和网络连接之间传输字节切片。类型接口中的逻辑会处理剩余部分。'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-9: Server type implementation (*server.go*)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-9：服务器类型实现（*server.go*）
- en: Our server maintains a payload 1 that it returns for every read request, a record
    of the number of times to attempt packet delivery 2, and a time-out duration between
    each attempt 3. The server’s `Serve` method accepts a `net.PacketConn` and uses
    it to read incoming requests 4. Closing the network connection will cause the
    method to return.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器维护一个有效负载1，它会在每个读取请求时返回，包括尝试数据包传输的次数2和每次尝试之间的超时持续时间3。服务器的`Serve`方法接受一个`net.PacketConn`并使用它来读取传入的请求4。关闭网络连接将导致该方法返回。
- en: The server reads up to 516 bytes from its connection and attempts to unmarshal
    the bytes to a `ReadReq` object 5. Since your server is read-only, it’s interested
    only in servicing read requests. If the data read from the connection is a read
    request, the server passes it along to a handler method in a goroutine 6. We’ll
    define that next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从其连接中读取最多516字节，并尝试将字节反序列化为`ReadReq`对象5。由于你的服务器是只读的，它只关心服务读取请求。如果从连接中读取的数据是读取请求，服务器将把它传递给goroutine中的处理方法6。我们接下来将定义该方法。
- en: Handling Read Requests
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理读取请求
- en: The handler ([Listing 6-10](#listing6-10)) accepts read requests from the client
    and replies with the server’s payload. It uses the features you built into your
    TFTP server’s type system to improve the reliability of the data transfer over
    UDP. The handler sends one data packet and waits for an acknowledgment from the
    client before sending another data packet. It also attempts to retransmit the
    current data packet when it fails to receive a timely reply from the client.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该处理程序（[Listing 6-10](#listing6-10)）接受来自客户端的读取请求，并回复服务器的有效载荷。它利用你在TFTP服务器类型系统中构建的功能，来提高UDP数据传输的可靠性。该处理程序发送一个数据包，并在发送下一个数据包之前等待客户端的确认。如果在预定时间内未收到客户端的回复，它还会尝试重新传输当前的数据包。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-10: Handling read requests (*server.go* continued)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-10: 处理读取请求（*server.go* 续）'
- en: This handler is a method 1 on your `Server` type that accepts a client address
    and a read request. It’s defined as a method because you need access to the `Server`’s
    fields. You then initiate a connection with the client by using `net.Dial`2. The
    resulting UDP connection object created with `net.Dial`, if you remember, will
    read only packets from the client, freeing you from having to check the sender
    address on every `Read` call. You prepare a data object 3 by using the server’s
    payload, then enter a `for` loop to send each data packet 4. This `for` loop will
    continue looping as long as the data packet size is equal to 516 bytes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该处理程序是`Server`类型上的一个方法1，接受客户端地址和读取请求。之所以定义为方法，是因为你需要访问`Server`的字段。然后，通过使用`net.Dial`2与你的客户端建立连接。记得，使用`net.Dial`创建的UDP连接对象将仅从客户端读取数据包，免去了你每次`Read`调用时都需要检查发送者地址的麻烦。你通过使用服务器的有效载荷来准备数据对象3，然后进入`for`循环发送每个数据包4。只要数据包大小等于516字节，该`for`循环将继续。
- en: After marshaling the data object to a byte slice, you enter the `for` loop 5
    meant to resend the data packet until you either exhaust the number of retries
    or successfully deliver the data packet. Writing the data packet to the network
    connection 6 updates the `n` loop variable with the number of bytes sent. If this
    value is 516 bytes, you iterate again when control passes back to the `for` loop
    4 labeled `NEXTPACKET`. If this value is less than 516 bytes, you break out of
    the loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据对象编组为字节切片后，你进入`for`循环5，旨在重新发送数据包，直到达到重试次数上限或成功传送数据包为止。将数据包写入网络连接6会更新`n`循环变量，记录已发送的字节数。如果该值为516字节，当控制权回到标记为`NEXTPACKET`的`for`循环4时，你将再次迭代。如果该值小于516字节，则跳出循环。
- en: Before you determine whether the transfer is complete, you must first verify
    that the client successfully received the last data packet. You read bytes from
    the client and attempt to unmarshal them into an `Ack` object or `Err` object.
    If you successfully unmarshal them into an `Err` object, you know the client returned
    an error, so you should log that fact and return early. An early return from this
    handler means the transmission terminated short of sending the entire payload.
    For our purposes, this is unrecoverable. The client would need to re-request the
    file to initiate another transfer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定传输是否完成之前，你必须首先验证客户端是否成功接收了最后一个数据包。你从客户端读取字节，并尝试将其反序列化为`Ack`对象或`Err`对象。如果成功将其反序列化为`Err`对象，则说明客户端返回了一个错误，此时应记录该事实并提前返回。提前返回意味着此处理程序在未传送整个有效载荷的情况下终止传输。就我们的目的而言，这是不可恢复的。客户端需要重新请求文件，以启动另一次传输。
- en: If you successfully unmarshal the bytes into an `Ack` object, you can then check
    the object’s `Block` value to determine whether it matches the block number of
    the current data packet 7. If so, you iterate around the `for` loop 4 and send
    the next packet. If not, you iterate around the inner `for` loop 5 and resend
    the current data packet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你成功地将字节反序列化为`Ack`对象，则可以检查该对象的`Block`值，以确定它是否与当前数据包7的块号匹配。如果匹配，则绕过`for`循环4并发送下一个数据包。如果不匹配，则绕过内部`for`循环5并重新发送当前数据包。
- en: Starting the Server
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'To start your TFTP server, you need to give the server two things: a file (its
    payload) and an address on which to listen for incoming requests ([Listing 6-11](#listing6-11)).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动TFTP服务器，你需要提供两个参数：一个文件（其有效载荷）和一个监听传入请求的地址（[Listing 6-11](#listing6-11)）。
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-11: Command line TFTP server implementation (*tftp.go*)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-11: 命令行TFTP服务器实现（*tftp.go*）'
- en: Once you’ve read the file 1 that your TFTP server will serve into a byte slice,
    you instantiate the server and assign the byte slice to the server’s `Payload`
    field 2. The last step is calling its `ListenAndServe` method to establish the
    UDP connection on which it will listen for requests. The `ListenAndServe` method
    3 calls the server’s `Serve` method for you, which listens on the network connection
    for incoming requests. The server will continue to run until you terminate it
    with a ctrl-C on the command line.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将TFTP服务器要提供的文件1读取到字节切片中，就可以实例化服务器并将字节切片分配给服务器的`Payload`字段2。最后一步是调用它的`ListenAndServe`方法，以在其将监听请求的UDP连接上建立连接。`ListenAndServe`方法3会为你调用服务器的`Serve`方法，该方法在网络连接上监听传入的请求。服务器将继续运行，直到你在命令行使用ctrl-C终止它。
- en: Downloading Files over UDP
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过UDP下载文件
- en: Now let’s try to download a file from the server you just wrote. First, you
    need to make sure you have a TFTP client installed. Windows has a native TFTP
    client that you can install through the Programs and Features section of the Control
    Panel by clicking the Turn Windows features on or off link. Select the **TFTP
    Client** checkbox and click the **OK** button to install it. Most Linux distributions
    have a TFTP client available for installation through the distribution’s package
    manager, and macOS has a TFTP client installed by default.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试从你刚刚写的服务器下载一个文件。首先，你需要确保安装了TFTP客户端。Windows有一个本地TFTP客户端，你可以通过控制面板中的“程序和功能”部分，点击“打开或关闭Windows功能”链接来安装。勾选**TFTP客户端**复选框，然后点击**确定**按钮来安装它。大多数Linux发行版通过其包管理器提供TFTP客户端，而macOS默认已安装TFTP客户端。
- en: 'This example uses Windows 10\. Start by running the TFTP server by running
    the code in [Listing 6-11](#listing6-11) in a terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用的是Windows 10。首先通过在终端中运行[列表6-11](#listing6-11)中的代码来启动TFTP服务器：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The server should bind to UDP port 69 on 127.0.0.1 by default. Port 69 is a
    privileged port, and you may need root permissions on Linux. You may need to first
    build the binary by using `go build tftp.go` and then run the resulting binary
    by using the `sudo` command to bind to port 69: `sudo ./tftp`. The TFTP server
    should log a message to standard output that indicates it’s listening.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器默认应该绑定到127.0.0.1上的UDP端口69。端口69是特权端口，你可能需要在Linux上使用root权限。你可能需要先使用`go build
    tftp.go`构建二进制文件，然后使用`sudo`命令运行生成的二进制文件，以便绑定到端口69：`sudo ./tftp`。TFTP服务器应该在标准输出上记录一条消息，指示它正在监听。
- en: 'From a separate terminal, execute the TFTP client, making sure to pass the
    `-i` argument to tell the server you wish to initiate a binary (octet) transfer.
    Remember, your TFTP server doesn’t care what the source filename is because it
    returns the same payload regardless of the requested filename. You’ll use *test.svg*
    in this example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个终端执行TFTP客户端，确保传递`-i`参数来告诉服务器你希望发起二进制（字节）传输。记住，TFTP服务器并不关心源文件名是什么，因为它会根据请求的文件名返回相同的负载。在这个例子中，你将使用*test.svg*：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Almost immediately upon pressing enter, the client should report the transfer
    was successful. The TFTP server’s terminal should show its progress as well:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在按下回车键后，客户端应该报告传输成功。TFTP服务器的终端也应该显示其进度：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can confirm that the downloaded file is the same as the payload provided
    to the TFTP server by comparing *test.svg*’s checksum with the checksum of the
    server’s *payload.svg*. A *checksum* is a calculated value used to verify the
    integrity of a file. If two files are identical, they will have equivalent checksums.
    Linux and macOS both have various command line utilities for generating checksums,
    but you’ll use a pure Go implementation, as shown in [Listing 6-12](#listing6-12).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将下载的文件与TFTP服务器的*payload.svg*的校验和进行比较来确认下载的文件与提供给TFTP服务器的负载相同。*校验和*是一个计算值，用于验证文件的完整性。如果两个文件相同，它们将具有相同的校验和。Linux和macOS都有多种命令行工具可以生成校验和，但你将使用一个纯Go实现，如[列表6-12](#listing6-12)所示。
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-12: Generating SHA512/256 checksums for given command line arguments
    (*sha512-256sum.go*)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-12：为给定的命令行参数生成SHA512/256校验和（*sha512-256sum.go*）
- en: This bit of code will accept one or more file paths as command line arguments
    1 and generate SHA512/256 checksums 3 from their contents 2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将接受一个或多个文件路径作为命令行参数1，并从它们的内容2生成SHA512/256校验和3。
- en: A SHA512/256 checksum is a SHA512 checksum truncated to 256 bits. Calculating
    SHA512 on a 64-bit machine is faster than calculating a SHA256 checksum, because
    the SHA512 computation uses 64-bit words, whereas SHA256 uses 32-bit words. By
    truncating SHA512 to 256 bits, you eliminate a length extension hashing attack
    that SHA512 is vulnerable to by itself. SHA512/256 isn’t necessary here since
    you’re not using the checksum beyond verifying the integrity of a file, but you
    should be familiar with it, and it should be on your short list of hashing algorithms.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SHA512/256校验和是通过截断SHA512校验和得到的256位版本。在64位机器上计算SHA512比计算SHA256校验和更快，因为SHA512计算使用的是64位字，而SHA256使用的是32位字。通过将SHA512截断为256位，你消除了SHA512本身容易受到的长度扩展哈希攻击。SHA512/256在这里并不是必需的，因为你只是用它来验证文件的完整性，但你应该了解它，并将其列为你的哈希算法备选方案之一。
- en: 'You can use the code from [Listing 6-12](#listing6-12) in [Listing 6-13](#listing6-13)
    to verify that the file you downloaded (*test.svg*) is identical to the file the
    server sent (*payload.svg*). You’ll continue to use Windows as your target platform,
    but the code will work on Linux and macOS without changes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用[清单6-12](#listing6-12)中的代码在[清单6-13](#listing6-13)中验证你下载的文件（*test.svg*）是否与服务器发送的文件（*payload.svg*）相同。你将继续使用Windows作为目标平台，但这段代码在Linux和macOS上也能正常工作，无需修改：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-13: Generating SHA512/256 checksums for *test.svg* and *payload.svg*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-13：生成*test.svg*和*payload.svg*的SHA512/256校验和
- en: As you can see, the *test.svg* checksum 1 is equal to the *payload.svg* checksum
    2.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*test.svg*的校验和1等于*payload.svg*的校验和2。
- en: In this case, the *test.svg* file is an image of a gopher from Egon Elbre’s
    excellent *gophers* repository on GitHub ([https://github.com/egonelbre/gophers/](https://github.com/egonelbre/gophers/)).
    If you opened the file in a web browser, you’d see the image in [Figure 6-6](#figure6-6).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*test.svg*文件是Egon Elbre在GitHub上的优秀*gophers*库中的一张gopher图像（[https://github.com/egonelbre/gophers/](https://github.com/egonelbre/gophers/)）。如果你在浏览器中打开该文件，你会看到[图6-6](#figure6-6)中的图像。
- en: Although you transferred the payload over localhost and don’t expect data loss
    or corruption, the client and server still acknowledged every data packet, ensuring
    the proper delivery of the payload.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你通过本地回环地址传输了有效载荷，并且不预期数据丢失或损坏，但客户端和服务器仍然确认了每一个数据包，确保了有效载荷的正确传输。
- en: '![f06006](image_fi/500884c06/f06006.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f06006](image_fi/500884c06/f06006.png)'
- en: 'Figure 6-6: Downloaded payload from the TFTP server'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：从TFTP服务器下载的有效载荷
- en: What You’ve Learned
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: UDP can be made reliable at the application level, as evident by the Trivial
    File Transfer Protocol. TFTP uses a combination of data packet sequence numbers
    and acknowledgments to ensure that the client and server agree on all transferred
    data, redelivering packets as necessary.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: UDP可以在应用层实现可靠性，正如琐碎文件传输协议（TFTP）所展示的那样。TFTP结合了数据包序列号和确认机制，以确保客户端和服务器在所有传输的数据上达成一致，并在必要时重新传输丢失的数据包。
- en: Liberal use of Go’s binary marshaling and unmarshaling interfaces allow you
    to implement types that make communication using TFTP straightforward. Each TFTP
    type meant for delivery over UDP implements the `encoding.BinaryMarshaler` interface
    to marshal its data into a format suitable for writing to a network connection.
    Likewise, each type you expect to read from a network connection should implement
    the `encoding.BinaryUnmarshaler` interface. Successfully unmarshaling binary data
    to your custom type allows you to determine what binary data was received and
    that it is correct.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Go的二进制序列化和反序列化接口的广泛使用使得你能够实现一些类型，从而使得使用TFTP进行通信变得简单。每个通过UDP传输的TFTP类型都实现了`encoding.BinaryMarshaler`接口，以便将其数据序列化为适合写入网络连接的格式。同样，任何你期望从网络连接读取的类型都应该实现`encoding.BinaryUnmarshaler`接口。成功地将二进制数据反序列化为自定义类型，可以帮助你确定接收到的二进制数据及其正确性。
