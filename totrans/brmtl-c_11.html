<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="161" id="Page_161"/>10</span><br/>
<span class="ChapterTitle">Interrupts</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">The two main methods for handling I/O are <em>polling</em>, which repeatedly asks the device whether it has any data ready, and <em>interrupts</em>, which are when the device interrupts normal workflow to tell you it’s ready. This chapter describes the difference between polling and interrupts as well as explains how interrupts work so you can use them to write a string to the serial port more efficiently (yes, “Hello World” again).</p>
<h2 id="h1-501621c10-0001">Polling vs. Interrupts</h2>
<p class="BodyFirst">Let’s consider how polling and interrupts would work in the case of the telephone. With polling, the ringer is turned off, and you must check the phone every 10 seconds to see whether a call is coming in. You must sit by <span epub:type="pagebreak" title="162" id="Page_162"/>the phone and not get bored easily. This method is what we used in our previous serial program in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, which basically went like the following dialogue:</p>
<ol class="none">
<li>“Are you busy?” “Yes.”</li>
<li>“Are you busy?” “Yes.”</li>
<li>“Are you busy?” “Yes.”</li>
<li>“Are you busy?” “No.” “Here’s the next character.”</li>
</ol>
<p>The computer is stuck in a polling loop, waiting for the UART status register to indicate that the UART is ready for the next character. At this point, the computer has nothing else to do and doesn’t get bored. The main advantages of polling are that it’s easy to understand and implement.</p>
<p>Let’s go back to the telephone again, but this time we’ll use the interrupt method. You don’t sit by the phone continually checking whether a call is coming in. Instead, you go about your normal business until the phone rings (an interrupt occurs). Then you drop everything, race to the phone, and pick up it—only to discover that it’s another telemarketing call for something you wouldn’t buy in a million years.</p>
<p>The key sequence of events in the interrupt scenario is as follows:</p>
<ol class="decimal">
<li value="1">We go about our normal work.</li>
<li value="2">We get an interrupt (the phone rings).</li>
<li value="3">We pick up the phone (service the interrupt), shout “No, I don’t want to buy a combination shaving brush and fountain pen,” and hang up.</li>
<li value="4">We resume our normal work where we left off.</li>
</ol>
<h2 id="h1-501621c10-0002">Interrupts for Serial I/O</h2>
<p class="BodyFirst">We can send characters to the UART only when the transmit data register (TDR) is empty. <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a> shows a block diagram of a portion of the UART to illustrate how the TDR works.</p>
<figure>
<img src="image_fi/501621c10/f10001.png" alt="f10001" class=""/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: UART transmission hardware</p></figcaption>
</figure>
<p>When we want to send a character, we dump it in the TDR, which holds 8 bits. The character is then dumped into the <em>transmit shift register (TSR)</em>, which holds 10 bits. The 2 extra bits are the start bit at the beginning of the character and the stop bit at the end of the character. The TSR then sends the data out the <em>transmit serial line (TX)</em> one bit at a time.</p>
<p><span epub:type="pagebreak" title="163" id="Page_163"/>When the data is moved from the TDR to the TSR, the TDR becomes empty and is ready to receive another character.</p>
<p>The polling loop we’ve been using looks like the following:</p>
<pre><code>// Block until the transmit empty (TXE) flag is set.
while ((uartHandle.Instance-&gt;ISR &amp; UART_FLAG_TXE) == 0)
    continue;</code></pre>
<p>In English, this says, “Are you empty yet? Are you empty yet? Are you empty yet?” And it’s just as annoying in C code as it is in English. Again, polling’s main advantage is its simplicity.</p>
<p>The other way to transmit characters is to tell the system we want an interrupt when the UART is ready to receive another character. An interrupt function is called automatically when something occurs. In our case, we want an interrupt when the TDR is empty.</p>
<p>With interrupts, we tell the processor, “I’m going to go off and do useful work. When the TDR is empty, I want you to interrupt the normal flow and call an <em>interrupt routine</em> function, so I can give you the next character.”</p>
<h2 id="h1-501621c10-0003">Interrupt Routines</h2>
<p class="BodyFirst">When an interrupt occurs, the CPU calls an interrupt routine function, located at a fixed address determined by the CPU’s design. Early CPUs had <em>one</em> address for all interrupts, so the code had to go through a number of checks to see what had interrupted:</p>
<pre><code>if (diskInterrupt)      { handleDiskInterrupt(); return;}
if (serialInterrupt)    { handleSerialInterrupt(); return;}
if (keyboardInterrupt)  { handleKeyboardInterrupt(); return;}
if (mouseInterrupt)     { handleMouseInterrupt(); return;}
logUnknownInterrupt();</code></pre>
<p>Nowadays, even a simple chip can have many different devices. Checking all of them to see which one interrupted is a time-consuming process. As a result, chips (including our ARM chip), now use <em>vectored interrupts</em>, which means each peripheral gets its own interrupt address. Interrupts from UART1 will call an interrupt routine at one address, while interrupts from UART2 will go to another (specifically <code>USART2_IRQHandler</code>), and so on for other peripheral devices.</p>
<p>The interrupt vector is defined in the <em>startup/startup_stm32f030x8.S</em> file:</p>
<pre><code>g_pfnVectors:
  .word  _estack
  .word  Reset_Handler
  .word  NMI_Handler
  .word  HardFault_Handler
# Many more handlers
  .word  USART1_IRQHandler              /* USART1 */
  .word  USART2_IRQHandler              /* USART2 */</code></pre>
<p><span epub:type="pagebreak" title="164" id="Page_164"/>Later, the code defines the <code>USART2_IRQHandler</code> symbol:</p>
<pre><code>  .weak      USART2_IRQHandler
  .thumb_set USART2_IRQHandler,Default_Handler</code></pre>
<p>The second directive (<code>.thumb_set</code>) defines the procedure <code>USART2_IRQHandler</code> to be the same as <code>Default_Handler</code>.</p>
<p>The first <code>.weak</code> directive defines it as a <em>weak symbol</em>. If it were a regular symbol and we tried to define our own <code>USART2_IRQHandler</code>, the linker would abort with a <code>Duplicate symbol</code> error message. However, because the symbol is weak, the linker will throw away the weak definition and use the one that we provide.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The STM documentation sometimes labels our serial I/O port as both a UART (asynchronous I/O) and a USART (synchronous I/O) port. The port can do either one depending on configuration. Thus, we have one serial I/O port that has two names: USART and UART. It’d just be too easy if they picked one name and stuck to it.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The <em>startup/startup_stm32f030x8.S</em> file defines <code>Default_Handler</code> later:</p>
<pre><code>    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop</code></pre>
<p>The default response to an interrupt is to loop forever, making the machine almost totally useless (I say “almost totally useless” because the machine will still respond to the debugger and a reset).</p>
<p>We’ll write our own <code>USART2_IRQHandler</code> to respond when the TDR is empty and thereby replace the default handler with something more useful.</p>
<h2 id="h1-501621c10-0004">Writing a String with Interrupts</h2>
<p class="BodyFirst">Now let’s change our serial I/O program from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> so that it uses interrupts instead of polling to write a string. All that’s communicated between the upper layer (the main program) and the lower layer (interrupt routine) is a single global variable:</p>
<pre><code>const char* volatile usart2String = NULL;     // The string we are sending</code></pre>
<p>The <code>const</code> qualifier tells C that the character data is constant and we’ll never attempt to change it. The <code>volatile</code> qualifier tells C that this variable may be changed at any time by something outside the flow of a normal C program, such as an interrupt function.</p>
<p>To clarify, because C’s syntax is a little complex at this point, the <code>const</code> appears before the <code>char</code> declaration and means that the character data is constant. It does not appear after the pointer operator (<code>*</code>), so the pointer is <span epub:type="pagebreak" title="165" id="Page_165"/>not constant. The <code>volatile</code> modifier appears after the pointer operator, indicating the pointer may be changed. The lack of the <code>const</code> modifier after the pointer operator means that the program can change this value.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	It is possible to have a <code>const volatile</code> variable, which would tell C that the program cannot change the value of the variable, but something outside the scope of the program can. For example, the UART receive register can be <code>const volatile</code>. We can’t change it, but every time a character comes in, it changes.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>We need to be careful with any variables used by both layers. Fortunately, for this example, that’s just one variable, <code>usart2String</code>. The following lists show the workflow for that variable:</p>
<p class="ListHead"><b>Upper Layer (Main Program)</b></p>
<ol class="decimal">
<li value="1">Wait for <code>usart2String</code> to become <code>NULL</code>.</li>
<li value="2">Point it to the string we want to send to the output.</li>
<li value="3">Send the first character.</li>
<li value="4">Increment the pointer.</li>
<li value="5">Enable the UART interrupt.</li>
</ol>
<p class="ListHead"><b>Lower Layer (Interrupt)</b></p>
<ol class="decimal">
<li value="1">If we’ve reached the end of the string, set <code>usart2String</code> to <code>NULL</code>.</li>
<li value="2">Acknowledge that the UART received the interrupt.</li>
<li value="3">Send the character pointed to by the string.</li>
<li value="4">Increment the pointer.</li>
</ol>
<p>Both the upper and lower layers increment the pointer. We need to be very careful when it comes to enabling the interrupt to make sure both layers don’t try to use the pointer at the same time. The upper layer won’t do anything until <code>usart2String == NULL</code>, and the lower layer sets <code>usart2String</code> to <code>NULL</code> only when it has run out of data and disables the UART2 interrupt. The upper layer protects itself by not enabling interrupts until after it performs the increment. Thus, the interrupt routine cannot monkey with the code.</p>
<p>This analysis is extremely important. When it’s not done or not done properly, the program will fail, and the failures will occur at random times with random results. These results pose an extremely difficult, debug-resistant problem.</p>
<p>I actually spent about three years finding one of these bugs. The problem occurred only for one customer and only about once every two months. We were completely unable to reproduce it in the lab. Fortunately, the customer was very mellow and willing to work with us on the solution. Later in this chapter, we’ll explore what happens when this analysis is not done and consider some techniques for diagnosing interrupt-related bugs.</p>
<p><a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a> contains the interrupt-driven serial I/O program.</p>
<pre><code><span epub:type="pagebreak" title="166" id="Page_166"/>/**
  * @brief   Write Hello World to the serial I/O.
  * Use interrupts instead of polling.
*/
  
#include &lt;stdbool.h&gt;
#include "stm32f0xx_nucleo.h"
#include "stm32f0xx.h"
  
const char hello[] = "Hello World!\r\n";   // The message to send
int current; // The character in the message we are sending
  
UART_HandleTypeDef uartHandle;      // UART initialization

<var>... Error_Handler same as Listing 9-3 ...</var>

const char* volatile usart2String = NULL;       // The string we are sending
/**
 * Handle the USART2 interrupt.
 *
 * Magically called by the chip's interrupt system.
 * Name is fixed because of the startup code that
 * populates the interrupt vector.
 */
void USART2_IRQHandler(void)
{
    if ((uartHandle.Instance-&gt;ISR &amp; USART_ISR_TXE) != 0) {
        // This should never happen, but we don't want to crash if it does.
        if (usart2String == NULL) {
            // Turn off interrupt.
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
            return;
        }
        if (*usart2String == '\0') {
            usart2String = NULL;        // We're done with the string.
            // Turn off interrupt.
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
            return;
        }
        uartHandle.Instance-&gt;TDR = *usart2String; // Send character to the UART.
        ++usart2String;              // Point to next character.
        return;
    }
    // Since the only interrupt we enabled was TXE, we should never
    // get here. When we do enable other interrupts, we need to put
    // code to handle them here.
}
/**
 * Our version of puts
 *
 * Outputs the exact string given to the output
 *
 * @param str String to send
 *
<span epub:type="pagebreak" title="167" id="Page_167"/> * @note Assumes that str is not null and not
 * pointing to the empty string
 */
void myPuts(const char* str)
{
    // If someone is sending a string, wait for it.
    while (usart2String != NULL)
        continue;
  
    // Tell the interrupt route what string to use.
    usart2String = str;
  
    uartHandle.Instance-&gt;TDR = *usart2String;  // Send character to the UART.
    ++usart2String;             // Point to next character.
    // Enable the interrupt.
    uartHandle.Instance-&gt;CR1 |= USART_CR1_TXEIE;
}

<var>... led2_Init and uart2_Init, same as Listing 9-3 ...</var>

int main(void)
{
    HAL_Init(); // Initialize hardware.
    led2_Init();
    uart2_Init();
    // Tell the chip that we want the interrupt vector
    // for USART2 to be enabled.
    NVIC_EnableIRQ(USART2_IRQn);
  
    // Keep sending the message for a long time.
    for (;;) {
        myPuts(hello);
        HAL_Delay(500);
    }
}

<var>... HAL_UART_MspInit and HAL_UART_MspDeInit, same as Listing 9-3 ...</var></code></pre>
<p class="CodeListingCaption"><em><a id="listing10-1">Listing 10-1</a>: 10.serial.int/main.c</em></p>
<h3 id="h2-501621c10-0001">Program Details</h3>
<p class="BodyFirst"><a href="#listing10-1">Listing 10-1</a> looks a lot like the serial I/O program from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, because setting up the I/O system is the same, with a lot of extra little details. But in this case, we added something new:</p>
<pre><code>int main(void)
{
    HAL_Init(); // Initialize hardware
    led2_Init();
    uart2_Init();
    // Tell the chip that we want the interrupt vector
    // for USART2 to be enabled.
    NVIC_EnableIRQ(USART2_IRQn);</code></pre>
<p><span epub:type="pagebreak" title="168" id="Page_168"/>The <code>NVIC_EnableIRQ</code> function initializes the <em>nested vectored interrupt controller (NVIC)</em>, which is a bit of hardware that decides what the processor does when it receives an interrupt and enables the USART2 interrupt. When the processor is reset, it turns off all interrupts, so we need to tell it that we want USART2 to interrupt it.</p>
<p>Now let’s look at the <code>myPuts</code> function, which sends a string (instead of a single character, like <code>myPutchar</code> from <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>) to the serial device:</p>
<pre><code>void myPuts(const char* str)
{
    // If someone is sending a string, wait for it.
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> while (usart2String != NULL)
        continue;

    // Tell the interrupt route what string to use.
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> usart2String = str;

  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> uartHandle.Instance-&gt;TDR = *usart2String;  // Send character to the UART.
    ++usart2String;             // Point to next character.
    // Enable the interrupt.
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> uartHandle.Instance-&gt;CR1 |= USART_CR1_TXEIE;
}</code></pre>
<p>The first thing we do is wait for the previous string to finish <span class="CodeAnnotation" aria-label="annotation1">1</span>. We know that if <code>usart2String</code> is not <code>NULL</code>, the interrupt routine is active and we should wait until the previous string is transmitted. When it becomes <code>NULL</code>, the interrupt routine is inactive and we can start our transmission.</p>
<p>When we do get our turn, we tell the interrupt function what string we are transmitting <span class="CodeAnnotation" aria-label="annotation2">2</span>, and then we transmit the first character <span class="CodeAnnotation" aria-label="annotation3">3</span>. As a final step, we enable the transmit data buffer empty interrupt <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>Several symbols control what interrupts are enabled. The <code>USART_CR1_TXNEIE</code> bit tells the UART to interrupt when the transmit data buffer is empty. Here are some other symbols to note:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_CR1_IDLEIE</code></span></span>  IDLE interrupt enable</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_CR1_RXNEIE</code></span></span>  Receive interrupt enable</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_CR1_TCIE</code></span></span>  Transmission complete interrupt enable (interrupt when the character has gone out, not when we first load a character into the transmission register)</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_CR1_PEIE</code></span></span>  Parity error interrupt enable</li>
</ol>
<p>Once we send the first character, the TDR is filled. When it is transferred to the TSR, the TDR will be empty and we’ll get an interrupt. From here on, the interrupt routine does the work.</p>
<p>The actual interrupt routine is as follows:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> void USART2_IRQHandler(void)
{
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> if ((uartHandle.Instance-&gt;ISR &amp; USART_ISR_TXE) != 0) {
        // This should never happen, but we don't want to crash if it does.
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if (usart2String == NULL) {
<span epub:type="pagebreak" title="169" id="Page_169"/>            // Turn off interrupt.
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
            return;
        }
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if (*usart2String == '\0') {
            usart2String = NULL;        // We're done with the string.
            // Turn off interrupt.
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
            return;
        }
      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> uartHandle.Instance-&gt;TDR = *usart2String; // Send character to the UART.
      <span class="CodeAnnotationCode" aria-label="annotation6">6</span> ++usart2String;         // Point to next character.
        return;
    }
    // Since the only interrupt we enabled was TXE, we should never
    // get here. When we do enable other interrupts, we need to put
    // code to handle them here.
}</code></pre>
<p>The function declaration uses a magic name that identifies it as the interrupt routine <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>If the function gets called, we know we have an interrupt from USART2, but we don’t know what type of interrupt it is because the USART has multiple types of interrupts:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_TXE</code></span></span>  TDR<code> </code>empty</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_CTSIF</code></span></span>  CTS interrupt</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_TC</code></span></span>  Transmission complete</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_RXNE</code></span></span>  Receive data register not empty (data ready to be read)</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_ORE</code></span></span>  Overrun error detected</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_IDLE</code></span></span>  Idle line detected</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_FE</code></span></span>  Framing error</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_PE</code></span></span>  Parity error</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_NE</code></span></span>  Noise flag</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_CMF</code></span></span>  Character match</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>USART_ISR_TXE</code></span></span>  Receiver timeout</li>
</ol>
<p>All of these interrupts will result in a call to <code>USART2_IRQHandler</code>.</p>
<p>First, we need to check whether we have a transmit buffer empty interrupt <span class="CodeAnnotation" aria-label="annotation2">2</span>. Our interrupt function should never be called with <code>usart2String</code> set to <code>NULL</code>, but “should” and “reality” are vastly different, so we put in a little bit of paranoia to make sure we don’t crash if something goes wrong <span class="CodeAnnotation" aria-label="annotation3">3</span>. The variable <code>usart2String</code> should never be <code>NULL</code> at this point, but if it is, we don’t want to cause trouble.</p>
<p>Without that check, we might try to deference a <code>NULL</code> pointer <span class="CodeAnnotation" aria-label="annotation4">4</span>. Dereferencing a <code>NULL</code> pointer is illegal, and the STM32 is nice enough to have hardware to check for this condition. When it occurs, the STM32 <span epub:type="pagebreak" title="170" id="Page_170"/>generates a <em>memory fault interrupt</em>. In other words, the interrupt handler is being interrupted, and control transfers to the memory fault interrupt handler. However, we haven’t written one, so the default handler is executed. As mentioned previously, the default handler locks up the system until you reset it. To protect ourselves against an improper <code>usart2String</code>, when we see it, we do the safest thing, which is to turn off the interrupt and do nothing else <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Next, we check to see whether we’ve run out of string. If we have, we <code>NULL</code> out the string to signal to the top level that we’re done and to turn off interrupts. Otherwise, we know we have data for the UART and that the TDR is empty, so we dump a character into it <span class="CodeAnnotation" aria-label="annotation5">5</span>. Once we’ve sent the character, we need to point to the next one for the next time we get interrupted, and then return to the main program <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<p>At this point, the TDR is full, and the UART is sending characters. The interrupt route has nothing more to do, so it will return and normal execution will resume. When the character is sent and the TDR is empty, we’ll get another interrupt, which will continue until we run out of string and turn off the interrupt.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The ARM chip is nice in that an ordinary procedure can serve as an interrupt routine. The chip does the saving and restoring of all the state needed to execute the routine safely. Other chips are not so nice. For example, the PIC family of processors requires the use of a keyword interrupt (a PIC extension) before each interrupt routine: <code>interrupt PIC_GPIO_Interrupt(void)</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The hardware engineers at STMicroelectronics have helpfully explained this process with a diagram (see <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a>).</p>
<figure>
<img src="image_fi/501621c10/f10002.png" alt="f10002" class=""/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: USART interrupt mapping</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="171" id="Page_171"/>This diagram shows that if the TCIE (transmit character interrupt enable) bit is on <span class="CodeAnnotation" aria-label="annotation1">1</span> and a character has been transmitted (TC) <span class="CodeAnnotation" aria-label="annotation2">2</span>, the output of the AND gate is true <span class="CodeAnnotation" aria-label="annotation3">3</span>. This result is combined with the output of three other interrupts, and if any one is true (OR gate), the result <span class="CodeAnnotation" aria-label="annotation4">4</span> is true. Then that result is combined with the output of another OR gate <span class="CodeAnnotation" aria-label="annotation5">5</span> for all the other signals, and the result of the last OR gate is the USART interrupt signal. Note that the diagram is meant to simplify this process. If you want to know what the alphabet soup of inputs mean, read the 800-page reference manual for this processor.</p>
<h3 id="h2-501621c10-0002">Interrupt Hell</h3>
<p class="BodyFirst">Interrupts are extremely powerful tools when it comes to controlling hardware as well as dealing with events in real time. However, using interrupts can cause a number of unique and difficult problems to occur.</p>
<p>First, they can interrupt normal program flow at any time. For example, consider the following code:</p>
<pre><code>i = 5;
if (i == 5) {</code></pre>
<p>What’s the value of <code>i</code> after this statement is executed? The answer is obviously 5, unless an interrupt routine just executed and modified it:</p>
<pre><code>i = 5;
←----- interrupt triggers, i set to 6.
if (i == 5) { // No longer true</code></pre>
<p>Second, interrupt routines execute asynchronously, which means they execute whenever they feel like it, so any bugs caused by poorly written interrupt routines can be difficult to reproduce. I’ve seen cases where a bug occurred only randomly after about two weeks of testing because the interrupt had to occur exactly when one of two instructions was executing—that’s two out of the tens of thousands in the code. It took a lot of testing to stumble upon this problem.</p>
<p>Because of the inherent difficulties with interrupt routines, it pays to give them a lot of respect. The most important design rule when dealing with interrupt routines is to keep them small and simple, because the less the routine does, the less there is that can go wrong. It’s better to leave the “thinking” to the higher-level code where debuggers work nicely and where reproducibility is not a problem.</p>
<p>Interrupt routines also need to execute quickly, because while an interrupt routine is executing, other interrupts are held off until the routine is finished. If you take a long time in an interrupt routine that’s reading a character from UART1, another device, such as UART2, might lose data because its interrupt couldn’t get serviced in time.</p>
<h2 id="h1-501621c10-0005"><span epub:type="pagebreak" title="172" id="Page_172"/>Using a Buffer to Increase Speed</h2>
<p class="BodyFirst">The system we just used has some limits. It can transmit only one message at a time. Suppose we wanted to output multiple short messages. Each one would have to wait until the previous one finished. Here’s an example:</p>
<pre><code>myPuts("There are ");
if (messageCount == 0)
   myPuts(" no ");              // Blocks waiting on previous message
else
   myPuts(" some ");            // Blocks waiting on previous message
myPuts("messages waiting\r\n"); // Blocks waiting on previous message</code></pre>
<p>One solution to this problem is to create a <em>buffer</em> to hold the character data until the interrupt routine can service it. Doing that adds complexity to the application, but it increases the speed at which your top-level program can send data.</p>
<p>Using serial I/O means considering the general trend of speed versus simplicity. The polling version was very simple and slow. The single string interrupt version was faster but more complex. The buffer system we are using now is much faster and much more complex. This trend is true for most programs.</p>
<p>For this problem, let’s go back to the buffer. We’ll use a <em>circular buffer</em> that has the following basic structure:</p>
<pre><code>struct circularBuffer {
    uint32_t putIndex;      // Where we will put the next character
    uint32_t getIndex;      // Where to get the next character
    uint32_t nCharacters;   // Number of characters in the buffer
    char data[BUFFER_SIZE]; // The data in the buffer
}</code></pre>
<p>It’s called a circular buffer because the indices wrap. In other words, after a character is put in the last element of data, the <code>putIndex</code> will wrap from 7 (<code>BUFFER_SIZE-1</code>) to 0.</p>
<p>Graphically, this looks like <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a>.</p>
<figure>
<img src="image_fi/501621c10/f10003.png" alt="f10003" class=""/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: A circular buffer in action</p></figcaption>
</figure>
<p>Our implementation is going to contain a deliberate nasty mistake, so we can look at techniques and procedures for finding such mistakes in a small, controlled program. I’ll show the symptoms of the bug, the diagnostic techniques used to locate it, and the fix as we go through the program.</p>
<p><span epub:type="pagebreak" title="173" id="Page_173"/>The first time I encountered a problem like this was about 30 years ago. It wasn’t in a 200-line demonstration program; it was in the BSD Unix kernel in a serial module with tens of thousands of lines. It occurred about once every three to seven days randomly and took three engineers two months to find it. To make matters worse, it was processor-dependent and didn’t occur on the VAX processor that ran the original BSD.</p>
<p>The top-level program (the sender) puts data in the buffer. The lower-level interrupt routine (the receiver) removes data from the buffer.</p>
<p>In pseudocode, the sender’s job is as follows:</p>
<pre><code>If the buffer is full, wait.
Put a character in the buffer at putIndex.
Move putIndex up one, wrapping if needed.
Increment the number of characters in the buffer.</code></pre>
<p>And the receiver’s job is as follows:</p>
<pre><code>Get a character from the buffer at getIndex.
Increment getIndex, wrapping as needed.
Decrement the number of characters in the buffer.</code></pre>
<h3 id="h2-501621c10-0003">Sending Function</h3>
<p class="BodyFirst">To use a circular buffer, we have to go back to sending one character at a time with another version of <code>myPutchar</code>. Let’s look at the code doing the sending:</p>
<pre><code>void myPutchar(const char ch)
{
    // Wait until there is room.
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> while (buffer.nCharacters == BUFFER_SIZE)
        continue;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> buffer.data[buffer.putIndex] = ch;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> ++buffer.putIndex;
    if (buffer.putIndex == BUFFER_SIZE)
        buffer.putIndex = 0;

    // We've added another character.
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> ++buffer.nCharacters;
    // Now we're done.
    
    // Enable the interrupt (or reenable it).
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> uartHandle.Instance-&gt;CR1 |= USART_CR1_TXEIE;
}</code></pre>
<p>In the beginning, we wait until there is room for at least one character in the buffer <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then we dump the character in the buffer <span class="CodeAnnotation" aria-label="annotation2">2</span>. The <code>putIndex</code> advances by one and wraps back to 0 if necessary <span class="CodeAnnotation" aria-label="annotation3">3</span>.The number of characters in the buffer has increased, so we increment the <code>nCharacters</code> count in the buffer structure <span class="CodeAnnotation" aria-label="annotation4">4</span>. Finally, we enable the interrupt <span class="CodeAnnotation" aria-label="annotation5">5</span>. If we are transmitting, the interrupt may already be enabled. Enabling it again won’t cause problems.</p>
<h3 id="h2-501621c10-0004"><span epub:type="pagebreak" title="174" id="Page_174"/>Interrupt Routine</h3>
<p class="BodyFirst">The interrupt routine reads the data from the buffer and transmits it to the UART. If a character is in the buffer, the routine removes it and sends it to the UART. If nothing is in the buffer, the routine turns off the interrupt.</p>
<p>Here’s the code for this procedure:</p>
<pre><code>void USART2_IRQHandler(void)
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if ((uartHandle.Instance-&gt;ISR &amp; USART_ISR_TXE) != 0) {
        if (buffer.nCharacters == 0) {
            // Turn off interrupt.
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
            return;
        }
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> // Send to UART.
        uartHandle.Instance-&gt;TDR = buffer.data[buffer.getIndex];
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> ++buffer.getIndex;
        if (buffer.getIndex == BUFFER_SIZE)
            buffer.getIndex = 0;

      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> --buffer.nCharacters;

      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> if (buffer.nCharacters == 0)
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
        return;
    }
    // Since the only interrupt we enabled was TXE, we should
    // never get here. When we do enable other interrupts,
    // we need to put the code to handle them here.
}</code></pre>
<p>First, we check to see whether the device has run out of data. If it has, we shut down the interrupt until we get more data from the upper level <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then we send the character <span class="CodeAnnotation" aria-label="annotation2">2</span>, move the <code>getIndex</code> up one, and wrap if needed <span class="CodeAnnotation" aria-label="annotation3">3</span>. Next, we let the upper layer know we have one less character <span class="CodeAnnotation" aria-label="annotation4">4</span>. Finally, we shut down the interrupt if this was the last character <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
<h3 id="h2-501621c10-0005">Full Program</h3>
<p class="BodyFirst"><a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a> shows the complete program.</p>
<pre><code>/**
  * @brief   Write Hello World to the serial I/O
  * using a circular buffer.
  *
  * @note Contains a race condition to demonstrate
  * how not do do this program
  */
  
#include &lt;stdbool.h&gt;
#include "stm32f0xx_nucleo.h"
#include "stm32f0xx.h"
  
<span epub:type="pagebreak" title="175" id="Page_175"/>const char hello[] = "Hello World!\r\n";   // The message to send
int current; // The character in the message we are sending
  
UART_HandleTypeDef uartHandle;      // UART initialization
  
#define BUFFER_SIZE 8   // The data buffer size
  
struct circularBuffer {
    uint32_t putIndex;      // Where we will put the next character
    uint32_t getIndex;      // Where to get the next character
    uint32_t nCharacters;   // Number of characters in the buffer
    char data[BUFFER_SIZE]; // The data in the buffer
};
  
// A simple, classic circular buffer for USART2
volatile struct circularBuffer buffer = {0,0,0, {'\0'}};

<var>... Error_Handler from Listing 9-3</var> <var>...</var>

/**
 * Handle the USART2 interrupt.
 *
 * Magically called by the chip's interrupt system.
 * Name is fixed because of the startup code that
 * populates the interrupt vector.
 */
void USART2_IRQHandler(void)
{
    if ((uartHandle.Instance-&gt;ISR &amp; USART_ISR_TXE) != 0) {
        if (buffer.nCharacters == 0) {
            // Turn off interrupt.
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
            return;
        }
        // Send to UART.
        uartHandle.Instance-&gt;TDR = buffer.data[buffer.getIndex];
        ++buffer.getIndex;
        if (buffer.getIndex == BUFFER_SIZE)
            buffer.getIndex = 0;

        --buffer.nCharacters;

        if (buffer.nCharacters == 0)
            uartHandle.Instance-&gt;CR1 &amp;= ~(USART_CR1_TXEIE);
        return;
    }
    // Since the only interrupt we enabled was TXE, we should never
    // get here. When we do enable other interrupts, we need to put
    // code to handle them here.
}

/**
 * Put a character in the serial buffer.
 *
 * @param ch The character to send
<span epub:type="pagebreak" title="176" id="Page_176"/> */
void myPutchar(const char ch)
{
    // Wait until there is room.
    while (buffer.nCharacters == BUFFER_SIZE)
        continue;
    buffer.data[buffer.putIndex] = ch;
    ++buffer.putIndex;
    if (buffer.putIndex == BUFFER_SIZE)
        buffer.putIndex = 0;

    // We've added another character.
    ++buffer.nCharacters;
    // Now we're done.
    
    // Enable the interrupt (or reenable it).
    uartHandle.Instance-&gt;CR1 |= USART_CR1_TXEIE;
}

/**
 * Our version of puts
 *
 * Outputs the exact string given to the output
 *
 * @param str String to send
 *
 * @note Assumes that str is not null
 */
void myPuts(const char* str)
{
    for (/* str set */; *str != '\0'; ++str)
        myPutchar(*str);
}

<var>... led2_init and uart2_init same as Listing 9-3 ...</var>

int main(void)
{
    HAL_Init(); // Initialize hardware.
    led2_Init();
    uart2_Init();
    // Tell the chip that we want the interrupt vector
    // for USART2 to be enabled.
    NVIC_EnableIRQ(USART2_IRQn);

    // Keep sending the message for a long time.
    for (;;) {
        myPuts(hello);
        HAL_Delay(500);
    }
}

<var>... HAL_UART_MspInit and HAL_UART_MspDeInit same as Listing 9-3 ...</var></code></pre>
<p class="CodeListingCaption"><em><a id="listing10-2">Listing 10-2</a>: 10.serial.buffer.bad/src/main.c</em></p>
<h3 id="h2-501621c10-0006"><span epub:type="pagebreak" title="177" id="Page_177"/>The Problem</h3>
<p class="BodyFirst">When we run the program, we expect to see the following:</p>
<pre><code>Hello World!
Hello World!
Hello World!</code></pre>
<p>Instead, we get this:</p>
<pre><code>Hello World!
ello World!
Hello Wold!
Hello World!</code></pre>
<p>There is no pattern to when this issue will occur, other than that the more data we send to the buffer, the more likely we are to have a problem.</p>
<p>With this tiny program, replicating that problem in the field is going to be difficult because it requires very precise timing. It’s more likely that after implementing and testing this code, we would incorporate the module in another program that would make the timing more likely. Timing bugs are notoriously difficult to cause on demand, but there is one in this code.</p>
<p>We know that the busier the system is, the more likely it is that the problem will happen. Plus, we have another clue—we haven’t been able to catch it in the act, but afterward we looked at the debugger and discovered the following:</p>
<pre><code>nCharacters == 0
getIndex != putIndex</code></pre>
<p>In a correctly working program, both of these conditions can never be true. There are two ways of attacking this problem. The first is to instrument the code and try to find out what is going on. The second is to perform very detailed analysis of any data shared between the upper and lower layers and the code that manipulates this data. Let’s do both.</p>
<h4 id="h3-501621c10-0001">Instrumenting the Code</h4>
<p class="BodyFirst"><em>Instrumenting</em> the code means putting in temporary debugging statements that will help find a problem. With most code, this means writing <code>printf</code> statements to output intermediate data that we can check as the program progresses. Sometimes data is printed to a logfile that can be analyzed after the problem occurs. Neither of these options is viable for our embedded program. We can’t use <code>printf</code> because the output would go to the serial console, and that’s the code with the bug. We can’t write a logfile because we don’t have a filesystem to write logging information to.</p>
<p>We need to use a log buffer that will store the last 100 events. When we encounter a problem, we can go back and look at the events to see what led up to the problem. The log records the relevant data (<code>getIndex</code>, <code>putIndex</code>, <code>nCharacters</code>) and the line number of the call to the event-logging code.</p>
<p><span epub:type="pagebreak" title="178" id="Page_178"/>When the problem occurs and we get a chance to stop the program in the debugger, we can look through the log. If we are lucky, we should be able to find a few log entries where at line <em>X</em> the buffer information was consistent and at line <em>Y</em> it was screwed up, which reveals that the problem occurred between lines <em>X</em> and <em>Y</em>.</p>
<p><a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a> shows the code to record an event. Add this code after the other definitions and variable declarations.</p>
<pre><code>#define N_EVENTS 100                   // Store 100 events.
uint32_t nextEvent = 0;                // Where to put the next event
struct logEvent debugEvents[N_EVENTS]; // The log data

void debugEvent(const uint32_t line)
{
    debugEvents[nextEvent].line = line;
    debugEvents[nextEvent].putIndex = buffer.putIndex;
    debugEvents[nextEvent].getIndex = buffer.getIndex;
    debugEvents[nextEvent].nCharacters = buffer.nCharacters;
    ++nextEvent;
    if (nextEvent == N_NEVETS)
        nextEvent = 0;
}</code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: The event recorder</p>
<p>This event recorder contains the same type of bug we’re trying to find, but for now, we’ll assume that it works well enough for us to locate the problem.</p>
<p>Now we need to put in a few calls to the <code>debugEvent</code> function to see whether we can spot the error. Since <code>nCharacters</code> is driving us nuts, we put a call to <code>debugEvent</code> before and after each operation we perform on <code>nCharacters</code>:</p>
<pre><code>void USART2_IRQHandler(void)
<em>--snip--</em>
      debugEvent(__LINE__);
      --buffer.nCharacters;
      debugEvent(__LINE__);


void myPutchar(const char ch)
<em>--snip--</em>
      debugEvent(__LINE__);
      ++buffer.nCharacters;
      debugEvent(__LINE__);</code></pre>
<p>We also put a consistency check at the beginning of <code>myPutchar</code> to make sure the <code>buffer</code> is sane. Specifically, if we see the condition where the <code>buffer</code> is inconsistent (<code>nCharacters == 0</code> and <code>getIndex != putIndex</code>), we invoke the <code>Error_Handler</code> function to stop the program:</p>
<pre><code>void myPutchar(const char ch)
{
    if ((buffer.nCharacters == 0) &amp;&amp; (buffer.getIndex != buffer.putIndex))
        Error_Handler();</code></pre>
<p><span epub:type="pagebreak" title="179" id="Page_179"/>Let’s start the program under the debugger with a breakpoint at <code>Error_Handler</code> and see if we can catch the error. Eventually, we hit the breakpoint and, using the debugger, examine the <code>debugEvents</code>. Looking back through the traces using the debugger, we find the following:</p>
<ul>
<li>Line 119: <code>nCharacters == 3</code></li>
<li>Line 89: <code>nCharacters == 3</code></li>
<li>Line 91: <code>nCharacters == 2</code></li>
<li>Line 121: <code>nCharacters == 4</code></li>
</ul>
<p>Why did <code>nCharacters</code> jump by 2 between the last two events?</p>
<p>Here are the relevant lines:</p>
<pre><code>77 void USART2_IRQHandler(void)
<em>--snip--</em>
89      debugEvent(__LINE__);
90      --buffer.nCharacters;
91      debugEvent(__LINE__);</code></pre>
<p class="BodyContinued">and:</p>
<pre><code>106 void myPutchar(const char ch)
<em>--snip--</em>
119     debugEvent(__LINE__);
120     ++buffer.nCharacters;
121     debugEvent(__LINE__);</code></pre>
<p>Something is wrong with line 90 or 120, which also tells us something important. After line 119 and before line 121, an interrupt occurred. We’ve now pinpointed the error to a couple lines of code and an interrupt. Let’s shift gears and use code analysis to reach the same conclusion. We’re exploring both methods because sometimes one method works and the other doesn’t.</p>
<h4 id="h3-501621c10-0002">Analyzing the Code</h4>
<p class="BodyFirst">The other way to figure out the problem is to analyze what is going on and try to identify potential problem spots. The analysis starts by identifying the shared data between the upper and lower layers—in other words, the buffer:</p>
<pre><code>struct circularBuffer {
    uint32_t putIndex;      // Where we will put the next character
    uint32_t getIndex;      // Where to get the next character
    uint32_t nCharacters;   // Number of characters in the buffer
    char data[BUFFER_SIZE]; // The data in the buffer
};</code></pre>
<p>Neither <code>putIndex</code> nor <code>getIndex</code> should cause a problem, since they’re used by only one layer each (the upper and lower layer, respectively). The <code>data</code> array is shared by both layers, but it’s written by the upper layer and read by <span epub:type="pagebreak" title="180" id="Page_180"/>the lower level, so each layer has a distinct job when it comes to that array. In addition, <code>putIndex</code> controls the portion of the array the upper layer uses, and <code>getIndex</code> controls the portion the lower layer uses. They point to different elements of the array, and nothing going into or out of <code>data</code> could affect the indices or character counter. The <code>data</code> array is not the problem.</p>
<p>All that’s left is <code>nCharacters</code>, which the upper layer increments and the lower level decrements, so there are two potential problem lines. One is in the interrupt routine:</p>
<pre><code>--buffer.nCharacters;</code></pre>
<p class="BodyContinued">And the other is in <code>myPutchar</code>:</p>
<pre><code>++buffer.nCharacters;</code></pre>
<p>These are the same two lines our instrumented code indicated might be a problem.</p>
<h4 id="h3-501621c10-0003">Closely Examining the Code</h4>
<p class="BodyFirst">Let’s see exactly what happens when the following line is executed:</p>
<pre><code>++buffer.nCharacters;</code></pre>
<p>Here is the assembly code (comments added) for this line:</p>
<pre><code>120:../src/main.c ***  ++buffer.nCharacters;
404               loc 2 118 0
405 005c 094B     ldr  r3, .L22     ; Load r3 with the address in .L22,
                                    ; which happens to be "buffer".
406 005e 9B68     ldr  r3, [r3, #8] ; Get the value of  
                                    ; buffer.nCharacters.
407 0060 5A1C   <span class="CodeAnnotationCode" aria-label="annotation1">1</span> adds r2, r3, #1   ; Add 1 to r3 and store the result in r2.
408 0062 084B     ldr  r3, .L22     ; Get the address again.
409 0064 9A60     str  r2, [r3, #8] ; Store buffer.nCharacters.</code></pre>
<p>This code loads the value of <code>nCharacters</code> into register <code>r3</code>, increments it, and sticks it back in <code>nCharacters</code>. Interrupts can happen at any time, like right after the value is loaded into <code>r3</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which causes the following to happen (assuming <code>nCharacters</code> is 3):</p>
<ol class="decimal">
<li value="1">At line 406, register <code>r3</code> gets the value of <code>nCharacters</code> (<code>r3 == 3</code>).</li>
<li value="2">Just before the instruction at line 407, an interrupt occurs.</li>
<li value="3">The interrupt routine reads <code>nCharacters</code> (it’s 3).</li>
<li value="4">It decrements it, so the value of <code>nCharacters</code> is now 2.</li>
<li value="5">The interrupt routine completes and returns control to line 407.</li>
<li value="6">The instruction at line 407 adds 1 to register <code>r3</code> and sticks the result in <code>r2</code> (<code>r3</code> contains 3, <code>r2</code> contains 4).</li>
<li value="7"><span epub:type="pagebreak" title="181" id="Page_181"/>Line 409 stores the value of <code>r2</code> into <code>nCharacters</code>, which should be 3, but it’s now 4.</li>
<li value="8">At line 407, the program assumes that <code>r3</code> has the correct value of <code>nCharacters</code>, but it doesn’t.</li>
</ol>
<p>The register <code>r3</code> doesn’t have the correct value of <code>nCharacters</code> because an interrupt occurred at just the right time and the variable was modified. We failed to protect the consistency of shared data. The upper layer was modifying <code>nCharacters</code> while the lower layer was modifying it <em>at the same time</em>.</p>
<p>If the interrupt occurs between some other instructions, the problem does not occur. This problem is random and happens infrequently, making it one of the more difficult problems to solve.</p>
<h4 id="h3-501621c10-0004">Fixing the Problem</h4>
<p class="BodyFirst">The solution is to prevent the interrupt routine from modifying <code>nCharacters</code> while we are modifying it. To do that, we turn off interrupts before the increment and turn them on afterward:</p>
<pre><code>119      __disable_irq();
120      ++buffer.nCharacters;
121      __enable_irq();</code></pre>
<p>Keep the amount of time interrupts are turned off short. If interrupts are turned off for a long period of time, you might miss an interrupt and drop data.</p>
<p>In the interrupt routine, we decrement <code>nCharacters</code>, so don’t we need to protect that with a <code>__disable_irq</code> and an <code>__enable_irq</code>? We don’t, because when an interrupt occurs, the system automatically performs the following steps:</p>
<ol class="decimal">
<li value="1">It disables interrupts for this level interrupt and lower. Higher-level interrupts can interrupt our interrupt routine, but lower ones cannot.</li>
<li value="2">It saves the state of the machine, including all general-purpose registers and status registers.</li>
<li value="3">It calls the interrupt function.</li>
</ol>
<p>When the interrupt routine returns, the system then performs these steps:</p>
<ol class="decimal">
<li value="1">It restores the state of the machine.</li>
<li value="2">It turns the interrupts back on.</li>
<li value="3">It returns control to the upper-level code.</li>
</ol>
<p>A lot of bookkeeping needs to be done at the start and end of an interrupt routine. Fortunately, the designers of the ARM processor family decided to do it all in hardware. Other processors may not be so nice.</p>
<h2 id="h1-501621c10-0006"><span epub:type="pagebreak" title="182" id="Page_182"/>Summary</h2>
<p class="BodyFirst">Interrupts allow you to respond to input and output requests in real time. They also allow you to screw up your program in strange and random ways. Be sure to keep interrupt routines and code that accesses shared data as simple and clear as possible. Spending extra time making sure that interrupt-related code is written properly will save you a tremendous amount of debugging time later.</p>
<h2 id="h1-501621c10-0007">Programming Problems</h2>
<ol class="decimal">
<li value="1">Create an interrupt routine that reads characters from the serial port.</li>
<li value="2">Add an interrupt routine to service a button push and change the message when it occurs.</li>
<li value="3">Browse the HAL library and find out how <code>__disable_irq</code> is implemented.</li>
</ol>
</section>
</body></html>