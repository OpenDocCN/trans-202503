["```\nvoid power_up_rat_thing(int nuclear_isotopes) {\n  int waste_heat = 0;\n  --snip--\n}\n```", "```\n#include <cstdio>\n\nstatic int rat_things_power = 200; ➊\n\nvoid power_up_rat_thing(int nuclear_isotopes) {\n  rat_things_power = rat_things_power + nuclear_isotopes; ➋\n  const auto waste_heat = rat_things_power * 20; ➌\n  if (waste_heat > 10000) { ➍\n    printf(\"Warning! Hot doggie!\\n\"); ➎\n  }\n}\n\nint main() {\n  printf(\"Rat-thing power: %d\\n\", rat_things_power); ➏\n  power_up_rat_thing(100); ➐\n  printf(\"Rat-thing power: %d\\n\", rat_things_power);\n  power_up_rat_thing(500);\n  printf(\"Rat-thing power: %d\\n\", rat_things_power);\n}\n--------------------------------------------------------------------------\nRat-thing power: 200\nRat-thing power: 300\nWarning! Hot doggie! ➑\nRat-thing power: 800\n```", "```\n#include <cstdio>\n\nextern int rat_things_power = 200; // External linkage\n--snip--\n```", "```\n#include <cstdio>\n\nvoid power_up_rat_thing(int nuclear_isotopes) {\n  static int rat_things_power = 200;\n  rat_things_power = rat_things_power + nuclear_isotopes;\n  const auto waste_heat = rat_things_power * 20;\n  if (waste_heat > 10000) {\n    printf(\"Warning! Hot doggie!\\n\");\n  }\n  printf(\"Rat-thing power: %d\\n\", rat_things_power);\n}\nint main() {\n  power_up_rat_thing(100);\n  power_up_rat_thing(500);\n}\n```", "```\n#include <cstdio>\n\nstruct RatThing {\n  static int rat_things_power; ➊\n  static➋ void power_up_rat_thing(int nuclear_isotopes) {\n    rat_things_power➌ = rat_things_power + nuclear_isotopes;\n    const auto waste_heat = rat_things_power * 20;\n    if (waste_heat > 10000) {\n      printf(\"Warning! Hot doggie!\\n\");\n    }\n    printf(\"Rat-thing power: %d\\n\", rat_things_power);\n  }\n};\n\nint RatThing::rat_things_power = 200; ➍\n\nint main() {\n RatThing::power_up_rat_thing(100); ➎\n  RatThing::power_up_rat_thing(500);\n}\n```", "```\n#include <cstdio>\n\nvoid power_up_rat_thing(int nuclear_isotopes) {\n  static thread_local int rat_things_power = 200; ➊\n  --snip--\n}\n```", "```\nint*➊ my_int_ptr = new➋ int➌;\n```", "```\nint* my_int_ptr = new int{ 42 }; // Initializes dynamic object to 42\n```", "```\ndelete my_int_ptr;\n```", "```\nnew MyType[n_elements] { init-list }\n```", "```\nint* my_int_array_ptr = new int[100➊];\n```", "```\ndelete[] my_int_array_ptr\n```", "```\n#include <cstdio>\n\nstruct Tracer {\n  Tracer(const char* name➊) : name{ name }➋ {\n    printf(\"%s constructed.\\n\", name); ➌\n  }\n  ~Tracer() {\n    printf(\"%s destructed.\\n\", name); ➍\n  }\nprivate:\n  const char* const name;\n};\n```", "```\n#include <cstdio>\n\nstruct Tracer {\n  --snip--\n};\n\nstatic Tracer t1{ \"Static variable\" }; ➊\nthread_local Tracer t2{ \"Thread-local variable\" }; ➋\n\nint main() {\nconst auto t2_ptr = &t2;\n  printf(\"A\\n\"); ➌\n  Tracer t3{ \"Automatic variable\" }; ➍\n  printf(\"B\\n\");\n  const auto* t4 = new Tracer{ \"Dynamic variable\" }; ➎\n  printf(\"C\\n\");\n}\n```", "```\nStatic variable constructed.\nThread-local variable constructed.\nA ➌\nAutomatic variable constructed.\nB\nDynamic variable constructed.\nC\nAutomatic variable destructed.\nThread-local variable destructed.\nStatic variable destructed.\n```", "```\n#include <stdexcept>\n#include <cstdio>\n\nstruct Groucho {\n  void forget(int x) {\n    if (x == 0xFACE) {\n      throw➊ std::runtime_error➋{ \"I'd be glad to make an exception.\" };\n    }\n    printf(\"Forgot 0x%x\\n\", x);\n  }\n};\n```", "```\n#include <stdexcept>\n#include <cstdio>\n\nstruct Groucho {\n  --snip--\n};\n\nint main() {\n  Groucho groucho;\n  try { ➊\n    groucho.forget(0xC0DE); ➋\n    groucho.forget(0xFACE); ➌\n    groucho.forget(0xC0FFEE); ➍\n  } catch (const std::runtime_error& e➎) {\n    printf(\"exception caught with message: %s\\n\", e.what()); ➏\n  }\n}\n```", "```\nForgot 0xc0de\nexception caught with message: I'd be glad to make an exception.\n```", "```\nstruct Superclass {\n  int x;\n};\n\nstruct Subclass : Superclass { ➊\n  int y;\n  int foo() {\n    return x + y; ➋\n}\n};\n```", "```\ntry {\n  throw std::logic_error{ \"It's not about who wrong \"\n                        \"it's not about who right\" };\n} catch (std::exception& ex) {\n  // Handles std::logic_error as it inherits from std::exception\n}\n```", "```\ntry {\n  throw 'z'; // Don't do this.\n} catch (...) {\n  // Handles any exception, even a 'z'\n}\n```", "```\ntry {\n  // Code that might throw an exception\n  --snip--\n} catch (const std::logic_error& ex) {\n  // Log exception and terminate the program; there is a programming error!\n  --snip--\n} catch (const std::runtime_error& ex) {\n  // Do our best to recover gracefully\n  --snip--\n} catch (const std::exception& ex) {\n  // This will handle any exception that derives from std:exception\n  // that is not a logic_error or a runtime_error.\n  --snip--\n} catch (...) {\n  // Panic; an unforeseen exception type was thrown\n  --snip--\n}\n```", "```\ntry {\n  // Some code that might throw a system_error\n  --snip--\n} catch(const std::system_error& ex) {\n  if(ex.code()!= std::errc::permission_denied){\n    // Not a permission denied error\n    throw; ➊\n  }\n  // Recover from a permission denied\n  --snip--\n}\n```", "```\ntry {\n  // Throw a PermissionDenied instead\n  --snip--\n} catch(const PermissionDenied& ex) {\n  // Recover from an EACCES error (Permission Denied) ..\n  --snip--\n}\n```", "```\nbool is_odd(int x) noexcept {\n  return 1 == (x % 2);\n}\n```", "```\nvoid hari_kari() noexcept {\n  throw std::runtime_error{ \"Goodbye, cruel world.\" };\n}\n```", "```\n#include <cstdio>\n#include <stdexcept>\n\nstruct CyberdyneSeries800 {\n  CyberdyneSeries800() {\n    printf(\"I'm a friend of Sarah Connor.\"); ➊\n  }\n  ~CyberdyneSeries800() {\n    throw std::runtime_error{ \"I'll be back.\" }; ➋\n  }\n};\n\nint main() {\n  try {\n    CyberdyneSeries800 t800; ➌\n    throw std::runtime_error{ \"Come with me if you want to live.\" }; ➍\n  } catch(const std::exception& e) { ➎\n    printf(\"Caught exception: %s\\n\", e.what()); ➏\n  }\n}\n--------------------------------------------------------------------------\nI'm a friend of Sarah Connor. ➊\n```", "```\n#include <stdexcept>\n\nstruct SimpleString {\n  SimpleString(size_t max_size) ➊\n    : max_size{ max_size }, ➋\n      length{} { ➌\n    if (max_size == 0) {\n      throw std::runtime_error{ \"Max size must be at least 1.\" }; ➍\n    }\n    buffer = new char[max_size]; ➎\n    buffer[0] = 0; ➏\n  }\n\n  ~SimpleString() {\n    delete[] buffer; ➐\n  }\n--snip--\nprivate:\n  size_t max_size;\n  char* buffer;\n  size_t length;\n};\n```", "```\n#include <cstdio>\n#include <cstring>\n#include <stdexcept>\n\nstruct SimpleString {\n  --snip--\n  void print(const char* tag) const { ➊\n    printf(\"%s: %s\", tag, buffer);\n  }\n\n  bool append_line(const char* x) { ➋\n    const auto x_len = strlen➌(x);\n    if (x_len + length + 2 > max_size) return false; ➍\n    std::strncpy➎(buffer + length, x, max_size - length);\n    length += x_len;\n    buffer[length++] = '\\n';\n    buffer[length] = 0;\n    return true;\n  }\n--snip--\n};\n```", "```\nsize_t strlen(const char* str);\n```", "```\nchar* std::strncpy(char* destination, const char* source, std::size_t num);\n```", "```\n#include <cstdio>\n#include <cstring>\n#include <exception>\n\nstruct SimpleString {\n  --snip--\n}\nint main() {\n  SimpleString string{ 115 }; ➊\n  string.append_line(\"Starbuck, whaddya hear?\");\n  string.append_line(\"Nothin' but the rain.\"); ➋\n  string.print(\"A\") ➌\n  string.append_line(\"Grab your gun and bring the cat in.\");\n  string.append_line(\"Aye-aye sir, coming home.\"); ➍\n  string.print(\"B\") ➎\n  if (!string.append_line(\"Galactica!\")) { ➏\n    printf(\"String was not big enough to append another message.\"); ➐\n  }\n}\n```", "```\nA: Starbuck, whaddya hear? ➊\nNothin' but the rain.\nB: Starbuck, whaddya hear? ➋\nNothin' but the rain.\nGrab your gun and bring the cat in.\nAye-aye sir, coming home.\nString was not big enough to append another message. ➌\n```", "```\n#include <stdexcept>\n\nstruct SimpleStringOwner {\n  SimpleStringOwner(const char* x)\n    : string{ 10 } { ➊\n    if (!string.append_line(x)) {\n      throw std::runtime_error{ \"Not enough memory!\" };\n }\n    string.print(\"Constructed\");\n  }\n  ~SimpleStringOwner() {\n    string.print(\"About to destroy\"); ➋\n  }\nprivate:\n  SimpleString string;\n};\n```", "```\n--snip--\nint main() {\n  SimpleStringOwner x{ \"x\" };\n  printf(\"x is alive\\n\");\n}\n--------------------------------------------------------------------------\nConstructed: x ➊\nx is alive\nAbout to destroy: x ➋\n```", "```\n--snip--\nvoid fn_c() {\n  SimpleStringOwner c{ \"cccccccccc\" }; ➊\n}\nvoid fn_b() {\n  SimpleStringOwner b{ \"b\" };\n  fn_c(); ➋\n}\n\nint main() {\n  try { ➌\n    SimpleStringOwner a{ \"a\" };\n    fn_b(); ➍\n    SimpleStringOwner d{ \"d\" }; ➎\n  } catch(const std::exception& e) { ➏\n    printf(\"Exception: %s\\n\", e.what());\n  }\n}\n```", "```\nConstructed: a\nConstructed: b\nAbout to destroy: b\nAbout to destroy: a\nException: Not enough memory!\n```", "```\nstruct HumptyDumpty {\n   HumptyDumpty();\n   bool is_together_again();\n  --snip--\n};\n```", "```\nbool send_kings_horses_and_men() {\n  HumptyDumpty hd{};\n  if (hd.is_together_again()) return false;\n  // Class invariants of hd are now guaranteed.\n  // Humpty Dumpty had a great fall.\n  --snip--\n  return true;\n}\n```", "```\nstruct Result { ➊\n  HumptyDumpty hd;\n  bool success;\n};\n\nResult make_humpty() { ➋\n  HumptyDumpty hd{};\n  bool is_valid;\n  // Check that hd is valid and set is_valid appropriately\n  return { hd, is_valid };\n}\n\nbool send_kings_horses_and_men() {\n  auto [hd, success] = make_humpty(); ➌\n  if(!success) return false;\n  // Class invariants established\n  --snip--\n  return true;\n}\n```", "```\n#include <cstdio>\n\nint add_one_to(int x) {\n  x++; ➊\n  return x;\n}\n\nint main() {\n  auto original = 1;\n  auto result = add_one_to(original); ➋\n  printf(\"Original: %d; Result: %d\", original, result);\n}\n--------------------------------------------------------------------------\nOriginal: 1; Result: 2\n```", "```\nstruct Point {\n  int x, y;\n};\n\nPoint make_transpose(Point p) {\n  int tmp = p.x;\n  p.x = p.y;\n p.y = tmp;\n  return p;\n}\n```", "```\nstruct SimpleString {\n  --snip--\n  SimpleString(const SimpleString& other);\n};\n```", "```\nSimpleString a;\nSimpleString a_copy{ a };\n```", "```\nSimpleString(const SimpleString& other)\n  : max_size{ other.max_size }, ➊\n    buffer{ new char[other.max_size] }, ➋\n    length{ other.length } { ➌\n    std::strncpy(buffer, other.buffer, max_size); ➍\n}\n```", "```\n--snip--\nint main() {\n  SimpleString a{ 50 };\n  a.append_line(\"We apologize for the\");\n  SimpleString a_copy{ a }; ➊\n  a.append_line(\"inconvenience.\"); ➋\n  a_copy.append_line(\"incontinence.\"); ➌\n  a.print(\"a\");\n  a_copy.print(\"a_copy\");\n}\n--------------------------------------------------------------------------\na: We apologize for the\ninconvenience.\na_copy: We apologize for the\nincontinence.\n```", "```\n--snip--\nvoid foo(SimpleString x) {\n  x.append_line(\"Change lost.\");\n}\n\nint main() {\n  SimpleString a { 20 };\n  foo(a); // Invokes copy constructor\n  a.print(\"Still empty\");\n}\n--------------------------------------------------------------------------\nStill empty:\n```", "```\n--snip--\nvoid dont_do_this() {\n  SimpleString a{ 50 };\n  a.append_line(\"We apologize for the\");\n  SimpleString b{ 50 };\n  b.append_line(\"Last message\");\n  b = a; ➊\n}\n```", "```\nstruct SimpleString {\n  --snip--\n  SimpleString& operator=(const SimpleString& other) {\n    if (this == &other) return *this; ➊\n    --snip--\n    return *this; ➋\n  }\n}\n```", "```\n  SimpleString& operator=(const SimpleString& other) {\n    if (this == &other) return *this;\n    const auto new_buffer = new char[other.max_size]; ➊\n    delete[] buffer; ➋\n    buffer = new_buffer; ➌\n    length = other.length; ➍\n    max_size = other.max_size; ➎\n    std::strncpy(buffer, other.buffer, max_size); ➏\n    return *this;\n  }\n```", "```\n--snip--\nint main() {\n  SimpleString a{ 50 };\n  a.append_line(\"We apologize for the\"); ➊\n  SimpleString b{ 50 };\n  b.append_line(\"Last message\"); ➋\n  a.print(\"a\"); ➌\n  b.print(\"b\"); ➍\n  b = a; ➎\n  a.print(\"a\"); ➏\n  b.print(\"b\"); ➐\n}\n--------------------------------------------------------------------------\na: We apologize for the ➌\nb: Last message ➍\na: We apologize for the ➏\nb: We apologize for the ➐\n```", "```\nstruct Replicant {\n  Replicant(const Replicant&) = default;\n  Replicant& operator=(const Replicant&) = default;\n  --snip--\n};\n```", "```\nstruct Highlander {\n  Highlander(const Highlander&) = delete;\n  Highlander& operator=(const Highlander&) = delete;\n  --snip--\n};\n```", "```\n--snip--\nint main() {\n  Highlander a;\n  Highlander b{ a }; // Bang! There can be only one.\n}\n```", "```\n--snip--\nvoid own_a_string() {\n  SimpleString a{ 50 };\n  a.append_line(\"We apologize for the\");\n  a.append_line(\"inconvenience.\");\n  SimpleStringOwner b{ a };\n  --snip--\n}\n```", "```\nstruct SimpleStringOwner {\n  SimpleStringOwner(const SimpleString& my_string) : string{ my_string }➊ { }\n  --snip--\nprivate:\n  SimpleString string; ➋\n};\n```", "```\nSimpleString a{ 50 };\nSimpleStringOwner b{ a };                   // a is an lvalue\nSimpleStringOwner c{ SimpleString{ 50 } };  // SimpleString{ 50 } is an rvalue\n```", "```\n#include <cstdio>\nvoid ref_type(int &x) { ➊\n  printf(\"lvalue reference %d\\n\", x);\n}\nvoid ref_type(int &&x) { ➋\n  printf(\"rvalue reference %d\\n\", x);\n}\n\nint main() {\n  auto x = 1;\n  ref_type(x); ➌\n  ref_type(2); ➍\n  ref_type(x + 2); ➎\n}\n--------------------------------------------------------------------------\nlvalue reference 1 ➌\nrvalue reference 2 ➍\nrvalue reference 3 ➎\n```", "```\n#include <utility>\n--snip--\nint main() {\n  auto x = 1;\n  ref_type(std::move(x)); ➊\n  ref_type(2);\n  ref_type(x + 2);\n}\n--------------------------------------------------------------------------\nrvalue reference 1 ➊\nrvalue reference 2\nrvalue reference 3\n```", "```\nSimpleString(SimpleString&& other) noexcept\n  : max_size{ other.max_size }, ➊\n  buffer(other.buffer),\n  length(other.length) {\n  other.length = 0; ➋\n  other.buffer = nullptr;\n  other.max_size = 0;\n}\n```", "```\nSimpleString& operator=(SimpleString&& other) noexcept { ➊\n  if (this == &other) return *this; ➋\n  delete[] buffer; ➌\n buffer = other.buffer; ➍\n  length = other.length;\n  max_size = other.max_size;\n  other.buffer = nullptr; ➎\n  other.length = 0;\n  other.max_size = 0;\n  return *this;\n}\n```", "```\nSimpleStringOwner(SimpleString&& x) : string{ std::move(x)➊ } { }\n```", "```\n--snip--\nint main() {\n  SimpleString a{ 50 };\n  a.append_line(\"We apologize for the\"); ➊\n  SimpleString b{ 50 };\n  b.append_line(\"Last message\"); ➋\n  a.print(\"a\"); ➌\n  b.print(\"b\"); ➍\n  b = std::move(a); ➎\n  // a is \"moved-from\"\n  b.print(\"b\"); ➏\n}\n--------------------------------------------------------------------------\na: We apologize for the ➌\nb: Last message ➍\nb: We apologize for the ➏\n```", "```\n#include <cstdio>\n#include <cstring>\n#include <stdexcept>\n#include <utility>\n\nstruct SimpleString {\n  SimpleString(size_t max_size)\n    : max_size{ max_size },\n    length{} {\n    if (max_size == 0) {\n      throw std::runtime_error{ \"Max size must be at least 1.\" };\n    }\n    buffer = new char[max_size];\n    buffer[0] = 0;\n  }\n  ~SimpleString() {\n    delete[] buffer;\n  }\n  SimpleString(const SimpleString& other)\n    : max_size{ other.max_size },\n    buffer{ new char[other.max_size] },\n    length{ other.length } {\n    std::strncpy(buffer, other.buffer, max_size);\n  }\n  SimpleString(SimpleString&& other) noexcept\n    : max_size(other.max_size),\n    buffer(other.buffer),\n    length(other.length) {\n    other.length = 0;\n    other.buffer = nullptr;\n    other.max_size = 0;\n  }\n  SimpleString& operator=(const SimpleString& other) {\n    if (this == &other) return *this;\n    const auto new_buffer = new char[other.max_size];\n    delete[] buffer;\n    buffer = new_buffer;\n    length = other.length;\n    max_size = other.max_size;\n    std::strncpy(buffer, other.buffer, max_size);\n return *this;\n  }\n  SimpleString& operator=(SimpleString&& other) noexcept {\n    if (this == &other) return *this;\n    delete[] buffer;\n    buffer = other.buffer;\n    length = other.length;\n    max_size = other.max_size;\n    other.buffer = nullptr;\n    other.length = 0;\n    other.max_size = 0;\n    return *this;\n  }\n  void print(const char* tag) const {\n    printf(\"%s: %s\", tag, buffer);\n  }\n  bool append_line(const char* x) {\n    const auto x_len = strlen(x);\n    if (x_len + length + 2 > max_size) return false;\n    std::strncpy(buffer + length, x, max_size - length);\n    length += x_len;\n    buffer[length++] = '\\n';\n    buffer[length] = 0;\n    return true;\n  }\nprivate:\n  size_t max_size;\n  char* buffer;\n  size_t length;\n};\n```"]