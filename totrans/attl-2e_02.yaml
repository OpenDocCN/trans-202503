- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A BRIEF INTRODUCTION TO THE GNU AUTOTOOLS
  prefs: []
  type: TYPE_NORMAL
- en: '*We shall not cease from exploration And the end of all our exploring Will
    be to arrive where we started And know the place for the first time.'
  prefs: []
  type: TYPE_NORMAL
- en: '—T.S. Eliot, “Quartet No. 4: Little Gidding”*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As stated in the preface to this book, the purpose of the GNU Autotools is
    to make life simpler for the end user, not the maintainer. Nevertheless, using
    the Autotools will make your job as a project maintainer easier in the long run,
    although maybe not for the reasons you suspect. The Autotools framework is as
    simple as it can be, given the functionality it provides. The real purpose of
    the Autotools is twofold: it serves the needs of your users, and it makes your
    project incredibly portable—even to systems on which you’ve never tested, installed,
    or built your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, I will often use the term *Autotools*, although you won’t
    find a package in the GNU archives with this label. I use this term to signify
    the following three GNU projects, which are considered by the community to be
    part of the GNU build system:'
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf, which is used to generate a configuration script for a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automake, which is used to simplify the process of creating consistent and functional
    makefiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libtool, which provides an abstraction for the portable creation of shared libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other build tools, such as the open source projects CMake and SCons, attempt
    to provide the same functionality as the Autotools but in a more user-friendly
    manner. However, because these tools attempt to hide much of their complexity
    behind GUI interfaces and script builders, they actually end up being less functional,
    and more difficult to manage, because the build system is not as transparent.
    In the final analysis, this transparency is what makes the Autotools both simpler
    to use and simpler to understand. Initial frustration with the Autotools, therefore,
    comes not from their complexity—for they are truly very simple—but from their
    extensive use of less well understood tools and subsystems, such as the Linux
    command shell (Bash), the `make` utility, and the M4 macro processor and accompanying
    macro libraries. Indeed, the meta-language provided by Automake is so simple it
    can be entirely digested and comprehended within a few hours of perusing the manual
    (though the ramifications of this meta-language may take a bit longer to thoroughly
    internalize).
  prefs: []
  type: TYPE_NORMAL
- en: Who Should Use the Autotools?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re writing open source software that targets Unix or Linux systems, you
    should absolutely be using the GNU Autotools, and even if you’re writing proprietary
    software for Unix or Linux systems, you’ll still benefit significantly from using
    them. The Autotools provide you with a build environment that allows your project
    to build successfully on future versions or distributions with virtually no changes
    to the build scripts. This is useful even if you only intend to target a single
    Linux distribution, because—let’s be honest—you really *can’t* know in advance
    whether or not your company will want your software to run on other platforms
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: When Should You Not Use the Autotools?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: About the only time it makes sense not to use the Autotools is when you’re writing
    software that will *only* run on non-Unix platforms, such as Microsoft Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Autotools support for Windows requires an Msys^([1](footnote.xhtml#ch02fn1))
    environment in order to work correctly, because Autoconf-generated configuration
    scripts are Bourne-shell scripts, and Windows doesn’t provide a native Bourne
    shell.^([2](footnote.xhtml#ch02fn2)) Unix and Microsoft tools are just different
    enough in command line options and runtime characteristics that it’s often simpler
    to use Windows ports of GNU tools, such as Cygwin, Msys2, or MinGW, to build Windows
    programs with an Autotools build system.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, I’ll focus mostly on using the Autotools on POSIX-compliant
    platforms. Nevertheless, if you’re interested in trying out the Autotools on Windows,
    check out [Chapter 17](ch17.xhtml) for an in-depth overview.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’m not a typical Unix bigot. While I love Unix (and especially Linux), I
    also appreciate Windows for the areas in which it excels.^([3](footnote.xhtml#ch02fn3))
    For Windows development, I highly recommend using Microsoft tools. The original
    reasons for using GNU tools to develop Windows programs are more or less academic
    nowadays because Microsoft has made the better part of its tools available for
    download at no cost. For download information, see Visual Studio Community at*
    [https://visualstudio.microsoft.com/vs/express/](https://visualstudio.microsoft.com/vs/express/).'
  prefs: []
  type: TYPE_NORMAL
- en: Apple Platforms and Mac OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Macintosh operating system has been POSIX compliant since 2007 when the
    “Leopard” release of macOS version 10 (OS X) was published. OS X is derived from
    NeXTSTEP/OpenStep, which is based on the Mach kernel, with parts taken from FreeBSD
    and NetBSD. As a POSIX-compliant operating system, OS X provides all the infrastructure
    required by the Autotools. The problems you’ll encounter with OS X will most likely
    involve Apple’s graphical user interface and package management systems, both
    of which are specific to the Mac.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface presents the same issues you encounter when dealing with
    the X Window system on other Unix platforms, and then some. The primary difference
    is that the X Window system is used exclusively on most Unix systems, but macOS
    has its own graphical user interface called *Cocoa*. While the X Window system
    can be used on the Mac (Apple provides a window manager that makes X applications
    look a lot like native Cocoa apps), Mac programmers will sometimes wish to take
    full advantage of the native user interface features provided by the operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The Autotools skirt the issue of package management differences between Unix
    platforms by simply ignoring them. Instead, they create packages that are little
    more than compressed source archives using the `tar` and `gzip` utilities, and
    they install and uninstall products from the `make` command line. The macOS package
    management system is an integral part of installing an application on an Apple
    system, and projects like Fink (*[http://www.finkproject.org/](http://www.finkproject.org/)*)
    and MacPorts (*[http://www.macports.org/](http://www.macports.org/)*) help make
    existing open source packages available on the Mac by providing simplified mechanisms
    for converting Autotools packages into installable Mac packages.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that the Autotools can be used quite effectively on Apple
    Macintosh systems running OS X or later, as long as you keep these caveats in
    mind.
  prefs: []
  type: TYPE_NORMAL
- en: The Choice of Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your choice of programming language is another important factor to consider
    when deciding whether to use the Autotools. Remember that the Autotools were designed
    by GNU people to manage GNU projects. In the GNU community, two factors determine
    the importance of a computer programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: Are there any GNU packages written in the language?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the GNU compiler tool set support the language?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Autoconf provides native support for the following languages based on these
    two criteria (by *native support*, I mean that Autoconf will compile, link, and
    run source-level feature checks in these languages):'
  prefs: []
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortran
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortran 77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, if you want to build a Java package, you can configure Automake to
    do so (as you’ll see in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml)), but you
    can’t ask Autoconf to compile, link, or run Java-based checks,^([4](footnote.xhtml#ch02fn4))
    because Autoconf simply doesn’t natively support Java. However, you can find Autoconf
    macros (which I will cover in more detail in later chapters) that enhance Autoconf’s
    ability to manage the configuration process for projects written in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The general feeling is that Java has plenty of its own build environments and
    tools that work very well (maven, for instance); therefore, adding full support
    for Java seems like a wasted effort. This is especially true since Java and its
    build tools are themselves highly portable—even to non-Unix/Linux platforms such
    as Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Rudimentary support does exist in Automake for Java compilers and JVMs. I’ve
    used these features myself on projects, and they work well, as long as you don’t
    try to push them too far.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re into Smalltalk, ADA, Modula, Lisp, Forth, or some other non-mainstream
    language, you’re probably not too interested in porting your code to dozens of
    platforms and CPUs. However, if you *are* using a non-mainstream language and
    you’re concerned about the portability of your build systems, consider adding
    support for your language to the Autotools yourself. This is not as daunting a
    task as you may think, and I guarantee that you’ll be an Autotools expert when
    you’re finished.^([5](footnote.xhtml#ch02fn5))
  prefs: []
  type: TYPE_NORMAL
- en: Generating Your Package Build System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GNU Autotools framework includes three main packages: Autoconf, Automake,
    and Libtool. The tools in these packages can depend on utilities and functionality
    from the gettext, M4, sed, make, and Perl packages, among others; however, the
    build systems generated by these packages rely only on a Bourne shell and the
    `make` utility.'
  prefs: []
  type: TYPE_NORMAL
- en: With respect to the Autotools, it’s important to distinguish between a *maintainer’s*
    system and an *end user’s* system. The design goals of the Autotools specify that
    an Autotools-generated build system should rely only on tools that are readily
    available and preinstalled on the end user’s machine (assuming the end user’s
    system has rudimentary support for building programs from source code). For example,
    the machine a maintainer uses to create distributions requires a Perl interpreter,
    but a machine on which an end user builds products from release distribution source
    archives should not require Perl (unless, of course, the project sources are written
    in Perl).
  prefs: []
  type: TYPE_NORMAL
- en: A corollary is that an end user’s machine doesn’t need to have the Autotools
    installed—an end user’s system only requires a reasonably POSIX-compliant version
    of `make` and some variant of the Bourne shell that can execute the generated
    configuration script. And, of course, any package will also require compilers,
    linkers, and other tools needed to convert source files into executable binary
    programs, help files, and other runtime resources.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most developers understand the purpose of the `make` utility, but what’s the
    point of `configure`? While Unix systems have followed the de facto standard Unix
    kernel interface for decades, most software has to stretch beyond these boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, configuration scripts were hand-coded shell scripts designed to
    set environment variables based on platform-specific characteristics. They also
    allowed users to configure package options before running `make`. This approach
    worked well for decades, but as the number of Linux distributions and Unix-like
    systems grew, the variety of features and installation and configuration options
    exploded, so it became very difficult to write a decent portable configuration
    script. In fact, it was much more difficult to write a portable configuration
    script than it was to write makefiles for a new project. Therefore, most people
    just created configuration scripts for their projects by copying and modifying
    the script for a similar project.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1990s, it was apparent to many open source software developers
    that project configuration would become painful if something wasn’t done to ease
    the burden of writing massive complex shell scripts to manage configuration options.
    The number of GNU project packages had grown to hundreds, and maintaining consistency
    across their separate build systems had become more time-consuming than simply
    maintaining the code for these projects. These problems had to be solved.
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Autoconf ^([6](footnote.xhtml#ch02fn6)) changed this paradigm almost overnight.
    David MacKenzie started the Autoconf project in 1991, but a look at the *AUTHORS*
    file in the Savannah Autoconf project^([7](footnote.xhtml#ch02fn7)) repository
    will give you an idea of the number of people who had a hand in making the tool.
    Although configuration scripts were long and complex, users needed to specify
    only a few variables when executing them. Most of these variables were simply
    choices about components, features, and options, such as *Where can the build
    system find libraries and header files? Where do I want to install my finished
    products? Which optional components do I want to build into my products?*
  prefs: []
  type: TYPE_NORMAL
- en: Instead of modifying and debugging hundreds of lines of supposedly portable
    shell script, developers can now write a short metascript file using a concise,
    macro-based language, and Autoconf will generate a perfect configuration script
    that is more portable, more accurate, and more maintainable than a hand-coded
    one. In addition, Autoconf often catches semantic or logic errors that could otherwise
    take days to debug. Another benefit of Autoconf is that the shell code it generates
    is portable between most variations of the Bourne shell. Mistakes made in portability
    between shells are very common and, unfortunately, are the most difficult kinds
    of mistakes to find, because no one developer has access to all Bourne-like shells.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*While portable scripting languages like Perl and Python are now more pervasive
    than the Bourne shell, this was not the case when the idea for Autoconf was first
    conceived.*'
  prefs: []
  type: TYPE_NORMAL
- en: Autoconf-generated configuration scripts provide a common set of options that
    are important to all portable software projects running on POSIX systems. These
    include options to modify standard locations (a concept I’ll cover in more detail
    in [Chapter 3](ch03.xhtml)), as well as project-specific options defined in the
    *configure.ac* file (which I’ll discuss in [Chapter 5](ch05.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The autoconf package provides several programs, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`autoconf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoreconf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoheader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoscan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoupdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ifnames`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autom4te`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `autoconf` program is a simple Bourne shell script. Its main task is to
    ensure that the current shell contains the functionality necessary to execute
    the `m4` macro processor. (I’ll discuss Autoconf’s use of M4 in detail in [Chapter
    4](ch04.xhtml).) The remainder of the script parses command line parameters and
    executes `autom4te`.
  prefs: []
  type: TYPE_NORMAL
- en: '*autoreconf*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `autoreconf` utility executes the configuration tools in the autoconf, automake,
    and libtool packages as required by the project. This utility minimizes the amount
    of regeneration required to address changes in timestamps, features, and project
    state. It was written as an attempt to consolidate existing maintainer-written,
    script-based utilities that ran all the required Autotools in the right order.
    You can think of `autoreconf` as a sort of smart Autotools bootstrap utility.
    If all you have is a *configure.ac* file, you can run `autoreconf` to execute
    all the tools you need, in the correct order, so that `configure` will be properly
    generated. [Figure 2-1](ch02.xhtml#ch02fig01) shows how `autoreconf` interacts
    with other utilities in the Autotools suite.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: A dataflow diagram for the `autoreconf` utility*'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, there are times when a project requires more than simply bootstrapping
    the Autotools to get a developer up and running on a newly checked-out repository
    work area. In these cases, a small shell script that runs `autoreconf`, along
    with any non-Autotools-related processes, is appropriate. Many projects name such
    a script `autogen.sh`, but this is often confusing to developers because there
    is a GNU Autogen project. A better name would be something like `bootstrap.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used with the `-i` option, `autoreconf` will bootstrap a
    project into a distributable state by adding missing files that are recommended
    or required by GNU for proper open source projects. These include a proper *ChangeLog*
    and template *INSTALL*, *README*, and *AUTHORS* files and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '*autoheader*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `autoheader` utility generates a C/C++ compatible header file template from
    various constructs in *configure.ac*. This file is usually called *config.h.in*.
    When the end user executes `configure`, the configuration script generates *config.h*
    from *config.h.in*. As maintainer, you’ll use `autoheader` to generate the template
    file you will include in your distribution package. (We’ll examine `autoheader`
    in greater detail in [Chapter 4](ch04.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: '*autoscan*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `autoscan` program generates a default *configure.ac* file for a new project;
    it can also examine an existing Autotools project for flaws and opportunities
    for enhancement. (We’ll discuss `autoscan` in more detail in [Chapters 4](ch04.xhtml)
    and [14](ch14.xhtml).) `autoscan` is very useful as a starting point for a project
    that uses a non-Autotools-based build system, but it may also be useful for suggesting
    features that might enhance an existing Autotools-based project.
  prefs: []
  type: TYPE_NORMAL
- en: '*autoupdate*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `autoupdate` utility is used to update *configure.ac* or the template (*.in*)
    files to match the syntax supported by current versions of the Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: '*ifnames*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ifnames` program is a small and generally underused utility that accepts
    a list of source file names on the command line and displays a list of C-preprocessor
    definitions. This utility was designed to help maintainers determine what to put
    into the *configure.ac* and *Makefile.am* files to make them portable. If your
    project was written with some level of portability in mind, `ifnames` can help
    you determine where those attempts at portability are located in your source tree
    and give you the names of potential portability definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '*autom4te*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `autom4te` utility is a Perl-based intelligent caching wrapper for `m4`
    that is used by most of the other Autotools. The `autom4te` cache decreases the
    time successive tools spend accessing *configure.ac* constructs by as much as
    30 percent.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t spend a lot of time on `autom4te` (pronounced *automate*) because it’s
    primarily used internally by the Autotools. The only sign that it’s working is
    the *autom4te.cache* directory that appears in your top-level project directory
    after you run `autoconf` or `autoreconf`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Working Together*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Of the previously listed tools, `autoconf` and `autoheader` are the only ones
    project maintainers use when generating a `configure` script, and `autoreconf`
    is the only one that the developer needs to directly execute. [Figure 2-2](ch02.xhtml#ch02fig02)
    shows the interaction between input files and `autoconf` and `autoheader` that
    generates the corresponding product files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A data flow diagram for `autoconf` and `autoheader`*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I use the data flow diagram format shown in [Figure 2-2](ch02.xhtml#ch02fig02)
    throughout this book. Dark boxes represent objects provided either by the user
    or by an Autotools package. Light boxes represent generated objects. Boxes with
    square corners are scripts and programs, and boxes with rounded corners are data
    files. The meaning of most of the labels here should be obvious, but at least
    one deserves an explanation: the term ac-vars refers to Autoconf-specific replacement
    text. I’ll explain the gradient shading of the aclocal.m4 box shortly.*'
  prefs: []
  type: TYPE_NORMAL
- en: The primary task of this suite of tools is to generate a configuration script
    that can be used to configure a project build directory for a target platform
    (not necessarily the local host). This script does not rely on the Autotools themselves;
    in fact, `autoconf` is designed to generate configuration scripts that will run
    on all Unix-like platforms and in most variations of the Bourne shell. This means
    that you can generate a configuration script using `autoconf` and then successfully
    execute that script on a machine that does not have the Autotools installed.
  prefs: []
  type: TYPE_NORMAL
- en: The `autoconf` and `autoheader` programs are executed either directly by you
    or indirectly by `autoreconf`. They take their input from your project’s *configur**e**.ac*
    file and various Autoconf-flavored M4 macro definition files (which, by convention,
    have a *.m4* extension), using `autom4te` to maintain cache information. The `autoconf`
    program generates a configuration script called `configure`, a very portable Bourne
    shell script that enables your project to offer many useful configuration capabilities.
    The program `autoheader` generates the *config.h.in* template based on certain
    macro definitions in *configure.ac*.
  prefs: []
  type: TYPE_NORMAL
- en: Automake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve done it a few times, writing a basic makefile for a new project
    is fairly simple. But problems may occur when you try to do more than just the
    basics. And let’s face it—what project maintainer has ever been satisfied with
    just a basic makefile?
  prefs: []
  type: TYPE_NORMAL
- en: 'Attention to detail is what makes an open source project successful. Users
    lose interest in a project fairly easily—especially when functionality they expect
    is missing or improperly written. For example, power users have come to expect
    makefiles to support certain standard targets or goals, specified on the `make`
    command line, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Common `make` targets include `all`, `clean`, and `install`. In this example,
    `install` is the target. But you should realize that none of these are *real*
    targets: a *real target* is a filesystem object that is produced by the build
    system—usually a file (but sometimes a directory or a link). When building an
    executable called `doofabble`, for instance, you’d expect to be able to enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For this project, `doofabble` is a real target, and this command works for the
    doofabble project. However, requiring the user to enter real targets on the `make`
    command line is asking a lot of them, because each project must be built differently—`make
    doofabble`, `make foodabble`, `make abfooble`, and so on. Standardized targets
    for `make` allow all projects to be built in the same way using commonly known
    commands like `make all` and `make clean`. But *commonly known* doesn’t mean *automatic*,
    and writing and maintaining makefiles that support these targets is tedious and
    error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Automake’s job is to convert a simplified specification of your project’s build
    process into boilerplate makefile syntax that always works correctly the first
    time *and provides all the standard functionality expected*. Automake creates
    projects that support the guidelines defined in the *GNU Coding Standards* (discussed
    in [Chapter 3](ch03.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Just like `autoconf` produces a `configure` script that is portable to many
    flavors of the Bourne shell, `automake` produces `make` script that is portable
    to many flavors of `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automake package provides the following tools in the form of Perl scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`automake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aclocal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*automake*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `automake` program generates standard makefile templates (named *Makefile.in*)
    from high-level build specification files (named *Makefile.am*). These *Makefile.am*
    input files are essentially just regular makefiles. If you were to put only the
    few required Automake definitions in a *Makefile.am* file, you’d get a *Makefile.in*
    file containing several hundred lines of parameterized `make` script.
  prefs: []
  type: TYPE_NORMAL
- en: If you add additional `make` syntax to a *Makefile.am* file, Automake will move
    this code to the most functionally correct location in the resulting *Makefile.in*
    file. In fact, you can write your *Makefile.am* files so all they contain is ordinary
    `make` script, and the resulting makefiles will work just fine. This pass-through
    feature gives you the ability to extend Automake’s functionality to suit your
    project’s specific requirements.^([8](footnote.xhtml#ch02fn8))
  prefs: []
  type: TYPE_NORMAL
- en: '*aclocal*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the *GNU Automake Manual*, the `aclocal` utility is documented as a temporary
    workaround for a certain lack of flexibility in Autoconf. Automake enhances Autoconf
    by adding an extensive set of macros, but Autoconf was not really designed with
    this level of enhancement in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The original documented method for adding user-defined macros to an Autoconf
    project was to create a file called *aclocal.m4*, place the user-defined macros
    in this file, and place the file in the same directory as *configure.ac*. Autoconf
    then automatically includes this set of macros while processing *configure.ac*.
    The designers of Automake found this extension mechanism too useful to pass up;
    however, users would have been required to add an `m4_include` statement to a
    possibly unnecessary *aclocal.m4* file in order to include the Automake macros.
    Since both user-defined macros and the use of M4 itself are considered advanced
    concepts, this was deemed too harsh a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The `aclocal` script was designed to solve this problem. This utility generates
    an *aclocal.m4* file for a project that contains both user-defined macros and
    all required Automake macros.^([9](footnote.xhtml#ch02fn9)) Instead of adding
    user-defined macros directly to *aclocal.m4*, project maintainers should now add
    them to a new file called *acinclude.m4*.
  prefs: []
  type: TYPE_NORMAL
- en: To make it clear to readers that Autoconf doesn’t depend on Automake (and perhaps
    due to a bit of stubbornness), the *GNU Autoconf Manual* doesn’t make much mention
    of the `aclocal` utility. The *GNU Automake Manual* originally suggested that
    you rename *aclocal.m4* to *acinclude.m4* when adding Automake to an existing
    Autoconf project, and this approach is still commonly used. The flow of data for
    `aclocal` is depicted in [Figure 2-3](ch02.xhtml#ch02fig03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: A data flow diagram for `aclocal`*'
  prefs: []
  type: TYPE_NORMAL
- en: However, the latest documentation for both Autoconf and Automake suggests that
    the entire paradigm is now obsolete. Developers should now specify a directory
    that contains a set of M4 macro files. The current recommendation is to create
    a directory in the project root directory called *m4* and add macros as individual
    *.m4* files to it. All files in this directory will be gathered into *aclocal.m4*
    before Autoconf processes *configure.ac*.^([10](footnote.xhtml#ch02fn10))
  prefs: []
  type: TYPE_NORMAL
- en: It may now be more apparent why the *aclocal.m4* box in [Figure 2-2](ch02.xhtml#ch02fig02)
    couldn’t decide which color it should be. When you’re using it without Automake
    and Libtool, you write *aclocal.m4* by hand. However, when you’re using it with
    Automake, the file is generated by the `aclocal` utility, and you provide project-specific
    macros either in *acinclude.m4* or in an *m4* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Libtool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you build shared libraries on different Unix platforms without adding
    a lot of very platform-specific conditional code to your build system and source
    code? This is the question that the Libtool project tries to address.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a significant amount of common functionality among Unix-like platforms.
    However, one very significant difference has to do with how shared libraries are
    built, named, and managed. Some platforms name their libraries *lib*name*.so*,
    others use *lib*name*.a* or even *lib*name*.sl*. The Cygwin system for Windows
    names Cygwin-generated shared libraries *cyg*name*.dll*. Still others don’t even
    provide native shared libraries. Some platforms provide *libdl.so* to allow software
    to dynamically load and access library functionality at runtime, while others
    provide different mechanisms, and some platforms don’t provide this functionality
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: The developers of Libtool have carefully considered all of these differences.
    Libtool supports dozens of platforms, not only providing a set of Autoconf macros
    that hide library-naming differences in makefiles but also offering an optional
    library of dynamic loader functionality that can be added to programs. This functionality
    allows maintainers to make their runtime, dynamic shared-object management code
    more portable and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The libtool package provides the following programs, libraries, and header
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libtool` (program)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libtoolize` (program)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ltdl* (static and shared libraries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ltdl.h* (header file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*libtool*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `libtool` shell script that ships with the libtool package is a generic
    version of the custom script that `libtoolize` generates for a project.
  prefs: []
  type: TYPE_NORMAL
- en: '*libtoolize*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `libtoolize` shell script prepares your project to use Libtool. It generates
    a custom version of the generic `libtool` script and adds it to your project directory.
    This custom script is shipped with the project along with the Automake-generated
    makefiles, which execute the script on the user’s system at the appropriate time.
  prefs: []
  type: TYPE_NORMAL
- en: '*ltdl, the Libtool C API*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The libtool package also provides the *ltdl* library and associated header files,
    which provide a consistent runtime shared-object manager across platforms. The
    *ltdl* library may be linked statically or dynamically into your programs, giving
    them a consistent runtime shared-library access interface between platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](ch02.xhtml#ch02fig04) illustrates the interaction between the
    `automake` and `libtool` scripts, and the input files used to create products
    that configure and build your projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Automake and Libtool are both standard pluggable options that can be added to
    *configure.ac* with just a few simple macro calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: A data flow diagram for `automake` and `libtool`*'
  prefs: []
  type: TYPE_NORMAL
- en: Building Your Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As maintainer, you probably build your software packages fairly often, and you’re
    also probably intimately familiar with your project’s components, architecture,
    and build system. However, you should make sure that your users’ build experiences
    are much simpler than your own. One way to do this is to give users a simple,
    easy-to-understand pattern to follow when building your software packages. In
    the following sections, I’ll show you the build pattern supported by the Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: '*Running configure*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After running the Autotools, you’re left with a shell script called `configure`
    and one or more *Makefile.in* files. These files are intended to be shipped with
    your project release distribution packages.^([11](footnote.xhtml#ch02fn11)) Your
    users will download these packages, unpack them, and enter `./configure && make`
    from the top-level project directory. The `configure` script will generate makefiles
    (called *Makefile*) from the *Makefile.in* templates created by `automake` and
    a *config.h* header file from the *config.h.in* template generated by `autoheader`.
  prefs: []
  type: TYPE_NORMAL
- en: Automake generates *Makefile.in* templates rather than makefiles because without
    makefiles, your users can’t run `make`; you don’t want them to run `make` until
    after they’ve run `configure`, and this functionality guards against them doing
    so. *Makefile.in* templates are nearly identical to makefiles you might write
    by hand, except that you didn’t have to. They also do a lot more than most people
    are willing to hand-code. Another reason for not shipping ready-to-run makefiles
    is that it gives `configure` the chance to insert platform characteristics and
    user-specified optional features directly into the makefiles. This makes them
    a better fit for their target platforms and the end user’s build preferences.
    Finally, the makefiles can also be generated outside the source tree, which means
    you can create custom build systems in different directories for the same source
    directory tree. I’ll discuss this topic in greater detail in “Building Outside
    the Source Directory” on [page 28](ch02.xhtml#page_28).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](ch02.xhtml#ch02fig05) illustrates the interaction between `configure`
    and the scripts it executes during the configuration process in order to create
    the makefiles and the *config.h* header file.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: A data flow diagram for `configure`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `configure` script has a bidirectional relationship with another script
    called `config.status`. You may have thought that your `configure` script generated
    your makefiles. But actually, the only file (besides a log file) that `configure`
    generates is `config.status`.
  prefs: []
  type: TYPE_NORMAL
- en: The `configure` script is designed to determine platform characteristics and
    features available on the user’s system, as specified in the maintainer-written
    *configure.ac*. Once it has this information, it generates `config.status`, which
    contains all of the check results, and then it executes this script. The `config.status`
    script, in turn, uses the check information embedded within it to generate platform-specific
    *config.h* and makefiles, as well as any other template-based output files specified
    in *configure.ac*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As the double-ended fat arrow in [Figure 2-5](ch02.xhtml#ch02fig05) shows,
    *`config.status`* can also call *`configure`*. When used with the *`--recheck`*
    option, *`config.status`* will call *`configure`* using the same command line
    options used to originally generate *`config.status`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `configure` script also generates a log file called *config.log*, which
    will contain very useful information in the event that an execution of `configure`
    fails on the user’s system. As the maintainer, you can use this information for
    debugging. The *config.log* file also logs how `configure` was executed. (You
    can run `config.status --version` to discover the command line options used to
    generate `config.status`.) This feature can be particularly handy when, for example,
    a user returns from vacation and can’t remember which options they used to originally
    generate the project build directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To regenerate makefiles and the* config.h *header files, just enter* *`./config.status`*
    *from within the project build directory. The output files will be generated using
    the same options originally used to generate* *`config.status`*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *config.site* file can be used to customize the way `configure` works based
    on the `--prefix` option passed to it. The *config.site* file is a script, but
    it’s not meant to be executed directly. Rather, `configure` looks for *$(prefix)/share/config**.**site*
    and “sources” it (incorporates it as part of its own script) before executing
    any of its own code. This can be a handy way of specifying the same set of options
    for many packages, all destined to be built and installed the same way. Since
    `configure` is just a shell script, *config.site* should just contain shell code.
  prefs: []
  type: TYPE_NORMAL
- en: The *config.cache* file is generated by `configure` when the `-C` or `--config-cache`
    options are used. The results of configuration tests are cached in this file and
    are reusable by subdirectory `configure` scripts or by future runs of `configure`.
    By default, *config.cache* is disabled because it can be a potential source of
    configuration errors. If you’re confident with your configuration process, *config.cache*
    can really speed up the configuration process between executions of `configure`.
  prefs: []
  type: TYPE_NORMAL
- en: Building Outside the Source Directory
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A little-known feature of Autotools build environments is that they don’t need
    to be generated within a project source tree. That is, if a user executes `configure`
    from a directory other than the project source directory, they can generate a
    full build environment within an isolated build directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the user downloads *doofabble-3.0.tar.gz*, unpacks
    it, and creates two sibling directories called *doofabble-3.0.debug* and *doofabble-3.0.release*.
    They change into the *doofabble-3.0.debug* directory; execute doofabble’s `configure`
    script, using a relative path, with a doofabble-specific `debug` option; and then
    run `make` from within this same directory. Then they switch over to the *doofabble-3.0.release*
    directory and do the same thing, this time running `configure` without the `debug`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Users generally don’t care about remote build functionality, because all they
    usually want to do is configure, build, and install your code on their platforms.
    Maintainers, on the other hand, find remote build functionality very useful, as
    it allows them to not only maintain a reasonably pristine source tree but also
    to maintain multiple build environments for their project, each with complex configuration
    options. Rather than reconfigure a single build environment, a maintainer can
    simply switch to another build directory that has been configured with different
    options.
  prefs: []
  type: TYPE_NORMAL
- en: There is one case, however, where a user might wish to use remote-build. Consider
    the case where one obtains the full unpacked source code of a project on CD or
    has access to it via a read-only NFS mount. The ability to build outside the source
    tree can grant the ability to build the project without having to copy it to writable
    media.
  prefs: []
  type: TYPE_NORMAL
- en: '*Running make*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, you run plain old `make`. The designers of the Autotools went to a
    *lot* of trouble to ensure that you didn’t need any special version or brand of
    `make`. [Figure 2-6](ch02.xhtml#ch02fig06) depicts the interaction between `make`
    and the makefiles that are generated during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There has been some discussion on the Autotools mailing lists during the last
    few years about supporting only GNU *`make`*, as modern GNU *`make`* is so much
    more functional than other *`make`* utilities. Almost all Unix-y platforms (and
    even Microsoft Windows) have a version of GNU *`make`* today, so the rationale
    for continuing to support other brands of *`make`* is no longer as important as
    it once was.*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `make` runs several generated scripts, but these are all really
    ancillary to the `make` process. The generated makefiles contain commands that
    execute these scripts under the appropriate conditions. These scripts are part
    of the Autotools, and they are either shipped with your package or generated by
    your configuration script.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/02fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: A data flow diagram for `make`*'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Most Up-to-Date Autotools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’re running a variant of Linux and you’ve chosen to install the compilers
    and tools used for developing C-language software, you probably already have some
    version of the Autotools installed on your system. To determine which versions
    of Autoconf, Automake, and Libtool you’re using, simply open a terminal window
    and type the following commands (if you don’t have the `which` utility on your
    system, try type -p instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have the Linux-distribution varieties of these Autotools packages installed
    on your system, the executables will probably be found in* /usr/bin *rather than*
    /usr/local/bin, *as you can see from the output of the *`which`* command here.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to download, build, and install the latest released version of
    any one of these packages from the GNU website, you must do the same for all of
    them, because the Automake and Libtool packages install macros into the Autoconf
    macro directory. If you don’t already have the Autotools installed, you can install
    them using your system package manager (for example, `yum` or `apt`), or from
    source, using their GNU distribution source archives. The latter can be done with
    the following commands (be sure to change the version numbers as necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how to use the associated *.sig* files to validate
    the signature on GNU packages. The example assumes you have not configured a gpg
    key server on your system and that you have not installed the public key for any
    of these packages. If you have already configured a preferred key server, you
    can skip the `gpg` command line `--keyserver` options. Once you’ve imported the
    public keys for these packages, you need not do it again.
  prefs: []
  type: TYPE_NORMAL
- en: You may also wish to install in a manner that does not require root access via
    `sudo`. To do this, execute `configure` with a `--prefix` option such as `--prefix=$HOME/autotools`
    and then add *~/autotools/bin* to your `PATH` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to successfully execute the version-check commands from
    the previous example. If you still see older versions, ensure your `PATH` environment
    variable properly contains */usr/local/bin* (or wherever you installed to) before
    */usr/bin*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I presented a high-level overview of the Autotools to give
    you a feel for how everything ties together. I also showed you the pattern to
    follow when building software from distribution tarballs created by Autotools
    build systems. Finally, I showed you how to install the Autotools and how to tell
    which versions you have installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.xhtml), we’ll step away from the Autotools briefly and
    begin creating a hand-coded build system for a toy project called *Jupiter*. You’ll
    learn the requirements of a reasonable build system, and you’ll become familiar
    with the rationale behind the original design of the Autotools. With this background
    knowledge, you’ll begin to understand why the Autotools do things the way they
    do. I can’t really emphasize this enough: *[Chapter 3](ch03.xhtml) is one of the
    most important chapters in this book, because it will get you past any emotional
    stigma you may have associated with the Autotools due to misconceptions*.'
  prefs: []
  type: TYPE_NORMAL
