- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 6 GAINING A WEB SHELL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 获得 Web Shell
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Now that you understand the power of the bash shell, it should come as no surprise
    that hackers find popping a shell exhilarating. The phrase *popping a shell* describes
    the outcome of any attack whereby a hacker gains local or remote access to a system’s
    shell, then sends execution instructions to it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 bash shell 的强大功能，黑客发现爆破 shell 令人兴奋应该不再感到惊讶。*爆破 shell* 这个词描述了任何攻击的结果，即黑客获得了对系统
    shell 的本地或远程访问权限，然后向其发送执行指令。
- en: There are numerous ways to gain shell access to a remote system, each targeting
    different entry points. For example, you could gain a remote shell via a web application
    vulnerability, by brute-forcing system accounts on a server, or by exploiting
    a vulnerability in a network service, such as FTP or Server Message Block.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以获得对远程系统的 shell 访问权限，每种方法都针对不同的入口点。例如，你可以通过 web 应用程序漏洞获得远程 shell，或者通过暴力破解服务器上的系统账户，或者通过利用网络服务中的漏洞，如
    FTP 或 Server Message Block。
- en: These remote shells may differ from the bash shell you’re running on Kali, as
    they often come with limited interfaces and functionality, and without elevated
    privileges. Nonetheless, obtaining access to another computer’s shell is often
    the first step in performing some of the most catastrophic cyberattacks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些远程 shell 可能与在 Kali 上运行的 bash shell 不同，因为它们通常带有有限的界面和功能，并且没有提升的权限。尽管如此，获得对另一台计算机的
    shell 访问权限通常是执行一些最具破坏性的网络攻击的第一步。
- en: 'In this chapter, we’ll explore this popular approach to gaining initial access
    by using a *web shell*: a malicious script that provides an interface for unauthorized
    access to a web server. To achieve this, we’ll exploit *file upload vulnerabilities*
    that allow you to upload web shells to vulnerable websites.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨通过使用 *web shell* 获得初步访问权限的这种流行方法：web shell 是一种恶意脚本，它为未授权访问 web 服务器提供接口。为了实现这一点，我们将利用
    *文件上传漏洞*，允许你将 web shell 上传到易受攻击的网站。
- en: 'We’ll also gain initial access using *OS command injection*: a vulnerability
    that allows for remote code execution through the injection of operating system
    commands into a web application’s form fields. By the end of this chapter, you’ll
    have gained initial access to two lab servers and developed custom bash scripts
    to interact with the underlying system.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过 *操作系统命令注入* 获得初步访问权限：这是一种允许通过将操作系统命令注入到 web 应用程序表单字段中来实现远程代码执行的漏洞。到本章结束时，你将获得对两个实验室服务器的初步访问权限，并开发自定义的
    bash 脚本与底层系统进行交互。
- en: Arbitrary File Upload Vulnerabilities
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意文件上传漏洞
- en: An *arbitrary file upload vulnerability* is a fairly common security flaw in
    web applications. It allows users to upload file types that shouldn’t be accepted
    and is caused by improper configurations or poor file validation and restriction
    controls.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*任意文件上传漏洞* 是 web 应用程序中相当常见的安全缺陷。它允许用户上传不应该接受的文件类型，通常是由于配置不当或文件验证与限制控制措施不完善导致的。'
- en: As an example, the following vulnerable HTML accepts a user’s file via an HTTP
    POST request and moves the uploaded file to a specified target directory without
    validating the file’s type, size, or name. As a result, an attacker could upload
    any file, including a script, an executable, or other malicious content, to the
    server’s *uploads* directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，以下存在漏洞的 HTML 通过 HTTP POST 请求接受用户上传的文件，并将上传的文件移动到指定的目标目录，而不验证文件的类型、大小或名称。因此，攻击者可以上传任何文件，包括脚本、可执行文件或其他恶意内容到服务器的
    *uploads* 目录。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To exploit this code, an attacker might upload a file containing a PHP: Hypertext
    Preprocessor (PHP) web shell payload, typically with a.*php* extension. The web
    shell code would provide the attacker with a command execution interface on the
    target system. Here is a simplified example of such a web shell payload:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '为了利用这个漏洞，攻击者可能会上传一个包含 PHP: 超文本预处理器（PHP）web shell 负载的文件，通常具有 . *php* 扩展名。web
    shell 代码会为攻击者提供一个在目标系统上执行命令的接口。以下是此类 web shell 负载的简化示例：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The shell_exec() function allows a web application to execute shell commands
    from within a PHP script. It provides a way to interact with the server or operating
    system’s command line environment. When shell_exec() is called with a command
    as its parameter, it executes that command in the system shell and returns the
    output as a string with the same user as the application’s context (commonly *www-data*,
    *apache*, or *nginx*). The payload will execute commands sent to it via the cmd
    parameter in an HTTP GET request.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: shell_exec() 函数允许 Web 应用程序从 PHP 脚本中执行 Shell 命令。它提供了一种与服务器或操作系统命令行环境交互的方式。当 shell_exec()
    被调用并传入一个命令作为参数时，它将在系统 Shell 中执行该命令，并以与应用程序上下文相同的用户（通常是 *www-data*、*apache* 或 *nginx*）返回输出。有效载荷将通过
    HTTP GET 请求的 cmd 参数执行发送到它的命令。
- en: 'If the PHP web shell’s filename were *webshell.php*, the attacker could access
    it in a web browser by visiting the following URL: *http://target-site.com/uploads/webshell.php*.
    The PHP code in the web shell might then execute on the server, providing the
    attacker with an interface to execute commands on the system. Using the cmd URL
    query parameter, the attacker could, for example, list files on the server with
    ls: *http://target-site.com/uploads/webshell.php?cmd=ls*. If visited by a browser,
    this URL might execute the command on the target system and display the response
    in the browser.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PHP Web Shell 的文件名是 *webshell.php*，攻击者可以通过访问以下 URL 在 Web 浏览器中访问它：*http://target-site.com/uploads/webshell.php*。Web
    Shell 中的 PHP 代码可能会在服务器上执行，从而为攻击者提供一个接口，以便在系统上执行命令。通过 cmd URL 查询参数，攻击者可以例如使用 ls
    列出服务器上的文件：*http://target-site.com/uploads/webshell.php?cmd=ls*。如果浏览器访问此 URL，可能会在目标系统上执行命令并将响应显示在浏览器中。
- en: Kali has a list of built-in web shells for numerous languages in the */usr/
    share/webshells* directory. Alternatively, you can find web shells at *[https://github.com/nicholasaleks/webshells.git](https://github.com/nicholasaleks/webshells.git)*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kali 在 */usr/share/webshells* 目录下有多种语言的内建 Web Shell 列表。或者，你也可以在 *[https://github.com/nicholasaleks/webshells.git](https://github.com/nicholasaleks/webshells.git)*
    找到 Web Shell。
- en: Fuzzing for Arbitrary File Uploads
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对任意文件上传的模糊测试
- en: Developing and executing a web shell isn’t always as easy as the PHP example
    we just explored. Often you’ll need to bypass common controls used to protect
    against arbitrary file uploads. Let’s turn to the lab environment to explore tools
    for identifying these vulnerabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和执行 Web Shell 并不像我们刚才探讨的 PHP 示例那样简单。通常，你需要绕过一些常见的控制措施，这些措施用于防止任意文件上传。让我们转到实验环境，探索识别这些漏洞的工具。
- en: One way to identify upload vulnerabilities is to use automated web application
    scanning tools. In [Chapter 5](chapter5.xhtml), we used dirsearch to find endpoints
    and functions that allow file uploads. Our scan revealed that the *p-web-01* machine
    (172.16.10.10) has a file upload page at *http://172.16.10.10:8081/upload*. [Figure
    6-1](chapter6.xhtml#fig6-1) shows what your Kali Firefox browser should return
    when you navigate to this URL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 识别上传漏洞的一种方法是使用自动化的 Web 应用扫描工具。在[第 5 章](chapter5.xhtml)中，我们使用 dirsearch 查找允许文件上传的端点和功能。我们的扫描结果显示，*p-web-01*
    机器（172.16.10.10）在 *http://172.16.10.10:8081/upload* 上有一个文件上传页面。[图 6-1](chapter6.xhtml#fig6-1)
    显示了当你访问此 URL 时，Kali Firefox 浏览器应该返回的内容。
- en: '![](../images/pg119.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg119.jpg)'
- en: 'Figure 6-1: A file uploader on the p-web-01 machine'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：p-web-01 机器上的文件上传器
- en: As you can see, the web page tells us it accepts only files with the *.jpg*,
    *.jpeg*, *.gif*, and *.png* extensions. Using manual testing, we can verify whether
    the application actually enforces this requirement.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，网页告诉我们它只接受 *.jpg*、*.jpeg*、*.gif* 和 *.png* 后缀的文件。通过手动测试，我们可以验证该应用程序是否确实执行了这一要求。
- en: To upload the correct web shell payload to the target, however, we must perform
    reconnaissance. There is no such thing as a silver-bullet payload that works for
    every language, web application, framework, and platform.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了将正确的 Web Shell 有效载荷上传到目标，我们必须先进行侦察。没有一种“万能”有效载荷可以适用于所有语言、Web 应用程序、框架和平台。
- en: In previous chapters, scans against *p-web-01* told us that the web application
    uses Python and is running Flask, a web framework written in Python. Let’s try
    uploading a web shell that targets Python. First, download the *python-webshell-check.py*
    test file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，对 *p-web-01* 进行的扫描告诉我们，Web 应用程序使用 Python，并且运行 Flask，这是一种用 Python 编写的
    Web 框架。让我们尝试上传一个针对 Python 的 Web Shell。首先，下载 *python-webshell-check.py* 测试文件。
- en: NOTE
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can find this chapter’s files at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在此章节的文件中找到相关内容* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06)。'
- en: 'Now take a look at the file’s contents to better understand how it should work
    when we upload it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看文件的内容，以便更好地理解我们上传时它应该如何工作：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This Python script uses the imported subprocess module to execute a bash command
    on the underlying operating system. We hardcode the id bash command in the subprocess.check_output()
    function, which executes the specified command in a subprocess and captures its
    output. The shell=True parameter allows the command to be executed through the
    shell, enabling the use of shell-specific functions and syntax. Finally, we print
    the results of the command to the console after decoding from a byte type to a
    string. When executed, this code should retrieve the user and group information
    for the user running the web application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Python 脚本使用导入的 subprocess 模块来在底层操作系统上执行一个 bash 命令。我们在 subprocess.check_output()
    函数中硬编码了 id bash 命令，该命令会在一个子进程中执行并捕获其输出。shell=True 参数允许通过 shell 执行命令，使得可以使用特定于
    shell 的函数和语法。最后，我们将命令的结果从字节类型解码为字符串并打印到控制台。当执行时，这段代码应该能检索运行该 Web 应用程序的用户的用户和组信息。
- en: Unfortunately, as you can see in [Figure 6-2](chapter6.xhtml#fig6-2), we can’t
    upload the Python file to the web application. To check this yourself, click **Choose
    File**, browse to the saved web shell, then click **Upload**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如你在 [图6-2](chapter6.xhtml#fig6-2) 中看到的那样，我们无法将 Python 文件上传到网络应用程序中。为了自己检查这一点，点击
    **选择文件**，浏览到保存的 Web Shell，然后点击 **上传**。
- en: '![](../images/pg120.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg120.jpg)'
- en: 'Figure 6-2: A file-type upload error'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：文件类型上传错误
- en: In the next section, you’ll learn about several file upload bypass techniques
    you can use to evade restrictions and hopefully execute code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将学习到几种文件上传绕过技术，你可以利用这些技术避开限制，并有可能执行代码。
- en: Bypassing File Upload Controls
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绕过文件上传控制
- en: To protect against arbitrary file uploads, developers frequently use validating
    functions. These functions can verify a file’s size, extension, and other properties.
    However, hackers can leverage several common techniques to bypass many of these
    file upload controls. Let’s consider some of these techniques.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止任意文件上传，开发者通常使用验证函数。这些函数可以验证文件的大小、扩展名及其他属性。然而，黑客可以利用一些常见的技术绕过这些文件上传控制。我们来看看其中的一些技术。
- en: accept Attribute Modification
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: accept 属性修改
- en: 'Developers use the accept HTML attribute in file input elements to specify
    the types of files that the browser should allow users to select for upload. By
    default, this attribute restricts files based on their extensions or Multipurpose
    Internet Mail Extensions (MIME) types. For example, the following line of HTML
    uses the accept attribute to allow only specific file extensions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在文件输入元素中使用 accept HTML 属性来指定浏览器允许用户选择上传的文件类型。默认情况下，该属性根据文件的扩展名或多用途互联网邮件扩展（MIME）类型来限制文件。例如，以下
    HTML 代码使用 accept 属性只允许特定的文件扩展名：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But because this attribute is set on the client side, attackers can easily bypass
    the control to trick the application into accepting files with different extensions
    or MIME types. We can manipulate the accept attribute by using browser developer
    tools.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于这个属性是在客户端设置的，攻击者可以轻松绕过控制，欺骗应用程序接受具有不同扩展名或 MIME 类型的文件。我们可以通过使用浏览器开发者工具来修改
    accept 属性。
- en: By default, the ACME Hyper Branding web application doesn’t use accept attributes
    for the file upload input. To get a better understanding of how this control works,
    try modifying the client-side HTML to include the attribute, as shown in [Figure
    6-3](chapter6.xhtml#fig6-3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ACME Hyper Branding 网络应用程序并没有使用 accept 属性来控制文件上传输入。为了更好地理解这个控制是如何工作的，尝试修改客户端
    HTML 来包括该属性，如 [图6-3](chapter6.xhtml#fig6-3) 所示。
- en: '![](../images/pg121.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg121.jpg)'
- en: 'Figure 6-3: Using developer tools to modify the accept attribute'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：使用开发者工具修改 accept 属性
- en: If you attempt to upload files once more, you should notice that the Kali file
    explorer won’t display unsupported file types. However, you can easily append
    another file extension, like *.py*, to the accept attribute or tell it to accept
    all file extensions by using the wildcard (*) value. The web shell payload should
    then show up in the file explorer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次尝试上传文件，你应该会注意到Kali文件浏览器不会显示不支持的文件类型。然而，你可以轻松地在接受属性中附加另一个文件扩展名，如*.py*，或者通过使用通配符(*)值来告诉它接受所有文件扩展名。然后，web
    shell有效载荷应该会出现在文件浏览器中。
- en: This technique alone may not succeed in bypassing file upload controls, especially
    if the web application implements server-side validation and proper file-type
    checking. Let’s consider some server-side control bypasses.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单凭这项技术可能无法绕过文件上传控制，特别是如果web应用程序实施了服务器端验证和适当的文件类型检查。让我们考虑一些绕过服务器端控制的方法。
- en: File Extension Modification
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件扩展名修改
- en: We can attempt to upload a malicious web shell payload by changing its file
    extension to one that the application allows. For instance, renaming a malicious
    script from *webshell.php* to *webshell.jpg* may bypass file-extension checks
    that allow only image files to be uploaded.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过将恶意web shell有效载荷的文件扩展名更改为应用程序允许的扩展名来上传它。例如，将恶意脚本从*webshell.php*重命名为*webshell.jpg*，可能会绕过仅允许上传图像文件的文件扩展名检查。
- en: 'We can attempt to change the file extension for *python-webshell-check.py*
    to something like *python-webshell-check.jpg* and test the *p-web-01* web application’s
    upload functionality. Copy and rename the file by using this bash command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试将*python-webshell-check.py*的文件扩展名更改为类似*python-webshell-check.jpg*的文件，然后测试*p-web-01*
    web应用程序的上传功能。使用以下bash命令复制并重命名文件：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we attempt to upload the malicious script, the file should successfully
    upload, as shown in [Figure 6-4](chapter6.xhtml#fig6-4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试上传恶意脚本时，文件应该会成功上传，如[图6-4](chapter6.xhtml#fig6-4)所示。
- en: '![](../images/pg122-1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg122-1.jpg)'
- en: 'Figure 6-4: Successfully uploading the malicious script by changing its file
    extension'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：通过更改文件扩展名成功上传恶意脚本
- en: Can we now execute the script on the server? In [Chapter 5](chapter5.xhtml),
    we discovered the web application’s */uploads* directory. Let’s visit this directory
    in the browser by navigating to *[http://172.16.10.10:8081/uploads](http://172.16.10.10:8081/uploads)*.
    You should receive the error message in [Figure 6-5](chapter6.xhtml#fig6-5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在服务器上执行脚本吗？在[第5章](chapter5.xhtml)中，我们发现了web应用程序的*/uploads*目录。让我们通过浏览器访问该目录，方法是导航到*[http://172.16.10.10:8081/uploads](http://172.16.10.10:8081/uploads)*。你应该会收到[图6-5](chapter6.xhtml#fig6-5)中的错误信息。
- en: '![](../images/pg122-2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg122-2.jpg)'
- en: 'Figure 6-5: The ACME Hyper Branding /uploads directory error message'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：ACME Hyper Branding /uploads目录错误信息
- en: It looks like we’ll need to add a filename to the URL as a parameter. Try appending
    *python-webshell-check.jpg* to the end of this */uploads* URL endpoint and then
    visit it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们需要将文件名作为参数添加到URL中。尝试将*python-webshell-check.jpg*附加到这个*/uploads* URL端点的末尾，然后访问它。
- en: 'The browser request should succeed, and the file should automatically download.
    We can verify whether the integrity of the malicious script was kept intact by
    the server by checking the contents of the downloaded file. Run the following
    bash command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器请求应该会成功，并且文件应自动下载。我们可以通过检查下载文件的内容来验证恶意脚本的完整性是否被服务器保持。运行以下bash命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, the web application doesn’t execute the Python file or run the id shell
    command. Instead, it ignores the file contents and serves the file as a download
    when we visit its full URL path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，web应用程序不会执行Python文件或运行id shell命令。相反，它会忽略文件内容，当我们访问文件的完整URL路径时，将其作为下载提供。
- en: To execute malicious code, we’ll most likely need to rely on additional vulnerabilities
    in the application or server-side code that mishandle file uploads, perform insufficient
    validation, or incorrectly interpret the file’s content. By exploiting these vulnerabilities,
    we may be able to trick the server into executing the uploaded file as a script
    or executable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行恶意代码，我们很可能需要依赖应用程序或服务器端代码中的其他漏洞，这些漏洞可能导致文件上传处理不当、验证不足或错误解释文件内容。通过利用这些漏洞，我们可能能够欺骗服务器将上传的文件当作脚本或可执行文件执行。
- en: Another variation on this technique is using *double extensions*, whereby an
    attacker appends a second extension to a file to bypass file-type checks. For
    example, we could try renaming *webshell.php* to *webshell.php.jpg*. This trick
    might be able to bypass a control that checks only the last part of the file extension
    or relies solely on the file extension to determine the file type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的另一种变体是使用*双扩展名*，攻击者将第二个扩展名附加到文件后，以绕过文件类型检查。例如，我们可以尝试将*webshell.php*重命名为*webshell.php.jpg*。这种技巧可能能够绕过只检查文件扩展名最后部分或完全依赖文件扩展名来确定文件类型的控制。
- en: Malicious Polyglot Files
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 恶意多用途文件
- en: '*Polyglot files* are a fascinating kind of file that different applications
    interpret in different ways. This versatility stems from their exploitation of
    the specific structure and parsing rules of various file formats.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*多用途文件*是一种有趣的文件类型，不同的应用程序以不同的方式解析它们。这种多样性源自它们利用各种文件格式的特定结构和解析规则。'
- en: One way to create polyglot files is by manipulating the *file headers*, also
    known as *file signatures* or *magic bytes*, found at the beginning of the file.
    Operating systems and applications often use file headers to understand a file’s
    type so they can correctly interpret its data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多用途文件的一种方法是通过操控*文件头部*，也叫做*文件签名*或*魔术字节*，这些通常位于文件的开头。操作系统和应用程序通常使用文件头部来识别文件的类型，以便正确解释其数据。
- en: Malicious polyglot files could potentially circumvent security measures that
    validate a file’s extension or content type. By skillfully creating the file headers,
    we can deceive systems into treating files as benign when in reality they contain
    harmful content.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意的多用途文件有可能规避验证文件扩展名或内容类型的安全措施。通过巧妙地创建文件头部，我们可以欺骗系统将文件当作无害文件处理，而实际上它们包含有害内容。
- en: 'As an example, let’s consider the header for a JPEG image file. Ordinarily,
    JPEG files start with the standard magic byte signature of FF D8 FF E0, followed
    by additional bytes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们来看看JPEG图像文件的头部。通常，JPEG文件以标准的魔术字节签名FF D8 FF E0开头，后面跟着附加的字节：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We could try disguising the PHP web shell code as an innocent image file by
    cleverly appending the JPEG magic bytes to it, as demonstrated here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过巧妙地将JPEG魔术字节附加到PHP Webshell代码后，来伪装成一个无害的图像文件，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This bash command creates a malicious *polyglot.php* file with initial bytes
    suggesting that it is a JPEG file. After those bytes, however, we introduce PHP
    code. The injection will execute an eval() function using the cmd query parameter.
    You can use the file polyglot.php command to confirm the file’s type is a JPEG
    image data file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bash命令创建了一个恶意的*polyglot.php*文件，初始字节表明它是一个JPEG文件。但在这些字节之后，我们引入了PHP代码。注入将执行一个使用cmd查询参数的eval()函数。你可以使用polyglot.php命令来确认文件类型是JPEG图像数据文件。
- en: Many tools and libraries can help us manipulate image file headers. Examples
    include hex editors like HxD, Hex Fiend, and Bless and libraries like libjpeg
    and libpng. The powerful ImageMagick and ExifTool command line tools can also
    manipulate a wide range of image file formats.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具和库可以帮助我们操控图像文件头部。例如，像HxD、Hex Fiend和Bless这样的十六进制编辑器，或像libjpeg和libpng这样的库。强大的ImageMagick和ExifTool命令行工具也能操控多种图像文件格式。
- en: Certain conditions must exist for the malicious polyglot to work. First, when
    a user uploads the file, the server must interpret it as an image and save it
    successfully. Second, when the user requests the file, the PHP interpreter generating
    the response must recognize the file as a script and process it. In some cases,
    the file might need a.*php* extension to trigger PHP processing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意多用途文件要生效必须满足某些条件。首先，当用户上传文件时，服务器必须将其解释为图像并成功保存。其次，当用户请求该文件时，生成响应的PHP解释器必须将该文件识别为脚本并进行处理。在某些情况下，文件可能需要带有.*php*扩展名才能触发PHP处理。
- en: Other Bypass Techniques
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他绕过技巧
- en: In this section, we’ll briefly mention a few additional bypass techniques you
    could attempt.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要提到几种你可以尝试的其他绕过技巧。
- en: '*Null byte poisoning*, also known as *null byte injection* or *null character
    injection*, is used to manipulate file-handling systems that rely on null-terminated
    strings. This technique takes advantage of the presence of the null byte \x00,
    which marks the end of a string in various programming languages.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*空字节注入*，也称为*空字节注入攻击*或*空字符注入*，用于操控依赖于空字符终止字符串的文件处理系统。这种技术利用了空字节\x00的存在，它标志着在多种编程语言中字符串的结束。'
- en: This attack injects the null byte into the filename string, causing it to be
    truncated and potentially leading to unintended behavior. For instance, an attacker
    could rename *webshell.php* to *webshell.jpg%00.php*, injecting the URL-encoded
    representation of the null byte into the filename right after the *.jpg* extension.
    When processing the filename, a server may interpret it as *webshell.jpg*, unaware
    of the presence of the null byte and the subsequent.*php* extension. However,
    when the server later processes the file, it could read the file as a PHP script
    and execute the web shell.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击将空字节注入到文件名字符串中，导致文件名被截断，可能会导致意外行为。例如，攻击者可以将 *webshell.php* 重命名为 *webshell.jpg%00.php*，在
    * .jpg* 扩展名后注入空字节的 URL 编码表示。当服务器处理文件名时，它可能会将其解释为 *webshell.jpg*，未意识到空字节和随后的 *
    .php* 扩展名的存在。然而，当服务器稍后处理文件时，它可能将文件作为 PHP 脚本读取并执行 web shell。
- en: '*Content-Type header manipulation*, also known as *MIME type spoofing*, is
    a file upload control bypass technique that leverages the manipulation of the
    Content-Type header in the HTTP request sent during the file upload. By changing
    the header to an allowed content type, we can potentially bypass the server-side
    file checks. The attacker would capture their outbound upload request by using
    an HTTP intercepting proxy like Burp Suite to manipulate the Content-Type header
    before the request reaches the server.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*Content-Type 头部操作*，也称为 *MIME 类型伪造*，是一种通过操控文件上传过程中发送的 HTTP 请求中的 Content-Type
    头部来绕过文件上传控制的技术。通过将头部更改为允许的内容类型，我们可以潜在地绕过服务器端的文件检查。攻击者将使用类似 Burp Suite 的 HTTP 拦截代理捕获他们的上传请求，并在请求到达服务器之前操作
    Content-Type 头部。'
- en: Now that we’ve covered a few techniques, we can explore them in the lab environment
    to try uploading and executing a web shell.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些技术，可以在实验环境中探索它们，尝试上传并执行 web shell。
- en: Uploading Files with Burp Suite
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Burp Suite 上传文件
- en: Let’s exploit the arbitrary file upload vulnerability on the *p-web-01* server
    by using Burp Suite to manipulate the Content-Type HTTP header. Burp Suite is
    a popular security testing tool developed by PortSwigger that allows us to easily
    manipulate traffic being sent to web applications and view the responses they
    return.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 Burp Suite 操控 Content-Type HTTP 头部，利用 *p-web-01* 服务器上的任意文件上传漏洞进行攻击。Burp
    Suite 是一个由 PortSwigger 开发的流行安全测试工具，它使我们能够轻松操控发送到 web 应用程序的流量，并查看它们返回的响应。
- en: Burp Suite comes preinstalled in Kali. Start it by clicking the top-left corner
    of the Kali machine’s menu bar and searching for **burp suite**. This should open
    the Burp Suite graphical user interface (GUI) in a separate window. If this is
    your first time launching the application, it should prompt you to choose your
    license type and the type of project file you want to run. Create a temporary
    project with the default settings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Burp Suite 在 Kali 中预装。通过点击 Kali 机器菜单栏的左上角并搜索 **burp suite** 启动它。这将打开 Burp Suite
    图形用户界面（GUI）在一个独立的窗口中。如果这是你第一次启动该应用程序，它会提示你选择许可证类型和你希望运行的项目文件类型。创建一个使用默认设置的临时项目。
- en: Next, open the Burp Suite browser by navigating to the **Proxy** tab. Burp Suite
    allows you to temporarily halt all traffic between your client and remote web
    application by using its *proxy intercept* feature. We don’t need to enable this
    option currently, so ensure that its toggle button is set to **Intercept Is Off**,
    as shown in [Figure 6-6](chapter6.xhtml#fig6-6).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过导航到 **代理** 标签页打开 Burp Suite 浏览器。Burp Suite 允许你通过使用其 *代理拦截* 功能，暂时停止客户端与远程
    web 应用程序之间的所有流量。当前我们不需要启用此选项，因此请确保它的开关按钮设置为 **拦截关闭**，如 [图 6-6](chapter6.xhtml#fig6-6)
    所示。
- en: '![](../images/pg125.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg125.jpg)'
- en: 'Figure 6-6: The Burp Suite Proxy page'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6：Burp Suite 代理页面
- en: Next, click **Open Browser**. This should launch Burp Suite’s internal, Chromium-based
    browser and proxy its traffic to the currently running Burp Suite instance. We’ll
    use this browser to launch initial attacks against the web application. Navigate
    to the *p-web-01* web application by visiting its URL, *http://172.16.10.10:8081*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**打开浏览器**。这将启动 Burp Suite 内部的基于 Chromium 的浏览器，并将其流量代理到当前运行的 Burp Suite
    实例。我们将使用这个浏览器对 web 应用程序发起初步攻击。通过访问 *http://172.16.10.10:8081*，导航到 *p-web-01* web
    应用程序。
- en: Now visit the */upload* URL endpoint by using the Burp Suite browser. If you
    navigate to Burp Suite’s **Target** tab, you should see a directory structure
    similar to the one shown in [Figure 6-7](chapter6.xhtml#fig6-7). Click the upload
    link in the left navigation pane to see both the HTTP GET request and the response
    details.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 Burp Suite 浏览器访问 */upload* URL 端点。如果你导航到 Burp Suite 的 **目标** 标签，你应该会看到类似于
    [图 6-7](chapter6.xhtml#fig6-7) 中显示的目录结构。点击左侧导航窗格中的上传链接，查看 HTTP GET 请求和响应的详细信息。
- en: '![](../images/pg126.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg126.jpg)'
- en: 'Figure 6-7: The Burp Suite Target tab'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7：Burp Suite 的目标标签页
- en: Try uploading your original *python-webshell-check.py* file by using the Burp
    Suite browser and inspect the resulting traffic. You should get the File type
    is not allowed! error message. In Burp Suite, this should look as shown in [Figure
    6-8](chapter6.xhtml#fig6-8).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 Burp Suite 浏览器上传原始的 *python-webshell-check.py* 文件，并检查生成的流量。你应该会看到“文件类型不允许！”的错误信息。在
    Burp Suite 中，它应该如 [图 6-8](chapter6.xhtml#fig6-8) 所示。
- en: '![](../images/pg127.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg127.jpg)'
- en: 'Figure 6-8: Captured request and response traffic in Burp Suite'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-8：Burp Suite 中捕获的请求和响应流量
- en: 'In the request pane on the left, we can clearly see the HTTP POST request made
    to the */upload* endpoint. It includes information about the host, origin, and
    header, but we’ll focus on the body of the request, which contains the filename,
    content type, and the file content itself:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的请求窗格中，我们可以清楚地看到发送到 */upload* 端点的 HTTP POST 请求。它包含了主机、来源和头部信息，但我们将重点关注请求的主体，其中包含文件名、内容类型以及文件内容本身：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We want to change the Content-Type header value, so let’s forward this request
    to the Burp Suite *Repeater*, a tool used to manipulate HTTP requests and responses.
    Repeater allows us to tamper with any part of the HTTP request before we resend
    it to the web application. To send the request to Repeater, simply right-click
    the request pane and select **Send to Repeater**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望更改 `Content-Type` 头部的值，因此我们将这个请求转发到 Burp Suite 的*Repeater*，这是一个用于操作 HTTP
    请求和响应的工具。Repeater 允许我们在重新发送请求到 Web 应用程序之前，修改 HTTP 请求的任何部分。要将请求发送到 Repeater，只需右键点击请求窗格并选择
    **发送到 Repeater**。
- en: 'Now navigate to the **Repeater** tab in Burp Suite and modify the line Content-Type:
    text/x-python to Content-Type: image/jpeg. This small change will hopefully trick
    the web application into thinking we’re uploading a *.jpeg* file, when really,
    we’re uploading a Python file. Note that we’re not modifying the *.py* extension
    of the filename.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，转到 Burp Suite 中的 **Repeater** 标签，并将 `Content-Type: text/x-python` 修改为 `Content-Type:
    image/jpeg`。这个小的修改应该能够欺骗 Web 应用程序，让它认为我们上传的是一个 *.jpeg* 文件，而实际上我们上传的是一个 Python
    文件。请注意，我们并没有修改文件名的 *.py* 扩展名。'
- en: Click the **Send** button located at the top left of the GUI and analyze the
    response. The File upload was successful! message in the HTML content indicates
    that the Content-Type manipulation succeeded at bypassing the file format control.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 点击位于 GUI 左上角的 **发送** 按钮并分析响应。HTML 内容中的“文件上传成功！”消息表明，`Content-Type` 操作成功绕过了文件格式控制。
- en: Is the web shell now accessible in the web application’s */uploads* directory?
    Try browsing to the URL *http://172.16.10.10:8081/uploads/python-webshell-check.py*.
    As you can see in [Figure 6-9](chapter6.xhtml#fig6-9), the web page displays the
    contents of the Python file in a single line, instead of automatically serving
    it as a download as before.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Web Shell 是否可以在 Web 应用程序的 */uploads* 目录中访问？尝试浏览到 URL *http://172.16.10.10:8081/uploads/python-webshell-check.py*。正如在
    [图 6-9](chapter6.xhtml#fig6-9) 中看到的，网页以单行形式显示了 Python 文件的内容，而不是像之前那样自动作为下载提供。
- en: '![](../images/pg128.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg128.jpg)'
- en: 'Figure 6-9: The raw Python web shell uploaded to the web application'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-9：上传到 Web 应用程序的原始 Python Web Shell
- en: While we’ve made progress, our payload isn’t executing as expected on the web
    application. We wanted the *python-webshell-check.py* script to run the id bash
    command and return the output to us in an HTTP response. In the next section,
    we’ll discuss the importance of properly staging a web shell by considering its
    execution context, file location, access controls, and the type of web framework
    being targeted.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们取得了一些进展，但我们的有效载荷并没有如预期那样在 Web 应用程序中执行。我们希望 *python-webshell-check.py* 脚本执行
    `id bash` 命令，并将输出通过 HTTP 响应返回给我们。在下一节中，我们将讨论通过考虑执行上下文、文件位置、访问控制以及目标 Web 框架类型来正确部署
    Web Shell 的重要性。
- en: Staging Web Shells
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Shell 阶段
- en: 'Successfully popping a shell may involve technical considerations beyond simply
    exploiting a file upload vulnerability. Here are factors you should consider when
    staging a web shell:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 成功弹出 Shell 可能涉及技术层面的考虑，不仅仅是利用文件上传漏洞。以下是您在置备 Web Shell 时应考虑的因素：
- en: '**Execution context **Consider the target’s programming language, server configuration,
    and execution environment. For example, if the application runs on a PHP server,
    ensure that the web shell code is compatible with PHP syntax and features.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行上下文** 考虑目标的编程语言、服务器配置和执行环境。例如，如果应用程序运行在 PHP 服务器上，请确保 Web Shell 代码与 PHP
    语法和特性兼容。'
- en: '**Filepath and location **Determine an appropriate filepath and location for
    the web shell by considering the target application’s directory structure, access
    controls, and file-inclusion mechanisms. Identify writable directories and locations
    at which the web shell can be stored and executed effectively. For example, you
    might be able to upload non-image filepaths such as */uploads*, */files*, or */static*
    and images to */images* or */imgs*. There is no single standard, and files can
    live anywhere the developer desires. Identifying the web application’s root directory
    also helps. For example, websites are commonly stored at */var/www/html* on a
    web server.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件路径和位置** 通过考虑目标应用程序的目录结构、访问控制和文件包含机制，确定 Web Shell 的合适文件路径和位置。识别可写的目录和位置，以便
    Web Shell 可以有效地存储和执行。例如，您可能能够上传非图片文件路径，如 */uploads*、*/files* 或 */static*，以及图片文件到
    */images* 或 */imgs*。没有单一的标准，文件可以存放在开发人员希望的任何位置。识别 Web 应用程序的根目录也很重要。例如，网站通常存储在
    Web 服务器的 */var/www/html* 目录下。'
- en: '**Access controls and authorization **Consider any access controls, authentication
    mechanisms, or user roles implemented in the application. Exploiting vulnerabilities
    related to user roles, privilege escalation, or authentication can provide additional
    opportunities for successful web shell staging. For example, you may be required
    to authenticate in order to upload a file even if the file is then accessible
    to unauthenticated users.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问控制和授权** 考虑应用程序中实现的任何访问控制、身份验证机制或用户角色。利用与用户角色、权限提升或身份验证相关的漏洞，可以为成功的 Web
    Shell 置备提供额外的机会。例如，您可能需要进行身份验证才能上传文件，即使文件之后可以被未经身份验证的用户访问。'
- en: '**Web application firewalls **Security systems such as web application firewalls
    could detect attempts to upload commonly used web shells. They could also identify
    attempts to execute system commands via HTTP parameters. Thus, using popular web
    shells like *c99.php* or *b374k* may increase your chances of getting caught and
    blocked. Other security systems, such as endpoint detection and response, may
    observe system process activity; if they detect a web server process attempting
    to run shell commands, they may raise alarms or block the execution altogether.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 应用程序防火墙** 诸如 Web 应用程序防火墙等安全系统可能会检测到上传常见 Web Shell 的尝试。它们还可能识别通过 HTTP
    参数执行系统命令的尝试。因此，使用像 *c99.php* 或 *b374k* 这样的流行 Web Shell 可能会增加被发现和阻止的几率。其他安全系统，如端点检测与响应（EDR），可能会监视系统进程活动；如果它们检测到
    Web 服务器进程尝试执行 Shell 命令，可能会触发警报或完全阻止执行。'
- en: Let’s apply these principles to stage an effective web shell payload and completely
    compromise the *p-web-01* web application so we can execute whatever bash command
    we want on it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用这些原则，置备一个有效的 Web Shell 有效负载，并完全控制 *p-web-01* Web 应用程序，以便我们可以在其上执行任何我们想要的
    bash 命令。
- en: Finding Directory Traversal Vulnerabilities
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找目录遍历漏洞
- en: Although we spoofed the Content-Type header of the web shell to successfully
    bypass a server’s upload controls, we weren’t able to execute the malicious Python
    code because we didn’t properly stage the web shell on the Flask server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们伪造了 Web Shell 的 Content-Type 头以成功绕过服务器的上传控制，但我们未能执行恶意的 Python 代码，因为我们没有在
    Flask 服务器上正确置备 Web Shell。
- en: Applications built with the Flask framework may contain a file called *app.py*
    or another similar name that indicates an application’s entry point. This file
    is responsible for initializing and configuring the application; it creates an
    instance of the Flask application and defines its various routes, views, and configurations.
    Manipulating this file would be a great way to execute a web shell on a Flask
    application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flask 框架构建的应用程序可能包含一个名为 *app.py* 或其他类似名称的文件，该文件表示应用程序的入口点。此文件负责初始化和配置应用程序；它创建
    Flask 应用程序的实例，并定义其各种路由、视图和配置。操作这个文件是执行 Flask 应用程序 Web Shell 的一种有效方式。
- en: We can try to overwrite the *app.py* file of the *p-web-01* web application
    by uploading a tampered version of it that includes a malicious web shell route.
    However, to accomplish this task, we’ll first need to figure out if we can upload
    a file outside the */uploads* directory, which isn’t the parent directory of the
    application, where *app.py* should live.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过上传一个篡改过的 *app.py* 文件来覆盖 *p-web-01* 网络应用程序的原文件，这个篡改版本包含一个恶意的 Web Shell
    路由。然而，为了完成这个任务，我们首先需要弄清楚是否能够上传一个文件到 */uploads* 目录之外，因为 *app.py* 应该位于应用程序的父目录中，而该目录并不是
    *uploads* 目录。
- en: '*Directory traversal* vulnerabilities allow attackers to access files or directories
    outside the intended directory. This weakness can occur when input parameters
    or file upload functionality aren’t properly validated and sanitized. To exploit
    a directory traversal vulnerability, an attacker can craft a malicious filename
    that includes the directory traversal sequence ../.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*目录遍历* 漏洞允许攻击者访问目标目录以外的文件或目录。这种弱点通常出现在输入参数或文件上传功能未经过正确验证和清理的情况下。为了利用目录遍历漏洞，攻击者可以构造一个恶意文件名，其中包含目录遍历序列
    ../。'
- en: For example, an attacker could upload a file with the filename *../../../../../etc/password*,
    allowing them to potentially modify critical system information. A single dot
    (.) represents the current directory, and two dots (..) represent the parent directory.
    By using multiple dot-dot-slash patterns (../), we’re essentially navigating upward
    in the filesystem.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，攻击者可以上传一个文件，文件名为 *../../../../../etc/password*，从而可能修改系统的关键配置信息。一个点（.）表示当前目录，两个点（..）表示父目录。通过使用多个点点斜杠模式（../），我们基本上是在文件系统中向上导航。
- en: If we can manipulate the filename in our input, we could potentially traverse
    the filesystem, then upload the malicious *app.py* file to the app’s sensitive
    system directory. Let’s see if we can upload a file to another directory in *p-web-01*.
    Burp Suite’s Target tab shows us that the server has a */static* directory used
    to host permanent assets like the *hero.png* image, as shown in [Figure 6-10](chapter6.xhtml#fig6-10).
    Targeting this static directory would be a good way to detect whether the server
    is vulnerable to directory traversal upload attacks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以操控输入中的文件名，我们就有可能遍历文件系统，然后将恶意的 *app.py* 文件上传到应用程序的敏感系统目录。让我们看看是否可以将文件上传到
    *p-web-01* 的另一个目录中。Burp Suite 的 Target 标签显示服务器有一个 */static* 目录，用于托管像 *hero.png*
    图像这样的永久资源，如 [图 6-10](chapter6.xhtml#fig6-10) 所示。瞄准这个静态目录将是检测服务器是否容易受到目录遍历上传攻击的一个好方法。
- en: '![](../images/pg130.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg130.jpg)'
- en: 'Figure 6-10: The /static directory on p-web-01 shown in the Burp Suite Target
    tab'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-10：Burp Suite Target 标签中显示的 p-web-01 上的 /static 目录
- en: NOTE
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you can’t see images under the* /static *directory, click the* ***Filter***
    *bar below the Site Map tab, then click* ***Show All***.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在* /static *目录下看不到图片，点击* ***Filter*** *栏位，然后点击* ***Show All***。'
- en: In Burp Suite Repeater, we’ll include a relative path to the */static* directory
    in the filename of the *python-webshell-check.py* file. Rename it to *../static/python-webshell-check.py*,
    then send the request to the server. According to the response, the file should
    have been successfully uploaded. Browse to the */static/python-webshell-check.py*
    URL to verify this.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp Suite 的 Repeater 中，我们将在 *python-webshell-check.py* 文件的文件名中加入一个相对路径，指向
    */static* 目录。将其重命名为 *../static/python-webshell-check.py*，然后发送请求到服务器。根据响应，文件应该已经成功上传。浏览到
    */static/python-webshell-check.py* URL 来验证这一点。
- en: Uploading Malicious Payloads
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传恶意载荷
- en: Now that we know we can exploit a directory traversal vulnerability, let’s stage
    a malicious *app.py* payload. We’ll use the @app.route() function to include a
    new web shell endpoint in *p-web-01*. Download the malicious version of the *app.py*
    file from the book’s GitHub repository.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道可以利用目录遍历漏洞了，让我们来准备一个恶意的 *app.py* 载荷。我们将使用 @app.route() 函数在 *p-web-01*
    中加入一个新的 Web Shell 端点。从本书的 GitHub 仓库中下载恶意版本的 *app.py* 文件。
- en: 'When you open this file, you’ll see that it’s pretty much a direct copy of
    the original *app.py* file. However, we’ve added another route to the bottom of
    the file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开这个文件时，你会看到它几乎是原始 *app.py* 文件的直接复制。然而，我们在文件的底部添加了另一个路由：
- en: app.py
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: app.py
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The line at ❶ appends a new */webshell/<command>* URL, which executes the webshell()
    function. This function accepts a command as a parameter. The rest of the file
    looks very similar to the *python-webshell-check.py* file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这一行附加了一个新的 */webshell/<command>* URL，这个 URL 执行 webshell() 函数。该函数接受一个命令作为参数。文件的其余部分与
    *python-webshell-check.py* 文件非常相似。
- en: Let’s upload this web shell to *p-web-01* by using Burp Suite. First, exploit
    the directory traversal vulnerability by renaming the filename in the request
    to *../app.py*. Doing this should allow us to overwrite the original *app.py*
    file on the server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Burp Suite 将这个 web shell 上传到 *p-web-01*。首先，通过将请求中的文件名重命名为 *../app.py*，利用目录遍历漏洞。这样做应该允许我们覆盖服务器上原来的
    *app.py* 文件。
- en: The next step is to change the request’s Content-Type header to trick the server
    into thinking we’re uploading an image. Modify the header to include the image/jpeg
    content type. Then paste the content of the malicious file into the request’s
    body. Before clicking **Send**, make sure your request looks like the one in [Figure
    6-11](chapter6.xhtml#fig6-11). (Keep in mind that this screenshot does not display
    the entirety of the file’s contents in the request body.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将请求的 Content-Type 头部更改，以欺骗服务器认为我们正在上传一张图片。将头部修改为包含 image/jpeg 内容类型。然后将恶意文件的内容粘贴到请求的主体中。在点击
    **发送** 之前，确保你的请求看起来像 [图 6-11](chapter6.xhtml#fig6-11) 中的那样。（请记住，这张截图没有显示请求主体中完整的文件内容。）
- en: '![](../images/pg131.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg131.jpg)'
- en: 'Figure 6-11: Uploading the malicious app.py file containing a web shell route'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-11：上传包含 web shell 路由的恶意 app.py 文件
- en: If the request worked, you should get a File upload was successful! message.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求成功，你应该会看到 “文件上传成功！” 的信息。
- en: Note that the exploit preserved all the *app.py* file’s original functionality.
    This undercover web shell exploitation helps us evade detection, since we kept
    the site’s core behavior intact and didn’t create any new files. An analyst reviewing
    the */uploads* directory won’t find a web shell, as we added the shell to the
    web application’s source code. However, security systems such as *file integrity
    monitoring (FIM)* may catch that a file’s hash was changed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，利用这个漏洞保留了 *app.py* 文件的所有原始功能。这个隐蔽的 web shell 利用帮助我们避免被检测到，因为我们保持了站点的核心行为不变，并且没有创建任何新文件。审查
    */uploads* 目录的分析师不会找到 web shell，因为我们将 shell 添加到 Web 应用程序的源代码中。然而，像 *文件完整性监控 (FIM)*
    这样的安全系统可能会捕捉到文件哈希已被更改。
- en: In real-world scenarios, be very careful when attempting to overwrite an application.
    It may not always work on the first attempt, and you could break the application
    if a code error exists in the modified version. Always seek authorization when
    attempting dangerous penetration-testing techniques.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，尝试覆盖应用程序时要非常小心。这可能不会在第一次尝试时就成功，如果修改后的版本存在代码错误，可能会破坏应用程序。尝试危险的渗透测试技术时，务必寻求授权。
- en: Executing Web Shell Commands
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 Web Shell 命令
- en: After chaining together three separate vulnerabilities, we can now execute commands
    on *p-web-01*. To do this, navigate to the endpoint you just created and append
    a bash command to the URL. The command’s output should be returned in the browser
    response.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 经过三次漏洞链式利用后，我们现在可以在 *p-web-01* 上执行命令。为此，导航到你刚刚创建的端点，并将一个 bash 命令附加到 URL 上。命令的输出应在浏览器响应中返回。
- en: 'For example, to figure out what user we’re operating as, run the id command
    by navigating to *http://172.16.10.10:8081/webshell/id*. This should produce the
    following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要找出我们以哪个用户身份操作，可以运行 id 命令，访问 *http://172.16.10.10:8081/webshell/id*。这应该会输出以下内容：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Navigate to *http://172.16.10.10:8081/webshell/pwd* to figure out where we
    are on the system:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 *http://172.16.10.10:8081/webshell/pwd* 查看我们在系统中的位置：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, navigate to *http://172.16.10.10:8081/webshell/uname%20-a* to identify
    the operating system we just compromised:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，访问 *http://172.16.10.10:8081/webshell/uname%20-a* 来识别我们刚刚攻陷的操作系统：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that when we sent this uname -a bash command to the web shell, we had to
    URL-encode the space character by using the %20 representation. [Table 6-1](chapter6.xhtml#tab6-1)
    displays some commonly used URL-encoded characters you can insert into bash web
    shells.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们将 uname -a bash 命令发送到 web shell 时，我们必须使用 %20 表示法对空格字符进行 URL 编码。[表 6-1](chapter6.xhtml#tab6-1)
    显示了一些常用的 URL 编码字符，你可以将它们插入到 bash web shell 中。
- en: 'Table 6-1: Common URL-Encoded Characters for Bash Web Shells'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：Bash Web Shell 常用的 URL 编码字符
- en: '| Character | URL encoding |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | URL 编码 |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Space () | %20 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 空格 () | %20 |'
- en: '| Forward slash (/) | %2F |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 斜杠 (/) | %2F |'
- en: '| Question mark (?) | %3F |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 问号 (?) | %3F |'
- en: '| Ampersand (&) | %26 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 和号 (&) | %26 |'
- en: '| Equal sign (=) | %3D |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 等号 (=) | %3D |'
- en: '| Colon (:) | %3A |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 冒号 (:) | %3A |'
- en: '| Semicolon (;) | %3B |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 分号 (;) | %3B |'
- en: '| Hash (#) | %23 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 哈希 (#) | %23 |'
- en: '| Plus sign (+) | %2B |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 加号 (+) | %2B |'
- en: '| Comma (,) | %2C |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 逗号 (,) | %2C |'
- en: Now that we have an initial foothold on the server, let’s develop a unique bash
    script that we can use to better interface with it, so we don’t have to use the
    browser.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在服务器上获得了初步控制，让我们开发一个独特的 bash 脚本，以便更好地与其交互，这样我们就不必使用浏览器了。
- en: 'Exercise 8: Building a Web Shell Interface'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 8：构建一个 Web Shell 接口
- en: In this exercise, you’ll develop a bash script you can use to automatically
    send commands to the web shell you uploaded to *p-web-01* (172.16.10.10) and then
    parse the output you receive. The script should interact with the web shell by
    sending HTTP requests that were generated based on bash commands entered at a
    local bash input prompt.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将开发一个 bash 脚本，用于自动向你上传到 *p-web-01*（172.16.10.10）的 Web Shell 发送命令，并解析你收到的输出。该脚本应通过发送基于本地
    bash 输入提示符输入的 bash 命令生成的 HTTP 请求与 Web Shell 进行交互。
- en: The commands may use special characters, so you’ll need to ensure that you properly
    encode all inputs. You’ll also want to return clean output that contains only
    the relevant command execution response. [Listing 6-1](chapter6.xhtml#Lis6-1)
    shows an example of such a web shell script.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令可能包含特殊字符，因此你需要确保正确编码所有输入。你还需要返回干净的输出，只包含相关的命令执行响应。[清单 6-1](chapter6.xhtml#Lis6-1)
    显示了一个这样的 Web Shell 脚本示例。
- en: webshell.sh
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: webshell.sh
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-1: A web shell interface'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-1：一个 Web Shell 接口
- en: We begin the script by collecting the host address and port for the remote target
    to which we want to connect ❶. Inside a while loop, the script asks the user to
    enter a command to execute ❷. We encode the command string by using jq and its
    built-in @uri function, which converts the input string to a URI-encoded string.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过收集远程目标的主机地址和端口来开始脚本，以便我们可以连接到目标 ❶。在一个 while 循环内，脚本要求用户输入要执行的命令 ❷。我们通过使用
    jq 及其内置的 @uri 函数对命令字符串进行编码，该函数将输入字符串转换为 URI 编码字符串。
- en: Next, we send the target a specially crafted curl request ❸. The -s option suppresses
    any unnecessary curl output that isn’t directly related to the bash command. Next,
    the -w argument specifies a custom output format for curl. In this case, "%{http_code}"
    is a placeholder that will be replaced with the request’s HTTP response code.
    This allows us to retrieve the status code separately. Also, we can see that this
    curl request uses the -o output argument and points it to */dev/null*, meaning
    we discard the response body.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向目标发送一个特别构造的 curl 请求 ❸。-s 选项抑制任何与 bash 命令无关的不必要的 curl 输出。接下来，-w 参数指定 curl
    的自定义输出格式。在这种情况下，"%{http_code}" 是一个占位符，将被请求的 HTTP 响应代码替换。这使我们能够单独获取状态码。此外，我们可以看到，这个
    curl 请求使用了 -o 输出参数，并将其指向 */dev/null*，意味着我们丢弃响应体。
- en: At ❹, we check whether the HTTP status code is 200\. We then send a second curl
    request to retrieve the output at ❺.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❹，我们检查 HTTP 状态码是否为 200。然后我们发送第二个 curl 请求来获取 ❺ 处的输出。
- en: 'Can you further improve this script? Try implementing some of the following
    features:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你能进一步改进这个脚本吗？尝试实现以下一些功能：
- en: '**Using a single HTTP request **Remove the need to send two curl requests for
    each command.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用单个 HTTP 请求**：移除每个命令都需要发送两个 curl 请求的需求。'
- en: '**Changing directory persistence **When using cd to move around the filesystem,
    have your script keep track of the present working directory.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**改变目录持久性**：使用 cd 在文件系统中移动时，让你的脚本跟踪当前工作目录。'
- en: '**Creating a history audit log **When commands are sent to the web shell, store
    them in a log that remembers which commands were executed and when.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建历史审计日志**：当命令被发送到 Web Shell 时，将它们存储在一个日志中，记录哪些命令在何时执行。'
- en: '**Using a quick access alias **Instead of requiring users to manually type
    the target host and port in the script, accept these parameters as command line
    arguments and then store the full script path with these arguments as an alias.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用快速访问别名**：不再要求用户手动输入目标主机和端口，而是将这些参数作为命令行参数接收，并将包含这些参数的完整脚本路径存储为别名。'
- en: Limitations of Web Shells
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Shell 的局限性
- en: Despite their usefulness, web shells have several limitations. Here we discuss
    some of their common downsides.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Web Shell 很有用，但它们有几个局限性。这里我们讨论一些常见的缺点。
- en: Lack of Persistence
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺乏持久性
- en: Web shells are often temporary, existing only as long as the compromised web
    server remains accessible. System administrators may regularly monitor and clean
    up uploaded files, reducing their persistence and effectiveness. Also, if the
    server is taken down, patched, or reconfigured, the web shell may become ineffective,
    reducing your ability to maintain access.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Web Shell 通常是临时的，仅在被攻陷的 Web 服务器仍然可访问时存在。系统管理员可能会定期监控并清理上传的文件，从而降低它们的持久性和有效性。此外，如果服务器被关闭、打补丁或重新配置，Web
    Shell 可能会变得无效，从而降低你保持访问的能力。
- en: Lack of Real-Time Responses
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时响应的缺乏
- en: Real-time responses from commands such as a ping won’t work, and unless you
    limit the number of ping commands you send, your web shell may hang, as hotkeys
    like CTRL-C to exit the command won’t be available.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 来自命令的实时响应，如 ping，将无法工作，除非你限制发送的 ping 命令的数量，否则你的 Web Shell 可能会挂起，因为像 CTRL-C 这样的热键无法使用来退出命令。
- en: Limited Functionality
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能有限
- en: Web shells often provide limited feedback or error messages, making it challenging
    to troubleshoot issues or understand the underlying cause of failures. They provide
    only a subset of the functionality available through native system administrative
    tools and may lack advanced bash features, such as key bindings.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Web Shell 通常提供有限的反馈或错误信息，这使得故障排除或理解失败的根本原因变得具有挑战性。它们仅提供通过本地系统管理工具可用功能的一个子集，并且可能缺少一些高级的
    bash 功能，例如键盘快捷键。
- en: 'We’ve considered one way of gaining initial access to a target server. Let’s
    end this chapter by considering an additional method: OS command injection.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考虑了一种获取目标服务器初始访问的方法。让我们通过考虑另一种方法来结束本章：操作系统命令注入。
- en: OS Command Injection
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统命令注入
- en: '*OS command injection* is a type of security vulnerability that occurs when
    an application allows users to execute unauthorized operating system commands
    by supplying them as input to the application. As attackers, we can exploit a
    target’s lack of proper input sanitization to inject these malicious commands
    and gain an initial foothold into systems.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作系统命令注入*是一种安全漏洞，当应用程序允许用户通过输入未授权的操作系统命令并将其传递给应用程序时，就会发生此漏洞。作为攻击者，我们可以利用目标系统缺乏适当的输入清理来注入这些恶意命令，从而获得对系统的初步控制。'
- en: Unlike web shells, OS command injection attacks don’t require us to upload malicious
    files to a server. Instead, we must identify places in the target application
    that rely directly on user input to construct operating system commands. Then,
    we must manipulate the user-supplied input by injecting specially crafted characters
    or sequences into them to break out of the intended input context and run our
    own commands.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Web Shell 不同，操作系统命令注入攻击不需要我们将恶意文件上传到服务器。相反，我们必须识别目标应用程序中直接依赖用户输入来构造操作系统命令的地方。然后，我们必须通过注入特制字符或序列来操纵用户提供的输入，突破预期的输入上下文并运行我们自己的命令。
- en: 'For example, the following is a snippet from a Python web application that
    allows users to submit a filename for processing:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个 Python Web 应用程序的代码片段，允许用户提交文件名以进行处理：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the application’s process_file() function takes the filename
    parameter and passes it to the ls -l operating system command without first checking
    the input for special characters or other malicious content.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，应用程序的 process_file() 函数接受文件名参数，并将其传递给 ls -l 操作系统命令，而没有首先检查输入中的特殊字符或其他恶意内容。
- en: 'An attacker can exploit this vulnerability if the value to filename comes from
    a different function that accepts untrusted user input; in that case, they could
    inject additional commands into the filename parameter. For instance, if an attacker
    submitted a malicious filename input, such as file.txt; id, the application would
    construct the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件名的值来自另一个接受不可信用户输入的函数，攻击者就可以利用此漏洞；在这种情况下，他们可以将额外的命令注入文件名参数。例如，如果攻击者提交了一个恶意的文件名输入，比如file.txt;
    id，应用程序将构造以下命令：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This input would first execute the intended ls -l command by using the parameter
    file.txt, then run the injected id command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该输入首先通过使用文件名 file.txt 执行预定的 ls -l 命令，然后运行注入的 id 命令。
- en: Notice that the input relies on the semicolon bash control operator (;) to escape
    the intended input context. In Chapters 1 and 2, you learned about several of
    these operators, which hold special meanings to the bash interpreter. [Table 6-2](chapter6.xhtml#tab6-2)
    illustrates how to use these operators as a way to test for possible OS command
    injection vulnerabilities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入依赖于分号 bash 控制操作符（;）来转义预期的输入上下文。在第1章和第2章中，您学到了一些这些操作符，它们对 bash 解释器具有特殊意义。[表6-2](chapter6.xhtml#tab6-2)展示了如何使用这些操作符来测试可能存在的操作系统命令注入漏洞。
- en: 'Table 6-2: Common OS Command Injection Techniques'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2：常见的操作系统命令注入技术
- en: '| Operator | Description | Example usage |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 操作符 | 描述 | 示例用法 |'
- en: '| --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Semicolon (;) | Executes multiple commands in a single line | filename=abc.txt;
    id |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 分号 (;) | 在单行中执行多个命令 | 文件名=abc.txt; id |'
- en: '| Pipe (&#124;) or double pipe (&#124;&#124;) | Chains commands and redirects
    command output, as well as provides OR conditional logic | filename=abd.txt &#124;
    cat /etc/passwd |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 管道符（&#124;）或双管道符（&#124;&#124;） | 连接命令并重定向命令输出，同时提供OR条件逻辑 | 文件名=abd.txt &#124;
    cat /etc/passwd |'
- en: '| Ampersand (&) or double ampersand (&&) | Concatenates commands or runs them
    in the background, as well as provides AND conditional logic | filename=abc.txt
    & ls -l |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| &符号或双&符号 (&) | 连接命令或在后台运行命令，同时提供AND条件逻辑 | 文件名=abc.txt & ls -l |'
- en: '| Command substitution (`, $()) | Substitutes commands | filename=`cat /etc/passwd`
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 命令替换 (`, $()) | 替换命令 | 文件名=`cat /etc/passwd` |'
- en: '| Redirection operators (>, >>, <) | Redirects input/output | filename=abc;
    cat /etc/passwd > pass.txt |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 重定向操作符 (>, >>, <) | 重定向输入/输出 | 文件名=abc; cat /etc/passwd > pass.txt |'
- en: '| Double and single quotes (", '') | Encapsulates command arguments | filename="abc.txt;
    id" |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 双引号和单引号 (", '') | 封装命令参数 | 文件名="abc.txt; id" |'
- en: Let’s exploit an OS command injection vulnerability in the lab. Instead of using
    special hacking tools to find the vulnerability, we’ll lean on our understanding
    of bash syntax.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实验室中利用操作系统命令注入漏洞。我们不使用特殊的黑客工具来发现漏洞，而是依赖我们对 bash 语法的理解。
- en: 'We’ll target the *p-web-02* web application located at *http://172.16.10.12*.
    When scanning this application in [Chapter 5](chapter5.xhtml), we noticed two
    interesting endpoints: the *donate.php* file and the *amount_to_donate.txt* file.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将瞄准位于 *http://172.16.10.12* 的 *p-web-02* web 应用程序。在 [第5章](chapter5.xhtml)
    扫描此应用程序时，我们注意到两个有趣的端点：*donate.php* 文件和 *amount_to_donate.txt* 文件。
- en: Take a look at the *donate.php* web page by browsing to *http://172.16.10.12/donate.php*.
    As shown in [Figure 6-12](chapter6.xhtml#fig6-12), the page appears to contain
    a simple form with a text input field and a submission button.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览至 *http://172.16.10.12/donate.php* 查看 *donate.php* 网页。如图 [6-12](chapter6.xhtml#fig6-12)
    所示，页面似乎包含一个简单的表单，其中有一个文本输入字段和一个提交按钮。
- en: '![](../images/pg136.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg136.jpg)'
- en: 'Figure 6-12: The donate page on the p-web-02 application'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-12：p-web-02应用程序上的捐赠页面
- en: By performing manual testing, we’ll get a better idea of how this application
    functions. Try entering **1** in the text input field, then submit it ([Figure
    6-13](chapter6.xhtml#fig6-13)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手动测试，我们将更好地了解此应用程序的功能。尝试在文本输入字段中输入 **1**，然后提交它（[图6-13](chapter6.xhtml#fig6-13)）。
- en: '![](../images/pg137-1.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg137-1.jpg)'
- en: 'Figure 6-13: A successful donation response'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-13：成功的捐赠响应
- en: As you can see, it looks like the input we entered is displayed in the response
    message shown on the page. Notice how the URL of the page changed to include an
    amount parameter that is equal to 1.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，输入内容显示在页面上显示的响应消息中。请注意页面的 URL 如何更改以包含等于 1 的金额参数。
- en: Now, take a look at the *amount_to_donate.txt* file by browsing to *http://172.16.10.12/amount_to_donate.txt*.
    You should see that the 1 value we previously entered from the *donate.php* form
    was saved to this *.txt* file on the server. This indicates that some type of
    filesystem processing is being executed on the server, based on input from the
    web application, and that the form we discovered might be a good entry point for
    injected OS commands.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览至 *http://172.16.10.12/amount_to_donate.txt* 查看 *amount_to_donate.txt*
    文件。您会看到我们之前从 *donate.php* 表单输入的值 1 已保存到服务器上的此 *.txt* 文件中。这表明基于来自 web 应用程序的输入执行了某种类型的文件系统处理，并且我们发现的表单可能是注入操作系统命令的良好入口点。
- en: Let’s attempt to perform OS command injection in the *donate.php* page. Submit
    the semicolon control operator (;) as well as the bash command id in the form.
    Unfortunately, a validation script seems to catch the semicolon character. You
    should see the message *Character ; is not allowed* displayed on the web page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Not to worry; we can try a different method. Let’s inject a pipe character (|)
    instead of a semicolon. As you can see in [Figure 6-14](chapter6.xhtml#fig6-14),
    the input is accepted.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg137-2.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: A successful OS command injection response'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: If you check the *amounts_to_donate.txt* file, you should see evidence that
    the command was successfully injected into the file, as we’re able to identify
    the output of running the id command. In [Figure 6-15](chapter6.xhtml#fig6-15),
    you can see that the *www-data* user is running the *p-web-02* (172.16.10.12)
    web application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg138.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The injected command’s output'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Using the browser’s Inspect tool or a Burp Suite proxy, we can see that the
    OS command injection occurs by sending a GET request to */donate.php?amount=*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Building a Command Injection Interface'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Like the web shell interface you built in Exercise 8, develop a bash script
    that makes it easier to send commands to *p-web-02* by exploiting its OS command
    injection vulnerability.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: This interface script should interact with the *donate.php* endpoint for sending
    commands as well as the *amount_to_donate.txt* endpoint for parsing and displaying
    the response of your commands. The script should also return only the response
    from the current command, not a full dump of all the previous command results
    in the *amount_to_donate.txt* file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](chapter6.xhtml#Lis6-2) shows an example solution.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: os-command -injection.sh
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 6-2: An OS command injection interface'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The code begins much like the web shell interface script: by collecting target
    connection details and beginning a while loop that prompts the user for commands
    to encode.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Before sending the OS command injection request, the script first needs to take
    a snapshot of the *amount_to_donate.txt* file’s contents and save it to a variable
    called prev_resp ❶. We’ll discuss why we’re doing this shortly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Within the next curl request, we inject the amount parameter with the encoded
    command and prepend the 1| value to it ❷. After sending the curl request, we then
    send another snapshot request to capture the new *amount_to_donate.txt* file contents
    in the new_resp variable ❸.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to display the correct output from the command, we run a diff operation
    to extract the difference between the prev_resp and the new_resp variables ❹.
    The diff output is stored in a delta variable, which showcases all the new *amount_to_donate.txt*
    file lines that were created after our injection.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Try extending this script to make it more useful. For example, you could add
    support for viewing all commands that have been executed, along with their responses,
    by writing them to a file, then presenting them during the script’s runtime when
    a special command is used.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Command Injection Restrictions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we observed, developers often implement sanitization checks to prevent OS
    command injection attacks against their web applications. We got lucky, as the
    pipe (|) character wasn’t blocked in our target. Even so, it’s important to understand
    a few methods you could use to bypass command injection controls.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation and Encoding
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we sent commands to a web shell earlier in this chapter, URL encoding requirements
    posed a challenge we needed to overcome. However, encoding and obfuscation may
    actually help us evade detection in some cases. Techniques like URL encoding,
    base64 encoding, and character encoding can hide the payload from security controls,
    checks, and filters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could base64-encode an entire command, such as ls -l, and hide
    it in the input. Test this encoding by sending the following payload to */donate.php*:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should receive a full filesystem listing of the web application’s present
    working directory.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: This technique aims to evade simple pattern-matching or filtering mechanisms
    used for detection. Basic techniques such as the use of regular expressions will
    have trouble identifying bash commands in the encoded bHMgLWw= string.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Globbing
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Globbing* is the process of using wildcard patterns to partially or fully
    match filenames or other content in files. A string is considered a wildcard pattern
    if it contains characters such as ?, *, [,], or !.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Globbing is interesting because it allows us to specify patterns that expand
    to specific filenames or directories without actually providing the exact name,
    potentially bypassing accessing restrictions. Consider the */etc/passwd* file
    on Linux. To view it, we could use ls, followed by the specific path and filename:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But we could also run a command such as this one to list the file by using
    the ? wildcard character:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Bash will try to match this pattern to files under the */etc* directory. Since
    *passwd* is the only file with a name pattern that is similar, the *?* character
    will expand to *a*, which matches *passwd*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same approach to access potentially restricted directories:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because no other directory names are three characters long and start with *e*
    at the root of the filesystem (*/*), the pattern will match the */etc* directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Globbing can get more extreme. How about filling in all characters with question
    marks except the last character? This, too, would match */etc/passwd* if no similar
    filenames exist in the directory:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can combine globbing with brace expansion to match more than one pattern
    under */etc*. In the following example, bash will search for files that start
    with *p* and end with *d*, as well as files that start with *g* and end with *p*.
    This should match files such as */etc/passwd* and */etc/group*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将通配符与大括号扩展（brace expansion）结合起来，以匹配 */etc* 下的多个模式。在以下示例中，bash 将搜索以 *p* 开头、以
    *d* 结尾的文件，以及以 *g* 开头、以 *p* 结尾的文件。这应该会匹配如 */etc/passwd* 和 */etc/group* 这样的文件：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Familiarizing yourself with features like globbing is helpful because you may
    run into applications (or even web application firewalls) that restrict the use
    of certain characters in input without taking into consideration globbing, allowing
    us to bypass filters and validations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉像通配符（globbing）这样的特性是有帮助的，因为你可能会遇到一些应用程序（甚至是 web 应用防火墙），它们限制了输入中某些字符的使用，而没有考虑到通配符，这使得我们能够绕过过滤器和验证。
- en: For example, web application firewalls commonly block requests to URLs containing
    parameters such as *http://example.com?file=/etc/passwd*. Depending on how the
    application uses the filename, globbing may help bypass the firewall’s detection
    logic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，web 应用防火墙通常会阻止对包含如 *http://example.com?file=/etc/passwd* 这样的参数的 URL 的请求。根据应用程序如何使用文件名，通配符可能有助于绕过防火墙的检测逻辑。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As you’ve seen in previous chapters, the power of the bash shell is undeniable,
    making popping a shell an exciting prospect. These shells open up possibilities
    for further exploitation and lateral movement on the target system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中看到的，bash shell 的强大功能是不可否认的，这也使得打开一个 shell 成为一个令人兴奋的前景。这些 shell 为进一步的利用和目标系统的横向移动提供了可能性。
- en: In this chapter, we gained low-privileged footholds into targeted systems by
    deploying web shells and injecting OS commands. We also used bash to craft accessible
    interfaces to these vulnerabilities and explored ways of obfuscating bash commands
    through strategies like globbing. In the next chapter, we’ll explore a few more
    techniques for establishing remote shells across different environments.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过部署 web shell 和注入操作系统命令，获得了对目标系统的低权限立足点。我们还利用 bash 构建了这些漏洞的可访问接口，并探讨了通过通配符等策略对
    bash 命令进行混淆的方法。在下一章中，我们将探索一些跨不同环境建立远程 shell 的技术。
