- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 6 GAINING A WEB SHELL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you understand the power of the bash shell, it should come as no surprise
    that hackers find popping a shell exhilarating. The phrase *popping a shell* describes
    the outcome of any attack whereby a hacker gains local or remote access to a system’s
    shell, then sends execution instructions to it.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous ways to gain shell access to a remote system, each targeting
    different entry points. For example, you could gain a remote shell via a web application
    vulnerability, by brute-forcing system accounts on a server, or by exploiting
    a vulnerability in a network service, such as FTP or Server Message Block.
  prefs: []
  type: TYPE_NORMAL
- en: These remote shells may differ from the bash shell you’re running on Kali, as
    they often come with limited interfaces and functionality, and without elevated
    privileges. Nonetheless, obtaining access to another computer’s shell is often
    the first step in performing some of the most catastrophic cyberattacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore this popular approach to gaining initial access
    by using a *web shell*: a malicious script that provides an interface for unauthorized
    access to a web server. To achieve this, we’ll exploit *file upload vulnerabilities*
    that allow you to upload web shells to vulnerable websites.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also gain initial access using *OS command injection*: a vulnerability
    that allows for remote code execution through the injection of operating system
    commands into a web application’s form fields. By the end of this chapter, you’ll
    have gained initial access to two lab servers and developed custom bash scripts
    to interact with the underlying system.'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary File Upload Vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *arbitrary file upload vulnerability* is a fairly common security flaw in
    web applications. It allows users to upload file types that shouldn’t be accepted
    and is caused by improper configurations or poor file validation and restriction
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the following vulnerable HTML accepts a user’s file via an HTTP
    POST request and moves the uploaded file to a specified target directory without
    validating the file’s type, size, or name. As a result, an attacker could upload
    any file, including a script, an executable, or other malicious content, to the
    server’s *uploads* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To exploit this code, an attacker might upload a file containing a PHP: Hypertext
    Preprocessor (PHP) web shell payload, typically with a.*php* extension. The web
    shell code would provide the attacker with a command execution interface on the
    target system. Here is a simplified example of such a web shell payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The shell_exec() function allows a web application to execute shell commands
    from within a PHP script. It provides a way to interact with the server or operating
    system’s command line environment. When shell_exec() is called with a command
    as its parameter, it executes that command in the system shell and returns the
    output as a string with the same user as the application’s context (commonly *www-data*,
    *apache*, or *nginx*). The payload will execute commands sent to it via the cmd
    parameter in an HTTP GET request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the PHP web shell’s filename were *webshell.php*, the attacker could access
    it in a web browser by visiting the following URL: *http://target-site.com/uploads/webshell.php*.
    The PHP code in the web shell might then execute on the server, providing the
    attacker with an interface to execute commands on the system. Using the cmd URL
    query parameter, the attacker could, for example, list files on the server with
    ls: *http://target-site.com/uploads/webshell.php?cmd=ls*. If visited by a browser,
    this URL might execute the command on the target system and display the response
    in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Kali has a list of built-in web shells for numerous languages in the */usr/
    share/webshells* directory. Alternatively, you can find web shells at *[https://github.com/nicholasaleks/webshells.git](https://github.com/nicholasaleks/webshells.git)*.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing for Arbitrary File Uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developing and executing a web shell isn’t always as easy as the PHP example
    we just explored. Often you’ll need to bypass common controls used to protect
    against arbitrary file uploads. Let’s turn to the lab environment to explore tools
    for identifying these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: One way to identify upload vulnerabilities is to use automated web application
    scanning tools. In [Chapter 5](chapter5.xhtml), we used dirsearch to find endpoints
    and functions that allow file uploads. Our scan revealed that the *p-web-01* machine
    (172.16.10.10) has a file upload page at *http://172.16.10.10:8081/upload*. [Figure
    6-1](chapter6.xhtml#fig6-1) shows what your Kali Firefox browser should return
    when you navigate to this URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: A file uploader on the p-web-01 machine'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the web page tells us it accepts only files with the *.jpg*,
    *.jpeg*, *.gif*, and *.png* extensions. Using manual testing, we can verify whether
    the application actually enforces this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: To upload the correct web shell payload to the target, however, we must perform
    reconnaissance. There is no such thing as a silver-bullet payload that works for
    every language, web application, framework, and platform.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, scans against *p-web-01* told us that the web application
    uses Python and is running Flask, a web framework written in Python. Let’s try
    uploading a web shell that targets Python. First, download the *python-webshell-check.py*
    test file.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find this chapter’s files at* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch06).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the file’s contents to better understand how it should work
    when we upload it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This Python script uses the imported subprocess module to execute a bash command
    on the underlying operating system. We hardcode the id bash command in the subprocess.check_output()
    function, which executes the specified command in a subprocess and captures its
    output. The shell=True parameter allows the command to be executed through the
    shell, enabling the use of shell-specific functions and syntax. Finally, we print
    the results of the command to the console after decoding from a byte type to a
    string. When executed, this code should retrieve the user and group information
    for the user running the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, as you can see in [Figure 6-2](chapter6.xhtml#fig6-2), we can’t
    upload the Python file to the web application. To check this yourself, click **Choose
    File**, browse to the saved web shell, then click **Upload**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: A file-type upload error'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn about several file upload bypass techniques
    you can use to evade restrictions and hopefully execute code.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing File Upload Controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To protect against arbitrary file uploads, developers frequently use validating
    functions. These functions can verify a file’s size, extension, and other properties.
    However, hackers can leverage several common techniques to bypass many of these
    file upload controls. Let’s consider some of these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: accept Attribute Modification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Developers use the accept HTML attribute in file input elements to specify
    the types of files that the browser should allow users to select for upload. By
    default, this attribute restricts files based on their extensions or Multipurpose
    Internet Mail Extensions (MIME) types. For example, the following line of HTML
    uses the accept attribute to allow only specific file extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But because this attribute is set on the client side, attackers can easily bypass
    the control to trick the application into accepting files with different extensions
    or MIME types. We can manipulate the accept attribute by using browser developer
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the ACME Hyper Branding web application doesn’t use accept attributes
    for the file upload input. To get a better understanding of how this control works,
    try modifying the client-side HTML to include the attribute, as shown in [Figure
    6-3](chapter6.xhtml#fig6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: Using developer tools to modify the accept attribute'
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to upload files once more, you should notice that the Kali file
    explorer won’t display unsupported file types. However, you can easily append
    another file extension, like *.py*, to the accept attribute or tell it to accept
    all file extensions by using the wildcard (*) value. The web shell payload should
    then show up in the file explorer.
  prefs: []
  type: TYPE_NORMAL
- en: This technique alone may not succeed in bypassing file upload controls, especially
    if the web application implements server-side validation and proper file-type
    checking. Let’s consider some server-side control bypasses.
  prefs: []
  type: TYPE_NORMAL
- en: File Extension Modification
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can attempt to upload a malicious web shell payload by changing its file
    extension to one that the application allows. For instance, renaming a malicious
    script from *webshell.php* to *webshell.jpg* may bypass file-extension checks
    that allow only image files to be uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to change the file extension for *python-webshell-check.py*
    to something like *python-webshell-check.jpg* and test the *p-web-01* web application’s
    upload functionality. Copy and rename the file by using this bash command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we attempt to upload the malicious script, the file should successfully
    upload, as shown in [Figure 6-4](chapter6.xhtml#fig6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg122-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Successfully uploading the malicious script by changing its file
    extension'
  prefs: []
  type: TYPE_NORMAL
- en: Can we now execute the script on the server? In [Chapter 5](chapter5.xhtml),
    we discovered the web application’s */uploads* directory. Let’s visit this directory
    in the browser by navigating to *[http://172.16.10.10:8081/uploads](http://172.16.10.10:8081/uploads)*.
    You should receive the error message in [Figure 6-5](chapter6.xhtml#fig6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg122-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: The ACME Hyper Branding /uploads directory error message'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we’ll need to add a filename to the URL as a parameter. Try appending
    *python-webshell-check.jpg* to the end of this */uploads* URL endpoint and then
    visit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser request should succeed, and the file should automatically download.
    We can verify whether the integrity of the malicious script was kept intact by
    the server by checking the contents of the downloaded file. Run the following
    bash command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, the web application doesn’t execute the Python file or run the id shell
    command. Instead, it ignores the file contents and serves the file as a download
    when we visit its full URL path.
  prefs: []
  type: TYPE_NORMAL
- en: To execute malicious code, we’ll most likely need to rely on additional vulnerabilities
    in the application or server-side code that mishandle file uploads, perform insufficient
    validation, or incorrectly interpret the file’s content. By exploiting these vulnerabilities,
    we may be able to trick the server into executing the uploaded file as a script
    or executable.
  prefs: []
  type: TYPE_NORMAL
- en: Another variation on this technique is using *double extensions*, whereby an
    attacker appends a second extension to a file to bypass file-type checks. For
    example, we could try renaming *webshell.php* to *webshell.php.jpg*. This trick
    might be able to bypass a control that checks only the last part of the file extension
    or relies solely on the file extension to determine the file type.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious Polyglot Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Polyglot files* are a fascinating kind of file that different applications
    interpret in different ways. This versatility stems from their exploitation of
    the specific structure and parsing rules of various file formats.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to create polyglot files is by manipulating the *file headers*, also
    known as *file signatures* or *magic bytes*, found at the beginning of the file.
    Operating systems and applications often use file headers to understand a file’s
    type so they can correctly interpret its data.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious polyglot files could potentially circumvent security measures that
    validate a file’s extension or content type. By skillfully creating the file headers,
    we can deceive systems into treating files as benign when in reality they contain
    harmful content.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s consider the header for a JPEG image file. Ordinarily,
    JPEG files start with the standard magic byte signature of FF D8 FF E0, followed
    by additional bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We could try disguising the PHP web shell code as an innocent image file by
    cleverly appending the JPEG magic bytes to it, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This bash command creates a malicious *polyglot.php* file with initial bytes
    suggesting that it is a JPEG file. After those bytes, however, we introduce PHP
    code. The injection will execute an eval() function using the cmd query parameter.
    You can use the file polyglot.php command to confirm the file’s type is a JPEG
    image data file.
  prefs: []
  type: TYPE_NORMAL
- en: Many tools and libraries can help us manipulate image file headers. Examples
    include hex editors like HxD, Hex Fiend, and Bless and libraries like libjpeg
    and libpng. The powerful ImageMagick and ExifTool command line tools can also
    manipulate a wide range of image file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Certain conditions must exist for the malicious polyglot to work. First, when
    a user uploads the file, the server must interpret it as an image and save it
    successfully. Second, when the user requests the file, the PHP interpreter generating
    the response must recognize the file as a script and process it. In some cases,
    the file might need a.*php* extension to trigger PHP processing.
  prefs: []
  type: TYPE_NORMAL
- en: Other Bypass Techniques
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll briefly mention a few additional bypass techniques you
    could attempt.
  prefs: []
  type: TYPE_NORMAL
- en: '*Null byte poisoning*, also known as *null byte injection* or *null character
    injection*, is used to manipulate file-handling systems that rely on null-terminated
    strings. This technique takes advantage of the presence of the null byte \x00,
    which marks the end of a string in various programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: This attack injects the null byte into the filename string, causing it to be
    truncated and potentially leading to unintended behavior. For instance, an attacker
    could rename *webshell.php* to *webshell.jpg%00.php*, injecting the URL-encoded
    representation of the null byte into the filename right after the *.jpg* extension.
    When processing the filename, a server may interpret it as *webshell.jpg*, unaware
    of the presence of the null byte and the subsequent.*php* extension. However,
    when the server later processes the file, it could read the file as a PHP script
    and execute the web shell.
  prefs: []
  type: TYPE_NORMAL
- en: '*Content-Type header manipulation*, also known as *MIME type spoofing*, is
    a file upload control bypass technique that leverages the manipulation of the
    Content-Type header in the HTTP request sent during the file upload. By changing
    the header to an allowed content type, we can potentially bypass the server-side
    file checks. The attacker would capture their outbound upload request by using
    an HTTP intercepting proxy like Burp Suite to manipulate the Content-Type header
    before the request reaches the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered a few techniques, we can explore them in the lab environment
    to try uploading and executing a web shell.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading Files with Burp Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s exploit the arbitrary file upload vulnerability on the *p-web-01* server
    by using Burp Suite to manipulate the Content-Type HTTP header. Burp Suite is
    a popular security testing tool developed by PortSwigger that allows us to easily
    manipulate traffic being sent to web applications and view the responses they
    return.
  prefs: []
  type: TYPE_NORMAL
- en: Burp Suite comes preinstalled in Kali. Start it by clicking the top-left corner
    of the Kali machine’s menu bar and searching for **burp suite**. This should open
    the Burp Suite graphical user interface (GUI) in a separate window. If this is
    your first time launching the application, it should prompt you to choose your
    license type and the type of project file you want to run. Create a temporary
    project with the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the Burp Suite browser by navigating to the **Proxy** tab. Burp Suite
    allows you to temporarily halt all traffic between your client and remote web
    application by using its *proxy intercept* feature. We don’t need to enable this
    option currently, so ensure that its toggle button is set to **Intercept Is Off**,
    as shown in [Figure 6-6](chapter6.xhtml#fig6-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg125.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: The Burp Suite Proxy page'
  prefs: []
  type: TYPE_NORMAL
- en: Next, click **Open Browser**. This should launch Burp Suite’s internal, Chromium-based
    browser and proxy its traffic to the currently running Burp Suite instance. We’ll
    use this browser to launch initial attacks against the web application. Navigate
    to the *p-web-01* web application by visiting its URL, *http://172.16.10.10:8081*.
  prefs: []
  type: TYPE_NORMAL
- en: Now visit the */upload* URL endpoint by using the Burp Suite browser. If you
    navigate to Burp Suite’s **Target** tab, you should see a directory structure
    similar to the one shown in [Figure 6-7](chapter6.xhtml#fig6-7). Click the upload
    link in the left navigation pane to see both the HTTP GET request and the response
    details.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg126.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: The Burp Suite Target tab'
  prefs: []
  type: TYPE_NORMAL
- en: Try uploading your original *python-webshell-check.py* file by using the Burp
    Suite browser and inspect the resulting traffic. You should get the File type
    is not allowed! error message. In Burp Suite, this should look as shown in [Figure
    6-8](chapter6.xhtml#fig6-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-8: Captured request and response traffic in Burp Suite'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the request pane on the left, we can clearly see the HTTP POST request made
    to the */upload* endpoint. It includes information about the host, origin, and
    header, but we’ll focus on the body of the request, which contains the filename,
    content type, and the file content itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We want to change the Content-Type header value, so let’s forward this request
    to the Burp Suite *Repeater*, a tool used to manipulate HTTP requests and responses.
    Repeater allows us to tamper with any part of the HTTP request before we resend
    it to the web application. To send the request to Repeater, simply right-click
    the request pane and select **Send to Repeater**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now navigate to the **Repeater** tab in Burp Suite and modify the line Content-Type:
    text/x-python to Content-Type: image/jpeg. This small change will hopefully trick
    the web application into thinking we’re uploading a *.jpeg* file, when really,
    we’re uploading a Python file. Note that we’re not modifying the *.py* extension
    of the filename.'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Send** button located at the top left of the GUI and analyze the
    response. The File upload was successful! message in the HTML content indicates
    that the Content-Type manipulation succeeded at bypassing the file format control.
  prefs: []
  type: TYPE_NORMAL
- en: Is the web shell now accessible in the web application’s */uploads* directory?
    Try browsing to the URL *http://172.16.10.10:8081/uploads/python-webshell-check.py*.
    As you can see in [Figure 6-9](chapter6.xhtml#fig6-9), the web page displays the
    contents of the Python file in a single line, instead of automatically serving
    it as a download as before.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg128.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-9: The raw Python web shell uploaded to the web application'
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve made progress, our payload isn’t executing as expected on the web
    application. We wanted the *python-webshell-check.py* script to run the id bash
    command and return the output to us in an HTTP response. In the next section,
    we’ll discuss the importance of properly staging a web shell by considering its
    execution context, file location, access controls, and the type of web framework
    being targeted.
  prefs: []
  type: TYPE_NORMAL
- en: Staging Web Shells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Successfully popping a shell may involve technical considerations beyond simply
    exploiting a file upload vulnerability. Here are factors you should consider when
    staging a web shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Execution context **Consider the target’s programming language, server configuration,
    and execution environment. For example, if the application runs on a PHP server,
    ensure that the web shell code is compatible with PHP syntax and features.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filepath and location **Determine an appropriate filepath and location for
    the web shell by considering the target application’s directory structure, access
    controls, and file-inclusion mechanisms. Identify writable directories and locations
    at which the web shell can be stored and executed effectively. For example, you
    might be able to upload non-image filepaths such as */uploads*, */files*, or */static*
    and images to */images* or */imgs*. There is no single standard, and files can
    live anywhere the developer desires. Identifying the web application’s root directory
    also helps. For example, websites are commonly stored at */var/www/html* on a
    web server.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access controls and authorization **Consider any access controls, authentication
    mechanisms, or user roles implemented in the application. Exploiting vulnerabilities
    related to user roles, privilege escalation, or authentication can provide additional
    opportunities for successful web shell staging. For example, you may be required
    to authenticate in order to upload a file even if the file is then accessible
    to unauthenticated users.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web application firewalls **Security systems such as web application firewalls
    could detect attempts to upload commonly used web shells. They could also identify
    attempts to execute system commands via HTTP parameters. Thus, using popular web
    shells like *c99.php* or *b374k* may increase your chances of getting caught and
    blocked. Other security systems, such as endpoint detection and response, may
    observe system process activity; if they detect a web server process attempting
    to run shell commands, they may raise alarms or block the execution altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s apply these principles to stage an effective web shell payload and completely
    compromise the *p-web-01* web application so we can execute whatever bash command
    we want on it.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Directory Traversal Vulnerabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we spoofed the Content-Type header of the web shell to successfully
    bypass a server’s upload controls, we weren’t able to execute the malicious Python
    code because we didn’t properly stage the web shell on the Flask server.
  prefs: []
  type: TYPE_NORMAL
- en: Applications built with the Flask framework may contain a file called *app.py*
    or another similar name that indicates an application’s entry point. This file
    is responsible for initializing and configuring the application; it creates an
    instance of the Flask application and defines its various routes, views, and configurations.
    Manipulating this file would be a great way to execute a web shell on a Flask
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We can try to overwrite the *app.py* file of the *p-web-01* web application
    by uploading a tampered version of it that includes a malicious web shell route.
    However, to accomplish this task, we’ll first need to figure out if we can upload
    a file outside the */uploads* directory, which isn’t the parent directory of the
    application, where *app.py* should live.
  prefs: []
  type: TYPE_NORMAL
- en: '*Directory traversal* vulnerabilities allow attackers to access files or directories
    outside the intended directory. This weakness can occur when input parameters
    or file upload functionality aren’t properly validated and sanitized. To exploit
    a directory traversal vulnerability, an attacker can craft a malicious filename
    that includes the directory traversal sequence ../.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, an attacker could upload a file with the filename *../../../../../etc/password*,
    allowing them to potentially modify critical system information. A single dot
    (.) represents the current directory, and two dots (..) represent the parent directory.
    By using multiple dot-dot-slash patterns (../), we’re essentially navigating upward
    in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: If we can manipulate the filename in our input, we could potentially traverse
    the filesystem, then upload the malicious *app.py* file to the app’s sensitive
    system directory. Let’s see if we can upload a file to another directory in *p-web-01*.
    Burp Suite’s Target tab shows us that the server has a */static* directory used
    to host permanent assets like the *hero.png* image, as shown in [Figure 6-10](chapter6.xhtml#fig6-10).
    Targeting this static directory would be a good way to detect whether the server
    is vulnerable to directory traversal upload attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-10: The /static directory on p-web-01 shown in the Burp Suite Target
    tab'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you can’t see images under the* /static *directory, click the* ***Filter***
    *bar below the Site Map tab, then click* ***Show All***.'
  prefs: []
  type: TYPE_NORMAL
- en: In Burp Suite Repeater, we’ll include a relative path to the */static* directory
    in the filename of the *python-webshell-check.py* file. Rename it to *../static/python-webshell-check.py*,
    then send the request to the server. According to the response, the file should
    have been successfully uploaded. Browse to the */static/python-webshell-check.py*
    URL to verify this.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading Malicious Payloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know we can exploit a directory traversal vulnerability, let’s stage
    a malicious *app.py* payload. We’ll use the @app.route() function to include a
    new web shell endpoint in *p-web-01*. Download the malicious version of the *app.py*
    file from the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open this file, you’ll see that it’s pretty much a direct copy of
    the original *app.py* file. However, we’ve added another route to the bottom of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: app.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The line at ❶ appends a new */webshell/<command>* URL, which executes the webshell()
    function. This function accepts a command as a parameter. The rest of the file
    looks very similar to the *python-webshell-check.py* file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s upload this web shell to *p-web-01* by using Burp Suite. First, exploit
    the directory traversal vulnerability by renaming the filename in the request
    to *../app.py*. Doing this should allow us to overwrite the original *app.py*
    file on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to change the request’s Content-Type header to trick the server
    into thinking we’re uploading an image. Modify the header to include the image/jpeg
    content type. Then paste the content of the malicious file into the request’s
    body. Before clicking **Send**, make sure your request looks like the one in [Figure
    6-11](chapter6.xhtml#fig6-11). (Keep in mind that this screenshot does not display
    the entirety of the file’s contents in the request body.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-11: Uploading the malicious app.py file containing a web shell route'
  prefs: []
  type: TYPE_NORMAL
- en: If the request worked, you should get a File upload was successful! message.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the exploit preserved all the *app.py* file’s original functionality.
    This undercover web shell exploitation helps us evade detection, since we kept
    the site’s core behavior intact and didn’t create any new files. An analyst reviewing
    the */uploads* directory won’t find a web shell, as we added the shell to the
    web application’s source code. However, security systems such as *file integrity
    monitoring (FIM)* may catch that a file’s hash was changed.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world scenarios, be very careful when attempting to overwrite an application.
    It may not always work on the first attempt, and you could break the application
    if a code error exists in the modified version. Always seek authorization when
    attempting dangerous penetration-testing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Web Shell Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After chaining together three separate vulnerabilities, we can now execute commands
    on *p-web-01*. To do this, navigate to the endpoint you just created and append
    a bash command to the URL. The command’s output should be returned in the browser
    response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to figure out what user we’re operating as, run the id command
    by navigating to *http://172.16.10.10:8081/webshell/id*. This should produce the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to *http://172.16.10.10:8081/webshell/pwd* to figure out where we
    are on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, navigate to *http://172.16.10.10:8081/webshell/uname%20-a* to identify
    the operating system we just compromised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we sent this uname -a bash command to the web shell, we had to
    URL-encode the space character by using the %20 representation. [Table 6-1](chapter6.xhtml#tab6-1)
    displays some commonly used URL-encoded characters you can insert into bash web
    shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Common URL-Encoded Characters for Bash Web Shells'
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | URL encoding |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Space () | %20 |'
  prefs: []
  type: TYPE_TB
- en: '| Forward slash (/) | %2F |'
  prefs: []
  type: TYPE_TB
- en: '| Question mark (?) | %3F |'
  prefs: []
  type: TYPE_TB
- en: '| Ampersand (&) | %26 |'
  prefs: []
  type: TYPE_TB
- en: '| Equal sign (=) | %3D |'
  prefs: []
  type: TYPE_TB
- en: '| Colon (:) | %3A |'
  prefs: []
  type: TYPE_TB
- en: '| Semicolon (;) | %3B |'
  prefs: []
  type: TYPE_TB
- en: '| Hash (#) | %23 |'
  prefs: []
  type: TYPE_TB
- en: '| Plus sign (+) | %2B |'
  prefs: []
  type: TYPE_TB
- en: '| Comma (,) | %2C |'
  prefs: []
  type: TYPE_TB
- en: Now that we have an initial foothold on the server, let’s develop a unique bash
    script that we can use to better interface with it, so we don’t have to use the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Building a Web Shell Interface'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ll develop a bash script you can use to automatically
    send commands to the web shell you uploaded to *p-web-01* (172.16.10.10) and then
    parse the output you receive. The script should interact with the web shell by
    sending HTTP requests that were generated based on bash commands entered at a
    local bash input prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The commands may use special characters, so you’ll need to ensure that you properly
    encode all inputs. You’ll also want to return clean output that contains only
    the relevant command execution response. [Listing 6-1](chapter6.xhtml#Lis6-1)
    shows an example of such a web shell script.
  prefs: []
  type: TYPE_NORMAL
- en: webshell.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: A web shell interface'
  prefs: []
  type: TYPE_NORMAL
- en: We begin the script by collecting the host address and port for the remote target
    to which we want to connect ❶. Inside a while loop, the script asks the user to
    enter a command to execute ❷. We encode the command string by using jq and its
    built-in @uri function, which converts the input string to a URI-encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we send the target a specially crafted curl request ❸. The -s option suppresses
    any unnecessary curl output that isn’t directly related to the bash command. Next,
    the -w argument specifies a custom output format for curl. In this case, "%{http_code}"
    is a placeholder that will be replaced with the request’s HTTP response code.
    This allows us to retrieve the status code separately. Also, we can see that this
    curl request uses the -o output argument and points it to */dev/null*, meaning
    we discard the response body.
  prefs: []
  type: TYPE_NORMAL
- en: At ❹, we check whether the HTTP status code is 200\. We then send a second curl
    request to retrieve the output at ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you further improve this script? Try implementing some of the following
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a single HTTP request **Remove the need to send two curl requests for
    each command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing directory persistence **When using cd to move around the filesystem,
    have your script keep track of the present working directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a history audit log **When commands are sent to the web shell, store
    them in a log that remembers which commands were executed and when.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a quick access alias **Instead of requiring users to manually type
    the target host and port in the script, accept these parameters as command line
    arguments and then store the full script path with these arguments as an alias.'
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of Web Shells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite their usefulness, web shells have several limitations. Here we discuss
    some of their common downsides.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web shells are often temporary, existing only as long as the compromised web
    server remains accessible. System administrators may regularly monitor and clean
    up uploaded files, reducing their persistence and effectiveness. Also, if the
    server is taken down, patched, or reconfigured, the web shell may become ineffective,
    reducing your ability to maintain access.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Real-Time Responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real-time responses from commands such as a ping won’t work, and unless you
    limit the number of ping commands you send, your web shell may hang, as hotkeys
    like CTRL-C to exit the command won’t be available.
  prefs: []
  type: TYPE_NORMAL
- en: Limited Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web shells often provide limited feedback or error messages, making it challenging
    to troubleshoot issues or understand the underlying cause of failures. They provide
    only a subset of the functionality available through native system administrative
    tools and may lack advanced bash features, such as key bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve considered one way of gaining initial access to a target server. Let’s
    end this chapter by considering an additional method: OS command injection.'
  prefs: []
  type: TYPE_NORMAL
- en: OS Command Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*OS command injection* is a type of security vulnerability that occurs when
    an application allows users to execute unauthorized operating system commands
    by supplying them as input to the application. As attackers, we can exploit a
    target’s lack of proper input sanitization to inject these malicious commands
    and gain an initial foothold into systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike web shells, OS command injection attacks don’t require us to upload malicious
    files to a server. Instead, we must identify places in the target application
    that rely directly on user input to construct operating system commands. Then,
    we must manipulate the user-supplied input by injecting specially crafted characters
    or sequences into them to break out of the intended input context and run our
    own commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is a snippet from a Python web application that
    allows users to submit a filename for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the application’s process_file() function takes the filename
    parameter and passes it to the ls -l operating system command without first checking
    the input for special characters or other malicious content.
  prefs: []
  type: TYPE_NORMAL
- en: 'An attacker can exploit this vulnerability if the value to filename comes from
    a different function that accepts untrusted user input; in that case, they could
    inject additional commands into the filename parameter. For instance, if an attacker
    submitted a malicious filename input, such as file.txt; id, the application would
    construct the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This input would first execute the intended ls -l command by using the parameter
    file.txt, then run the injected id command.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the input relies on the semicolon bash control operator (;) to escape
    the intended input context. In Chapters 1 and 2, you learned about several of
    these operators, which hold special meanings to the bash interpreter. [Table 6-2](chapter6.xhtml#tab6-2)
    illustrates how to use these operators as a way to test for possible OS command
    injection vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-2: Common OS Command Injection Techniques'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Example usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Semicolon (;) | Executes multiple commands in a single line | filename=abc.txt;
    id |'
  prefs: []
  type: TYPE_TB
- en: '| Pipe (&#124;) or double pipe (&#124;&#124;) | Chains commands and redirects
    command output, as well as provides OR conditional logic | filename=abd.txt &#124;
    cat /etc/passwd |'
  prefs: []
  type: TYPE_TB
- en: '| Ampersand (&) or double ampersand (&&) | Concatenates commands or runs them
    in the background, as well as provides AND conditional logic | filename=abc.txt
    & ls -l |'
  prefs: []
  type: TYPE_TB
- en: '| Command substitution (`, $()) | Substitutes commands | filename=`cat /etc/passwd`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Redirection operators (>, >>, <) | Redirects input/output | filename=abc;
    cat /etc/passwd > pass.txt |'
  prefs: []
  type: TYPE_TB
- en: '| Double and single quotes (", '') | Encapsulates command arguments | filename="abc.txt;
    id" |'
  prefs: []
  type: TYPE_TB
- en: Let’s exploit an OS command injection vulnerability in the lab. Instead of using
    special hacking tools to find the vulnerability, we’ll lean on our understanding
    of bash syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll target the *p-web-02* web application located at *http://172.16.10.12*.
    When scanning this application in [Chapter 5](chapter5.xhtml), we noticed two
    interesting endpoints: the *donate.php* file and the *amount_to_donate.txt* file.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the *donate.php* web page by browsing to *http://172.16.10.12/donate.php*.
    As shown in [Figure 6-12](chapter6.xhtml#fig6-12), the page appears to contain
    a simple form with a text input field and a submission button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-12: The donate page on the p-web-02 application'
  prefs: []
  type: TYPE_NORMAL
- en: By performing manual testing, we’ll get a better idea of how this application
    functions. Try entering **1** in the text input field, then submit it ([Figure
    6-13](chapter6.xhtml#fig6-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg137-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-13: A successful donation response'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it looks like the input we entered is displayed in the response
    message shown on the page. Notice how the URL of the page changed to include an
    amount parameter that is equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Now, take a look at the *amount_to_donate.txt* file by browsing to *http://172.16.10.12/amount_to_donate.txt*.
    You should see that the 1 value we previously entered from the *donate.php* form
    was saved to this *.txt* file on the server. This indicates that some type of
    filesystem processing is being executed on the server, based on input from the
    web application, and that the form we discovered might be a good entry point for
    injected OS commands.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s attempt to perform OS command injection in the *donate.php* page. Submit
    the semicolon control operator (;) as well as the bash command id in the form.
    Unfortunately, a validation script seems to catch the semicolon character. You
    should see the message *Character ; is not allowed* displayed on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Not to worry; we can try a different method. Let’s inject a pipe character (|)
    instead of a semicolon. As you can see in [Figure 6-14](chapter6.xhtml#fig6-14),
    the input is accepted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg137-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-14: A successful OS command injection response'
  prefs: []
  type: TYPE_NORMAL
- en: If you check the *amounts_to_donate.txt* file, you should see evidence that
    the command was successfully injected into the file, as we’re able to identify
    the output of running the id command. In [Figure 6-15](chapter6.xhtml#fig6-15),
    you can see that the *www-data* user is running the *p-web-02* (172.16.10.12)
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg138.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-15: The injected command’s output'
  prefs: []
  type: TYPE_NORMAL
- en: Using the browser’s Inspect tool or a Burp Suite proxy, we can see that the
    OS command injection occurs by sending a GET request to */donate.php?amount=*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Building a Command Injection Interface'
  prefs: []
  type: TYPE_NORMAL
- en: Like the web shell interface you built in Exercise 8, develop a bash script
    that makes it easier to send commands to *p-web-02* by exploiting its OS command
    injection vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: This interface script should interact with the *donate.php* endpoint for sending
    commands as well as the *amount_to_donate.txt* endpoint for parsing and displaying
    the response of your commands. The script should also return only the response
    from the current command, not a full dump of all the previous command results
    in the *amount_to_donate.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-2](chapter6.xhtml#Lis6-2) shows an example solution.'
  prefs: []
  type: TYPE_NORMAL
- en: os-command -injection.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: An OS command injection interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code begins much like the web shell interface script: by collecting target
    connection details and beginning a while loop that prompts the user for commands
    to encode.'
  prefs: []
  type: TYPE_NORMAL
- en: Before sending the OS command injection request, the script first needs to take
    a snapshot of the *amount_to_donate.txt* file’s contents and save it to a variable
    called prev_resp ❶. We’ll discuss why we’re doing this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Within the next curl request, we inject the amount parameter with the encoded
    command and prepend the 1| value to it ❷. After sending the curl request, we then
    send another snapshot request to capture the new *amount_to_donate.txt* file contents
    in the new_resp variable ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to display the correct output from the command, we run a diff operation
    to extract the difference between the prev_resp and the new_resp variables ❹.
    The diff output is stored in a delta variable, which showcases all the new *amount_to_donate.txt*
    file lines that were created after our injection.
  prefs: []
  type: TYPE_NORMAL
- en: Try extending this script to make it more useful. For example, you could add
    support for viewing all commands that have been executed, along with their responses,
    by writing them to a file, then presenting them during the script’s runtime when
    a special command is used.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Command Injection Restrictions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we observed, developers often implement sanitization checks to prevent OS
    command injection attacks against their web applications. We got lucky, as the
    pipe (|) character wasn’t blocked in our target. Even so, it’s important to understand
    a few methods you could use to bypass command injection controls.
  prefs: []
  type: TYPE_NORMAL
- en: Obfuscation and Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we sent commands to a web shell earlier in this chapter, URL encoding requirements
    posed a challenge we needed to overcome. However, encoding and obfuscation may
    actually help us evade detection in some cases. Techniques like URL encoding,
    base64 encoding, and character encoding can hide the payload from security controls,
    checks, and filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could base64-encode an entire command, such as ls -l, and hide
    it in the input. Test this encoding by sending the following payload to */donate.php*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should receive a full filesystem listing of the web application’s present
    working directory.
  prefs: []
  type: TYPE_NORMAL
- en: This technique aims to evade simple pattern-matching or filtering mechanisms
    used for detection. Basic techniques such as the use of regular expressions will
    have trouble identifying bash commands in the encoded bHMgLWw= string.
  prefs: []
  type: TYPE_NORMAL
- en: Globbing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Globbing* is the process of using wildcard patterns to partially or fully
    match filenames or other content in files. A string is considered a wildcard pattern
    if it contains characters such as ?, *, [,], or !.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Globbing is interesting because it allows us to specify patterns that expand
    to specific filenames or directories without actually providing the exact name,
    potentially bypassing accessing restrictions. Consider the */etc/passwd* file
    on Linux. To view it, we could use ls, followed by the specific path and filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'But we could also run a command such as this one to list the file by using
    the ? wildcard character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Bash will try to match this pattern to files under the */etc* directory. Since
    *passwd* is the only file with a name pattern that is similar, the *?* character
    will expand to *a*, which matches *passwd*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same approach to access potentially restricted directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because no other directory names are three characters long and start with *e*
    at the root of the filesystem (*/*), the pattern will match the */etc* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Globbing can get more extreme. How about filling in all characters with question
    marks except the last character? This, too, would match */etc/passwd* if no similar
    filenames exist in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine globbing with brace expansion to match more than one pattern
    under */etc*. In the following example, bash will search for files that start
    with *p* and end with *d*, as well as files that start with *g* and end with *p*.
    This should match files such as */etc/passwd* and */etc/group*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Familiarizing yourself with features like globbing is helpful because you may
    run into applications (or even web application firewalls) that restrict the use
    of certain characters in input without taking into consideration globbing, allowing
    us to bypass filters and validations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, web application firewalls commonly block requests to URLs containing
    parameters such as *http://example.com?file=/etc/passwd*. Depending on how the
    application uses the filename, globbing may help bypass the firewall’s detection
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen in previous chapters, the power of the bash shell is undeniable,
    making popping a shell an exciting prospect. These shells open up possibilities
    for further exploitation and lateral movement on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we gained low-privileged footholds into targeted systems by
    deploying web shells and injecting OS commands. We also used bash to craft accessible
    interfaces to these vulnerabilities and explored ways of obfuscating bash commands
    through strategies like globbing. In the next chapter, we’ll explore a few more
    techniques for establishing remote shells across different environments.
  prefs: []
  type: TYPE_NORMAL
