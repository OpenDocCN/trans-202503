## 附录 A. 系统调用跟踪

*strace*命令允许我们跟踪程序所执行的系统调用。这对于调试或仅仅是想了解程序在做什么非常有用。在其最简单的形式下，我们可以如下使用*strace*：

```
$ `strace` ``*`command arg...`*``
```

这会运行*command*，并带上给定的命令行参数，生成它所执行的系统调用的跟踪。默认情况下，*strace*将输出写入*stderr*，但我们可以使用*-o filename*选项来更改此行为。

*strace*产生的输出类型的例子包括以下内容（摘自命令*strace date*的输出）：

```
execve("/bin/date", ["date"], [/* 114 vars */]) = 0
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=111059, ...}) = 0
mmap2(NULL, 111059, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7f38000
close(3)                                = 0
open("/lib/libc.so.6", O_RDONLY)        = 3
fstat64(3, {st_mode=S_IFREG|0755, st_size=1491141, ...}) = 0
close(3)                                = 0
write(1, "Mon Jan 17 12:14:24 CET 2011\n", 29) = 29
exit_group(0)                           = ?
```

每个系统调用以函数调用的形式显示，输入和输出参数都显示在括号内。从上面的例子可以看出，参数以符号形式打印：

+   位掩码使用相应的符号常量表示。

+   字符串以文本形式打印（最多限制为 32 个字符，但可以使用*-s strsize*选项更改此限制）。

+   结构字段单独显示（默认情况下，只显示大型结构的简化子集，但可以使用*-v*选项显示整个结构）。

在跟踪调用的右括号后，*strace*打印一个等号（`=`），后面跟着系统调用的返回值。如果系统调用失败，还会显示符号化的*errno*值。因此，我们可以看到`ENOENT`在上面*access()*调用失败时被显示出来。

即使是一个简单的程序，*strace*产生的输出也会因为 C 运行时启动代码和共享库的加载而变得非常庞大。对于一个复杂的程序，*strace*的输出可能会非常长。由于这些原因，有时选择性地过滤*strace*的输出会很有用。一种方法是使用*grep*，如下所示：

```
$ `strace date 2>&1 | grep open`
```

另一种方法是使用-e 选项选择要跟踪的事件。例如，我们可以使用以下命令来跟踪*open()*和*close()*系统调用：

```
$ `strace -e trace=open,close date`
```

在使用上述任一技术时，我们需要注意，在某些情况下，系统调用的真实名称与其*glibc*包装器的名称不同。例如，尽管我们在第二十六章中将所有*wait()*类型的函数称为系统调用，但其中大多数（*wait()*, *waitpid()*, 和*wait3()*）是调用内核*wait4()*系统调用服务例程的包装器。这个后者的名称由*strace*显示，我们必须在*-e trace=*选项中指定该名称。同样，所有的*exec*库函数（第 27.2 节）都会调用*execve()*系统调用。通常，我们可以通过查看*strace*输出（或查看下面描述的*strace -c*产生的输出）来对这种转换做出合理的猜测，但如果不行，我们可能需要查看*glibc*源代码，看看在包装函数内部可能发生了什么转换。

*strace(1)* 手册页面记录了 *strace* 的更多选项，包括以下内容：

+   *-p pid* 选项用于追踪一个现有的进程，通过指定其进程 ID。普通用户只能追踪他们拥有的进程，并且这些进程不能执行设置用户 ID 或设置组 ID 的程序（参见第 9.3 节）。

+   *-c* 选项使得 *strace* 打印程序所做的所有系统调用的汇总信息。对于每个系统调用，汇总信息包括调用的总次数、失败的调用次数，以及执行调用所花费的总时间。

+   *-f* 选项使得该进程的子进程也被追踪。如果我们将跟踪输出发送到一个文件（*-o filename*），那么替代的 *-ff* 选项会使每个进程将其跟踪输出写入一个名为 *filename.PID* 的文件。

*strace* 命令是 Linux 专用的，但大多数 UNIX 实现也提供了它们自己的类似工具（例如，Solaris 上的 *truss* 和 BSD 系统上的 *ktrace*）。

### 注意

*ltrace* 命令执行的任务与 *strace* 类似，但它用于库函数。详细信息请参见 *ltrace(1)* 手册页面。
