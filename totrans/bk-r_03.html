<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_17"/><span class="big"><strong>2</strong></span><br/><strong>NUMERICS, ARITHMETIC, ASSIGNMENT, AND VECTORS</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">In its simplest role, R can function as a mere desktop calculator. In this chapter, I’ll discuss how to use the software for arithmetic. I’ll also show how to store results so you can use them later in other calculations. Then, you’ll learn about vectors, which let you handle multiple values at once. Vectors are an essential tool in R, and much of R’s functionality was designed with vector operations in mind. You’ll examine some common and useful ways to manipulate vectors and take advantage of vector-oriented behavior.</p>&#13;
<h3 class="h3" id="ch02lev1sec09"><strong>2.1 R for Basic Math</strong></h3>&#13;
<p class="noindent">All common arithmetic operations and mathematical functionality are ready to use at the console prompt. You can perform addition, subtraction, multiplication, and division with the symbols <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, respectively. You can create exponents (also referred to as <em>powers</em> or <em>indices</em>) using <code>^</code>, and you control the order of the calculations in a single command using parentheses, <code>()</code>.</p>&#13;
<h4 class="h4" id="ch02lev2sec17"><span epub:type="pagebreak" id="page_18"/><strong><em>2.1.1 Arithmetic</em></strong></h4>&#13;
<p class="noindent">In R, standard mathematical rules apply throughout and follow the usual left-to-right order of operations: parentheses, exponents, multiplication, division, addition, subtraction (PEMDAS). Here’s an example in the console:</p>&#13;
<pre>R&gt; 2+3<br/>[1] 5<br/>R&gt; 14/6<br/>[1] 2.333333<br/>R&gt; 14/6+5<br/>[1] 7.333333<br/>R&gt; 14/(6+5)<br/>[1] 1.272727<br/>R&gt; 3^2<br/>[1] 9<br/>R&gt; 2^3<br/>[1] 8</pre>&#13;
<p class="indent">You can find the square root of any non-negative number with the <code>sqrt</code> function. You simply provide the desired number to <code>x</code> as shown here:</p>&#13;
<pre>R&gt; sqrt(x=9)<br/>[1] 3<br/>R&gt; sqrt(x=5.311)<br/>[1] 2.304561</pre>&#13;
<p class="indent">When using R, you’ll often find that you need to translate a complicated arithmetic formula into code for evaluation (for example, when replicating a calculation from a textbook or research paper). The next examples provide a mathematically expressed calculation, followed by its execution in R:</p>&#13;
<div class="imagec"><img src="../images/f0018-01.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>Note that some R expressions require extra parentheses that aren’t present in the mathematical expressions. Missing or misplaced parentheses are common causes of arithmetic errors in R, especially when dealing with exponents. If the exponent is itself an arithmetic calculation, it must always appear in parentheses. For example, in the third expression, you need parentheses around <code>2.25-1/4</code>. You also need to use parentheses if the number being raised to some power is a calculation, such as the expression 2<sup>2+1</sup> in the third example. Note that R considers a negative number a calculation because it interprets, for example, <code>-2</code> as <code>-1*2</code>. This is why you also need the parentheses around <code>-2</code> in that same expression. It’s important to highlight these issues early because they can easily be overlooked in large chunks of code.</p>&#13;
<h4 class="h4" id="ch02lev2sec18"><strong><em>2.1.2 Logarithms and Exponentials</em></strong></h4>&#13;
<p class="noindent">You’ll often see or read about researchers performing a <em>log transformation</em> on certain data. This refers to rescaling numbers according to the <em>logarithm</em>. When supplied a given number <em>x</em> and a value referred to as a <em>base</em>, the logarithm calculates the power to which you must raise the base to get to <em>x</em>. For example, the logarithm of <em>x</em> = 243 to base 3 (written mathematically as log<sub>3</sub> 243) is 5, because 3<sup>5</sup> = 243. In R, the log transformation is achieved with the <code>log</code> function. You supply <code>log</code> with the number to transform, assigned to the value <code>x</code>, and the base, assigned to <code>base</code>, as follows:</p>&#13;
<pre>R&gt; log(x=243,base=3)<br/>[1] 5</pre>&#13;
<p class="indentb">Here are some things to consider:</p>&#13;
<p class="bull">• Both <em>x</em> and the base must be positive.</p>&#13;
<p class="bull">• The log of any number <em>x</em> when the base is equal to <em>x</em> is 1.</p>&#13;
<p class="bull">• The log of <em>x</em> = 1 is always 0, regardless of the base.</p>&#13;
<p class="indentt">There’s a particular kind of log transformation often used in mathematics called the <em>natural log</em>, which fixes the base at a special mathematical number—<em>Euler’s number</em>. This is conventionally written as <em>e</em> and is approximately equal to 2.718.</p>&#13;
<p class="indent">Euler’s number gives rise to the <em>exponential function</em>, defined as <em>e</em> raised to the power of <em>x</em>, where <em>x</em> can be any number (negative, zero, or positive). The exponential function, <em>f</em>(<em>x</em>) = <em>e</em><sup>x</sup>, is often written as exp(<em>x</em>) and represents the <em>inverse</em> of the natural log such that exp(log<sub><em>e</em></sub> <em>x</em>) = log<sub><em>e</em></sub> exp(<em>x</em>) = <em>x</em>. The R command for the exponential function is <code>exp</code>:</p>&#13;
<pre>R&gt; exp(x=3)<br/>[1] 20.08554</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_20"/>The default behavior of <code>log</code> is to assume the natural log:</p>&#13;
<pre>R&gt; log(x=20.08554)<br/>[1] 3</pre>&#13;
<p class="indent">You must provide the value of <code>base</code> yourself if you want to use a value other than <em>e</em>. The logarithm and exponential functions are mentioned here because they become important later on in the book—many statistical methods use them because of their various helpful mathematical properties.</p>&#13;
<h4 class="h4" id="ch02lev2sec19"><strong><em>2.1.3 E-Notation</em></strong></h4>&#13;
<p class="noindentb">When R prints large or small numbers beyond a certain threshold of significant figures, set at 7 by default, the numbers are displayed using the classic scientific e-notation. The e-notation is typical to most programming languages—and even many desktop calculators—to allow easier interpretation of extreme values. In e-notation, any number <em>x</em> can be expressed as <em>x</em>e<em>y</em>, which represents exactly <em>x</em> × 10<sup><em>y</em></sup>. Consider the number 2,342,151,012,900. It could, for example, be represented as follows:</p>&#13;
<p class="bull">• 2.3421510129e12, which is equivalent to writing 2.3421510129 × 10<sup>12</sup></p>&#13;
<p class="bull">• 234.21510129e10, which is equivalent to writing 234.21510129 × 10<sup>10</sup></p>&#13;
<p class="indentt">You could use any value for the power of <em>y</em>, but standard e-notation uses the power that places a decimal just after the first significant digit. Put simply, for a <em>positive</em> power +<em>y</em>, the e-notation can be interpreted as “move the decimal point <em>y</em> positions to the <em>right</em>.” For a <em>negative</em> power −<em>y</em>, the interpretation is “move the decimal point <em>y</em> positions to the <em>left</em>.” This is exactly how R presents e-notation:</p>&#13;
<pre>R&gt; 2342151012900<br/>[1] 2.342151e+12<br/>R&gt; 0.0000002533<br/>[1] 2.533e-07</pre>&#13;
<p class="indent">In the first example, R shows only the first seven significant digits and hides the rest. Note that no information is lost in any calculations even if R hides digits; the e-notation is purely for ease of readability by the user, and the extra digits are still stored by R, even though they aren’t shown.</p>&#13;
<p class="indent">Finally, note that R must impose constraints on how extreme a number can be before it is treated as either infinity (for large numbers) or zero (for small numbers). These constraints depend on your individual system, and I’ll discuss the technical details a bit more in <a href="ch06.xhtml#ch06lev2sec55">Section 6.1.1</a>. However, any modern desktop system can be trusted to be precise enough by default for most computational and statistical endeavors in R.</p>&#13;
<div class="ex">&#13;
<p class="ext"><span epub:type="pagebreak" id="page_21"/><a id="ch2exc1"/><strong>Exercise 2.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Using R, verify that</p>&#13;
<div class="imagec"><img src="../images/f0021-01.jpg" alt="image"/></div>&#13;
<p class="noindent">when <em>a</em> = 2.3.</p></li>&#13;
<li><p class="noindents">Which of the following squares negative 4 and adds 2 to the result?</p>&#13;
<ol type="i">&#13;
<li><p class="noindent"><code>(-4)^2+2</code></p></li>&#13;
<li><p class="noindent"><code>-4^2+2</code></p></li>&#13;
<li><p class="noindent"><code>(-4)^(2+2)</code></p></li>&#13;
<li><p class="noindent"><code>-4^(2+2)</code></p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Using R, how would you calculate the square root of half of the average of the numbers 25.2, 15, 16.44, 15.3, and 18.6?</p></li>&#13;
<li><p class="noindents">Find log<sub><em>e</em></sub> 0.3.</p></li>&#13;
<li><p class="noindents">Compute the exponential transform of your answer to (d).</p></li>&#13;
<li><p class="noindents">Identify R’s representation of −0.00000000423546322 when printing this number to the console.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec10"><strong>2.2 Assigning Objects</strong></h3>&#13;
<p class="noindent">So far, R has simply displayed the results of the example calculations by printing them to the console. If you want to save the results and perform further operations, you need to be able to <em>assign</em> the results of a given computation to an <em>object</em> in the current workspace. Put simply, this amounts to storing some item or result under a given name so it can be accessed later, without having to write out that calculation again. In this book, I will use the terms <em>assign</em> and <em>store</em> interchangeably. Note that some programming books refer to a stored object as a <em>variable</em> because of the ability to easily overwrite that object and change it to something different, meaning that what it represents can vary throughout a session. However, I’ll use the term <em>object</em> throughout this book because we’ll discuss variables in <a href="part03.xhtml#part03">Part III</a> as a distinctly different statistical concept.</p>&#13;
<p class="indent">You can specify an assignment in R in two ways: using arrow notation (<code>&lt;-</code>) and using a single equal sign (<code>=</code>). Both methods are shown here:</p>&#13;
<pre>R&gt; x &lt;- -5<br/>R&gt; x<br/>[1] -5<br/>R&gt; x = x + 1 # this overwrites the previous value of x<br/>R&gt; x<br/>[1] -4<br/><br/>R&gt; mynumber = 45.2<br/><br/>R&gt; y &lt;- mynumber*x<br/>R&gt; y<br/>[1] -180.8<br/><br/>R&gt; ls()<br/>[1] "mynumber" "x"      "y"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>As you can see from these examples, R will display the value assigned to an object when you enter the name of the object into the console. When you use the object in subsequent operations, R will substitute the value you assigned to it. Finally, if you use the <code>ls</code> command (which you saw in <a href="ch01.xhtml#ch01lev2sec12">Section 1.3.1</a>) to examine the contents of the current workspace, it will reveal the names of the objects in alphabetical order (along with any other previously created items).</p>&#13;
<p class="indent">Although <code>=</code> and <code>&lt;-</code> do the same thing, it is wise (for the neatness of code if nothing else) to be consistent. Many users choose to stick with the <code>&lt;-</code>, however, because of the potential for confusion in using the <code>=</code> (for example, I clearly didn’t mean that <em>x</em> is <em>mathematically</em> equal to <em>x</em> + 1 earlier). In this book, I’ll do the same and reserve <code>=</code> for setting function arguments, which begins in <a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a>. So far you’ve used only numeric values, but note that the procedure for assignment is universal for all types and classes of objects, which you’ll examine in the coming chapters.</p>&#13;
<p class="indent">Objects can be named almost anything as long as the name begins with a letter (in other words, not a number), avoids symbols (though underscores and periods are fine), and avoids the handful of “reserved” words such as those used for defining special values (see <a href="ch06.xhtml#ch06lev1sec21">Section 6.1</a>) or for controlling code flow (see <a href="ch10.xhtml#ch10">Chapter 10</a>). You can find a useful summary of these naming rules in <a href="ch09.xhtml#ch09lev2sec80">Section 9.1.2</a>.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch2exc2"/><strong>Exercise 2.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create an object that stores the value 3<sup>2</sup> × 4<sup>1/8</sup>.</p></li>&#13;
<li><p class="noindents">Overwrite your object in (a) by itself divided by 2.33. Print the result to the console.</p></li>&#13;
<li><p class="noindents">Create a new object with the value −8.2 × 10<sup>−13</sup>.</p></li>&#13;
<li><p class="noindents">Print directly to the console the result of multiplying (b) by (c).</p></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec11"><span epub:type="pagebreak" id="page_23"/><strong>2.3 Vectors</strong></h3>&#13;
<p class="noindent">Often you’ll want to perform the same calculations or comparisons upon multiple entities, for example if you’re rescaling measurements in a data set. You could do this type of operation one entry at a time, though this is clearly not ideal, especially if you have a large number of items. R provides a far more efficient solution to this problem with <em>vectors</em>.</p>&#13;
<p class="indent">For the moment, to keep things simple, you’ll continue to work with numeric entries only, though many of the utility functions discussed here may also be applied to structures containing non-numeric values. You’ll start looking at these other kinds of data in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<h4 class="h4" id="ch02lev2sec20"><strong><em>2.3.1 Creating a Vector</em></strong></h4>&#13;
<p class="noindent">The vector is the essential building block for handling multiple items in R. In a numeric sense, you can think of a vector as a collection of observations or measurements concerning a single variable, for example, the heights of 50 people or the number of coffees you drink daily. More complicated data structures may consist of several vectors. The function for creating a vector is the single letter <code>c</code>, with the desired entries in parentheses separated by commas.</p>&#13;
<pre>R&gt; myvec &lt;- c(1,3,1,42)<br/>R&gt; myvec<br/>[1]  1  3  1 42</pre>&#13;
<p class="indent">Vector entries can be calculations or previously stored items (including vectors themselves).</p>&#13;
<pre>R&gt; foo &lt;- 32.1<br/>R&gt; myvec2 &lt;- c(3,-3,2,3.45,1e+03,64^0.5,2+(3-1.1)/9.44,foo)<br/>R&gt; myvec2<br/>[1]    3.000000   -3.000000    2.000000    3.450000 1000.000000    8.000000<br/>[7]    2.201271   32.100000</pre>&#13;
<p class="indent">This code created a new vector assigned to the object <code>myvec2</code>. Some of the entries are defined as arithmetic expressions, and it’s the result of the expression that’s stored in the vector. The last element, <code>foo</code>, is an existing numeric object defined as <code>32.1</code>.</p>&#13;
<p class="indent">Let’s look at another example.</p>&#13;
<pre>R&gt; myvec3 &lt;- c(myvec,myvec2)<br/>R&gt; myvec3<br/>[1]     1.000000    3.000000    1.000000    42.000000    3.000000    -3.000000<br/>[7]     2.000000    3.450000 1000.000000     8.000000    2.201271    32.100000</pre>&#13;
<p class="indent">This code creates and stores yet another vector, <code>myvec3</code>, which contains the entries of <code>myvec</code> and <code>myvec2</code> appended together in that order.</p>&#13;
<h4 class="h4" id="ch02lev2sec21"><span epub:type="pagebreak" id="page_24"/><strong><em>2.3.2 Sequences, Repetition, Sorting, and Lengths</em></strong></h4>&#13;
<p class="noindent">Here I’ll discuss some common and useful functions associated with R vectors: <code>seq</code>, <code>rep</code>, <code>sort</code>, and <code>length</code>.</p>&#13;
<p class="indent">Let’s create an equally spaced sequence of increasing or decreasing numeric values. This is something you’ll need often, for example when programming loops (see <a href="ch10.xhtml#ch10">Chapter 10</a>) or when plotting data points (see <a href="ch07.xhtml#ch07">Chapter 7</a>). The easiest way to create such a sequence, with numeric values separated by intervals of 1, is to use the colon operator.</p>&#13;
<pre>R&gt; 3:27<br/> [1]  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27</pre>&#13;
<p class="indent">The example <code>3:27</code> should be read as “from 3 to 27 (by 1).” The result is a numeric vector just as if you had listed each number manually in parentheses with <code>c</code>. As always, you can also provide either a previously stored value or a (strictly parenthesized) calculation when using the colon operator:</p>&#13;
<pre>R&gt; foo &lt;- 5.3<br/>R&gt; bar &lt;- foo:(-47+1.5)<br/>R&gt; bar<br/> [1]   5.3   4.3   3.3   2.3   1.3   0.3  -0.7  -1.7  -2.7  -3.7  -4.7<br/>[12]  -5.7  -6.7  -7.7  -8.7  -9.7 -10.7 -11.7 -12.7 -13.7 -14.7 -15.7<br/>[23] -16.7 -17.7 -18.7 -19.7 -20.7 -21.7 -22.7 -23.7 -24.7 -25.7 -26.7<br/>[34] -27.7 -28.7 -29.7 -30.7 -31.7 -32.7 -33.7 -34.7 -35.7 -36.7 -37.7<br/>[45] -38.7 -39.7 -40.7 -41.7 -42.7 -43.7 -44.7</pre>&#13;
<h5 class="h5" id="ch02lev3sec05"><strong>Sequences with seq</strong></h5>&#13;
<p class="noindent">You can also use the <code>seq</code> command, which allows for more flexible creations of sequences. This ready-to-use function takes in a <code>from</code> value, a <code>to</code> value, and a <code>by</code> value, and it returns the corresponding sequence as a numeric vector.</p>&#13;
<pre>R&gt; seq(from=3,to=27,by=3)<br/>[1]  3  6  9 12 15 18 21 24 27</pre>&#13;
<p class="indent">This gives you a sequence with intervals of 3 rather than 1. Note that these kinds of sequences will always start at the <code>from</code> number but will not always include the <code>to</code> number, depending on what you are asking R to increase (or decrease) them <code>by</code>. For example, if you are increasing (or decreasing) by even numbers and your sequence ends in an odd number, the final number won’t be included. Instead of providing a <code>by</code> value, however, you can specify a <code>length.out</code> value to produce a vector with that many numbers, evenly spaced between the <code>from</code> and <code>to</code> values.</p>&#13;
<pre>R&gt; seq(from=3,to=27,length.out=40)<br/> [1]  3.000000  3.615385  4.230769  4.846154  5.461538  6.076923  6.692308<br/> [8]  7.307692  7.923077  8.538462  9.153846  9.769231 10.384615 11.000000<br/>[15] 11.615385 12.230769 12.846154 13.461538 14.076923 14.692308 15.307692<br/>[22] 15.923077 16.538462 17.153846 17.769231 18.384615 19.000000 19.615385<br/>[29] 20.230769 20.846154 21.461538 22.076923 22.692308 23.307692 23.923077<br/>[36] 24.538462 25.153846 25.769231 26.384615 27.000000</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_25"/>By setting <code>length.out</code> to <code>40</code>, you make the program print exactly 40 evenly spaced numbers from 3 to 27.</p>&#13;
<p class="indent">For decreasing sequences, the use of <code>by</code> must be negative. Here’s an example:</p>&#13;
<pre>R&gt; foo &lt;- 5.3<br/>R&gt; myseq &lt;- seq(from=foo,to=(-47+1.5),by=-2.4)<br/>R&gt; myseq<br/> [1]   5.3   2.9   0.5  -1.9  -4.3  -6.7  -9.1 -11.5 -13.9 -16.3 -18.7 -21.1<br/>[13] -23.5 -25.9 -28.3 -30.7 -33.1 -35.5 -37.9 -40.3 -42.7 -45.1</pre>&#13;
<p class="indent">This code uses the previously stored object <code>foo</code> as the value for <code>from</code> and uses the parenthesized calculation <code>(-47+1.5)</code> as the <code>to</code> value. Given those values (that is, with <code>foo</code> being greater than <code>(-47+1.5)</code>), the sequence can progress only in negative steps; directly above, we set <code>by</code> to be <code>-2.4</code>. The use of <code>length.out</code> to create decreasing sequences, however, remains the same (it would make no sense to specify a “negative length”). For the same <code>from</code> and <code>to</code> values, you can create a decreasing sequence of length 5 easily, as shown here:</p>&#13;
<pre>R&gt; myseq2 &lt;- seq(from=foo,to=(-47+1.5),length.out=5)<br/>R&gt; myseq2<br/>[1]   5.3  -7.4 -20.1 -32.8 -45.5</pre>&#13;
<p class="indent">There are shorthand ways of calling these functions, which you’ll learn about in <a href="ch09.xhtml#ch09">Chapter 9</a>, but in these early stages I’ll stick with the explicit usage.</p>&#13;
<h5 class="h5" id="ch02lev3sec06"><strong>Repetition with rep</strong></h5>&#13;
<p class="noindent">Sequences are extremely useful, but sometimes you may want simply to repeat a certain value. You do this using <code>rep</code>.</p>&#13;
<pre>R&gt; rep(x=1,times=4)<br/>[1] 1 1 1 1<br/>R&gt; rep(x=c(3,62,8.3),times=3)<br/>[1]  3.0 62.0  8.3  3.0 62.0  8.3  3.0 62.0  8.3<br/>R&gt; rep(x=c(3,62,8.3),each=2)<br/>[1]  3.0  3.0 62.0 62.0  8.3  8.3<br/>R&gt; rep(x=c(3,62,8.3),times=3,each=2)<br/> [1]  3.0  3.0 62.0 62.0  8.3  8.3  3.0  3.0 62.0 62.0  8.3  8.3  3.0  3.0 62.0<br/>[16] 62.0  8.3  8.3</pre>&#13;
<p class="indent">The <code>rep</code> function is given a single value or a vector of values as its argument <code>x</code>, as well as a value for the arguments <code>times</code> and <code>each</code>. The value for <code>times</code> provides the number of times to repeat <code>x</code>, and <code>each</code> provides the <span epub:type="pagebreak" id="page_26"/>number of times to repeat each element of <code>x</code>. In the first line directly above, you simply repeat a single value four times. The other examples first use <code>rep</code> and <code>times</code> on a vector to repeat the entire vector, then use <code>each</code> to repeat each member of the vector, and finally use both <code>times</code> and <code>each</code> to do both at once.</p>&#13;
<p class="indent">If neither <code>times</code> nor <code>each</code> is specified, R’s default is to treat the values of <code>times</code> and <code>each</code> as <code>1</code> so that a call of <code>rep(x=c(3,62,8.3))</code> will just return the originally supplied <code>x</code> with no changes.</p>&#13;
<p class="indent">As with <code>seq</code>, you can include the result of <code>rep</code> in a vector of the same data type, as shown in the following example:</p>&#13;
<pre>R&gt; foo &lt;- 4<br/>R&gt; c(3,8.3,rep(x=32,times=foo),seq(from=-2,to=1,length.out=foo+1))<br/>[1]  3.00  8.30 32.00 32.00 32.00 32.00 -2.00 -1.25 -0.50  0.25  1.00</pre>&#13;
<p class="indent">Here, I’ve constructed a vector where the third to sixth entries (inclusive) are governed by the evaluation of a <code>rep</code> command—the single value <code>32 rep</code>eated <code>foo</code> times (where <code>foo</code> is stored as <code>4</code>). The last five entries are the result of an evaluation of <code>seq</code>, namely a sequence from −2 to 1 of length <code>foo+1</code> (5).</p>&#13;
<h5 class="h5" id="ch02lev3sec07"><strong>Sorting with sort</strong></h5>&#13;
<p class="noindent">Sorting a vector in increasing or decreasing order of its elements is another simple operation that crops up in everyday tasks. The conveniently named <code>sort</code> function does just that.</p>&#13;
<pre>R&gt; sort(x=c(2.5,-1,-10,3.44),decreasing=FALSE)<br/>[1] -10.00  -1.00   2.50   3.44<br/><br/>R&gt; sort(x=c(2.5,-1,-10,3.44),decreasing=TRUE)<br/>[1]   3.44   2.50  -1.00 -10.00<br/><br/>R&gt; foo &lt;- seq(from=4.3,to=5.5,length.out=8)<br/>R&gt; foo<br/>[1] 4.300000 4.471429 4.642857 4.814286 4.985714 5.157143 5.328571 5.500000<br/>R&gt; bar &lt;- sort(x=foo,decreasing=TRUE)<br/>R&gt; bar<br/>[1] 5.500000 5.328571 5.157143 4.985714 4.814286 4.642857 4.471429 4.300000<br/><br/>R&gt; sort(x=c(foo,bar),decreasing=FALSE)<br/> [1] 4.300000 4.300000 4.471429 4.471429 4.642857 4.642857 4.814286 4.814286<br/> [9] 4.985714 4.985714 5.157143 5.157143 5.328571 5.328571 5.500000 5.500000</pre>&#13;
<p class="indent">The <code>sort</code> function is pretty straightforward. You supply a vector to the function as the argument <code>x</code>, and a second argument, <code>decreasing</code>, indicates the order in which you want to sort. This argument takes a type of value you have not yet met: one of the all-important <em>logical</em> values. A logical value <span epub:type="pagebreak" id="page_27"/>can be only one of two specific, case-sensitive values: <code>TRUE</code> or <code>FALSE</code>. Generally speaking, logicals are used to indicate the satisfaction or failure of a certain <em>condition</em>, and they form an integral part of all programming languages. You’ll investigate logical values in R in greater detail in <a href="ch04.xhtml#ch04lev1sec16">Section 4.1</a>. For now, in regards to <code>sort</code>, you set <code>decreasing=FALSE</code> to sort from smallest to largest, and <code>decreasing=TRUE</code> sorts from largest to smallest.</p>&#13;
<h5 class="h5" id="ch02lev3sec08"><strong>Finding a Vector Length with length</strong></h5>&#13;
<p class="noindent">I’ll round off this section with the <code>length</code> function, which determines how many entries exist in a vector given as the argument <code>x</code>.</p>&#13;
<pre>R&gt; length(x=c(3,2,8,1))<br/>[1] 4<br/><br/>R&gt; length(x=5:13)<br/>[1] 9<br/><br/>R&gt; foo &lt;- 4<br/>R&gt; bar &lt;- c(3,8.3,rep(x=32,times=foo),seq(from=-2,to=1,length.out=foo+1))<br/>R&gt; length(x=bar)<br/>[1] 11</pre>&#13;
<p class="indent">Note that if you include entries that depend on the evaluation of other functions (in this case, calls to <code>rep</code> and <code>seq</code>), <code>length</code> tells you the number of entries <em>after</em> those inner functions have been executed.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch2exc3"/><strong>Exercise 2.3</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create and store a sequence of values from 5 to −11 that progresses in steps of 0.3.</p></li>&#13;
<li><p class="noindents">Overwrite the object from (a) using the same sequence with the order reversed.</p></li>&#13;
<li><p class="noindents">Repeat the vector <code>c(-1,3,-5,7,-9)</code> twice, with each element repeated 10 times, and store the result. Display the result sorted from largest to smallest.</p></li>&#13;
<li><p class="noindents">Create and store a vector that contains, in any configuration, the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">A sequence of integers from 6 to 12 (inclusive)</p></li>&#13;
<li><p class="noindent">A threefold repetition of the value 5.3</p></li>&#13;
<li><p class="noindent">The number −3</p></li>&#13;
<li><p class="noindent">A sequence of nine values starting at 102 and ending at the number that is the total length of the vector created in (c)</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Confirm that the length of the vector created in (d) is 20.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev2sec22"><span epub:type="pagebreak" id="page_28"/><strong><em>2.3.3 Subsetting and Element Extraction</em></strong></h4>&#13;
<p class="noindent">In all the results you have seen printed to the console screen so far, you may have noticed a curious feature. Immediately to the left of the output there is a square-bracketed <code>[1]</code>. When the output is a long vector that spans the width of the console and wraps onto the following line, another square-bracketed number appears to the left of the new line. These numbers represent the <em>index</em> of the entry directly to the right. Quite simply, the index corresponds to the <em>position</em> of a value within a vector, and that’s precisely why the first value always has a <code>[1]</code> next to it (even if it’s the only value and not part of a larger vector).</p>&#13;
<p class="indent">These indexes allow you to retrieve specific elements from a vector, which is known as <em>subsetting</em>. Suppose you have a vector called <code>myvec</code> in your workspace. Then there will be exactly <code>length(x=myvec)</code> entries in <code>myvec</code>, with each entry having a specific position: <code>1</code> or <code>2</code> or <code>3</code>, all the way up to <code>length(x=myvec)</code>. You can access individual elements by asking R to return the values of <code>myvec</code> at specific locations, done by entering the name of the vector followed by the position in square brackets.</p>&#13;
<pre>R&gt; myvec &lt;- c(5,-2.3,4,4,4,6,8,10,40221,-8)<br/>R&gt; length(x=myvec)<br/>[1] 10<br/>R&gt; myvec[1]<br/>[1] 5<br/><br/>R&gt; foo &lt;- myvec[2]<br/>R&gt; foo<br/>[1] -2.3<br/><br/>R&gt; myvec[length(x=myvec)]<br/>[1] -8</pre>&#13;
<p class="indent">Because <code>length(x=myvec)</code> results in the final index of the vector (in this case, <code>10</code>), entering this phrase in the square brackets extracts the final element, <code>-8</code>. Similarly, you could extract the second-to-last element by subtracting 1 from the length; let’s try that, and also assign the result to a new object:</p>&#13;
<pre>R&gt; myvec.len &lt;- length(x=myvec)<br/>R&gt; bar &lt;- myvec[myvec.len-1]<br/>R&gt; bar<br/>[1] 40221</pre>&#13;
<p class="indent">As these examples show, the index may be an arithmetic function of other numbers or previously stored values. You can assign the result to a new object in your workspace in the usual way with the <code>&lt;-</code> notation. Using your knowledge of sequences, you can use the colon notation with the length of <span epub:type="pagebreak" id="page_29"/>the specific vector to obtain all possible indexes for extracting a particular element in the vector:</p>&#13;
<pre>R&gt; 1:myvec.len<br/>[1]  1  2  3  4  5  6  7  8  9 10</pre>&#13;
<p class="indent">You can also delete individual elements by using <em>negative</em> versions of the indexes supplied in the square brackets. Continuing with the objects <code>myvec</code>, <code>foo</code>, <code>bar</code>, and <code>myvec.len</code> as defined earlier, consider the following operations:</p>&#13;
<pre>R&gt; myvec[-1]<br/>[1]    -2.3    4.0    4.0    4.0    6.0    8.0    10.0 40221.0    -8.0</pre>&#13;
<p class="indent">This line produces the contents of <code>myvec</code> without the first element. Similarly, the following code assigns to the object <code>baz</code> the contents of <code>myvec</code> without its second element:</p>&#13;
<pre>R&gt; baz &lt;- myvec[-2]<br/>R&gt; baz<br/>[1]     5     4     4     4     6     8     10 40221     -8</pre>&#13;
<p class="indent">Again, the index in the square brackets can be the result of an appropriate calculation, like so:</p>&#13;
<pre>R&gt; qux &lt;- myvec[-(myvec.len-1)]<br/>R&gt; qux<br/>[1]  5.0 -2.3  4.0  4.0  4.0  6.0  8.0 10.0 -8.0</pre>&#13;
<p class="indent">Using the square-bracket operator to extract or delete values from a vector does not change the original vector you are subsetting <em>unless</em> you explicitly overwrite the vector with the subsetted version. For instance, in this example, <code>qux</code> is a new vector defined as <code>myvec</code> without its second-to-last entry, but in your workspace, <code>myvec</code> itself <em>remains unchanged</em>. In other words, subsetting vectors in this way simply returns the requested elements, which can be assigned to a new object if you want, but doesn’t alter the original object in the workspace.</p>&#13;
<p class="indent">Now, suppose you want to piece <code>myvec</code> back together from <code>qux</code> and <code>bar</code>. You can call something like this:</p>&#13;
<pre>R&gt; c(qux[-length(x=qux)],bar,qux[length(x=qux)])<br/> [1]     5.0    -2.3     4.0     4.0     4.0    6.0    8.0    10.0 40221.0<br/>[10]    -8.0</pre>&#13;
<p class="indentb">As you can see, this line uses <code>c</code> to reconstruct the vector in three parts: <code>qux[-length(x=qux)]</code>, the object <code>bar</code> defined earlier, and <code>qux[length(x=qux)]</code>. For clarity, let’s examine each part in turn.</p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_30"/>• <code>qux[-length(x=qux)]</code></p>&#13;
<p class="bullp">This piece of code returns the values of <code>qux</code> except for its last element.</p>&#13;
<p class="programs-b">R&gt; length(x=qux)<br/>[1] 9<br/>R&gt; qux[-length(x=qux)]<br/>[1]  5.0 -2.3  4.0  4.0  4.0  6.0  8.0 10.0</p>&#13;
<p class="bullpi">Now you have a vector that’s the same as the first eight entries of <code>myvec</code>.</p>&#13;
<p class="bull">• <code>bar</code></p>&#13;
<p class="bullp">Earlier, you had stored <code>bar</code> as the following:</p>&#13;
<p class="programs-b">R&gt; bar &lt;- myvec[myvec.len-1]<br/>R&gt; bar<br/>[1] 40221</p>&#13;
<p class="bullp">This is precisely the second-to-last element of <code>myvec</code> that <code>qux</code> is missing. So, you’ll slot this value in after <code>qux[-length(x=qux)]</code>.</p>&#13;
<p class="bull">• <code>qux[length(x=qux)]</code></p>&#13;
<p class="bullp">Finally, you just need the last element of <code>qux</code> that matches the last element of <code>myvec</code>. This is extracted from <code>qux</code> (not deleted as earlier) using <code>length</code>.</p>&#13;
<p class="programs-b">R&gt; qux[length(x=qux)]<br/>[1] -8</p>&#13;
<p class="indent">Now it should be clear how calling these three parts of code together, in this order, is one way to reconstruct <code>myvec</code>.</p>&#13;
<p class="indent">As with most operations in R, you are not restricted to doing things one by one. You can also subset objects using <em>vectors of indexes</em>, rather than individual indexes. Using <code>myvec</code> again from earlier, you get the following:</p>&#13;
<pre>R&gt; myvec[c(1,3,5)]<br/>[1] 5 4 4</pre>&#13;
<p class="indent">This returns the first, third, and fifth elements of <code>myvec</code> in one go. Another common and convenient subsetting tool is the colon operator (discussed in <a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a>), which creates a sequence of indexes. Here’s an example:</p>&#13;
<pre>R&gt; 1:4<br/>[1] 1 2 3 4<br/>R&gt; foo &lt;- myvec[1:4]<br/>R&gt; foo<br/>[1]  5.0 -2.3  4.0  4.0</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>This provides the first four elements of <code>myvec</code> (recall that the colon operator returns a numeric vector, so there is no need to explicitly wrap this using <code>c</code>).</p>&#13;
<p class="indent">The order of the returned elements depends entirely upon the index vector supplied in the square brackets. For example, using <code>foo</code> again, consider the order of the indexes and the resulting extractions, shown here:</p>&#13;
<pre>R&gt; length(x=foo):2<br/>[1] 4 3 2<br/>R&gt; foo[length(foo):2]<br/>[1]  4.0  4.0 -2.3</pre>&#13;
<p class="indent">Here you extracted elements starting at the end of the vector, working backward. You can also use <code>rep</code> to repeat an index, as shown here:</p>&#13;
<pre>R&gt; indexes &lt;- c(4,rep(x=2,times=3),1,1,2,3:1)<br/>R&gt; indexes<br/> [1] 4 2 2 2 1 1 2 3 2 1<br/>R&gt; foo[indexes]<br/> [1]  4.0 -2.3 -2.3 -2.3  5.0  5.0 -2.3  4.0 -2.3  5.0</pre>&#13;
<p class="indent">This is now something a little more general than strictly “subsetting”—by using an index vector, you can create an entirely new vector of any length consisting of some or all of the elements in the original vector. As shown earlier, this index vector can contain the desired element positions in any order and can repeat indexes.</p>&#13;
<p class="indent">You can also return the elements of a vector after deleting more than one element. For example, to create a vector after removing the first and third elements of <code>foo</code>, you can execute the following:</p>&#13;
<pre>R&gt; foo[-c(1,3)]<br/>[1] -2.3  4.0</pre>&#13;
<p class="indent">Note that it is not possible to mix positive and negative indexes in a single index vector.</p>&#13;
<p class="indent">Sometimes you’ll need to overwrite certain elements in an existing vector with new values. In this situation, you first specify the elements you want to overwrite using square brackets and then use the assignment operator to assign the new values. Here’s an example:</p>&#13;
<pre>R&gt; bar &lt;- c(3,2,4,4,1,2,4,1,0,0,5)<br/>R&gt; bar<br/> [1] 3 2 4 4 1 2 4 1 0 0 5<br/>R&gt; bar[1] &lt;- 6<br/>R&gt; bar<br/> [1] 6 2 4 4 1 2 4 1 0 0 5</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_32"/>This overwrites the first element of <code>bar</code>, which was originally <code>3</code>, with a new value, <code>6</code>. When selecting multiple elements, you can specify a single value to replace them all or enter a vector of values that’s equal in length to the number of elements selected to replace them one for one. Let’s try this with the same <code>bar</code> vector from earlier.</p>&#13;
<pre>R&gt; bar[c(2,4,6)] &lt;- c(-2,-0.5,-1)<br/>R&gt; bar<br/> [1]  6.0 -2.0  4.0 -0.5  1.0 -1.0  4.0  1.0  0.0  0.0  5.0</pre>&#13;
<p class="indent">Here you overwrite the second, fourth, and sixth elements with <code>-2</code>, <code>-0.5</code>, and <code>-1</code>, respectively; all else remains the same. By contrast, the following code overwrites elements <code>7</code> to <code>10</code> (inclusive), replacing them all with <code>100</code>:</p>&#13;
<pre>R&gt; bar[7:10] &lt;- 100<br/>R&gt; bar<br/> [1]   6.0  -2.0   4.0  -0.5   1.0  -1.0 100.0 100.0 100.0 100.0   5.0</pre>&#13;
<p class="indent">Finally, it’s important to mention that this section has focused on just one of the two main methods, or “flavors,” of vector element extraction in R. You’ll look at the alternative method, using logical flags, in <a href="ch04.xhtml#ch04lev2sec41">Section 4.1.5</a>.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch2exc4"/><strong>Exercise 2.4</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create and store a vector that contains the following, in this order:</p>&#13;
<p class="dash">– A sequence of length 5 from 3 to 6 (inclusive)</p>&#13;
<p class="dash">– A twofold repetition of the vector <code>c(2,-5.1,-33)</code></p>&#13;
<p class="dash">– The value <img class="middle" src="../images/f0032-01.jpg" alt="image"/></p></li>&#13;
<li><p class="noindents">Extract the first and last elements of your vector from (a), storing them as a new object.</p></li>&#13;
<li><p class="noindents">Store as a third object the values returned by omitting the first and last values of your vector from (a).</p></li>&#13;
<li><p class="noindents">Use only (b) and (c) to reconstruct (a).</p></li>&#13;
<li><p class="noindents">Overwrite (a) with the same values sorted from smallest to largest.</p></li>&#13;
<li><p class="noindents">Use the colon operator as an index vector to reverse the order of (e), and confirm this is identical to using <code>sort</code> on (e) with <code>decreasing=TRUE</code>.</p></li>&#13;
<li><p class="noindents">Create a vector from (c) that repeats the third element of (c) three times, the sixth element four times, and the last element once.</p></li>&#13;
<li><p class="noindents"><span epub:type="pagebreak" id="page_33"/>Create a new vector as a copy of (e) by assigning (e) as is to a newly named object. Using this new copy of (e), overwrite the first, the fifth to the seventh (inclusive), and the last element with the values 99 to 95 (inclusive), respectively.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h4 class="h4" id="ch02lev2sec23"><strong><em>2.3.4 Vector-Oriented Behavior</em></strong></h4>&#13;
<p class="noindent">Vectors are so useful because they allow R to carry out operations on multiple elements simultaneously with speed and efficiency. This <em>vector-oriented</em>, <em>vectorized</em>, or <em>element-wise</em> behavior is a key feature of the language, one that you will briefly examine here through some examples of rescaling measurements.</p>&#13;
<p class="indent">Let’s start with this simple example:</p>&#13;
<pre>R&gt; foo &lt;- 5.5:0.5<br/>R&gt; foo<br/>[1] 5.5 4.5 3.5 2.5 1.5 0.5<br/>R&gt; foo-c(2,4,6,8,10,12)<br/>[1]   3.5   0.5  -2.5  -5.5  -8.5 -11.5</pre>&#13;
<p class="indent">This code creates a sequence of six values between 5.5 and 0.5, in increments of 1. From this vector, you subtract another vector containing 2, 4, 6, 8, 10, and 12. What does this do? Well, quite simply, R matches up the elements according to their respective positions and performs the operation on each corresponding pair of elements. The resulting vector is obtained by subtracting the first element of <code>c(2,4,6,8,10,12)</code> from the first element of <code>foo</code> (5.5 − 2 = 3.5), then by subtracting the second element of <code>c(2,4,6,8,10,12)</code> from the second element of <code>foo</code> (4.5 − 4 = 0.5), and so on. Thus, rather than inelegantly cycling through each element in turn (as you could do by hand or by explicitly using a loop), R permits a fast and efficient alternative using vector-oriented behavior. <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> illustrates how you can understand this type of calculation and highlights the fact that the positions of the elements are crucial in terms of the final result; elements in differing positions have no effect on one another.</p>&#13;
<p class="indent">The situation is made more complicated when using vectors of different lengths, which can happen in two distinct ways. The first is when the length of the longer vector can be evenly divided by the length of the shorter vector. The second is when the length of the longer vector <em>cannot</em> be divided by the length of the shorter vector—this is usually unintentional on the user’s part. In both of these situations, R essentially attempts to replicate, or <em>recycle</em>, the shorter vector by as many times as needed to match the length of the longer vector, before completing the specified operation. As an example, suppose you wanted to alternate the entries of <code>foo</code> shown earlier as negative <span epub:type="pagebreak" id="page_34"/>and positive. You could explicitly multiply <code>foo</code> by <code>c(1,-1,1,-1,1,-1)</code>, but you don’t need to write out the full latter vector. Instead, you can write the following:</p>&#13;
<div class="image"><img src="../images/f02-01.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch2fig1"/>Figure 2-1: A conceptual diagram of the element-wise behavior of a comparison or operation carried out on two vectors of equal length in R. Note that the operation is performed by matching up the element positions.</em></p>&#13;
<pre>R&gt; bar &lt;- c(1,-1)<br/>R&gt; foo*bar<br/>[1]  5.5 -4.5  3.5 -2.5  1.5 -0.5</pre>&#13;
<p class="indent">Here <code>bar</code> has been applied repeatedly throughout the length of <code>foo</code> until completion. The left plot of <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> illustrates this particular example. Now let’s see what happens when the vector lengths are not evenly divisible.</p>&#13;
<pre>R&gt; baz &lt;- c(1,-1,0.5,-0.5)<br/>R&gt; foo*baz<br/>[1]  5.50 -4.50  1.75 -1.25  1.50 -0.50<br/>Warning message:<br/>In foo * baz :<br/>  longer object length is not a multiple of shorter object length</pre>&#13;
<p class="indent">Here you see that R has matched the first four elements of <code>foo</code> with the entirety of <code>baz</code>, but it’s not able to fully repeat the vector again. The repetition has been attempted, with the first two elements of <code>baz</code> being matched with the last two of the longer <code>foo</code>, though not without a protest from R, which notifies the user of the unevenly divisible lengths (you’ll look at warnings in more detail in <a href="ch12.xhtml#ch12lev1sec39">Section 12.1</a>). The plot on the right in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> illustrates this example.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_35"/><img src="../images/f02-02.jpg" alt="image"/></div>&#13;
<p class="figt"><em><a id="ch2fig2"/>Figure 2-2: An element-wise operation on two vectors of differing lengths. Left:</em> <code>foo</code> <em>multiplied by</em> <code>bar</code><em>; lengths are evenly divisible. Right:</em> <code>foo</code> <em>multiplied by</em> <code>baz</code><em>; lengths are not evenly divisible, and a warning is issued.</em></p>&#13;
<p class="indent">As I noted in <a href="ch02.xhtml#ch02lev2sec22">Section 2.3.3</a>, you can consider single values to be vectors of length 1, so you can use a single value to repeat an operation on all the values of a vector of any length. Here’s an example, using the same vector <code>foo</code>:</p>&#13;
<pre>R&gt; qux &lt;- 3<br/>R&gt; foo+qux<br/>[1] 8.5 7.5 6.5 5.5 4.5 3.5</pre>&#13;
<p class="indent">This is far easier than executing <code>foo+c(3,3,3,3,3,3)</code> or the more general <code>foo+rep(x=3,times=length(x=foo))</code>. Operating on vectors using a single value in this fashion is quite common, such as if you want to rescale or translate a set of measurements by some constant amount.</p>&#13;
<p class="indent">Another benefit of vector-oriented behavior is that you can use vectorized functions to complete potentially laborious tasks. For example, if you want to sum or multiply all the entries in a numeric vector, you can just use a built-in function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>Recall <code>foo</code>, shown earlier:</p>&#13;
<pre>R&gt; foo<br/>[1] 5.5 4.5 3.5 2.5 1.5 0.5</pre>&#13;
<p class="indent">You can find the sum of these six elements with</p>&#13;
<pre>R&gt; sum(foo)<br/>[1] 18</pre>&#13;
<p class="noindent">and their product with</p>&#13;
<pre>R&gt; prod(foo)<br/>[1] 162.4219</pre>&#13;
<p class="indent">Far from being just convenient, vectorized functions are faster and more efficient than an explicitly coded iterative approach like a loop. The main takeaway from these examples is that much of R’s functionality is designed specifically for certain data structures, ensuring neatness of code as well as optimization of performance.</p>&#13;
<p class="indent">Lastly, as mentioned earlier, this vector-oriented behavior applies in the same way to overwriting multiple elements. Again using <code>foo</code>, examine the following:</p>&#13;
<pre>R&gt; foo<br/>[1] 5.5 4.5 3.5 2.5 1.5 0.5<br/>R&gt; foo[c(1,3,5,6)] &lt;- c(-99,99)<br/>R&gt; foo<br/>[1] -99.0   4.5  99.0   2.5 -99.0  99.0</pre>&#13;
<p class="indent">You see four specific elements being overwritten by a vector of length 2, which is recycled in the same fashion you’re familiar with. Again, the length of the vector of replacements must evenly divide the number of elements being overwritten, or else a warning similar to the one shown earlier will be issued when R cannot complete a full-length recycle.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch2exc5"/><strong>Exercise 2.5</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Convert the vector <code>c(2,0.5,1,2,0.5,1,2,0.5,1)</code> to a vector of only <code>1</code>s, using a vector of length 3.</p></li>&#13;
<li><p class="noindents">The conversion from a temperature measurement in degrees Fahrenheit <em>F</em> to Celsius <em>C</em> is performed using the following equation:</p>&#13;
<div class="imagec"><img src="../images/f0036-01.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>Use vector-oriented behavior in R to convert the temperatures 45, 77, 20, 19, 101, 120, and 212 in degrees Fahrenheit to degrees Celsius.</p></li>&#13;
<li><p class="noindents">Use the vector <code>c(2,4,6)</code> and the vector <code>c(1,2)</code> in conjunction with <code>rep</code> and <code>*</code> to produce the vector <code>c(2,4,6,4,8,12)</code>.</p></li>&#13;
<li><p class="noindents">Overwrite the middle four elements of the resulting vector from (c) with the two recycled values <code>-0.1</code> and <code>-100</code>, in that order.</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch02lev3sec09"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, <code>^</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Arithmetic</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev1sec09">Section 2.1</a>, <a href="ch02.xhtml#page_17">p. 17</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>sqrt</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Square root</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec17">Section 2.1.1</a>, <a href="ch02.xhtml#page_18">p. 18</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>log</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Logarithm</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec18">Section 2.1.2</a>, <a href="ch02.xhtml#page_19">p. 19</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>exp</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Exponential</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec18">Section 2.1.2</a>, <a href="ch02.xhtml#page_19">p. 19</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>&lt;-</code>, <code>=</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Object assignment</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev1sec10">Section 2.2</a>, <a href="ch02.xhtml#page_21">p. 21</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>c</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Vector creation</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec20">Section 2.3.1</a>, <a href="ch02.xhtml#page_23">p. 23</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>:</code>, <code>seq</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Sequence creation</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a>, <a href="ch02.xhtml#page_24">p. 24</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>rep</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Value/vector repetition</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a>, <a href="ch02.xhtml#page_25">p. 25</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>sort</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Vector sorting</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a>, <a href="ch02.xhtml#page_26">p. 26</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>length</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Determine vector length</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec21">Section 2.3.2</a>, <a href="ch02.xhtml#page_27">p. 27</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>[ ]</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Vector subsetting/extraction</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec22">Section 2.3.3</a>, <a href="ch02.xhtml#page_28">p. 28</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>sum</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Sum all vector elements</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec23">Section 2.3.4</a>, <a href="ch02.xhtml#page_36">p. 36</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>prod</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Multiply all vector elements</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch02.xhtml#ch02lev2sec23">Section 2.3.4</a>, <a href="ch02.xhtml#page_36">p. 36</a><span epub:type="pagebreak" id="page_38"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>