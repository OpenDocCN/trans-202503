- en: '**8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IDENTIFYING NETWORK CONFIGURATION ARTIFACTS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The forensic analysis of Linux systems includes examination of networking configuration
    and reconstruction of past network activity. This analysis can be used to understand
    a system breach or compromise, or abuse by local users on the machine. This chapter
    describes common Linux network configurations for both static systems like servers
    and dynamic clients like desktops and roaming laptops. The analysis includes network
    interfaces, assigned IP addresses, wireless networks, attached Bluetooth devices,
    and more. Security coverage includes examining evidence of VPNs, firewalls, and
    proxy settings.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not about network forensics, and it does not cover network traffic
    capture or packet analysis. The focus remains on postmortem (“dead disk”) examination
    of Linux systems. However, the topics covered here should complement any independent
    network forensic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Configuration Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Networking has always been a fundamental part of Unix, and TCP/IP protocol support
    played a significant role in Unix popularity on the internet. Networking is also
    a core function of the Linux kernel and Linux distros. Early Unix and Linux systems
    had a simple static network configuration that was not expected to change, at
    least not frequently. The configuration could be defined at installation or edited
    in several files.
  prefs: []
  type: TYPE_NORMAL
- en: Networking today is more dynamic, and Linux systems, especially mobile systems,
    use network management software to keep the network configuration updated. This
    section provides an introduction to network interfaces and addressing, followed
    by the software that manages network configuration. Artifacts that are of forensic
    interest are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Interfaces and Addressing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understanding the naming of network devices and network addressing is useful
    in a forensic examination. This knowledge helps the investigator find corresponding
    references to devices and addresses in logs, configuration files, or other persistent
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'During a system boot, the kernel detects and initializes hardware, including
    network devices. As the Linux kernel finds physical network interfaces, it automatically
    assigns generic names (which systemd will later rename). Additional virtual interfaces
    may also be created and configured. Common generic names for interfaces include:'
  prefs: []
  type: TYPE_NORMAL
- en: '| eth0 | Ethernet |'
  prefs: []
  type: TYPE_TB
- en: '| wlan0 | Wi-Fi |'
  prefs: []
  type: TYPE_TB
- en: '| wwan0 | Cellular/Mobile |'
  prefs: []
  type: TYPE_TB
- en: '| ppp0 | Point-to-point protocol |'
  prefs: []
  type: TYPE_TB
- en: '| br0 | Bridge |'
  prefs: []
  type: TYPE_TB
- en: '| vmnet0 | Virtual machines |'
  prefs: []
  type: TYPE_TB
- en: The first three examples here are physical hardware interfaces; the last three
    are virtual. There is a problem when a system has multiple physical interfaces
    of the same type. When the kernel boots, it assigns generic interface names to
    network devices in the order they are detected. This ordering is not always the
    same across reboots, and an Ethernet interface named `eth0` might be named `eth1`
    the next time the system boots. To solve this problem, systemd began renaming
    interfaces (via the `systemd-udevd` service) with a naming convention that is
    consistent across boots and encodes information about the device in the interface
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'A renamed interface begins with a descriptive prefix—for example, `en` for
    Ethernet, `wl` for WLAN, or `ww` for WWAN. The PCI bus is denoted with `p`, the
    PCI slot is denoted with `s`, and the PCI device function (if not zero) is denoted
    with `f`. For example, if a running machine has interfaces `enp0s31f6` and `wlp2s0`,
    we know they are Ethernet (`en`) and Wi-Fi (`wl`), and we can match the PCI bus,
    slot, and function with the `lspci` output^([1](footnotes.xhtml#ch08foot_01))
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These are only some of the characters used to denote a device name. For a complete
    description of the systemd device names, see the systemd.net-naming-scheme(7)
    man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, this automatic renaming can lead to long and complex interface names
    (`wwp0s20f0u2i12`, for example); however, these names can be analyzed to understand
    more about the physical hardware. The renaming action can be observed in the kernel
    logs; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the Ethernet, Wi-Fi, and WWAN interfaces of a laptop have all been renamed
    by `systemd-udevd`. A system administrator can prevent the renaming of interfaces
    with a bootloader kernel flag (`net.ifnames=0`) or by using udev rules (*/etc/udev/rules.d/**).
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a MAC address can provide information about the hardware or lower-layer
    protocols used. Physical interfaces have MAC addresses to identify the machine
    at the link layer of an attached network. These MAC addresses are intended to
    be unique for each network device, and they can be used as identifiers in an investigation.
    Manufacturers define MAC addresses based on address blocks allocated by the IEEE.
    The IEEE Organizationally Unique Identifier (OUI) database (*[https://standards.ieee.org/regauth/](https://standards.ieee.org/regauth/)*)
    lists the MAC address blocks allocated to organizations. The Internet Assigned
    Numbers Authority (IANA) MAC address block (00-00-5E) lists the allocated IEEE
    802 protocol numbers (*[https://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xhtml](https://www.iana.org/assignments/ethernet-numbers/ethernet-numbers.xhtml)*).
    These are both described in RFC 7042 (*[https://tools.ietf.org/html/rfc7042/](https://tools.ietf.org/html/rfc7042/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The MAC address used will typically be found in the kernel logs when the device
    was first detected. A device’s kernel module logs the MAC address, and log entries
    may look slightly different across devices. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, three different kernel modules (`e1000e`, `r8169m`, and `igb`)
    produced kernel logs containing a MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MAC address can be manually modified, randomly generated, or even made
    to spoof another machine. Reasons for MAC address modification may be legitimate
    concerns for personal privacy, deliberate anti-forensic efforts to obscure identity,
    or even attempts to impersonate the identity of another device on a network. MAC
    address randomization is a systemd feature (not used by default), and it’s documented
    in the systemd.link(5) man page. The modification of a MAC address might not be
    visible in the logs, and it may be determined from configuration files (*/etc/systemd/network/*
    .link*), udev rules (*/etc/udev/rules.d/*.rules*), or manually entered commands
    (possibly found in the shell history). The following command example manually
    changes a MAC address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: IP addresses (IPv4 or IPv6), routes, and other network configuration information
    can be statically defined in distro-specific files, dynamically configured by
    network managers, or manually specified with tools such as `ip` (the modern replacement
    for ifconfig). For more information, see the ip(8) man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of forensic investigations, previously used IP and MAC addresses
    can be used to reconstruct past events and activity. Places to search for IP and
    MAC addresses on the local machine include:'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel logs (`dmesg`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systemd journal and syslog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache and persistent data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other files in user XDG directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell history of system administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many places to look for MAC and IP addresses are not on the local machine, but
    rather on the surrounding infrastructure or remote servers. MAC addresses are
    visible only on a local subnet, so searching for MAC addresses will be limited
    to link-layer infrastructure, such as Wi-Fi access points, DHCP servers, link-layer
    monitoring systems (arpwatch, for example), and other local network switching
    infrastructure. During an ongoing incident, other machines on the same subnet
    may have traces of a suspect machine’s MAC address in their arp caches (mostly
    from broadcast packets). Remote servers will likely retain a significant amount
    of information regarding past IP addresses. Applications and OS components sending
    telemetry data or other network traffic that contains unique identifiers may also
    be logged on the remote infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Within an organization, CERT/SOC/Security teams may have access to further security
    monitoring information to investigate incidents. Within a legal jurisdiction,
    law enforcement agencies may be able to make requests for this information to
    investigate criminal activity.
  prefs: []
  type: TYPE_NORMAL
- en: '***Network Managers and Distro-Specific Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Historically, each Linux distribution has managed the network configuration
    in its own way. On server systems, this may change in the future, as systemd provides
    a standard network configuration method using unit files. On client and desktop
    systems, the need for dynamically configured networking (roaming with Wi-Fi or
    mobile protocols) has increased, and network managers have become common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debian-based systems configure networking in the */etc/network/interfaces*
    file. This file specifies the network configuration for each interface. An interface
    can be statically configured or use DHCP. IPv4 and IPv6 addresses can be specified
    with static routing, DNS, and more. Here’s an example taken from a */etc/network/interfaces*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the interface is configured at boot with a static IPv4 address. The address,
    netmask, and default route are defined. The DNS server and search domain are configured.
    Files containing snippets of configuration can also be stored in the */etc/network/interfaces.d/*
    directory. Other directories in */etc/ network/* are used for pre and post scripts
    to be run when interfaces go up or down. See the interfaces(5) man page for more
    information on a Debian or Debian-based system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Red Hat and SUSE use the */etc/sysconfig/* directory to store configuration
    files. These files contain variables (`key=value`) and shell commands that can
    be included in other shell scripts or used by unit files during system boot or
    during system administration. The */etc/sysconfig/network-scripts/* and */etc/
    sysconfig/network/* directories contain network configuration files. The following
    example shows a configuration for an `enp2s0` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the configuration of the `enp2s0` interface is defined. These
    variable-based configuration files are tool independent, and different network
    management tools can use the same set of configuration files. SUSE has also introduced
    Wicked, an alternative network configuration system using a daemon (wickedd) that
    monitors network interfaces and can be controlled over the D-Bus. The */etc/sysconfig/*
    directory is still read and additional XML configuration files are created in
    the */etc/wicked/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: The Arch Linux project has developed a network management system called netctl,
    which is based on systemd. Arch does not install netctl by default, but it gives
    users the choice to use it or other distro-independent network managers. Netctl
    profiles are stored by name in the */etc/netctl/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Systemd provides network management using three types of network configuration
    files that look similar to unit files. The configuration file typically references
    the network device (eth0 for example) with one of the following extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '***.link*** Configure physical network devices; Ethernet, for example'
  prefs: []
  type: TYPE_NORMAL
- en: '***.netdev*** Configure virtual network devices such as VPNs and tunnels'
  prefs: []
  type: TYPE_NORMAL
- en: '***.network*** Configure the network layer (IPv4, IPv6, DHCP, and so on)'
  prefs: []
  type: TYPE_NORMAL
- en: The systemd-udevd daemon uses *.link* files, and the systemd-networkd daemon
    uses *.netdev* and *.network* files. Default network configuration files provided
    by the distribution or installed packages are found in the */usr/lib/ systemd/network/*
    directory. System administrator custom configurations are found in the */etc/systemd/network/*
    directory. Examining these directories will provide insight into how networking
    was configured using systemd.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example *.link* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the default link configuration is overridden so that interfaces
    get a randomly generated MAC address at boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example *.netdev* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple *.netdev* file defines a bridge interface called `br0`. An interface
    can then be added to the bridge in a *.network* file, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, a static IP address, netmask (`/24`), and default route are defined for
    the `eth1` interface. See the systemd.link(5), systemd.netdev(5), and systemd
    .network(5) man pages for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Many Linux systems use the NetworkManager daemon to manage network configuration,
    especially on desktop systems. The configuration data is located in the */etc/NetworkManager/*
    directory. The *NetworkManager.conf* file holds general configuration information,
    and the individual connections are defined by name in the */etc/NetworkManager/system-connections/*
    directory. For Wi-Fi connections, these files may contain network names and passwords.
    See the NetworkManager(8) and NetworkManager.conf(5) man pages for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '***DNS Resolution***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computer systems on the internet use the domain name system (DNS) to determine
    IP addresses from hostnames and hostnames from IP addresses.^([2](footnotes.xhtml#ch08foot_02))
    This online lookup is called DNS resolution, and Linux machines implement it using
    a mechanism called a *DNS resolver*. Unlike IP addresses and routing, DNS resolution
    is not configured in the kernel, but operates entirely in userspace. The resolver
    functionality is built into the standard C library that uses the */etc/resolv.conf*
    file to specify the local DNS configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration file contains a list of DNS name server IP addresses and
    may also contain domain names used by the local system. The IP addresses may be
    IPv4 or IPv6, and refer to DNS servers run by the local network administrators,
    internet service providers (ISPs), or DNS providers. The following is an example
    *resolv.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the search domain is appended to simple hostnames and two name servers
    are specified (if the first one is down, the second one is tried). More recent
    resolver implementations facilitate resolution over D-Bus and local sockets.
  prefs: []
  type: TYPE_NORMAL
- en: You can find other options in the resolv.conf(5) man page. Also, an */etc/resolv.conf.bak*
    file may exist that contains settings from previous DNS configurations. The filesystem
    timestamps of the *resolv.conf* file will indicate when the file was generated.
  prefs: []
  type: TYPE_NORMAL
- en: As roaming and mobile machines made networking more dynamic, system administrators,
    network managers, daemons, and other programs all wanted to make changes to the
    *resolv.conf* file. This was problematic because one program (or person) would
    sometimes undo the changes made by another, causing confusion. Today, the *resolv.conf*
    file is typically managed using a framework called *resolvconf* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the Linux distribution, the resolvconf framework used may be openresolv
    or systemd’s resolvconf. The systemd-resolved daemon is configured in the */etc/systemd/resolved.conf*
    file; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The systemd-resolved system manages the *resolv.conf* file based on parameters
    in the */etc/systemd/resolved.conf* file, and specifies DNS servers, domains,
    fallback servers, and other DNS resolver configuration. The alternative openresolv
    framework stores its configuration in the */etc/resolvconf.conf* file. See the
    resolvconf(8) man page for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Some applications are able to use DNS over HTTPS (DoH) or DNS over TLS (DoT),
    where DNS queries are sent to a DNS provider over an encrypted connection. Many
    modern web browsers provide this feature, which bypasses the local DNS resolver
    system. Be sure to check the browser configuration for alternate DNS providers.
    Systemd currently supports DoT.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resolver configuration files are interesting because they provide a link
    between a Linux system and the ISP or DNS provider. The ISP or DNS provider may
    have logs of DNS queries and timestamps available for investigators on request.
    DNS queries logged on DNS servers can provide a wealth of information about the
    activities of a machine, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: History of websites a user visited (including frequency of repeat visits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email, messaging, and social media activity (which providers are used and the
    frequency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of any applications that check for updates or send telemetry requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On server systems, reverse DNS^([3](footnotes.xhtml#ch08foot_03)) lookups may
    indicate network connections *to* the Linux system under investigation (the resolved
    FQDNs may be visible in the logs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other DNS resource records (MX, TXT, and so on) that have been queried
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within an organization, CERT/SOC/Security teams may have access to this information
    to investigate security incidents. Within a legal jurisdiction, law enforcement
    agencies may be able to make lawful requests for this information to investigate
    criminal activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */etc/nsswitch.conf* file was developed to allow multiple sources of information
    (databases) for users, groups, host lookups, and more. The `hosts:` entry defines
    how lookups are made; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, that entry states that the local files (*/etc/hosts*) should be queried
    first, followed by DNS. This line may define conditional statements or other databases.
    See the nsswitch.conf(5) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The */etc/hosts* file predates DNS and is a local table of IP-to-hostname mappings.
    The system will check this file first before it attempts to resolve a hostname
    or IP address using DNS. The *hosts* file is typically used today to configure
    local hostnames and define custom IP/hostname pairs. In a forensic examination,
    this file should be checked for any changes by the system administrator or malicious
    actors.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, Avahi is the Linux implementation of Apple’s Zeroconf specification.
    Zeroconf (and therefore Avahi) uses multicast DNS to publish services (like file
    sharing, for example) on a local network. These services are discoverable by other
    clients on the local network. The Avahi configuration is found in */etc/avahi/*
    and the avahi daemon logs activity to the journal (search for logs from avahi-daemon).
  prefs: []
  type: TYPE_NORMAL
- en: '***Network Services***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some Linux daemons listen on network interfaces for incoming service requests.
    At the transport layer, this is typically a listening UDP or TCP socket. UDP and
    TCP sockets bind to one or more interfaces and listen on a specified port number.
    In a forensic examination, we are interested in identifying the listening services
    started at boot time and possibly those started during the operation of the machine.
    These services may be normal legitimate services, services run by the system owner
    for abusive purposes, or services started by malicious actors (backdoors, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many network services have a daemon permanently running on the system that
    accepts connection requests from remote clients over the network. The configuration
    of these services typically includes the port and interfaces on which to listen.
    This configuration is specified by flags provided to the daemon program binary,
    a configuration file, or compiled-in defaults. Network daemon configuration files
    don’t have a standard syntax, but there are similarities. Here are a few common
    daemons and their associated configuration syntax for listening services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These examples show how configuration file syntax is completely different among
    network service daemons. However, they all specify the same things, like port
    numbers (possibly more than one), the address family (IPv4, IPv6, or both), or
    the interface on which to listen (by IP address or network device name).
  prefs: []
  type: TYPE_NORMAL
- en: On a running system, the `ss` tool (a modern alternative to `netstat`) can show
    all the listening ports together with the name of the daemon. For example, we
    can use `ss -lntup` to show all listening numeric TCP and UDP ports with the listener
    process name. But in a postmortem forensic examination of a filesystem, we have
    only configuration files and logs to determine what was listening. This analysis
    involves examining all the enabled network daemons and individually checking their
    configuration files for listening interfaces or IP addresses (if nothing is defined,
    the compiled-in defaults are used).
  prefs: []
  type: TYPE_NORMAL
- en: 'Many services will emit log messages on startup describing how they are listening
    on the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, the secure shell daemon (`sshd`) and the Bind DNS server
    (`named`) both logged information about their listening configuration on startup.
  prefs: []
  type: TYPE_NORMAL
- en: Services bound only to localhost (127.0.0.1 or ::1) are accessible from the
    local machine, but not from attached networks (like the internet). This restricted
    listening is typically done for backend services like databases that are accessed
    by other local daemons, but never intended for remote machines over a network.
    Some incidents involve the misconfiguration of these backend services, which accidentally
    exposes them to the internet where they can be abused or compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Hosts with more than one network interface are known as *multihomed systems*
    and typically include firewalls, proxy servers, routers, or machines with virtual
    interfaces from VPNs or tunnels. Client programs may have flags or configuration
    defining which interface (or IP) to use as the originating source. For example,
    the `ping` command has the `-I` flag to specify a source IP or interface for ping
    packets. Secure shell (SSH) clients may use the `-b` flag or `bindaddress` directive
    to specify the source IP on a machine with multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In a forensic examination, these flags or configurations can be important because
    they indicate the source IP of established network connections, or the interface
    from where network traffic came. The IP address may correlate with remote logs,
    intrusion detection systems (IDSs), or network forensic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Some network services are started on demand using a network-based activation
    mechanism. Traditional Unix-style activation for network services uses a daemon
    called inetd (or xinetd, a popular alternative) that listens on multiple incoming
    TCP and UDP ports and waits to start the appropriate daemon when a connection
    is attempted. A systemd **.socket* file performs similar socket-based activation
    for daemons that are started on demand.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Network Backdoor**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'I’ll conclude this section with a case study of a backdoor implemented using
    systemd socket activation. In this example, two malicious unit files are written
    to a user’s systemd unit directory (*.config/systemd/user/*), providing a socket-activated
    backdoor shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If enabled, this *backdoor.socket* file listens on TCP port 6666 and starts
    the *backdoor.service* unit when a connection is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This *backdoor.service* file starts a Bash shell and passes input and output
    (`stdin` and `stdout`) to the connected network client. A remote attacker can
    then access the backdoor with netcat and run shell commands (using CTRL-C to disconnect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When the user is logged in, the backdoor is available and shell commands can
    be run as that user. This backdoor is an example of unauthenticated shell access
    to a Linux machine using socket activation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Socket activated services are visible in the journal logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first log entry is a message that the listener has started and the
    next two entries show an incoming connection from a remote IP causing the service
    to start. The last entry is the termination of the connection that includes information
    about the TCP session (source and destination ports and IP addresses).
  prefs: []
  type: TYPE_NORMAL
- en: '**Wireless Network Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The growth of wireless mobile devices and the convenience of wireless technologies
    have led to the implementation of wireless standards in Linux systems. The most
    prevalent include Wi-Fi, Bluetooth, and WWAN mobile technology. Each of these
    three technologies leave traces of evidence on the local system that may be of
    interest to forensic investigators. In addition, the wireless device or infrastructure
    with which the Linux machine connects may also have traces of evidence (Locard’s
    principle applied to wireless technologies).
  prefs: []
  type: TYPE_NORMAL
- en: '***Wi-Fi Artifacts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The 802.11x Wi-Fi standards allow client computers to connect wirelessly to
    access points (APs), also known as hotspots or base stations. From a forensics
    perspective, we are looking for various artifacts that might be found on the Linux
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: SSID (Service Set IDentifier), the name of connected Wi-Fi networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BSSID (Basic SSID), the MAC address of connected base stations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords to connected Wi-Fi networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Linux system was an AP, the SSID and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Linux system was an AP, which clients connected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other configuration parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can find these artifacts in configuration files, logs, and other persistent
    cache data.
  prefs: []
  type: TYPE_NORMAL
- en: Computers typically connect to Wi-Fi networks using various forms of authentication
    and security, with WPA2 (Wi-Fi Protected Access 2) being the most popular today.
    Managing WPA2 under Linux requires a daemon to monitor and manage key negotiation,
    authentication, and association/disassociation of the kernel’s Wi-Fi device. The
    wpa_supplicant daemon was originally developed for this purpose in 2003 and has
    been widely used since.
  prefs: []
  type: TYPE_NORMAL
- en: The iwd daemon was created by Intel and released in 2018 as a modern and simplified
    replacement for wpa_supplicant. Both of these implementations may have configuration
    data, logs, and cached information that can be of interest to forensic examiners.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wpa_supplicant` daemon (which is part of the software package called wpa_
    supplicant or wpasupplicant) can store static configuration in */etc/wpa _supplicant.conf*,
    but it is more commonly configured by a network manager dynamically over D-Bus.
    The daemon may log information to the system log; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a Linux system running `wpa_supplicant` connected to the `Free`
    network and disconnected a few minutes later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel may log certain activity related to the joining and disconnecting
    of Wi-Fi networks, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the access point’s MAC address is shown with timestamps of when the system
    successfully authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The iwd daemon can be controlled over D-Bus by different network managers. The
    configuration file is */etc/iwd/main.conf*, which is documented in the iwd.config(5)
    man page. The */var/lib/iwd/** directory contains a file for each network configured
    using iwd.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is the file for a network called *myfreewifi*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The name of the network is part of the filename. The contents of the file contains
    the password to the network and other settings. The file creation timestamp is
    a possible indicator of when the network was first created and joined. The iwd.network(5)
    man page provides more information about the contents of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'On some distros (such as Red Hat and SUSE), configured Wi-Fi details may be
    found in the */etc/sysconfig/* directory; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here the *myhotspot* Wi-Fi network is configured and saved to the *ifcfg-wlan0*
    file, and the password is also in plain view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NetworkManager stores connection information in the directory */etc/ NetworkManager/system-connections/*.
    A file for each connected network is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This shows the Wi-Fi network details, including a timestamp of when the network
    was first configured, SSID name, BSSID MAC address, and more. Depending on the
    configuration a password may also be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the NetworkManager saves information in the directory */var/lib/NetworkManager/*,
    where you may find DHCP lease files containing information about obtained leases
    from various interfaces, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation (birth) timestamp of the file indicates when the lease was given
    by the DHCP server, and the file called *timestamps* contains a list of leases
    with an identifier associated with a lease filename and a numeric timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, a list of BSSIDs (MAC addresses) that were seen is recorded in the *seen-bssids*
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A Wi-Fi network (with the same SSID) may consist of multiple BSSIDs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Access Points**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If a Linux system was used as an access point, it was most likely using the
    hostapd software package. Check whether the hostapd package is installed and whether
    it was enabled to run as a systemd service. The hostapd configuration files are
    usually located in */etc/hostapd/**, and the *hostapd.conf* file contains the
    configuration of the Wi-Fi network(s) being provided, such as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Wi-Fi network name and password are shown, it’s a hidden network (broadcast
    ignored), and the region is specified (regulatory compliance). The original *hostapd.conf*
    file is well commented with further parameter examples, and more information can
    be found at *[https://w1.fi/hostapd/](https://w1.fi/hostapd/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A password can also be stored in password-based key derivation function (PBKDF2)
    format, in which case recovery is difficult, but it can be attempted with password
    recovery tools. Pre-shared key (PSK) strings in *hostapd.conf* look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This string does not reveal the password, but it is sufficient to gain access
    to a Wi-Fi network. The password might be found on another client device attached
    to the same network.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several places to look for MAC addresses of clients connecting to
    a hostapd access point. Hostapd writes logs to syslog by default, and the MAC
    addresses of other clients connecting and disconnecting may be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Another place to look for possible MAC addresses is in the accept and deny files.
    If used, the location of these files is defined with the `accept_mac_file=` and
    `deny_mac_file=` parameters in the configuration. These files contain a list of
    MAC addresses that the administrator has explicitly allowed or blocked. These
    MAC addresses could be meaningful in a forensic investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Bluetooth Artifacts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bluetooth under Linux is achieved using a combination of kernel modules, daemons,
    and utilities. The Bluetooth subsystem retains multiple forensic artifacts that
    can be analyzed and associated with separate physical devices. Evidence of a Bluetooth
    device paired with a Linux system may be useful in an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about current and previously paired Bluetooth devices is found
    in the */var/lib/bluetooth/* directory. There is an initial subdirectory named
    after the MAC address of the locally installed Bluetooth adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The creation (birth) timestamp of this directory indicates when the adapter
    was first installed. If the Bluetooth adapter is on the mainboard, it will likely
    match the time of the distro installation. If a USB Bluetooth adapter was used,
    the creation time will indicate when it was first plugged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This local adapter device directory contains further directories and a *settings*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The *settings* file provides information about the discoverability. The MAC
    address directories are named after the currently paired devices. The *cache/*
    directory contains files named after current and previously paired device MAC
    addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These files include Bluetooth devices that the user has deleted from the paired
    devices list in the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MAC address directories contain one or more files. An *info* file provides
    more information about the paired device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This shows the device MAC address (in the directory name), a description of
    the device and its services, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *cache/* directory is potentially more interesting from a historical perspective,
    as it contains both currently paired devices and previously paired devices. The
    files may have less information than the paired device *info* files, but a simple
    `grep` in the cache directory can show a list of previously used devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The creation (birth) timestamps of these files may indicate when the device
    was paired with the Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reconstruction of paired devices is interesting, but so is the actual usage
    of those paired devices. Depending on the device type and Bluetooth services used,
    that usage may be revealed in the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These logs indicate that the previously identified `[Samsung] R3` device was
    connected for 17 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Additional device-specific fields and files (attributes) may exist for each
    MAC address. Depending on the device and the relevance to an investigation, they
    may require additional scrutiny.
  prefs: []
  type: TYPE_NORMAL
- en: '***WWAN Artifacts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many laptops today are able access mobile networks (3G/4G/5G, and so on) using
    an internal modem or plug-in USB device, together with a SIM card provided by
    the carrier. Linux supports these mobile technologies, and traces of activity
    can be found in local configuration files, databases, and logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways a Linux system interfaces with mobile modems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Legacy serial devices: */dev/ttyUSB** controlled with AT commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'USB communications device class (CDC) devices: */dev/cdc-wdm** controlled with
    a binary protocol^([4](footnotes.xhtml#ch08foot_04))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PCIe devices: */dev/wwan** controlled over the modem host interface (MHI)^([5](footnotes.xhtml#ch08foot_05))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the mobile connection is authenticated, authorized, and established, the
    network interface can be configured. Common network interface names include `ppp*`
    (for legacy modems), `wwan*`, `ww*` (for renamed interfaces), and `mhi*` (for
    MHI based PCIe modems). The modem device names and network interfaces can be found
    in the logs and may reveal connectivity to mobile infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few examples show an integrated USB modem using the MBIM protocol
    to connect to a mobile network. Here, the modem device is detected by the kernel
    and a `wwan0` network device is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The ModemManager daemon then takes over the management of the device and setting
    up the mobile connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, the ModemManager logs several state changes. It enables the modem, searches
    for the provider and home network, registers the device, and connects to the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the device is connected at the modem layer, the NetworkManager takes
    over, requesting and configuring the IP network (IP addresses, routing, and DNS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The mobile provider gives the mobile interface an IP address, default gateway,
    and DNS servers. By default, the kernel and ModemManager don’t log mobile identifier
    information such as the IMSI or IMEI. Depending on regional regulatory requirements,
    this connection information may be logged by the mobile provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Linux systems may have the *Modem Manager GUI* installed that can send
    and receive SMS text messages and USSD commands. The Modem Manager GUI stores
    SMS messages in a GNU database (`sms.gdbm`) in the user’s home directory with
    a unique device identifier for a directory name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This file can be dumped with the `gdbm_dump` tool (part of the gdbm package),
    but the `strings` command will also produce readable output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Each SMS message is shown within the `<text>` tags. The phone numbers and times^([6](footnotes.xhtml#ch08foot_06))
    are shown, and the `<read>` tag indicates if an incoming message was read or not.
    The folder numbers represent incoming messages (`0`), sent messages (`1`), and
    draft messages (`2`). More information can be found at *[https://sourceforge.net/projects/modem-manager-gui/](https://sourceforge.net/projects/modem-manager-gui/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network Security Artifacts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The topic of network security involves protecting the perimeter of a system
    with firewalls and protecting the privacy and integrity of network traffic. The
    following sections describe common firewalls and VPNs under Linux and how to analyze
    the logs, configuration, and other persistent information that may be of interest
    in a forensic investigation. Focus will be especially given to (relatively) new
    technologies such as NFTables and WireGuard. The SSH protocol also provides a
    layer of network security (see [Chapter 10](ch10.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: '***WireGuard, IPsec, and OpenVPN***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'WireGuard is a relative newcomer to the VPN landscape. It was originally developed
    for Linux by Jason Donenfeld and is now a default part of the kernel. WireGuard
    was designed for simplicity, and implemented as a kernel module that creates a
    virtual interface. The interface behaves like any other network interface: it
    can be brought up or down, be firewalled, route traffic, or be queried with standard
    network interface tools. A packet sniffer like tcpdump or Wireshark can also be
    used to capture network traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: WireGuard is a point-to-point tunnel-mode VPN, encapsulating IP packets inside
    UDP and transmitting them to configured peers. Modern cryptographic protocols
    (such as Curve, ChaCha, and so on) are used, and the key management is in-band.
    Its ease of use, performance, and stealthy behavior are making WireGuard popular
    among hobbyists, researchers, and the hacking community.
  prefs: []
  type: TYPE_NORMAL
- en: WireGuard interfaces can be arbitrarily named by the system owner, but `wg0`
    is most commonly used. References to this device may be found in configuration
    files and logs wherever you would use other network interface names (like `eth0`
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each WireGuard interface typically has one configuration file that contains
    a private key, public keys of all peers, IP addresses of endpoints, and allowed
    IP ranges. The WireGuard configuration information is usually found in one of
    several places:'
  prefs: []
  type: TYPE_NORMAL
- en: The WireGuard default file, */etc/wireguard/wg0.conf*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A systemd *.netdev* file like */etc/systemd/network/wg0.netdev*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A NetworkManager file like */etc/NetworkManager/system-connections/ Wireguard
    connection 1*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The */etc/wireguard/* directory may have one or more configuration files named
    after the interface. The files look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `[Interface]` section describes the local machine, and the `[Peer]` section(s)
    describe the trusted peers (there can be more than one peer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Systemd supports WireGuard configuration in a .*netdev* file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: An associated *.network* file may be needed to configure the IP address of the
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The NetworkManager daemon has a VPN plug-in for WireGuard and can be configured
    alongside other VPNs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The WireGuard configuration follows the NetworkManager file format described
    earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The software package *wireguard-tools* provides documentation, systemd unit
    files, and tools for configuring WireGuard. The `wg-quick` script was created
    for easy command line use. Forensic investigators should examine the shell history
    for evidence of manual use of the `wg` and `wg-quick` tools.
  prefs: []
  type: TYPE_NORMAL
- en: WireGuard’s configuration provides several artifacts that may be interesting
    from a forensics perspective. The IP addresses used for the `wg0` interface may
    be found in both the local and the remote peer’s logs or configuration. The public
    keys of peers provide a cryptographic association between multiple machines (increased
    strength of evidence). The allowed IP list describes a range of IP addresses expected
    to exist behind the remote peer (possible routed networks). These IPs may also
    appear in the logs and may be of significance. All of these artifacts are helpful
    in reconstructing a VPN network setup.
  prefs: []
  type: TYPE_NORMAL
- en: IPsec is an IETF standard, and the associated protocols are documented in dozens
    of RFCs. IPsec operates in either tunnel-mode (encrypting whole packets) or transport-mode
    (encrypting just payloads). IPsec is a standard part of the kernel that can encrypt
    and authenticate traffic, but userspace tools and daemons are needed for configuration
    and key management. Out-of-band key management is performed using Internet Key
    Exchange (IKE), a daemon provided independently by various implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The three most current IPsec implementations for Linux are StrongSwan (*[https://www.strongswan.org/](https://www.strongswan.org/)*),
    Openswan (*[https://www.openswan.org/](https://www.openswan.org/)*), and Libreswan
    (*[https://libreswan.org/](https://libreswan.org/)*). These implementations store
    configuration data on the local system and log various usage. Check locally installed
    packages and associated directories in */etc/* for the existence of these IPsec
    implementations. If they have been installed, the configuration and logs can be
    analyzed to understand usage and recover interesting forensic artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: OpenVPN (*[https://openvpn.net/](https://openvpn.net/)*) was originally developed
    as a TLS-based userspace competitor to IPsec. OpenVPN is the name of both the
    commercial company and the open source project. OpenVPN’s advantage is not performance,
    but ease of use. Another difference from IPsec is its focus on authenticating
    people rather than machines to allow network access to protected networks.
  prefs: []
  type: TYPE_NORMAL
- en: The `openvpn` program (installed as part of the openvpn package) can run as
    a client or server, depending on the startup flags used. Configuration data can
    be found in the */etc/openvpn/client/* or */etc/openvpn/server/* directories.
    See the openvpn(8) man page for more information. The NetworkManager daemon has
    an OpenVPN plug-in and may have a separate configuration file (or files) in the
    */etc/NetworkManager/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux Firewalls and IP Access Control***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linux has a long history of firewall support and has made many significant changes
    to the kernel firewall subsystem over time (nftables replaced iptables, which
    replaced ipchains, which replaced ipfwadm). The most recent major change was the
    replacement of iptables with nftables.
  prefs: []
  type: TYPE_NORMAL
- en: Linux also has a basic firewall functionality called Berkeley Packet Filter
    (BPF), which is often used for filtering by process or systemd unit. Other IP
    filtering is done in the form of userspace access control lists for network-facing
    applications. Depending on the context of a forensic investigation, an examination
    of firewall controls (or lack thereof) may be important.
  prefs: []
  type: TYPE_NORMAL
- en: Linux network firewalling is done in the kernel. Userspace tools and daemons
    can manage the firewall (and other network components), but they only pass configuration
    information to the kernel. To remain persistent, the firewall rules must also
    be added to the kernel on boot. Firewall logging is done through the kernel’s
    ring buffer, as described in [Chapter 5](ch05.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The nftables firewall functionality is a significant upgrade to the old iptables
    system, and all distros and tools are replacing the legacy iptables with it (compatibility
    scripts make this easy). In addition, nftables combines IPv4, IPv6, and MAC address
    filtering into a single configuration file and allows multiple actions per rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'If configured by hand (on servers, for example), the typical nftables configuration
    location is in the */etc/nftables.conf* file or an */etc/nftables/* directory.
    This file is typically loaded by a systemd unit, either automatically at boot
    or manually after changes have been made. Here is an example configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The kernel firewall in this example is configured to allow outgoing connections
    (including return packets), allow incoming `ping` and `ssh`, and block the rest
    (and prevent routing). The comments in the file explain the rules. See the nft(8)
    man page for more information about nftables rules.
  prefs: []
  type: TYPE_NORMAL
- en: Linux distros may have their own mechanism for managing firewall rules. Ubuntu
    uses Uncomplicated FireWall (UFW) to specify rules that are passed to iptables/nftables.
    Configuration and firewall rule files are located in the */etc/ufw/* directory.
    The `ENABLED=` setting in *ufw.conf* indicates whether the firewall is active.
    If logging is enabled, UFW will log to syslog, which may save logs to */var/log/ufw.log*
    (if rsyslog is configured).
  prefs: []
  type: TYPE_NORMAL
- en: Fedora/Red Hat and SUSE use firewalld to configure nftables (SUSE replaced its
    old SuSEfirewall2 system in SLES15). The firewalld daemon is enabled in systemd,
    and configuration is found in the */etc/firewalld/* directory. If logging is enabled,
    logs are written to */var/log/firewalld*. All these distro-specific rule management
    systems (scripts or GUIs) ultimately just add rules to nftables in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Some firewall rules may be dynamically created by security software or intrusion
    prevention systems (IPSs) reacting to malicious activity. For instance, the fail2ban
    software package runs a daemon that monitors various logfiles for brute-force
    attacks. If a malicious IP address is detected, it is temporarily banned using
    iptables or nftables. Banned IP addresses from fail2ban are logged. Other similar
    IPS software (sshguard is an alternative to fail2ban) may also be running on a
    system and logging malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd unit files may contain directives that perform access IP control. Depending
    on the unit type, the directives `IPAddressAllow=` and `IPAddressDeny=` may be
    found in the `[Slice]`, `[Scope]`, `[Service]`, `[Socket]`, `[Mount]`, or `[Swap]`
    sections of a unit file. This systemd feature does not use nftables, but rather
    the extended Berkeley Packet Filter (eBPF), which is also part of the kernel.
    See the systemd.resource-control(5) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Applications may configure their own filter controls, where IP access decisions
    are made by userspace processes (not in the kernel). A traditional way of doing
    this is with */etc/hosts.allow* and */etc/hosts.deny* files. These files allow
    tailored access controls for applications that are compiled with the libwrap (TCP
    wrappers) library. See the hosts_access(5) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many applications have their own IP access control mechanisms that can be specified
    in their configuration files, which often allows more flexible access control
    tied to the application. For example, the Apache web server can be configured
    to allow access to only parts of the web tree for certain IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, anyone trying to access the */secretstuff* directory from outside
    the defined IP address ranges will receive an “HTTP 403 Forbidden” error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example where SSH allows logins only for selected users coming
    from a specified IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: These application layer IP controls don’t need to filter based on port numbers
    if they are listening only on one port.
  prefs: []
  type: TYPE_NORMAL
- en: From a forensics perspective, any logs containing blocked packets may be interesting.
    They show attempted connections and scanning activity that may be related to a
    compromise. They also reveal information about the location or state of a machine
    (possibly a roaming laptop) at a certain time. If the source MAC addresses are
    logged, they indicate the MAC addresses of sending machines on a locally attached
    network (a router typically). In the case of DDoS attacks, scanning, or other
    blocked malicious activity, the IP addresses used can be correlated with other
    intelligence data to gather more information about threat actors (possibly attributing
    them to a particular botnet).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proxy Settings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Proxy servers are a form of application layer firewall designed to provide indirect
    access to a remote service by proxy. When proxies are used, a client machine’s
    network connection terminates at the proxy server together with information about
    the remote service. The proxy server then establishes a new connection to the
    remote service on the client’s behalf. The passing of information about the remote
    connection is built in to the proxying protocol. Some protocols, like SOCKS or
    HTTP CONNECT, were specifically designed as proxies for TCP sessions. Other protocols,
    like SMTP, have an inherent proxying model in the protocol (for example, transferring
    email from host to host until it arrives at an inbox).
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux distro, proxy settings can be global for the entire system, specific
    to a user, or set individually in each application. The proxy server can be either
    a remote machine or a locally running daemon. Local proxy daemons are typically
    used for filtering local web traffic or acting as gateways to remote networks
    that are not directly accessible (like TOR, for example).
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways a Linux system can specify system-wide proxy settings.
    It is up to each application to decide how to handle those settings. Depending
    on the application, system-wide settings may be used, partially used, or ignored
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of environment variables can be used to specify proxies, which can be
    set in the shell startup scripts or anywhere environment variables are set. In
    some distros, the */etc/sysconfig/proxy* file, which contains proxy variables,
    is read at startup, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `NO_PROXY` setting ignores proxy settings for defined hosts, IP ranges,
    and domains. This is interesting from a forensics perspective, as it may contain
    domain names and network addresses, explicitly configured by a system administrator,
    that are not public and are possibly relevant to an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: A user’s dconf database also stores proxy settings that can be read by any supported
    application (like GNOME 3 or 40 applications). This information is stored in a
    *GVariant* database file in the user’s home directory (*~/.config/dconf/user/*).
    [Chapter 10](ch10.xhtml) explains how to extract and analyze dconf database contents.
  prefs: []
  type: TYPE_NORMAL
- en: The NetworkManager daemon has an option to discover and configure web proxy
    settings using *proxy auto configuration (pac*) files. A *pac* file uses JavaScript
    to define if and how URLs are to be proxied. Proxy *pac* files can be local or
    fetched from remote servers, and they can be found in the `[proxy]` section of
    network profiles stored in the */etc/NetworkManager/system -connections/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Each installed network application may have its own proxy settings that deviate
    from the system-wide proxy settings, which, in a forensic investigation, means
    that relevant applications need to be examined individually.
  prefs: []
  type: TYPE_NORMAL
- en: Command line proxies may also be used for starting applications. For example,
    `tsocks` and `socksify` are tools that allow programs to be started on the command
    line using SOCKS libraries to proxy network traffic (designed for programs with
    no proxy support). Evidence of command line proxying might be found in the shell
    history.
  prefs: []
  type: TYPE_NORMAL
- en: The examples above refer to clients using proxies, but Linux servers may also
    be running as proxy servers. Popular web proxies running on Linux include Squid
    and Polipo. Dante is another popular SOCKS proxy server.
  prefs: []
  type: TYPE_NORMAL
- en: Nginx provides support for several proxy protocols and can also act as a reverse
    proxy. A reverse proxy “impersonates” a remote server, accepting connections from
    clients while establishing a separate connection to the real server. Reverse proxying
    is common in enterprise environments for load balancing and web application firewalling
    (WAF). Reverse proxying is also how some anonymizer systems function.
  prefs: []
  type: TYPE_NORMAL
- en: A malicious use of reverse proxies is real-time-phishing attacks, where the
    reverse proxy performs an application layer man-in-the-middle attack between a
    victim client and server. Botnet command-and-control servers may also use reverse
    proxies for resilience against takedowns and for anonymization.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side proxies typically log client connections and activity, which can
    be analyzed in a forensic investigation. This is especially valuable in the case
    of seized malicious servers, because lists of client PCs (possibly infected victims
    from a botnet) can be extracted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter described how to analyze Linux networking, including the hardware
    layer dealing with interfaces and MAC addresses, network services, and DNS resolution.
    It also covered how to identify Wi-Fi artifacts and paired Bluetooth devices and
    analyze WWAN mobile activity. In addition, this chapter also explored Linux network
    security such as VPNs, firewalls, and proxies.
  prefs: []
  type: TYPE_NORMAL
