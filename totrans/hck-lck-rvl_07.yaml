- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DOCKER,
    ALEPH, AND MAKING DATASETS SEARCHABLE</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DOCKER、ALEPH与使数据集可搜索</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: When I get my hands on a new dataset, the first thing I do is search it for
    any juicy, easy-to-find revelations. Depending on the dataset, I might look for
    politicians, organizations, or the city where I live. In the previous chapter,
    you learned to search text files like CSV or JSON files using <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>,
    but <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> won’t work on binary
    files like PDFs or Office documents. In this chapter, you’ll expand your search
    capabilities with Aleph, an open source investigation tool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我获得一个新的数据集时，我做的第一件事就是搜索其中是否有任何有价值且易于发现的信息。根据数据集的不同，我可能会查找政治人物、组织或我所在的城市。在上一章中，你学习了如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>来搜索CSV或JSON文件这样的文本文件，但<samp
    class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>无法对像PDF或Office文档这样的二进制文件进行搜索。在本章中，你将通过Aleph这一开源调查工具，拓展你的搜索能力。
- en: Aleph is developed by the Organized Crime and Corruption Reporting Project,
    a group of investigative journalists largely based in eastern Europe and central
    Asia. The tool allows you to *index* datasets, extracting all the text they contain
    so they’re easy to search. You can use Aleph to search for keywords or *entities*
    (like people, companies, organizations, or addresses) and discover related entities
    in other datasets. Aleph also performs optical character recognition (OCR), which,
    as mentioned in [Chapter 1](chapter1.xhtml), takes flat images like scanned documents
    or screenshots, uses artificial intelligence to recognize any words, and converts
    those words into text that you can search or copy and paste.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph是由“有组织犯罪与腐败报告项目”开发的，这个项目是一个主要基于东欧和中亚地区的调查记者团队。该工具允许你*索引*数据集，提取其中包含的所有文本，使其易于搜索。你可以使用Aleph搜索关键词或*实体*（例如人物、公司、组织或地址），并发现与其他数据集中的相关实体。Aleph还可以执行光学字符识别（OCR），正如在[第1章](chapter1.xhtml)中提到的，它将扫描文档或截图等平面图像，利用人工智能识别其中的文字，并将这些文字转换成可以搜索或复制粘贴的文本。
- en: In the first half of this chapter, you’ll learn the ins and outs of using Docker
    and Docker Compose, the software required for running Aleph. In the second half,
    you’ll use your new Docker skills to run an Aleph server, then index and search
    part of the BlueLeaks dataset.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前半部分，你将学习如何使用Docker和Docker Compose，这是运行Aleph所需的软件。在后半部分，你将运用新学的Docker技能来运行Aleph服务器，然后对BlueLeaks数据集的部分内容进行索引和搜索。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introducing Docker and Linux Containers</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">介绍Docker和Linux容器</samp>
- en: Docker is the most popular software for running *Linux containers*, a type of
    software package. Linux containers can organize ready-to-go Linux software—complete
    with all of its dependencies, configuration, and source code—into a single bundle
    called a *container image* that you can quickly and easily run. The software inside
    containers is isolated from the rest of your computer; it can’t access any of
    those files unless you allow it to do so.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是运行*Linux容器*（一种软件包类型）最流行的软件。Linux容器可以将已经配置好的Linux软件——包括所有依赖项、配置和源代码——打包成一个叫做*容器镜像*的单一包，这样你就可以快速且轻松地运行它。容器中的软件与计算机的其他部分是隔离的；除非你允许，否则它不能访问任何文件。
- en: For example, let’s say you want to set up the popular WordPress blogging software
    in Linux. You use a package manager like apt to install the software WordPress
    depends on. You then put the WordPress source code in a location on your disk
    with the right permissions, configure your web server software so it knows where
    to look for that source code, and configure a database to store the blog’s data.
    You can then save all this work in a Linux container called <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    and reuse that container to spin up new WordPress sites with a single Docker command.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想在Linux中设置流行的WordPress博客软件。你使用像apt这样的包管理器来安装WordPress所依赖的软件包。然后，你将WordPress的源代码放置在磁盘上的一个位置，并设置正确的权限，配置你的Web服务器软件，以便它知道在哪里查找源代码，并配置一个数据库来存储博客的数据。之后，你可以将这些工作保存到一个名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>的Linux容器中，并通过一个Docker命令重新使用该容器来启动新的WordPress站点。
- en: 'Because Linux containers are isolated from the rest of your computer, multiple
    WordPress containers can run at the same time without interfering with each other.
    If someone hacks the software running in your container, they won’t be able to
    access any of the data located elsewhere on your computer—at least, not without
    also hacking Docker itself. This is why Dangerzone relies on Linux containers:
    if a malicious document manages to hack the Dangerzone container you’re using,
    your computer should still be safe. In addition to software like WordPress, you
    can use Linux containers to run commands in most Linux distributions without having
    to install those operating systems.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Linux 容器与计算机其他部分是隔离的，所以多个 WordPress 容器可以同时运行而互不干扰。如果有人入侵了在容器中运行的软件，他们将无法访问存储在计算机其他地方的数据——至少，在没有黑入
    Docker 本身的情况下，是无法做到的。这就是为什么 Dangerzone 依赖于 Linux 容器：如果恶意文档成功入侵你正在使用的 Dangerzone
    容器，你的计算机应该依然是安全的。除了像 WordPress 这样的软件，你还可以使用 Linux 容器在大多数 Linux 发行版中运行命令，而无需安装这些操作系统。
- en: 'Docker comes with two commands you’ll use in this chapter: <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>,
    which runs individual containers, and <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>,
    which lets you run multiple containers at once. You’ll practice using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command by running Linux
    containers for the Ubuntu and Kali Linux operating systems, as well as for the
    data science software Jupyter Notebook. You’ll then use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>
    to run a WordPress server and an Aleph server. Aleph requires a small network
    of services that communicate with each other, but as with WordPress, you can use
    a single Docker command to start up all these individual servers in their own
    containers. This process should prepare you to run Linux containers with Docker
    for other purposes later in the book.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 带有两个你将在本章中使用的命令：<samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>，用于运行单独的容器，以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>，它让你可以同时运行多个容器。你将通过运行
    Ubuntu 和 Kali Linux 操作系统的 Linux 容器，以及数据科学软件 Jupyter Notebook 来练习使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    命令。然后，你将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>
    来运行 WordPress 服务器和 Aleph 服务器。Aleph 需要一个小型的服务网络，它们相互通信，但和 WordPress 一样，你可以使用单个
    Docker 命令在各自的容器中启动所有这些独立的服务器。这个过程应该能帮助你为本书后续章节中使用 Docker 运行 Linux 容器做准备。
- en: 'This chapter covers two applications for running Docker containers: Docker
    Desktop and Docker Engine. Docker Desktop runs Docker containers on workstation
    computers in a Linux VM. Docker Engine, on the other hand, runs Docker directly
    on a Linux computer. Windows and Mac users, turn to Exercise 5-1 to set up Docker
    Desktop. Linux users, turn to Exercise 5-2 to install Docker Engine.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种用于运行 Docker 容器的应用程序：Docker Desktop 和 Docker Engine。Docker Desktop 在工作站计算机的
    Linux 虚拟机上运行 Docker 容器。而 Docker Engine 则直接在 Linux 计算机上运行 Docker。Windows 和 Mac
    用户请转到练习 5-1 来设置 Docker Desktop。Linux 用户请转到练习 5-2 来安装 Docker Engine。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*It’s possible for Linux users to install Docker Desktop, but I don’t recommend
    it for this chapter. Without a VM, Docker will be free to use all of your computer’s
    memory and processors, which will make indexing datasets in Aleph much faster.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linux 用户可以安装 Docker Desktop，但我不推荐在本章中使用它。没有虚拟机时，Docker 会自由地使用你计算机的所有内存和处理器，这将使
    Aleph 中的数据集索引速度大大加快。*'
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-1: Initialize Docker Desktop
    on Windows and macOS</samp>'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 5-1：在 Windows 和 macOS 上初始化 Docker
    Desktop</samp>
- en: When you installed Dangerzone in Exercise 1-3, Docker Desktop also should have
    been installed, since Dangerzone requires it. Confirm that Docker Desktop is installed
    by checking whether your *Applications* folder in macOS or Start menu in Windows
    has a Docker program; if not, download it from [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在练习 1-3 中安装 Dangerzone 时，Docker Desktop 应该也已安装，因为 Dangerzone 需要它。通过检查你的 macOS
    中的 *应用程序* 文件夹或 Windows 中的开始菜单是否有 Docker 程序来确认 Docker Desktop 是否已安装；如果没有，请从 [*https://<wbr>www<wbr>.docker<wbr>.com<wbr>/products<wbr>/docker<wbr>-desktop<wbr>/*](https://www.docker.com/products/docker-desktop/)
    下载。
- en: Open Docker and follow the onscreen instructions to initialize the software.
    You may need to reboot your computer. Docker Desktop’s Linux VM should be up and
    running before you can use Docker. If you click the Docker icon in your system
    tray and it tells you that Docker Desktop is running, you’re ready to proceed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Docker并按照屏幕上的说明初始化软件。您可能需要重新启动计算机。Docker Desktop的Linux虚拟机应已启动并运行，才能使用Docker。如果您点击系统托盘中的Docker图标并看到Docker
    Desktop正在运行，说明您可以继续操作。
- en: If you’re using Windows, you can use either PowerShell or Ubuntu with WSL for
    this chapter, since the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-desktop</samp> commands
    should run fine in either. Even when you use Docker from PowerShell, it technically
    relies on WSL under the hood.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows，可以使用PowerShell或Ubuntu与WSL来完成本章内容，因为<samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-desktop</samp>命令在两者中都应该能正常运行。即使您在PowerShell中使用Docker，它本质上也依赖于后台的WSL。
- en: If you’re using macOS, click the Docker icon in your system tray and choose
    **Preferences**. Switch to the Resources tab and make sure that the Memory resource
    is set to at least 6GB—higher if you have more to spare—to be sure Docker’s Linux
    VM has enough memory to handle Aleph. Click **Apply & Restart**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，点击系统托盘中的Docker图标并选择**偏好设置**。切换到“资源”标签，确保内存资源至少设置为6GB——如果您的电脑有更多内存，可以设置得更高——确保Docker的Linux虚拟机有足够的内存来运行Aleph。点击**应用并重启**。
- en: 'For either operating system, to test whether Docker is working, open a terminal
    and run this command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任一操作系统，测试Docker是否正常工作，打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command should run a Docker container image called <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>.
    If you don’t already have the <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    image on your computer, Docker should download it first. The output should look
    something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该运行一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>的Docker容器镜像。如果您的计算机上尚未有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>镜像，Docker会先下载该镜像。输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your computer is ready to run Linux containers. Skip to the “Running Containers
    with Docker” section on page 123.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计算机已经准备好运行Linux容器。跳至第123页的“使用Docker运行容器”部分。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-2: Initialize Docker Engine
    on Linux</samp>'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 5-2：在Linux上初始化Docker Engine</samp>
- en: Follow the detailed instructions for Server rather than Desktop at [*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/engine<wbr>/install<wbr>/*](https://docs.docker.com/engine/install/)
    to install Docker Engine for your version of Linux. In Ubuntu, the installation
    process involves adding a new apt repository to your computer and installing some
    Docker packages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照[*https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/engine<wbr>/install<wbr>/*](https://docs.docker.com/engine/install/)中的详细说明安装适用于您版本的Linux的Docker
    Engine。在Ubuntu中，安装过程包括将一个新的apt源添加到您的计算机中并安装一些Docker软件包。
- en: Docker Engine on Linux requires root access to run containers. After completing
    this exercise, if you’re using Linux, add <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>
    to the beginning of all <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> commands
    in this book. To run all your Docker commands as root automatically without using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>, check the Docker Engine
    documentation for instructions on adding your Linux user to the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    group; however, keep in mind that doing so decreases your computer’s security
    and isn’t recommended.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上运行Docker Engine需要root权限。完成此练习后，如果您使用的是Linux，请在本书中所有的<samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>命令前添加<samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>。要使所有Docker命令都自动以root身份运行而无需使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>，请查阅Docker Engine文档，了解如何将Linux用户添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>组中；但请注意，这样做会降低计算机的安全性，不建议这么做。
- en: 'Once Docker is installed, open a terminal and run:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker后，打开终端并运行：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command runs a Docker container image called <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>.
    If you don’t already have the <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    image on your computer, Docker downloads it first. The output should look something
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令运行一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    的Docker容器镜像。如果你的计算机上还没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp>
    镜像，Docker将首先下载它。输出结果应该类似于以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp> container
    ran successfully, you can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    command on your computer. Next, run the following command to install the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> package, which will
    give you access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp>
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">hello-world</samp> 容器成功运行，你现在可以在计算机上使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> 命令。接下来，运行以下命令来安装 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> 包，这将使你能够使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose</samp> 命令：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your computer is now ready to run Linux containers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机现在已经准备好运行Linux容器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Running Containers with Docker</samp>
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用Docker运行容器</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command you’ve
    just installed allows you to run Linux containers on your computer. In this section
    you’ll learn how to use this command to open a shell inside containers, force
    running containers to quit, mount volumes to save persistent data or access certain
    files, set environment variables, and publish ports so your computer can connect
    to network services inside your container. This foundational understanding of
    Docker will prepare you to run Docker containers in Exercise 5-3 and help you
    troubleshoot any problems you later encounter with Aleph.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚安装的 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> 命令允许你在计算机上运行Linux容器。在本节中，你将学习如何使用这个命令在容器内打开Shell、强制运行中的容器退出、挂载卷以保存持久数据或访问特定文件、设置环境变量，以及发布端口，使你的计算机能够连接到容器内的网络服务。对Docker的这一基础理解将帮助你在第5-3章运行Docker容器，并帮助你排查以后与Aleph相关的任何问题。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*For additional information on Docker commands, run* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">docker
    help</samp> *or check the documentation at* [https://docs.docker.com](https://docs.docker.com)*.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关Docker命令的更多信息，请运行* <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">docker
    help</samp> *或查看文档* [https://docs.docker.com](https://docs.docker.com)*。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running an Ubuntu
    Container</samp>
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行Ubuntu容器</samp>
- en: You’ll begin by learning how to run a Linux container with the Ubuntu operating
    system in it. People often base more complicated container images on the Ubuntu
    container image to access all Ubuntu software that apt can install. An Ubuntu
    container is also a convenient way to access a shell on a clean Ubuntu system,
    allowing you to install software or test programs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从学习如何运行一个包含Ubuntu操作系统的Linux容器开始。人们通常在Ubuntu容器镜像的基础上构建更复杂的容器镜像，以便访问apt可以安装的所有Ubuntu软件。Ubuntu容器也是一种方便的方式来访问一个干净的Ubuntu系统上的Shell，允许你安装软件或测试程序。
- en: 'Docker commands use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">command</samp> syntax.
    Run the following to start your own Ubuntu container (if you’re using Linux, remember
    to add <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">命令</samp> 语法。运行以下命令来启动你自己的Ubuntu容器（如果你使用的是Linux，请记得加上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sudo</samp>）：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command runs <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>,
    the latest version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu</samp>
    image. If that image isn’t already on your computer, Docker automatically downloads
    it from Docker Hub, a library of public container images at [*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com).
    Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp> command runs,
    giving you shell access inside that container. Include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    argument, which is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>) and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-t</samp> (or <samp class="SANS_TheSansMonoCd_W5Regular_11">--tty</samp>),
    after <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> whenever
    you plan to open a shell in a container, so that any commands you type in the
    terminal run in the container. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>
    argument, the bash shell would immediately quit before you could run any commands,
    as would the container.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行<samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>，即最新版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ubuntu</samp>镜像。如果该镜像尚未存在于你的计算机中，Docker会自动从Docker
    Hub下载该镜像，Docker Hub是一个公开容器镜像库，网址是[*https://<wbr>hub<wbr>.docker<wbr>.com*](https://hub.docker.com)。接下来，运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>命令，为你提供容器内部的shell访问权限。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp>后加上<samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>参数，它是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-i</samp>（或<samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-t</samp>（或<samp class="SANS_TheSansMonoCd_W5Regular_11">--tty</samp>）的缩写，当你计划在容器内打开shell时使用该参数，这样你在终端中输入的任何命令都会在容器内运行。如果没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-it</samp>参数，bash shell会在你运行任何命令之前立刻退出，容器也会退出。
- en: 'This command gives me the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令给我以下输出：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since I didn’t already have the <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>
    image, the command downloaded that image, started the container, and dropped me
    into a bash shell. I can now run whatever commands I want inside this container,
    such as installing software or running programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我之前没有安装<samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>镜像，命令下载了该镜像，启动了容器，并进入了bash
    shell。我现在可以在这个容器内运行任何命令，例如安装软件或运行程序。
- en: 'Running the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> command
    quits the container. If you start a new <samp class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>
    container, it contains none of the old container’s data. For example, with the
    following commands, I create a file called *test.txt* in one container, quit the
    container, and start a new one:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行<samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>命令退出容器。如果你启动一个新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ubuntu:latest</samp>容器，它将不包含旧容器的任何数据。例如，使用以下命令，我在一个容器中创建了一个名为*test.txt*的文件，然后退出了该容器，接着启动了一个新的容器：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output shows that *test.txt* no longer exists. For data in a container to
    persist when you rerun the container image, you need to use volumes, as we’ll
    discuss in “Mounting and Removing Volumes” on page 125.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示*test.txt*文件不再存在。为了让容器中的数据在重新运行容器镜像时得以保存，你需要使用卷，具体内容我们将在第125页的《挂载和移除卷》中讨论。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Listing and Killing
    Containers</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">列出和终止容器</samp>
- en: 'If you’ve exited your Ubuntu container, run a new one. With that container
    running in the background, open a second terminal window and run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    ps</samp> command. This should show you a list of all containers currently running.
    Here’s the output I get, for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经退出了Ubuntu容器，运行一个新的容器。该容器在后台运行时，打开第二个终端窗口，运行<samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    ps</samp>命令。这个命令将显示当前所有正在运行的容器列表。以下是我得到的输出示例：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you start a container with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp>, you can give it a name with the arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">your_container_name</samp>.
    Otherwise, it will be assigned a random name. The container in my <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    ps</samp> output is called <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp>.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> 启动一个容器时，你可以通过参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">your_container_name</samp>
    给它命名。否则，它将被分配一个随机名称。我的 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker ps</samp>
    输出中的容器名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp>。
- en: 'To *kill* a container, or force it to quit, you run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    kill</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name</samp>.
    For example, running the following command in my other terminal window quits my
    <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp> container:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要*杀死*一个容器，或者强制它退出，你可以运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    kill</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name</samp>。例如，在我的另一个终端窗口中运行以下命令可以退出我的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">epic_borg</samp> 容器：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run this command for your own container. If you switch back to your other terminal
    window, the container should have quit, and you should be back in your normal
    shell.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的容器运行这个命令。如果你切换回另一个终端窗口，容器应该已经退出，并且你应该回到正常的 shell 中。
- en: 'When you exit a container, Docker still keeps track of it, allowing you to
    restart it if you want. To see all of the containers Docker is tracking, including
    ones that aren’t running anymore, you run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    ps -a</samp> (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--all</samp>).
    Here’s the output I get when I run this command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你退出一个容器时，Docker 仍然会追踪它，允许你在需要时重新启动它。要查看 Docker 追踪的所有容器，包括那些已经不再运行的容器，你可以运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker ps -a</samp>（即 <samp class="SANS_TheSansMonoCd_W5Regular_11">--all</samp>
    的简写）。以下是我运行此命令时的输出：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s good practice to run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    rm</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">container_name</samp>
    to prune your stopped Docker containers when you’re done using them. For example,
    I’d run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker rm nostalgic_keldysh</samp>
    to remove my <samp class="SANS_TheSansMonoCd_W5Regular_11">nostalgic_keldysh</samp>
    container.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker rm</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">container_name</samp>
    来修剪你停止的 Docker 容器是一种好习惯，当你完成使用它们时。举个例子，我会运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    rm nostalgic_keldysh</samp> 来删除我的 <samp class="SANS_TheSansMonoCd_W5Regular_11">nostalgic_keldysh</samp>
    容器。
- en: 'You can run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp>
    to remove all stopped containers at once. When I ran this command, I saw the following
    output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp>
    来一次性删除所有停止的容器。当我运行这个命令时，我看到了以下输出：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I entered <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> and got the
    following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> 并得到了以下输出：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This displays the container ID, a long string of random-looking text, for each
    container that’s deleted. In my case, I deleted a single container.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这会显示每个已删除容器的容器 ID，一长串看起来随机的文本。在我的例子中，我删除了一个容器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mounting and Removing
    Volumes</samp>
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">挂载和移除卷</samp>
- en: Containers support *volumes*, which you can think of as folders in your container
    designed to store persistent data. You can use volumes to save changes you’ve
    made to your container after you quit and remove it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持*卷*，你可以把它们看作是容器中的文件夹，用于存储持久化数据。你可以使用卷来保存你在退出并删除容器后所做的更改。
- en: For example, suppose you start a container without any volumes that runs the
    PostgreSQL database software. Any data you add to it is saved to the */var/lib/postgresql/data*
    folder inside your container. When you quit and remove the container, you’ll lose
    all of your data. If you instead *mount* a folder on your host operating system
    into */var/lib/postgresql/data* on the container, when software in the container
    accesses that folder, it’s actually accessing the folder on your host operating
    system. You’ll still have all of your data when the container closes and is removed,
    and you can start the container again in the future with the same data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你启动了一个没有任何卷的容器，并且运行 PostgreSQL 数据库软件。你添加到容器中的任何数据都会保存在容器内的*/var/lib/postgresql/data*文件夹中。当你退出并移除容器时，所有数据都会丢失。如果你将主机操作系统中的一个文件夹*挂载*到容器中的*/var/lib/postgresql/data*，那么当容器中的软件访问该文件夹时，实际上是在访问主机操作系统中的文件夹。容器关闭并移除后，你仍然可以保留所有数据，未来你可以使用相同的数据重新启动容器。
- en: 'Docker has two main types of volumes: *bind mounts*, or folders from your host
    machine mounted into a container, and normal Docker volumes, where Docker keeps
    track of your persistent folders without your having to provide a path on your
    host operating system. For example, if you want to store your database container’s
    data in the */Volumes/datasets/volumes/db-data* folder on your host filesystem,
    you would mount this folder as a bind mount. If you don’t need your data to be
    stored in a specific folder on your host, just use a normal volume, and Docker
    will keep track of where it’s stored.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 有两种主要的卷类型：*绑定挂载*，即将主机机器上的文件夹挂载到容器中，以及普通 Docker 卷，其中 Docker 会跟踪你的持久化文件夹，而你无需提供主机操作系统中的路径。例如，如果你想将数据库容器的数据存储在主机文件系统中的*/Volumes/datasets/volumes/db-data*文件夹中，你将把这个文件夹作为绑定挂载。如果你不需要将数据存储在主机上的特定文件夹中，只需使用普通卷，Docker
    会自动跟踪数据存储的位置。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*Storing volumes in a Linux VM with Docker Desktop makes them faster than bind
    mounts, but your VM might run out of disk space if your volumes get too big (if
    you index large datasets into Aleph, for example). In macOS, you can increase
    the amount of disk space available to your VM in the Docker Desktop preferences
    under the Resources tab. In Windows, your VM will use as much space on the* C:
    *drive as it needs, but again, this drive could run out of disk space if you’re
    dealing with large amounts of data. Alternatively, you could use bind mounts instead
    of volumes, storing data on external disks.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*将卷存储在带有 Docker Desktop 的 Linux 虚拟机中比绑定挂载更快，但如果你的卷变得太大（例如，如果你将大型数据集索引到 Aleph
    中），虚拟机可能会用完磁盘空间。在 macOS 中，你可以通过 Docker Desktop 偏好设置中的资源选项卡增加虚拟机可用的磁盘空间。在 Windows
    中，虚拟机会使用 C: 盘上需要的空间，但如果处理大量数据，该驱动器也可能会用完磁盘空间。另一种选择是使用绑定挂载，而不是卷，将数据存储在外部磁盘上。*'
- en: You can also use volumes to access data outside of a container while that container
    is running. In Exercise 5-5, you’ll bind-mount your *datasets* USB disk as a folder
    in an Aleph container. This way, your container can access the BlueLeaks dataset,
    allowing you to index it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在容器运行时使用卷来访问容器外部的数据。在练习 5-5 中，你将把你的*datasets* USB 磁盘绑定挂载为 Aleph 容器中的一个文件夹。这样，容器就可以访问
    BlueLeaks 数据集，从而进行索引。
- en: 'Use this command to start a container with a volume:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令启动带有卷的容器：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use this command to start a container with a bind mount:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令启动带有绑定挂载的容器：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp> argument tells
    Docker that you’re going to mount a volume and is followed by comma-separated
    details about that volume. The <samp class="SANS_TheSansMonoCd_W5Regular_11">type</samp>
    parameter specifies the type of mount: <samp class="SANS_TheSansMonoCd_W5Regular_11">volume</samp>
    for volumes and <samp class="SANS_TheSansMonoCd_W5Regular_11">bind</samp> for
    bind mounts. The <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> parameter
    specifies the source of the volume or bind mount. For volumes, its value is the
    volume name; for bind mounts, its value is the absolute path on your host filesystem
    to the folder you want to mount. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    parameter specifies the destination of the volume or bind mount, in both cases
    the absolute path of the folder inside the container to which you’re mounting.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp> 参数告诉 Docker 你将挂载一个卷，后面跟着有关该卷的以逗号分隔的详细信息。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">type</samp> 参数指定挂载类型：对于卷是 <samp class="SANS_TheSansMonoCd_W5Regular_11">volume</samp>，对于绑定挂载是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">bind</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>
    参数指定卷或绑定挂载的源。对于卷，它的值是卷名；对于绑定挂载，它的值是主机文件系统中你想挂载的文件夹的绝对路径。<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    参数指定卷或绑定挂载的目标，在两种情况下，它都是容器内你要挂载的文件夹的绝对路径。
- en: 'Let’s practice these two commands, starting with mounting a volume. Run the
    following code (your prompt will be different from mine):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习这两个命令，从挂载一个卷开始。运行以下代码（你的提示符与我的会有所不同）：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code starts an Ubuntu container and mounts a volume called <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp>
    into the */mnt* folder in the container. It then saves some data into the */mnt/test.txt*
    file and exits the container.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码启动一个 Ubuntu 容器，并将一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp>
    的卷挂载到容器中的 */mnt* 文件夹。然后，它将一些数据保存到 */mnt/test.txt* 文件中，并退出容器。
- en: 'Use the following commands to open a separate container, mounting the same
    volume into it to see whether your data is still there (again, your command prompt
    will be different):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打开一个单独的容器，将相同的卷挂载到其中，看看你的数据是否仍然存在（再次提醒，你的命令提示符会不同）：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, because you mounted */mnt* in the <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp>
    volume, the data persisted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于你在 <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp> 卷中挂载了
    */mnt*，数据得以持久化。
- en: 'To see a list of the volumes that Docker is managing, run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    volume ls</samp> command. You should get the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Docker 管理的卷列表，运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume
    ls</samp> 命令。你应该看到以下输出：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can remove volumes only from containers that have been completely removed
    from Docker. If you’ve just stopped a container but Docker is still tracking it,
    it won’t let you remove the volume. Completely remove all stopped containers by
    running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp>,
    which then allows you to remove any volumes attached to those containers. You
    should get the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能从已经完全从 Docker 中删除的容器中删除卷。如果你刚刚停止了一个容器，但 Docker 仍在跟踪它，它将不允许你删除该卷。通过运行 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">docker container prune</samp> 完全删除所有停止的容器，然后你可以删除附加到这些容器的任何卷。你应该看到以下输出：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp> to continue:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">y</samp> 继续：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can now run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">volume-name</samp> to remove
    any volumes attached to those containers, or run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker
    volume prune</samp> to delete all volumes that Docker containers aren’t currently
    using. Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm test-data</samp>
    to remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp> volume,
    then run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume ls</samp>
    command again. This time, you shouldn’t see any volumes listed in the output.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">volume-name</samp> 来删除附加到这些容器的任何卷，或者运行
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume prune</samp> 来删除 Docker
    容器当前未使用的所有卷。运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume rm test-data</samp>
    来删除 <samp class="SANS_TheSansMonoCd_W5Regular_11">test-data</samp> 卷，然后再次运行 <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">docker volume ls</samp> 命令。这次，你不应该在输出中看到任何列出的卷。
- en: Next, you’ll practice bind mounting by mounting the folder on your host system
    containing the BlueLeaks dataset into a container running Kali Linux. This Linux
    distribution is designed for *penetration testing*, in which people hack into
    systems with permission from the system owners to find and fix security flaws.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将通过将包含BlueLeaks数据集的文件夹挂载到运行Kali Linux的容器中来练习绑定挂载。这个Linux发行版专为*渗透测试*设计，在渗透测试中，人员在系统所有者的许可下进入系统，寻找并修复安全漏洞。
- en: 'If you’re a Mac or Linux user, run the following command, replacing the path
    with the appropriate path on your machine:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Mac或Linux用户，运行以下命令，并将路径替换为你计算机上的适当路径：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This should run a <samp class="SANS_TheSansMonoCd_W5Regular_11">kalilinux/kali-rolling</samp>
    container, mounting your *BlueLeaks-extracted* folder in it at the path */blueleaks*,
    and drop you into a bash shell.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行一个<samp class="SANS_TheSansMonoCd_W5Regular_11">kalilinux/kali-rolling</samp>容器，将你的*BlueLeaks-extracted*文件夹挂载到路径*/blueleaks*下，并进入bash终端。
- en: Windows users might have trouble bind-mounting a folder on the *datasets* USB
    disk into a container, because Docker Desktop for Windows runs Linux containers
    using WSL, and WSL doesn’t always have access to your USB disks. To avoid this
    problem, if you plugged in your USB disk after opening a WSL terminal or using
    Docker, restart WSL by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">wsl
    --shutdown</samp> in PowerShell. You should see a notification from Docker Desktop
    asking if you want to restart it. Click **Restart**. After you restart WSL with
    the USB disk already plugged in, Docker should be able to mount it. (See Appendix
    A for more information.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户在将*datasets* USB磁盘的文件夹绑定挂载到容器时，可能会遇到问题，因为Windows版Docker Desktop使用WSL运行Linux容器，而WSL并不总是能够访问你的USB磁盘。为避免此问题，如果你在打开WSL终端或使用Docker后插入了USB磁盘，请通过在PowerShell中运行<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">wsl --shutdown</samp>来重启WSL。你应该会看到来自Docker
    Desktop的通知，询问是否要重新启动它。点击**重启**。在重启WSL并确保USB磁盘已插入后，Docker应该能够挂载它。（有关更多信息，请参见附录A。）
- en: 'If you’re using Windows with PowerShell to work through this chapter, run the
    following command to mount the folder that contains the BlueLeaks data into */datasets*,
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">D:/BlueLeaks-extracted</samp>
    with the appropriate path:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上使用PowerShell进行此章节操作，运行以下命令将包含BlueLeaks数据的文件夹挂载到*/datasets*，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">D:/BlueLeaks-extracted</samp>替换为适当的路径：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you’re using Ubuntu with WSL in Windows, mount the *BlueLeaks* folder by
    accessing the *D:* drive from */mnt/d* with the following syntax:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上使用WSL的Ubuntu，可以通过以下语法从*/mnt/d*访问*D:*驱动器来挂载*BlueLeaks*文件夹：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From within your Kali container, you can now use the tools that come with Kali
    on the BlueLeaks dataset. By default, Kali customizes your bash shell to look
    slightly different than Ubuntu does. The prompt will look something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kali容器内，你可以使用Kali附带的工具对BlueLeaks数据集进行处理。默认情况下，Kali会定制你的bash终端，使其与Ubuntu稍有不同。终端提示符大致是这样的：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Docker containers are assigned random hostnames. In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>
    is the name of the current user, <samp class="SANS_TheSansMonoCd_W5Regular_11">6a36e316663c</samp>
    is the hostname of the computer, and <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>
    is the current working directory. From here, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls
    /blueleaks/</samp> to list the files in the *BlueLeaks* folder:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器会被分配随机的主机名。在本例中，<samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>是当前用户的名称，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">6a36e316663c</samp>是计算机的主机名，<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>是当前工作目录。从这里开始，运行<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">ls /blueleaks/</samp>来列出*BlueLeaks*文件夹中的文件：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can learn more about volumes and bind mounts at* [https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/storage<wbr>/](https://docs.docker.com/storage/).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过以下链接了解更多关于卷和绑定挂载的信息* [https://<wbr>docs<wbr>.docker<wbr>.com<wbr>/storage<wbr>/](https://docs.docker.com/storage/)。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing Environment
    Variables</samp>
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">传递环境变量</samp>
- en: You can also use environment variables, introduced in [Chapter 4](chapter4.xhtml),
    to pass sensitive information like database credentials into containers. When
    starting up a container, you pass an environment variable into it using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-e</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>
    (the <samp class="SANS_TheSansMonoCd_W5Regular_11">-e</samp> is short for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">--env</samp>) arguments. Programs in the
    container can then access the value of that variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用在[第 4 章](chapter4.xhtml)中介绍的环境变量，将敏感信息（如数据库凭证）传递到容器中。在启动容器时，你可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-e</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">value</samp>（其中
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-e</samp> 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">--env</samp>
    的简写）来传递环境变量。容器中的程序可以访问该变量的值。
- en: 'For example, run the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行以下命令：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This starts an Ubuntu container with the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_USER</samp>
    set to <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp> and the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_PASSWORD</samp> set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">yourefired</samp>. From inside the container,
    try displaying the values of those variables to confirm that you can access this
    information there, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">echo
    $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>
    command like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个 Ubuntu 容器，其中变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_USER</samp>
    被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">root</samp>，变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">DB_PASSWORD</samp>
    被设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">yourefired</samp>。在容器内，尝试使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">echo $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">variable_name</samp>
    命令来显示这些变量的值，以确认你可以在容器内访问这些信息。
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll practice passing environment variables to containers further in Exercise
    5-3.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在练习 5-3 中进一步练习如何向容器传递环境变量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running Server Software</samp>
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行服务器软件</samp>
- en: You can also run robust, fully configured software on the operating systems
    running in containers. This technique is mostly used to access *server software*,
    software to which you can connect over a network using web browsers, database
    clients, or other similar programs. You’ll need this skill for Exercise 5-3 and,
    eventually, to run Aleph.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在运行在容器中的操作系统上运行强大的、完全配置的软件。这项技术主要用于访问 *服务器软件*，即可以通过网络使用网页浏览器、数据库客户端或其他类似程序连接的软件。你将在练习
    5-3 中需要用到这项技能，最终你也会用它来运行 Aleph。
- en: Different computers (or VMs, or containers), called *hosts*, are identified
    by IP addresses or hostnames. Your own computer’s IP address is always 127.0.0.1,
    and its hostname is always *localhost*. Hosts can listen on different ports for
    incoming network connections, meaning the host is available for other hosts to
    connect to over a network. A *port* is a number that the computer uses to sort
    out which network traffic should go to which application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的计算机（或虚拟机、或容器），被称为 *主机*，通过 IP 地址或主机名来标识。你自己计算机的 IP 地址总是 127.0.0.1，它的主机名总是
    *localhost*。主机可以在不同的端口上监听传入的网络连接，这意味着主机可以为其他主机提供网络连接。*端口* 是一个数字，计算机通过它来区分哪些网络流量应该发送到哪个应用程序。
- en: Different services have different default ports. For example, HTTP and HTTPS
    services are two types of websites that use port 80 and port 443, respectively.
    When you load the URL *http://<wbr>example<wbr>.com* in your browser, it will
    try to connect to the host *example.com* on port 80 using HTTP. If you load *https://<wbr>example<wbr>.com*,
    it will try to connect on port 443 using HTTPS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的服务有不同的默认端口。例如，HTTP 和 HTTPS 服务分别使用端口 80 和端口 443。当你在浏览器中加载 URL *http://<wbr>example<wbr>.com*
    时，它会尝试使用 HTTP 协议通过端口 80 连接到主机 *example.com*。如果你加载 *https://<wbr>example<wbr>.com*，它会尝试通过端口
    443 使用 HTTPS 协议连接。
- en: However, you can change the default ports that services use. If you’re running
    an HTTP service on *localhost* on port 5000, the URL for that service would be
    *http://<wbr>localhost:5000*, where *http://<wbr>* means you’re using the HTTP
    protocol, *localhost* means you’re connecting to the *localhost* host, and *:5000*
    means you’re connecting to port 5000 instead of the default HTTP port, 80.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以更改服务使用的默认端口。如果你在 *localhost* 上的 5000 端口运行 HTTP 服务，则该服务的 URL 是 *http://<wbr>localhost:5000*，其中
    *http://<wbr>* 表示你使用 HTTP 协议，*localhost* 表示你连接到 *localhost* 主机，而 *:5000* 表示你连接到
    5000 端口，而不是默认的 HTTP 端口 80。
- en: To connect to a network port inside your Docker container, you must *publish*
    a network port when you run your container, making that port available on the
    host operating system. To do so, use the arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp> (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish</samp>).
    Once the container starts up, your host operating system will listen on <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp>. If you connect
    to that port, your connection will be forwarded to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>
    inside the container.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 Docker 容器内部的网络端口，必须在运行容器时*发布*一个网络端口，使该端口在宿主操作系统上可用。为此，使用参数 <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>（<samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish</samp> 的缩写）。一旦容器启动，宿主操作系统会在
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp> 上监听。如果你连接到该端口，连接会被转发到容器内部的
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>。
- en: 'Let’s look at an example of running server software and publishing a port so
    that you can connect to it from your host computer. Run the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个运行服务器软件并发布端口的示例，这样你就可以从宿主计算机连接到它。运行以下命令：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command should download and run the latest version of the *jupyter/scipy-notebook*
    container image, which includes the most popular science-related Python libraries.
    (Jupyter Notebook is a powerful data science tool for creating and sharing computational
    documents.) Jupyter Notebook starts an HTTP service on port 8888 in the container.
    The arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">-p 8000:8888</samp>
    mean that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">8000</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">8888</samp>. If you connect to
    *localhost* on port 8000, using either the URL *http://<wbr>localhost:8000* or
    *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*, you’ll now actually connect to port
    8888 inside the container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该会下载并运行最新版本的 *jupyter/scipy-notebook* 容器镜像，其中包含了最流行的与科学相关的 Python 库。（Jupyter
    Notebook 是一个强大的数据科学工具，用于创建和共享计算文档。）Jupyter Notebook 会在容器的 8888 端口启动一个 HTTP 服务。参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-p 8000:8888</samp> 意味着 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">host_port</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">8000</samp>，而 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_port</samp>
    是 <samp class="SANS_TheSansMonoCd_W5Regular_11">8888</samp>。如果你连接到 *localhost*
    的 8000 端口，使用 URL *http://<wbr>localhost:8000* 或 *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*，你实际上会连接到容器内部的
    8888 端口。
- en: 'Here’s the output from the previous command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前一个命令的输出：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output shows that this command downloaded the latest version of the *jupyter/scipy-notebook*
    container image from Docker Hub and then ran it. This time, instead of starting
    a shell in the container, the container runs only the service it was designed
    for, which is Jupyter Notebook. Each time Jupyter Notebook outputs a log message,
    the terminal window now displays it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示该命令从 Docker Hub 下载了最新版本的 *jupyter/scipy-notebook* 容器镜像，并且运行了它。这一次，容器没有启动
    shell，而是仅运行了为其设计的服务，即 Jupyter Notebook。每当 Jupyter Notebook 输出日志信息时，终端窗口都会显示它。
- en: The end of the output shows three different URLs to access the server. Copy
    the final URL, paste it in your browser, and change the port number from 8888
    to 8000 before you load it. When you connect to your own computer on port 8000
    (127.0.0.1:8000), your connection will be forwarded to the container on port 8888\.
    Your browser should load the Jupyter Notebook service running in your container.
    When this happens, you should see more log messages appear in the terminal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的末尾显示了访问服务器的三个不同 URL。复制最后一个 URL，将其粘贴到浏览器中，并将端口号从 8888 更改为 8000 后加载。当您在端口 8000（127.0.0.1:8000）连接到自己的计算机时，您的连接将被转发到容器的
    8888 端口。您的浏览器应该加载在容器中运行的 Jupyter Notebook 服务。当发生这种情况时，您应该看到终端中出现更多日志消息。
- en: '[Figure 5-1](#fig5-1) shows a web browser running on my Mac, connected to a
    Jupyter Notebook server, which is running in my Linux container.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](#fig5-1) 显示了我在 Mac 上运行的 Web 浏览器，连接到一个运行在我的 Linux 容器中的 Jupyter Notebook
    服务器。'
- en: '![A screenshot of a web browser loading Jupyter Notebook running in a container.
    The open document shows a snippet of Python code that was run.](Images/Figure5-1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器加载容器中运行的 Jupyter Notebook 的屏幕截图。打开的文档显示了已运行的 Python 代码片段。](Images/Figure5-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Jupyter Notebook
    running in a container</samp>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-1：在容器中运行的 Jupyter Notebook</samp>
- en: The container keeps running until you press CTRL-C to quit it. If you need to
    run any other terminal commands while the container is still running, you’ll need
    to open a separate terminal window. For now, press CTRL-C in your terminal to
    exit the Jupyter Notebook container.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 容器会一直运行，直到您按 CTRL-C 退出。如果在容器仍在运行时需要运行其他终端命令，您需要打开一个独立的终端窗口。现在，在终端中按 CTRL-C 退出
    Jupyter Notebook 容器。
- en: You won’t use Jupyter Notebook further in this book, but you’ll rely on your
    new understanding of running server software to run a WordPress website in Exercise
    5-3.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中不会再使用 Jupyter Notebook，但您将依靠自己对运行服务器软件的新理解来在练习 5-3 中运行 WordPress 网站。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*For more information about Jupyter Notebook, visit* [https://jupyter.org](https://jupyter.org)*,*
    *and for thorough documentation on running Jupyter Notebook in Docker, see* [https://jupyter-docker-stacks.readthedocs.io](https://jupyter-docker-stacks.readthedocs.io)*.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 Jupyter Notebook 的更多信息，请访问* [https://jupyter.org](https://jupyter.org)*，*
    *要查看有关在 Docker 中运行 Jupyter Notebook 的详细文档，请参阅* [https://jupyter-docker-stacks.readthedocs.io](https://jupyter-docker-stacks.readthedocs.io)*。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Freeing Up Disk Space</samp>
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">释放磁盘空间</samp>
- en: 'Docker images take up a lot of disk space. To free up space quickly, use the
    following command to delete all of the container images you’ve downloaded from
    Docker Hub and other data that Docker stores (besides volumes):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像占用大量磁盘空间。要快速释放空间，请使用以下命令删除您从 Docker Hub 下载的所有容器镜像以及 Docker 存储的其他数据（除了卷之外）：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since this command doesn’t delete volumes, it won’t delete any of your important
    data. The next time you use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> commands, you’ll just redownload the container images you need from
    Docker Hub.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此命令不会删除卷，它不会删除您的任何重要数据。下次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> 命令时，您只需从 Docker Hub 重新下载所需的容器镜像。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-3: Run a WordPress Site
    with</samp> <samp class="SANS_Futura_Std_Heavy_B_21">Docker Compose</samp>'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习 5-3：使用</samp> <samp class="SANS_Futura_Std_Heavy_B_21">Docker
    Compose 运行 WordPress 网站</samp>
- en: More complicated software like Aleph requires running multiple containers that
    interact with each other. To do that, you’ll need to learn to use Docker Compose,
    as the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command’s
    arguments quickly become hard to keep track of when used to run more complicated
    containers—those with volumes, environment variables, publishing ports, and so
    on. It’s especially unwieldy to run a single application that requires multiple
    containers at once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的软件，如 Aleph，需要运行多个相互交互的容器。为此，您需要学习使用 Docker Compose，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    run</samp> 命令的参数在运行更复杂的容器时会变得很难追踪——这些容器可能有卷、环境变量、发布端口等等。运行需要多个容器的单一应用程序尤其麻烦。
- en: Docker Compose makes it easier to define and run such Docker applications. The
    tool allows you to configure your containers (choosing images, volumes, environment
    variables, published ports, and so on) in a single file, and to start and stop
    all of your containers with a single command. I often use Docker Compose even
    for software that requires a single container, because it simplifies keeping track
    of all of the configuration. You’ll need to be proficient in Docker Compose to
    run an Aleph server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 使得定义和运行此类 Docker 应用程序变得更容易。该工具允许你在一个文件中配置容器（选择镜像、卷、环境变量、发布端口等），并通过一个命令启动和停止所有容器。我经常使用
    Docker Compose，即使是仅需要一个容器的软件，因为它简化了所有配置的跟踪。要运行 Aleph 服务器，你需要熟练使用 Docker Compose。
- en: In this exercise, you’ll familiarize yourself with Docker Compose by using it
    to run WordPress. You won’t need WordPress for the remainder of this book, but
    here it serves as an example to prepare you for using Docker Compose with Aleph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，你将通过使用 Docker Compose 来运行 WordPress，从而熟悉 Docker Compose。虽然在本书的其余部分你不需要使用
    WordPress，但它作为一个示例将帮助你为使用 Docker Compose 运行 Aleph 做准备。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Make a docker-compose.yaml
    File</samp>
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建一个docker-compose.yaml文件</samp>
- en: The YAML file format ([*https://<wbr>yaml<wbr>.org*](https://yaml.org)) is popular
    among programmers for storing configuration files because it’s relatively human-readable.
    YAML files have either a *.yml* or *.yaml* file extension. Docker Compose defines
    containers and their settings in a file called *docker-compose.yaml*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件格式（[*https://<wbr>yaml<wbr>.org*](https://yaml.org)）因其相对人类可读的特点而广泛受到程序员的喜爱，用于存储配置文件。YAML
    文件的扩展名为*.yml*或*.yaml*。Docker Compose 在名为*docker-compose.yaml*的文件中定义容器及其设置。
- en: 'Open a terminal and change to your *exercises* folder. Make a new folder called
    *wordpress* for this exercise and then, using your text editor, make a file in
    that folder called *docker-compose.yaml*. Enter the following code into *that*
    file (or copy and paste it from [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-5<wbr>/wordpress<wbr>/docker<wbr>-compose<wbr>.yaml*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-5/wordpress/docker-compose.yaml)):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并切换到你的*exercises*文件夹。为本次练习创建一个名为*wordpress*的新文件夹，然后使用文本编辑器，在该文件夹中创建一个名为*docker-compose.yaml*的文件。在*该*文件中输入以下代码（或从[*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-5<wbr>/wordpress<wbr>/docker<wbr>-compose<wbr>.yaml*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-5/wordpress/docker-compose.yaml)复制并粘贴）：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: YAML files are whitespace sensitive, meaning that indentations affect the meaning
    of the code. This file defines two containers named <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>. For each container,
    it defines which container image to use, what volumes to mount, which ports to
    publish (in the case of the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container), which environment variables to set, and other settings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件对空白字符敏感，这意味着缩进会影响代码的含义。此文件定义了两个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">db</samp>的容器。对于每个容器，它定义了使用哪个容器镜像、挂载哪些卷、发布哪些端口（对于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>容器）、设置哪些环境变量以及其他设置。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp> container
    uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress:latest</samp>
    image to create an instance of the WordPress web application. The <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    container uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">mariadb:10.9</samp>
    container image to create an instance of a MySQL database server. (MySQL is a
    popular data management system that you’ll learn more about in [Chapter 12](chapter12.xhtml).)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>容器使用<samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress:latest</samp>镜像来创建一个
    WordPress 网站应用实例。<samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>容器使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mariadb:10.9</samp>容器镜像来创建一个 MySQL 数据库服务器实例。（MySQL
    是一个流行的数据管理系统，你将在[第12章](chapter12.xhtml)中了解更多。）
- en: Because these two containers are defined in the same *docker-compose.yaml* file,
    by default they’re part of the same Docker network so that they can communicate
    with each other. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container sets <samp class="SANS_TheSansMonoCd_W5Regular_11">WORDPRESS_DB_HOST</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>, the name of the other
    container, because it connects to that hostname. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    environment variables ❶ also match the <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    environment variables ❷. If these database credentials aren’t the same, WordPress
    gets a “permission denied” error when trying to connect to the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个容器在同一个 *docker-compose.yaml* 文件中定义，默认情况下它们属于同一个 Docker 网络，因此可以互相通信。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp> 容器将 <samp class="SANS_TheSansMonoCd_W5Regular_11">WORDPRESS_DB_HOST</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>，即另一个容器的名称，因为它连接到该主机名。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp> 的环境变量❶也与 <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    的环境变量❷匹配。如果这些数据库凭证不相同，WordPress 在尝试连接数据库时会收到“权限拒绝”错误。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The WordPress* docker-compose.yaml *file in this example is a slightly modified
    version of a sample file in the Docker documentation at* [https://docs.docker.com/samples/wordpress/](https://docs.docker.com/samples/wordpress/)*.*
    *See the documentation for a more thorough description of how to use Docker Compose.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*本示例中的 WordPress* docker-compose.yaml *文件是 Docker 文档中示例文件的稍作修改版本，详情请参见* [https://docs.docker.com/samples/wordpress/](https://docs.docker.com/samples/wordpress/)*.*
    *有关如何使用 Docker Compose 的更详细说明，请参见文档。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Start Your WordPress
    Site</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">启动你的 WordPress 网站</samp>
- en: 'In your terminal, change to the folder you created for this exercise and run
    the following command to start both containers at the same time:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，切换到你为本次练习创建的文件夹，然后运行以下命令同时启动两个容器：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first time you run it, Docker should download the <samp class="SANS_TheSansMonoCd_W5Regular_11">mariadb:10.9</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress:latest</samp> container
    images from Docker Hub. The command should then run a MySQL container and a web
    server container running WordPress, and you should see logs from both containers
    scroll by in your terminal. Logs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    container start with <samp class="SANS_TheSansMonoCd_W5Regular_11">db_1</samp>,
    while logs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container start with <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress_1</samp>.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行时，Docker 应该会从 Docker Hub 下载 <samp class="SANS_TheSansMonoCd_W5Regular_11">mariadb:10.9</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress:latest</samp> 容器镜像。然后命令将启动一个
    MySQL 容器和一个运行 WordPress 的 Web 服务器容器，你应该能看到两个容器的日志在终端中滚动显示。<samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp>
    容器的日志以 <samp class="SANS_TheSansMonoCd_W5Regular_11">db_1</samp> 开头，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    容器的日志以 <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress_1</samp> 开头。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp> container doesn’t
    need to publish any ports for WordPress to connect to it, since both containers
    share a Docker network. However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container publishes ports 8000:80\. This means that loading *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*
    in your browser connects to your host operating system on port 8000 and loads
    the web server in the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container running on port 80.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">db</samp> 容器不需要公开任何端口，WordPress
    就可以连接到它，因为这两个容器共享同一个 Docker 网络。然而，<samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    容器公开了 8000:80 的端口。这意味着在浏览器中加载 *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000* 会连接到主机操作系统的
    8000 端口，并加载运行在 80 端口上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    容器中的 Web 服务器。
- en: Enter ***http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000*** in your browser, and you’re
    running WordPress! [Figure 5-2](#fig5-2) shows the WordPress installation process
    that appears when I load that URL on my Mac after selecting English as my language.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中输入***http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8000***，你就成功运行了 WordPress！[图
    5-2](#fig5-2) 显示了我在选择英语作为语言后，在我的 Mac 上加载该 URL 时出现的 WordPress 安装过程。
- en: '![A screenshot of a web browser loading WordPress running in a container. It
    shows the installation screen where the user sets a website title, a username,
    and a password.](Images/Figure5-2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![加载 WordPress 的网页浏览器截图，显示安装屏幕，用户在此设置网站标题、用户名和密码。](Images/Figure5-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: WordPress running
    in two containers with Docker Compose</samp>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-2：使用 Docker Compose 在两个容器中运行
    WordPress</samp>
- en: Fill out the form with your WordPress site’s title, a username, and a password,
    and then explore your new WordPress site.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单，输入您的 WordPress 网站标题、用户名和密码，然后开始探索您的新 WordPress 网站。
- en: 'To open a shell and run commands in an active container with Docker Compose,
    you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose exec</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name command</samp>
    syntax. For example, this is how you’d get a shell in the <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    container:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个 shell 并在 Docker Compose 的活动容器中运行命令，您需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    exec</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">container_name
    命令</samp> 语法。例如，以下是如何在 <samp class="SANS_TheSansMonoCd_W5Regular_11">wordpress</samp>
    容器中获得一个 shell：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose run</samp>
    starts a new container, <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    exec</samp> runs a command in an active container—a little like opening a new
    terminal window inside a running container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose run</samp> 启动一个新容器时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose exec</samp> 则在活动容器中运行一个命令——有点像在运行中的容器内打开一个新的终端窗口。
- en: Exit the shell when you are done. Back in the terminal running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker
    -compose up</samp>, press CTRL-C to shut down the containers. Now you’re ready
    to use your new Docker and Docker Compose skills to make your datasets searchable
    with Aleph.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后退出 shell。在运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    up</samp> 的终端中，按 CTRL-C 关闭容器。现在，您已经准备好使用新的 Docker 和 Docker Compose 技能，通过 Aleph
    使您的数据集可搜索。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introducing Aleph</samp>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">介绍 Aleph</samp>
- en: '*Truth cannot penetrate a closed mind. If all places in the universe are in
    the Aleph, then all stars, all lamps, all sources of light are in it, too.*'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*真理无法穿透封闭的心灵。如果宇宙中的所有地方都在阿莱夫中，那么所有的星星、所有的灯、所有的光源也都在其中。*'
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Jorge Luis Borges, “The Aleph”
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —豪尔赫·路易斯·博尔赫斯，《阿莱夫》
- en: The Organized Crime and Corruption Reporting Project (OCCRP), founded in 2006,
    has a history of publishing high-profile investigations into corruption, often
    leading to criminal investigations, arrests, and seizure of stolen funds. In partnership
    with dozens of newsrooms around the world, the group relies on large datasets
    for its investigations. For example, OCCRP, along with the International Consortium
    of Investigative Journalists (ICIJ), was part of a coalition investigating the
    Panama Papers, an offshore tax haven dataset that led to over 40 stories about
    corruption. One of those stories implicated a close friend of Vladimir Putin who
    had embezzled $230 million from Russian taxpayers. Because OCCRP deals with so
    much data, it developed Aleph as an investigation tool to make it easier to track
    white-collar crime, follow the money, and cross-reference various datasets.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有组织犯罪和腐败报道项目（OCCRP），成立于2006年，历史上曾发布多起高调的腐败调查，通常导致刑事调查、逮捕和赃款的查扣。该组织与全球多个新闻机构合作，依靠大规模数据集进行调查。例如，OCCRP与国际调查记者联盟（ICIJ）共同组成联盟，调查了“巴拿马文件”这一离岸避税天堂数据集，揭露了超过40篇关于腐败的报道。其中一篇故事揭露了弗拉基米尔·普京的密友挪用了来自俄罗斯纳税人的2.3亿美元。由于OCCRP处理大量数据，它开发了Aleph作为调查工具，以便更轻松地追踪白领犯罪、追踪资金流动并交叉引用各种数据集。
- en: 'OCCRP runs an Aleph server available to the public at [*https://<wbr>data<wbr>.occrp<wbr>.org*](https://data.occrp.org).
    This server includes over 250 public datasets with documents from 139 different
    countries and territories. While there’s some overlap with datasets published
    by DDoSecrets, most public datasets in OCCRP’s Aleph server are different. Many
    of them are regularly updated datasets of public records: registries of company
    ownership around the world, lists of people and organizations facing international
    sanctions, and court records. These datasets might not seem exciting on their
    own, but when your investigation leads you to a specific person or company, they
    can be crucial for helping you fill in the gaps. OCCRP’s Aleph server also contains
    many more private datasets, which are available to journalists who apply for access.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: OCCRP运行一个向公众开放的Aleph服务器，网址为[*https://<wbr>data<wbr>.occrp<wbr>.org*](https://data.occrp.org)。该服务器包含超过250个公共数据集，涵盖来自139个不同国家和地区的文档。虽然与DDoSecrets发布的数据集有一些重叠，但OCCRP的Aleph服务器中的大多数公共数据集是不同的。许多数据集是定期更新的公共记录数据集：全球公司所有权注册、面临国际制裁的个人和组织名单以及法院记录。这些数据集单独看可能不那么吸引人，但当你的调查指向某个特定人物或公司时，它们对于填补空白至关重要。OCCRP的Aleph服务器还包含许多私有数据集，只有申请访问的记者才能使用。
- en: Take some time to check out OCCRP’s Aleph server, explore which public datasets
    are available, and make some searches. For example, if you search for Rudy Giuliani
    (Donald Trump’s confidant and former lawyer, and the former mayor of New York
    City) and filter by the US Federal Courts Archive dataset, you’ll find a series
    of court documents that reference Giuliani.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间查看OCCRP的Aleph服务器，探索可用的公共数据集，并进行一些搜索。例如，如果你搜索Rudy Giuliani（唐纳德·特朗普的密友和前律师，以及纽约市前市长），并按美国联邦法院档案数据集进行筛选，你将找到一系列涉及Giuliani的法院文件。
- en: 'You can upload your own datasets to OCCRP’s Aleph server only if OCCRP makes
    an account for you. Even if you do have an account, you won’t be able to upload
    medium- or high-security datasets without sharing this data with a third party:
    OCCRP. That’s why I help run a private Aleph server for The Intercept. You won’t
    use OCCRP’s public Aleph server further in this book. Instead, in Exercise 5-4,
    you’ll run a small Aleph server and bring up Aleph containers on your own laptop.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在OCCRP为你创建账户后，才能将自己的数据集上传到OCCRP的Aleph服务器。即使你有账户，没有与第三方OCCRP共享数据的情况下，你也无法上传中高安全级别的数据集。这就是为什么我帮助为The
    Intercept运行一个私有Aleph服务器的原因。本书后面你不会再使用OCCRP的公共Aleph服务器，而是会在练习5-4中，在自己的笔记本电脑上运行一个小型的Aleph服务器，并启动Aleph容器。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-4: Run Aleph Locally in
    Linux Containers</samp>'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习5-4：在Linux容器中本地运行Aleph</samp>
- en: This exercise prepares you to run your own server directly on your computer
    with Docker Compose. Instead of accessing Aleph at [*https://<wbr>data<wbr>.occrp<wbr>.org*](https://data.occrp.org),
    you’ll bring up your Aleph containers and access your private server at *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8080*.
    You’ll use Docker Compose to run the many different services Aleph requires on
    your computer with a single command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习将帮助你直接在自己的计算机上使用Docker Compose运行服务器。你将不再通过[*https://<wbr>data<wbr>.occrp<wbr>.org*](https://data.occrp.org)访问Aleph，而是在*http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8080*上访问自己的私有服务器。你将使用Docker
    Compose通过一个命令在计算机上运行Aleph所需的多个不同服务。
- en: Make a new folder called *aleph* to use for this exercise and the next. Save
    a copy of *docker-compose.yml* and *aleph.env.tmpl* from Aleph’s git repo, located
    at [*https://<wbr>github<wbr>.com<wbr>/alephdata<wbr>/aleph*](https://github.com/alephdata/aleph),
    into the *aleph* folder.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*aleph*的新文件夹，用于本练习以及接下来的练习。从Aleph的Git仓库中保存一份*docker-compose.yml*和*aleph.env.tmpl*文件，位置为[*https://<wbr>github<wbr>.com<wbr>/alephdata<wbr>/aleph*](https://github.com/alephdata/aleph)，并将其保存到*aleph*文件夹中。
- en: 'The *docker-compose.yml* file describes the nine containers that Aleph requires
    and all of their configuration, including the volumes that will save the indexed
    versions of your datasets. One of these containers, called <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>,
    includes a bind mount that maps your home folder (*~*) on your host filesystem
    to */host* in the container:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*docker-compose.yml*文件描述了Aleph所需的九个容器及其所有配置，包括将保存索引版本数据集的卷。其中一个名为<samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>的容器包含一个绑定挂载，将你主机文件系统中的主目录(*~*)映射到容器中的*/host*：'
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In your copy of *docker-compose.yml*, delete this line or comment it out by
    prepending a hash mark (<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>)
    to make Aleph run faster and avoid giving the container access to your home folder.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 *docker-compose.yml* 文件中，删除这一行或通过在行首添加井号 (<samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>)
    来注释掉，以使 Aleph 运行更快并避免给容器访问你的主文件夹的权限。
- en: Now rename *aleph.env.tmpl* to *aleph.env*, and open that file in your text
    editor. This file contains the settings for your Aleph instance on different lines,
    in the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SETTING_NAME</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">setting_value</samp>,
    which you’ll need to modify in a few ways.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 *aleph.env.tmpl* 重命名为 *aleph.env*，并在文本编辑器中打开该文件。该文件包含你在不同设置下的 Aleph 实例设置，每行的格式为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SETTING_NAME</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">setting_value</samp>，你需要在几个地方进行修改。
- en: 'First, run the following command to generate a random value for <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SECRET_KEY</samp>
    (Windows users, run this in your Ubuntu terminal):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行以下命令为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SECRET_KEY</samp>
    生成一个随机值（Windows 用户请在你的 Ubuntu 终端中运行）：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Since you’re running Aleph on your computer instead of setting it up on a server
    for others to use, change <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    in *aleph.env* to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, which allows you
    to use Aleph without having to create an admin user for yourself. Save the file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你是在本地计算机上运行 Aleph，而不是将其设置在供其他人使用的服务器上，请将 *aleph.env* 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    设置为 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>，这样你就可以使用
    Aleph，而无需为自己创建一个管理员用户。保存文件。
- en: 'Aleph relies on many different services to run, including three databases:
    PostgreSQL, Redis, and Elasticsearch. Elasticsearch is designed to search large
    amounts of data for text strings. For it to operate quickly, it needs to hold
    lots of data in memory. Linux’s default memory management setting <samp class="SANS_TheSansMonoCd_W5Regular_11">vm.max_map_count</samp>
    is far too low for Elasticsearch to work properly. If you’re using Linux or Windows
    with WSL, run the following command to increase the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">vm.max_map_count</samp>:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph 依赖于多种不同的服务来运行，包括三个数据库：PostgreSQL、Redis 和 Elasticsearch。Elasticsearch 旨在搜索大量数据中的文本字符串。为了能够快速运行，它需要将大量数据保存在内存中。Linux
    的默认内存管理设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">vm.max_map_count</samp>
    对 Elasticsearch 来说太低，无法正常工作。如果你在使用 Linux 或 Windows（通过 WSL），请运行以下命令以增加 <samp class="SANS_TheSansMonoCd_W5Regular_11">vm.max_map_count</samp>
    的值：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you’re using macOS, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sysctl
    -w vm.max_map_count=262144</samp> inside of your Linux VM managed by Docker Desktop.
    To do this, run the following command to start a shell directly in your Linux
    VM:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 macOS，在由 Docker Desktop 管理的 Linux 虚拟机中运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sysctl
    -w vm.max_map_count=262144</samp>。为此，运行以下命令直接在你的 Linux 虚拟机中启动一个 shell：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once you’re in this shell, run this command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入该 shell，运行以下命令：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> to exit the Linux
    VM shell. Each time you restart Docker Desktop, this change is undone, so you’ll
    need to run these commands again to continue using Elasticsearch. (Refer to the
    “Increasing Elasticsearch Memory in Docker Desktop” box to speed up this process
    in the future.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> 退出 Linux 虚拟机 shell。每次重启
    Docker Desktop 后，这一更改都会被撤销，因此你需要再次运行这些命令才能继续使用 Elasticsearch。（参考“在 Docker Desktop
    中增加 Elasticsearch 内存”框以加速未来的这一过程。）
- en: 'Finally, for all operating systems, run the following command to start Aleph:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于所有操作系统，运行以下命令以启动 Aleph：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first time you run this command, you’ll download a few gigabytes of container
    images. Text will scroll past in the terminal while Aleph boots up; wait for it
    to stop.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行此命令时，你将下载几个 GB 的容器镜像。在 Aleph 启动时，终端会滚动显示文本；等待其停止。
- en: 'You also need to run an <samp class="SANS_TheSansMonoCd_W5Regular_11">upgrade</samp>
    command the first time you use Aleph and whenever you upgrade your version of
    it. Once Aleph finishes booting, open a second terminal, change to the *exercises*
    folder, and run:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在第一次使用 Aleph 时以及每次升级其版本时运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">upgrade</samp>
    命令。Aleph 启动完成后，打开第二个终端，切换到 *exercises* 文件夹并运行：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command initializes the databases that Aleph uses by running the command
    <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph upgrade</samp> inside the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp> container. Wait for
    this command to completely finish; you’ll know it’s done when the program stops
    displaying output and you end up back at your terminal’s command prompt.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令通过在 <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp> 容器中运行命令 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">aleph upgrade</samp> 来初始化 Aleph 使用的数据库。请等待此命令完全完成；当程序停止显示输出并返回到终端的命令提示符时，表示操作已完成。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*For more detailed documentation for Aleph, see* [https://docs.aleph.occrp.org](https://docs.aleph.occrp.org)*.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 Aleph 的更详细文档，请参见* [https://docs.aleph.occrp.org](https://docs.aleph.occrp.org)*.*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Aleph’s Web and Command Line Interfaces</samp>
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 Aleph 的网页和命令行界面</samp>
- en: 'Now that you have a local Aleph server, you can explore its two different interfaces:
    the web interface, which you’ll use to investigate datasets, and the CLI interface,
    which you’ll use to index new datasets or administer your Aleph server.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个本地的 Aleph 服务器，你可以探索其两种不同的接口：网页界面，你将用它来调查数据集；以及 CLI 界面，你将用它来索引新的数据集或管理你的
    Aleph 服务器。
- en: With your Aleph containers up, open *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8080<wbr>/*
    in a browser to see the web interface. For example, [Figure 5-3](#fig5-3) shows
    Aleph running in Docker containers on my Mac.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Aleph 容器后，在浏览器中打开 *http://<wbr>127<wbr>.0<wbr>.0<wbr>.1:8080<wbr>/* 查看网页界面。例如，[图
    5-3](#fig5-3) 展示了我在 Mac 上运行的 Aleph，托管在 Docker 容器中。
- en: '![A screenshot of Aleph loaded in a web browser, with link to “Search entities,”
    “Browse datasets,” “Start an investigation,” and “Create a search alert.”](Images/Figure5-3.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![一张截图，展示了在网页浏览器中加载的 Aleph，包含“搜索实体”，“浏览数据集”，“开始调查”和“创建搜索提醒”的链接](Images/Figure5-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: Aleph hosted in
    Docker containers</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-3：Aleph 托管在 Docker 容器中</samp>
- en: You’ll use this interface to search data you upload into Aleph. The search bar
    at the top allows you to search every dataset you’ve indexed in your Aleph server
    at once, and the slider icon just to the right of the search box lets you perform
    advanced searches.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用这个界面来搜索你上传到 Aleph 的数据。顶部的搜索框允许你一次性搜索你在 Aleph 服务器上索引的所有数据集，而搜索框右侧的滑块图标让你进行高级搜索。
- en: The Datasets and Investigations buttons at the top show you the datasets in
    Aleph; for now, both of those pages will be empty. In Aleph, datasets and investigations
    are both collections of documents, with different user interfaces for exploring
    each. A dataset should be static, while an investigation is a collection of documents
    that you might still be adding to.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的“数据集”和“调查”按钮会显示 Aleph 中的数据集；目前，这两页将是空的。在 Aleph 中，数据集和调查都是文档集合，只是它们有不同的用户界面来进行探索。数据集应该是静态的，而调查是你可能还在添加文档的集合。
- en: After performing a search in Aleph, you can optionally save your search query
    as an alert. This feature is useful only on servers that have multiple users and
    are configured to send email. In those cases, the server automatically searches
    any new data indexed into the server for all of a user’s saved alerts. If it gets
    a hit, it sends an email to the user. In the example, you set <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, so that feature
    doesn’t apply.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Aleph 中执行搜索后，你可以选择将搜索查询保存为提醒。此功能仅在具有多个用户并配置为发送电子邮件的服务器上有用。在这种情况下，服务器会自动搜索所有新索引到服务器的数据，并检查是否有用户保存的提醒。如果找到匹配项，它会向用户发送电子邮件。在这个例子中，你将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp> 设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，因此该功能不适用。
- en: In addition to the web-based user interface you just explored, designed for
    journalists and researchers, Aleph has a command line interface designed for running
    the Aleph server itself. You must use the command line interface for administrative
    tasks like creating Aleph users (if you aren’t using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>
    setting in future projects) or indexing folders of data, which you’ll do later
    in this chapter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你刚刚探索的、为记者和研究人员设计的基于网页的用户界面外，Aleph还有一个命令行界面，专为运行Aleph服务器本身设计。你必须使用命令行界面来执行管理任务，如创建Aleph用户（如果你在未来的项目中没有使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ALEPH_SINGLE_USER</samp>设置）或索引数据文件夹，这将在本章后面进行。
- en: 'To use the command line interface, run <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>
    inside the container called <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>
    to start an Aleph shell like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行界面，请在名为<samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>的容器内运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>，以启动Aleph shell，如下所示：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you first opened a shell in a container using Docker Compose, you used
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose exec</samp>, which
    executes a command in an already running container. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    run</samp> runs a new container in which to execute your command. The <samp class="SANS_TheSansMonoCd_W5Regular_11">--rm</samp>
    argument tells Docker to remove the container as soon as your command finishes
    running. In this case, your command is <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>,
    so you can run <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> in the
    bash shell to remove this temporary container.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次通过Docker Compose在容器中打开shell时，你使用了<samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    exec</samp>，它会在已运行的容器中执行命令。在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    run</samp>则运行一个新的容器来执行你的命令。<samp class="SANS_TheSansMonoCd_W5Regular_11">--rm</samp>参数告诉Docker在命令执行完后立即删除该容器。在这种情况下，你的命令是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>，所以你可以在bash shell中运行<samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>来删除这个临时容器。
- en: You can now use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>
    command. Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">aleph --help</samp>
    to see a list of all of the commands that Aleph supports. To learn more about
    a specific command, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--help</samp>
    on it. For example, to learn more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">crawldir</samp>
    command (which we’ll discuss in Exercise 5-5), you’d run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">aleph
    crawldir --help</samp>.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">aleph</samp>命令。运行<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">aleph --help</samp>来查看Aleph支持的所有命令列表。要了解更多关于某个特定命令的信息，可以在该命令上运行<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">--help</samp>。例如，要了解更多关于<samp class="SANS_TheSansMonoCd_W5Regular_11">crawldir</samp>命令的信息（我们将在练习5-5中讨论），你可以运行<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">aleph crawldir --help</samp>。
- en: Run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp> to quit the Aleph
    shell. Back in your other terminal window, press CTRL-C to shut down all the Aleph
    containers when you’re not using them. When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    up</samp> to start the containers again, all the data in Aleph—including any datasets
    that you’ve added to it—will still be there, because that data is stored in Docker
    volumes, making it persistent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行<samp class="SANS_TheSansMonoCd_W7Bold_B_11">exit</samp>以退出Aleph shell。在另一个终端窗口中，当你不再使用它们时，按CTRL-C以关闭所有Aleph容器。再次运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">docker-compose up</samp>启动容器时，Aleph中的所有数据——包括你添加的任何数据集——仍然存在，因为这些数据存储在Docker卷中，使其保持持久性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Indexing Data in Aleph</samp>
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">在Aleph中索引数据</samp>
- en: Adding data to Aleph is called *indexing*. By loading and processing every file
    in a dataset, Aleph allows you to extract useful information, which you can browse
    and search via its web-based user interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 向Aleph添加数据称为*索引*。通过加载和处理数据集中的每个文件，Aleph可以让你提取有用的信息，你可以通过其基于网页的用户界面浏览和搜索这些信息。
- en: 'Indexing works differently for different types of files:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在不同类型的文件中工作方式不同：
- en: '**Office documents and PDFs** Aleph extracts all of the searchable text from
    these documents and attempts to find anything that looks like a person’s name,
    a company name, or other types of data that Aleph calls *entities*. It also extracts
    any metadata it can find.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**办公文档和PDF** Aleph从这些文档中提取所有可搜索的文本，并尝试找到任何看起来像是人名、公司名或其他Aleph称为*实体*的数据。它还提取任何它能找到的元数据。'
- en: '**Email messages**#x2003;Aleph again extracts searchable text and entities.
    This time, the entities it finds are likely to include both names and email addresses,
    which it determines by checking the sender and recipient of each email. It also
    extracts email attachments and indexes those individually.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**电子邮件消息**#x2003;Aleph再次提取可搜索的文本和实体。这一次，它找到的实体可能包括姓名和电子邮件地址，这些是通过检查每封邮件的发件人和收件人来确定的。它还提取电子邮件附件，并单独索引这些附件。'
- en: '**Compressed files, such as ZIP files** Aleph decompresses these files, then
    indexes each file inside them individually, which can become as recursive as necessary.
    For example, a ZIP file might contain an email file with an attachment that contains
    another ZIP file, and so on.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩文件，如ZIP文件** Aleph 解压这些文件，然后逐个索引其中的每个文件，必要时可以递归处理。例如，一个ZIP文件可能包含一个带附件的电子邮件文件，而附件里又包含另一个ZIP文件，依此类推。'
- en: Indexing datasets can take hours, days, or weeks, depending on the size of the
    dataset and the computational resources available to your Aleph server. In Exercise
    5-5, you’ll index a single BlueLeaks folder called *icefishx*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数据集可能需要几个小时、几天或几周，具体取决于数据集的大小和Aleph服务器的计算资源。在练习5-5中，你将索引一个名为*icefishx*的BlueLeaks文件夹。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 5-5: Index a BlueLeaks Folder
    in Aleph</samp>'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习5-5：在Aleph中索引BlueLeaks文件夹</samp>
- en: The *icefishx* folder contains data from an American police intelligence network
    called Intelligence Communications Enterprise for Information Sharing and Exchange
    (ICEFISHX), a partnership between law enforcement in Minnesota, North Dakota,
    and South Dakota. I’ve selected this data because it covers the state where Minneapolis
    cop Derek Chauvin murdered George Floyd, sparking the 2020 Black Lives Matter
    uprising. Searching this dataset for *George Floyd* might reveal some interesting
    internal docs about police violence or the protests that it triggered.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*icefishx* 文件夹包含来自美国一个名为“情报通信企业信息共享与交换（ICEFISHX）”的警察情报网络的数据，这是明尼苏达州、北达科他州和南达科他州执法机构之间的合作。我选择了这些数据，因为它涉及到明尼阿波利斯警察德里克·肖文杀害乔治·弗洛伊德的案件，激起了2020年“黑人的命也是命”抗议活动。搜索此数据集中的*乔治·弗洛伊德*可能会揭示一些关于警察暴力或由此引发的抗议活动的有趣内部文件。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mount Your Datasets
    into the Aleph Shell</samp>
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将数据集挂载到Aleph Shell中</samp>
- en: 'If you don’t already have Aleph running, change to your *aleph* folder and
    enter the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有运行Aleph，请切换到你的*aleph*文件夹并输入以下命令：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Wait for Aleph to boot up.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 等待Aleph启动。
- en: 'In a separate terminal, start an Aleph shell. This time, however, bind-mount
    your *datasets* USB disk into the container, using the following command, substituting
    the correct path for your USB disk:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，启动Aleph shell。然而，这次，你需要使用以下命令将*datasets* USB磁盘绑定到容器中，并替换为你USB磁盘的正确路径：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The arguments in this command are similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp>
    argument you used earlier to mount a volume with the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp>
    command. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp> argument
    (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp>) is followed
    by the colon-separated list <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">/Volumes/datasets</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:/datasets:ro</samp> containing three
    parts: the absolute path to the folder on the host operating system (on my computer,
    this is */Volumes/datasets*), the absolute path to the folder in the container
    (*/datasets*), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ro</samp>
    option. Short for “read-only,” <samp class="SANS_TheSansMonoCd_W5Regular_11">ro</samp>
    gives the container permission to access the files in the bind mount but not to
    change any of them or create new files.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令中的参数类似于你之前使用的<samp class="SANS_TheSansMonoCd_W5Regular_11">--mount</samp>参数，它用于通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> 命令挂载一个卷。<samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>
    参数（<samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp> 的缩写）后面跟着一个以冒号分隔的列表
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">/Volumes/datasets</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">:/datasets:ro</samp>，它包含三部分：主机操作系统中文件夹的绝对路径（在我的计算机上是*/Volumes/datasets*），容器中文件夹的绝对路径（*/datasets*），以及
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ro</samp> 选项。<samp class="SANS_TheSansMonoCd_W5Regular_11">ro</samp>
    是“只读”的缩写，它允许容器访问绑定挂载中的文件，但不允许更改文件或创建新文件。
- en: 'When you run this command, make sure to use the correct path for your USB disk.
    In macOS, the path is */Volumes/datasets* or similar; in Linux, it’s */media/micah/datasets*
    or similar; and in Windows with WSL, it’s */mnt/d* or similar. If you’re using
    Windows with PowerShell, mount the *D:* drive into the container at the path */datasets*
    with this command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时，请确保使用正确的 USB 磁盘路径。在 macOS 中，路径是*/Volumes/datasets*或类似路径；在 Linux 中，路径是*/media/micah/datasets*或类似路径；在使用
    WSL 的 Windows 中，路径是*/mnt/d*或类似路径。如果你在 Windows 中使用 PowerShell，请使用以下命令将 *D:* 驱动器挂载到容器中的路径*/datasets*：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Altogether, this command runs a new <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>
    container and executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp>
    command inside of it. Your *datasets* folder on your host operating system becomes
    accessible as the folder */datasets* in the container, and it’s mounted in read-only
    mode, preventing the container from modifying anything on the USB disk.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个命令运行了一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">shell</samp>
    容器，并在其中执行了 <samp class="SANS_TheSansMonoCd_W5Regular_11">bash</samp> 命令。你主机操作系统中的
    *datasets* 文件夹变成了容器中的 */datasets* 文件夹，并且以只读模式挂载，防止容器修改 USB 磁盘上的任何内容。
- en: Now that you have access to your datasets within the Aleph shell, you’ll index
    the *icefishx* data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经可以在 Aleph shell 中访问到你的数据集，你将开始对 *icefishx* 数据进行索引。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Index the icefishx
    Folder</samp>
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">索引 icefishx 文件夹</samp>
- en: To index a dataset, you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> command. Aleph’s use of the term *crawl* means to open the folder
    and index each file in it, then open each subfolder it finds and index each file
    in that, and so on, until everything in the original folder has been indexed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要索引一个数据集，你需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp>
    命令。Aleph 中使用的 *crawl* 术语意味着打开文件夹并索引其中的每个文件，然后打开它找到的每个子文件夹，并索引其中的每个文件，依此类推，直到原始文件夹中的所有内容都被索引。
- en: 'Run the following command to start indexing the *icefishx* folder:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以开始索引 *icefishx* 文件夹：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command tells Aleph to index data in the */datasets/BlueLeaks-extracted/icefishx*
    folder in the container (which is actually */Volumes/datasets/BlueLeaks-extracted/icefishx*
    on my host operating system). The <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>
    option (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--language</samp>)
    helps you use OCR on documents. Because different languages use different alphabets
    and words, using <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> tells
    the OCR software what language you’re dealing with—in this case, English (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">eng</samp>).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉 Aleph 在容器中的*/datasets/BlueLeaks-extracted/icefishx* 文件夹中索引数据（这个文件夹在我的主机操作系统中实际上是*/Volumes/datasets/BlueLeaks-extracted/icefishx*）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-l</samp> 选项（<samp class="SANS_TheSansMonoCd_W5Regular_11">--language</samp>的缩写）帮助你在文档上使用OCR。因为不同语言使用不同的字母表和单词，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-l</samp>告诉OCR软件你正在处理的语言——在这个例子中是英语（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">eng</samp>）。
- en: Aleph should begin to work its way through each of the 19,992 files in the *icefishx*
    folder, totaling over 2GB. The output should display the filename of each file,
    which is added to a list of files to crawl. Even before the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> command finishes, Aleph begins to index each file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph应该开始处理*icefishx*文件夹中的每个19,992个文件，总大小超过2GB。输出应该显示每个文件的文件名，这些文件将被添加到待爬取的文件列表中。即使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp>命令还没有完成，Aleph也会开始对每个文件进行索引。
- en: Switch to your other terminal window running Docker Compose and watch the output
    as it indexes and performs OCR on each file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到运行Docker Compose的另一个终端窗口，观察它在索引并对每个文件进行OCR时的输出。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*You can use OCR for documents in languages other than English, too. To index
    a Russian dataset, for example, you’d use -<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">l
    rus</samp> so that Aleph recognizes Russian words in the Cyrillic alphabet. Under
    the hood, Aleph uses software called Tesseract to do the OCR; for a list of valid
    language codes in Tesseract’s documentation, see* [https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html](https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html)*.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以对非英语的文档使用OCR。例如，要索引一个俄语数据集，你可以使用-<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">l
    rus</samp>，这样Aleph就能识别俄语中的西里尔字母。实际上，Aleph使用名为Tesseract的软件来进行OCR；有关Tesseract文档中有效语言代码的列表，请参见*
    [https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html](https://tesseract-ocr.github.io/tessdoc/Data-Files-in-different-versions.html)*.*'
- en: The *icefishx* folder took about an hour and a half to index on my Mac. It also
    used about 17GB worth of Docker volumes. Indexing larger quantities of data could
    take days and require much more disk space.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*icefishx* 文件夹在我的Mac上大约花了一个半小时来进行索引。它还使用了大约17GB的Docker卷。索引更多的数据可能需要几天时间，并且需要更多的磁盘空间。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Check Indexing Status</samp>
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查索引状态</samp>
- en: After <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp> has
    finished running, while you’re waiting for the indexing to complete, try a few
    more Aleph commands to query your Aleph server and check the indexing status.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在<samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp>完成运行后，当你等待索引完成时，可以尝试其他Aleph命令来查询你的Aleph服务器并检查索引状态。
- en: 'First, run the following command to see a list of all of the datasets and investigations
    (known together as *collections*) in your Aleph server:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行以下命令来查看Aleph服务器中所有数据集和调查（统称为*集合*）的列表：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Foreign ID</samp> field is
    the unique identifier for each dataset, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp>
    field is the human-readable name for the dataset displayed in the Aleph web application.
    I used the Aleph web interface to create a new investigation called Test Investigation
    before I started indexing *icefishx*, so I have two collections. When you use
    the web interface to make investigations, they get assigned completely random
    foreign IDs. When you use <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> to create them, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Foreign
    ID</samp> is based on the filesystem path that you’re indexing; alternatively,
    you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-f</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">foreign_id</samp> arguments to
    specify your own if you like.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">外部 ID</samp> 字段是每个数据集的唯一标识符，而
    <samp class="SANS_TheSansMonoCd_W5Regular_11">标签</samp> 字段是 Aleph 网页应用中显示的数据集的人类可读名称。在我开始索引
    *icefishx* 之前，我使用 Aleph 网页界面创建了一个名为 Test Investigation 的新调查，因此我有两个集合。当你使用网页界面创建调查时，它们会被分配完全随机的外部
    ID。当你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp> 创建它们时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">外部 ID</samp> 是基于你正在索引的文件系统路径；或者，你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-f</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">foreign_id</samp>
    参数来指定你自己的 ID。
- en: 'Next, run the following command while indexing *icefishx* to check the status
    of the indexing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在索引 *icefishx* 时运行以下命令以检查索引状态：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This command displays a table of data that tells you the number of pending,
    running, and finished tasks for each collection that’s indexing, split into <samp
    class="SANS_TheSansMonoCd_W5Regular_11">analyze</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">ingest</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp> phases. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Collection</samp> column shows the ID
    of the collection—if you look back at the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    collections</samp>, the ID of the ICEFISHX dataset is <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>.
    When I ran <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph status</samp>,
    based on the total pending and finished numbers, indexing was roughly 15 percent
    complete (though this might be misleading; for example, one of those pending files
    could be a ZIP file containing another 1,000 files).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示一个数据表，告诉你每个正在索引的集合的待处理、运行和已完成任务的数量，并将它们分为 <samp class="SANS_TheSansMonoCd_W5Regular_11">分析</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">摄取</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">索引</samp>
    阶段。<samp class="SANS_TheSansMonoCd_W5Regular_11">集合</samp> 列显示集合的ID——如果你回顾一下 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">aleph collections</samp> 的输出，ICEFISHX
    数据集的 ID 是 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。当我运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    status</samp> 时，根据待处理和已完成的总数，索引大约完成了 15%（尽管这可能会产生误导；例如，其中一个待处理的文件可能是一个 ZIP 文件，包含了另外
    1,000 个文件）。
- en: If Aleph breaks in the middle of indexing a dataset, you can recover your progress.
    If you’re seeing a lot of error messages in the Docker Compose logs or in the
    Aleph web interface, the simplest solution is to restart the containers. In your
    Docker Compose terminal window, you’d press CTRL-C to quit all of the containers
    and then run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose up</samp>
    to start them again. After a few minutes, your containers should finish booting
    and the indexing should commence where it left off. If something failed before
    your <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp> command
    finished running in the Aleph shell, you can run <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> again. This will reindex the entire dataset, but it should be
    quicker the second time around, because it won’t redo time-consuming tasks like
    performing OCR on documents that have already been processed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Aleph 在索引数据集的过程中出现故障，你可以恢复进度。如果你在 Docker Compose 日志或 Aleph 网页界面中看到很多错误信息，最简单的解决方案是重启容器。在你的
    Docker Compose 终端窗口中，按下 CTRL-C 退出所有容器，然后运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">docker-compose
    up</samp> 重新启动它们。几分钟后，你的容器应该完成启动，索引将从中断的地方继续。如果在运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp> 命令时出现故障，你可以再次运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph
    crawldir</samp>。这将重新索引整个数据集，但第二次会更快，因为它不会重新执行一些耗时的任务，比如对已经处理过的文档执行 OCR。
- en: You can also check the indexing status via the Aleph web interface. In your
    browser, navigate to the Investigations page. From there, click the ICEFISHX investigation,
    and you should see a progress bar showing you how the indexing is doing. [Figure
    5-4](#fig5-4) shows the indexing status from inside the web application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过 Aleph 网页界面查看索引状态。在浏览器中，导航到“调查”页面。从那里，点击 ICEFISHX 调查，你应该能看到一个进度条，显示索引进度。[图
    5-4](#fig5-4) 显示了在网页应用程序内部的索引状态。
- en: '![A screenshot of Aleph showing that the ICEFISHX dataset is 29% finished indexing.](Images/Figure5-4.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Aleph 截图，显示 ICEFISHX 数据集已完成 29% 的索引。](Images/Figure5-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The ICEFISHX dataset
    in the process of indexing</samp>'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-4：ICEFISHX 数据集在索引过程中的状态</samp>
- en: 'While you’re here, click the gear icon in the top-right corner of the screen
    and go to **Settings**. From there you can change the label, category, and summary
    of this dataset. For example, you can change the label from *icefishx* to something
    more descriptive, like *BlueLeaks: Intelligence Communications Enterprise for
    Information Sharing and Exchange (ICEFISHX)*. The default category is Investigations.
    If you change it to anything else, like Leaks, Court Archives, or Other Material,
    ICEFISHX will appear under Datasets instead of Investigations. For now, stick
    with the Investigations category.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，点击屏幕右上角的齿轮图标，进入 **设置**。在此你可以更改此数据集的标签、类别和摘要。例如，你可以将标签从 *icefishx* 更改为更具描述性的名称，如
    *BlueLeaks: Intelligence Communications Enterprise for Information Sharing and
    Exchange (ICEFISHX)*。默认类别是“调查”。如果你将其更改为其他类别，如“泄露”，“法院档案”或“其他材料”，则 ICEFISHX 会出现在“数据集”下，而不是“调查”下。现在，保持“调查”类别不变。'
- en: Sit back and wait for Aleph to finish indexing the ICEFISHX dataset before moving
    on to the next section, where you’ll begin to use Aleph to explore the data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 休息一下，等待 Aleph 完成对 ICEFISHX 数据集的索引，然后继续下一部分，在那里你将开始使用 Aleph 探索数据。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*It’s possible to start looking through datasets in Aleph before indexing is
    complete, but it’s best to wait for the full index to finish before digging too
    deep. If you don’t, you’ll search only the data that’s been indexed to that point,
    so your searches might miss important documents.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*在索引完成之前，你也可以开始浏览 Aleph 中的数据集，但最好等待完整的索引完成后再深入探索。如果你不这样做，你将只搜索到已经完成索引的数据，因此你的搜索可能会错过重要文档。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Explore BlueLeaks with Aleph</samp>
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 Aleph 探索 BlueLeaks</samp>
- en: Once you’ve finished indexing the *icefishx* folder, navigate to the ICEFISHX
    dataset you’ve just imported in the Aleph web interface. It should be listed under
    the Investigations link at the top of the page. The Documents link in the left
    sidebar lets you manually browse the files in the dataset and open various documents,
    but where Aleph really shines is its search engine.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成对 *icefishx* 文件夹的索引，导航到你刚刚在 Aleph 网页界面中导入的 ICEFISHX 数据集。它应列在页面顶部的“调查”链接下。左侧边栏中的“文档”链接让你手动浏览数据集中的文件并打开各种文档，但
    Aleph 的真正优势在于其搜索引擎。
- en: 'When you enter a term in the search field, Aleph searches every dataset you’ve
    imported. You can filter your results in a variety of ways, using the left sidebar:
    for example, you can filter to a specific dataset, a specific date range, or even
    to documents that mention specific email addresses, phone numbers, or names. Once
    you’ve filtered the search results, you can click on documents to preview them.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在搜索框中输入一个术语时，Aleph 会搜索你导入的每一个数据集。你可以通过多种方式在左侧边栏中筛选搜索结果：例如，你可以筛选到某个特定的数据集、特定的日期范围，甚至是提到特定电子邮件地址、电话号码或姓名的文档。筛选结果后，你可以点击文档进行预览。
- en: '[Figure 5-5](#fig5-5) shows some of the 335 search results for the term *George
    Floyd* in the ICEFISHX dataset.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-5](#fig5-5) 显示了在 ICEFISHX 数据集中搜索术语 *George Floyd* 时的 335 条搜索结果中的一部分。'
- en: '![A screenshot of Aleph search results, with a document selected that’s titled
    “Possibility for Increased Threatening Activity towards Law Enforcement and Government
    Officials Following Worldwide Coverage of Minneapolis In-Custody Death.”](Images/Figure5-5.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Aleph 搜索结果截图，选中了标题为“在全球报道明尼阿波利斯拘押死亡事件后，针对执法人员和政府官员的威胁活动可能增加”的文档。](Images/Figure5-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: Aleph’s search
    interface with results returned for the term</samp> <samp class="SANS_Futura_Std_Book_11">George
    Floyd</samp>'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-5：Aleph的搜索界面，显示针对关键词</samp>
    <samp class="SANS_Futura_Std_Book_11">George Floyd</samp>的搜索结果
- en: The document selected in [Figure 5-5](#fig5-5), classified as U//LES (Unclassified,
    Law Enforcement Sensitive), was created by the Minnesota Fusion Center on May
    27, 2020\. It warns of an increase in threatening activity toward law enforcement
    officers in response to George Floyd’s murder in police custody two days earlier.
    According to the document, two of the four officers involved had been doxed, and
    people protested outside one of their homes. Thousands of people began marching
    in the streets, and there were “increased discussions on White Supremacist Extremist
    (WSE) online forums.” The document recommends that police “avoid wearing organizationally-affiliated
    clothing outside of work settings,” “reduce social media footprint and use an
    alias,” and consider “varying travel patterns to avoid surveillance.”
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-5](#fig5-5)中选择的文档，分类为U//LES（未分类、执法敏感），由明尼苏达融合中心于2020年5月27日创建。该文档警告称，由于乔治·弗洛伊德在警方拘留中被杀害，针对执法人员的威胁活动有所增加。根据该文档，四名涉事警察中的两人已被公开个人信息，且有人在其中一人的住所外抗议。成千上万的人开始在街头游行，并且在“白人至上主义极端主义者（WSE）在线论坛”上出现了“更多讨论”。文档建议警察“避免在工作场所以外穿戴带有组织标识的衣物”，“减少社交媒体足迹并使用化名”，并考虑“改变旅行模式以避免被监视”。'
- en: Aleph makes it easy to find connections between documents. If you click Expand
    in the top left of the selected document, you should end up at that document’s
    detail page. This page shows the document’s metadata on the left, as well as any
    names or email addresses it finds that are also mentioned in other documents.
    If you click on one of those—for example, on someone’s name or email—you should
    be taken to search results that list all of the documents mentioning that person.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph使查找文档之间的联系变得容易。如果你点击所选文档左上角的“展开”按钮，你将进入该文档的详细页面。该页面在左侧显示文档的元数据，并列出其中找到的所有名字或电子邮件地址，这些名字或电子邮件地址也出现在其他文档中。如果你点击其中之一——例如，点击某个人的名字或电子邮件——你将进入搜索结果，列出所有提到该人的文档。
- en: When you’re done exploring *icefishx*, try indexing additional folders in BlueLeaks
    or even the entire *BlueLeaks-extracted* folder.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成*icefishx*的探索后，可以尝试对BlueLeaks中的其他文件夹，甚至整个*BlueLeaks-extracted*文件夹进行索引。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Aleph Features</samp>
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加的Aleph功能</samp>
- en: There’s a lot more to Aleph than what we’ve covered so far. This section will
    introduce a few of the other cool things it can do, which you’ll find useful in
    the future as you continue to analyze hacked and leaked datasets. As you’ve seen,
    Aleph is great at indexing folders full of a wide variety of documents, but it
    also supports importing *structured data*—data that follows a consistent and well-defined
    data model. Entities in Aleph, which I mentioned earlier, are an example of structured
    data. Specifically, Aleph uses a data model called FollowTheMoney, which contains
    types of entities like Person, Company, Organization, or Address. Learn more about
    the FollowTheMoney data model and how to import these entities directly into Aleph
    at [*https://<wbr>followthemoney<wbr>.tech*](https://followthemoney.tech).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph有更多的功能尚未涉及。本节将介绍一些它可以执行的其他酷功能，随着你继续分析被黑客攻击和泄露的数据集，你会发现它们非常有用。正如你所看到的，Aleph非常擅长对装满各种文档的文件夹进行索引，但它也支持导入*结构化数据*——遵循一致且明确定义的数据模型的数据。之前提到的Aleph中的实体就是结构化数据的一个例子。具体来说，Aleph使用一种叫做FollowTheMoney的数据模型，其中包含像“个人”、“公司”、“组织”或“地址”等实体类型。你可以在[*https://<wbr>followthemoney<wbr>.tech*](https://followthemoney.tech)了解更多关于FollowTheMoney数据模型的信息，以及如何将这些实体直接导入到Aleph中。
- en: When you index a dataset in Aleph, it automatically extracts its best guess
    at entities—data like the names of people and companies, and phone numbers and
    addresses—but its guesses are far from perfect. Aleph also allows you to manually
    create and edit entities in more detail. You can add a list of people to an investigation,
    for example, providing not just their names but also their contact information
    and any relationships they have to other entities like their employers. When you’re
    viewing an entity in Aleph’s web interface, it shows you all of the data about
    that entity and links to all of its related entities.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Aleph 中索引一个数据集时，它会自动提取出其最佳猜测的实体——例如人名、公司名、电话号码和地址等数据——但这些猜测远非完美。Aleph 还允许你手动创建和编辑实体的更多细节。例如，你可以向一个调查中添加人员列表，提供他们的姓名、联系方式以及与其他实体（如雇主）的关系。当你在
    Aleph 的网页界面中查看某个实体时，它会显示该实体的所有数据，并链接到所有与该实体相关的实体。
- en: You can also generate entities from data in spreadsheets like CSV or Excel files.
    For example, the ICEFISHX dataset has a spreadsheet called *Registrations.csv*
    that lists the name, rank, agency, home address, email address, phone number,
    supervisor, and other information about all 6,000 people who had accounts on the
    site. From the detail page of this file in the Aleph web interface, you can click
    Generate Entities to define exactly how this data should map to entities, and
    even how these entities should relate to other entities. This could help you build
    an organization chart of who reports to whom, for example.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从电子表格中的数据（如 CSV 或 Excel 文件）生成实体。例如，ICEFISHX 数据集中有一个名为 *Registrations.csv*
    的电子表格，列出了所有 6,000 名在该网站上拥有账户的人员的姓名、职务、机构、家庭地址、电子邮件地址、电话号码、主管及其他信息。在 Aleph 网页界面的该文件详细信息页中，你可以点击“Generate
    Entities”来精确定义这些数据应该如何映射到实体上，甚至如何将这些实体与其他实体关联起来。这可以帮助你构建一个组织结构图，展示谁向谁汇报。
- en: In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp>
    command you used in Exercise 5-5, there are other ways to index data into Aleph.
    First, you can use a different CLI program called <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>,
    which allows you to index data and push it into a remote Aleph server over the
    internet using Aleph’s application programming interface (API), without opening
    an Aleph shell. APIs are designed to allow software, rather than humans, to communicate.
    Every user on an Aleph server (or, if it’s a server with users disabled, the whole
    server) has an API secret access key, a credential that allows software to add
    data to, or otherwise interact with, the Aleph server. You can pass this API key
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp> as an argument
    to index large datasets on an Aleph server that someone else runs. The command
    to install <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp> is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip install alephclient</samp>.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在练习 5-5 中使用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">aleph crawldir</samp>
    命令外，还有其他方法可以将数据索引到 Aleph 中。首先，你可以使用一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>
    的 CLI 程序，它允许你通过 Aleph 的应用程序编程接口（API）将数据索引并推送到远程的 Aleph 服务器，而无需打开 Aleph shell。API
    设计用于让软件之间进行通信，而非人类。每个 Aleph 服务器上的用户（或者，如果服务器禁用了用户功能，则是整个服务器）都有一个 API 秘密访问密钥，这是一个允许软件将数据添加到
    Aleph 服务器或与其交互的凭证。你可以将这个 API 密钥作为参数传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>，用来在其他人运行的
    Aleph 服务器上索引大数据集。安装 <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>
    的命令是 <samp class="SANS_TheSansMonoCd_W5Regular_11">python3 -m pip install alephclient</samp>。
- en: Alternatively, you can create a new investigation directly in the web interface
    by clicking Investigations at the top, then New Investigation. You’ll be prompted
    to give your investigation a title and an optional summary and language. You can
    upload files to your investigation directly from your web browser. This is useful
    if you want to upload a spreadsheet of names and email address and cross-reference
    it with the rest of the data in your Aleph server. For uploading big datasets
    like BlueLeaks, however, using the Aleph shell or <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>
    is easier and less error-prone.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过点击网页界面顶部的“Investigations”，然后选择“New Investigation”直接创建一个新的调查。系统会提示你为调查命名，并可以选择填写摘要和语言。你可以直接通过网页浏览器上传文件到你的调查中。如果你想上传包含姓名和电子邮件地址的电子表格，并将其与
    Aleph 服务器中的其他数据交叉引用，这将非常有用。然而，对于像 BlueLeaks 这样的庞大数据集，使用 Aleph shell 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">alephclient</samp>
    会更简便，且错误率更低。
- en: One of Aleph’s most powerful features is its ability to search multiple datasets
    at once. For example, you could index the BlueLeaks dataset, the Oath Keepers
    dataset you downloaded in [Chapter 4](chapter4.xhtml), and several others to search
    them all for someone’s name, email address, or phone number. Since the BlueLeaks
    dataset is full of PII of law enforcement officers and the Oath Keepers militia
    is known to recruit retired police, you could check if any Oath Keepers members
    or donors are mentioned in BlueLeaks. (I recommend waiting to try this until you
    further explore the Oath Keepers dataset in [Chapter 6](chapter6.xhtml).)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph 最强大的功能之一是能够同时搜索多个数据集。例如，你可以索引 BlueLeaks 数据集、你在[第4章](chapter4.xhtml)中下载的
    Oath Keepers 数据集以及其他几个数据集，一次性搜索它们中的某个人的姓名、电子邮件地址或电话号码。由于 BlueLeaks 数据集中充满了执法人员的个人身份信息（PII），而
    Oath Keepers 以招募退休警察而闻名，你可以检查是否有 Oath Keepers 的成员或捐赠者在 BlueLeaks 中被提到。（我建议你等到在[第6章](chapter6.xhtml)进一步探索
    Oath Keepers 数据集后再尝试此操作。）
- en: Aleph can also cross-reference the entities from one dataset with entities in
    all of the other datasets that have been indexed in a server. Navigating to an
    investigation and clicking Cross-Reference in the left sidebar allows you to compare
    each entity in the investigation with entities in every other dataset or investigation.
    For example, you could upload a spreadsheet of people you’re investigating—say,
    everyone who works at the White House—into an investigation, use the Generate
    Entities feature to convert it into a detailed list of Person entities, and then
    cross-reference this list with all of the other datasets you’ve indexed to see
    if any White House employees show up in them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Aleph 还可以将一个数据集中的实体与服务器中所有其他已索引的数据集中的实体进行交叉引用。导航到某个调查并点击左侧边栏的交叉引用，可以将该调查中的每个实体与其他所有数据集或调查中的实体进行比较。例如，你可以将你正在调查的人员名单——比如所有在白宫工作的人——上传到调查中，使用“生成实体”功能将其转换为详细的人员实体列表，然后将此列表与所有其他已索引的数据集进行交叉引用，查看是否有任何白宫员工出现在其中。
- en: Spend some time experimenting with Aleph and getting to know its features on
    your own. When DDoSecrets publishes a dataset that you’re interested in, try downloading
    it and indexing it in Aleph. Explore searching multiple datasets at once as well
    as using the cross-referencing feature. Aleph’s documentation is available at
    [*https://<wbr>docs<wbr>.aleph<wbr>.occrp<wbr>.org*](https://docs.aleph.occrp.org).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间亲自尝试使用 Aleph，并熟悉它的功能。当 DDoSecrets 发布你感兴趣的数据集时，尝试下载并在 Aleph 中进行索引。探索同时搜索多个数据集以及使用交叉引用功能。Aleph
    的文档可以在[*https://<wbr>docs<wbr>.aleph<wbr>.occrp<wbr>.org*](https://docs.aleph.occrp.org)找到。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dedicated Aleph Servers</samp>
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">专用的 Aleph 服务器</samp>
- en: Running Aleph in containers on your computer works well if you want to search
    just a few small datasets yourself. However, to index a large amount of data (such
    as all of BlueLeaks) that will stretch your laptop’s computational resources,
    or to work with others on the same datasets, consider setting up a dedicated Aleph
    server instead. Full instructions on doing that are outside the scope of this
    book, but this section provides an introduction.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的计算机上以容器方式运行 Aleph，如果你只是想自己搜索几个小数据集是很有效的。然而，要索引大量数据（例如所有的 BlueLeaks 数据集），这将占用你笔记本电脑的大量计算资源，或者如果你想和其他人一起处理相同的数据集，考虑设置一个专用的
    Aleph 服务器。关于如何设置 Aleph 服务器的完整说明超出了本书的范围，但本节提供了一个入门介绍。
- en: In [Chapter 4](chapter4.xhtml), you learned how to create servers in the cloud;
    earlier in this chapter, you learned how to set up your own Aleph server. By combining
    those skills, you should be able to set up Aleph running in Docker containers
    on a cloud server. However, you’ll also need to decide how to secure the server
    and make sure it stays updated. How will you manage its users, and how will you
    restrict access to the server? How will you know and what will you do if someone
    hacks it? To run an Aleph server for your organization, I recommend that you bring
    in a professional system administrator or DevOps engineer to set it up and maintain
    it over time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，你学习了如何在云端创建服务器；在本章的早些时候，你学习了如何设置自己的 Aleph 服务器。通过结合这些技能，你应该能够在云服务器上设置运行在
    Docker 容器中的 Aleph。然而，你还需要决定如何保障服务器的安全并确保它保持更新。你将如何管理其用户，如何限制对服务器的访问？如果有人入侵服务器，你将如何知晓并采取行动？如果要为你的组织运行
    Aleph 服务器，我建议你请一位专业的系统管理员或 DevOps 工程师来设置并长期维护它。
- en: As you set up your server, consider the security levels of the datasets on which
    you plan to use Aleph. For low- to medium-security datasets, you can host Aleph
    in a cloud server, which allows you to temporarily give your server more RAM or
    processing power to index a dataset more quickly. For medium- to high-security
    datasets, host Aleph on physical hardware, like a server in an office or in a
    server closet in a data center. Decide whether to require people to come into
    the office to use Aleph or to configure it so that they can access it over the
    internet. If you choose the latter, you’ll need to secure your Aleph server and
    the data it contains. For the highest-security datasets, you’ll have to download
    Linux containers on a computer with internet access, export the datasets, and
    import them on an air-gapped server.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置你的服务器时，考虑你计划使用Aleph的数据集的安全级别。对于低到中等安全的数据集，你可以将Aleph托管在云服务器上，这样可以暂时增加更多内存或处理能力，以便更快速地索引数据集。对于中到高安全的数据集，应将Aleph托管在物理硬件上，比如办公室中的服务器或数据中心的服务器机房中。你需要决定是否要求人们到办公室使用Aleph，还是配置使其可以通过互联网访问。如果选择后者，你需要确保Aleph服务器和其中的数据安全。对于最高安全的数据集，你将需要在一台有互联网连接的计算机上下载Linux容器，导出数据集，并将其导入到隔离的服务器上。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter, you’ve learned how to run software in Linux containers using
    Docker, then applied those skills to run Aleph on your computer and index the
    *icefishx* folder from BlueLeaks, making it searchable. A search for the keyword
    *George Floyd* uncovered interesting law enforcement documents about the 2020
    racial justice protests that you couldn’t have uncovered with just <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>.
    You’ve also learned about some Aleph features you can explore on your own, the
    possibility of running a dedicated Aleph server instead of running it on your
    laptop, and dataset-indexing tools other than Aleph.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你已经学会了如何使用Docker在Linux容器中运行软件，并将这些技能应用于在你的电脑上运行Aleph，并对来自BlueLeaks的*icefishx*文件夹进行索引，使其变得可搜索。对关键词*George
    Floyd*的搜索揭示了有关2020年种族正义抗议活动的有趣执法文件，这是通过仅使用<samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>无法找到的。你还了解了Aleph的一些功能，未来可以自行探索，了解到除了在笔记本电脑上运行Aleph，还可以运行独立的Aleph服务器，以及其他数据集索引工具。
- en: 'You’ll revisit Docker in [Chapter 10](chapter10.xhtml), when you learn to use
    BlueLeaks Explorer, and in [Chapter 12](chapter12.xhtml), when you learn about
    SQL databases. In the following chapter, you’ll learn the tools and techniques
    required to dig through one of the most prevalent forms of data leaks: email dumps.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第10章](chapter10.xhtml)中重新学习Docker，当时你将学习如何使用BlueLeaks Explorer；在[第12章](chapter12.xhtml)中，你将学习SQL数据库。接下来的章节中，你将学习挖掘数据泄露的常用工具和技术，尤其是邮件泄露。
